(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":3}],3:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],4:[function(require,module,exports){
//Main module code
var NashJS = require('./lib/engine').Frontend;

//Stock-games
NashJS.StockGames = require('./stock-games');


module.exports = NashJS;

},{"./lib/engine":6,"./stock-games":69}],5:[function(require,module,exports){
({
	Player,
	_Player,
	gamePopulation,
	Population,
	PlayerList,
	registerStrategy,
	Strategies,
	strategyLoader,
	_expose,
	registry,
	Variable,
	Expression,
	RandomVariable,
	ComplexVariable,
	History,
	Queries,
	excludedPlayers,
	startREPL,
	nhistory,
	Information,
	PerfectInformation,
	PluginManager
} = require("../index"));
({
	Choice,
	Turn,
	Sequence,
	Consecutive,
	Loop,
	StochasticLoop,
	HaltIf,
	StochasticHalt,
	Lambda,
	RandomPlayerChoice,
	PopulationDynamics,
	Simultaneous
} = require("../index").Playables);
StockGames = require("../index").StockGames;



p1 = Player();
p2 = Player();
p3 = Player();
ipd = StockGames["Iterated Prisoner's Dilemma"]([p1, p2], 20)
/*
StockGames["Prisoner's Dilemma"]([p1, p2])

p1.assign("chooseFirst")
p2.assign("randomize");

p3 = Player();
p3.assign("chooseSecond");
p4 = Player();
p4.assign("randomize")

c1 = Choice(p1, ["cooperate", "defect"]);
//c1['left'](5) ;
//c1['right'](2);
c2 = Choice(p2, ["Cooperate", "Defect"]);
//c2['up'](1);
//c2['down'](7);

t2 = Turn([c1, c2]);
t3 = Turn([c1, c2]);
t4 = Turn([c1, c2]);
t5 = Turn([c1, c2]);
s1 = Simultaneous([t2, t3, t4, t5])

c = Consecutive([
	Turn([c1, c2]),
	Turn([c2, c1]),
	Choice(p1, ["cooperate", "defect"]),
	Lambda(function() { console.log("hi") }),
	HaltIf(function() { return true })
])

c3 = RandomPlayerChoice(["cooperate", "defect"]);
c4 = RandomPlayerChoice(["Cooperate", "Defect"]);

t1 = Turn([c3, c4]);

v1 = new Variable(3);

t1.defect.Defect([2, 2]);
t1.defect.Cooperate([4, 1]);
t1.cooperate.Defect([1, 4]);
t1.cooperate.Cooperate([v1, v1]);

L1 = Lambda(function() {
	v1.set(v1 + 1);
});

pd1 = PopulationDynamics(1.5, 1);

h2 = HaltIf(function() {
	return Population().onlyAlive().length == 0;
});

L1(t1);
pd1(L1);
h2(pd1);

//s1 = Sequence(t1, h2);

//l1 = Loop(s1, 10, { logContinue: true });

//console.log(_expose(t1).next)
//console.log(_expose(t1).next.cooperate.Cooperate)

h2 = HaltIf(function() {
	return Population().onlyAlive().length == 0;
});

L2 = Lambda(function() {
	p1.kill();
});

t2(L2);

generatePopulation = function() {
	for (i = 0; i < 30; i++) {
		Player({ assign: "chooseFirst" });
	}
	for (i = 0; i < 30; i++) {
		Player({ assign: "chooseSecond" });
	}
};

function gameGenerator() {
	var t = Turn([
		RandomPlayerChoice(["cooperate", "defect"]),
		RandomPlayerChoice(["Cooperate", "Defect"])
	]);

	t.defect.Defect([2, 2]);
	t.defect.Cooperate([4, 1]);
	t.cooperate.Defect([1, 4]);
	t.cooperate.Cooperate([3, 3]);

	return t;
}
//
//
//

//CE = StockGames["Cultural Evolution"](gameGenerator, 1, {generatePopulation});

//n = StockGames["Two-Player Normal"](p1,p2,[["left","right"],["up","down"]]);
//pd1 = StockGames["Prisoner's Dilemma"]([p1, p2]);
//pd2 = StockGames["Prisoner's Dilemma"]([p3, p4]);

//s = Simultaneous([pd1, pd2])

v2 = Variable(1);

//n = StockGames["Simple Zero-Sum"](p1,p2,[["left","right"],["up","down"]], [[v2,2],[3,4]]);

//rpc = StockGames["Rock-Paper-Scissors"]([p1, p2]);
//t = StockGames["Axelrod Tournament"];
//t = StockGames["Iterated Prisoner's Dilemma"]([p1, p2]);
//The code below is to run the repl for testing purposes.
//var toRepl = {_expose, registry,Player,Choice,Turn,Sequence,Loop,StochasticLoop,HaltIf, StochasticHalt, Lambda, p1,c1,c2,t1};
//startREPL(toRepl);
*/

},{"../index":4}],6:[function(require,module,exports){
"use strict";

// Start plug-in manager
var PluginManager = require("./plugin-manager")
PluginManager.start(function() {})


//Logging
var log = require("./logger");
log.setLevel("info");
log("info", "Starting NashJS");


//Game state controllers
var { registry, idCounters } = require('./state');


// Query language and shortcuts
var { Queries, Query, QueryResult, evaluateQuery, registerQueryObject } = require("./query");


// History
var { gameHistory, userGameHistory, History, UserHistory } = require('./history');


//Players
var { _Player, Player } = require('./player');
registry._addType_("players");
idCounters._addType_("player");


//Population
var { gamePopulation, Population, PlayerList, UserPlayerList } = require('./population');


//Information mechanics
var { Information, PerfectInformation } = require("./information");


//Playables
var { playableClasses, playableInterfaces } = require('./playables/')
for (var _class in playableClasses) {
	registry._addType_(playableClasses[_class].registryName);
	idCounters._addType_(playableClasses[_class].counterName);
}

//Symbolic Logic
var {
	variablePrototype,
	Variable,
	expressionPrototype,
	Expression,
	RandomVariable,
	ComplexVariable
} = require("./logic");


//Strategies
registry._addType_("strategies");
idCounters._addType_("strategy");

var { registerStrategy, registerStrategyObject, Strategies } = require('./strategy');
var { loadStrategy, loadStrategyFolder } = require('./strategy-loader');


// Helper function loader
var HelperFunctions = require('./helper-functions');


//THIS FUNCTION IS ONLY FOR DEBUGGING. REMOVE IT FROM MODULE EXPORTS WHEN PUBLISHING
function Expose(interfacePlayable) {
	return registry.playables[interfacePlayable.id()];
}


function startREPL(toREPL) {
	var repl = require("repl");

	var replServer = repl.start({
		prompt: "Nash >> "
	});

	Object.assign(replServer.context, toREPL);
}



var Engine = {
	Frontend: {
		Player,
		_Player, //REMOVE THIS LINE WHEN PUBLISHING
		gamePopulation, //REMOVE THIS LINE WHEN PUBLISHING
		'PlayerList': UserPlayerList,
		Population,
		//Information, //REMOVE THIS LINE WHEN PUBLISHING
		//PerfectInformation, //REMOVE THIS LINE WHEN PUBLISHING
		'Playables': playableInterfaces,
		registerStrategy,
		registerStrategyObject,
		Strategies,
		loadStrategy,
		loadStrategyFolder,
		History: userGameHistory,
		Queries,
		//Expose, //REMOVE THIS LINE WHEN PUBLISHING
		//registry, //REMOVE THIS LINE WHEN PUBLISHING
		startREPL, //Should this line be removed when publishing?
		Variable,
		Expression,
		RandomVariable,
		ComplexVariable,
		//PluginManager //REMOVE THIS LINE WHEN PUBLISHING
	},

	Backend: {
		logger: log,
		State: { registry, idCounters, gameHistory, gamePopulation, PerfectInformation },
		Classes: {
			Player: _Player,
			History,
			UserHistory,
			PlayerList,
			UserPlayerList,
			Information,
			PlayableClasses: { playableClasses },
			Query,
			QueryResult,
			variablePrototype,
			expressionPrototype
		},
		HelperFunctions,
		PluginManager,
		registerQueryObject,
		Expose
	}
}

module.exports = Engine;

},{"./helper-functions":8,"./history":16,"./information":17,"./logger":18,"./logic":19,"./playables/":23,"./player":34,"./plugin-manager":36,"./population":40,"./query":41,"./state":42,"./strategy":44,"./strategy-loader":43,"repl":1}],7:[function(require,module,exports){
var general = {
	//Check if variable is an Object
	isObject(a) {
		return !!a && a.constructor === Object;
	},

	//What do you think?
	isFunction(a) {
		return typeof a === "function";
	},

	//Provide a function, a context ('this'), and an argument array.
	//Returns a function that can be called.
	applyBind(func, that, argArray) {
		return func.bind.apply(func, [that].concat(argArray));
	},

	//Wraps a function to ensure it only gets called one time.
	once(fn, context) {
		var result;

		return function() {
			if (fn) {
				result = fn.apply(context || this, arguments);
				fn = null;
			}

			return result;
		};
	},

	// Randomly re-order array
	shuffle(array) {
		var currentIndex = array.length,
			temporaryValue,
			randomIndex;

		// While there remain elements to shuffle...
		while (0 !== currentIndex) {
			// Pick a remaining element...
			randomIndex = Math.floor(Math.random() * currentIndex);
			currentIndex -= 1;

			// And swap it with the current element.
			temporaryValue = array[currentIndex];
			array[currentIndex] = array[randomIndex];
			array[randomIndex] = temporaryValue;
		}

		return array;
	}
};

module.exports = general;

},{}],8:[function(require,module,exports){
"use strict";

var log = require("../logger");

log("debug", "helperFunctions-index: Loading helper functions loader.");

/*
var general  = require('./general');
var player   = require('./player');
var playable = require('./playable');
var turn 	 = require('./turn');
var state 	 = require('./state'); 
*/

function loader(file) {
	return require("./" + file + ".js");
}

module.exports = loader;
//module.exports = {general, player, playable, turn, state};

// Hack to compile Glob files (in browserify). Don´t call this function!
(function() {
	require('./general.js');require('./index.js');require('./logic.js');require('./playable.js');require('./player.js');require('./state.js');require('./stock-games.js');require('./tournament.js');require('./turn.js');
});

},{"../logger":18,"./general.js":7,"./index.js":8,"./logic.js":9,"./playable.js":10,"./player.js":11,"./state.js":12,"./stock-games.js":13,"./tournament.js":14,"./turn.js":15}],9:[function(require,module,exports){
"use strict";

var logic = {

	// Check to see if object is Variable/Expression or not. Returns true/false
	isLogic(logic) {

		if (logic instanceof Function && logic == logic * 1) return true
		else return false;
	}
};

module.exports = logic;

},{}],10:[function(require,module,exports){
"use strict";

var { SynchronousPromise } = require('synchronous-promise');

//Game state controllers
var { registry } = require('../state');

var playable = {
	// Generates the function that gets returned when a Playable is called, which can then be called to chain playables together.
	chainerGenerator(externalObj, internalObj) {
		externalObj = this;
		return function(source) {
			var previousPlayable, path;

			//TODO: verify that source is the right type

			return SynchronousPromise.all([function() {
				if (source instanceof Promise || source instanceof SynchronousPromise) {
					source.then(function(result) {
						previousPlayable = registry.playables[result.playable.id()];
						path = result.path
						return SynchronousPromise.resolve();
					});
				}
				return SynchronousPromise.resolve()
			}(), function() {
				if (!(source instanceof Promise || source instanceof SynchronousPromise)) {
					previousPlayable = registry.playables[source.id()];
					path = source.path;
				}
				return SynchronousPromise.resolve();
			}()]).then(function(result) {

				if (path == "all") previousPlayable.addNext(internalObj);
				else {

					outcomeTreeGetValue(previousPlayable.next, path).push(internalObj);
				}

				//previousPlayable.next[selected].push(_choice);

				return SynchronousPromise.resolve({
					'playable': externalObj,
					path: "all"
				});
			});
		};
	},


	//Use to set every value of an outcome tree
	outcomeTreeAddAll(tree, value) {

		//If it's an array, then we're already done.
		if (Array.isArray(tree)) {
			tree.push(value); //Use push here because this will be a unique array
		} else {
			var recurse = function(obj, val) {

				for (var keys in obj) {

					//If no keys left to traverse, then assign value. If not, recurse.
					if (Array.isArray(obj[keys])) {
						obj[keys] = obj[keys].slice().concat(val); //Use slice-concat here because this might not be a unique array (the creation process duplicates them)
					} else recurse(obj[keys], val);

				}
			};
			recurse(tree, value);
		}
	},


	//Traverse an outcome tree to obtain the value for a desired key-set
	//Argument one is a nested object, while argument 2 is an array of keys for the object, 1 layer at a time.
	outcomeTreeGetValue(tree, selector) {

		//Find the next item in the chain associated with the resultant outcome
		for (var i = 0, len = selector.length; i < len; i++) {
			tree = tree[selector[i]];
		}

		return tree;
	},


	//Traverse an outcome tree to set the value for a desired key-set
	//Argument one is a nested object, while argument 2 is an array of keys for the object, 1 layer at a time.
	outcomeTreeSetValue(tree, selector, value) {

		//Find the next item in the chain associated with the resultant outcome
		for (var i = 0, len = selector.length - 1; i < len; i++) {
			tree = tree[selector[i]];
		}

		return tree[selector[i]] = value;
	}
}



module.exports = playable;

},{"../state":42,"synchronous-promise":62}],11:[function(require,module,exports){
"use strict";

//  Game state
var { registry } = require("../state");

// helper function
var { isFunction } = require("./general");

// Player claass
var { _Player } = require("../player");

// Population
var { gamePopulation } = require("../population")

// Plugins
var PluginManager = require("../plugin-manager/")

var player = {

	//reset all players. Recreate from class, re-assign strategy, loop through objects that reference player to set new reference. result argument is only for pass-through.
	reinitializePlayers(population = "all", result = null) {
		return Promise.resolve().then(function() {
			var oldPlayer, strategy, strategyArgs, parameters;

			// if no population is supplied, fetch everybody
			if (population === "all") population = Object.keys(registry.players)
			else(population = population.ids())

			//Redefine each player
			for (var i = 0; i < population.length; i++) {
				var player = population[i];

				oldPlayer = registry.players[player];
				strategy = oldPlayer.strategy ? oldPlayer.strategy._id : null;
				strategyArgs = strategy ? oldPlayer.strategy._args : [];
				parameters = {}; //TODO: when adding player parameters, be sure they're included here

				registry.players[player] = new _Player(oldPlayer.id, parameters);
				registry.players[player].interface = oldPlayer.interface;
				strategy && registry.players[player].assign(strategy, ...strategyArgs);

				// Plugin, to alter players in re-initialization
				PluginManager.run("player-reinitialize", registry.players[player]);
			}

			//For each choice, recreate player references
			for (var choice in registry.choices) {
				if (registry.choices[choice].player)
					registry.choices[choice].player = registry.players[registry.choices[choice].player.id];
			}

			return Promise.resolve(result);
		});
	}
};

module.exports = player;

},{"../player":34,"../plugin-manager/":36,"../population":40,"../state":42,"./general":7}],12:[function(require,module,exports){
"use strict";

var log = require('../logger');

// State variables
var {idCounters, registry} = require('../state');

var state = {
	
	//Handle ID setting for all objects that get stored in the registry
	idHandler: function idHandler(id, type, recursing=false){
		//Assign id
		
		idCounters[type]++;
		var counter = idCounters[type];
		
		if (!id) {
			return type + counter.toString();
		}
		else {
			
			// Check that id isn't taken. If it is, construct a new one.
			
			//Construct list of all objects by extracting all registry entries
			var items = []
			Object.keys(registry).forEach(function(reg){items.push.apply(items, Object.keys(registry[reg]))})
			
			// if id is already taken, generate a new one by adding a number at the end.
			if (items.indexOf(id) > -1) {
				
				var match, oldNum, exp, newId;
				var oldId = id;
				
				do {
					// This finds a number at the end, and increments it, or starts with 1 if there wasn't one.
					match = /\d+$/.exec(id);
					oldNum = match ? match[0] : "";
					exp = new RegExp(oldNum + "$");
					id = id.replace(exp, Number(oldNum) + 1)
				
				}	
				while (items.indexOf(id) >-1)
				
				// Log warning
				log("warn", "ID " + oldId + " is taken. Using instead " + id);
			}
			
			return id
		}
	}
};

module.exports = state;
},{"../logger":18,"../state":42}],13:[function(require,module,exports){
"use strict";

// Strategy registration
var { registerStrategyObject } = require("../engine").Frontend;

// Helper functions
var { isFunction, once } = require("./general");

//External dependency
var esprima = require("esprima");


// For handling queries
var { registry } = require("../engine").Backend.State
var { registerQueryObject } = require("../engine").Backend
var { idHandler } = require("./state")



var stockGames = {
	// utility function to create two ways to call a game, either with all the arguments, or curried, where the returned function takes players and parameters
	// The combineParameters setting will
	gameWrapper(game, {
		argumentValidator = function() { return true; },
		combineParameters = true,
		gameDescription = "No description given.",
		strategyLoader = null,
		queries = null
	} = {}) {

		var generate;

		// If there's a strategy loader, make sure it only runs once
		var loadStrategies
		if (isFunction(strategyLoader)) loadStrategies = once(function() {
			return registerStrategyObject(strategyLoader());
		});
		else loadStrategies = function() {}

		// If there's a query loader, make sure it only runs once
		var loadQueries
		if (queries) loadQueries = once(function() {
			return registerQueryObject(queries);
		});
		else loadQueries = function() {}

		// run the game. Optionally, validate the arguments and load strageies first
		generate = function(...args) {
			var result = argumentValidator(...args)
			if (result === true) {
				loadStrategies();
				loadQueries();
				return game(...args);
			} else throw new Error(result);
		}

		// creates a wrapper around the game, which accepts the first argument (players) and last argument (parameters), and passes it forward.
		// If combineParameters is set to true, then the second argument of the returned function will get merged with the last argument
		// given when generator is called.
		generate.createGenerator = function(...args) {

			var gameCode = esprima.parseScript("(" + game.toString() + ")")

			var gameArgs = gameCode.body[0].expression.params
			var lastArg = gameArgs[gameArgs.length - 1]

			var originalParameters
			if ((lastArg.name && lastArg.name.toLowerCase() === "parameters") || lastArg.type === "ObjectPattern" ||
				(lastArg.type == "AssignmentPattern" && lastArg.left.type == "ObjectPattern")) {
				// Check that the game arguments and createGenerator arguments are the correct lengths. createGenerator should be
				// 1 less than game, because players is omitted.
				// TODO: use esprima to allow players to be anywhere in the game definition (or even omitted) rather than first
				if (args.length == gameArgs.length - 1) originalParameters = args.pop();
			}


			return function(players, parameters = {}) {

				// If combining parameters, merge and remove from arguments
				if (combineParameters && originalParameters) parameters = Object.assign({}, originalParameters,
					parameters)

				return generate(players, ...args, parameters)
			}
		}

		// Allow for game description feature
		generate.description = function() {
			return gameDescription;
		};

		// Display any queries
		generate.queries = function() {
			return queries;
		}

		return generate;
	}


}

module.exports = stockGames;

},{"../engine":6,"./general":7,"./state":12,"esprima":51}],14:[function(require,module,exports){
"use strict";

// Strategies
var { Strategies } = require("../strategy");

// Players
var { Player } = require("../player");

module.exports = {
	// Create a player for each available strategy
	generatePopulation() {
		var players = [];

		Strategies().forEach(function(strategy) {
			players.push(Player({ assign: strategy }));
		});

		return players;
	}
};

},{"../player":34,"../strategy":44}],15:[function(require,module,exports){
"use strict";

var {SynchronousPromise} = require('synchronous-promise');

var turn = {
	
	//Recurse through the options in input, and write val to output. 
	recurse : function recurse(input, output, val, valGenerator=function(){}, path=[]){
		return SynchronousPromise.resolve(path).then(function(path){
			
			//Since we slice the array each time, if there are no more entries left then we're done with this branch.
			if (input.length == 0) return SynchronousPromise.resolve(path)
			
			
			//Among all values from the array
			return SynchronousPromise.all(input[0].map(function(item){
				var value;
				var splitPath = path.slice(0).concat(item);
				
				//If there are more items to iterate over, include them in the output then recurse.
				//If not, put in the new value.
				if (input.length == 1) {
					
					//If val is a function, wrap it in a function that will get supplied an argument with where we are				
					if (typeof val == "function") {
						value = function(){	
							var args = [splitPath].concat(Array.prototype.slice.call(arguments));
							return val.apply(null, args);
						};
					}
					else value = val || valGenerator(splitPath);
					
					output[item] = value;
				}
				else output[item] = {};
				
				
				return recurse(input.slice(1),output[item], val, valGenerator, splitPath);
			}));		
		});
	}
};


module.exports = turn;
},{"synchronous-promise":62}],16:[function(require,module,exports){
"use strict";

var { evaluateQuery } = require("./query")

var { registry } = require("./state")

var { isObject, isFunction } = require("./helper-functions")("general");

//Extension of array to handle history lists.
function History(...args) {
	if (Array.isArray(args[0])) args = args[0];

	Object.setPrototypeOf(args, History.prototype);

	args.log = args.slice();
	args.log.tree = args;
	Object.setPrototypeOf(args.log, History.prototype);

	args.scores = [];
	args.scores.tree = args;
	Object.setPrototypeOf(args.scores, History.prototype);

	return args;
}

History.prototype = Object.create(Array.prototype);
History.prototype.constructor = History;

//To add entry
History.prototype.add = function(entry) {
	//Add to history and to log
	this.push(entry);
	if (this.log) this.log.push(entry);

	//Cycle up the parent tree, add to each log
	var check = this;
	if (check.tree instanceof History && check.tree.parent instanceof History) {
		check.tree.parent.log.add(entry);
	}
	if (check.parent instanceof History) {
		check.parent.log.add(entry);
	}

	//If we're being called fr

	return this;
};

//To add entry without logging (for playables that would like the tree history
//to be structured differently than the log history.
History.prototype.addNoLog = function(entry) {
	this.push(entry);
	return this;
};


History.prototype.addScores = function(entry) {
	//Add to history
	this.scores.push(entry);

	//Cycle up the parent tree, add to each log
	var check = this;
	if (check.parent instanceof History) {
		check.parent.addScores(entry);
	}



	return this;
};


//A temporary History that can be merged back in later. The child and parent are linked until .orphan() is called.
History.prototype.child = function(parent = this) {
	var h = new History();
	h.parent = parent;
	return h;
};

//Same as .child except includes prior parent history when .print() is called.
History.prototype.childWithContent = function(parent = this) {
	var storedLog = parent.slice();
	var storedScores = parent.slice();

	var h = new History();


	h.log.print = function() {
		History.prototype.print.call(storedLog.concat(h.log))
	}
	h.scores.print = function() {
		History.prototype.print.call(storedScores.concat(h.scores))
	}

	h.parent = parent;
	return h;
};

//This severs the link between the temporary history and its parent. Use this when merging composite entries.
History.prototype.orphan = function() {
	delete this.parent;
	delete this.log;
	delete this.scores;
	return this;
};

//Clear history
History.prototype.clearHistory = function() {
	this.splice(0, this.length);
	if (this.log) this.log.splice(0, this.log.length);
	if (this.scores) this.scores.splice(0, this.scores.length);
	delete this.parent;
};

//End the game.
History.prototype.end = function() {
	this.stop = true;
	if (this.parent) this.parent.end();
};

//Get a particular sort of entry, eg. Turn.
History.prototype.getType = function(type) {
	return new History(
		this.filter(function(entry) {
			//If it's not an object, don't even bother.
			if (!isObject(entry)) return false;

			for (var key in entry) {
				if (key == type) return true;
			}

			return false;
		})
	);
};

History.prototype.mostRecent = function() {
	return this[this.length - 1]
}

//Help read the history in Chrome with less clutter.
History.prototype.print = function() {
	var history = JSON.parse(JSON.stringify(this));
	history.query = History.prototype.query
	return history;
};

History.prototype.query = function(queryString, ...args) {
	return evaluateQuery(queryString, this, ...args)
}

//Supply an entry, it will check for a property that is a History
History.prototype.recurse = function(type) {
	var list = this;

	return new History(
		list.map(function(entry) {
			for (var key in entry) {
				console.log(key, entry);
				if (entry[key] instanceof History) return entry[key].recurse(type);
				else if (key == type) return entry;
			}
			return null;
		})
	);
};

//Accept a History and return one suitable for the user
function UserHistory(history) {
	var userHistory = history.map(function(entry) {
		return JSON.parse(JSON.stringify(entry));
	});
	if (history.log) {
		userHistory.log = new UserHistory(history.log)
	};
	if (history.scores) {
		userHistory.scores = new UserHistory(history.scores)
	}

	Object.setPrototypeOf(userHistory, UserHistory.prototype);

	//Attach methods from History, wrapped in a function. If those methods return a history,
	//then the function will convert that to a userHistory.
	for (var method in History.prototype) {
		if (isFunction(history[method])) {
			if (method != "constructor")
				userHistory[method] = (function(method) {
					return function() {
						var result = history[method].apply(history, arguments);
						if (result instanceof History) return new UserHistory(result);
						else if (isObject(result))
							return JSON.parse(JSON.stringify(result));
						else return result;
					};
				})(method);
		}
	}

	return userHistory;
}

UserHistory.prototype = Object.create(History.prototype);
UserHistory.prototype.constructor = UserHistory;

var gameHistory = new History(); //TODO: add choice-only history

var userGameHistory = function() {
	return new UserHistory(gameHistory)
}

module.exports = { History, UserHistory, gameHistory, userGameHistory };

},{"./helper-functions":8,"./query":41,"./state":42}],17:[function(require,module,exports){
"use strict";

//When a strategy's .choose() function is called, it is given an information set. That data is a limited map of the internal objects of the game engine, including information on the game history and the players. This is threaded through playables, much like History, so that a parent playable can specify an information set for the playables it calls, or else the default construction will be used. Additionally, the user can provide a filter function, to selectively delete (or add) information elements before they are passed to .choose().

//History functions
var { gameHistory, History } = require('./history');

//Population functions
var { gamePopulation, PlayerList } = require('./population');


function Information(history = gameHistory, population = gamePopulation, { parentHistory = [] } = {}) {
	this.history = history;
	this.population = population;

	// Record any history entries that need to be added to the records
	this.parentHistory = parentHistory.slice(0);

	this.additional = [];

	this.update();
};

//Check the source then cache a hard-copy.
Information.prototype.update = function(player, local) {
	this.infoPopulation = this.population().info();

	this.infoHistory = { log: this.parentHistory.concat(this.history.log).slice(0), scores: this.history.scores
			.slice(0) };

	this.additional = [];

	//Return value. Mimics .deliver()
	var information = {
		history: { log: this.infoHistory.log, scores: this.infoHistory.scores },
		population: this
			.infoPopulation
	}
	if (player) information.me = information.population.get(player.id);
	if (local) Object.assign(information, local);

	return information;
};

//Clone the cached copies and provide them. Will deliver the same thing every time until update is called.
Information.prototype.deliver = function(player, local) {
	var information = {
		history: { log: this.infoHistory.log, scores: this.infoHistory.scores },
		population: this
			.infoPopulation
	}


	if (player) information.me = information.population.get(player.id);
	if (local) Object.assign(information, local);
	if (this.additional) this.additional.forEach(function(entry) { Object.assign(information, entry) });

	return JSON.parse(JSON.stringify(information));
};

//This probably doesn't need to be a separate function, but adding it in case it expands later.
Information.prototype.addAdditional = function(entry = null) {
	if (entry) this.additional.push(entry);
};

//Make copy of this information function, which allows for updating and freezing.
Information.prototype.child = function() {
	var information = new Information(this.history, this.population, { parentHistory: this.parentHistory });

	return information;
};



//Game state, analogous to gameHistory
var PerfectInformation = new Information(gameHistory, gamePopulation);

//Overwrite .deliver(). PerfectInformation is always up-to-date! Thus no need to do a 2nd JSON.stringify.
PerfectInformation.deliver = function(player, local) {

	var information = this.update(player, local);

	if (player) information.me = information.population.get(player.id);
	if (local) Object.assign(information, local);

	return information;
};


module.exports = { Information, PerfectInformation };

},{"./history":16,"./population":40}],18:[function(require,module,exports){
"use strict";


var logger = function() {
	var args = [...arguments];
	var level = (args[0] == "silly" || !args[0]) ? "trace" : args[0];
	var level = level == "warning" ? "warn" : level;
	args.shift();

	logger.logger[level].apply(logger.logger, args);
};

//logger.logger = console;					//TODO clean this all up a lot.

var getLogger = require("loglevel-colored-level-prefix");
var options = { prefix: 'nashJS', level: 'trace' }
logger.logger = getLogger(options)

logger.setLevel = function(level) {
	logger.logger.level = level;
	logger.logger.setLevel(level)
};

/*
logger.useWinston = function(){

	var winston = require('winston');
	var util = require('util');

	winston.level = "warn";

	winston.clear()
	winston.add(winston.transports.Console, {
		level: 'trace',
		prettyPrint:  function ( object ){
			return util.inspect(object);
		},
		colorize: true,
		silent: false,
		timestamp: false
	});

	this.logger = winston;
};
*/

module.exports = logger;

},{"loglevel-colored-level-prefix":56}],19:[function(require,module,exports){
"use strict";

var log = require("./logger");

//Helper functions
var { isFunction } = require("./helper-functions")("general");

// Extend function, the sneaky way.
var variablePrototype = Object.create(Function.prototype);

variablePrototype.constructor = function(value, { enforceNumber = true } = {}) {
	var variable = this;
	variable.value = enforceNumber ? value * 1 : value;
	variable.enforceNumber = enforceNumber

	this.id = function() {
		return _playable.id;
	}; //TODO: work on ids and registration
};

variablePrototype.call = function() {
	return this.value;
};

variablePrototype.toJSON = function() {
	return this.call();
};
variablePrototype.toString = function() {
	return this.call();
};
variablePrototype.valueOf = function() {
	return this.call();
};

variablePrototype.set = function(newValue) {
	this.value = this.enforceNumber ? newValue * 1 : newValue
	return this.value;
};

//Repurpose the very-similar code for Variable, but re-write certain keys
var expressionPrototype = Object.create(Function.prototype);

expressionPrototype.constructor = function(expression) {
	if (!isFunction(expression)) log("error", "Expression must be a function.");

	var value = expression();
	if (isNaN(value)) log("error", "Expression must return a number"); //TODO: should Expressions/Variables allow strings?

	this.value = expression;

	return value;
};

expressionPrototype.call = function() {
	return this.value() * 1;
};

expressionPrototype.toJSON = function() {
	return this.call();
};
expressionPrototype.toString = function() {
	return this.call();
};
expressionPrototype.valueOf = function() {
	return this.call();
};

expressionPrototype.set = function(newExpression) {
	if (!isFunction(newExpression))
		log("error", "Expression must be a function.");

	var value = newExpression();
	this.value = newExpression;

	return value;
};

//Produces the function that will produce the end result. This part is reusable if you need to do this again.
var classFactory = function(proto) {
	return function() {
		var f = function() {
			return f.call.apply(f, arguments);
		};

		Object.defineProperty(f, "constructor", {
			configurable: true,
			writable: true
		});
		Object.defineProperty(f, "call", {
			writable: true
		});
		Object.defineProperty(f, "toString", {
			writable: true
		});
		Object.defineProperty(f, "valueOf", {
			writable: true
		});

		Object.keys(proto).forEach(function(key) {
			f[key] = proto[key];
		});

		f.constructor.apply(f, arguments);

		return f;
	};
};

var Variable = classFactory(variablePrototype);
var Expression = classFactory(expressionPrototype);
// called as: var instance = Variable();

// A pre-built Expression generator, for generating random numbers
var RandomVariable = function({ lowerbound = 0, upperbound = 10, generator = "uniform" }) {

	if (isFunction(generator)) {
		var expression = Expression(generator);
		expression.generator = generator;
		return expression;

	} else if (generator.toLowerCase() == "uniform") {
		generator = function() {
			return Math.floor(Math.random() * (upperbound - lowerbound + 1) + lowerbound);
		};
		//	TODO: add more distributions here.
	}

	return Expression(generator);
};



// A way to have Variables which are more complicated things, like arrays or obects
var ComplexVariable = function(value) {
	var variable = Variable(value, { enforceNumber: false })

	var excludeList = ["set", "call", "toJSON", "toString", "valueOf"]

	var handler = {
		get(target, key) {
			var prop;
			if (excludeList.indexOf(key) > -1) prop = target[key].bind(target);
			else {
				prop = target.value[key]
				if (isFunction(prop)) prop = prop.bind(target.value)
			}

			return prop
		},
		set(target, key, prop) {
			target.value[key] = prop;
			return true;
		}
	}
	return new Proxy(variable, handler)
}




module.exports = {
	variablePrototype,
	Variable,
	expressionPrototype,
	Expression,
	RandomVariable,
	ComplexVariable
};

},{"./helper-functions":8,"./logger":18}],20:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Choice");

// External dependency
var { SynchronousPromise } = require("synchronous-promise");

//Game state controllers
var { registry } = require("../state");
var { gameHistory } = require("../history");
var { PerfectInformation } = require("../information");

//Helper functions
var { idHandler } = require("../helper-functions")("state");
var { isFunction } = require("../helper-functions")("general");
var { chainerGenerator } = require("../helper-functions")("playable");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Choice
function _Choice(id, player, options, parameters = {}) {
	_Playable.call(this, id);

	this.next = {};

	this.player = registry.players[player];
	this.options = options;
	this.defaultOption = parameters.defaultOption || options[0]; //TODO: make defaultOption functional
	this.informationFilter = parameters.informationFilter || null;
	this.usePayoffs = parameters.usePayoffs || false;

	registry.choices[id] = this;

	var choice = this;
	this.options.forEach(function(item) {
		choice.next[item] = [];
	});
}

_Choice.prototype = Object.create(_Playable.prototype);
_Choice.prototype.constructor = _Choice;

_Choice.registryName = "choices";
_Choice.counterName = "choice";

_Choice.prototype.play = function({
	usePayoffs = this.usePayoffs,
	history = gameHistory,
	information: rawInformation = PerfectInformation,
	releasePlayer = true,
	informationFilter = this.informationFilter,
	_compileInformation = null
} = {}) {
	var choice = this;

	if (!choice.player.alive)
		return Promise.reject({
			result: choice.id + ": Player " + choice.player.id + " is dead."
		});

	//While this choice is happening, don't allow other choices to use this player.
	choice.player.available = false;

	//Information mechanics. If we're dealing with PerfectInformation, this won't get delivered, so we'll include it in the call to .deliver(). If we're using an information supplied from some other playable, then they can do what they like with it.
	var choiceInfo = {
		choice: {
			id: choice.id,
			player: choice.player.id,
			options: choice.options
		}
	};
	rawInformation.addAdditional(choiceInfo);
	//Perform some data processing if other playables need it.
	if (_compileInformation) _compileInformation(rawInformation);

	return Promise.resolve()
		.then(function() {
			//Prep information
			var information = rawInformation.deliver(choice.player, choiceInfo);
			if (informationFilter) information = informationFilter(information);

			return choice.player.choose(choice.options.slice(0), information);
		})
		.then(function(result) {
			var player = choice.player;
			var id = choice.id;

			//Add to player's individual history;
			player.history.push({
				choice: id,
				options: choice.options,
				result
			});

			result = result || choice.defaultOption;

			var resultObject = {
				result,
				historyEntry: {
					choice: id,
					player: player.id,
					result
				}
			};

			//This will probably only happen if it's a single-player game, otherwise we'll use playoffs defined in a Turn
			if (usePayoffs) {
				var payout = choice.payoffs[result];

				player.score += payout;

				//track the payoff
				var scoreEntry = {
					choice: id,
					payouts: {
						[player.id]: Number(payout)
					}
				};

				history.addScores(scoreEntry);
				resultObject.historyEntry.payouts = {
					[player.id]: payout
				};
			}

			log(
				"silly",
				"_Choice.play: removing from occupiedPlayers: ",
				choice.player.id
			);
			if (releasePlayer) choice.releasePlayer();

			return Promise.resolve(resultObject); //TODO: add information mechanisms
		});
};

//Release player from excluded players list, so that other objects can use it.
_Choice.prototype.releasePlayer = function() {
	this.player.available = true;
};

_Choice.prototype.findNext = function({ result } = {}) {
	return this.next[result.result];
};

_Choice.prototype.generateChainingFunctions = function(choice) {
	var _choice = this;

	_choice.options.forEach(function(option) {
		_choice.payoffs[option] = 0; //Start payoffs at zero

		choice[option] = function(payoff) {
			//Create functions for user to assign payoffs
			if (!isNaN(payoff)) _choice.payoffs[option] = payoff;
			return SynchronousPromise.resolve({
				playable: choice,
				path: [option]
			});
		};
	});
};

_Choice.prototype.summaryThis = function(summary) {
	summary.player = this.player.id;
	summary.options = this.options.slice();

	return summary;
};

//TODO: un-fuck this.
_Choice.prototype.summaryNext = function(
	summary,
	entries = {},
	shortCircuit = false,
	maxEntries = 10
) {
	// Copy over the choice options
	summary.next = Object.assign({}, this.next);

	// Loop through them and summarize at each step.
	var count = 0;
	for (var key in summary.next) {
		summary.next[key] = summary.next[key].map(function(playable) {
			count++;
			return playable.summarize({}, entries);
		});
	}

	// If there weren't any next steps, delete the next key, to reduce clutter.
	if (count == 0) delete summary.next;

	return summary;
};

//Set all payoffs to zero.
_Choice.prototype.zeroPayoffs = function() {
	var choice = this;

	choice.payoffs = {};

	choice.options.forEach(function(option) {
		choice.payoffs[option] = 0;
	});
};

function Choice(player, options, parameters = {}) {
	var id = idHandler(parameters.id, "choice");

	//If informationFilter was supplied, it must be a function
	if (parameters.informationFilter && !isFunction(parameters.informationFilter))
		throw new Error("informationFilter must be a function");

	//Create backend choice object
	var _choice = new _Choice(id, player.id(), options, parameters);

	//Return this reference object to the user. Run the function to select a source
	var choice = Playable(_choice);

	//Interface to specify single-player payoffs in single-player/single-choice games
	_choice.zeroPayoffs();

	_choice.generateChainingFunctions(choice);

	/*
	options.forEach(function(option){
		_choice.payoffs[option] = 0;			//Start payoffs at zero

		choice[option] = function(payoff){					//Create functions for user to assign payoffs
			if (!isNaN(payoff))_choice.payoffs[option] = payoff;
			return Promise.resolve({
				playable:choice,
				path:[option]
			})
		};
	});
	*/

	//Function to set all payoffs at once
	choice.setAllPayoffs = function(payoffs) {
		if (!Array.isArray(payoffs)) throw new Error("Payoffs must be array")
		if (payoffs.length != registry.choices[id].options.length) throw new Error(
			"Payoffs must be same dimensions as choice options")

		payoffs.forEach(function(payoff, index) {
			registry.choices[id].payoffs[options[index]] = payoff;
		})
		//TODO: make this work. Include error handling if array given isn't expected dimensions.
	};

	//Way for user to interact with payoffs
	choice.payoffs = function() {
		return registry.choices[id].payoffs;
	};

	return choice;
}

module.exports = { _Choice, Choice };

},{"../helper-functions":8,"../history":16,"../information":17,"../logger":18,"../state":42,"./playable":26,"synchronous-promise":62}],21:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Consecutive");

//Game state controllers
var { registry } = require("../state");
var { gameHistory } = require("../history");

//Helper functions
var { idHandler } = require("../helper-functions")("state");

//Information
var { Information, PerfectInformation } = require("../information");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Consecutive
function _Consecutive(id, playablesArray, parameters = {}) {
	_Playable.call(this, id, parameters);

	playablesArray = playablesArray.map(function(playable) {
		return registry.playables[playable.id()]
	})
	this.playablesArray = playablesArray

	registry.consecutives[id] = this;
}
_Consecutive.prototype = Object.create(_Playable.prototype);
_Consecutive.prototype.constructor = _Consecutive;

_Consecutive.registryName = "consecutives";
_Consecutive.counterName = "consecutive";

_Consecutive.prototype.play = function({
	history = gameHistory,
	information = this.information ||
	PerfectInformation
} = {}) {

	var consecutive = this;

	//Log the history appropriately
	var startEntry = {
		consecutive: consecutive.id,
		action: "start"
	};
	history.log.add(startEntry);

	//History object to give to consecutived playables.
	var consecutiveHistory = history.child();

	//compartmentalize if set. "compartmentalize" means pass on information as if this playable is the entire game.
	if (consecutive.compartmentalize) {
		information = new Information(consecutive.compartmentalize.history || consecutiveHistory,
			consecutive.compartmentalize.population || information.population);
	}

	var action = function action(playablesArray) {
		//Stop if the game is over.
		if (history.stop) return { playable: consecutive };

		if (playablesArray.length > 0) {
			return playablesArray.shift().play({ shortCircuit: true, history: consecutiveHistory, information })
				.then(function(result) {
					return action(playablesArray) || result
				})
		} else return false
	}

	return action(consecutive.playablesArray.slice())
		.then(function(result) {
			result.historyEntry = {
				consecutive: consecutive.id,
				action: consecutiveHistory.orphan()
			};

			//TODO: add information mechanisms

			return Promise.resolve(result);
		});
};

//Overwrite history handler so that tree doesn't have "start" and "finish" entries.
_Consecutive.prototype.handleHistory = function({ history = gameHistory } = {},
	result
) {
	var consecutive = this;

	return Promise.resolve(result).then(function(result) {
		history.log.add({
			consecutive: consecutive.id,
			action: "finish",
			duration: result.historyEntry.duration
		});

		history.addNoLog(result.historyEntry);
		return Promise.resolve(result);
	});
};

//TODO: finish this!
_Consecutive.prototype.summaryThis = function(summary, entries, shortCircuit) {
	summary.action = {};

	this.playableStart.summarize(
		summary.action,
		entries,
		(shortCircuit = this.playableFinish)
	);
};

function Consecutive(playablesArray, parameters = {}) {
	var id = idHandler(parameters.id, "consecutive");

	//Create backend loop object
	var _consecutive = new _Consecutive(id, playablesArray, parameters);

	//Return this reference object to the user. Run the function to select a source
	var consecutive = Playable(_consecutive);

	consecutive.ids = function() {
		return playablesArray.map(function(playable) {
			return playable.id();
		})
	}

	return consecutive;
}

module.exports = { _Consecutive, Consecutive };

},{"../helper-functions":8,"../history":16,"../information":17,"../logger":18,"../state":42,"./playable":26}],22:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: HaltIf")

//Game state controllers
var {registry} = require('../state');
var {gameHistory} = require('../history');

//Helper functions
var {isFunction}	= require('../helper-functions')("general");
var {idHandler} 	= require('../helper-functions')("state");

//Parent class
var {_Playable, Playable} = require('./playable');



//Backend function class for Game
function _Halt(id,testCondition, {logContinue = false}){
	_Playable.call(this,id);
	
	this.testCondition = testCondition;
	this.logContinue = logContinue;
	
	registry.halts[id] = this;
}

_Halt.prototype = Object.create(_Playable.prototype);
_Halt.prototype.constructor = _Halt;

_Halt.registryName = "halts";
_Halt.counterName = "haltIf";

_Halt.prototype.play = function({initializePlayers=false, shortCircuit=false, history=gameHistory}={}){
	
	var halt = this;
	
	var resultObject = {
		'playable':halt,
		'historyEntry':{
			'halt':halt.id
		}
	};
	
	
	var test = halt.testCondition();
	
	
	if (test) {
		log("info", "Halting at " + halt.id)
		
		resultObject.historyEntry.action = "halt";
		resultObject.result = "Halt";
	
		return Promise.reject(resultObject);
	}
	
	//Halt probably gets used for loops, and we might not want to see lots of continue messages, so "logContinue" will omit them.
	if (halt.logContinue) {
		resultObject.historyEntry.action = "continue";
	}
	else delete resultObject.historyEntry
	
	
	return Promise.resolve(resultObject)
};


_Halt.prototype.summaryThis = function(summary){
	summary.condition = this.testCondition.toString();
}



function HaltIf(testCondition=function(){}, {id=null, logContinue=false}={}){
	var id = idHandler(id,"haltIf")
	
	if (!isFunction(testCondition)) log("warn",id + ": testCondition should be a function, or else game will not halt.")

	//Create backend loop object
	var _halt = new _Halt(id, testCondition, {logContinue});
	
	
	//Return this reference object to the user. Run the function to select a source
	var halt = Playable(_halt);	
	return halt;	
}


module.exports = {_Halt, HaltIf};
},{"../helper-functions":8,"../history":16,"../logger":18,"../state":42,"./playable":26}],23:[function(require,module,exports){
"use strict";

//Loads the playables that will be used by Nash. This is basically the controller list: if it's not in these lists,
// then it won't be available for us.

//External dependency
var present = require("present");

var log = require("../logger");

var { applyBind } = require("../helper-functions")("general");

log("debug", "Loading Playable Classes: ");

//Playables
var { _Playable } = require("./playable");
var { _Choice, Choice } = require("./choice");
var { _Turn, Turn } = require("./turn");
var { _Sequence, Sequence } = require("./sequence");
var { _Consecutive, Consecutive } = require("./consecutive");
var { _Loop, Loop } = require("./loop");
var { _SLoop, StochasticLoop } = require("./stochasticLoop");
var { _Halt, HaltIf } = require("./halt-if");
var { _SHalt, StochasticHalt } = require("./stochastic-halt");
var { _Lambda, Lambda } = require("./lambda");
var { _RPChoice, RandomPlayerChoice } = require("./random-player-choice");
var { _PopulationDynamics, PopulationDynamics } = require("./population-dynamics");
var { _Simultaneous, Simultaneous } = require("./simultaneous");

//Runs when loading Playable classes.
function initializePlayableClass(playableClass) {
	//Replace the .play() method with a wrapper which calls it and a few other functions
	if (playableClass.prototype.hasOwnProperty("play")) {
		playableClass.prototype.play = (function(play) {
			return function({ history = gameHistory } = {}) {
				var playable = this;
				var args = [].slice.call(arguments);

				// Set our history
				args[0].history ? null : args[0].history = this.history || gameHistory

				// how to halt the game without errors. TODO this is probably fucked
				if (history.stop) return { playable };


				return _Playable.prototype._startTimer
					.apply(playable, args)
					.then(applyBind(playable.checkInit, playable, args))
					.then(applyBind(playable.prePlay, playable, args))
					.then(applyBind(play, playable, args))
					.then(applyBind(playable.postPlay, playable, args))
					.then(applyBind(_Playable.prototype._stopTimer, playable, args))
					.then(applyBind(playable.handleHistory, playable, args))
					.then(applyBind(_Playable.prototype.proceed, playable, args));
			};
		})(playableClass.prototype.play);
	}
}

exports.playableClasses = {
	_Playable,
	_Choice,
	_Turn,
	_Sequence,
	_Consecutive,
	_Loop,
	_SLoop,
	_Halt,
	_SHalt,
	_Lambda,
	_RPChoice,
	_PopulationDynamics,
	_Simultaneous
};
exports.playableInterfaces = {
	Choice,
	Turn,
	Sequence,
	Consecutive,
	Loop,
	StochasticLoop,
	HaltIf,
	StochasticHalt,
	Lambda,
	RandomPlayerChoice,
	PopulationDynamics,
	Simultaneous
};

for (var playableClass in exports.playableClasses) {
	if (playableClass != "_Playable")
		initializePlayableClass(exports.playableClasses[playableClass]);
}

},{"../helper-functions":8,"../logger":18,"./choice":20,"./consecutive":21,"./halt-if":22,"./lambda":24,"./loop":25,"./playable":26,"./population-dynamics":27,"./random-player-choice":28,"./sequence":29,"./simultaneous":30,"./stochastic-halt":31,"./stochasticLoop":32,"./turn":33,"present":58}],24:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: Lambda")

//Game state controllers
var { registry, gameHistory } = require('../state');

// Information mechanics
var { PerfectInformation } = require("../information");

//Helper functions
var { isFunction } = require('../helper-functions')("general");
var { idHandler } = require('../helper-functions')("state");

//Parent class
var { _Playable, Playable } = require('./playable');



//Backend function class for Game
function _Lambda(id, action, parameters = {}) {
	_Playable.call(this, id);

	this.action = action;

	registry.lambdas[id] = this;
}
_Lambda.prototype = Object.create(_Playable.prototype);
_Lambda.prototype.constructor = _Lambda

_Lambda.registryName = "lambdas";
_Lambda.counterName = "lambda";


_Lambda.prototype.play = function({ initializePlayers = false, shortCircuit = false, history = gameHistory,
	information = PerfectInformation } = {}) {

	var lambda = this;

	var result = lambda.action({ history, information })

	var resultObject = {
		result,
		'playable': lambda,
		historyEntry: {
			lambda: lambda.id,
			result
		}
	};

	return Promise.resolve(resultObject)
};

// Simple helper to just run synchronously whatever the Lambda is. Useful for debugging.
_Lambda.prototype.run = function() {
	return this.action();
}

_Lambda.prototype.summaryThis = function(summary) {
	summary.action = this.action.toString();
}


function Lambda(action = function() {}, parameters = {}) {
	var id = idHandler(parameters.id, "lambda")

	if (!isFunction(action)) log("warn", id + ": action should be a function.")

	//Create backend lambda object
	var _lambda = new _Lambda(id, action, parameters);


	//Return this reference object to the user. Run the function to select a source
	var lambda = Playable(_lambda);


	lambda.run = function() {
		return _lambda.run();
	}

	return lambda;
}


module.exports = { _Lambda, Lambda };

},{"../helper-functions":8,"../information":17,"../logger":18,"../state":42,"./playable":26}],25:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Loop");

//Game state controllers
var { registry } = require("../state");
var { gameHistory, History } = require("../history");

//Helper functions
var { idHandler } = require("../helper-functions")("state");
var { chainerGenerator } = require("../helper-functions")("playable");

// Information mechanics
var { Information, PerfectInformation } = require("../information");
var { gamePopulation } = require("../population");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Loop

function _Loop(id, playable, count, parameters) {
	_Playable.call(this, id, parameters);

	var { logContinue = true, playableParameters = {} } = parameters;

	this.playable = registry.playables[playable.id()];
	this.logContinue = logContinue;
	this.playableParameters = playableParameters;

	this.count = count;

	registry.loops[id] = this;
}
_Loop.prototype = Object.create(_Playable.prototype);
_Loop.prototype.constructor = _Loop;

_Loop.registryName = "loops";
_Loop.counterName = "loop";

_Loop.prototype.play = function({
	history = this.history || gameHistory,
	information = this.information || PerfectInformation,
	playableParameters = this.playableParameters
} = {}) {

	var loop = this;
	loop.counter = 0;

	// Split the history entry
	var loopHistory = history.child();

	// information mechanics.
	//compartmentalize If set
	if (loop.compartmentalize) {
		information = new Information(loop.compartmentalize.history || loopHistory,
			loop.compartmentalize.population || information.population);
	}
	// Pass along
	playableParameters.information = information


	var promise = Promise.resolve();

	var action = function(result) {
		//If the game has been ended early, don't continue.
		if (history.stop) return { playable: loop };

		loop.counter++;
		if (!result) result = {};

		//Deal with history
		history.log.add({
			loop: loop.id,
			loopTo: loop.playable.id,
			count: loop.counter
		});

		playableParameters.shortCircuit = true;
		playableParameters.history = loopHistory;

		return loop.playable.play(playableParameters).then(function(result) {
			//Re-format result, replace playable with Loop playable
			result.playable = loop;

			//TODO: add information mechanisms

			return Promise.resolve(result);
		});
	};

	//Repeat the playable loop.count times, by chaining promises.
	for (var i = 0; i < loop.count; i++) {
		promise = promise.then(action);
	}

	return promise.then(function(result) {
		result.historyEntry = {
			loop: loop.id,
			count: loop.counter,
			action: loopHistory.orphan()
		};
		return Promise.resolve(result);
	});
};

//Overwrite history handler to prevent "loop finished" entry from hitting the tree.
_Loop.prototype.handleHistory = function({
		history = this.history || gameHistory,
		information = this.information || PerfectInformation,
		logContinue = this.logContinue
	} = {},
	result
) {
	var loop = this;

	return Promise.resolve(result).then(function(result) {
		//Write final entry if logContinue is set to true
		if (logContinue) {
			history.log.add({
				loop: loop.id,
				loopTo: "Loop finished.",
				count: loop.counter
			});
		}

		history.addNoLog(result.historyEntry);

		return result;
	});
};

// Add detail/nesting to summary.
_Loop.prototype.summaryThis = function(summary, entries) {
	summary.count = this.count;

	summary.action = {};
	this.playable.summarize(summary.action, entries, true);
};

function Loop(playable, count = 1, parameters = {}) {
	var id = idHandler(parameters.id, "loop");

	//Create backend loop object
	var _loop = new _Loop(id, playable, count, parameters);

	//Return this reference object to the user. Run the function to select a source
	var loop = Playable(_loop);
	return loop;
}

module.exports = { _Loop, Loop };

},{"../helper-functions":8,"../history":16,"../information":17,"../logger":18,"../population":40,"../state":42,"./playable":26}],26:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Playable");

var { SynchronousPromise } = require("synchronous-promise");
var present = require("present");

//Game state controllers
var { registry, idCounters } = require("../state");
var { gameHistory, History } = require("../history");

//Helper functions
var { isFunction } = require("../helper-functions")("general");
var { outcomeTreeAddAll, outcomeTreeGetValue } = require("../helper-functions")("playable");
var { reinitializePlayers } = require("../helper-functions")("player");

//To return to user
var { Population, PlayerList } = require("../population");

//_playable class, superclass for objects which can execute game steps (choice, turn, game)
function _Playable(id, parameters = {}) {
	this.id = id;
	this.next = [];
	registry.playables[id] = this;
	idCounters.playable++;

	parameters.compartmentalize ? this.compartmentalize = parameters.compartmentalize : null;
	parameters.history ? (this.history = parameters.history) : null;
	parameters.information ? (this.information = parameters.information) : null;
	parameters.initializePlayers ? (this.initializePlayers = parameters.initializePlayers) : null;
}

_Playable.registryName = "playables";
_Playable.counterName = "playable";

//Add reference to next playable branch, to chain playables together.
_Playable.prototype.addNext = function(nextPlayable) {
	outcomeTreeAddAll(this.next, nextPlayable);
};

//Called before .play() to start timing.
_Playable.prototype._startTimer = function() {
	this._timer = present();
	return Promise.resolve();
};

//Called before prePlay, initialize players if true.
_Playable.prototype.checkInit = function({ initializePlayers = this.initializePlayers } = {}, result) {
	// if we get something
	if (initializePlayers) {
		// if it's just true, then reinitialize everybody
		if (initializePlayers === true) return reinitializePlayers("all", result)

		// if it's a playerList, use that
		else if (initializePlayers instanceof PlayerList) return reinitializePlayers(initializePlayers)

		// if we get a function, then run the function and check that it's returning a playerList
		else if (isFunction(initializePlayers)) {
			var list = initializePlayers()
			if (list instanceof PlayerList) return reinitializePlayers(list, result);
		}

		// otherwise, convert it to a playerList and let PlayerList deal with it.
		else return reinitializePlayers(new PlayerList(initializePlayers), result);
	}

	// if we didn't get anything or got false, we're done here.
	else return Promise.resolve(result);
};


//Called before .play() but after _startTimer
_Playable.prototype.prePlay = function({} = {}, result) {
	return Promise.resolve(result);
};

//Called after .play(), overwritable.
_Playable.prototype.postPlay = function({} = {}, result) {
	return Promise.resolve(result);
};

//Called after .postPlay() to stop timer and log.
_Playable.prototype._stopTimer = function({} = {}, result) {
	if (result.historyEntry)
		result.historyEntry.duration = present() - this._timer;
	delete this._timer;

	return Promise.resolve(result);
};

//Called after timer stops, to write log. Overwiteable if playable has specific logging behavior.
_Playable.prototype.handleHistory = function({ history = gameHistory } = {},
	result
) {
	return Promise.resolve(result).then(function(result) {
		if (result.historyEntry) history.add(result.historyEntry);
		return Promise.resolve(result);
	});
};

//Determine whether to play next, and if so, do.
_Playable.prototype.proceed = function({ shortCircuit } = {}, result) {
	var playable = this;

	return Promise.resolve(result).then(function(result) {
		//Replace reported playable with latest running playable (this is necessary for short-circuit logic)
		result.playable = playable;

		//Short-circuit logic allows higher-order playable to figure out what to do next.
		if (shortCircuit) return Promise.resolve(result);

		return playable.playNext(result);
	});
};

//Play next.
_Playable.prototype.playNext = function(result, parameters = {}) {
	var playable = this;

	return Promise.resolve(result).then(function(result) {
		//Find out where to go next
		var next = playable.findNext({ result });

		//If there's somewhere to go, then go.
		if (next[0] instanceof _Playable)
			return Promise.all(
				next.map(function(playable) {
					return playable.play(parameters);
				})
			);

		//Otherwise, we're done here
		return Promise.resolve(result);
	});
};

// Return the next playable in the sequence. Overwriteable for playables with more complicated branching.
_Playable.prototype.findNext = function() {
	return this.next;
};

_Playable.prototype._summarize = function() {};

// Summarize the game structure. Calls summaryThis and summaryNext, which are overwritable.
_Playable.prototype.summarize = function(
	summary = {},
	entries = {},
	shortCircuit = false,
	maxEntries = 10
) {
	// Start summary for this playable
	summary[this.constructor.counterName] = this.id;

	// Track how many times we've been here before, to avoid circular recursion
	entries[this.id] ? ++entries[this.id] : (entries[this.id] = 1);
	if (entries[this.id] > maxEntries) shortCircuit = true;

	// Add summary
	this.summaryThis(summary, entries);

	// Proceed to next steps
	if (!shortCircuit || shortCircuit !== this)
		this.summaryNext(summary, entries);

	return summary;
};

// Adds the summary information on this playable. Overwrite this in order to add specific information.
_Playable.prototype.summaryThis = function(summary = {}, entries = {}) {
	return summary;
};

// Adds summary information down the next-path. Overwite this for playables with more complex branching.
_Playable.prototype.summaryNext = function(summary = {}, entries = {}) {
	// If there's a next-entry
	if (this.next.length > 0) {
		// Loop over each next-item, and summarize it.
		summary.next = this.next.map(function(playable) {
			return playable.summarize({}, entries);
		});

		// If there's only one item, no need for an array.
		if (summary.next.length == 1) summary.next = summary.next[0];
	}
};


//Convoluted code here to produce the object that user interacts with (ie c1 in 'c1 = Choice()')
//This mimics creating a class that inherits from Function. First define the "prototype", which includes
//a "constructor", a "call" method that will get called, and any other properties and methods.
//Then 'classFactory' produces the class/constructing object (see below), which you can use to
//produce the actual objects.

var playablePrototype = Object.create(Function.prototype);

playablePrototype.constructor = function(_playable) {
	var playable = this;

	//Tag-back. Store the front-end object in the back-end object, for retrieval
	_playable.interface = playable;

	this.call = function(source) {
		var previousPlayable, path;

		//TODO: verify that source is the right type

		return SynchronousPromise.all([
			(function() {
				if (source instanceof Promise || source instanceof SynchronousPromise) {
					source.then(function(result) {
						previousPlayable = registry.playables[result.playable.id()];
						path = result.path;
						console.log(path);
						return SynchronousPromise.resolve();
					});
				}
				return SynchronousPromise.resolve();
			})(),
			(function() {
				if (!(source instanceof Promise || source instanceof SynchronousPromise)) {
					previousPlayable = registry.playables[source.id()];
					path = source.path;
				}

				return SynchronousPromise.resolve();
			})()
		]).then(function(result) {
			console.log(path);
			log(
				"debug",
				"Adding next playable to " +
				previousPlayable.id +
				", node " +
				_playable.id
			);

			if (path == "all") previousPlayable.addNext(_playable);
			else {
				outcomeTreeGetValue(previousPlayable.next, path).push(_playable);
			}

			log("silly", previousPlayable.next);
			//previousPlayable.next[selected].push(_choice);

			return SynchronousPromise.resolve({
				playable: playable,
				path: "all"
			});
		});
	};

	this.id = function() {
		return _playable.id;
	};

	this.play = function({
		initializePlayers = false,
		usePayoffs = true,
		shortCircuit = false,
		writeHistory = true,
		clearHistory = true,
		releasePlayers = true
	} = {}) {

		if (clearHistory) gameHistory.clearHistory();

		var history = writeHistory ?
			_playable.history || gameHistory :
			new History();

		return Promise.resolve()
			.then(function(result) {
				return _playable.play({ initializePlayers, usePayoffs, shortCircuit, history, releasePlayers });
			})
			.catch(function(reason) {
				console.log(reason);

				//If the game was stopped by a Halt playable or everybody's dead, we'll end up here, and things are fine. Just log it.
				if (reason.result == "Halt") {
					gameHistory.add(reason.historyEntry);
					return Promise.resolve(reason.result);
				} else if (reason.result == "Population Collapse")
					return Promise.resolve(reason.result);
				else {
					history.log.add({ error: reason });
					return Promise.reject(reason);
				}
			})
			.then(function(result) {
				//Replace result, so that user can't get access to _playables

				return Promise.resolve({
					Population: Population(),
					gameHistory
				});
			});
	};

	this.summarize = function() {
		return _playable.summarize({});
	};
};

playablePrototype.call = function() {
	//This will get overwritten when the "constructor" is called, but leaving it here so you can figure out how the hell this works.
};

playablePrototype.path = "all";

//Produces the function that will produce the end result. This part is reusable if you need to do this again.
var classFactory = function(proto) {
	return function() {
		var f = function() {
			return f.call.apply(f, arguments);
		};

		Object.defineProperty(f, "constructor", {
			configurable: true,
			writable: true
		});
		Object.defineProperty(f, "call", { writable: true });

		Object.keys(proto).forEach(function(key) {
			f[key] = proto[key];
		});

		f.constructor.apply(f, arguments);

		delete f.constructor; //Added this bit here, to prevent the user from trying to create new objects.

		return f;
	};
};

var Playable = classFactory(playablePrototype);
// called as: var instance = Playable(/* some internal object like _choice */);

module.exports = { _Playable, Playable };

},{"../helper-functions":8,"../history":16,"../logger":18,"../population":40,"../state":42,"present":58,"synchronous-promise":62}],27:[function(require,module,exports){
"use strict";

var log = require('../logger');

//External dependency
var poisson = require('randgen').rpoisson;

//Game state controllers
var {registry, gameHistory} = require('../state');

//Helper functions
var {isFunction}	= require('../helper-functions')("general");
var {idHandler} 	= require('../helper-functions')("state");

//Parent class
var {_Playable, Playable} = require('./playable');

//Player controllers
var {_Player, Player} = require('../player');
var {PlayerList, UserPlayerList, gamePopulation, Population} = require('../population');

//Update this each time .play is called, but leave it available to the whole scope so that 
//growth and decay can access it
var population;

//Default growth function
var growthDefault = function growth(player, population, birthRate, selectiveMultiplier) {
	var score = player.score;
	var mean = population.scoresMean();
	var std = population.scoresStd();
	
	var Z = !(isNaN(std) || std==0) ? (score-mean)/std : 0
	
	console.log(score, mean, std,Z);
	
	var rate = birthRate + selectiveMultiplier*Z;

	var generated = poisson(rate);
	log("silly","growthDefault: generated random number " + generated.toString()+ " using rate "+ rate.toString());
	
	return generated;
}

//Default decay function
var decayDefault = function decay(player, population, deathRate, selectiveMultiplier) {
	var score = player.score;
	var mean = population.scoresMean();
	var std = population.scoresStd();
	
	console.log(score, mean, std);
	
	var Z =  !(isNaN(std)||std==0) ? (score-mean)/std : 0;
	
	console.log(Z)
	var rate = deathRate - selectiveMultiplier*Z;
	
	var generated = poisson(rate);
	log("silly","decayDefault: generated random number " + generated.toString()+ " using rate "+ rate.toString());
	return generated;
}



//Backend function class for PopulationDynamics
function _PopulationDynamics(id, birthRate,deathRate, {growthFunction=growthDefault, decayFunction=decayDefault, selectiveMultiplier= .5, playerParameters={}}={}){
	_Playable.call(this,id);
	
	var pd = this;
	
	this.birthRate = birthRate;
	this.deathRate = deathRate;
	this.selectiveMultiplier = selectiveMultiplier;
	
	//Wrap the growth and decay functions, so that the user doesn't have to worry about calling this.birthRate or this.deathRate
	this.growth = function(player){
		log("silly","_pd.growth: Checking grow condition");
		return growthFunction(player, population, pd.birthRate, pd.selectiveMultiplier)
	};
	this.decay = function(player){
		log("silly","_pd.decay: Checking decay condition");
		return decayFunction(player, population, pd.deathRate, pd.selectiveMultiplier);
	};
	
	this.playerParameters = playerParameters;
	
	registry.controllers[id] = this;
}
_PopulationDynamics.prototype = Object.create(_Playable.prototype);
_PopulationDynamics.prototype.constructor = _PopulationDynamics;

_PopulationDynamics.registryName = "controllers";
_PopulationDynamics.counterName = "populationDynamics";


_PopulationDynamics.prototype.play = function({initializePlayers=false, shortCircuit=false, history=gameHistory}={}){
	
	var pd = this;
	
	var births = 0;
	var deaths = 0;
	
	//Update population using whoever's alive currently
	population = gamePopulation().onlyAlive();
		
	
	//Kill cycle
	var killed = new PlayerList([]);
	population.forEach(function(player){
		// If the decay function is returns truthy, kill.
		
		if (pd.decay(player)) {
			log("silly","must kill...")
			player.kill();
			deaths++;
			killed.push(player);
			log("silly","dead");
		}
		
		
	});
	
	//Update update again to prevent the recently deceased from reproducing
	population = gamePopulation().onlyAlive();
	
	if (population.length == 0) {
		//Everybody's dead. Let's wrap it up.
		var reason = {result:"Population Collapse", playable:pd};
		history.end();
		return Promise.resolve(reason);
	}
	
	//Birth cycle
	var born = new UserPlayerList([]);
	population.forEach(function(player){
		//Birth whatever number is returned
		var numBirth = pd.growth(player)
		console.log(numBirth);
		for (var i=1; i<=numBirth; i++){
			log("silly", "Player " + player.id +" giving birth!");
			
			var playerParameters = Object.assign({},{
					assign:player.strategy ? player.strategy._id : "",
					parent:player.id}
				,pd.playerParameters);
			
			born.push(Player(playerParameters));
		}	
	});
	
	
	var result = {births, deaths};
	
	var resultObject = {
		result,
		'playable':pd,
		historyEntry:{
			populationDynamics:pd.id,
			result
		}
	};
	
	return Promise.resolve(resultObject);
};



function PopulationDynamics(birthRate=.05, deathRate = .05, parameters={}){
	var id = idHandler(parameters.id,"populationDynamics")
	
	if (parameters.growth && !isFunction(growth)) log("error",id + ": growth should be a function.");
	if (parameters.decay && !isFunction(decay))   log("error",id + ": decay should be a function.");
		
	//Create backend lambda object
	var _pd = new _PopulationDynamics(id, birthRate, deathRate, parameters);
	
	
	//Return this reference object to the user. Run the function to select a source
	var pd = Playable(_pd);	
	return pd;	
}


module.exports = {_PopulationDynamics, PopulationDynamics};
},{"../helper-functions":8,"../logger":18,"../player":34,"../population":40,"../state":42,"./playable":26,"randgen":59}],28:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: RandomPlayerChoice")

//Game state controllers
var { registry, gameHistory, occupiedPlayers } = require('../state');

//Helper functions
var { idHandler } = require('../helper-functions')("state");
var { chainerGenerator } = require('../helper-functions')("playable");

//Parent class
var { _Playable, Playable } = require('./playable');
var { _Choice, Choice } = require('./choice');

//Population helpers
var { PlayerList } = require('../population');


//Backend function class for RPChoice
function _RPChoice(id, options, parameters = {}) {

	//If they specify players to draw from, use only that list. Otherwise, use whoever's around.
	this.includePlayers = parameters.includePlayers || "all";

	this.excludePlayers = parameters.excludePlayers ? new PlayerList(parameters.excludePlayers) : new PlayerList()

	this.generator = Math.random;

	var player = null;


	_Choice.call(this, id, player, options, parameters);
}

_RPChoice.prototype = Object.create(_Choice.prototype);
_RPChoice.prototype.constructor = _RPChoice;

_RPChoice.registryName = "choices";
_RPChoice.counterName = "randomPlayerChoice";



//Select the player to make the choice
_RPChoice.prototype.choosePlayer = function choosePlayer() {

	var rpChoice = this;

	return Promise.resolve().then(function() {

		//Find players to choose from
		var pool = new PlayerList(rpChoice.includePlayers).onlyAlive().onlyAvailable().exclude(rpChoice.excludePlayers)
		if (pool.length == 0) return Promise.reject("No available players.");

		log("silly", "rpChoice.choosePlayer: choosing froom pool: " + pool.ids());

		var randomNumber = Math.floor(rpChoice.generator() * pool.length);
		var candidate = pool[randomNumber];


		log("silly", "rpChoice.choosePlayer: selecting player ", candidate.id)

		rpChoice.player = candidate;
		candidate.available = false;

		return Promise.resolve(candidate.id);
	});
};

_RPChoice.prototype.prePlay = function() {
	return this.choosePlayer();
};


_RPChoice.prototype.summaryThis = function(summary) {
	summary.options = this.options;
};



function RandomPlayerChoice(options, parameters = {}) {
	var { id = null, excludePlayers = [], playerList = null } = parameters

	var id = idHandler(id, "randomPlayerChoice")

	//Create backend choice object
	var _rpChoice = new _RPChoice(id, options, parameters);

	//Return this reference object to the user. Run the function to select a source
	var rpChoice = Playable(_rpChoice)

	rpChoice.playerList = function(playerList) {
		if (Array.isArray(playerList)) _rpChoice.playerList = playerList;
		return _rpChoice.playerList
	};

	rpChoice.excludePlayers = function(excludePlayers) {
		if (Array.isArray(excludePlayers)) {
			_rpChoice.excludePlayers = [];

			excludePlayers.forEach(function(player) {
				_rpChoice.excludePlayers.push(player.id());
			});

		}
		return _rpChoice.excludePlayers
	};

	//Interface to specify single-player payoffs in single-player/single-choice games
	_rpChoice.zeroPayoffs();

	_rpChoice.generateChainingFunctions(rpChoice);

	//Function to set all payoffs at once
	rpChoice.setAllPayoffs = function(payoffs) {
		//TODO: make this work. Include error handling if array given isn't expected dimensions.
	};


	//Way for user to interact with payoffs
	rpChoice.payoffs = function() { return registry.choices[id].payoffs; };

	return rpChoice;
}



module.exports = { _RPChoice, RandomPlayerChoice };

},{"../helper-functions":8,"../logger":18,"../population":40,"../state":42,"./choice":20,"./playable":26}],29:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Sequence");

//Game state controllers
var { registry } = require("../state");
var { gameHistory } = require("../history");

//Helper functions
var { idHandler } = require("../helper-functions")("state");

//Information
var { Information, PerfectInformation } = require("../information");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Sequence
function _Sequence(id, playableStart, playableFinish, parameters = {}) {
	_Playable.call(this, id, parameters);

	this.playableStart = registry.playables[playableStart.id()];
	this.playableFinish = registry.playables[playableFinish.id()];

	registry.sequences[id] = this;
}
_Sequence.prototype = Object.create(_Playable.prototype);
_Sequence.prototype.constructor = _Sequence;

_Sequence.registryName = "sequences";
_Sequence.counterName = "sequence";

_Sequence.prototype.play = function({
	history = gameHistory,
	information = this.information ||
	PerfectInformation
} = {}) {

	var sequence = this;

	//Log the history appropriately
	var startEntry = {
		sequence: sequence.id,
		action: "start"
	};
	history.log.add(startEntry);

	//History object to give to sequenced playables.
	var sequenceHistory = history.child();

	//compartmentalize if set. "compartmentalize" means pass on information as if this playable is the entire game.
	if (sequence.compartmentalize) {
		information = new Information(sequence.compartmentalize.history || sequenceHistory,
			sequence.compartmentalize.population || information.population);
	}

	// Recursion down the chain of playables
	var action = function action(result) {
		//Stop if the game is over.
		if (history.stop) return { playable: sequence };

		//Otherwise, recurse to figure out what to do next.
		if (Array.isArray(result)) {
			log("silly", "sequence.play: Next-item is an array, splitting into pieces.");

			return Promise.all(
				result.map(function(item) {
					log("silly", "sequence.play: recursing on", item);
					return action(item);
				})
			);
		}

		if (result.playable !== sequence.playableFinish) {
			log("silly", result);

			if (result.playable.findNext({ result }).length > 0) {
				log("silly", "Playable has next-item, continuing down chain.");

				return result.playable.playNext(result, { shortCircuit: true, history: sequenceHistory, information })
					.then(action); //Repeat for next playable in chain
			}
			return Promise.resolve(result);
		}
		return Promise.resolve(result);
	};

	return sequence.playableStart
		.play({ shortCircuit: true, history: sequenceHistory, information })
		.then(action)
		.then(function(result) {
			result.historyEntry = {
				sequence: sequence.id,
				action: sequenceHistory.orphan()
			};

			//TODO: add information mechanisms

			return Promise.resolve(result);
		});
};

//Overwrite history handler so that tree doesn't have "start" and "finish" entries.
_Sequence.prototype.handleHistory = function({ history = gameHistory } = {},
	result
) {
	var sequence = this;

	return Promise.resolve(result).then(function(result) {
		history.log.add({
			sequence: sequence.id,
			action: "finish",
			duration: result.historyEntry.duration
		});

		history.addNoLog(result.historyEntry);
		return Promise.resolve(result);
	});
};

//TODO: finish this!
_Sequence.prototype.summaryThis = function(summary, entries, shortCircuit) {
	summary.action = {};

	this.playableStart.summarize(
		summary.action,
		entries,
		(shortCircuit = this.playableFinish)
	);
};

function Sequence(playableStart, playableFinish, parameters = {}) {
	var id = idHandler(parameters.id, "sequence");

	//Create backend loop object
	var _sequence = new _Sequence(id, playableStart, playableFinish, parameters);

	//Return this reference object to the user. Run the function to select a source
	var sequence = Playable(_sequence);
	return sequence;
}

module.exports = { _Sequence, Sequence };

},{"../helper-functions":8,"../history":16,"../information":17,"../logger":18,"../state":42,"./playable":26}],30:[function(require,module,exports){
"use strict";

var log = require('../logger');

//Helper functions
var { isObject } = require('../helper-functions')("general");
var { idHandler } = require('../helper-functions')("state");

//Parent class
var { _Playable, Playable } = require('./playable');

// Information mechanics
var { Information, PerfectInformation } = require('../information');


//Backend class
function _Simultaneous(id, playableArray, { playableParameters = {} } = {}) {
	_Playable.call(this, id);

	this.playableArray = playableArray;
	this.playableParameters = playableParameters;

	registry.controllers[id] = this;
}

_Simultaneous.prototype = Object.create(_Playable.prototype);
_Simultaneous.prototype.constructor = _Simultaneous;

_Simultaneous.registryName = "controllers";
_Simultaneous.counterName = "simultaneous";


//Simultaneous Promise.all's the playables, which causes them to run meshed.
_Simultaneous.prototype.play = function({ history = gameHistory, information = PerfectInformation } = {}) {

	var simultaneous = this;

	// Deal with history. Log start, then split history for children playables to fill in.
	history.log.add({
		simultaneous: simultaneous.id,
		action: "Simultaneous start."
	});
	var simultaneousHistory = []



	//TODO: is information mechanics correct?

	return Promise.all(simultaneous.playableArray.map(function(playable) {

		var branchHistory = history.child();
		simultaneousHistory.push(branchHistory)

		// Information mechanics
		var infoPopulation, parentHistory, infoHistory = branchHistory;
		//compartmentalize if set. "compartmentalize" means pass on information as if this playable is the entire game.
		if (simultaneous.compartmentalize) {
			infoPopulation = simultaneous.compartmentalize.population || information.population;
			parentHistory = simultaneous.compartmentalize.history || information.history;
		} else {
			infoPopulation = information.population;
			parentHistory = information.history
		}
		var simultaneousInformation = new Information(infoHistory, infoPopulation, { parentHistory });



		return playable.play({ history: branchHistory, information: simultaneousInformation });
	})).then(function(resultArray) {

		var resultObject = {
			resultArray,
			playable: simultaneous,
			historyEntry: {
				simultaneous: simultaneous.id,
				action: simultaneousHistory.map(function(history) {
					return history.orphan();
				})
			}
		};
		return resultObject;
	});
};


_Simultaneous.prototype.handleHistory = function({ history = gameHistory } = {}, result) {

	history.log.add({
		simultaneous: this.id,
		action: "Simultaneous complete."
	});

	history.addNoLog(result.historyEntry);

	return Promise.resolve(result);
};

_Simultaneous.prototype.summaryThis = function(summary, entries) {
	summary.action = [];

	this.playableArray.forEach(function(playable, index) {
		summary.action[index] = {}
		playable.summarize(summary.action[index], entries);
	});
}


//Frontend class
function Simultaneous(playableArray, parameters = {}) {
	var id = idHandler(parameters.id, "simultaneous")

	playableArray = playableArray.map(function(playable) {
		return registry.playables[playable.id()];
	});


	//Create backend instance.
	var _simultaneous = new _Simultaneous(id, playableArray, parameters);

	//Return this reference object to the user. Run the function to select a source
	var simultaneous = Playable(_simultaneous);
	return simultaneous;
}


module.exports = { _Simultaneous, Simultaneous };

},{"../helper-functions":8,"../information":17,"../logger":18,"./playable":26}],31:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: Stochastic-Halt")

//Game state controllers
var {registry, gameHistory} = require('../state');

//Helper functions
var {isFunction}	= require('../helper-functions')("general");
var {idHandler} 	= require('../helper-functions')("state");

//Parent class
var {_Playable, Playable} 	= require('./playable');
var {_Halt, Halt}			= require('./halt-if');


//Backend function class for SHalt
function _SHalt(id, probability, parameters){
	_Halt.call(this,id,null,parameters);
	
	var sHalt = this;
	
	this.probability = probability;
	this.generator = Math.random;				//TODO: allow user to specify random number generator
	
	this.testCondition = function(){
		if (sHalt.generator() < sHalt.probability) return true;
	};
	
	
	registry.sHalts[id] = this;
}
_SHalt.prototype = Object.create(_Halt.prototype);
_SHalt.prototype.constructor = _SHalt;

_SHalt.registryName = "sHalts";
_SHalt.counterName = "stochasticHalt";

/*
_SHalt.prototype.play = function({initializePlayers=false, shortCircuit=false}={}){
	
	var sHalt = this;
	var test = sHalt.testCondition();
	
	if (test) {
		log("info", "Halting at " + sHalt.id)
		
		return Promise.reject({
			result:"Halt",
			playable:sHalt
		});
	}
	
	var resultObject = {
		'result':"Continued",
		'playable':sHalt
	};
	
	return Promise.resolve(resultObject)
	.then(function(result){	
		
		//TODO: add information mechanisms
		
		return Promise.resolve(result)		
	}).then(function(result){
		
		return sHalt.proceed(result, shortCircuit);
	});
};
*/

_SHalt.prototype.summaryThis = function(summary, entries){
	summary.probability = this.probability;
}


function StochasticHalt(probability, {id=null, logContinue=false}={}){
	var id = idHandler(id,"stochasticHalt")
	
	if (isNaN(probability) || probability < 0 || probability > 1) throw new Error('Invalid probability');

	//Create backend sHalt objects
	var _sHalt = new _SHalt(id, probability, {logContinue});
	
	
	//Return this reference object to the user. Run the function to select a source
	var sHalt = Playable(_sHalt);	
	return sHalt;	
}


module.exports = {_SHalt, StochasticHalt};
},{"../helper-functions":8,"../logger":18,"../state":42,"./halt-if":22,"./playable":26}],32:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: StochasticLoop")

//Game state controllers
var { registry, gameHistory } = require('../state');

//Helper functions
var { idHandler } = require('../helper-functions')("state");
var { chainerGenerator } = require('../helper-functions')("playable");

//Parent classes
var { _Playable, Playable } = require('./playable');
var { _Loop, Loop } = require('./loop');


//Backend function class for StochasticLoop
function _SLoop(id, playable, probability, parameters) {
	_Loop.call(this, id, playable, null, parameters);

	this.playable = registry.playables[playable.id()];

	//This inherits from Loop which uses a count. Delete that and replace with probability.
	delete this.count;
	this.probability = probability;

	this.generator = Math.random; //TODO: allow user to specify random number generator

	registry.sLoops[id] = this;
}
_SLoop.prototype = Object.create(_Loop.prototype);
_SLoop.prototype.constructor = _SLoop;

_SLoop.registryName = "sLoops";
_SLoop.counterName = "stochasticLoop";


_SLoop.prototype.play = function({
	initializePlayers = false,
	shortCircuit = false,
	history = gameHistory,
	information: PerfectInformation
} = {}) {

	var sLoop = this;
	sLoop.counter = 0;
	var loopHistory = history.child();

	if (sLoop.compartmentalize) {
		information = new Information(sLoop.compartmentalize.history || loopHistory,
			sLoop.compartmentalize.population || information.population);
	}


	var promise = Promise.resolve({});

	//Section that will be looped
	var action = function(result) {

		sLoop.counter++;
		if (!result) result = {};


		//Deal with history
		history.log.add({
			loop: sLoop.id,
			loopTo: sLoop.playable.id,
			count: sLoop.counter
		});

		return sLoop.playable.play({ shortCircuit: true, history: loopHistory, information })
			.then(function(result) {

				result.playable = sLoop;
				//TODO: add information mechanisms

				return Promise.resolve(result)
			});
	};


	//Generate random numbers, repeat while number is above halting probability
	while (sLoop.generator() > sLoop.probability) {
		promise = promise.then(action);
	}


	return promise.then(function(result) {

		result.historyEntry = {
			loop: sLoop.id,
			count: sLoop.counter,
			action: loopHistory.orphan()
		};

		return Promise.resolve(result);
	});
};

_SLoop.prototype.summaryThis = function(summary, entries) {
	summary.probability = this.probability;

	summary.action = {}
	this.playable.summarize(summary.action, entries, true)
}


//User interface
function StochasticLoop(playable, probability = .5, parameters = {}) {
	var id = idHandler(parameters.id, "stochasticLoop")

	if (isNaN(probability) || probability < 0 || probability > 1) throw new Error('Invalid probability');

	//Create backend sLoop object
	var _sLoop = new _SLoop(id, playable, probability, parameters);


	//Return this reference object to the user. Run the function to select a source
	var sLoop = Playable(_sLoop);
	return sLoop;
}



module.exports = { _SLoop, StochasticLoop };

},{"../helper-functions":8,"../logger":18,"../state":42,"./loop":25,"./playable":26}],33:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Turn");

//External dependency
var { SynchronousPromise } = require("synchronous-promise");

//Helper functions
var { isObject, once } = require("../helper-functions")("general");
var { chainerGenerator, outcomeTreeGetValue, outcomeTreeSetValue } = require("../helper-functions")("playable");
var { recurse } = require("../helper-functions")("turn");
var { idHandler } = require("../helper-functions")("state");

//Game state controllers
var { registry } = require("../state");
var { gameHistory } = require("../history");
var { Information, PerfectInformation } = require("../information");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Turn
function _Turn(id, choices, parameters = {}) {
	_Playable.call(this, id);

	this.payoffsImplicit = {};
	this.payoffsExplicit = {};

	this.next = {};

	this.choices = choices.map(function(choice) {
		return registry.choices[choice.id()];
	});

	registry.turns[id] = this;

	var turn = this;

	this.choiceMap = this.choices.map(function(item) {
		return item.options;
	});

	recurse(turn.choiceMap, turn.payoffsImplicit, null, function() {
			return Array(turn.choiceMap.length).fill(0);
		})
		.then(function(result) {
			log("silly", "Added implicit payoffs map to turn.");
			return recurse(turn.choiceMap, turn.payoffsExplicit, {});
		})
		.then(function(result) {
			log("silly", "Added explicit payoffs map to turn.");
			return recurse(turn.choiceMap, turn.next, null, function() {
				return [];
			});
		})
		.then(function(result) {
			log("silly", "Added blank next map to turn.");
			return Promise.resolve(result);
		})
		.catch(function(reason) {
			log("error", reason);
		}); //TODO: error handling here
}
_Turn.prototype = Object.create(_Playable.prototype);
_Turn.prototype.constructor = _Turn;

_Turn.registryName = "turns";
_Turn.counterName = "turn";


_Turn.prototype.play = function({
	usePayoffs = true,
	history = gameHistory,
	information = PerfectInformation,
	releasePlayers = true
} = {}) {

	var turn = this;
	var choiceHistory = history.child();
	var choiceInformation = information.child();

	if (turn.compartmentalize) {
		choiceInformation = new Information(turn.compartmentalize.history || choiceHistory,
			turn.compartmentalize.population || information.population);
	}

	history.log.add({
		turn: turn.id,
		choices: turn.choices.map(function(choice) {
			return choice.id;
		})
	});

	var compileInformation = function(ri) {
		//If there's no turn entry, create one.
		if (!choiceInformation.additional[0].turn) {
			var turnInfo = {
				turn: {
					id: turn.id,
					choices: [],
					exclude(player) {
						return this.choices.filter(function(choice) {
							return choice.player == player;
						});
					}
				}
			};
			choiceInformation.additional.unshift(turnInfo);
		}
		choiceInformation.additional[0].turn.choices.push(
			choiceInformation.additional.pop()
		);

		information.additional.forEach( // TODO: what does this do???
			choiceInformation.addAdditional.bind(choiceInformation)
		);
	};

	return Promise.all(
			turn.choices.map(function(choice) {
				return choice.play({
					shortCircuit: true,
					history: choiceHistory,
					information: choiceInformation,
					_compileInformation: compileInformation,
					releasePlayers: false
				});
			})
		)
		.then(function(result) {
			//Re-format output from array of Choice results to single Turn result
			//And release players
			var resultPath = result.map(function(choice, index) {
				if (releasePlayers) turn.choices[index].releasePlayer();
				return choice.result;
			});

			//Pass along results and record history
			var resultObject = {
				result: resultPath,
				playable: turn,
				historyEntry: {
					turn: turn.id,
					results: choiceHistory.orphan(),
					payouts: {}
				}
			};

			return Promise.resolve(resultObject);
		})
		.then(function(result) {
			//Implement payoffs
			if (usePayoffs) {
				var implicitPayoffs = outcomeTreeGetValue(
					turn.payoffsImplicit,
					result.result
				);
				var explicitPayoffs = outcomeTreeGetValue(
					turn.payoffsExplicit,
					result.result
				);

				// For the log
				var payouts = {};

				implicitPayoffs.forEach(function(payoff, index) {
					// Do nothing if payoff is zero.
					if (payoff == 0) return;

					// fetch player and increment score
					var player = turn.choices[index].player;
					player.score += payoff;

					//And include it in the log entry
					payouts[player.id] = Number(payoff);
				});

				for (var player in explicitPayoffs) {
					registry.players[player].score += explicitPayoffs[player];

					//And include it in the log entry
					payouts[player] = Number(explicitPayoffs[player]);
				}

				//Log for the scores log
				var scoreEntry = {
					turn: turn.id,
					result: result.result,
					payouts: payouts
				};
				history.addScores(scoreEntry);


				// Log for the game history
				result.historyEntry.payouts = payouts;
			}

			return Promise.resolve(result); //TODO: add information mechanisms
		});
};

//Overwrite default history handler, because we don't want a second entry in the tree
_Turn.prototype.handleHistory = function({ history = gameHistory } = {},
	result
) {
	history.addNoLog(result.historyEntry);

	return Promise.resolve(result);
};

_Turn.prototype.findNext = function({ result } = {}) {
	return outcomeTreeGetValue(this.next, result.result);
};

_Turn.prototype.generateChainingFunctions = function() {
	var _turn = this;
	var turn = _turn.interface;

	//Create payoff setter/branch router functions.
	//recurse adds a wrapper around this function which supplies the path.
	recurse(_turn.choiceMap, turn, function(path, payoffs) {
		//If user supplied payoffs in array form, then translate to object based on which players are involved in the choices
		if (Array.isArray(payoffs)) {
			if (payoffs.length !== _turn.choices.length) {
				//If array isn't right length, then this is unintelligible.
				log(
					"error",
					"Payoff array does not match Turn dimensions, cannot assign payoffs."
				);
				return Promise.reject(new Error("Payoff array is not correct length"));
			}

			var originalPayoffs = payoffs.slice();
			payoffs = {};

			outcomeTreeSetValue(_turn.payoffsImplicit, path, originalPayoffs);
		} else if (isObject(payoffs)) {
			payoffs = JSON.parse(JSON.stringify(payoffs));
			outcomeTreeSetValue(_turn.payoffsExplicit, path, payoffs);
		}

		return SynchronousPromise.resolve({
			playable: turn,
			path: path
		});
	});
};

_Turn.prototype.setAllPayoffs = function(payoffArray) {
	var turn = this;

	//Recurse through the options in input, to come up with a path to every combination of options in the array of arrays.
	function recurse(input, numPlayers, payoffs, path = [], coordinates = []) {
		return SynchronousPromise.resolve(path).then(function(path) {
			//Since we slice the array each time, if there are no more entries left then we're done with this branch.
			if (input.length == 0) return SynchronousPromise.resolve(path);

			//Among all values from the array
			return SynchronousPromise.all(
				input[0].map(function(item, index) {
					var splitPath = path.slice(0).concat(item);
					var splitCoordinates = coordinates.slice(0).concat(index);
					var splitPayoffs = payoffs[index];

					//If we're at the last position in the array of options, then we have a complete path.
					if (input.length == 1) {
						/* you might need these later
					console.log("path ", splitPath);
					console.log("coordinates ", splitCoordinates)
					console.log("payoff ",splitPayoffs)
					*/

						splitPayoffs = JSON.parse(JSON.stringify(splitPayoffs));

						//Allow the first few array elements to be implicit payoffs. Check that they are actually there and are numbers
						var implicit = splitPayoffs.slice(0, numPlayers);
						if (
							implicit.length == numPlayers &&
							implicit.every(function(payoff) {
								return !isNaN(payoff);
							})
						) {
							outcomeTreeSetValue(turn.payoffsImplicit, splitPath, implicit);
						}

						//Any remaining should be assigned as explicit payoffs, if they're objects.
						splitPayoffs.slice(numPlayers).forEach(function(explicit) {
							if (isObject(explicit))
								outcomeTreeSetValue(turn.payoffsExplicit, splitPath, explicit);
						});
					}

					//If there are more items to iterate over, include them in the output then recurse.
					return recurse(
						input.slice(1),
						numPlayers,
						splitPayoffs,
						splitPath,
						splitCoordinates
					);
				})
			);
		});
	}

	return recurse(turn.choiceMap, turn.choices.length, payoffArray).catch(
		function(reason) {
			log("error", reason);
		}
	);
};

// Adding more complicated summary entry
_Turn.prototype.summaryThis = function(summary, entries, shortCircuit = false) {
	// Fetch summaries for each choice.
	summary.choices = [];
	this.choices.forEach(function(choice, index) {
		summary.choices[index] = choice.summarize(
			summary.choices[index],
			entries,
			true
		);
	});

	// Include payoffs
	summary.payoffs = JSON.parse(
		JSON.stringify({
			implicit: this.payoffsImplicit,
			explicit: this.payoffsExplicit
		})
	);

	return summary;
};

//
_Turn.prototype.summaryNext = function(summary, entries) {
	var turn = this;

	// Create map
	summary.next = {};
	var count = 0;
	recurse(this.choiceMap, summary.next, null, function(path) {
		return outcomeTreeGetValue(turn.next, path).map(function(playable) {
			++count;
			return playable.summarize();
		});
	});

	// If there is no next, delete the key.
	if (count == 0) delete summary.next;
};

function Turn(choices, parameters = {}) {
	var id = idHandler(parameters.id, "turn");

	//Create backend choice object
	var _turn = new _Turn(id, choices, parameters);

	//Return this reference object to the user. Run the function to select a source
	var turn = Playable(_turn);

	_turn.generateChainingFunctions();

	//Function to set all payoffs at once
	turn.setAllPayoffs = function(payoffs) {
		//TODO: Include error handling if array given isn't expected dimensions.
		_turn.setAllPayoffs(payoffs);
	};

	//Way for user to interact with payoffs
	turn.payoffs = function() {
		return JSON.parse(
			JSON.stringify({
				implicit: _turn.payoffsImplicit,
				explicit: _turn.payoffsExplicit
			})
		);
	};

	// Returns the payoffs in nested array form, to make cloning easier, ie. t2.setAllPayoffs(t1.payoffsMatrix())
	turn.payoffsMatrix = function() {

		// recursion to construct payoff matrix
		var mapper = function(obj, path = []) {
			//If it's an array, then we've reached the payoffs
			if (Array.isArray(obj)) {
				var payoff = obj.slice(0)
				// Add explicit payoffs too
				var explicit = outcomeTreeGetValue(_turn.payoffsExplicit, path);

				// Only add an entry if the explicit payoffs object is not empty
				return Object.keys(explicit).length > 0 ? payoff.concat([outcomeTreeGetValue(_turn.payoffsExplicit,
					path)]) : payoff
			}

			// Otherwise, dig in deeper
			else return Object.keys(obj).map(function(key) { return mapper(obj[key], path.slice(0).concat([key])) })
		}
		return mapper(_turn.payoffsImplicit)
	}

	return turn;
}

module.exports = { _Turn, Turn };

},{"../helper-functions":8,"../history":16,"../information":17,"../logger":18,"../state":42,"./playable":26,"synchronous-promise":62}],34:[function(require,module,exports){
"use strict";

var log = require('./logger');

//Game state controllers
var { registry } = require('./state');

//Helper functions
var { idHandler } = require('./helper-functions')("state");
var { chainerGenerator } = require('./helper-functions')("playable");

var { UserHistory } = require('./history');

// Plugins
var PluginManager = require("./plugin-manager")

//Backend for Player
function _Player(id, { name = "", assign = null } = {}) {
	log('silly', 'Creating interal player object.');

	this.id = id
	this.score = 0
	this.name = name;

	this.history = [];

	if (assign) this.assign(assign);

	this.alive = true;
	this.available = true;

	registry.players[id] = this;
}


//Make a copy of the player, in order to take a snapshot. ////TODO try this again sometime.
/*
_Player.prototype.clone = function(){
	//Make new copy. Don't keep more than one.
	delete this.copy

	var clone = new _Player(this.id);

	//Loop through properties and assign them.
	for (var key in this){
		clone[key] = this[key];
	}
	//Do not add to registry. This will keep duplicates out of population.

	//Do add reference so we can find it again.
	this.copy = clone;

	return clone;
};
*/


//Assign strategy to player
_Player.prototype.assign = function(strategy, ...args) {

	//TODO: verify strategy type
	if (registry.strategies[strategy]) {
		this.strategy = new registry.strategies[strategy](...args);
		this.strategy._id = strategy
		this.strategy._args = args
	} else throw new Error("Strategy '" + strategy + "' is not defined");
};


//Call strategy to make a choice
_Player.prototype.choose = function(options, information = {}) { //TODO: check that there's a strategy assigned before trying to play
	var player = this;
	if (player.strategy) {
		let result = player.strategy.choose(options, information)
		if (result) return Promise.resolve(result.toString());
		// If no response, give warning
		else log("warning", "No response from player " + player.id + ". Using default option.")
	}
	// If no strategy, give warning
	else
		log("warning", "No strategy assigned to player " + player.id + ". Using default option.");
	return Promise.resolve(null);
};


//Takes a JSON.parse(JSON.stringify()) copy of _player. Returns a cleaned up version
_Player.prototype.infoClean = function(infoObject) {
	delete infoObject.interface;
	infoObject.strategy = infoObject.strategy ? infoObject.strategy._id : null;

	return infoObject;
};


//Kill player. TODO: add player to some sort of "dead" list to avoid being picked to do things.
_Player.prototype.kill = function() {
	this.alive = false;
};



//Class that is the reference for the user to hold onto
function player() {}


//Frontend for Player
function Player(parameters = {}) {
	var id = idHandler(parameters.id, "player");

	//Create backend player object
	var _player = new _Player(id, parameters);


	//Return this reference object to the user
	var playerInterface = new player(); //Probably add functionality here

	//Tag-back. Store the front-end object in the back-end object, for retrieval
	_player.interface = playerInterface;

	playerInterface.alive = function() {
		return registry.players[id].alive;
	}

	playerInterface.assign = function(strategy, ...args) {
		registry.players[id].assign(strategy, ...args);
	};

	playerInterface.available = function() {
		return registry.players[id].available
	};

	playerInterface.busy = function() {
		registry.players[id].available = false;
	};

	playerInterface.history = function() {
		return new UserHistory(registry.players[id].history);
	};

	playerInterface.id = function() { return id; };

	playerInterface.kill = function() {
		registry.players[id].kill();
	}

	playerInterface.release = function() {
		registry.players[id].available = true;
	};

	playerInterface.resetScore = function() {
		registry.players[id].score = 0;
	}

	playerInterface.score = function() {
		return registry.players[id].score;
	};

	playerInterface.strategy = function() {
		return registry.players[id].strategy._id;
	};

	// PLUGIN: run after player creation
	PluginManager.run("player-create", _player)

	return playerInterface
}




module.exports = { _Player, Player };

},{"./helper-functions":8,"./history":16,"./logger":18,"./plugin-manager":36,"./state":42}],35:[function(require,module,exports){
/**
 *
 * @type {{}}
 */

function AsyncCtx(callback) {
	this.callback = callback;
	this.sync = true;
}

AsyncCtx.prototype.async = function() {
	this.sync = false;
	return this.callback;
};

/**
 * This is an API meant to be used only from synchronous
 * callbacks into an asynchronous like hook.
 *
 * it represent continuity from the "sync()" or "waterfall()"
 * plugin management
 */
AsyncCtx.prototype.stop = function() {
	var callback = this.async();
	callback(true);
};

module.exports = AsyncCtx;
},{}],36:[function(require,module,exports){
// Stolen liberally and brazenly from "polite-plugin-manager".
"use strict";

const pluginDirectoryPath = "../../plugins/"
// Hack to compile Glob files for browserify. Don´t call this function!
function $_DONOTCALL() {
	require('../../plugins/balance-sheet-complex.js');require('../../plugins/balance-sheet.js')
}

/**
 * Polite Plugin Manager
 * register and run hooks granting extendability
 *
 */


// Global Dependencies
var fs = require('fs'),
	path = require('path'),
	async = require('async'),

	// Local Modules
	AsyncCtx = require('./async-ctx'),
	WaterfallCtx = require('./waterfall-ctx'),
	PluginNameError = require('./plugin-name-error'),
	PluginCallbackError = require('./plugin-callback-error');


// ------------------------------------------------------------------------------------ //
// ---[[   C O N S T R U C T O R   A N D   L I F E C Y C L E   U T I L I T I E S   ]]-- //
// ------------------------------------------------------------------------------------ //

var PluginManager = {},
	packages = [],
	packageNames = [],
	hooks = {},
	skipProps = ['module', 'name', 'priority', 'active', 'init', 'require', 'stop', 'public', 'settings'];



PluginManager.reset = function() {
	packages = [];
	packageNames = [];
	hooks = {};
	return this;
};

/**
 * Apply package sorting,
 * register packages into hooks,
 * run packages init() method
 */
PluginManager.start = function(callback) {

	var self = this,
		inits = [];

	// sort by priorities
	packages.sort(function(a, b) {
		return a.priority > b.priority;
	});

	// register init & hooks
	// hooks are all functions who are not special properties
	// identified by "skipProps" list
	packages.forEach(function(pkg) {
		if (pkg.init) {
			inits.push(pkg.init);
		}
		for (var prop in pkg) {
			if (skipProps.indexOf(prop) === -1 && typeof pkg[prop] == 'function') {
				PluginManager.registerHook(prop, pkg[prop]);
			}
		}
	});

	// run all package.init() method in series!
	if (inits.length) {
		async.eachSeries(inits, function(fn, done) {

			var context = new AsyncCtx(done),
				result = fn.apply(context);

			// sync false stop initialization cycle!
			if (context.sync) {
				if (result === false) {
					callback.call(self);
				} else {
					done(result);
				}
			}

		}, callback.bind(this));
	} else {
		callback.call(self);
	}

	return this;
};




// --------------------------------- //
// ---[[   H O O K S   A P I   ]]--- //
// --------------------------------- //

PluginManager.registerHook = function(hookName, hookFn, hookPriority = 100) {
	hookFn.priority = hookPriority;

	if (!hooks[hookName]) {
		hooks[hookName] = [];
	}

	hooks[hookName].push(hookFn);
	return this;
};


PluginManager.isEmpty = function(hookName) {
	if (hooks[hookName] && hooks[hookName].length) {
		return false;
	} else {
		return true;
	}
};



/**
 * Run registered hook callbacks in series
 * (it supports asynchronous callbacks)
 */
PluginManager.run = function(hookName, ...args) {

	// Use the runWithCallback but with blank callback.
	PluginManager.runWithCallback(hookName, ...args, function() {})
};

// Same as above, but use last argument as callback
PluginManager.runWithCallback = function(hookName, ...args) {

	// collect hookName property
	if (!hookName) throw new PluginNameError('missing plugin name!');

	// obtain async callback
	if (!args.length || typeof args[args.length - 1] !== 'function') {
		throw new PluginCallbackError('[' + hookName + '] missing callback for async plugin!');
	} else {
		var callback = args.pop();
	}


	// check for some callbacks existance
	// [???] may give out an exception when no callbacks were found!
	if (!hooks[hookName] || !hooks[hookName].length) {
		callback(false);
		return false;
	}

	// Sort hooks by priority
	hooks[hookName].sort(function(a, b) {
		return a.priority > b.priority
	})

	// run async queque
	// NOTE: a step function should stop the queque by done(true)
	async.eachSeries(hooks[hookName], function(fn, done) {
		var context = new AsyncCtx(done),
			result = fn.apply(context, args);

		if (context.sync) {
			if (result === false) {
				callback();
			} else {
				done(result);
			}
		}
	}, callback);

	return true;
}

/**
 * Run registered hook callbacks in parallel
 * (it supports asynchronous callbacks)
 * @param hookName
 */

PluginManager.parallel = function() {

	var hookName = '',
		callback = null,
		args = Array.prototype.slice.call(arguments);

	// collect hookName property
	if (!args.length) {
		throw new PluginNameError('missing plugin name!');
	} else {
		hookName = args.shift();
	}

	// obtain async callback
	if (!args.length || typeof args[args.length - 1] !== 'function') {
		throw new PluginCallbackError('[' + hookName + '] missing callback for async plugin!');
	} else {
		callback = args[args.length - 1];
	}

	// check for some callbacks existance
	// [???] may give out an exception when no callbacks were found!
	if (!hooks[hookName] || !hooks[hookName].length) {
		callback(false);
		return false;
	}

	// run async in parallel
	// NOTE: a step function should stop the queque by done(true)
	async.each(hooks[hookName], function(fn, done) {
		var context = new AsyncCtx(done),
			result = fn.apply(context, args);

		// handle sync callbacks
		if (context.sync) {
			done(result);
		}
	}, callback);

	return true;
};


/**
 * WATERFALL
 * Run a hook as a normal function in a fully syncronous mode
 * Each hookFn should return a value who's forward as first argument for the next one
 * last hookFn return value is the final output
 */
PluginManager.waterfall = function(hookName) {

	if (!hookName) {
		throw new PluginNameError('missing plugin name!');
	}

	var args = Array.prototype.slice.call(arguments);
	args.shift();

	if (hooks[hookName]) {
		// use known exception to exit forEach cycle implementing a stoppable watefall
		// (http://stackoverflow.com/questions/2641347/how-to-short-circuit-array-foreach-like-calling-break?answertab=votes#tab-top)
		var WaterfallBreakException = {};
		try {
			hooks[hookName].forEach(function(fn) {
				var context = new WaterfallCtx(),
					result = fn.apply(context, args);

				if (args.length) {
					args[0] = result;
				}

				if (context.stopped) {
					throw WaterfallBreakException;
				}

			});
		} catch (e) {
			if (e !== WaterfallBreakException) throw e;
		}
	}

	if (args.length) {
		return args[0];
	} else {
		return;
	}
};




// --------------------------------------- //
// ---[[   P A C K A G E S   A P I   ]]--- //
// --------------------------------------- //

function getPackageByName(name) {
	var list = packages.filter(function(pkg) { return (pkg.name === name) })
	if (list.length == 1) return list[0]
	else return list;
}

// Package class
function Package(module, name = null, context = null) {
	// Basic assignment and default values
	Object.assign(this, {
		module,
		name,
		priority: 100,
		active: false,
		init: function() {},
		require: function() {},
		stop: function() {},
		settings: function() {},
		public: {}
	})
	// Package-defined values and hooks
	Object.assign(this, module(context || {}))

	// add to registry
	// Check to see if it's the same module being loaded twice, or different modules with the same name
	if (packageNames.includes(this.name)) {
		if (this.module === getPackageByName(this.name).module) {
			// Same module. Do nothing
		} else {
			// Different modules with same name, handle name conflict.
			//TODO: figure out how to handle name conflict.
		}
	}
	// No name conflict, add to registry
	else {
		packages.push(this);
		packageNames.push(this.name)
	}
}

Package.prototype.registerHooks = function() {
	var pkg = this;
	for (var prop in pkg) {
		if (skipProps.indexOf(prop) === -1 && typeof pkg[prop] == 'function') {
			PluginManager.registerHook(prop, pkg[prop]);
		}
	}
}

// Create interface for user to interact with package.
function PackageInterface(pkg) {

	// Merge any public items specified by the package with this interface format
	return Object.assign({}, pkg.public, {
		name: function() { return pkg.name },
		priority: function() { return pkg.priority },
		active: function() { return pkg.active },

		init: function(...args) {
			pkg.init(...args);
			pkg.registerHooks();
			pkg.active = true;
			return Object.assign(this, pkg.publicIfActive);
		},
		require: function(...args) {
			if (pkg.active) pkg.require(...args);
			else {
				pkg.init(...args);
				pkg.registerHooks();
				Object.assign(this, pkg.publicIfActive);
			}
			pkg.active = true;

			return this;
		},
		stop: function(...args) {
			if (pkg.active) pkg.stop(...args);
			pkg.active = false;
		},
		settings: function(...args) {
			return pkg.settings(...args);
		}

	}, pkg.active ? pkg.publicIfActive : null);
}




/**
 * Load a plugin package by folder path
 * @param sourceFolder
 */
PluginManager.package = function(source, context) {
	if (packageNames.includes(source)) {
		// Already loaded module, just return it
		return PackageInterface(getPackageByName(source))
	} else {
		var name = path.basename(source),
			module = require(pluginDirectoryPath + source + '.js')

		// obtain package informations and apply some default values
		var pkg = new Package(module, name, context)
		return PackageInterface(pkg)
	}
}

/*
			load: function(callback = function() {}, ...initArgs) {
				var self = pm,
					inits = [],


					// register init & hooks
					// hooks are all functions who are not special properties
					// identified by "skipProps" list

					if (pkg.init) {
						inits.push(pkg.init);
					}


				// run all package.init() method in series! //EDIT: will only be the one
				if (inits.length) {
					async.eachSeries(inits, function(fn, done) {

						var context = new AsyncCtx(done),
							result = fn.apply(context, initArgs);

						// sync false stop initialization cycle!
						if (context.sync) {
							if (result === false) {
								callback.call(self);
							} else {
								done(result);
							}
						}

					}, callback.bind(self));
				} else {
					callback.call(self);
				}

				return self;
			}

		};
	};
*/

/** TODO: this doesn't work right now
 * Load all packages from a given folder path
 * (syncronous)
 */
PluginManager.registerMany = function(sourceFolder, context) {
	var self = this;

	if (fs.existsSync(sourceFolder)) {
		fs.readdirSync(sourceFolder).forEach(function(item) {
			var itemPath = sourceFolder + '/' + item,
				itemStat = fs.lstatSync(itemPath);

			if (itemStat.isDirectory()) {
				self.loadPackage(itemPath, context);
			}
		});
	}

	return this;
};

module.exports = PluginManager

},{"../../plugins/balance-sheet-complex.js":63,"../../plugins/balance-sheet.js":64,"./async-ctx":35,"./plugin-callback-error":37,"./plugin-name-error":38,"./waterfall-ctx":39,"async":47,"fs":1,"path":2}],37:[function(require,module,exports){

function PluginCallbackError(message) {
	this.name = "PluginCallbackError";
	this.message = (message || "");
}


PluginCallbackError.prototype = new Error();
PluginCallbackError.prototype.constructor = PluginCallbackError;

module.exports = PluginCallbackError;
},{}],38:[function(require,module,exports){

function PluginNameError(message) {
	this.name = "PluginNameError";
	this.message = (message || "");
}


PluginNameError.prototype = new Error();
PluginNameError.prototype.constructor = PluginNameError;

module.exports = PluginNameError;
},{}],39:[function(require,module,exports){
/**
 *
 * @type {{}}
 */

function WaterfallCtx() {
	this.stopped = false;
}

WaterfallCtx.prototype.stop = function() {
	this.stopped = true;
};

module.exports = WaterfallCtx;
},{}],40:[function(require,module,exports){
"use strict";

var log = require("./logger");

//Helper functions
var { isFunction, isObject } = require("./helper-functions")("general");

//Game state controllers
var { registry } = require("./state");

var { _Player } = require("./player");

//Class PlayerList is a list of players which includes some extra functionality. UserPlayerList takes a playerList and
//sanitizes it for the user (ie returns .interface for each player).

function PlayerList(...args) {
	if (Array.isArray(args[0])) args = args[0].slice(0);
	if (args == "all") return gamePopulation();

	// We'll need to retain the original arguments in order to create the generator
	var originalArgs = []

	// Loop over the arguments, save the originals, parse them to _players
	for (var i = 0, len = args.length; i < len; i++) {
		originalArgs.push(args[i]);
		if (isFunction(args[i].id)) args[i] = registry.players[args[i].id()];
		else if (typeof args[i] === 'string') args[i] = registry.players[args[i]]
	}

	Object.setPrototypeOf(args, PlayerList.prototype);

	// returns the same playerlist, but updated, using the original args.
	args.generator = function() {
		return new PlayerList(originalArgs);
	};

	return args;
}

PlayerList.prototype = Object.create(Array.prototype);
PlayerList.prototype.constructor = PlayerList;


// Assign a strategy en masse
PlayerList.prototype.assign = function(strategyName) {
	this.forEach(function(player) {
		player.assign(strategyName)
	})
	return this;
}


//Return a PlayerList minus the specified players.
//Argument can be _player, interface, or a player's id.
PlayerList.prototype.exclude = function(playerArg) {
	if (Array.isArray(playerArg))
		return playerArg.reduce(function(running, item) {
			return running.exclude(item);
		}, this);

	return new PlayerList(
		this.filter(function(player) {
			if (
				playerArg === player ||
				playerArg == player.interface ||
				playerArg == player.id ||
				(isObject(playerArg) && playerArg.id == player.id)
			)
				return false;
			else return true;
		})
	);
};


// Placeholder for generator method.
PlayerList.prototype.generator = function() {
	// This will get shadowed when the constructor is called, but it needs to be here so that the
	// UserPlayerList and InfoPlayerList constructors can see it.
}


//Create an InfoPlayerList out of this PlayerList. Useful for getting summary view.
PlayerList.prototype.info = function() {
	return new InfoPlayerList(this);
};


//Return array of ids of each player in the list
PlayerList.prototype.ids = function() {
	return this.map(function(player) {
		return player.id;
	});
};


//Kill all players in the playerList
PlayerList.prototype.kill = function() {
	this.forEach(function(player) {
		player.kill();
	});
	return this;
};


//Returns the single player with the highest score
PlayerList.prototype.leader = function() {
	var players = this.slice();

	players.sort(function(a, b) {
		return b.score - a.score;
	});

	players = players.filter(function(player) {
		return player.score == players[0].score
	})


	return players.length > 1 ? new PlayerList(players) : players[0];
};


PlayerList.prototype.release = function() {
	this.forEach(function(player) {
		player.available = true;
	});
	return this;
};



//Return a playerList with only the players who are available
PlayerList.prototype.onlyAlive = function() {
	return new PlayerList(
		this.filter(function(player) {
			return player.alive;
		})
	);
};


//Return a playerList with only the players who are available
PlayerList.prototype.onlyAvailable = function() {
	return new PlayerList(
		this.filter(function(player) {
			return player.available;
		})
	);
};


//Returns an array of scores of each player in the list
PlayerList.prototype.scores = function() {
	var scores = [];

	this.forEach(function(player) {
		scores.push(player.score); //Use the interface function to avoid users re-assigning the reference
	});
	return scores;
};


// Returns an object where each key is a strategy and each value is an array of the scores of players with that strategy.
// TODO: finish .total() method, which will sum the arrays (duplicating .scoresByStrategyTotals)
PlayerList.prototype.scoresByStrategy = function() {
	var scores = {};
	var list = this;

	list.strategies().map(function(strategy) {
		scores[strategy] = list.usingStrategy(strategy).scores();
	});

	scores.total = function() {
		var score = {};
		var scores = this;
		Object.keys(scores).forEach(function(strategy) {
			if (Array.isArray(scores[strategy])) score[strategy] = scores[strategy].reduce(function(a, b) {
				return a + b;
			}, 0);
		});
		return score;
	};

	return scores;
};

// Returns an object where each key is a strategy and each value is the sum of scores of all players with that value
PlayerList.prototype.scoresByStrategyTotals = function() {
	var scores = {};
	var list = this;

	list.strategies().map(function(strategy) {
		scores[strategy] = list
			.usingStrategy(strategy)
			.scores()
			.reduce(function(a, b) {
				return a + b;
			}, 0);
	});

	return scores;
};

//Returns an object where the keys are the player ids and the values
//are the players' score
PlayerList.prototype.scoresObject = function() {
	var scores = {};

	this.forEach(function(player) {
		scores[player.id] = player.score;
	});

	return scores;
};

//Mean of the scores
PlayerList.prototype.scoresMean = function() {
	var scores = this.scores();

	var mean =
		scores.reduce(function(sum, value) {
			return sum + value;
		}, 0) / scores.length;

	return mean;
};

//Array with 2 entries, the lowest and highest score
PlayerList.prototype.scoresRange = function() {
	var scores = this.scores();

	scores.sort(function(a, b) {
		return a - b;
	});

	return [scores[0], scores[scores.length - 1]];
};

//The standard deviation of the scores
PlayerList.prototype.scoresStd = function() {
	var scores = this.scores();
	var mean = this.scoresMean();

	var variance =
		scores.reduce(function(sum, value) {
			return sum + Math.pow(value - mean, 2);
		}, 0) / scores.length;

	var std = Math.sqrt(variance);

	return std;
};


//Return an array of the strategy of each player in the list
PlayerList.prototype.strategies = function() {
	return this.map(function(player) {
		return player.strategy ? player.strategy._id : "";
	});
};

//Return a PlayerList with only players using a given strategy
PlayerList.prototype.usingStrategy = function(strategy) {
	return new PlayerList(
		this.filter(function(player) {
			if (
				player.strategy == strategy ||
				player.strategy._id == strategy ||
				(isFunction(strategy) && player.strategy instanceof strategy)
			)
				return true;
			else return false;
		})
	);
};

/*

TODO figure out how to make this work

//Returns an object where the keys are strategy names and the values are arrays of players.
//This needs to be overridden on the UserPlayerList prototype, because the normal wrapper logic
//for UserPlayerList cannot sanitize this.
PlayerList.prototype.byStrategy = function(){
	var list = this;
	var data = {};

	Object.keys(registry.strategies).forEach(function(strategy){
		data[strategy] = list.usingStrategy(strategy);
	});

	return data;
};
*/

//Returns an object where the keys are each strategy and the values
//are the number of players in the list who are using it.
PlayerList.prototype.strategyDistribution = function() {
	var counts = {};

	this.forEach(function(player) {
		var s = player.strategy._id;
		counts[s] = (counts[s] || 0) + 1;
	});

	return counts;
};



PlayerList.prototype.resetScores = function() {
	this.forEach(function(player) {
		player.score = 0;
	});
	return this;
};

//Accept a PlayerList and return one suitable for the user, or create a playerlist and return one suitable for the user
function UserPlayerList(...playerList) {
	if (Array.isArray(playerList[0])) playerList = playerList[0];

	// If we've got a playerList, return the interface of each player
	if (playerList instanceof PlayerList) {
		var userPlayerList = playerList.map(function(player) {
			return player.interface;
		});
	}
	// If not, first create a playerList, then call this function again to wrap it.
	else return new UserPlayerList(new PlayerList(playerList));

	Object.setPrototypeOf(userPlayerList, UserPlayerList.prototype);

	//Attach methods from PlayerList, wrapped in a function. If those methods return a playerList,
	//then the function will convert that to a UserPlayerList.
	for (var method in PlayerList.prototype) {
		if (isFunction(playerList[method])) {
			if (method != "constructor")
				userPlayerList[method] = (function(method) {
					return function() {
						var result = playerList[method].apply(playerList, arguments);
						if (result instanceof PlayerList) return new UserPlayerList(result);
						else if (result instanceof _Player) return result.interface;
						else return result;
					};
				})(method);
		}
	}

	return userPlayerList;
}

UserPlayerList.prototype = Object.create(PlayerList.prototype);
UserPlayerList.prototype.constructor = UserPlayerList;

//Accept a PlayerList and return one suitable for a strategy information set.
function InfoPlayerList(playerList) {
	var infoPlayerList = playerList.map(function(player) {
		return player.infoClean(JSON.parse(JSON.stringify(player)));
	});

	Object.setPrototypeOf(infoPlayerList, InfoPlayerList.prototype);

	//Attach selected methods from PlayerList, wrapped in a function. If those methods return a playerList,
	//then the function will convert that to an InfoPlayerList.
	var methodsToInclude = [
		"onlyAlive",
		"onlyAvailable",
		"ids",
		"exclude",
		"generator",
		"strategies",
		"usingStrategy",
		"strategyDistribution",
		"scores",
		"scoresObject",
		"scoresMean",
		"scoresRange",
		"scoresStd",
		"leader"
	];

	for (var method in PlayerList.prototype) {
		if (isFunction(playerList[method])) {
			if (methodsToInclude.indexOf(method) > -1)
				infoPlayerList[method] = (function(method) {
					return function() {
						var result = playerList[method].apply(playerList, arguments);
						if (result instanceof PlayerList) return new InfoPlayerList(result);
						else if (result instanceof _Player)
							return result.infoClean(JSON.parse(JSON.stringify(result)));
						else return result;
					};
				})(method);
		}
	}

	return infoPlayerList;
}

InfoPlayerList.prototype = Object.create(Array.prototype);
InfoPlayerList.prototype.constructor = InfoPlayerList;

//Extra method to return a single player from an infoPlayerList
InfoPlayerList.prototype.get = function(playerID) {
	return this.find(function(player) {
		return player.id == playerID;
	});
};

//Generates a PlayerList containing all players.
var gamePopulation = function() {
	var population = [];

	for (var player in registry.players) {
		population.push(registry.players[player]);
	}

	return new PlayerList(population);
};

//Does the same, but a UserPlayerList
var Population = function() {
	return new UserPlayerList(gamePopulation());
};

//Does the same, but an InfoPlayerList
var InfoPopulation = function() {
	return new InfoPlayerList(gamePopulation());
};

//A short-hand to return total population size without creating a PlayerList
Population.size = function() {
	return Object.keys(registry.players).length;
};

module.exports = {
	PlayerList,
	UserPlayerList,
	InfoPlayerList,
	gamePopulation,
	Population,
	InfoPopulation
};

},{"./helper-functions":8,"./logger":18,"./player":34,"./state":42}],41:[function(require,module,exports){
"use strict";

// External dependency
var jsonata = require("jsonata");

// Game state
var { registry, idCounters } = require("./state")
var { idHandler } = require('./helper-functions')("state");
registry._addType_("queries")
idCounters._addType_("query")


var registerQueryObject = function(queryObject, gameName) {
	// If there are multiple queries, recurse
	if (Array.isArray(queryObject)) return queryObject.map(function(query) {
		return registerQueryObject(query)
	});

	var { shortcut, query, description = "No description given." } = queryObject;
	// Enforce naming convention, first character '@'
	if (shortcut[0] != "@") shortcut = "@".concat(shortcut)

	// Check for duplicates. Abort if so, but return the data for display purposes.
	if (registry.queries[shortcut] && registry.queries[shortcut].query == query &&
		registry.queries[shortcut].description == description)
		return { shortcut, description };

	// assign id and add to registry
	var id = idHandler(shortcut, "query")
	registry.queries[id] = { query, description }

	//return the data for display purposes
	return { shortcut: id, description }
}


// The code which evaluates all queries, no matter where they come from.
function evaluateQuery(queryString, target, ...args) {
	// Check for pre-programmed query, designated by '@'
	if (queryString[0] == "@" && registry.queries[queryString]) queryString = registry.queries[queryString].query
	else if (queryString[0] == "@") queryString = queryString.slice(1)

	return new QueryResult(queryString, jsonata(queryString).evaluate(target, ...args)).pack();
}


// Object to pass around queries
function Query(shortcut, query, description, format = "shortcut") {

	if (format == "save") {
		this.saveShortcut = function(shortcut, description) {
			return registerQueryObject({ query: this.query, shortcut, description })
		}
	}

	// Only include requested properties, to avoid visual clutter
	if (format == "code" || format == "save" || format == "all") this.query = query;
	if (format == "shortcut" || format == "all") {
		this.shortcut = shortcut

		if (format !== "all") {
			// Normally we'd use the prototype method to save memory, but in this case it won't work, so attach another
			this.evaluate = function(target, ...args) {
				return evaluateQuery(query, target, ...args);
			}
		}

	}
	this.description = description
}

Query.prototype.evaluate = function(target, ...args) {
	return evaluateQuery(this.query, target, ...args)
};



// A class to share results with. A simple QueryResult has a `result` and
// a `queryString` property, and a `.pack` method. Calling `.pack` will
// create a new object whose value is the `result` property, but whose
//prototype is the original object. This gives a clean result, that still
// has a `.queryString` property, to view the string that generated it.
function QueryResult(query, result) {
	// Can't add properties to undefined, to change to a string
	if (result == undefined) result = {}

	this.query = query
	this.result = result
}
QueryResult.prototype = Object.create(Array.prototype)
QueryResult.prototype.constructor = QueryResult;

// Returns an object that is the results of the query, but whose
// prototype contains .query (unless the result was just a string)
QueryResult.prototype.pack = function() {
	// If result is string,
	if (typeof this.result === "string") {
		var packed = new String(this.result)
		packed.query = this.query
		return packed;
	}
	// If it's array
	else if (Array.isArray(this.result)) {
		var packed = Object.create(this)
		packed.push(...this.result)
		return packed
	}
	//Normal object
	else return Object.assign(Object.create(this), this.result)
}


// User object for dealing with these things.
function Queries(queryString, target, ...args) {
	// If no query string, display all available shortcuts
	if (!queryString) {
		return Object.keys(registry.queries).map(function(query) {
			var q = registry.queries[query]
			return new Query(query, q.query, q.description, "shortcut")
		})
	}
	// If query string, either run query or return query
	else {
		// If no target, return query
		if (!target) {
			var q = registry.queries[queryString]
			if (q) return new Query(queryString, q.query, q.description, "code")
			else return new Query(null, queryString, null, "save")
		}
		// If yes target, run query on target and return result
		else {
			return evaluateQuery(queryString, target, ...args)
		}
	}
}


module.exports = { Queries, Query, QueryResult, evaluateQuery, registerQueryObject }

},{"./helper-functions":8,"./state":42,"jsonata":55}],42:[function(require,module,exports){
"use strict";

var log = require('./logger');

log("debug", "state: Creating game state variables.")


var registry = {}
registry._addType_ = function(type){	
	registry[type] = {};
	log("silly", "state: adding registry entry: ", type)
};


var idCounters = {}
idCounters._addType_ = function(type){
	idCounters[type] = 0
	log("silly", "state: adding counter entry: ", type)
};





module.exports = {registry, idCounters};
},{"./logger":18}],43:[function(require,module,exports){
"use strict";

const nashName = "./core"; //Change this when published, probably to 'nash-js'

var fs = require("fs");

var { registerStrategy, registerStrategyObject } = require('./strategy');

//Check to see if parsed expression is call to require or eval
function isBannedCall(node) {
	return (node.type === 'CallExpression') &&
		(node.callee.type === 'MemberExpression') &&
		(node.callee.object.type === 'Identifier') &&
		((node.callee.object.name === 'require') || (node.callee.object.name === 'eval'));
}


function removeCalls(source) {
	const entries = [];
	esprima.parseScript(source, {}, function(node, meta) {
		if (isBannedCall(node)) {
			entries.push({
				start: meta.start.offset,
				end: meta.end.offset
			});
		}
	});
	entries.sort((a, b) => { return b.end - a.end }).forEach(n => {
		source = source.slice(0, n.start) + " null; " + source.slice(n.end);
	});
	return source;
}



var loadStrategy = function(filepath, trusted = false) {
	var compiler = require('expression-sandbox');

	var source = fs.readFileSync(filepath);

	if (!trusted) {
		var originalSource = source;
		var parsedSource = removeCalls(source);

		if (originalSource != parsedSource) throw new Error("Strategy " + filepath + " uses require or eval.");
	}

	source = "\"use strict\"; \n " + source;
	compiler(source)({ registerStrategy, registerStrategyObject });

}; //TODO: change this so that strategies can't require any modules.



function loadStrategyFolder(path, trusted = false) {
	var files = fs.readdirSync(path);
	files.forEach(function(file) {
		var filePath = path + '/' + file;
		loadStrategy(filepath);
	});
};


module.exports = { loadStrategy, loadStrategyFolder };

},{"./strategy":44,"expression-sandbox":52,"fs":1}],44:[function(require,module,exports){
"use strict";

var log = require('./logger');

//Javascript code parser
var esprima = require('esprima');

//Game state controllers
var { registry } = require('./state');

//Helper functions
var { idHandler } = require('./helper-functions')("state");



//User interface to declare strategy type.
function registerStrategy(strategy, name, description = "No description given.", playerName = "") {
	var id = idHandler(name, "strategy");

	if (id !== name) {
		//There was already a strategy registered with this name.
		//Check to see if it's the same strategy or not.
		if (!registry.strategies[id] === strategy) {
			//They're different, so we have a name conflict.
			throw new Error("Strategy name conflict with " + name);

		} else {
			// They're the same, do nothing.
			return true;
		}
	}

	// No name conflict and strategy not loaded yet. Add to registry.
	log("debug", "Loading strategy '" + id + "'")
	strategy.playerName = playerName;
	strategy.description = description;
	registry.strategies[id] = strategy;
	return name;
}

function registerStrategyObject(strategyObject) {
	// If multiple strategies, split into individuals
	if (Array.isArray(strategyObject)) return strategyObject.map(registerStrategyObject)

	return registerStrategy(strategyObject.strategy, strategyObject.name, strategyObject.description,
		strategyObject.playerName)
}

//Strip out requires and such
function sanitizeStrategy(strategy) {
	// console.log(x) or console['error'](y)
	function isRequireCall(node) {
		return (node.type === 'CallExpression') &&
			(node.callee.type === 'MemberExpression') &&
			(node.callee.object.type === 'Identifier') &&
			(node.callee.object.name === 'require');
	}

	function removeCalls(source) {
		const entries = [];
		esprima.parseScript(source, {}, function(node, meta) {
			if (isRequireCall(node)) {
				entries.push({
					start: meta.start.offset,
					end: meta.end.offset
				});
			}
		});
		entries.sort((a, b) => { return b.end - a.end }).forEach(n => {
			source = source.slice(0, n.start) + source.slice(n.end);
		});
		return source;
	}

	removeCalls(strategy.toString());

}

//Returns to the user an array of all registered strategies. TODO: have this mirror PlayerList, to provide functionality like onlyAlive and scoresObject.
function Strategies() {
	var strategies = [];
	for (var strategy in registry.strategies) strategies.push(strategy);
	return strategies;
};

// Fetch the descriptions of the strategies.
Strategies.descriptions = function() {
	var strategies = {};
	for (var strategy in registry.strategies) strategies[strategy] = registry.strategies[strategy].description;
	return strategies;
}


// A built-in debugging strategy. Calling this function loads the strategy.
// The strategy just calles 'debugger' when asked to choose.
Strategies.debugger = function() {
	registerStrategy(function() {
		this.choose = function(options, information) {
			debugger;
		}
	}, "debugger")
	return "debugger"
}

Strategies.logger = function() {
	registerStrategy(function() {
		this.choose = function(options, information) {
			console.log("Options: ", options);
			console.log("Information: ", information)
		}
	}, "logger")
	return "logger"
}

module.exports = { registerStrategy, registerStrategyObject, Strategies };

},{"./helper-functions":8,"./logger":18,"./state":42,"esprima":51}],45:[function(require,module,exports){
'use strict';
module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};

},{}],46:[function(require,module,exports){
'use strict';

function assembleStyles () {
	var styles = {
		modifiers: {
			reset: [0, 0],
			bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		colors: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39]
		},
		bgColors: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49]
		}
	};

	// fix humans
	styles.colors.grey = styles.colors.gray;

	Object.keys(styles).forEach(function (groupName) {
		var group = styles[groupName];

		Object.keys(group).forEach(function (styleName) {
			var style = group[styleName];

			styles[styleName] = group[styleName] = {
				open: '\u001b[' + style[0] + 'm',
				close: '\u001b[' + style[1] + 'm'
			};
		});

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	});

	return styles;
}

Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});

},{}],47:[function(require,module,exports){
(function (process,global){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.async = global.async || {})));
}(this, (function (exports) { 'use strict';

function slice(arrayLike, start) {
    start = start|0;
    var newLen = Math.max(arrayLike.length - start, 0);
    var newArr = Array(newLen);
    for(var idx = 0; idx < newLen; idx++)  {
        newArr[idx] = arrayLike[start + idx];
    }
    return newArr;
}

/**
 * Creates a continuation function with some arguments already applied.
 *
 * Useful as a shorthand when combined with other control flow functions. Any
 * arguments passed to the returned function are added to the arguments
 * originally passed to apply.
 *
 * @name apply
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {Function} fn - The function you want to eventually apply all
 * arguments to. Invokes with (arguments...).
 * @param {...*} arguments... - Any number of arguments to automatically apply
 * when the continuation is called.
 * @returns {Function} the partially-applied function
 * @example
 *
 * // using apply
 * async.parallel([
 *     async.apply(fs.writeFile, 'testfile1', 'test1'),
 *     async.apply(fs.writeFile, 'testfile2', 'test2')
 * ]);
 *
 *
 * // the same process without using apply
 * async.parallel([
 *     function(callback) {
 *         fs.writeFile('testfile1', 'test1', callback);
 *     },
 *     function(callback) {
 *         fs.writeFile('testfile2', 'test2', callback);
 *     }
 * ]);
 *
 * // It's possible to pass any number of additional arguments when calling the
 * // continuation:
 *
 * node> var fn = async.apply(sys.puts, 'one');
 * node> fn('two', 'three');
 * one
 * two
 * three
 */
var apply = function(fn/*, ...args*/) {
    var args = slice(arguments, 1);
    return function(/*callArgs*/) {
        var callArgs = slice(arguments);
        return fn.apply(null, args.concat(callArgs));
    };
};

var initialParams = function (fn) {
    return function (/*...args, callback*/) {
        var args = slice(arguments);
        var callback = args.pop();
        fn.call(this, args, callback);
    };
};

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
var hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

function fallback(fn) {
    setTimeout(fn, 0);
}

function wrap(defer) {
    return function (fn/*, ...args*/) {
        var args = slice(arguments, 1);
        defer(function () {
            fn.apply(null, args);
        });
    };
}

var _defer;

if (hasSetImmediate) {
    _defer = setImmediate;
} else if (hasNextTick) {
    _defer = process.nextTick;
} else {
    _defer = fallback;
}

var setImmediate$1 = wrap(_defer);

/**
 * Take a sync function and make it async, passing its return value to a
 * callback. This is useful for plugging sync functions into a waterfall,
 * series, or other async functions. Any arguments passed to the generated
 * function will be passed to the wrapped function (except for the final
 * callback argument). Errors thrown will be passed to the callback.
 *
 * If the function passed to `asyncify` returns a Promise, that promises's
 * resolved/rejected state will be used to call the callback, rather than simply
 * the synchronous return value.
 *
 * This also means you can asyncify ES2017 `async` functions.
 *
 * @name asyncify
 * @static
 * @memberOf module:Utils
 * @method
 * @alias wrapSync
 * @category Util
 * @param {Function} func - The synchronous function, or Promise-returning
 * function to convert to an {@link AsyncFunction}.
 * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
 * invoked with `(args..., callback)`.
 * @example
 *
 * // passing a regular synchronous function
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(JSON.parse),
 *     function (data, next) {
 *         // data is the result of parsing the text.
 *         // If there was a parsing error, it would have been caught.
 *     }
 * ], callback);
 *
 * // passing a function returning a promise
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(function (contents) {
 *         return db.model.create(contents);
 *     }),
 *     function (model, next) {
 *         // `model` is the instantiated model object.
 *         // If there was an error, this function would be skipped.
 *     }
 * ], callback);
 *
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.queue(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.push(files);
 */
function asyncify(func) {
    return initialParams(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (isObject(result) && typeof result.then === 'function') {
            result.then(function(value) {
                invokeCallback(callback, null, value);
            }, function(err) {
                invokeCallback(callback, err.message ? err : new Error(err));
            });
        } else {
            callback(null, result);
        }
    });
}

function invokeCallback(callback, error, value) {
    try {
        callback(error, value);
    } catch (e) {
        setImmediate$1(rethrow, e);
    }
}

function rethrow(error) {
    throw error;
}

var supportsSymbol = typeof Symbol === 'function';

function isAsync(fn) {
    return supportsSymbol && fn[Symbol.toStringTag] === 'AsyncFunction';
}

function wrapAsync(asyncFn) {
    return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
}

function applyEach$1(eachfn) {
    return function(fns/*, ...args*/) {
        var args = slice(arguments, 1);
        var go = initialParams(function(args, callback) {
            var that = this;
            return eachfn(fns, function (fn, cb) {
                wrapAsync(fn).apply(that, args.concat(cb));
            }, callback);
        });
        if (args.length) {
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
}

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */
var Symbol$1 = root.Symbol;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$1.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]';
var undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]';
var funcTag = '[object Function]';
var genTag = '[object GeneratorFunction]';
var proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

// A temporary value used to identify if the loop should be broken.
// See #1064, #1293
var breakLoop = {};

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

function once(fn) {
    return function () {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}

var iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;

var getIterator = function (coll) {
    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
};

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]';
var arrayTag = '[object Array]';
var boolTag = '[object Boolean]';
var dateTag = '[object Date]';
var errorTag = '[object Error]';
var funcTag$1 = '[object Function]';
var mapTag = '[object Map]';
var numberTag = '[object Number]';
var objectTag = '[object Object]';
var regexpTag = '[object RegExp]';
var setTag = '[object Set]';
var stringTag = '[object String]';
var weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]';
var dataViewTag = '[object DataView]';
var float32Tag = '[object Float32Array]';
var float64Tag = '[object Float64Array]';
var int8Tag = '[object Int8Array]';
var int16Tag = '[object Int16Array]';
var int32Tag = '[object Int32Array]';
var uint8Tag = '[object Uint8Array]';
var uint8ClampedTag = '[object Uint8ClampedArray]';
var uint16Tag = '[object Uint16Array]';
var uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports$1 && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$1.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;

  return value === proto;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$3.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

function createArrayIterator(coll) {
    var i = -1;
    var len = coll.length;
    return function next() {
        return ++i < len ? {value: coll[i], key: i} : null;
    }
}

function createES2015Iterator(iterator) {
    var i = -1;
    return function next() {
        var item = iterator.next();
        if (item.done)
            return null;
        i++;
        return {value: item.value, key: i};
    }
}

function createObjectIterator(obj) {
    var okeys = keys(obj);
    var i = -1;
    var len = okeys.length;
    return function next() {
        var key = okeys[++i];
        return i < len ? {value: obj[key], key: key} : null;
    };
}

function iterator(coll) {
    if (isArrayLike(coll)) {
        return createArrayIterator(coll);
    }

    var iterator = getIterator(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
}

function onlyOnce(fn) {
    return function() {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}

function _eachOfLimit(limit) {
    return function (obj, iteratee, callback) {
        callback = once(callback || noop);
        if (limit <= 0 || !obj) {
            return callback(null);
        }
        var nextElem = iterator(obj);
        var done = false;
        var running = 0;
        var looping = false;

        function iterateeCallback(err, value) {
            running -= 1;
            if (err) {
                done = true;
                callback(err);
            }
            else if (value === breakLoop || (done && running <= 0)) {
                done = true;
                return callback(null);
            }
            else if (!looping) {
                replenish();
            }
        }

        function replenish () {
            looping = true;
            while (running < limit && !done) {
                var elem = nextElem();
                if (elem === null) {
                    done = true;
                    if (running <= 0) {
                        callback(null);
                    }
                    return;
                }
                running += 1;
                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
            }
            looping = false;
        }

        replenish();
    };
}

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name eachOfLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 */
function eachOfLimit(coll, limit, iteratee, callback) {
    _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
}

function doLimit(fn, limit) {
    return function (iterable, iteratee, callback) {
        return fn(iterable, limit, iteratee, callback);
    };
}

// eachOf implementation optimized for array-likes
function eachOfArrayLike(coll, iteratee, callback) {
    callback = once(callback || noop);
    var index = 0,
        completed = 0,
        length = coll.length;
    if (length === 0) {
        callback(null);
    }

    function iteratorCallback(err, value) {
        if (err) {
            callback(err);
        } else if ((++completed === length) || value === breakLoop) {
            callback(null);
        }
    }

    for (; index < length; index++) {
        iteratee(coll[index], index, onlyOnce(iteratorCallback));
    }
}

// a generic version of eachOf which can handle array, object, and iterator cases.
var eachOfGeneric = doLimit(eachOfLimit, Infinity);

/**
 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
 * to the iteratee.
 *
 * @name eachOf
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEachOf
 * @category Collection
 * @see [async.each]{@link module:Collections.each}
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each
 * item in `coll`.
 * The `key` is the item's key, or index in the case of an array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @example
 *
 * var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
 * var configs = {};
 *
 * async.forEachOf(obj, function (value, key, callback) {
 *     fs.readFile(__dirname + value, "utf8", function (err, data) {
 *         if (err) return callback(err);
 *         try {
 *             configs[key] = JSON.parse(data);
 *         } catch (e) {
 *             return callback(e);
 *         }
 *         callback();
 *     });
 * }, function (err) {
 *     if (err) console.error(err.message);
 *     // configs is now a map of JSON data
 *     doSomethingWith(configs);
 * });
 */
var eachOf = function(coll, iteratee, callback) {
    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
    eachOfImplementation(coll, wrapAsync(iteratee), callback);
};

function doParallel(fn) {
    return function (obj, iteratee, callback) {
        return fn(eachOf, obj, wrapAsync(iteratee), callback);
    };
}

function _asyncMap(eachfn, arr, iteratee, callback) {
    callback = callback || noop;
    arr = arr || [];
    var results = [];
    var counter = 0;
    var _iteratee = wrapAsync(iteratee);

    eachfn(arr, function (value, _, callback) {
        var index = counter++;
        _iteratee(value, function (err, v) {
            results[index] = v;
            callback(err);
        });
    }, function (err) {
        callback(err, results);
    });
}

/**
 * Produces a new collection of values by mapping each value in `coll` through
 * the `iteratee` function. The `iteratee` is called with an item from `coll`
 * and a callback for when it has finished processing. Each of these callback
 * takes 2 arguments: an `error`, and the transformed item from `coll`. If
 * `iteratee` passes an error to its callback, the main `callback` (for the
 * `map` function) is immediately called with the error.
 *
 * Note, that since this function applies the `iteratee` to each item in
 * parallel, there is no guarantee that the `iteratee` functions will complete
 * in order. However, the results array will be in the same order as the
 * original `coll`.
 *
 * If `map` is passed an Object, the results will be an Array.  The results
 * will roughly be in the order of the original Objects' keys (but this can
 * vary across JavaScript engines).
 *
 * @name map
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an Array of the
 * transformed items from the `coll`. Invoked with (err, results).
 * @example
 *
 * async.map(['file1','file2','file3'], fs.stat, function(err, results) {
 *     // results is now an array of stats for each file
 * });
 */
var map = doParallel(_asyncMap);

/**
 * Applies the provided arguments to each function in the array, calling
 * `callback` after all functions have completed. If you only provide the first
 * argument, `fns`, then it will return a function which lets you pass in the
 * arguments as if it were a single function call. If more arguments are
 * provided, `callback` is required while `args` is still optional.
 *
 * @name applyEach
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s
 * to all call with the same arguments
 * @param {...*} [args] - any number of separate arguments to pass to the
 * function.
 * @param {Function} [callback] - the final argument should be the callback,
 * called when all functions have completed processing.
 * @returns {Function} - If only the first argument, `fns`, is provided, it will
 * return a function which lets you pass in the arguments as if it were a single
 * function call. The signature is `(..args, callback)`. If invoked with any
 * arguments, `callback` is required.
 * @example
 *
 * async.applyEach([enableSearch, updateSchema], 'bucket', callback);
 *
 * // partial application example:
 * async.each(
 *     buckets,
 *     async.applyEach([enableSearch, updateSchema]),
 *     callback
 * );
 */
var applyEach = applyEach$1(map);

function doParallelLimit(fn) {
    return function (obj, limit, iteratee, callback) {
        return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
    };
}

/**
 * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.
 *
 * @name mapLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.map]{@link module:Collections.map}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an array of the
 * transformed items from the `coll`. Invoked with (err, results).
 */
var mapLimit = doParallelLimit(_asyncMap);

/**
 * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.
 *
 * @name mapSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.map]{@link module:Collections.map}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an array of the
 * transformed items from the `coll`. Invoked with (err, results).
 */
var mapSeries = doLimit(mapLimit, 1);

/**
 * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.
 *
 * @name applyEachSeries
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.applyEach]{@link module:ControlFlow.applyEach}
 * @category Control Flow
 * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s to all
 * call with the same arguments
 * @param {...*} [args] - any number of separate arguments to pass to the
 * function.
 * @param {Function} [callback] - the final argument should be the callback,
 * called when all functions have completed processing.
 * @returns {Function} - If only the first argument is provided, it will return
 * a function which lets you pass in the arguments as if it were a single
 * function call.
 */
var applyEachSeries = applyEach$1(mapSeries);

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

/**
 * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on
 * their requirements. Each function can optionally depend on other functions
 * being completed first, and each function is run as soon as its requirements
 * are satisfied.
 *
 * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence
 * will stop. Further tasks will not execute (so any other functions depending
 * on it will not run), and the main `callback` is immediately called with the
 * error.
 *
 * {@link AsyncFunction}s also receive an object containing the results of functions which
 * have completed so far as the first argument, if they have dependencies. If a
 * task function has no dependencies, it will only be passed a callback.
 *
 * @name auto
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Object} tasks - An object. Each of its properties is either a
 * function or an array of requirements, with the {@link AsyncFunction} itself the last item
 * in the array. The object's key of a property serves as the name of the task
 * defined by that property, i.e. can be used when specifying requirements for
 * other tasks. The function receives one or two arguments:
 * * a `results` object, containing the results of the previously executed
 *   functions, only passed if the task has any dependencies,
 * * a `callback(err, result)` function, which must be called when finished,
 *   passing an `error` (which can be `null`) and the result of the function's
 *   execution.
 * @param {number} [concurrency=Infinity] - An optional `integer` for
 * determining the maximum number of tasks that can be run in parallel. By
 * default, as many as possible.
 * @param {Function} [callback] - An optional callback which is called when all
 * the tasks have been completed. It receives the `err` argument if any `tasks`
 * pass an error to their callback. Results are always returned; however, if an
 * error occurs, no further `tasks` will be performed, and the results object
 * will only contain partial results. Invoked with (err, results).
 * @returns undefined
 * @example
 *
 * async.auto({
 *     // this function will just be passed a callback
 *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),
 *     showData: ['readData', function(results, cb) {
 *         // results.readData is the file's contents
 *         // ...
 *     }]
 * }, callback);
 *
 * async.auto({
 *     get_data: function(callback) {
 *         console.log('in get_data');
 *         // async code to get some data
 *         callback(null, 'data', 'converted to array');
 *     },
 *     make_folder: function(callback) {
 *         console.log('in make_folder');
 *         // async code to create a directory to store a file in
 *         // this is run at the same time as getting the data
 *         callback(null, 'folder');
 *     },
 *     write_file: ['get_data', 'make_folder', function(results, callback) {
 *         console.log('in write_file', JSON.stringify(results));
 *         // once there is some data and the directory exists,
 *         // write the data to a file in the directory
 *         callback(null, 'filename');
 *     }],
 *     email_link: ['write_file', function(results, callback) {
 *         console.log('in email_link', JSON.stringify(results));
 *         // once the file is written let's email a link to it...
 *         // results.write_file contains the filename returned by write_file.
 *         callback(null, {'file':results.write_file, 'email':'user@example.com'});
 *     }]
 * }, function(err, results) {
 *     console.log('err = ', err);
 *     console.log('results = ', results);
 * });
 */
var auto = function (tasks, concurrency, callback) {
    if (typeof concurrency === 'function') {
        // concurrency is optional, shift the args.
        callback = concurrency;
        concurrency = null;
    }
    callback = once(callback || noop);
    var keys$$1 = keys(tasks);
    var numTasks = keys$$1.length;
    if (!numTasks) {
        return callback(null);
    }
    if (!concurrency) {
        concurrency = numTasks;
    }

    var results = {};
    var runningTasks = 0;
    var hasError = false;

    var listeners = Object.create(null);

    var readyTasks = [];

    // for cycle detection:
    var readyToCheck = []; // tasks that have been identified as reachable
    // without the possibility of returning to an ancestor task
    var uncheckedDependencies = {};

    baseForOwn(tasks, function (task, key) {
        if (!isArray(task)) {
            // no dependencies
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
        }

        var dependencies = task.slice(0, task.length - 1);
        var remainingDependencies = dependencies.length;
        if (remainingDependencies === 0) {
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
        }
        uncheckedDependencies[key] = remainingDependencies;

        arrayEach(dependencies, function (dependencyName) {
            if (!tasks[dependencyName]) {
                throw new Error('async.auto task `' + key +
                    '` has a non-existent dependency `' +
                    dependencyName + '` in ' +
                    dependencies.join(', '));
            }
            addListener(dependencyName, function () {
                remainingDependencies--;
                if (remainingDependencies === 0) {
                    enqueueTask(key, task);
                }
            });
        });
    });

    checkForDeadlocks();
    processQueue();

    function enqueueTask(key, task) {
        readyTasks.push(function () {
            runTask(key, task);
        });
    }

    function processQueue() {
        if (readyTasks.length === 0 && runningTasks === 0) {
            return callback(null, results);
        }
        while(readyTasks.length && runningTasks < concurrency) {
            var run = readyTasks.shift();
            run();
        }

    }

    function addListener(taskName, fn) {
        var taskListeners = listeners[taskName];
        if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
        }

        taskListeners.push(fn);
    }

    function taskComplete(taskName) {
        var taskListeners = listeners[taskName] || [];
        arrayEach(taskListeners, function (fn) {
            fn();
        });
        processQueue();
    }


    function runTask(key, task) {
        if (hasError) return;

        var taskCallback = onlyOnce(function(err, result) {
            runningTasks--;
            if (arguments.length > 2) {
                result = slice(arguments, 1);
            }
            if (err) {
                var safeResults = {};
                baseForOwn(results, function(val, rkey) {
                    safeResults[rkey] = val;
                });
                safeResults[key] = result;
                hasError = true;
                listeners = Object.create(null);

                callback(err, safeResults);
            } else {
                results[key] = result;
                taskComplete(key);
            }
        });

        runningTasks++;
        var taskFn = wrapAsync(task[task.length - 1]);
        if (task.length > 1) {
            taskFn(results, taskCallback);
        } else {
            taskFn(taskCallback);
        }
    }

    function checkForDeadlocks() {
        // Kahn's algorithm
        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
        var currentTask;
        var counter = 0;
        while (readyToCheck.length) {
            currentTask = readyToCheck.pop();
            counter++;
            arrayEach(getDependents(currentTask), function (dependent) {
                if (--uncheckedDependencies[dependent] === 0) {
                    readyToCheck.push(dependent);
                }
            });
        }

        if (counter !== numTasks) {
            throw new Error(
                'async.auto cannot execute tasks due to a recursive dependency'
            );
        }
    }

    function getDependents(taskName) {
        var result = [];
        baseForOwn(tasks, function (task, key) {
            if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {
                result.push(key);
            }
        });
        return result;
    }
};

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined;
var symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the last unmatched string symbol.
 */
function charsEndIndex(strSymbols, chrSymbols) {
  var index = strSymbols.length;

  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

/**
 * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the first unmatched string symbol.
 */
function charsStartIndex(strSymbols, chrSymbols) {
  var index = -1,
      length = strSymbols.length;

  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff';
var rsComboMarksRange = '\\u0300-\\u036f';
var reComboHalfMarksRange = '\\ufe20-\\ufe2f';
var rsComboSymbolsRange = '\\u20d0-\\u20ff';
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

/** Used to compose unicode character classes. */
var rsAstralRange$1 = '\\ud800-\\udfff';
var rsComboMarksRange$1 = '\\u0300-\\u036f';
var reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f';
var rsComboSymbolsRange$1 = '\\u20d0-\\u20ff';
var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
var rsVarRange$1 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange$1 + ']';
var rsCombo = '[' + rsComboRange$1 + ']';
var rsFitz = '\\ud83c[\\udffb-\\udfff]';
var rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';
var rsNonAstral = '[^' + rsAstralRange$1 + ']';
var rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}';
var rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]';
var rsZWJ$1 = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?';
var rsOptVar = '[' + rsVarRange$1 + ']?';
var rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/**
 * Removes leading and trailing whitespace or specified characters from `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the trimmed string.
 * @example
 *
 * _.trim('  abc  ');
 * // => 'abc'
 *
 * _.trim('-_-abc-_-', '_-');
 * // => 'abc'
 *
 * _.map(['  foo  ', '  bar  '], _.trim);
 * // => ['foo', 'bar']
 */
function trim(string, chars, guard) {
  string = toString(string);
  if (string && (guard || chars === undefined)) {
    return string.replace(reTrim, '');
  }
  if (!string || !(chars = baseToString(chars))) {
    return string;
  }
  var strSymbols = stringToArray(string),
      chrSymbols = stringToArray(chars),
      start = charsStartIndex(strSymbols, chrSymbols),
      end = charsEndIndex(strSymbols, chrSymbols) + 1;

  return castSlice(strSymbols, start, end).join('');
}

var FN_ARGS = /^(?:async\s+)?(function)?\s*[^\(]*\(\s*([^\)]*)\)/m;
var FN_ARG_SPLIT = /,/;
var FN_ARG = /(=.+)?(\s*)$/;
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;

function parseParams(func) {
    func = func.toString().replace(STRIP_COMMENTS, '');
    func = func.match(FN_ARGS)[2].replace(' ', '');
    func = func ? func.split(FN_ARG_SPLIT) : [];
    func = func.map(function (arg){
        return trim(arg.replace(FN_ARG, ''));
    });
    return func;
}

/**
 * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent
 * tasks are specified as parameters to the function, after the usual callback
 * parameter, with the parameter names matching the names of the tasks it
 * depends on. This can provide even more readable task graphs which can be
 * easier to maintain.
 *
 * If a final callback is specified, the task results are similarly injected,
 * specified as named parameters after the initial error parameter.
 *
 * The autoInject function is purely syntactic sugar and its semantics are
 * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.
 *
 * @name autoInject
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.auto]{@link module:ControlFlow.auto}
 * @category Control Flow
 * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of
 * the form 'func([dependencies...], callback). The object's key of a property
 * serves as the name of the task defined by that property, i.e. can be used
 * when specifying requirements for other tasks.
 * * The `callback` parameter is a `callback(err, result)` which must be called
 *   when finished, passing an `error` (which can be `null`) and the result of
 *   the function's execution. The remaining parameters name other tasks on
 *   which the task is dependent, and the results from those tasks are the
 *   arguments of those parameters.
 * @param {Function} [callback] - An optional callback which is called when all
 * the tasks have been completed. It receives the `err` argument if any `tasks`
 * pass an error to their callback, and a `results` object with any completed
 * task results, similar to `auto`.
 * @example
 *
 * //  The example from `auto` can be rewritten as follows:
 * async.autoInject({
 *     get_data: function(callback) {
 *         // async code to get some data
 *         callback(null, 'data', 'converted to array');
 *     },
 *     make_folder: function(callback) {
 *         // async code to create a directory to store a file in
 *         // this is run at the same time as getting the data
 *         callback(null, 'folder');
 *     },
 *     write_file: function(get_data, make_folder, callback) {
 *         // once there is some data and the directory exists,
 *         // write the data to a file in the directory
 *         callback(null, 'filename');
 *     },
 *     email_link: function(write_file, callback) {
 *         // once the file is written let's email a link to it...
 *         // write_file contains the filename returned by write_file.
 *         callback(null, {'file':write_file, 'email':'user@example.com'});
 *     }
 * }, function(err, results) {
 *     console.log('err = ', err);
 *     console.log('email_link = ', results.email_link);
 * });
 *
 * // If you are using a JS minifier that mangles parameter names, `autoInject`
 * // will not work with plain functions, since the parameter names will be
 * // collapsed to a single letter identifier.  To work around this, you can
 * // explicitly specify the names of the parameters your task function needs
 * // in an array, similar to Angular.js dependency injection.
 *
 * // This still has an advantage over plain `auto`, since the results a task
 * // depends on are still spread into arguments.
 * async.autoInject({
 *     //...
 *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {
 *         callback(null, 'filename');
 *     }],
 *     email_link: ['write_file', function(write_file, callback) {
 *         callback(null, {'file':write_file, 'email':'user@example.com'});
 *     }]
 *     //...
 * }, function(err, results) {
 *     console.log('err = ', err);
 *     console.log('email_link = ', results.email_link);
 * });
 */
function autoInject(tasks, callback) {
    var newTasks = {};

    baseForOwn(tasks, function (taskFn, key) {
        var params;
        var fnIsAsync = isAsync(taskFn);
        var hasNoDeps =
            (!fnIsAsync && taskFn.length === 1) ||
            (fnIsAsync && taskFn.length === 0);

        if (isArray(taskFn)) {
            params = taskFn.slice(0, -1);
            taskFn = taskFn[taskFn.length - 1];

            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
        } else if (hasNoDeps) {
            // no dependencies, use the function as-is
            newTasks[key] = taskFn;
        } else {
            params = parseParams(taskFn);
            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
                throw new Error("autoInject task functions require explicit parameters.");
            }

            // remove callback param
            if (!fnIsAsync) params.pop();

            newTasks[key] = params.concat(newTask);
        }

        function newTask(results, taskCb) {
            var newArgs = arrayMap(params, function (name) {
                return results[name];
            });
            newArgs.push(taskCb);
            wrapAsync(taskFn).apply(null, newArgs);
        }
    });

    auto(newTasks, callback);
}

// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation
// used for queues. This implementation assumes that the node provided by the user can be modified
// to adjust the next and last properties. We implement only the minimal functionality
// for queue support.
function DLL() {
    this.head = this.tail = null;
    this.length = 0;
}

function setInitial(dll, node) {
    dll.length = 1;
    dll.head = dll.tail = node;
}

DLL.prototype.removeLink = function(node) {
    if (node.prev) node.prev.next = node.next;
    else this.head = node.next;
    if (node.next) node.next.prev = node.prev;
    else this.tail = node.prev;

    node.prev = node.next = null;
    this.length -= 1;
    return node;
};

DLL.prototype.empty = function () {
    while(this.head) this.shift();
    return this;
};

DLL.prototype.insertAfter = function(node, newNode) {
    newNode.prev = node;
    newNode.next = node.next;
    if (node.next) node.next.prev = newNode;
    else this.tail = newNode;
    node.next = newNode;
    this.length += 1;
};

DLL.prototype.insertBefore = function(node, newNode) {
    newNode.prev = node.prev;
    newNode.next = node;
    if (node.prev) node.prev.next = newNode;
    else this.head = newNode;
    node.prev = newNode;
    this.length += 1;
};

DLL.prototype.unshift = function(node) {
    if (this.head) this.insertBefore(this.head, node);
    else setInitial(this, node);
};

DLL.prototype.push = function(node) {
    if (this.tail) this.insertAfter(this.tail, node);
    else setInitial(this, node);
};

DLL.prototype.shift = function() {
    return this.head && this.removeLink(this.head);
};

DLL.prototype.pop = function() {
    return this.tail && this.removeLink(this.tail);
};

DLL.prototype.toArray = function () {
    var arr = Array(this.length);
    var curr = this.head;
    for(var idx = 0; idx < this.length; idx++) {
        arr[idx] = curr.data;
        curr = curr.next;
    }
    return arr;
};

DLL.prototype.remove = function (testFn) {
    var curr = this.head;
    while(!!curr) {
        var next = curr.next;
        if (testFn(curr)) {
            this.removeLink(curr);
        }
        curr = next;
    }
    return this;
};

function queue(worker, concurrency, payload) {
    if (concurrency == null) {
        concurrency = 1;
    }
    else if(concurrency === 0) {
        throw new Error('Concurrency must not be zero');
    }

    var _worker = wrapAsync(worker);
    var numRunning = 0;
    var workersList = [];

    var processingScheduled = false;
    function _insert(data, insertAtFront, callback) {
        if (callback != null && typeof callback !== 'function') {
            throw new Error('task callback must be a function');
        }
        q.started = true;
        if (!isArray(data)) {
            data = [data];
        }
        if (data.length === 0 && q.idle()) {
            // call drain immediately if there are no tasks
            return setImmediate$1(function() {
                q.drain();
            });
        }

        for (var i = 0, l = data.length; i < l; i++) {
            var item = {
                data: data[i],
                callback: callback || noop
            };

            if (insertAtFront) {
                q._tasks.unshift(item);
            } else {
                q._tasks.push(item);
            }
        }

        if (!processingScheduled) {
            processingScheduled = true;
            setImmediate$1(function() {
                processingScheduled = false;
                q.process();
            });
        }
    }

    function _next(tasks) {
        return function(err){
            numRunning -= 1;

            for (var i = 0, l = tasks.length; i < l; i++) {
                var task = tasks[i];

                var index = baseIndexOf(workersList, task, 0);
                if (index === 0) {
                    workersList.shift();
                } else if (index > 0) {
                    workersList.splice(index, 1);
                }

                task.callback.apply(task, arguments);

                if (err != null) {
                    q.error(err, task.data);
                }
            }

            if (numRunning <= (q.concurrency - q.buffer) ) {
                q.unsaturated();
            }

            if (q.idle()) {
                q.drain();
            }
            q.process();
        };
    }

    var isProcessing = false;
    var q = {
        _tasks: new DLL(),
        concurrency: concurrency,
        payload: payload,
        saturated: noop,
        unsaturated:noop,
        buffer: concurrency / 4,
        empty: noop,
        drain: noop,
        error: noop,
        started: false,
        paused: false,
        push: function (data, callback) {
            _insert(data, false, callback);
        },
        kill: function () {
            q.drain = noop;
            q._tasks.empty();
        },
        unshift: function (data, callback) {
            _insert(data, true, callback);
        },
        remove: function (testFn) {
            q._tasks.remove(testFn);
        },
        process: function () {
            // Avoid trying to start too many processing operations. This can occur
            // when callbacks resolve synchronously (#1267).
            if (isProcessing) {
                return;
            }
            isProcessing = true;
            while(!q.paused && numRunning < q.concurrency && q._tasks.length){
                var tasks = [], data = [];
                var l = q._tasks.length;
                if (q.payload) l = Math.min(l, q.payload);
                for (var i = 0; i < l; i++) {
                    var node = q._tasks.shift();
                    tasks.push(node);
                    workersList.push(node);
                    data.push(node.data);
                }

                numRunning += 1;

                if (q._tasks.length === 0) {
                    q.empty();
                }

                if (numRunning === q.concurrency) {
                    q.saturated();
                }

                var cb = onlyOnce(_next(tasks));
                _worker(data, cb);
            }
            isProcessing = false;
        },
        length: function () {
            return q._tasks.length;
        },
        running: function () {
            return numRunning;
        },
        workersList: function () {
            return workersList;
        },
        idle: function() {
            return q._tasks.length + numRunning === 0;
        },
        pause: function () {
            q.paused = true;
        },
        resume: function () {
            if (q.paused === false) { return; }
            q.paused = false;
            setImmediate$1(q.process);
        }
    };
    return q;
}

/**
 * A cargo of tasks for the worker function to complete. Cargo inherits all of
 * the same methods and event callbacks as [`queue`]{@link module:ControlFlow.queue}.
 * @typedef {Object} CargoObject
 * @memberOf module:ControlFlow
 * @property {Function} length - A function returning the number of items
 * waiting to be processed. Invoke like `cargo.length()`.
 * @property {number} payload - An `integer` for determining how many tasks
 * should be process per round. This property can be changed after a `cargo` is
 * created to alter the payload on-the-fly.
 * @property {Function} push - Adds `task` to the `queue`. The callback is
 * called once the `worker` has finished processing the task. Instead of a
 * single task, an array of `tasks` can be submitted. The respective callback is
 * used for every task in the list. Invoke like `cargo.push(task, [callback])`.
 * @property {Function} saturated - A callback that is called when the
 * `queue.length()` hits the concurrency and further tasks will be queued.
 * @property {Function} empty - A callback that is called when the last item
 * from the `queue` is given to a `worker`.
 * @property {Function} drain - A callback that is called when the last item
 * from the `queue` has returned from the `worker`.
 * @property {Function} idle - a function returning false if there are items
 * waiting or being processed, or true if not. Invoke like `cargo.idle()`.
 * @property {Function} pause - a function that pauses the processing of tasks
 * until `resume()` is called. Invoke like `cargo.pause()`.
 * @property {Function} resume - a function that resumes the processing of
 * queued tasks when the queue is paused. Invoke like `cargo.resume()`.
 * @property {Function} kill - a function that removes the `drain` callback and
 * empties remaining tasks from the queue forcing it to go idle. Invoke like `cargo.kill()`.
 */

/**
 * Creates a `cargo` object with the specified payload. Tasks added to the
 * cargo will be processed altogether (up to the `payload` limit). If the
 * `worker` is in progress, the task is queued until it becomes available. Once
 * the `worker` has completed some tasks, each callback of those tasks is
 * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
 * for how `cargo` and `queue` work.
 *
 * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers
 * at a time, cargo passes an array of tasks to a single worker, repeating
 * when the worker is finished.
 *
 * @name cargo
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.queue]{@link module:ControlFlow.queue}
 * @category Control Flow
 * @param {AsyncFunction} worker - An asynchronous function for processing an array
 * of queued tasks. Invoked with `(tasks, callback)`.
 * @param {number} [payload=Infinity] - An optional `integer` for determining
 * how many tasks should be processed per round; if omitted, the default is
 * unlimited.
 * @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can
 * attached as certain properties to listen for specific events during the
 * lifecycle of the cargo and inner queue.
 * @example
 *
 * // create a cargo object with payload 2
 * var cargo = async.cargo(function(tasks, callback) {
 *     for (var i=0; i<tasks.length; i++) {
 *         console.log('hello ' + tasks[i].name);
 *     }
 *     callback();
 * }, 2);
 *
 * // add some items
 * cargo.push({name: 'foo'}, function(err) {
 *     console.log('finished processing foo');
 * });
 * cargo.push({name: 'bar'}, function(err) {
 *     console.log('finished processing bar');
 * });
 * cargo.push({name: 'baz'}, function(err) {
 *     console.log('finished processing baz');
 * });
 */
function cargo(worker, payload) {
    return queue(worker, 1, payload);
}

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
 *
 * @name eachOfSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfSeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Invoked with (err).
 */
var eachOfSeries = doLimit(eachOfLimit, 1);

/**
 * Reduces `coll` into a single value using an async `iteratee` to return each
 * successive step. `memo` is the initial state of the reduction. This function
 * only operates in series.
 *
 * For performance reasons, it may make sense to split a call to this function
 * into a parallel map, and then use the normal `Array.prototype.reduce` on the
 * results. This function is for situations where each step in the reduction
 * needs to be async; if you can get the data before reducing it, then it's
 * probably a good idea to do so.
 *
 * @name reduce
 * @static
 * @memberOf module:Collections
 * @method
 * @alias inject
 * @alias foldl
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {*} memo - The initial state of the reduction.
 * @param {AsyncFunction} iteratee - A function applied to each item in the
 * array to produce the next step in the reduction.
 * The `iteratee` should complete with the next state of the reduction.
 * If the iteratee complete with an error, the reduction is stopped and the
 * main `callback` is immediately called with the error.
 * Invoked with (memo, item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the reduced value. Invoked with
 * (err, result).
 * @example
 *
 * async.reduce([1,2,3], 0, function(memo, item, callback) {
 *     // pointless async:
 *     process.nextTick(function() {
 *         callback(null, memo + item)
 *     });
 * }, function(err, result) {
 *     // result is now equal to the last value of memo, which is 6
 * });
 */
function reduce(coll, memo, iteratee, callback) {
    callback = once(callback || noop);
    var _iteratee = wrapAsync(iteratee);
    eachOfSeries(coll, function(x, i, callback) {
        _iteratee(memo, x, function(err, v) {
            memo = v;
            callback(err);
        });
    }, function(err) {
        callback(err, memo);
    });
}

/**
 * Version of the compose function that is more natural to read. Each function
 * consumes the return value of the previous function. It is the equivalent of
 * [compose]{@link module:ControlFlow.compose} with the arguments reversed.
 *
 * Each function is executed with the `this` binding of the composed function.
 *
 * @name seq
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.compose]{@link module:ControlFlow.compose}
 * @category Control Flow
 * @param {...AsyncFunction} functions - the asynchronous functions to compose
 * @returns {Function} a function that composes the `functions` in order
 * @example
 *
 * // Requires lodash (or underscore), express3 and dresende's orm2.
 * // Part of an app, that fetches cats of the logged user.
 * // This example uses `seq` function to avoid overnesting and error
 * // handling clutter.
 * app.get('/cats', function(request, response) {
 *     var User = request.models.User;
 *     async.seq(
 *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))
 *         function(user, fn) {
 *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))
 *         }
 *     )(req.session.user_id, function (err, cats) {
 *         if (err) {
 *             console.error(err);
 *             response.json({ status: 'error', message: err.message });
 *         } else {
 *             response.json({ status: 'ok', message: 'Cats found', data: cats });
 *         }
 *     });
 * });
 */
function seq(/*...functions*/) {
    var _functions = arrayMap(arguments, wrapAsync);
    return function(/*...args*/) {
        var args = slice(arguments);
        var that = this;

        var cb = args[args.length - 1];
        if (typeof cb == 'function') {
            args.pop();
        } else {
            cb = noop;
        }

        reduce(_functions, args, function(newargs, fn, cb) {
            fn.apply(that, newargs.concat(function(err/*, ...nextargs*/) {
                var nextargs = slice(arguments, 1);
                cb(err, nextargs);
            }));
        },
        function(err, results) {
            cb.apply(that, [err].concat(results));
        });
    };
}

/**
 * Creates a function which is a composition of the passed asynchronous
 * functions. Each function consumes the return value of the function that
 * follows. Composing functions `f()`, `g()`, and `h()` would produce the result
 * of `f(g(h()))`, only this version uses callbacks to obtain the return values.
 *
 * Each function is executed with the `this` binding of the composed function.
 *
 * @name compose
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {...AsyncFunction} functions - the asynchronous functions to compose
 * @returns {Function} an asynchronous function that is the composed
 * asynchronous `functions`
 * @example
 *
 * function add1(n, callback) {
 *     setTimeout(function () {
 *         callback(null, n + 1);
 *     }, 10);
 * }
 *
 * function mul3(n, callback) {
 *     setTimeout(function () {
 *         callback(null, n * 3);
 *     }, 10);
 * }
 *
 * var add1mul3 = async.compose(mul3, add1);
 * add1mul3(4, function (err, result) {
 *     // result now equals 15
 * });
 */
var compose = function(/*...args*/) {
    return seq.apply(null, slice(arguments).reverse());
};

var _concat = Array.prototype.concat;

/**
 * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.
 *
 * @name concatLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.concat]{@link module:Collections.concat}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
 * which should use an array as its result. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is an array
 * containing the concatenated results of the `iteratee` function. Invoked with
 * (err, results).
 */
var concatLimit = function(coll, limit, iteratee, callback) {
    callback = callback || noop;
    var _iteratee = wrapAsync(iteratee);
    mapLimit(coll, limit, function(val, callback) {
        _iteratee(val, function(err /*, ...args*/) {
            if (err) return callback(err);
            return callback(null, slice(arguments, 1));
        });
    }, function(err, mapResults) {
        var result = [];
        for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
                result = _concat.apply(result, mapResults[i]);
            }
        }

        return callback(err, result);
    });
};

/**
 * Applies `iteratee` to each item in `coll`, concatenating the results. Returns
 * the concatenated list. The `iteratee`s are called in parallel, and the
 * results are concatenated as they return. There is no guarantee that the
 * results array will be returned in the original order of `coll` passed to the
 * `iteratee` function.
 *
 * @name concat
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
 * which should use an array as its result. Invoked with (item, callback).
 * @param {Function} [callback(err)] - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is an array
 * containing the concatenated results of the `iteratee` function. Invoked with
 * (err, results).
 * @example
 *
 * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {
 *     // files is now a list of filenames that exist in the 3 directories
 * });
 */
var concat = doLimit(concatLimit, Infinity);

/**
 * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.
 *
 * @name concatSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.concat]{@link module:Collections.concat}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.
 * The iteratee should complete with an array an array of results.
 * Invoked with (item, callback).
 * @param {Function} [callback(err)] - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is an array
 * containing the concatenated results of the `iteratee` function. Invoked with
 * (err, results).
 */
var concatSeries = doLimit(concatLimit, 1);

/**
 * Returns a function that when called, calls-back with the values provided.
 * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to
 * [`auto`]{@link module:ControlFlow.auto}.
 *
 * @name constant
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {...*} arguments... - Any number of arguments to automatically invoke
 * callback with.
 * @returns {AsyncFunction} Returns a function that when invoked, automatically
 * invokes the callback with the previous given arguments.
 * @example
 *
 * async.waterfall([
 *     async.constant(42),
 *     function (value, next) {
 *         // value === 42
 *     },
 *     //...
 * ], callback);
 *
 * async.waterfall([
 *     async.constant(filename, "utf8"),
 *     fs.readFile,
 *     function (fileData, next) {
 *         //...
 *     }
 *     //...
 * ], callback);
 *
 * async.auto({
 *     hostname: async.constant("https://server.net/"),
 *     port: findFreePort,
 *     launchServer: ["hostname", "port", function (options, cb) {
 *         startServer(options, cb);
 *     }],
 *     //...
 * }, callback);
 */
var constant = function(/*...values*/) {
    var values = slice(arguments);
    var args = [null].concat(values);
    return function (/*...ignoredArgs, callback*/) {
        var callback = arguments[arguments.length - 1];
        return callback.apply(this, args);
    };
};

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

function _createTester(check, getResult) {
    return function(eachfn, arr, iteratee, cb) {
        cb = cb || noop;
        var testPassed = false;
        var testResult;
        eachfn(arr, function(value, _, callback) {
            iteratee(value, function(err, result) {
                if (err) {
                    callback(err);
                } else if (check(result) && !testResult) {
                    testPassed = true;
                    testResult = getResult(true, value);
                    callback(null, breakLoop);
                } else {
                    callback();
                }
            });
        }, function(err) {
            if (err) {
                cb(err);
            } else {
                cb(null, testPassed ? testResult : getResult(false));
            }
        });
    };
}

function _findGetResult(v, x) {
    return x;
}

/**
 * Returns the first value in `coll` that passes an async truth test. The
 * `iteratee` is applied in parallel, meaning the first iteratee to return
 * `true` will fire the detect `callback` with that result. That means the
 * result might not be the first item in the original `coll` (in terms of order)
 * that passes the test.

 * If order within the original `coll` is important, then look at
 * [`detectSeries`]{@link module:Collections.detectSeries}.
 *
 * @name detect
 * @static
 * @memberOf module:Collections
 * @method
 * @alias find
 * @category Collections
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
 * The iteratee must complete with a boolean value as its result.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 * @example
 *
 * async.detect(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, result) {
 *     // result now equals the first file in the list that exists
 * });
 */
var detect = doParallel(_createTester(identity, _findGetResult));

/**
 * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name detectLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.detect]{@link module:Collections.detect}
 * @alias findLimit
 * @category Collections
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
 * The iteratee must complete with a boolean value as its result.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 */
var detectLimit = doParallelLimit(_createTester(identity, _findGetResult));

/**
 * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.
 *
 * @name detectSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.detect]{@link module:Collections.detect}
 * @alias findSeries
 * @category Collections
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
 * The iteratee must complete with a boolean value as its result.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 */
var detectSeries = doLimit(detectLimit, 1);

function consoleFunc(name) {
    return function (fn/*, ...args*/) {
        var args = slice(arguments, 1);
        args.push(function (err/*, ...args*/) {
            var args = slice(arguments, 1);
            if (typeof console === 'object') {
                if (err) {
                    if (console.error) {
                        console.error(err);
                    }
                } else if (console[name]) {
                    arrayEach(args, function (x) {
                        console[name](x);
                    });
                }
            }
        });
        wrapAsync(fn).apply(null, args);
    };
}

/**
 * Logs the result of an [`async` function]{@link AsyncFunction} to the
 * `console` using `console.dir` to display the properties of the resulting object.
 * Only works in Node.js or in browsers that support `console.dir` and
 * `console.error` (such as FF and Chrome).
 * If multiple arguments are returned from the async function,
 * `console.dir` is called on each argument in order.
 *
 * @name dir
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} function - The function you want to eventually apply
 * all arguments to.
 * @param {...*} arguments... - Any number of arguments to apply to the function.
 * @example
 *
 * // in a module
 * var hello = function(name, callback) {
 *     setTimeout(function() {
 *         callback(null, {hello: name});
 *     }, 1000);
 * };
 *
 * // in the node repl
 * node> async.dir(hello, 'world');
 * {hello: 'world'}
 */
var dir = consoleFunc('dir');

/**
 * The post-check version of [`during`]{@link module:ControlFlow.during}. To reflect the difference in
 * the order of operations, the arguments `test` and `fn` are switched.
 *
 * Also a version of [`doWhilst`]{@link module:ControlFlow.doWhilst} with asynchronous `test` function.
 * @name doDuring
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.during]{@link module:ControlFlow.during}
 * @category Control Flow
 * @param {AsyncFunction} fn - An async function which is called each time
 * `test` passes. Invoked with (callback).
 * @param {AsyncFunction} test - asynchronous truth test to perform before each
 * execution of `fn`. Invoked with (...args, callback), where `...args` are the
 * non-error args from the previous callback of `fn`.
 * @param {Function} [callback] - A callback which is called after the test
 * function has failed and repeated execution of `fn` has stopped. `callback`
 * will be passed an error if one occurred, otherwise `null`.
 */
function doDuring(fn, test, callback) {
    callback = onlyOnce(callback || noop);
    var _fn = wrapAsync(fn);
    var _test = wrapAsync(test);

    function next(err/*, ...args*/) {
        if (err) return callback(err);
        var args = slice(arguments, 1);
        args.push(check);
        _test.apply(this, args);
    }

    function check(err, truth) {
        if (err) return callback(err);
        if (!truth) return callback(null);
        _fn(next);
    }

    check(null, true);

}

/**
 * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in
 * the order of operations, the arguments `test` and `iteratee` are switched.
 *
 * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.
 *
 * @name doWhilst
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.whilst]{@link module:ControlFlow.whilst}
 * @category Control Flow
 * @param {AsyncFunction} iteratee - A function which is called each time `test`
 * passes. Invoked with (callback).
 * @param {Function} test - synchronous truth test to perform after each
 * execution of `iteratee`. Invoked with any non-error callback results of
 * `iteratee`.
 * @param {Function} [callback] - A callback which is called after the test
 * function has failed and repeated execution of `iteratee` has stopped.
 * `callback` will be passed an error and any arguments passed to the final
 * `iteratee`'s callback. Invoked with (err, [results]);
 */
function doWhilst(iteratee, test, callback) {
    callback = onlyOnce(callback || noop);
    var _iteratee = wrapAsync(iteratee);
    var next = function(err/*, ...args*/) {
        if (err) return callback(err);
        var args = slice(arguments, 1);
        if (test.apply(this, args)) return _iteratee(next);
        callback.apply(null, [null].concat(args));
    };
    _iteratee(next);
}

/**
 * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the
 * argument ordering differs from `until`.
 *
 * @name doUntil
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}
 * @category Control Flow
 * @param {AsyncFunction} iteratee - An async function which is called each time
 * `test` fails. Invoked with (callback).
 * @param {Function} test - synchronous truth test to perform after each
 * execution of `iteratee`. Invoked with any non-error callback results of
 * `iteratee`.
 * @param {Function} [callback] - A callback which is called after the test
 * function has passed and repeated execution of `iteratee` has stopped. `callback`
 * will be passed an error and any arguments passed to the final `iteratee`'s
 * callback. Invoked with (err, [results]);
 */
function doUntil(iteratee, test, callback) {
    doWhilst(iteratee, function() {
        return !test.apply(this, arguments);
    }, callback);
}

/**
 * Like [`whilst`]{@link module:ControlFlow.whilst}, except the `test` is an asynchronous function that
 * is passed a callback in the form of `function (err, truth)`. If error is
 * passed to `test` or `fn`, the main callback is immediately called with the
 * value of the error.
 *
 * @name during
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.whilst]{@link module:ControlFlow.whilst}
 * @category Control Flow
 * @param {AsyncFunction} test - asynchronous truth test to perform before each
 * execution of `fn`. Invoked with (callback).
 * @param {AsyncFunction} fn - An async function which is called each time
 * `test` passes. Invoked with (callback).
 * @param {Function} [callback] - A callback which is called after the test
 * function has failed and repeated execution of `fn` has stopped. `callback`
 * will be passed an error, if one occurred, otherwise `null`.
 * @example
 *
 * var count = 0;
 *
 * async.during(
 *     function (callback) {
 *         return callback(null, count < 5);
 *     },
 *     function (callback) {
 *         count++;
 *         setTimeout(callback, 1000);
 *     },
 *     function (err) {
 *         // 5 seconds have passed
 *     }
 * );
 */
function during(test, fn, callback) {
    callback = onlyOnce(callback || noop);
    var _fn = wrapAsync(fn);
    var _test = wrapAsync(test);

    function next(err) {
        if (err) return callback(err);
        _test(check);
    }

    function check(err, truth) {
        if (err) return callback(err);
        if (!truth) return callback(null);
        _fn(next);
    }

    _test(check);
}

function _withoutIndex(iteratee) {
    return function (value, index, callback) {
        return iteratee(value, callback);
    };
}

/**
 * Applies the function `iteratee` to each item in `coll`, in parallel.
 * The `iteratee` is called with an item from the list, and a callback for when
 * it has finished. If the `iteratee` passes an error to its `callback`, the
 * main `callback` (for the `each` function) is immediately called with the
 * error.
 *
 * Note, that since this function applies `iteratee` to each item in parallel,
 * there is no guarantee that the iteratee functions will complete in order.
 *
 * @name each
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEach
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to
 * each item in `coll`. Invoked with (item, callback).
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOf`.
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @example
 *
 * // assuming openFiles is an array of file names and saveFile is a function
 * // to save the modified contents of that file:
 *
 * async.each(openFiles, saveFile, function(err){
 *   // if any of the saves produced an error, err would equal that error
 * });
 *
 * // assuming openFiles is an array of file names
 * async.each(openFiles, function(file, callback) {
 *
 *     // Perform operation on file here.
 *     console.log('Processing file ' + file);
 *
 *     if( file.length > 32 ) {
 *       console.log('This file name is too long');
 *       callback('File name too long');
 *     } else {
 *       // Do work to process file here
 *       console.log('File processed');
 *       callback();
 *     }
 * }, function(err) {
 *     // if any of the file processing produced an error, err would equal that error
 *     if( err ) {
 *       // One of the iterations produced an error.
 *       // All processing will now stop.
 *       console.log('A file failed to process');
 *     } else {
 *       console.log('All files have been processed successfully');
 *     }
 * });
 */
function eachLimit(coll, iteratee, callback) {
    eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}

/**
 * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.
 *
 * @name eachLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.each]{@link module:Collections.each}
 * @alias forEachLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOfLimit`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 */
function eachLimit$1(coll, limit, iteratee, callback) {
    _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}

/**
 * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.
 *
 * @name eachSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.each]{@link module:Collections.each}
 * @alias forEachSeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each
 * item in `coll`.
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOfSeries`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 */
var eachSeries = doLimit(eachLimit$1, 1);

/**
 * Wrap an async function and ensure it calls its callback on a later tick of
 * the event loop.  If the function already calls its callback on a next tick,
 * no extra deferral is added. This is useful for preventing stack overflows
 * (`RangeError: Maximum call stack size exceeded`) and generally keeping
 * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)
 * contained. ES2017 `async` functions are returned as-is -- they are immune
 * to Zalgo's corrupting influences, as they always resolve on a later tick.
 *
 * @name ensureAsync
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} fn - an async function, one that expects a node-style
 * callback as its last argument.
 * @returns {AsyncFunction} Returns a wrapped function with the exact same call
 * signature as the function passed in.
 * @example
 *
 * function sometimesAsync(arg, callback) {
 *     if (cache[arg]) {
 *         return callback(null, cache[arg]); // this would be synchronous!!
 *     } else {
 *         doSomeIO(arg, callback); // this IO would be asynchronous
 *     }
 * }
 *
 * // this has a risk of stack overflows if many results are cached in a row
 * async.mapSeries(args, sometimesAsync, done);
 *
 * // this will defer sometimesAsync's callback if necessary,
 * // preventing stack overflows
 * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
 */
function ensureAsync(fn) {
    if (isAsync(fn)) return fn;
    return initialParams(function (args, callback) {
        var sync = true;
        args.push(function () {
            var innerArgs = arguments;
            if (sync) {
                setImmediate$1(function () {
                    callback.apply(null, innerArgs);
                });
            } else {
                callback.apply(null, innerArgs);
            }
        });
        fn.apply(this, args);
        sync = false;
    });
}

function notId(v) {
    return !v;
}

/**
 * Returns `true` if every element in `coll` satisfies an async test. If any
 * iteratee call returns `false`, the main `callback` is immediately called.
 *
 * @name every
 * @static
 * @memberOf module:Collections
 * @method
 * @alias all
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collection in parallel.
 * The iteratee must complete with a boolean result value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 * @example
 *
 * async.every(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, result) {
 *     // if result is true then every file exists
 * });
 */
var every = doParallel(_createTester(notId, notId));

/**
 * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.
 *
 * @name everyLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.every]{@link module:Collections.every}
 * @alias allLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collection in parallel.
 * The iteratee must complete with a boolean result value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 */
var everyLimit = doParallelLimit(_createTester(notId, notId));

/**
 * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.
 *
 * @name everySeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.every]{@link module:Collections.every}
 * @alias allSeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collection in series.
 * The iteratee must complete with a boolean result value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 */
var everySeries = doLimit(everyLimit, 1);

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

function filterArray(eachfn, arr, iteratee, callback) {
    var truthValues = new Array(arr.length);
    eachfn(arr, function (x, index, callback) {
        iteratee(x, function (err, v) {
            truthValues[index] = !!v;
            callback(err);
        });
    }, function (err) {
        if (err) return callback(err);
        var results = [];
        for (var i = 0; i < arr.length; i++) {
            if (truthValues[i]) results.push(arr[i]);
        }
        callback(null, results);
    });
}

function filterGeneric(eachfn, coll, iteratee, callback) {
    var results = [];
    eachfn(coll, function (x, index, callback) {
        iteratee(x, function (err, v) {
            if (err) {
                callback(err);
            } else {
                if (v) {
                    results.push({index: index, value: x});
                }
                callback();
            }
        });
    }, function (err) {
        if (err) {
            callback(err);
        } else {
            callback(null, arrayMap(results.sort(function (a, b) {
                return a.index - b.index;
            }), baseProperty('value')));
        }
    });
}

function _filter(eachfn, coll, iteratee, callback) {
    var filter = isArrayLike(coll) ? filterArray : filterGeneric;
    filter(eachfn, coll, wrapAsync(iteratee), callback || noop);
}

/**
 * Returns a new array of all the values in `coll` which pass an async truth
 * test. This operation is performed in parallel, but the results array will be
 * in the same order as the original.
 *
 * @name filter
 * @static
 * @memberOf module:Collections
 * @method
 * @alias select
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @example
 *
 * async.filter(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, results) {
 *     // results now equals an array of the existing files
 * });
 */
var filter = doParallel(_filter);

/**
 * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name filterLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]{@link module:Collections.filter}
 * @alias selectLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 */
var filterLimit = doParallelLimit(_filter);

/**
 * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.
 *
 * @name filterSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]{@link module:Collections.filter}
 * @alias selectSeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results)
 */
var filterSeries = doLimit(filterLimit, 1);

/**
 * Calls the asynchronous function `fn` with a callback parameter that allows it
 * to call itself again, in series, indefinitely.

 * If an error is passed to the callback then `errback` is called with the
 * error, and execution stops, otherwise it will never be called.
 *
 * @name forever
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {AsyncFunction} fn - an async function to call repeatedly.
 * Invoked with (next).
 * @param {Function} [errback] - when `fn` passes an error to it's callback,
 * this function will be called, and execution stops. Invoked with (err).
 * @example
 *
 * async.forever(
 *     function(next) {
 *         // next is suitable for passing to things that need a callback(err [, whatever]);
 *         // it will result in this function being called again.
 *     },
 *     function(err) {
 *         // if next is called with a value in its first parameter, it will appear
 *         // in here as 'err', and execution will stop.
 *     }
 * );
 */
function forever(fn, errback) {
    var done = onlyOnce(errback || noop);
    var task = wrapAsync(ensureAsync(fn));

    function next(err) {
        if (err) return done(err);
        task(next);
    }
    next();
}

/**
 * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.
 *
 * @name groupByLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.groupBy]{@link module:Collections.groupBy}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a `key` to group the value under.
 * Invoked with (value, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Result is an `Object` whoses
 * properties are arrays of values which returned the corresponding key.
 */
var groupByLimit = function(coll, limit, iteratee, callback) {
    callback = callback || noop;
    var _iteratee = wrapAsync(iteratee);
    mapLimit(coll, limit, function(val, callback) {
        _iteratee(val, function(err, key) {
            if (err) return callback(err);
            return callback(null, {key: key, val: val});
        });
    }, function(err, mapResults) {
        var result = {};
        // from MDN, handle object having an `hasOwnProperty` prop
        var hasOwnProperty = Object.prototype.hasOwnProperty;

        for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
                var key = mapResults[i].key;
                var val = mapResults[i].val;

                if (hasOwnProperty.call(result, key)) {
                    result[key].push(val);
                } else {
                    result[key] = [val];
                }
            }
        }

        return callback(err, result);
    });
};

/**
 * Returns a new object, where each value corresponds to an array of items, from
 * `coll`, that returned the corresponding key. That is, the keys of the object
 * correspond to the values passed to the `iteratee` callback.
 *
 * Note: Since this function applies the `iteratee` to each item in parallel,
 * there is no guarantee that the `iteratee` functions will complete in order.
 * However, the values for each key in the `result` will be in the same order as
 * the original `coll`. For Objects, the values will roughly be in the order of
 * the original Objects' keys (but this can vary across JavaScript engines).
 *
 * @name groupBy
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a `key` to group the value under.
 * Invoked with (value, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Result is an `Object` whoses
 * properties are arrays of values which returned the corresponding key.
 * @example
 *
 * async.groupBy(['userId1', 'userId2', 'userId3'], function(userId, callback) {
 *     db.findById(userId, function(err, user) {
 *         if (err) return callback(err);
 *         return callback(null, user.age);
 *     });
 * }, function(err, result) {
 *     // result is object containing the userIds grouped by age
 *     // e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};
 * });
 */
var groupBy = doLimit(groupByLimit, Infinity);

/**
 * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.
 *
 * @name groupBySeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.groupBy]{@link module:Collections.groupBy}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a `key` to group the value under.
 * Invoked with (value, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Result is an `Object` whoses
 * properties are arrays of values which returned the corresponding key.
 */
var groupBySeries = doLimit(groupByLimit, 1);

/**
 * Logs the result of an `async` function to the `console`. Only works in
 * Node.js or in browsers that support `console.log` and `console.error` (such
 * as FF and Chrome). If multiple arguments are returned from the async
 * function, `console.log` is called on each argument in order.
 *
 * @name log
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} function - The function you want to eventually apply
 * all arguments to.
 * @param {...*} arguments... - Any number of arguments to apply to the function.
 * @example
 *
 * // in a module
 * var hello = function(name, callback) {
 *     setTimeout(function() {
 *         callback(null, 'hello ' + name);
 *     }, 1000);
 * };
 *
 * // in the node repl
 * node> async.log(hello, 'world');
 * 'hello world'
 */
var log = consoleFunc('log');

/**
 * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name mapValuesLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.mapValues]{@link module:Collections.mapValues}
 * @category Collection
 * @param {Object} obj - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - A function to apply to each value and key
 * in `coll`.
 * The iteratee should complete with the transformed value as its result.
 * Invoked with (value, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. `result` is a new object consisting
 * of each key from `obj`, with each transformed value on the right-hand side.
 * Invoked with (err, result).
 */
function mapValuesLimit(obj, limit, iteratee, callback) {
    callback = once(callback || noop);
    var newObj = {};
    var _iteratee = wrapAsync(iteratee);
    eachOfLimit(obj, limit, function(val, key, next) {
        _iteratee(val, key, function (err, result) {
            if (err) return next(err);
            newObj[key] = result;
            next();
        });
    }, function (err) {
        callback(err, newObj);
    });
}

/**
 * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.
 *
 * Produces a new Object by mapping each value of `obj` through the `iteratee`
 * function. The `iteratee` is called each `value` and `key` from `obj` and a
 * callback for when it has finished processing. Each of these callbacks takes
 * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`
 * passes an error to its callback, the main `callback` (for the `mapValues`
 * function) is immediately called with the error.
 *
 * Note, the order of the keys in the result is not guaranteed.  The keys will
 * be roughly in the order they complete, (but this is very engine-specific)
 *
 * @name mapValues
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Object} obj - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each value and key
 * in `coll`.
 * The iteratee should complete with the transformed value as its result.
 * Invoked with (value, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. `result` is a new object consisting
 * of each key from `obj`, with each transformed value on the right-hand side.
 * Invoked with (err, result).
 * @example
 *
 * async.mapValues({
 *     f1: 'file1',
 *     f2: 'file2',
 *     f3: 'file3'
 * }, function (file, key, callback) {
 *   fs.stat(file, callback);
 * }, function(err, result) {
 *     // result is now a map of stats for each file, e.g.
 *     // {
 *     //     f1: [stats for file1],
 *     //     f2: [stats for file2],
 *     //     f3: [stats for file3]
 *     // }
 * });
 */

var mapValues = doLimit(mapValuesLimit, Infinity);

/**
 * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.
 *
 * @name mapValuesSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.mapValues]{@link module:Collections.mapValues}
 * @category Collection
 * @param {Object} obj - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each value and key
 * in `coll`.
 * The iteratee should complete with the transformed value as its result.
 * Invoked with (value, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. `result` is a new object consisting
 * of each key from `obj`, with each transformed value on the right-hand side.
 * Invoked with (err, result).
 */
var mapValuesSeries = doLimit(mapValuesLimit, 1);

function has(obj, key) {
    return key in obj;
}

/**
 * Caches the results of an async function. When creating a hash to store
 * function results against, the callback is omitted from the hash and an
 * optional hash function can be used.
 *
 * If no hash function is specified, the first argument is used as a hash key,
 * which may work reasonably if it is a string or a data type that converts to a
 * distinct string. Note that objects and arrays will not behave reasonably.
 * Neither will cases where the other arguments are significant. In such cases,
 * specify your own hash function.
 *
 * The cache of results is exposed as the `memo` property of the function
 * returned by `memoize`.
 *
 * @name memoize
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} fn - The async function to proxy and cache results from.
 * @param {Function} hasher - An optional function for generating a custom hash
 * for storing results. It has all the arguments applied to it apart from the
 * callback, and must be synchronous.
 * @returns {AsyncFunction} a memoized version of `fn`
 * @example
 *
 * var slow_fn = function(name, callback) {
 *     // do something
 *     callback(null, result);
 * };
 * var fn = async.memoize(slow_fn);
 *
 * // fn can now be used as if it were slow_fn
 * fn('some name', function() {
 *     // callback
 * });
 */
function memoize(fn, hasher) {
    var memo = Object.create(null);
    var queues = Object.create(null);
    hasher = hasher || identity;
    var _fn = wrapAsync(fn);
    var memoized = initialParams(function memoized(args, callback) {
        var key = hasher.apply(null, args);
        if (has(memo, key)) {
            setImmediate$1(function() {
                callback.apply(null, memo[key]);
            });
        } else if (has(queues, key)) {
            queues[key].push(callback);
        } else {
            queues[key] = [callback];
            _fn.apply(null, args.concat(function(/*args*/) {
                var args = slice(arguments);
                memo[key] = args;
                var q = queues[key];
                delete queues[key];
                for (var i = 0, l = q.length; i < l; i++) {
                    q[i].apply(null, args);
                }
            }));
        }
    });
    memoized.memo = memo;
    memoized.unmemoized = fn;
    return memoized;
}

/**
 * Calls `callback` on a later loop around the event loop. In Node.js this just
 * calls `process.nextTick`.  In the browser it will use `setImmediate` if
 * available, otherwise `setTimeout(callback, 0)`, which means other higher
 * priority events may precede the execution of `callback`.
 *
 * This is used internally for browser-compatibility purposes.
 *
 * @name nextTick
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.setImmediate]{@link module:Utils.setImmediate}
 * @category Util
 * @param {Function} callback - The function to call on a later loop around
 * the event loop. Invoked with (args...).
 * @param {...*} args... - any number of additional arguments to pass to the
 * callback on the next tick.
 * @example
 *
 * var call_order = [];
 * async.nextTick(function() {
 *     call_order.push('two');
 *     // call_order now equals ['one','two']
 * });
 * call_order.push('one');
 *
 * async.setImmediate(function (a, b, c) {
 *     // a, b, and c equal 1, 2, and 3
 * }, 1, 2, 3);
 */
var _defer$1;

if (hasNextTick) {
    _defer$1 = process.nextTick;
} else if (hasSetImmediate) {
    _defer$1 = setImmediate;
} else {
    _defer$1 = fallback;
}

var nextTick = wrap(_defer$1);

function _parallel(eachfn, tasks, callback) {
    callback = callback || noop;
    var results = isArrayLike(tasks) ? [] : {};

    eachfn(tasks, function (task, key, callback) {
        wrapAsync(task)(function (err, result) {
            if (arguments.length > 2) {
                result = slice(arguments, 1);
            }
            results[key] = result;
            callback(err);
        });
    }, function (err) {
        callback(err, results);
    });
}

/**
 * Run the `tasks` collection of functions in parallel, without waiting until
 * the previous function has completed. If any of the functions pass an error to
 * its callback, the main `callback` is immediately called with the value of the
 * error. Once the `tasks` have completed, the results are passed to the final
 * `callback` as an array.
 *
 * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
 * parallel execution of code.  If your tasks do not use any timers or perform
 * any I/O, they will actually be executed in series.  Any synchronous setup
 * sections for each task will happen one after the other.  JavaScript remains
 * single-threaded.
 *
 * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the
 * execution of other tasks when a task fails.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 * results from {@link async.parallel}.
 *
 * @name parallel
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} tasks - A collection of
 * [async functions]{@link AsyncFunction} to run.
 * Each async function can complete with any number of optional `result` values.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed successfully. This function gets a results array
 * (or object) containing all the result arguments passed to the task callbacks.
 * Invoked with (err, results).
 *
 * @example
 * async.parallel([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     // the results array will equal ['one','two'] even though
 *     // the second function had a shorter timeout.
 * });
 *
 * // an example using an object instead of an array
 * async.parallel({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     // results is now equals to: {one: 1, two: 2}
 * });
 */
function parallelLimit(tasks, callback) {
    _parallel(eachOf, tasks, callback);
}

/**
 * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name parallelLimit
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.parallel]{@link module:ControlFlow.parallel}
 * @category Control Flow
 * @param {Array|Iterable|Object} tasks - A collection of
 * [async functions]{@link AsyncFunction} to run.
 * Each async function can complete with any number of optional `result` values.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed successfully. This function gets a results array
 * (or object) containing all the result arguments passed to the task callbacks.
 * Invoked with (err, results).
 */
function parallelLimit$1(tasks, limit, callback) {
    _parallel(_eachOfLimit(limit), tasks, callback);
}

/**
 * A queue of tasks for the worker function to complete.
 * @typedef {Object} QueueObject
 * @memberOf module:ControlFlow
 * @property {Function} length - a function returning the number of items
 * waiting to be processed. Invoke with `queue.length()`.
 * @property {boolean} started - a boolean indicating whether or not any
 * items have been pushed and processed by the queue.
 * @property {Function} running - a function returning the number of items
 * currently being processed. Invoke with `queue.running()`.
 * @property {Function} workersList - a function returning the array of items
 * currently being processed. Invoke with `queue.workersList()`.
 * @property {Function} idle - a function returning false if there are items
 * waiting or being processed, or true if not. Invoke with `queue.idle()`.
 * @property {number} concurrency - an integer for determining how many `worker`
 * functions should be run in parallel. This property can be changed after a
 * `queue` is created to alter the concurrency on-the-fly.
 * @property {Function} push - add a new task to the `queue`. Calls `callback`
 * once the `worker` has finished processing the task. Instead of a single task,
 * a `tasks` array can be submitted. The respective callback is used for every
 * task in the list. Invoke with `queue.push(task, [callback])`,
 * @property {Function} unshift - add a new task to the front of the `queue`.
 * Invoke with `queue.unshift(task, [callback])`.
 * @property {Function} remove - remove items from the queue that match a test
 * function.  The test function will be passed an object with a `data` property,
 * and a `priority` property, if this is a
 * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.
 * Invoked with `queue.remove(testFn)`, where `testFn` is of the form
 * `function ({data, priority}) {}` and returns a Boolean.
 * @property {Function} saturated - a callback that is called when the number of
 * running workers hits the `concurrency` limit, and further tasks will be
 * queued.
 * @property {Function} unsaturated - a callback that is called when the number
 * of running workers is less than the `concurrency` & `buffer` limits, and
 * further tasks will not be queued.
 * @property {number} buffer - A minimum threshold buffer in order to say that
 * the `queue` is `unsaturated`.
 * @property {Function} empty - a callback that is called when the last item
 * from the `queue` is given to a `worker`.
 * @property {Function} drain - a callback that is called when the last item
 * from the `queue` has returned from the `worker`.
 * @property {Function} error - a callback that is called when a task errors.
 * Has the signature `function(error, task)`.
 * @property {boolean} paused - a boolean for determining whether the queue is
 * in a paused state.
 * @property {Function} pause - a function that pauses the processing of tasks
 * until `resume()` is called. Invoke with `queue.pause()`.
 * @property {Function} resume - a function that resumes the processing of
 * queued tasks when the queue is paused. Invoke with `queue.resume()`.
 * @property {Function} kill - a function that removes the `drain` callback and
 * empties remaining tasks from the queue forcing it to go idle. No more tasks
 * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.
 */

/**
 * Creates a `queue` object with the specified `concurrency`. Tasks added to the
 * `queue` are processed in parallel (up to the `concurrency` limit). If all
 * `worker`s are in progress, the task is queued until one becomes available.
 * Once a `worker` completes a `task`, that `task`'s callback is called.
 *
 * @name queue
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {AsyncFunction} worker - An async function for processing a queued task.
 * If you want to handle errors from an individual task, pass a callback to
 * `q.push()`. Invoked with (task, callback).
 * @param {number} [concurrency=1] - An `integer` for determining how many
 * `worker` functions should be run in parallel.  If omitted, the concurrency
 * defaults to `1`.  If the concurrency is `0`, an error is thrown.
 * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can
 * attached as certain properties to listen for specific events during the
 * lifecycle of the queue.
 * @example
 *
 * // create a queue object with concurrency 2
 * var q = async.queue(function(task, callback) {
 *     console.log('hello ' + task.name);
 *     callback();
 * }, 2);
 *
 * // assign a callback
 * q.drain = function() {
 *     console.log('all items have been processed');
 * };
 *
 * // add some items to the queue
 * q.push({name: 'foo'}, function(err) {
 *     console.log('finished processing foo');
 * });
 * q.push({name: 'bar'}, function (err) {
 *     console.log('finished processing bar');
 * });
 *
 * // add some items to the queue (batch-wise)
 * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {
 *     console.log('finished processing item');
 * });
 *
 * // add some items to the front of the queue
 * q.unshift({name: 'bar'}, function (err) {
 *     console.log('finished processing bar');
 * });
 */
var queue$1 = function (worker, concurrency) {
    var _worker = wrapAsync(worker);
    return queue(function (items, cb) {
        _worker(items[0], cb);
    }, concurrency, 1);
};

/**
 * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and
 * completed in ascending priority order.
 *
 * @name priorityQueue
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.queue]{@link module:ControlFlow.queue}
 * @category Control Flow
 * @param {AsyncFunction} worker - An async function for processing a queued task.
 * If you want to handle errors from an individual task, pass a callback to
 * `q.push()`.
 * Invoked with (task, callback).
 * @param {number} concurrency - An `integer` for determining how many `worker`
 * functions should be run in parallel.  If omitted, the concurrency defaults to
 * `1`.  If the concurrency is `0`, an error is thrown.
 * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two
 * differences between `queue` and `priorityQueue` objects:
 * * `push(task, priority, [callback])` - `priority` should be a number. If an
 *   array of `tasks` is given, all tasks will be assigned the same priority.
 * * The `unshift` method was removed.
 */
var priorityQueue = function(worker, concurrency) {
    // Start with a normal queue
    var q = queue$1(worker, concurrency);

    // Override push to accept second parameter representing priority
    q.push = function(data, priority, callback) {
        if (callback == null) callback = noop;
        if (typeof callback !== 'function') {
            throw new Error('task callback must be a function');
        }
        q.started = true;
        if (!isArray(data)) {
            data = [data];
        }
        if (data.length === 0) {
            // call drain immediately if there are no tasks
            return setImmediate$1(function() {
                q.drain();
            });
        }

        priority = priority || 0;
        var nextNode = q._tasks.head;
        while (nextNode && priority >= nextNode.priority) {
            nextNode = nextNode.next;
        }

        for (var i = 0, l = data.length; i < l; i++) {
            var item = {
                data: data[i],
                priority: priority,
                callback: callback
            };

            if (nextNode) {
                q._tasks.insertBefore(nextNode, item);
            } else {
                q._tasks.push(item);
            }
        }
        setImmediate$1(q.process);
    };

    // Remove unshift function
    delete q.unshift;

    return q;
};

/**
 * Runs the `tasks` array of functions in parallel, without waiting until the
 * previous function has completed. Once any of the `tasks` complete or pass an
 * error to its callback, the main `callback` is immediately called. It's
 * equivalent to `Promise.race()`.
 *
 * @name race
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}
 * to run. Each function can complete with an optional `result` value.
 * @param {Function} callback - A callback to run once any of the functions have
 * completed. This function gets an error or result from the first function that
 * completed. Invoked with (err, result).
 * @returns undefined
 * @example
 *
 * async.race([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ],
 * // main callback
 * function(err, result) {
 *     // the result will be equal to 'two' as it finishes earlier
 * });
 */
function race(tasks, callback) {
    callback = once(callback || noop);
    if (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));
    if (!tasks.length) return callback();
    for (var i = 0, l = tasks.length; i < l; i++) {
        wrapAsync(tasks[i])(callback);
    }
}

/**
 * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.
 *
 * @name reduceRight
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.reduce]{@link module:Collections.reduce}
 * @alias foldr
 * @category Collection
 * @param {Array} array - A collection to iterate over.
 * @param {*} memo - The initial state of the reduction.
 * @param {AsyncFunction} iteratee - A function applied to each item in the
 * array to produce the next step in the reduction.
 * The `iteratee` should complete with the next state of the reduction.
 * If the iteratee complete with an error, the reduction is stopped and the
 * main `callback` is immediately called with the error.
 * Invoked with (memo, item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the reduced value. Invoked with
 * (err, result).
 */
function reduceRight (array, memo, iteratee, callback) {
    var reversed = slice(array).reverse();
    reduce(reversed, memo, iteratee, callback);
}

/**
 * Wraps the async function in another function that always completes with a
 * result object, even when it errors.
 *
 * The result object has either the property `error` or `value`.
 *
 * @name reflect
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} fn - The async function you want to wrap
 * @returns {Function} - A function that always passes null to it's callback as
 * the error. The second argument to the callback will be an `object` with
 * either an `error` or a `value` property.
 * @example
 *
 * async.parallel([
 *     async.reflect(function(callback) {
 *         // do some stuff ...
 *         callback(null, 'one');
 *     }),
 *     async.reflect(function(callback) {
 *         // do some more stuff but error ...
 *         callback('bad stuff happened');
 *     }),
 *     async.reflect(function(callback) {
 *         // do some more stuff ...
 *         callback(null, 'two');
 *     })
 * ],
 * // optional callback
 * function(err, results) {
 *     // values
 *     // results[0].value = 'one'
 *     // results[1].error = 'bad stuff happened'
 *     // results[2].value = 'two'
 * });
 */
function reflect(fn) {
    var _fn = wrapAsync(fn);
    return initialParams(function reflectOn(args, reflectCallback) {
        args.push(function callback(error, cbArg) {
            if (error) {
                reflectCallback(null, { error: error });
            } else {
                var value;
                if (arguments.length <= 2) {
                    value = cbArg;
                } else {
                    value = slice(arguments, 1);
                }
                reflectCallback(null, { value: value });
            }
        });

        return _fn.apply(this, args);
    });
}

/**
 * A helper function that wraps an array or an object of functions with `reflect`.
 *
 * @name reflectAll
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.reflect]{@link module:Utils.reflect}
 * @category Util
 * @param {Array|Object|Iterable} tasks - The collection of
 * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.
 * @returns {Array} Returns an array of async functions, each wrapped in
 * `async.reflect`
 * @example
 *
 * let tasks = [
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         // do some more stuff but error ...
 *         callback(new Error('bad stuff happened'));
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ];
 *
 * async.parallel(async.reflectAll(tasks),
 * // optional callback
 * function(err, results) {
 *     // values
 *     // results[0].value = 'one'
 *     // results[1].error = Error('bad stuff happened')
 *     // results[2].value = 'two'
 * });
 *
 * // an example using an object instead of an array
 * let tasks = {
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         callback('two');
 *     },
 *     three: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'three');
 *         }, 100);
 *     }
 * };
 *
 * async.parallel(async.reflectAll(tasks),
 * // optional callback
 * function(err, results) {
 *     // values
 *     // results.one.value = 'one'
 *     // results.two.error = 'two'
 *     // results.three.value = 'three'
 * });
 */
function reflectAll(tasks) {
    var results;
    if (isArray(tasks)) {
        results = arrayMap(tasks, reflect);
    } else {
        results = {};
        baseForOwn(tasks, function(task, key) {
            results[key] = reflect.call(this, task);
        });
    }
    return results;
}

function reject$1(eachfn, arr, iteratee, callback) {
    _filter(eachfn, arr, function(value, cb) {
        iteratee(value, function(err, v) {
            cb(err, !v);
        });
    }, callback);
}

/**
 * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.
 *
 * @name reject
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]{@link module:Collections.filter}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - An async truth test to apply to each item in
 * `coll`.
 * The should complete with a boolean value as its `result`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @example
 *
 * async.reject(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, results) {
 *     // results now equals an array of missing files
 *     createFiles(results);
 * });
 */
var reject = doParallel(reject$1);

/**
 * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name rejectLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.reject]{@link module:Collections.reject}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} iteratee - An async truth test to apply to each item in
 * `coll`.
 * The should complete with a boolean value as its `result`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 */
var rejectLimit = doParallelLimit(reject$1);

/**
 * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.
 *
 * @name rejectSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.reject]{@link module:Collections.reject}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - An async truth test to apply to each item in
 * `coll`.
 * The should complete with a boolean value as its `result`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 */
var rejectSeries = doLimit(rejectLimit, 1);

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant$1(value) {
  return function() {
    return value;
  };
}

/**
 * Attempts to get a successful response from `task` no more than `times` times
 * before returning an error. If the task is successful, the `callback` will be
 * passed the result of the successful task. If all attempts fail, the callback
 * will be passed the error and result (if any) of the final attempt.
 *
 * @name retry
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @see [async.retryable]{@link module:ControlFlow.retryable}
 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an
 * object with `times` and `interval` or a number.
 * * `times` - The number of attempts to make before giving up.  The default
 *   is `5`.
 * * `interval` - The time to wait between retries, in milliseconds.  The
 *   default is `0`. The interval may also be specified as a function of the
 *   retry count (see example).
 * * `errorFilter` - An optional synchronous function that is invoked on
 *   erroneous result. If it returns `true` the retry attempts will continue;
 *   if the function returns `false` the retry flow is aborted with the current
 *   attempt's error and result being returned to the final callback.
 *   Invoked with (err).
 * * If `opts` is a number, the number specifies the number of times to retry,
 *   with the default interval of `0`.
 * @param {AsyncFunction} task - An async function to retry.
 * Invoked with (callback).
 * @param {Function} [callback] - An optional callback which is called when the
 * task has succeeded, or after the final failed attempt. It receives the `err`
 * and `result` arguments of the last attempt at completing the `task`. Invoked
 * with (err, results).
 *
 * @example
 *
 * // The `retry` function can be used as a stand-alone control flow by passing
 * // a callback, as shown below:
 *
 * // try calling apiMethod 3 times
 * async.retry(3, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod 3 times, waiting 200 ms between each retry
 * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod 10 times with exponential backoff
 * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)
 * async.retry({
 *   times: 10,
 *   interval: function(retryCount) {
 *     return 50 * Math.pow(2, retryCount);
 *   }
 * }, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod the default 5 times no delay between each retry
 * async.retry(apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod only when error condition satisfies, all other
 * // errors will abort the retry control flow and return to final callback
 * async.retry({
 *   errorFilter: function(err) {
 *     return err.message === 'Temporary error'; // only retry on a specific error
 *   }
 * }, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // to retry individual methods that are not as reliable within other
 * // control flow functions, use the `retryable` wrapper:
 * async.auto({
 *     users: api.getUsers.bind(api),
 *     payments: async.retryable(3, api.getPayments.bind(api))
 * }, function(err, results) {
 *     // do something with the results
 * });
 *
 */
function retry(opts, task, callback) {
    var DEFAULT_TIMES = 5;
    var DEFAULT_INTERVAL = 0;

    var options = {
        times: DEFAULT_TIMES,
        intervalFunc: constant$1(DEFAULT_INTERVAL)
    };

    function parseTimes(acc, t) {
        if (typeof t === 'object') {
            acc.times = +t.times || DEFAULT_TIMES;

            acc.intervalFunc = typeof t.interval === 'function' ?
                t.interval :
                constant$1(+t.interval || DEFAULT_INTERVAL);

            acc.errorFilter = t.errorFilter;
        } else if (typeof t === 'number' || typeof t === 'string') {
            acc.times = +t || DEFAULT_TIMES;
        } else {
            throw new Error("Invalid arguments for async.retry");
        }
    }

    if (arguments.length < 3 && typeof opts === 'function') {
        callback = task || noop;
        task = opts;
    } else {
        parseTimes(options, opts);
        callback = callback || noop;
    }

    if (typeof task !== 'function') {
        throw new Error("Invalid arguments for async.retry");
    }

    var _task = wrapAsync(task);

    var attempt = 1;
    function retryAttempt() {
        _task(function(err) {
            if (err && attempt++ < options.times &&
                (typeof options.errorFilter != 'function' ||
                    options.errorFilter(err))) {
                setTimeout(retryAttempt, options.intervalFunc(attempt));
            } else {
                callback.apply(null, arguments);
            }
        });
    }

    retryAttempt();
}

/**
 * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method
 * wraps a task and makes it retryable, rather than immediately calling it
 * with retries.
 *
 * @name retryable
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.retry]{@link module:ControlFlow.retry}
 * @category Control Flow
 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional
 * options, exactly the same as from `retry`
 * @param {AsyncFunction} task - the asynchronous function to wrap.
 * This function will be passed any arguments passed to the returned wrapper.
 * Invoked with (...args, callback).
 * @returns {AsyncFunction} The wrapped function, which when invoked, will
 * retry on an error, based on the parameters specified in `opts`.
 * This function will accept the same parameters as `task`.
 * @example
 *
 * async.auto({
 *     dep1: async.retryable(3, getFromFlakyService),
 *     process: ["dep1", async.retryable(3, function (results, cb) {
 *         maybeProcessData(results.dep1, cb);
 *     })]
 * }, callback);
 */
var retryable = function (opts, task) {
    if (!task) {
        task = opts;
        opts = null;
    }
    var _task = wrapAsync(task);
    return initialParams(function (args, callback) {
        function taskFn(cb) {
            _task.apply(null, args.concat(cb));
        }

        if (opts) retry(opts, taskFn, callback);
        else retry(taskFn, callback);

    });
};

/**
 * Run the functions in the `tasks` collection in series, each one running once
 * the previous function has completed. If any functions in the series pass an
 * error to its callback, no more functions are run, and `callback` is
 * immediately called with the value of the error. Otherwise, `callback`
 * receives an array of results when `tasks` have completed.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function, and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 *  results from {@link async.series}.
 *
 * **Note** that while many implementations preserve the order of object
 * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
 * explicitly states that
 *
 * > The mechanics and order of enumerating the properties is not specified.
 *
 * So if you rely on the order in which your series of functions are executed,
 * and want this to work on all platforms, consider using an array.
 *
 * @name series
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} tasks - A collection containing
 * [async functions]{@link AsyncFunction} to run in series.
 * Each function can complete with any number of optional `result` values.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This function gets a results array (or object)
 * containing all the result arguments passed to the `task` callbacks. Invoked
 * with (err, result).
 * @example
 * async.series([
 *     function(callback) {
 *         // do some stuff ...
 *         callback(null, 'one');
 *     },
 *     function(callback) {
 *         // do some more stuff ...
 *         callback(null, 'two');
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     // results is now equal to ['one', 'two']
 * });
 *
 * async.series({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback){
 *         setTimeout(function() {
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     // results is now equal to: {one: 1, two: 2}
 * });
 */
function series(tasks, callback) {
    _parallel(eachOfSeries, tasks, callback);
}

/**
 * Returns `true` if at least one element in the `coll` satisfies an async test.
 * If any iteratee call returns `true`, the main `callback` is immediately
 * called.
 *
 * @name some
 * @static
 * @memberOf module:Collections
 * @method
 * @alias any
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in parallel.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 * @example
 *
 * async.some(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, result) {
 *     // if result is true then at least one of the files exists
 * });
 */
var some = doParallel(_createTester(Boolean, identity));

/**
 * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.
 *
 * @name someLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.some]{@link module:Collections.some}
 * @alias anyLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in parallel.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 */
var someLimit = doParallelLimit(_createTester(Boolean, identity));

/**
 * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.
 *
 * @name someSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.some]{@link module:Collections.some}
 * @alias anySeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in series.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 */
var someSeries = doLimit(someLimit, 1);

/**
 * Sorts a list by the results of running each `coll` value through an async
 * `iteratee`.
 *
 * @name sortBy
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a value to use as the sort criteria as
 * its `result`.
 * Invoked with (item, callback).
 * @param {Function} callback - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is the items
 * from the original `coll` sorted by the values returned by the `iteratee`
 * calls. Invoked with (err, results).
 * @example
 *
 * async.sortBy(['file1','file2','file3'], function(file, callback) {
 *     fs.stat(file, function(err, stats) {
 *         callback(err, stats.mtime);
 *     });
 * }, function(err, results) {
 *     // results is now the original array of files sorted by
 *     // modified date
 * });
 *
 * // By modifying the callback parameter the
 * // sorting order can be influenced:
 *
 * // ascending order
 * async.sortBy([1,9,3,5], function(x, callback) {
 *     callback(null, x);
 * }, function(err,result) {
 *     // result callback
 * });
 *
 * // descending order
 * async.sortBy([1,9,3,5], function(x, callback) {
 *     callback(null, x*-1);    //<- x*-1 instead of x, turns the order around
 * }, function(err,result) {
 *     // result callback
 * });
 */
function sortBy (coll, iteratee, callback) {
    var _iteratee = wrapAsync(iteratee);
    map(coll, function (x, callback) {
        _iteratee(x, function (err, criteria) {
            if (err) return callback(err);
            callback(null, {value: x, criteria: criteria});
        });
    }, function (err, results) {
        if (err) return callback(err);
        callback(null, arrayMap(results.sort(comparator), baseProperty('value')));
    });

    function comparator(left, right) {
        var a = left.criteria, b = right.criteria;
        return a < b ? -1 : a > b ? 1 : 0;
    }
}

/**
 * Sets a time limit on an asynchronous function. If the function does not call
 * its callback within the specified milliseconds, it will be called with a
 * timeout error. The code property for the error object will be `'ETIMEDOUT'`.
 *
 * @name timeout
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} asyncFn - The async function to limit in time.
 * @param {number} milliseconds - The specified time limit.
 * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)
 * to timeout Error for more information..
 * @returns {AsyncFunction} Returns a wrapped function that can be used with any
 * of the control flow functions.
 * Invoke this function with the same parameters as you would `asyncFunc`.
 * @example
 *
 * function myFunction(foo, callback) {
 *     doAsyncTask(foo, function(err, data) {
 *         // handle errors
 *         if (err) return callback(err);
 *
 *         // do some stuff ...
 *
 *         // return processed data
 *         return callback(null, data);
 *     });
 * }
 *
 * var wrapped = async.timeout(myFunction, 1000);
 *
 * // call `wrapped` as you would `myFunction`
 * wrapped({ bar: 'bar' }, function(err, data) {
 *     // if `myFunction` takes < 1000 ms to execute, `err`
 *     // and `data` will have their expected values
 *
 *     // else `err` will be an Error with the code 'ETIMEDOUT'
 * });
 */
function timeout(asyncFn, milliseconds, info) {
    var fn = wrapAsync(asyncFn);

    return initialParams(function (args, callback) {
        var timedOut = false;
        var timer;

        function timeoutCallback() {
            var name = asyncFn.name || 'anonymous';
            var error  = new Error('Callback function "' + name + '" timed out.');
            error.code = 'ETIMEDOUT';
            if (info) {
                error.info = info;
            }
            timedOut = true;
            callback(error);
        }

        args.push(function () {
            if (!timedOut) {
                callback.apply(null, arguments);
                clearTimeout(timer);
            }
        });

        // setup timer and call original function
        timer = setTimeout(timeoutCallback, milliseconds);
        fn.apply(null, args);
    });
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil;
var nativeMax = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}

/**
 * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name timesLimit
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.times]{@link module:ControlFlow.times}
 * @category Control Flow
 * @param {number} count - The number of times to run the function.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - The async function to call `n` times.
 * Invoked with the iteration index and a callback: (n, next).
 * @param {Function} callback - see [async.map]{@link module:Collections.map}.
 */
function timeLimit(count, limit, iteratee, callback) {
    var _iteratee = wrapAsync(iteratee);
    mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);
}

/**
 * Calls the `iteratee` function `n` times, and accumulates results in the same
 * manner you would use with [map]{@link module:Collections.map}.
 *
 * @name times
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.map]{@link module:Collections.map}
 * @category Control Flow
 * @param {number} n - The number of times to run the function.
 * @param {AsyncFunction} iteratee - The async function to call `n` times.
 * Invoked with the iteration index and a callback: (n, next).
 * @param {Function} callback - see {@link module:Collections.map}.
 * @example
 *
 * // Pretend this is some complicated async factory
 * var createUser = function(id, callback) {
 *     callback(null, {
 *         id: 'user' + id
 *     });
 * };
 *
 * // generate 5 users
 * async.times(5, function(n, next) {
 *     createUser(n, function(err, user) {
 *         next(err, user);
 *     });
 * }, function(err, users) {
 *     // we should now have 5 users
 * });
 */
var times = doLimit(timeLimit, Infinity);

/**
 * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.
 *
 * @name timesSeries
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.times]{@link module:ControlFlow.times}
 * @category Control Flow
 * @param {number} n - The number of times to run the function.
 * @param {AsyncFunction} iteratee - The async function to call `n` times.
 * Invoked with the iteration index and a callback: (n, next).
 * @param {Function} callback - see {@link module:Collections.map}.
 */
var timesSeries = doLimit(timeLimit, 1);

/**
 * A relative of `reduce`.  Takes an Object or Array, and iterates over each
 * element in series, each step potentially mutating an `accumulator` value.
 * The type of the accumulator defaults to the type of collection passed in.
 *
 * @name transform
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {*} [accumulator] - The initial state of the transform.  If omitted,
 * it will default to an empty Object or Array, depending on the type of `coll`
 * @param {AsyncFunction} iteratee - A function applied to each item in the
 * collection that potentially modifies the accumulator.
 * Invoked with (accumulator, item, key, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the transformed accumulator.
 * Invoked with (err, result).
 * @example
 *
 * async.transform([1,2,3], function(acc, item, index, callback) {
 *     // pointless async:
 *     process.nextTick(function() {
 *         acc.push(item * 2)
 *         callback(null)
 *     });
 * }, function(err, result) {
 *     // result is now equal to [2, 4, 6]
 * });
 *
 * @example
 *
 * async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {
 *     setImmediate(function () {
 *         obj[key] = val * 2;
 *         callback();
 *     })
 * }, function (err, result) {
 *     // result is equal to {a: 2, b: 4, c: 6}
 * })
 */
function transform (coll, accumulator, iteratee, callback) {
    if (arguments.length <= 3) {
        callback = iteratee;
        iteratee = accumulator;
        accumulator = isArray(coll) ? [] : {};
    }
    callback = once(callback || noop);
    var _iteratee = wrapAsync(iteratee);

    eachOf(coll, function(v, k, cb) {
        _iteratee(accumulator, v, k, cb);
    }, function(err) {
        callback(err, accumulator);
    });
}

/**
 * It runs each task in series but stops whenever any of the functions were
 * successful. If one of the tasks were successful, the `callback` will be
 * passed the result of the successful task. If all tasks fail, the callback
 * will be passed the error and result (if any) of the final attempt.
 *
 * @name tryEach
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} tasks - A collection containing functions to
 * run, each function is passed a `callback(err, result)` it must call on
 * completion with an error `err` (which can be `null`) and an optional `result`
 * value.
 * @param {Function} [callback] - An optional callback which is called when one
 * of the tasks has succeeded, or all have failed. It receives the `err` and
 * `result` arguments of the last attempt at completing the `task`. Invoked with
 * (err, results).
 * @example
 * async.tryEach([
 *     function getDataFromFirstWebsite(callback) {
 *         // Try getting the data from the first website
 *         callback(err, data);
 *     },
 *     function getDataFromSecondWebsite(callback) {
 *         // First website failed,
 *         // Try getting the data from the backup website
 *         callback(err, data);
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     Now do something with the data.
 * });
 *
 */
function tryEach(tasks, callback) {
    var error = null;
    var result;
    callback = callback || noop;
    eachSeries(tasks, function(task, callback) {
        wrapAsync(task)(function (err, res/*, ...args*/) {
            if (arguments.length > 2) {
                result = slice(arguments, 1);
            } else {
                result = res;
            }
            error = err;
            callback(!err);
        });
    }, function () {
        callback(error, result);
    });
}

/**
 * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,
 * unmemoized form. Handy for testing.
 *
 * @name unmemoize
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.memoize]{@link module:Utils.memoize}
 * @category Util
 * @param {AsyncFunction} fn - the memoized function
 * @returns {AsyncFunction} a function that calls the original unmemoized function
 */
function unmemoize(fn) {
    return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
    };
}

/**
 * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when
 * stopped, or an error occurs.
 *
 * @name whilst
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Function} test - synchronous truth test to perform before each
 * execution of `iteratee`. Invoked with ().
 * @param {AsyncFunction} iteratee - An async function which is called each time
 * `test` passes. Invoked with (callback).
 * @param {Function} [callback] - A callback which is called after the test
 * function has failed and repeated execution of `iteratee` has stopped. `callback`
 * will be passed an error and any arguments passed to the final `iteratee`'s
 * callback. Invoked with (err, [results]);
 * @returns undefined
 * @example
 *
 * var count = 0;
 * async.whilst(
 *     function() { return count < 5; },
 *     function(callback) {
 *         count++;
 *         setTimeout(function() {
 *             callback(null, count);
 *         }, 1000);
 *     },
 *     function (err, n) {
 *         // 5 seconds have passed, n = 5
 *     }
 * );
 */
function whilst(test, iteratee, callback) {
    callback = onlyOnce(callback || noop);
    var _iteratee = wrapAsync(iteratee);
    if (!test()) return callback(null);
    var next = function(err/*, ...args*/) {
        if (err) return callback(err);
        if (test()) return _iteratee(next);
        var args = slice(arguments, 1);
        callback.apply(null, [null].concat(args));
    };
    _iteratee(next);
}

/**
 * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when
 * stopped, or an error occurs. `callback` will be passed an error and any
 * arguments passed to the final `iteratee`'s callback.
 *
 * The inverse of [whilst]{@link module:ControlFlow.whilst}.
 *
 * @name until
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.whilst]{@link module:ControlFlow.whilst}
 * @category Control Flow
 * @param {Function} test - synchronous truth test to perform before each
 * execution of `iteratee`. Invoked with ().
 * @param {AsyncFunction} iteratee - An async function which is called each time
 * `test` fails. Invoked with (callback).
 * @param {Function} [callback] - A callback which is called after the test
 * function has passed and repeated execution of `iteratee` has stopped. `callback`
 * will be passed an error and any arguments passed to the final `iteratee`'s
 * callback. Invoked with (err, [results]);
 */
function until(test, iteratee, callback) {
    whilst(function() {
        return !test.apply(this, arguments);
    }, iteratee, callback);
}

/**
 * Runs the `tasks` array of functions in series, each passing their results to
 * the next in the array. However, if any of the `tasks` pass an error to their
 * own callback, the next function is not executed, and the main `callback` is
 * immediately called with the error.
 *
 * @name waterfall
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}
 * to run.
 * Each function should complete with any number of `result` values.
 * The `result` values will be passed as arguments, in order, to the next task.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This will be passed the results of the last task's
 * callback. Invoked with (err, [results]).
 * @returns undefined
 * @example
 *
 * async.waterfall([
 *     function(callback) {
 *         callback(null, 'one', 'two');
 *     },
 *     function(arg1, arg2, callback) {
 *         // arg1 now equals 'one' and arg2 now equals 'two'
 *         callback(null, 'three');
 *     },
 *     function(arg1, callback) {
 *         // arg1 now equals 'three'
 *         callback(null, 'done');
 *     }
 * ], function (err, result) {
 *     // result now equals 'done'
 * });
 *
 * // Or, with named functions:
 * async.waterfall([
 *     myFirstFunction,
 *     mySecondFunction,
 *     myLastFunction,
 * ], function (err, result) {
 *     // result now equals 'done'
 * });
 * function myFirstFunction(callback) {
 *     callback(null, 'one', 'two');
 * }
 * function mySecondFunction(arg1, arg2, callback) {
 *     // arg1 now equals 'one' and arg2 now equals 'two'
 *     callback(null, 'three');
 * }
 * function myLastFunction(arg1, callback) {
 *     // arg1 now equals 'three'
 *     callback(null, 'done');
 * }
 */
var waterfall = function(tasks, callback) {
    callback = once(callback || noop);
    if (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
    if (!tasks.length) return callback();
    var taskIndex = 0;

    function nextTask(args) {
        var task = wrapAsync(tasks[taskIndex++]);
        args.push(onlyOnce(next));
        task.apply(null, args);
    }

    function next(err/*, ...args*/) {
        if (err || taskIndex === tasks.length) {
            return callback.apply(null, arguments);
        }
        nextTask(slice(arguments, 1));
    }

    nextTask([]);
};

/**
 * An "async function" in the context of Async is an asynchronous function with
 * a variable number of parameters, with the final parameter being a callback.
 * (`function (arg1, arg2, ..., callback) {}`)
 * The final callback is of the form `callback(err, results...)`, which must be
 * called once the function is completed.  The callback should be called with a
 * Error as its first argument to signal that an error occurred.
 * Otherwise, if no error occurred, it should be called with `null` as the first
 * argument, and any additional `result` arguments that may apply, to signal
 * successful completion.
 * The callback must be called exactly once, ideally on a later tick of the
 * JavaScript event loop.
 *
 * This type of function is also referred to as a "Node-style async function",
 * or a "continuation passing-style function" (CPS). Most of the methods of this
 * library are themselves CPS/Node-style async functions, or functions that
 * return CPS/Node-style async functions.
 *
 * Wherever we accept a Node-style async function, we also directly accept an
 * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.
 * In this case, the `async` function will not be passed a final callback
 * argument, and any thrown error will be used as the `err` argument of the
 * implicit callback, and the return value will be used as the `result` value.
 * (i.e. a `rejected` of the returned Promise becomes the `err` callback
 * argument, and a `resolved` value becomes the `result`.)
 *
 * Note, due to JavaScript limitations, we can only detect native `async`
 * functions and not transpilied implementations.
 * Your environment must have `async`/`await` support for this to work.
 * (e.g. Node > v7.6, or a recent version of a modern browser).
 * If you are using `async` functions through a transpiler (e.g. Babel), you
 * must still wrap the function with [asyncify]{@link module:Utils.asyncify},
 * because the `async function` will be compiled to an ordinary function that
 * returns a promise.
 *
 * @typedef {Function} AsyncFunction
 * @static
 */

/**
 * Async is a utility module which provides straight-forward, powerful functions
 * for working with asynchronous JavaScript. Although originally designed for
 * use with [Node.js](http://nodejs.org) and installable via
 * `npm install --save async`, it can also be used directly in the browser.
 * @module async
 * @see AsyncFunction
 */


/**
 * A collection of `async` functions for manipulating collections, such as
 * arrays and objects.
 * @module Collections
 */

/**
 * A collection of `async` functions for controlling the flow through a script.
 * @module ControlFlow
 */

/**
 * A collection of `async` utility functions.
 * @module Utils
 */

var index = {
    apply: apply,
    applyEach: applyEach,
    applyEachSeries: applyEachSeries,
    asyncify: asyncify,
    auto: auto,
    autoInject: autoInject,
    cargo: cargo,
    compose: compose,
    concat: concat,
    concatLimit: concatLimit,
    concatSeries: concatSeries,
    constant: constant,
    detect: detect,
    detectLimit: detectLimit,
    detectSeries: detectSeries,
    dir: dir,
    doDuring: doDuring,
    doUntil: doUntil,
    doWhilst: doWhilst,
    during: during,
    each: eachLimit,
    eachLimit: eachLimit$1,
    eachOf: eachOf,
    eachOfLimit: eachOfLimit,
    eachOfSeries: eachOfSeries,
    eachSeries: eachSeries,
    ensureAsync: ensureAsync,
    every: every,
    everyLimit: everyLimit,
    everySeries: everySeries,
    filter: filter,
    filterLimit: filterLimit,
    filterSeries: filterSeries,
    forever: forever,
    groupBy: groupBy,
    groupByLimit: groupByLimit,
    groupBySeries: groupBySeries,
    log: log,
    map: map,
    mapLimit: mapLimit,
    mapSeries: mapSeries,
    mapValues: mapValues,
    mapValuesLimit: mapValuesLimit,
    mapValuesSeries: mapValuesSeries,
    memoize: memoize,
    nextTick: nextTick,
    parallel: parallelLimit,
    parallelLimit: parallelLimit$1,
    priorityQueue: priorityQueue,
    queue: queue$1,
    race: race,
    reduce: reduce,
    reduceRight: reduceRight,
    reflect: reflect,
    reflectAll: reflectAll,
    reject: reject,
    rejectLimit: rejectLimit,
    rejectSeries: rejectSeries,
    retry: retry,
    retryable: retryable,
    seq: seq,
    series: series,
    setImmediate: setImmediate$1,
    some: some,
    someLimit: someLimit,
    someSeries: someSeries,
    sortBy: sortBy,
    timeout: timeout,
    times: times,
    timesLimit: timeLimit,
    timesSeries: timesSeries,
    transform: transform,
    tryEach: tryEach,
    unmemoize: unmemoize,
    until: until,
    waterfall: waterfall,
    whilst: whilst,

    // aliases
    all: every,
    allLimit: everyLimit,
    allSeries: everySeries,
    any: some,
    anyLimit: someLimit,
    anySeries: someSeries,
    find: detect,
    findLimit: detectLimit,
    findSeries: detectSeries,
    forEach: eachLimit,
    forEachSeries: eachSeries,
    forEachLimit: eachLimit$1,
    forEachOf: eachOf,
    forEachOfSeries: eachOfSeries,
    forEachOfLimit: eachOfLimit,
    inject: reduce,
    foldl: reduce,
    foldr: reduceRight,
    select: filter,
    selectLimit: filterLimit,
    selectSeries: filterSeries,
    wrapSync: asyncify
};

exports['default'] = index;
exports.apply = apply;
exports.applyEach = applyEach;
exports.applyEachSeries = applyEachSeries;
exports.asyncify = asyncify;
exports.auto = auto;
exports.autoInject = autoInject;
exports.cargo = cargo;
exports.compose = compose;
exports.concat = concat;
exports.concatLimit = concatLimit;
exports.concatSeries = concatSeries;
exports.constant = constant;
exports.detect = detect;
exports.detectLimit = detectLimit;
exports.detectSeries = detectSeries;
exports.dir = dir;
exports.doDuring = doDuring;
exports.doUntil = doUntil;
exports.doWhilst = doWhilst;
exports.during = during;
exports.each = eachLimit;
exports.eachLimit = eachLimit$1;
exports.eachOf = eachOf;
exports.eachOfLimit = eachOfLimit;
exports.eachOfSeries = eachOfSeries;
exports.eachSeries = eachSeries;
exports.ensureAsync = ensureAsync;
exports.every = every;
exports.everyLimit = everyLimit;
exports.everySeries = everySeries;
exports.filter = filter;
exports.filterLimit = filterLimit;
exports.filterSeries = filterSeries;
exports.forever = forever;
exports.groupBy = groupBy;
exports.groupByLimit = groupByLimit;
exports.groupBySeries = groupBySeries;
exports.log = log;
exports.map = map;
exports.mapLimit = mapLimit;
exports.mapSeries = mapSeries;
exports.mapValues = mapValues;
exports.mapValuesLimit = mapValuesLimit;
exports.mapValuesSeries = mapValuesSeries;
exports.memoize = memoize;
exports.nextTick = nextTick;
exports.parallel = parallelLimit;
exports.parallelLimit = parallelLimit$1;
exports.priorityQueue = priorityQueue;
exports.queue = queue$1;
exports.race = race;
exports.reduce = reduce;
exports.reduceRight = reduceRight;
exports.reflect = reflect;
exports.reflectAll = reflectAll;
exports.reject = reject;
exports.rejectLimit = rejectLimit;
exports.rejectSeries = rejectSeries;
exports.retry = retry;
exports.retryable = retryable;
exports.seq = seq;
exports.series = series;
exports.setImmediate = setImmediate$1;
exports.some = some;
exports.someLimit = someLimit;
exports.someSeries = someSeries;
exports.sortBy = sortBy;
exports.timeout = timeout;
exports.times = times;
exports.timesLimit = timeLimit;
exports.timesSeries = timesSeries;
exports.transform = transform;
exports.tryEach = tryEach;
exports.unmemoize = unmemoize;
exports.until = until;
exports.waterfall = waterfall;
exports.whilst = whilst;
exports.all = every;
exports.allLimit = everyLimit;
exports.allSeries = everySeries;
exports.any = some;
exports.anyLimit = someLimit;
exports.anySeries = someSeries;
exports.find = detect;
exports.findLimit = detectLimit;
exports.findSeries = detectSeries;
exports.forEach = eachLimit;
exports.forEachSeries = eachSeries;
exports.forEachLimit = eachLimit$1;
exports.forEachOf = eachOf;
exports.forEachOfSeries = eachOfSeries;
exports.forEachOfLimit = eachOfLimit;
exports.inject = reduce;
exports.foldl = reduce;
exports.foldr = reduceRight;
exports.select = filter;
exports.selectLimit = filterLimit;
exports.selectSeries = filterSeries;
exports.wrapSync = asyncify;

Object.defineProperty(exports, '__esModule', { value: true });

})));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":3}],48:[function(require,module,exports){
(function (process){
'use strict';
var escapeStringRegexp = require('escape-string-regexp');
var ansiStyles = require('ansi-styles');
var stripAnsi = require('strip-ansi');
var hasAnsi = require('has-ansi');
var supportsColor = require('supports-color');
var defineProps = Object.defineProperties;
var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);

function Chalk(options) {
	// detect mode if not set manually
	this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
}

// use bright blue on Windows as the normal blue color is illegible
if (isSimpleWindowsTerm) {
	ansiStyles.blue.open = '\u001b[94m';
}

var styles = (function () {
	var ret = {};

	Object.keys(ansiStyles).forEach(function (key) {
		ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

		ret[key] = {
			get: function () {
				return build.call(this, this._styles.concat(key));
			}
		};
	});

	return ret;
})();

var proto = defineProps(function chalk() {}, styles);

function build(_styles) {
	var builder = function () {
		return applyStyle.apply(builder, arguments);
	};

	builder._styles = _styles;
	builder.enabled = this.enabled;
	// __proto__ is used because we must return a function, but there is
	// no way to create a function with a different prototype.
	/* eslint-disable no-proto */
	builder.__proto__ = proto;

	return builder;
}

function applyStyle() {
	// support varags, but simply cast to string in case there's only one arg
	var args = arguments;
	var argsLen = args.length;
	var str = argsLen !== 0 && String(arguments[0]);

	if (argsLen > 1) {
		// don't slice `arguments`, it prevents v8 optimizations
		for (var a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || !str) {
		return str;
	}

	var nestedStyles = this._styles;
	var i = nestedStyles.length;

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	var originalDim = ansiStyles.dim.open;
	if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
		ansiStyles.dim.open = '';
	}

	while (i--) {
		var code = ansiStyles[nestedStyles[i]];

		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;
	}

	// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
	ansiStyles.dim.open = originalDim;

	return str;
}

function init() {
	var ret = {};

	Object.keys(styles).forEach(function (name) {
		ret[name] = {
			get: function () {
				return build.call(this, [name]);
			}
		};
	});

	return ret;
}

defineProps(Chalk.prototype, init());

module.exports = new Chalk();
module.exports.styles = ansiStyles;
module.exports.hasColor = hasAnsi;
module.exports.stripColor = stripAnsi;
module.exports.supportsColor = supportsColor;

}).call(this,require('_process'))

},{"_process":3,"ansi-styles":46,"escape-string-regexp":50,"has-ansi":54,"strip-ansi":61,"supports-color":49}],49:[function(require,module,exports){
(function (process){
'use strict';
var argv = process.argv;

var terminator = argv.indexOf('--');
var hasFlag = function (flag) {
	flag = '--' + flag;
	var pos = argv.indexOf(flag);
	return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
};

module.exports = (function () {
	if ('FORCE_COLOR' in process.env) {
		return true;
	}

	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false')) {
		return false;
	}

	if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
})();

}).call(this,require('_process'))

},{"_process":3}],50:[function(require,module,exports){
'use strict';

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(matchOperatorsRe, '\\$&');
};

},{}],51:[function(require,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
/* istanbul ignore next */
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
/* istanbul ignore next */
	else if(typeof exports === 'object')
		exports["esprima"] = factory();
	else
		root["esprima"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/* istanbul ignore if */
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/*
	  Copyright JS Foundation and other contributors, https://js.foundation/

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	var comment_handler_1 = __webpack_require__(1);
	var jsx_parser_1 = __webpack_require__(3);
	var parser_1 = __webpack_require__(8);
	var tokenizer_1 = __webpack_require__(15);
	function parse(code, options, delegate) {
	    var commentHandler = null;
	    var proxyDelegate = function (node, metadata) {
	        if (delegate) {
	            delegate(node, metadata);
	        }
	        if (commentHandler) {
	            commentHandler.visit(node, metadata);
	        }
	    };
	    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;
	    var collectComment = false;
	    if (options) {
	        collectComment = (typeof options.comment === 'boolean' && options.comment);
	        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);
	        if (collectComment || attachComment) {
	            commentHandler = new comment_handler_1.CommentHandler();
	            commentHandler.attach = attachComment;
	            options.comment = true;
	            parserDelegate = proxyDelegate;
	        }
	    }
	    var isModule = false;
	    if (options && typeof options.sourceType === 'string') {
	        isModule = (options.sourceType === 'module');
	    }
	    var parser;
	    if (options && typeof options.jsx === 'boolean' && options.jsx) {
	        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
	    }
	    else {
	        parser = new parser_1.Parser(code, options, parserDelegate);
	    }
	    var program = isModule ? parser.parseModule() : parser.parseScript();
	    var ast = program;
	    if (collectComment && commentHandler) {
	        ast.comments = commentHandler.comments;
	    }
	    if (parser.config.tokens) {
	        ast.tokens = parser.tokens;
	    }
	    if (parser.config.tolerant) {
	        ast.errors = parser.errorHandler.errors;
	    }
	    return ast;
	}
	exports.parse = parse;
	function parseModule(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'module';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseModule = parseModule;
	function parseScript(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'script';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseScript = parseScript;
	function tokenize(code, options, delegate) {
	    var tokenizer = new tokenizer_1.Tokenizer(code, options);
	    var tokens;
	    tokens = [];
	    try {
	        while (true) {
	            var token = tokenizer.getNextToken();
	            if (!token) {
	                break;
	            }
	            if (delegate) {
	                token = delegate(token);
	            }
	            tokens.push(token);
	        }
	    }
	    catch (e) {
	        tokenizer.errorHandler.tolerate(e);
	    }
	    if (tokenizer.errorHandler.tolerant) {
	        tokens.errors = tokenizer.errors();
	    }
	    return tokens;
	}
	exports.tokenize = tokenize;
	var syntax_1 = __webpack_require__(2);
	exports.Syntax = syntax_1.Syntax;
	// Sync with *.json manifests.
	exports.version = '4.0.0';


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	var CommentHandler = (function () {
	    function CommentHandler() {
	        this.attach = false;
	        this.comments = [];
	        this.stack = [];
	        this.leading = [];
	        this.trailing = [];
	    }
	    CommentHandler.prototype.insertInnerComments = function (node, metadata) {
	        //  innnerComments for properties empty block
	        //  `function a() {/** comments **\/}`
	        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
	            var innerComments = [];
	            for (var i = this.leading.length - 1; i >= 0; --i) {
	                var entry = this.leading[i];
	                if (metadata.end.offset >= entry.start) {
	                    innerComments.unshift(entry.comment);
	                    this.leading.splice(i, 1);
	                    this.trailing.splice(i, 1);
	                }
	            }
	            if (innerComments.length) {
	                node.innerComments = innerComments;
	            }
	        }
	    };
	    CommentHandler.prototype.findTrailingComments = function (metadata) {
	        var trailingComments = [];
	        if (this.trailing.length > 0) {
	            for (var i = this.trailing.length - 1; i >= 0; --i) {
	                var entry_1 = this.trailing[i];
	                if (entry_1.start >= metadata.end.offset) {
	                    trailingComments.unshift(entry_1.comment);
	                }
	            }
	            this.trailing.length = 0;
	            return trailingComments;
	        }
	        var entry = this.stack[this.stack.length - 1];
	        if (entry && entry.node.trailingComments) {
	            var firstComment = entry.node.trailingComments[0];
	            if (firstComment && firstComment.range[0] >= metadata.end.offset) {
	                trailingComments = entry.node.trailingComments;
	                delete entry.node.trailingComments;
	            }
	        }
	        return trailingComments;
	    };
	    CommentHandler.prototype.findLeadingComments = function (metadata) {
	        var leadingComments = [];
	        var target;
	        while (this.stack.length > 0) {
	            var entry = this.stack[this.stack.length - 1];
	            if (entry && entry.start >= metadata.start.offset) {
	                target = entry.node;
	                this.stack.pop();
	            }
	            else {
	                break;
	            }
	        }
	        if (target) {
	            var count = target.leadingComments ? target.leadingComments.length : 0;
	            for (var i = count - 1; i >= 0; --i) {
	                var comment = target.leadingComments[i];
	                if (comment.range[1] <= metadata.start.offset) {
	                    leadingComments.unshift(comment);
	                    target.leadingComments.splice(i, 1);
	                }
	            }
	            if (target.leadingComments && target.leadingComments.length === 0) {
	                delete target.leadingComments;
	            }
	            return leadingComments;
	        }
	        for (var i = this.leading.length - 1; i >= 0; --i) {
	            var entry = this.leading[i];
	            if (entry.start <= metadata.start.offset) {
	                leadingComments.unshift(entry.comment);
	                this.leading.splice(i, 1);
	            }
	        }
	        return leadingComments;
	    };
	    CommentHandler.prototype.visitNode = function (node, metadata) {
	        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
	            return;
	        }
	        this.insertInnerComments(node, metadata);
	        var trailingComments = this.findTrailingComments(metadata);
	        var leadingComments = this.findLeadingComments(metadata);
	        if (leadingComments.length > 0) {
	            node.leadingComments = leadingComments;
	        }
	        if (trailingComments.length > 0) {
	            node.trailingComments = trailingComments;
	        }
	        this.stack.push({
	            node: node,
	            start: metadata.start.offset
	        });
	    };
	    CommentHandler.prototype.visitComment = function (node, metadata) {
	        var type = (node.type[0] === 'L') ? 'Line' : 'Block';
	        var comment = {
	            type: type,
	            value: node.value
	        };
	        if (node.range) {
	            comment.range = node.range;
	        }
	        if (node.loc) {
	            comment.loc = node.loc;
	        }
	        this.comments.push(comment);
	        if (this.attach) {
	            var entry = {
	                comment: {
	                    type: type,
	                    value: node.value,
	                    range: [metadata.start.offset, metadata.end.offset]
	                },
	                start: metadata.start.offset
	            };
	            if (node.loc) {
	                entry.comment.loc = node.loc;
	            }
	            node.type = type;
	            this.leading.push(entry);
	            this.trailing.push(entry);
	        }
	    };
	    CommentHandler.prototype.visit = function (node, metadata) {
	        if (node.type === 'LineComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (node.type === 'BlockComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (this.attach) {
	            this.visitNode(node, metadata);
	        }
	    };
	    return CommentHandler;
	}());
	exports.CommentHandler = CommentHandler;


/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Syntax = {
	    AssignmentExpression: 'AssignmentExpression',
	    AssignmentPattern: 'AssignmentPattern',
	    ArrayExpression: 'ArrayExpression',
	    ArrayPattern: 'ArrayPattern',
	    ArrowFunctionExpression: 'ArrowFunctionExpression',
	    AwaitExpression: 'AwaitExpression',
	    BlockStatement: 'BlockStatement',
	    BinaryExpression: 'BinaryExpression',
	    BreakStatement: 'BreakStatement',
	    CallExpression: 'CallExpression',
	    CatchClause: 'CatchClause',
	    ClassBody: 'ClassBody',
	    ClassDeclaration: 'ClassDeclaration',
	    ClassExpression: 'ClassExpression',
	    ConditionalExpression: 'ConditionalExpression',
	    ContinueStatement: 'ContinueStatement',
	    DoWhileStatement: 'DoWhileStatement',
	    DebuggerStatement: 'DebuggerStatement',
	    EmptyStatement: 'EmptyStatement',
	    ExportAllDeclaration: 'ExportAllDeclaration',
	    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	    ExportNamedDeclaration: 'ExportNamedDeclaration',
	    ExportSpecifier: 'ExportSpecifier',
	    ExpressionStatement: 'ExpressionStatement',
	    ForStatement: 'ForStatement',
	    ForOfStatement: 'ForOfStatement',
	    ForInStatement: 'ForInStatement',
	    FunctionDeclaration: 'FunctionDeclaration',
	    FunctionExpression: 'FunctionExpression',
	    Identifier: 'Identifier',
	    IfStatement: 'IfStatement',
	    ImportDeclaration: 'ImportDeclaration',
	    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	    ImportSpecifier: 'ImportSpecifier',
	    Literal: 'Literal',
	    LabeledStatement: 'LabeledStatement',
	    LogicalExpression: 'LogicalExpression',
	    MemberExpression: 'MemberExpression',
	    MetaProperty: 'MetaProperty',
	    MethodDefinition: 'MethodDefinition',
	    NewExpression: 'NewExpression',
	    ObjectExpression: 'ObjectExpression',
	    ObjectPattern: 'ObjectPattern',
	    Program: 'Program',
	    Property: 'Property',
	    RestElement: 'RestElement',
	    ReturnStatement: 'ReturnStatement',
	    SequenceExpression: 'SequenceExpression',
	    SpreadElement: 'SpreadElement',
	    Super: 'Super',
	    SwitchCase: 'SwitchCase',
	    SwitchStatement: 'SwitchStatement',
	    TaggedTemplateExpression: 'TaggedTemplateExpression',
	    TemplateElement: 'TemplateElement',
	    TemplateLiteral: 'TemplateLiteral',
	    ThisExpression: 'ThisExpression',
	    ThrowStatement: 'ThrowStatement',
	    TryStatement: 'TryStatement',
	    UnaryExpression: 'UnaryExpression',
	    UpdateExpression: 'UpdateExpression',
	    VariableDeclaration: 'VariableDeclaration',
	    VariableDeclarator: 'VariableDeclarator',
	    WhileStatement: 'WhileStatement',
	    WithStatement: 'WithStatement',
	    YieldExpression: 'YieldExpression'
	};


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
/* istanbul ignore next */
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var character_1 = __webpack_require__(4);
	var JSXNode = __webpack_require__(5);
	var jsx_syntax_1 = __webpack_require__(6);
	var Node = __webpack_require__(7);
	var parser_1 = __webpack_require__(8);
	var token_1 = __webpack_require__(13);
	var xhtml_entities_1 = __webpack_require__(14);
	token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
	token_1.TokenName[101 /* Text */] = 'JSXText';
	// Fully qualified element name, e.g. <svg:path> returns "svg:path"
	function getQualifiedElementName(elementName) {
	    var qualifiedName;
	    switch (elementName.type) {
	        case jsx_syntax_1.JSXSyntax.JSXIdentifier:
	            var id = elementName;
	            qualifiedName = id.name;
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
	            var ns = elementName;
	            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +
	                getQualifiedElementName(ns.name);
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
	            var expr = elementName;
	            qualifiedName = getQualifiedElementName(expr.object) + '.' +
	                getQualifiedElementName(expr.property);
	            break;
	        /* istanbul ignore next */
	        default:
	            break;
	    }
	    return qualifiedName;
	}
	var JSXParser = (function (_super) {
	    __extends(JSXParser, _super);
	    function JSXParser(code, options, delegate) {
	        return _super.call(this, code, options, delegate) || this;
	    }
	    JSXParser.prototype.parsePrimaryExpression = function () {
	        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
	    };
	    JSXParser.prototype.startJSX = function () {
	        // Unwind the scanner before the lookahead token.
	        this.scanner.index = this.startMarker.index;
	        this.scanner.lineNumber = this.startMarker.line;
	        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
	    };
	    JSXParser.prototype.finishJSX = function () {
	        // Prime the next lookahead.
	        this.nextToken();
	    };
	    JSXParser.prototype.reenterJSX = function () {
	        this.startJSX();
	        this.expectJSX('}');
	        // Pop the closing '}' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	    };
	    JSXParser.prototype.createJSXNode = function () {
	        this.collectComments();
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.createJSXChildNode = function () {
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.scanXHTMLEntity = function (quote) {
	        var result = '&';
	        var valid = true;
	        var terminated = false;
	        var numeric = false;
	        var hex = false;
	        while (!this.scanner.eof() && valid && !terminated) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === quote) {
	                break;
	            }
	            terminated = (ch === ';');
	            result += ch;
	            ++this.scanner.index;
	            if (!terminated) {
	                switch (result.length) {
	                    case 2:
	                        // e.g. '&#123;'
	                        numeric = (ch === '#');
	                        break;
	                    case 3:
	                        if (numeric) {
	                            // e.g. '&#x41;'
	                            hex = (ch === 'x');
	                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
	                            numeric = numeric && !hex;
	                        }
	                        break;
	                    default:
	                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
	                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
	                        break;
	                }
	            }
	        }
	        if (valid && terminated && result.length > 2) {
	            // e.g. '&#x41;' becomes just '#x41'
	            var str = result.substr(1, result.length - 2);
	            if (numeric && str.length > 1) {
	                result = String.fromCharCode(parseInt(str.substr(1), 10));
	            }
	            else if (hex && str.length > 2) {
	                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
	            }
	            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
	                result = xhtml_entities_1.XHTMLEntities[str];
	            }
	        }
	        return result;
	    };
	    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
	    JSXParser.prototype.lexJSX = function () {
	        var cp = this.scanner.source.charCodeAt(this.scanner.index);
	        // < > / : = { }
	        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
	            var value = this.scanner.source[this.scanner.index++];
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index - 1,
	                end: this.scanner.index
	            };
	        }
	        // " '
	        if (cp === 34 || cp === 39) {
	            var start = this.scanner.index;
	            var quote = this.scanner.source[this.scanner.index++];
	            var str = '';
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source[this.scanner.index++];
	                if (ch === quote) {
	                    break;
	                }
	                else if (ch === '&') {
	                    str += this.scanXHTMLEntity(quote);
	                }
	                else {
	                    str += ch;
	                }
	            }
	            return {
	                type: 8 /* StringLiteral */,
	                value: str,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // ... or .
	        if (cp === 46) {
	            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
	            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
	            var value = (n1 === 46 && n2 === 46) ? '...' : '.';
	            var start = this.scanner.index;
	            this.scanner.index += value.length;
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // `
	        if (cp === 96) {
	            // Only placeholder, since it will be rescanned as a real assignment expression.
	            return {
	                type: 10 /* Template */,
	                value: '',
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index,
	                end: this.scanner.index
	            };
	        }
	        // Identifer can not contain backslash (char code 92).
	        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {
	            var start = this.scanner.index;
	            ++this.scanner.index;
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source.charCodeAt(this.scanner.index);
	                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {
	                    ++this.scanner.index;
	                }
	                else if (ch === 45) {
	                    // Hyphen (char code 45) can be part of an identifier.
	                    ++this.scanner.index;
	                }
	                else {
	                    break;
	                }
	            }
	            var id = this.scanner.source.slice(start, this.scanner.index);
	            return {
	                type: 100 /* Identifier */,
	                value: id,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        return this.scanner.lex();
	    };
	    JSXParser.prototype.nextJSXToken = function () {
	        this.collectComments();
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = this.lexJSX();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        if (this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.nextJSXText = function () {
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var start = this.scanner.index;
	        var text = '';
	        while (!this.scanner.eof()) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === '{' || ch === '<') {
	                break;
	            }
	            ++this.scanner.index;
	            text += ch;
	            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.scanner.lineNumber;
	                if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
	                    ++this.scanner.index;
	                }
	                this.scanner.lineStart = this.scanner.index;
	            }
	        }
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = {
	            type: 101 /* Text */,
	            value: text,
	            lineNumber: this.scanner.lineNumber,
	            lineStart: this.scanner.lineStart,
	            start: start,
	            end: this.scanner.index
	        };
	        if ((text.length > 0) && this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.peekJSXToken = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.lexJSX();
	        this.scanner.restoreState(state);
	        return next;
	    };
	    // Expect the next JSX token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    JSXParser.prototype.expectJSX = function (value) {
	        var token = this.nextJSXToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next JSX token matches the specified punctuator.
	    JSXParser.prototype.matchJSX = function (value) {
	        var next = this.peekJSXToken();
	        return next.type === 7 /* Punctuator */ && next.value === value;
	    };
	    JSXParser.prototype.parseJSXIdentifier = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 100 /* Identifier */) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
	    };
	    JSXParser.prototype.parseJSXElementName = function () {
	        var node = this.createJSXNode();
	        var elementName = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = elementName;
	            this.expectJSX(':');
	            var name_1 = this.parseJSXIdentifier();
	            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
	        }
	        else if (this.matchJSX('.')) {
	            while (this.matchJSX('.')) {
	                var object = elementName;
	                this.expectJSX('.');
	                var property = this.parseJSXIdentifier();
	                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
	            }
	        }
	        return elementName;
	    };
	    JSXParser.prototype.parseJSXAttributeName = function () {
	        var node = this.createJSXNode();
	        var attributeName;
	        var identifier = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = identifier;
	            this.expectJSX(':');
	            var name_2 = this.parseJSXIdentifier();
	            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
	        }
	        else {
	            attributeName = identifier;
	        }
	        return attributeName;
	    };
	    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 8 /* StringLiteral */) {
	            this.throwUnexpectedToken(token);
	        }
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    JSXParser.prototype.parseJSXExpressionAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.finishJSX();
	        if (this.match('}')) {
	            this.tolerateError('JSX attributes must only be assigned a non-empty expression');
	        }
	        var expression = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXAttributeValue = function () {
	        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :
	            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
	    };
	    JSXParser.prototype.parseJSXNameValueAttribute = function () {
	        var node = this.createJSXNode();
	        var name = this.parseJSXAttributeName();
	        var value = null;
	        if (this.matchJSX('=')) {
	            this.expectJSX('=');
	            value = this.parseJSXAttributeValue();
	        }
	        return this.finalize(node, new JSXNode.JSXAttribute(name, value));
	    };
	    JSXParser.prototype.parseJSXSpreadAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.expectJSX('...');
	        this.finishJSX();
	        var argument = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
	    };
	    JSXParser.prototype.parseJSXAttributes = function () {
	        var attributes = [];
	        while (!this.matchJSX('/') && !this.matchJSX('>')) {
	            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :
	                this.parseJSXNameValueAttribute();
	            attributes.push(attribute);
	        }
	        return attributes;
	    };
	    JSXParser.prototype.parseJSXOpeningElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXBoundaryElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        if (this.matchJSX('/')) {
	            this.expectJSX('/');
	            var name_3 = this.parseJSXElementName();
	            this.expectJSX('>');
	            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
	        }
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXEmptyExpression = function () {
	        var node = this.createJSXChildNode();
	        this.collectComments();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        return this.finalize(node, new JSXNode.JSXEmptyExpression());
	    };
	    JSXParser.prototype.parseJSXExpressionContainer = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        var expression;
	        if (this.matchJSX('}')) {
	            expression = this.parseJSXEmptyExpression();
	            this.expectJSX('}');
	        }
	        else {
	            this.finishJSX();
	            expression = this.parseAssignmentExpression();
	            this.reenterJSX();
	        }
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXChildren = function () {
	        var children = [];
	        while (!this.scanner.eof()) {
	            var node = this.createJSXChildNode();
	            var token = this.nextJSXText();
	            if (token.start < token.end) {
	                var raw = this.getTokenRaw(token);
	                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
	                children.push(child);
	            }
	            if (this.scanner.source[this.scanner.index] === '{') {
	                var container = this.parseJSXExpressionContainer();
	                children.push(container);
	            }
	            else {
	                break;
	            }
	        }
	        return children;
	    };
	    JSXParser.prototype.parseComplexJSXElement = function (el) {
	        var stack = [];
	        while (!this.scanner.eof()) {
	            el.children = el.children.concat(this.parseJSXChildren());
	            var node = this.createJSXChildNode();
	            var element = this.parseJSXBoundaryElement();
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
	                var opening = element;
	                if (opening.selfClosing) {
	                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
	                    el.children.push(child);
	                }
	                else {
	                    stack.push(el);
	                    el = { node: node, opening: opening, closing: null, children: [] };
	                }
	            }
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
	                el.closing = element;
	                var open_1 = getQualifiedElementName(el.opening.name);
	                var close_1 = getQualifiedElementName(el.closing.name);
	                if (open_1 !== close_1) {
	                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
	                }
	                if (stack.length > 0) {
	                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
	                    el = stack[stack.length - 1];
	                    el.children.push(child);
	                    stack.pop();
	                }
	                else {
	                    break;
	                }
	            }
	        }
	        return el;
	    };
	    JSXParser.prototype.parseJSXElement = function () {
	        var node = this.createJSXNode();
	        var opening = this.parseJSXOpeningElement();
	        var children = [];
	        var closing = null;
	        if (!opening.selfClosing) {
	            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
	            children = el.children;
	            closing = el.closing;
	        }
	        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
	    };
	    JSXParser.prototype.parseJSXRoot = function () {
	        // Pop the opening '<' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	        this.startJSX();
	        var element = this.parseJSXElement();
	        this.finishJSX();
	        return element;
	    };
	    JSXParser.prototype.isStartOfExpression = function () {
	        return _super.prototype.isStartOfExpression.call(this) || this.match('<');
	    };
	    return JSXParser;
	}(parser_1.Parser));
	exports.JSXParser = JSXParser;


/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// See also tools/generate-unicode-regex.js.
	var Regex = {
	    // Unicode v8.0.0 NonAsciiIdentifierStart:
	    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
	    // Unicode v8.0.0 NonAsciiIdentifierPart:
	    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	};
	exports.Character = {
	    /* tslint:disable:no-bitwise */
	    fromCodePoint: function (cp) {
	        return (cp < 0x10000) ? String.fromCharCode(cp) :
	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
	                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
	    },
	    // https://tc39.github.io/ecma262/#sec-white-space
	    isWhiteSpace: function (cp) {
	        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
	            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
	    },
	    // https://tc39.github.io/ecma262/#sec-line-terminators
	    isLineTerminator: function (cp) {
	        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
	    },
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    isIdentifierStart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));
	    },
	    isIdentifierPart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp >= 0x30 && cp <= 0x39) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));
	    },
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    isDecimalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39); // 0..9
	    },
	    isHexDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39) ||
	            (cp >= 0x41 && cp <= 0x46) ||
	            (cp >= 0x61 && cp <= 0x66); // a..f
	    },
	    isOctalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x37); // 0..7
	    }
	};


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var jsx_syntax_1 = __webpack_require__(6);
	/* tslint:disable:max-classes-per-file */
	var JSXClosingElement = (function () {
	    function JSXClosingElement(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
	        this.name = name;
	    }
	    return JSXClosingElement;
	}());
	exports.JSXClosingElement = JSXClosingElement;
	var JSXElement = (function () {
	    function JSXElement(openingElement, children, closingElement) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXElement;
	        this.openingElement = openingElement;
	        this.children = children;
	        this.closingElement = closingElement;
	    }
	    return JSXElement;
	}());
	exports.JSXElement = JSXElement;
	var JSXEmptyExpression = (function () {
	    function JSXEmptyExpression() {
	        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
	    }
	    return JSXEmptyExpression;
	}());
	exports.JSXEmptyExpression = JSXEmptyExpression;
	var JSXExpressionContainer = (function () {
	    function JSXExpressionContainer(expression) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
	        this.expression = expression;
	    }
	    return JSXExpressionContainer;
	}());
	exports.JSXExpressionContainer = JSXExpressionContainer;
	var JSXIdentifier = (function () {
	    function JSXIdentifier(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
	        this.name = name;
	    }
	    return JSXIdentifier;
	}());
	exports.JSXIdentifier = JSXIdentifier;
	var JSXMemberExpression = (function () {
	    function JSXMemberExpression(object, property) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
	        this.object = object;
	        this.property = property;
	    }
	    return JSXMemberExpression;
	}());
	exports.JSXMemberExpression = JSXMemberExpression;
	var JSXAttribute = (function () {
	    function JSXAttribute(name, value) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
	        this.name = name;
	        this.value = value;
	    }
	    return JSXAttribute;
	}());
	exports.JSXAttribute = JSXAttribute;
	var JSXNamespacedName = (function () {
	    function JSXNamespacedName(namespace, name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
	        this.namespace = namespace;
	        this.name = name;
	    }
	    return JSXNamespacedName;
	}());
	exports.JSXNamespacedName = JSXNamespacedName;
	var JSXOpeningElement = (function () {
	    function JSXOpeningElement(name, selfClosing, attributes) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
	        this.name = name;
	        this.selfClosing = selfClosing;
	        this.attributes = attributes;
	    }
	    return JSXOpeningElement;
	}());
	exports.JSXOpeningElement = JSXOpeningElement;
	var JSXSpreadAttribute = (function () {
	    function JSXSpreadAttribute(argument) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
	        this.argument = argument;
	    }
	    return JSXSpreadAttribute;
	}());
	exports.JSXSpreadAttribute = JSXSpreadAttribute;
	var JSXText = (function () {
	    function JSXText(value, raw) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXText;
	        this.value = value;
	        this.raw = raw;
	    }
	    return JSXText;
	}());
	exports.JSXText = JSXText;


/***/ },
/* 6 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JSXSyntax = {
	    JSXAttribute: 'JSXAttribute',
	    JSXClosingElement: 'JSXClosingElement',
	    JSXElement: 'JSXElement',
	    JSXEmptyExpression: 'JSXEmptyExpression',
	    JSXExpressionContainer: 'JSXExpressionContainer',
	    JSXIdentifier: 'JSXIdentifier',
	    JSXMemberExpression: 'JSXMemberExpression',
	    JSXNamespacedName: 'JSXNamespacedName',
	    JSXOpeningElement: 'JSXOpeningElement',
	    JSXSpreadAttribute: 'JSXSpreadAttribute',
	    JSXText: 'JSXText'
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	/* tslint:disable:max-classes-per-file */
	var ArrayExpression = (function () {
	    function ArrayExpression(elements) {
	        this.type = syntax_1.Syntax.ArrayExpression;
	        this.elements = elements;
	    }
	    return ArrayExpression;
	}());
	exports.ArrayExpression = ArrayExpression;
	var ArrayPattern = (function () {
	    function ArrayPattern(elements) {
	        this.type = syntax_1.Syntax.ArrayPattern;
	        this.elements = elements;
	    }
	    return ArrayPattern;
	}());
	exports.ArrayPattern = ArrayPattern;
	var ArrowFunctionExpression = (function () {
	    function ArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = false;
	    }
	    return ArrowFunctionExpression;
	}());
	exports.ArrowFunctionExpression = ArrowFunctionExpression;
	var AssignmentExpression = (function () {
	    function AssignmentExpression(operator, left, right) {
	        this.type = syntax_1.Syntax.AssignmentExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentExpression;
	}());
	exports.AssignmentExpression = AssignmentExpression;
	var AssignmentPattern = (function () {
	    function AssignmentPattern(left, right) {
	        this.type = syntax_1.Syntax.AssignmentPattern;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentPattern;
	}());
	exports.AssignmentPattern = AssignmentPattern;
	var AsyncArrowFunctionExpression = (function () {
	    function AsyncArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = true;
	    }
	    return AsyncArrowFunctionExpression;
	}());
	exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
	var AsyncFunctionDeclaration = (function () {
	    function AsyncFunctionDeclaration(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionDeclaration;
	}());
	exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
	var AsyncFunctionExpression = (function () {
	    function AsyncFunctionExpression(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionExpression;
	}());
	exports.AsyncFunctionExpression = AsyncFunctionExpression;
	var AwaitExpression = (function () {
	    function AwaitExpression(argument) {
	        this.type = syntax_1.Syntax.AwaitExpression;
	        this.argument = argument;
	    }
	    return AwaitExpression;
	}());
	exports.AwaitExpression = AwaitExpression;
	var BinaryExpression = (function () {
	    function BinaryExpression(operator, left, right) {
	        var logical = (operator === '||' || operator === '&&');
	        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return BinaryExpression;
	}());
	exports.BinaryExpression = BinaryExpression;
	var BlockStatement = (function () {
	    function BlockStatement(body) {
	        this.type = syntax_1.Syntax.BlockStatement;
	        this.body = body;
	    }
	    return BlockStatement;
	}());
	exports.BlockStatement = BlockStatement;
	var BreakStatement = (function () {
	    function BreakStatement(label) {
	        this.type = syntax_1.Syntax.BreakStatement;
	        this.label = label;
	    }
	    return BreakStatement;
	}());
	exports.BreakStatement = BreakStatement;
	var CallExpression = (function () {
	    function CallExpression(callee, args) {
	        this.type = syntax_1.Syntax.CallExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return CallExpression;
	}());
	exports.CallExpression = CallExpression;
	var CatchClause = (function () {
	    function CatchClause(param, body) {
	        this.type = syntax_1.Syntax.CatchClause;
	        this.param = param;
	        this.body = body;
	    }
	    return CatchClause;
	}());
	exports.CatchClause = CatchClause;
	var ClassBody = (function () {
	    function ClassBody(body) {
	        this.type = syntax_1.Syntax.ClassBody;
	        this.body = body;
	    }
	    return ClassBody;
	}());
	exports.ClassBody = ClassBody;
	var ClassDeclaration = (function () {
	    function ClassDeclaration(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassDeclaration;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassDeclaration;
	}());
	exports.ClassDeclaration = ClassDeclaration;
	var ClassExpression = (function () {
	    function ClassExpression(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassExpression;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassExpression;
	}());
	exports.ClassExpression = ClassExpression;
	var ComputedMemberExpression = (function () {
	    function ComputedMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = true;
	        this.object = object;
	        this.property = property;
	    }
	    return ComputedMemberExpression;
	}());
	exports.ComputedMemberExpression = ComputedMemberExpression;
	var ConditionalExpression = (function () {
	    function ConditionalExpression(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.ConditionalExpression;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return ConditionalExpression;
	}());
	exports.ConditionalExpression = ConditionalExpression;
	var ContinueStatement = (function () {
	    function ContinueStatement(label) {
	        this.type = syntax_1.Syntax.ContinueStatement;
	        this.label = label;
	    }
	    return ContinueStatement;
	}());
	exports.ContinueStatement = ContinueStatement;
	var DebuggerStatement = (function () {
	    function DebuggerStatement() {
	        this.type = syntax_1.Syntax.DebuggerStatement;
	    }
	    return DebuggerStatement;
	}());
	exports.DebuggerStatement = DebuggerStatement;
	var Directive = (function () {
	    function Directive(expression, directive) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	        this.directive = directive;
	    }
	    return Directive;
	}());
	exports.Directive = Directive;
	var DoWhileStatement = (function () {
	    function DoWhileStatement(body, test) {
	        this.type = syntax_1.Syntax.DoWhileStatement;
	        this.body = body;
	        this.test = test;
	    }
	    return DoWhileStatement;
	}());
	exports.DoWhileStatement = DoWhileStatement;
	var EmptyStatement = (function () {
	    function EmptyStatement() {
	        this.type = syntax_1.Syntax.EmptyStatement;
	    }
	    return EmptyStatement;
	}());
	exports.EmptyStatement = EmptyStatement;
	var ExportAllDeclaration = (function () {
	    function ExportAllDeclaration(source) {
	        this.type = syntax_1.Syntax.ExportAllDeclaration;
	        this.source = source;
	    }
	    return ExportAllDeclaration;
	}());
	exports.ExportAllDeclaration = ExportAllDeclaration;
	var ExportDefaultDeclaration = (function () {
	    function ExportDefaultDeclaration(declaration) {
	        this.type = syntax_1.Syntax.ExportDefaultDeclaration;
	        this.declaration = declaration;
	    }
	    return ExportDefaultDeclaration;
	}());
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	var ExportNamedDeclaration = (function () {
	    function ExportNamedDeclaration(declaration, specifiers, source) {
	        this.type = syntax_1.Syntax.ExportNamedDeclaration;
	        this.declaration = declaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ExportNamedDeclaration;
	}());
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	var ExportSpecifier = (function () {
	    function ExportSpecifier(local, exported) {
	        this.type = syntax_1.Syntax.ExportSpecifier;
	        this.exported = exported;
	        this.local = local;
	    }
	    return ExportSpecifier;
	}());
	exports.ExportSpecifier = ExportSpecifier;
	var ExpressionStatement = (function () {
	    function ExpressionStatement(expression) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	    }
	    return ExpressionStatement;
	}());
	exports.ExpressionStatement = ExpressionStatement;
	var ForInStatement = (function () {
	    function ForInStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForInStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	        this.each = false;
	    }
	    return ForInStatement;
	}());
	exports.ForInStatement = ForInStatement;
	var ForOfStatement = (function () {
	    function ForOfStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForOfStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	    }
	    return ForOfStatement;
	}());
	exports.ForOfStatement = ForOfStatement;
	var ForStatement = (function () {
	    function ForStatement(init, test, update, body) {
	        this.type = syntax_1.Syntax.ForStatement;
	        this.init = init;
	        this.test = test;
	        this.update = update;
	        this.body = body;
	    }
	    return ForStatement;
	}());
	exports.ForStatement = ForStatement;
	var FunctionDeclaration = (function () {
	    function FunctionDeclaration(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionDeclaration;
	}());
	exports.FunctionDeclaration = FunctionDeclaration;
	var FunctionExpression = (function () {
	    function FunctionExpression(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionExpression;
	}());
	exports.FunctionExpression = FunctionExpression;
	var Identifier = (function () {
	    function Identifier(name) {
	        this.type = syntax_1.Syntax.Identifier;
	        this.name = name;
	    }
	    return Identifier;
	}());
	exports.Identifier = Identifier;
	var IfStatement = (function () {
	    function IfStatement(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.IfStatement;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return IfStatement;
	}());
	exports.IfStatement = IfStatement;
	var ImportDeclaration = (function () {
	    function ImportDeclaration(specifiers, source) {
	        this.type = syntax_1.Syntax.ImportDeclaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ImportDeclaration;
	}());
	exports.ImportDeclaration = ImportDeclaration;
	var ImportDefaultSpecifier = (function () {
	    function ImportDefaultSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportDefaultSpecifier;
	        this.local = local;
	    }
	    return ImportDefaultSpecifier;
	}());
	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	var ImportNamespaceSpecifier = (function () {
	    function ImportNamespaceSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
	        this.local = local;
	    }
	    return ImportNamespaceSpecifier;
	}());
	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
	var ImportSpecifier = (function () {
	    function ImportSpecifier(local, imported) {
	        this.type = syntax_1.Syntax.ImportSpecifier;
	        this.local = local;
	        this.imported = imported;
	    }
	    return ImportSpecifier;
	}());
	exports.ImportSpecifier = ImportSpecifier;
	var LabeledStatement = (function () {
	    function LabeledStatement(label, body) {
	        this.type = syntax_1.Syntax.LabeledStatement;
	        this.label = label;
	        this.body = body;
	    }
	    return LabeledStatement;
	}());
	exports.LabeledStatement = LabeledStatement;
	var Literal = (function () {
	    function Literal(value, raw) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	    }
	    return Literal;
	}());
	exports.Literal = Literal;
	var MetaProperty = (function () {
	    function MetaProperty(meta, property) {
	        this.type = syntax_1.Syntax.MetaProperty;
	        this.meta = meta;
	        this.property = property;
	    }
	    return MetaProperty;
	}());
	exports.MetaProperty = MetaProperty;
	var MethodDefinition = (function () {
	    function MethodDefinition(key, computed, value, kind, isStatic) {
	        this.type = syntax_1.Syntax.MethodDefinition;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.static = isStatic;
	    }
	    return MethodDefinition;
	}());
	exports.MethodDefinition = MethodDefinition;
	var Module = (function () {
	    function Module(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'module';
	    }
	    return Module;
	}());
	exports.Module = Module;
	var NewExpression = (function () {
	    function NewExpression(callee, args) {
	        this.type = syntax_1.Syntax.NewExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return NewExpression;
	}());
	exports.NewExpression = NewExpression;
	var ObjectExpression = (function () {
	    function ObjectExpression(properties) {
	        this.type = syntax_1.Syntax.ObjectExpression;
	        this.properties = properties;
	    }
	    return ObjectExpression;
	}());
	exports.ObjectExpression = ObjectExpression;
	var ObjectPattern = (function () {
	    function ObjectPattern(properties) {
	        this.type = syntax_1.Syntax.ObjectPattern;
	        this.properties = properties;
	    }
	    return ObjectPattern;
	}());
	exports.ObjectPattern = ObjectPattern;
	var Property = (function () {
	    function Property(kind, key, computed, value, method, shorthand) {
	        this.type = syntax_1.Syntax.Property;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.method = method;
	        this.shorthand = shorthand;
	    }
	    return Property;
	}());
	exports.Property = Property;
	var RegexLiteral = (function () {
	    function RegexLiteral(value, raw, pattern, flags) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	        this.regex = { pattern: pattern, flags: flags };
	    }
	    return RegexLiteral;
	}());
	exports.RegexLiteral = RegexLiteral;
	var RestElement = (function () {
	    function RestElement(argument) {
	        this.type = syntax_1.Syntax.RestElement;
	        this.argument = argument;
	    }
	    return RestElement;
	}());
	exports.RestElement = RestElement;
	var ReturnStatement = (function () {
	    function ReturnStatement(argument) {
	        this.type = syntax_1.Syntax.ReturnStatement;
	        this.argument = argument;
	    }
	    return ReturnStatement;
	}());
	exports.ReturnStatement = ReturnStatement;
	var Script = (function () {
	    function Script(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'script';
	    }
	    return Script;
	}());
	exports.Script = Script;
	var SequenceExpression = (function () {
	    function SequenceExpression(expressions) {
	        this.type = syntax_1.Syntax.SequenceExpression;
	        this.expressions = expressions;
	    }
	    return SequenceExpression;
	}());
	exports.SequenceExpression = SequenceExpression;
	var SpreadElement = (function () {
	    function SpreadElement(argument) {
	        this.type = syntax_1.Syntax.SpreadElement;
	        this.argument = argument;
	    }
	    return SpreadElement;
	}());
	exports.SpreadElement = SpreadElement;
	var StaticMemberExpression = (function () {
	    function StaticMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = false;
	        this.object = object;
	        this.property = property;
	    }
	    return StaticMemberExpression;
	}());
	exports.StaticMemberExpression = StaticMemberExpression;
	var Super = (function () {
	    function Super() {
	        this.type = syntax_1.Syntax.Super;
	    }
	    return Super;
	}());
	exports.Super = Super;
	var SwitchCase = (function () {
	    function SwitchCase(test, consequent) {
	        this.type = syntax_1.Syntax.SwitchCase;
	        this.test = test;
	        this.consequent = consequent;
	    }
	    return SwitchCase;
	}());
	exports.SwitchCase = SwitchCase;
	var SwitchStatement = (function () {
	    function SwitchStatement(discriminant, cases) {
	        this.type = syntax_1.Syntax.SwitchStatement;
	        this.discriminant = discriminant;
	        this.cases = cases;
	    }
	    return SwitchStatement;
	}());
	exports.SwitchStatement = SwitchStatement;
	var TaggedTemplateExpression = (function () {
	    function TaggedTemplateExpression(tag, quasi) {
	        this.type = syntax_1.Syntax.TaggedTemplateExpression;
	        this.tag = tag;
	        this.quasi = quasi;
	    }
	    return TaggedTemplateExpression;
	}());
	exports.TaggedTemplateExpression = TaggedTemplateExpression;
	var TemplateElement = (function () {
	    function TemplateElement(value, tail) {
	        this.type = syntax_1.Syntax.TemplateElement;
	        this.value = value;
	        this.tail = tail;
	    }
	    return TemplateElement;
	}());
	exports.TemplateElement = TemplateElement;
	var TemplateLiteral = (function () {
	    function TemplateLiteral(quasis, expressions) {
	        this.type = syntax_1.Syntax.TemplateLiteral;
	        this.quasis = quasis;
	        this.expressions = expressions;
	    }
	    return TemplateLiteral;
	}());
	exports.TemplateLiteral = TemplateLiteral;
	var ThisExpression = (function () {
	    function ThisExpression() {
	        this.type = syntax_1.Syntax.ThisExpression;
	    }
	    return ThisExpression;
	}());
	exports.ThisExpression = ThisExpression;
	var ThrowStatement = (function () {
	    function ThrowStatement(argument) {
	        this.type = syntax_1.Syntax.ThrowStatement;
	        this.argument = argument;
	    }
	    return ThrowStatement;
	}());
	exports.ThrowStatement = ThrowStatement;
	var TryStatement = (function () {
	    function TryStatement(block, handler, finalizer) {
	        this.type = syntax_1.Syntax.TryStatement;
	        this.block = block;
	        this.handler = handler;
	        this.finalizer = finalizer;
	    }
	    return TryStatement;
	}());
	exports.TryStatement = TryStatement;
	var UnaryExpression = (function () {
	    function UnaryExpression(operator, argument) {
	        this.type = syntax_1.Syntax.UnaryExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = true;
	    }
	    return UnaryExpression;
	}());
	exports.UnaryExpression = UnaryExpression;
	var UpdateExpression = (function () {
	    function UpdateExpression(operator, argument, prefix) {
	        this.type = syntax_1.Syntax.UpdateExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = prefix;
	    }
	    return UpdateExpression;
	}());
	exports.UpdateExpression = UpdateExpression;
	var VariableDeclaration = (function () {
	    function VariableDeclaration(declarations, kind) {
	        this.type = syntax_1.Syntax.VariableDeclaration;
	        this.declarations = declarations;
	        this.kind = kind;
	    }
	    return VariableDeclaration;
	}());
	exports.VariableDeclaration = VariableDeclaration;
	var VariableDeclarator = (function () {
	    function VariableDeclarator(id, init) {
	        this.type = syntax_1.Syntax.VariableDeclarator;
	        this.id = id;
	        this.init = init;
	    }
	    return VariableDeclarator;
	}());
	exports.VariableDeclarator = VariableDeclarator;
	var WhileStatement = (function () {
	    function WhileStatement(test, body) {
	        this.type = syntax_1.Syntax.WhileStatement;
	        this.test = test;
	        this.body = body;
	    }
	    return WhileStatement;
	}());
	exports.WhileStatement = WhileStatement;
	var WithStatement = (function () {
	    function WithStatement(object, body) {
	        this.type = syntax_1.Syntax.WithStatement;
	        this.object = object;
	        this.body = body;
	    }
	    return WithStatement;
	}());
	exports.WithStatement = WithStatement;
	var YieldExpression = (function () {
	    function YieldExpression(argument, delegate) {
	        this.type = syntax_1.Syntax.YieldExpression;
	        this.argument = argument;
	        this.delegate = delegate;
	    }
	    return YieldExpression;
	}());
	exports.YieldExpression = YieldExpression;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var error_handler_1 = __webpack_require__(10);
	var messages_1 = __webpack_require__(11);
	var Node = __webpack_require__(7);
	var scanner_1 = __webpack_require__(12);
	var syntax_1 = __webpack_require__(2);
	var token_1 = __webpack_require__(13);
	var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
	var Parser = (function () {
	    function Parser(code, options, delegate) {
	        if (options === void 0) { options = {}; }
	        this.config = {
	            range: (typeof options.range === 'boolean') && options.range,
	            loc: (typeof options.loc === 'boolean') && options.loc,
	            source: null,
	            tokens: (typeof options.tokens === 'boolean') && options.tokens,
	            comment: (typeof options.comment === 'boolean') && options.comment,
	            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant
	        };
	        if (this.config.loc && options.source && options.source !== null) {
	            this.config.source = String(options.source);
	        }
	        this.delegate = delegate;
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = this.config.tolerant;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = this.config.comment;
	        this.operatorPrecedence = {
	            ')': 0,
	            ';': 0,
	            ',': 0,
	            '=': 0,
	            ']': 0,
	            '||': 1,
	            '&&': 2,
	            '|': 3,
	            '^': 4,
	            '&': 5,
	            '==': 6,
	            '!=': 6,
	            '===': 6,
	            '!==': 6,
	            '<': 7,
	            '>': 7,
	            '<=': 7,
	            '>=': 7,
	            '<<': 8,
	            '>>': 8,
	            '>>>': 8,
	            '+': 9,
	            '-': 9,
	            '*': 11,
	            '/': 11,
	            '%': 11
	        };
	        this.lookahead = {
	            type: 2 /* EOF */,
	            value: '',
	            lineNumber: this.scanner.lineNumber,
	            lineStart: 0,
	            start: 0,
	            end: 0
	        };
	        this.hasLineTerminator = false;
	        this.context = {
	            isModule: false,
	            await: false,
	            allowIn: true,
	            allowStrictDirective: true,
	            allowYield: true,
	            firstCoverInitializedNameError: null,
	            isAssignmentTarget: false,
	            isBindingElement: false,
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            labelSet: {},
	            strict: false
	        };
	        this.tokens = [];
	        this.startMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.lastMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.nextToken();
	        this.lastMarker = {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    }
	    Parser.prototype.throwError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.lastMarker.line;
	        var column = this.lastMarker.column + 1;
	        throw this.errorHandler.createError(index, line, column, msg);
	    };
	    Parser.prototype.tolerateError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.scanner.lineNumber;
	        var column = this.lastMarker.column + 1;
	        this.errorHandler.tolerateError(index, line, column, msg);
	    };
	    // Throw an exception because of the token.
	    Parser.prototype.unexpectedTokenError = function (token, message) {
	        var msg = message || messages_1.Messages.UnexpectedToken;
	        var value;
	        if (token) {
	            if (!message) {
	                msg = (token.type === 2 /* EOF */) ? messages_1.Messages.UnexpectedEOS :
	                    (token.type === 3 /* Identifier */) ? messages_1.Messages.UnexpectedIdentifier :
	                        (token.type === 6 /* NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :
	                            (token.type === 8 /* StringLiteral */) ? messages_1.Messages.UnexpectedString :
	                                (token.type === 10 /* Template */) ? messages_1.Messages.UnexpectedTemplate :
	                                    messages_1.Messages.UnexpectedToken;
	                if (token.type === 4 /* Keyword */) {
	                    if (this.scanner.isFutureReservedWord(token.value)) {
	                        msg = messages_1.Messages.UnexpectedReserved;
	                    }
	                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
	                        msg = messages_1.Messages.StrictReservedWord;
	                    }
	                }
	            }
	            value = token.value;
	        }
	        else {
	            value = 'ILLEGAL';
	        }
	        msg = msg.replace('%0', value);
	        if (token && typeof token.lineNumber === 'number') {
	            var index = token.start;
	            var line = token.lineNumber;
	            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
	            var column = token.start - lastMarkerLineStart + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	        else {
	            var index = this.lastMarker.index;
	            var line = this.lastMarker.line;
	            var column = this.lastMarker.column + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	    };
	    Parser.prototype.throwUnexpectedToken = function (token, message) {
	        throw this.unexpectedTokenError(token, message);
	    };
	    Parser.prototype.tolerateUnexpectedToken = function (token, message) {
	        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
	    };
	    Parser.prototype.collectComments = function () {
	        if (!this.config.comment) {
	            this.scanner.scanComments();
	        }
	        else {
	            var comments = this.scanner.scanComments();
	            if (comments.length > 0 && this.delegate) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var node = void 0;
	                    node = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
	                    };
	                    if (this.config.range) {
	                        node.range = e.range;
	                    }
	                    if (this.config.loc) {
	                        node.loc = e.loc;
	                    }
	                    var metadata = {
	                        start: {
	                            line: e.loc.start.line,
	                            column: e.loc.start.column,
	                            offset: e.range[0]
	                        },
	                        end: {
	                            line: e.loc.end.line,
	                            column: e.loc.end.column,
	                            offset: e.range[1]
	                        }
	                    };
	                    this.delegate(node, metadata);
	                }
	            }
	        }
	    };
	    // From internal representation to an external structure
	    Parser.prototype.getTokenRaw = function (token) {
	        return this.scanner.source.slice(token.start, token.end);
	    };
	    Parser.prototype.convertToken = function (token) {
	        var t = {
	            type: token_1.TokenName[token.type],
	            value: this.getTokenRaw(token)
	        };
	        if (this.config.range) {
	            t.range = [token.start, token.end];
	        }
	        if (this.config.loc) {
	            t.loc = {
	                start: {
	                    line: this.startMarker.line,
	                    column: this.startMarker.column
	                },
	                end: {
	                    line: this.scanner.lineNumber,
	                    column: this.scanner.index - this.scanner.lineStart
	                }
	            };
	        }
	        if (token.type === 9 /* RegularExpression */) {
	            var pattern = token.pattern;
	            var flags = token.flags;
	            t.regex = { pattern: pattern, flags: flags };
	        }
	        return t;
	    };
	    Parser.prototype.nextToken = function () {
	        var token = this.lookahead;
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        this.collectComments();
	        if (this.scanner.index !== this.startMarker.index) {
	            this.startMarker.index = this.scanner.index;
	            this.startMarker.line = this.scanner.lineNumber;
	            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        }
	        var next = this.scanner.lex();
	        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
	        if (next && this.context.strict && next.type === 3 /* Identifier */) {
	            if (this.scanner.isStrictModeReservedWord(next.value)) {
	                next.type = 4 /* Keyword */;
	            }
	        }
	        this.lookahead = next;
	        if (this.config.tokens && next.type !== 2 /* EOF */) {
	            this.tokens.push(this.convertToken(next));
	        }
	        return token;
	    };
	    Parser.prototype.nextRegexToken = function () {
	        this.collectComments();
	        var token = this.scanner.scanRegExp();
	        if (this.config.tokens) {
	            // Pop the previous token, '/' or '/='
	            // This is added from the lookahead token.
	            this.tokens.pop();
	            this.tokens.push(this.convertToken(token));
	        }
	        // Prime the next lookahead.
	        this.lookahead = token;
	        this.nextToken();
	        return token;
	    };
	    Parser.prototype.createNode = function () {
	        return {
	            index: this.startMarker.index,
	            line: this.startMarker.line,
	            column: this.startMarker.column
	        };
	    };
	    Parser.prototype.startNode = function (token) {
	        return {
	            index: token.start,
	            line: token.lineNumber,
	            column: token.start - token.lineStart
	        };
	    };
	    Parser.prototype.finalize = function (marker, node) {
	        if (this.config.range) {
	            node.range = [marker.index, this.lastMarker.index];
	        }
	        if (this.config.loc) {
	            node.loc = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column
	                }
	            };
	            if (this.config.source) {
	                node.loc.source = this.config.source;
	            }
	        }
	        if (this.delegate) {
	            var metadata = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                    offset: marker.index
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column,
	                    offset: this.lastMarker.index
	                }
	            };
	            this.delegate(node, metadata);
	        }
	        return node;
	    };
	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    Parser.prototype.expect = function (value) {
	        var token = this.nextToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
	    Parser.prototype.expectCommaSeparator = function () {
	        if (this.config.tolerant) {
	            var token = this.lookahead;
	            if (token.type === 7 /* Punctuator */ && token.value === ',') {
	                this.nextToken();
	            }
	            else if (token.type === 7 /* Punctuator */ && token.value === ';') {
	                this.nextToken();
	                this.tolerateUnexpectedToken(token);
	            }
	            else {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
	            }
	        }
	        else {
	            this.expect(',');
	        }
	    };
	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.
	    Parser.prototype.expectKeyword = function (keyword) {
	        var token = this.nextToken();
	        if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next token matches the specified punctuator.
	    Parser.prototype.match = function (value) {
	        return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
	    };
	    // Return true if the next token matches the specified keyword
	    Parser.prototype.matchKeyword = function (keyword) {
	        return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token matches the specified contextual keyword
	    // (where an identifier is sometimes a keyword depending on the context)
	    Parser.prototype.matchContextualKeyword = function (keyword) {
	        return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token is an assignment operator
	    Parser.prototype.matchAssign = function () {
	        if (this.lookahead.type !== 7 /* Punctuator */) {
	            return false;
	        }
	        var op = this.lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '**=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    };
	    // Cover grammar support.
	    //
	    // When an assignment expression position starts with an left parenthesis, the determination of the type
	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	    //
	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
	    // after the outermost pair is closed. They are:
	    //
	    //   1. AssignmentExpression
	    //   2. BindingElements
	    //   3. AssignmentTargets
	    //
	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
	    // binding element or assignment target.
	    //
	    // The three productions have the relationship:
	    //
	    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
	    //
	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	    //
	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	    // the CoverInitializedName check is conducted.
	    //
	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	    // pattern. The CoverInitializedName check is deferred.
	    Parser.prototype.isolateCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        if (this.context.firstCoverInitializedNameError !== null) {
	            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
	        }
	        this.context.isBindingElement = previousIsBindingElement;
	        this.context.isAssignmentTarget = previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.inheritCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
	        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.consumeSemicolon = function () {
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else if (!this.hasLineTerminator) {
	            if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.lastMarker.index = this.startMarker.index;
	            this.lastMarker.line = this.startMarker.line;
	            this.lastMarker.column = this.startMarker.column;
	        }
	    };
	    // https://tc39.github.io/ecma262/#sec-primary-expression
	    Parser.prototype.parsePrimaryExpression = function () {
	        var node = this.createNode();
	        var expr;
	        var token, raw;
	        switch (this.lookahead.type) {
	            case 3 /* Identifier */:
	                if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
	                    this.tolerateUnexpectedToken(this.lookahead);
	                }
	                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
	                break;
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	                if (this.context.strict && this.lookahead.octal) {
	                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
	                }
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 1 /* BooleanLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
	                break;
	            case 5 /* NullLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(null, raw));
	                break;
	            case 10 /* Template */:
	                expr = this.parseTemplateLiteral();
	                break;
	            case 7 /* Punctuator */:
	                switch (this.lookahead.value) {
	                    case '(':
	                        this.context.isBindingElement = false;
	                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
	                        break;
	                    case '[':
	                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
	                        break;
	                    case '{':
	                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
	                        break;
	                    case '/':
	                    case '/=':
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                        this.scanner.index = this.startMarker.index;
	                        token = this.nextRegexToken();
	                        raw = this.getTokenRaw(token);
	                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
	                        break;
	                    default:
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                }
	                break;
	            case 4 /* Keyword */:
	                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
	                    expr = this.parseIdentifierName();
	                }
	                else if (!this.context.strict && this.matchKeyword('let')) {
	                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
	                }
	                else {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    if (this.matchKeyword('function')) {
	                        expr = this.parseFunctionExpression();
	                    }
	                    else if (this.matchKeyword('this')) {
	                        this.nextToken();
	                        expr = this.finalize(node, new Node.ThisExpression());
	                    }
	                    else if (this.matchKeyword('class')) {
	                        expr = this.parseClassExpression();
	                    }
	                    else {
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                    }
	                }
	                break;
	            default:
	                expr = this.throwUnexpectedToken(this.nextToken());
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-array-initializer
	    Parser.prototype.parseSpreadElement = function () {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
	        return this.finalize(node, new Node.SpreadElement(arg));
	    };
	    Parser.prototype.parseArrayInitializer = function () {
	        var node = this.createNode();
	        var elements = [];
	        this.expect('[');
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else if (this.match('...')) {
	                var element = this.parseSpreadElement();
	                if (!this.match(']')) {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    this.expect(',');
	                }
	                elements.push(element);
	            }
	            else {
	                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayExpression(elements));
	    };
	    // https://tc39.github.io/ecma262/#sec-object-initializer
	    Parser.prototype.parsePropertyMethod = function (params) {
	        this.context.isAssignmentTarget = false;
	        this.context.isBindingElement = false;
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = params.simple;
	        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
	        if (this.context.strict && params.firstRestricted) {
	            this.tolerateUnexpectedToken(params.firstRestricted, params.message);
	        }
	        if (this.context.strict && params.stricted) {
	            this.tolerateUnexpectedToken(params.stricted, params.message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        return body;
	    };
	    Parser.prototype.parsePropertyMethodFunction = function () {
	        var isGenerator = false;
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = false;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    Parser.prototype.parsePropertyMethodAsyncFunction = function () {
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        var previousAwait = this.context.await;
	        this.context.allowYield = false;
	        this.context.await = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        this.context.await = previousAwait;
	        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
	    };
	    Parser.prototype.parseObjectPropertyKey = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        var key;
	        switch (token.type) {
	            case 8 /* StringLiteral */:
	            case 6 /* NumericLiteral */:
	                if (this.context.strict && token.octal) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
	                }
	                var raw = this.getTokenRaw(token);
	                key = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 3 /* Identifier */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 4 /* Keyword */:
	                key = this.finalize(node, new Node.Identifier(token.value));
	                break;
	            case 7 /* Punctuator */:
	                if (token.value === '[') {
	                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    this.expect(']');
	                }
	                else {
	                    key = this.throwUnexpectedToken(token);
	                }
	                break;
	            default:
	                key = this.throwUnexpectedToken(token);
	        }
	        return key;
	    };
	    Parser.prototype.isPropertyKey = function (key, value) {
	        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||
	            (key.type === syntax_1.Syntax.Literal && key.value === value);
	    };
	    Parser.prototype.parseObjectProperty = function (hasProto) {
	        var node = this.createNode();
	        var token = this.lookahead;
	        var kind;
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var shorthand = false;
	        var isAsync = false;
	        if (token.type === 3 /* Identifier */) {
	            var id = token.value;
	            this.nextToken();
	            computed = this.match('[');
	            isAsync = !this.hasLineTerminator && (id === 'async') &&
	                !this.match(':') && !this.match('(') && !this.match('*');
	            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
	        }
	        else if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
	            kind = 'get';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.context.allowYield = false;
	            value = this.parseGetterMethod();
	        }
	        else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
	            kind = 'set';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseSetterMethod();
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        else {
	            if (!key) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            kind = 'init';
	            if (this.match(':') && !isAsync) {
	                if (!computed && this.isPropertyKey(key, '__proto__')) {
	                    if (hasProto.value) {
	                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
	                    }
	                    hasProto.value = true;
	                }
	                this.nextToken();
	                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
	            }
	            else if (this.match('(')) {
	                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	                method = true;
	            }
	            else if (token.type === 3 /* Identifier */) {
	                var id = this.finalize(node, new Node.Identifier(token.value));
	                if (this.match('=')) {
	                    this.context.firstCoverInitializedNameError = this.lookahead;
	                    this.nextToken();
	                    shorthand = true;
	                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
	                }
	                else {
	                    shorthand = true;
	                    value = id;
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectInitializer = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var properties = [];
	        var hasProto = { value: false };
	        while (!this.match('}')) {
	            properties.push(this.parseObjectProperty(hasProto));
	            if (!this.match('}')) {
	                this.expectCommaSeparator();
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectExpression(properties));
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literals
	    Parser.prototype.parseTemplateHead = function () {
	        assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateElement = function () {
	        if (this.lookahead.type !== 10 /* Template */) {
	            this.throwUnexpectedToken();
	        }
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateLiteral = function () {
	        var node = this.createNode();
	        var expressions = [];
	        var quasis = [];
	        var quasi = this.parseTemplateHead();
	        quasis.push(quasi);
	        while (!quasi.tail) {
	            expressions.push(this.parseExpression());
	            quasi = this.parseTemplateElement();
	            quasis.push(quasi);
	        }
	        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
	    };
	    // https://tc39.github.io/ecma262/#sec-grouping-operator
	    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	            case syntax_1.Syntax.MemberExpression:
	            case syntax_1.Syntax.RestElement:
	            case syntax_1.Syntax.AssignmentPattern:
	                break;
	            case syntax_1.Syntax.SpreadElement:
	                expr.type = syntax_1.Syntax.RestElement;
	                this.reinterpretExpressionAsPattern(expr.argument);
	                break;
	            case syntax_1.Syntax.ArrayExpression:
	                expr.type = syntax_1.Syntax.ArrayPattern;
	                for (var i = 0; i < expr.elements.length; i++) {
	                    if (expr.elements[i] !== null) {
	                        this.reinterpretExpressionAsPattern(expr.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectExpression:
	                expr.type = syntax_1.Syntax.ObjectPattern;
	                for (var i = 0; i < expr.properties.length; i++) {
	                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
	                }
	                break;
	            case syntax_1.Syntax.AssignmentExpression:
	                expr.type = syntax_1.Syntax.AssignmentPattern;
	                delete expr.operator;
	                this.reinterpretExpressionAsPattern(expr.left);
	                break;
	            default:
	                // Allow other node type for tolerant parsing.
	                break;
	        }
	    };
	    Parser.prototype.parseGroupExpression = function () {
	        var expr;
	        this.expect('(');
	        if (this.match(')')) {
	            this.nextToken();
	            if (!this.match('=>')) {
	                this.expect('=>');
	            }
	            expr = {
	                type: ArrowParameterPlaceHolder,
	                params: [],
	                async: false
	            };
	        }
	        else {
	            var startToken = this.lookahead;
	            var params = [];
	            if (this.match('...')) {
	                expr = this.parseRestElement(params);
	                this.expect(')');
	                if (!this.match('=>')) {
	                    this.expect('=>');
	                }
	                expr = {
	                    type: ArrowParameterPlaceHolder,
	                    params: [expr],
	                    async: false
	                };
	            }
	            else {
	                var arrow = false;
	                this.context.isBindingElement = true;
	                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                if (this.match(',')) {
	                    var expressions = [];
	                    this.context.isAssignmentTarget = false;
	                    expressions.push(expr);
	                    while (this.lookahead.type !== 2 /* EOF */) {
	                        if (!this.match(',')) {
	                            break;
	                        }
	                        this.nextToken();
	                        if (this.match(')')) {
	                            this.nextToken();
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else if (this.match('...')) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            expressions.push(this.parseRestElement(params));
	                            this.expect(')');
	                            if (!this.match('=>')) {
	                                this.expect('=>');
	                            }
	                            this.context.isBindingElement = false;
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else {
	                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        if (arrow) {
	                            break;
	                        }
	                    }
	                    if (!arrow) {
	                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	                    }
	                }
	                if (!arrow) {
	                    this.expect(')');
	                    if (this.match('=>')) {
	                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: [expr],
	                                async: false
	                            };
	                        }
	                        if (!arrow) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            if (expr.type === syntax_1.Syntax.SequenceExpression) {
	                                for (var i = 0; i < expr.expressions.length; i++) {
	                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);
	                                }
	                            }
	                            else {
	                                this.reinterpretExpressionAsPattern(expr);
	                            }
	                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: parameters,
	                                async: false
	                            };
	                        }
	                    }
	                    this.context.isBindingElement = false;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
	    Parser.prototype.parseArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAssignmentExpression);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.isIdentifierName = function (token) {
	        return token.type === 3 /* Identifier */ ||
	            token.type === 4 /* Keyword */ ||
	            token.type === 1 /* BooleanLiteral */ ||
	            token.type === 5 /* NullLiteral */;
	    };
	    Parser.prototype.parseIdentifierName = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (!this.isIdentifierName(token)) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseNewExpression = function () {
	        var node = this.createNode();
	        var id = this.parseIdentifierName();
	        assert_1.assert(id.name === 'new', 'New expression must start with `new`');
	        var expr;
	        if (this.match('.')) {
	            this.nextToken();
	            if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
	                var property = this.parseIdentifierName();
	                expr = new Node.MetaProperty(id, property);
	            }
	            else {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
	            var args = this.match('(') ? this.parseArguments() : [];
	            expr = new Node.NewExpression(callee, args);
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return this.finalize(node, expr);
	    };
	    Parser.prototype.parseAsyncArgument = function () {
	        var arg = this.parseAssignmentExpression();
	        this.context.firstCoverInitializedNameError = null;
	        return arg;
	    };
	    Parser.prototype.parseAsyncArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAsyncArgument);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
	        var startToken = this.lookahead;
	        var maybeAsync = this.matchContextualKeyword('async');
	        var previousAllowIn = this.context.allowIn;
	        this.context.allowIn = true;
	        var expr;
	        if (this.matchKeyword('super') && this.context.inFunctionBody) {
	            expr = this.createNode();
	            this.nextToken();
	            expr = this.finalize(expr, new Node.Super());
	            if (!this.match('(') && !this.match('.') && !this.match('[')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        }
	        while (true) {
	            if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.match('(')) {
	                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = false;
	                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
	                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
	                if (asyncArrow && this.match('=>')) {
	                    for (var i = 0; i < args.length; ++i) {
	                        this.reinterpretExpressionAsPattern(args[i]);
	                    }
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: args,
	                        async: true
	                    };
	                }
	            }
	            else if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        this.context.allowIn = previousAllowIn;
	        return expr;
	    };
	    Parser.prototype.parseSuper = function () {
	        var node = this.createNode();
	        this.expectKeyword('super');
	        if (!this.match('[') && !this.match('.')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        return this.finalize(node, new Node.Super());
	    };
	    Parser.prototype.parseLeftHandSideExpression = function () {
	        assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
	        var node = this.startNode(this.lookahead);
	        var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :
	            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        while (true) {
	            if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-update-expressions
	    Parser.prototype.parseUpdateExpression = function () {
	        var expr;
	        var startToken = this.lookahead;
	        if (this.match('++') || this.match('--')) {
	            var node = this.startNode(startToken);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
	            }
	            if (!this.context.isAssignmentTarget) {
	                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	            }
	            var prefix = true;
	            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
	                if (this.match('++') || this.match('--')) {
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
	                    }
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    var operator = this.nextToken().value;
	                    var prefix = false;
	                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-unary-operators
	    Parser.prototype.parseAwaitExpression = function () {
	        var node = this.createNode();
	        this.nextToken();
	        var argument = this.parseUnaryExpression();
	        return this.finalize(node, new Node.AwaitExpression(argument));
	    };
	    Parser.prototype.parseUnaryExpression = function () {
	        var expr;
	        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||
	            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
	            var node = this.startNode(this.lookahead);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
	            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
	                this.tolerateError(messages_1.Messages.StrictDelete);
	            }
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else if (this.context.await && this.matchContextualKeyword('await')) {
	            expr = this.parseAwaitExpression();
	        }
	        else {
	            expr = this.parseUpdateExpression();
	        }
	        return expr;
	    };
	    Parser.prototype.parseExponentiationExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-exp-operator
	    // https://tc39.github.io/ecma262/#sec-multiplicative-operators
	    // https://tc39.github.io/ecma262/#sec-additive-operators
	    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
	    // https://tc39.github.io/ecma262/#sec-relational-operators
	    // https://tc39.github.io/ecma262/#sec-equality-operators
	    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
	    // https://tc39.github.io/ecma262/#sec-binary-logical-operators
	    Parser.prototype.binaryPrecedence = function (token) {
	        var op = token.value;
	        var precedence;
	        if (token.type === 7 /* Punctuator */) {
	            precedence = this.operatorPrecedence[op] || 0;
	        }
	        else if (token.type === 4 /* Keyword */) {
	            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;
	        }
	        else {
	            precedence = 0;
	        }
	        return precedence;
	    };
	    Parser.prototype.parseBinaryExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
	        var token = this.lookahead;
	        var prec = this.binaryPrecedence(token);
	        if (prec > 0) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var markers = [startToken, this.lookahead];
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            var stack = [left, token.value, right];
	            var precedences = [prec];
	            while (true) {
	                prec = this.binaryPrecedence(this.lookahead);
	                if (prec <= 0) {
	                    break;
	                }
	                // Reduce: make a binary expression from the three topmost entries.
	                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {
	                    right = stack.pop();
	                    var operator = stack.pop();
	                    precedences.pop();
	                    left = stack.pop();
	                    markers.pop();
	                    var node = this.startNode(markers[markers.length - 1]);
	                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
	                }
	                // Shift.
	                stack.push(this.nextToken().value);
	                precedences.push(prec);
	                markers.push(this.lookahead);
	                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
	            }
	            // Final reduce to clean-up the stack.
	            var i = stack.length - 1;
	            expr = stack[i];
	            markers.pop();
	            while (i > 1) {
	                var node = this.startNode(markers.pop());
	                var operator = stack[i - 1];
	                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
	                i -= 2;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-conditional-operator
	    Parser.prototype.parseConditionalExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
	        if (this.match('?')) {
	            this.nextToken();
	            var previousAllowIn = this.context.allowIn;
	            this.context.allowIn = true;
	            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowIn = previousAllowIn;
	            this.expect(':');
	            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-assignment-operators
	    Parser.prototype.checkPatternParam = function (options, param) {
	        switch (param.type) {
	            case syntax_1.Syntax.Identifier:
	                this.validateParam(options, param, param.name);
	                break;
	            case syntax_1.Syntax.RestElement:
	                this.checkPatternParam(options, param.argument);
	                break;
	            case syntax_1.Syntax.AssignmentPattern:
	                this.checkPatternParam(options, param.left);
	                break;
	            case syntax_1.Syntax.ArrayPattern:
	                for (var i = 0; i < param.elements.length; i++) {
	                    if (param.elements[i] !== null) {
	                        this.checkPatternParam(options, param.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectPattern:
	                for (var i = 0; i < param.properties.length; i++) {
	                    this.checkPatternParam(options, param.properties[i].value);
	                }
	                break;
	            default:
	                break;
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	    };
	    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
	        var params = [expr];
	        var options;
	        var asyncArrow = false;
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	                break;
	            case ArrowParameterPlaceHolder:
	                params = expr.params;
	                asyncArrow = expr.async;
	                break;
	            default:
	                return null;
	        }
	        options = {
	            simple: true,
	            paramSet: {}
	        };
	        for (var i = 0; i < params.length; ++i) {
	            var param = params[i];
	            if (param.type === syntax_1.Syntax.AssignmentPattern) {
	                if (param.right.type === syntax_1.Syntax.YieldExpression) {
	                    if (param.right.argument) {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                    param.right.type = syntax_1.Syntax.Identifier;
	                    param.right.name = 'yield';
	                    delete param.right.argument;
	                    delete param.right.delegate;
	                }
	            }
	            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.checkPatternParam(options, param);
	            params[i] = param;
	        }
	        if (this.context.strict || !this.context.allowYield) {
	            for (var i = 0; i < params.length; ++i) {
	                var param = params[i];
	                if (param.type === syntax_1.Syntax.YieldExpression) {
	                    this.throwUnexpectedToken(this.lookahead);
	                }
	            }
	        }
	        if (options.message === messages_1.Messages.StrictParamDupe) {
	            var token = this.context.strict ? options.stricted : options.firstRestricted;
	            this.throwUnexpectedToken(token, options.message);
	        }
	        return {
	            simple: options.simple,
	            params: params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.parseAssignmentExpression = function () {
	        var expr;
	        if (!this.context.allowYield && this.matchKeyword('yield')) {
	            expr = this.parseYieldExpression();
	        }
	        else {
	            var startToken = this.lookahead;
	            var token = startToken;
	            expr = this.parseConditionalExpression();
	            if (token.type === 3 /* Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {
	                if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
	                    var arg = this.parsePrimaryExpression();
	                    this.reinterpretExpressionAsPattern(arg);
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: [arg],
	                        async: true
	                    };
	                }
	            }
	            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
	                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                var isAsync = expr.async;
	                var list = this.reinterpretAsCoverFormalsList(expr);
	                if (list) {
	                    if (this.hasLineTerminator) {
	                        this.tolerateUnexpectedToken(this.lookahead);
	                    }
	                    this.context.firstCoverInitializedNameError = null;
	                    var previousStrict = this.context.strict;
	                    var previousAllowStrictDirective = this.context.allowStrictDirective;
	                    this.context.allowStrictDirective = list.simple;
	                    var previousAllowYield = this.context.allowYield;
	                    var previousAwait = this.context.await;
	                    this.context.allowYield = true;
	                    this.context.await = isAsync;
	                    var node = this.startNode(startToken);
	                    this.expect('=>');
	                    var body = void 0;
	                    if (this.match('{')) {
	                        var previousAllowIn = this.context.allowIn;
	                        this.context.allowIn = true;
	                        body = this.parseFunctionSourceElements();
	                        this.context.allowIn = previousAllowIn;
	                    }
	                    else {
	                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    }
	                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
	                    if (this.context.strict && list.firstRestricted) {
	                        this.throwUnexpectedToken(list.firstRestricted, list.message);
	                    }
	                    if (this.context.strict && list.stricted) {
	                        this.tolerateUnexpectedToken(list.stricted, list.message);
	                    }
	                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :
	                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
	                    this.context.strict = previousStrict;
	                    this.context.allowStrictDirective = previousAllowStrictDirective;
	                    this.context.allowYield = previousAllowYield;
	                    this.context.await = previousAwait;
	                }
	            }
	            else {
	                if (this.matchAssign()) {
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
	                        var id = expr;
	                        if (this.scanner.isRestrictedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
	                        }
	                        if (this.scanner.isStrictModeReservedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	                        }
	                    }
	                    if (!this.match('=')) {
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                    }
	                    else {
	                        this.reinterpretExpressionAsPattern(expr);
	                    }
	                    token = this.nextToken();
	                    var operator = token.value;
	                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
	                    this.context.firstCoverInitializedNameError = null;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-comma-operator
	    Parser.prototype.parseExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        if (this.match(',')) {
	            var expressions = [];
	            expressions.push(expr);
	            while (this.lookahead.type !== 2 /* EOF */) {
	                if (!this.match(',')) {
	                    break;
	                }
	                this.nextToken();
	                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	            }
	            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-block
	    Parser.prototype.parseStatementListItem = function () {
	        var statement;
	        this.context.isAssignmentTarget = true;
	        this.context.isBindingElement = true;
	        if (this.lookahead.type === 4 /* Keyword */) {
	            switch (this.lookahead.value) {
	                case 'export':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
	                    }
	                    statement = this.parseExportDeclaration();
	                    break;
	                case 'import':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
	                    }
	                    statement = this.parseImportDeclaration();
	                    break;
	                case 'const':
	                    statement = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'function':
	                    statement = this.parseFunctionDeclaration();
	                    break;
	                case 'class':
	                    statement = this.parseClassDeclaration();
	                    break;
	                case 'let':
	                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
	                    break;
	                default:
	                    statement = this.parseStatement();
	                    break;
	            }
	        }
	        else {
	            statement = this.parseStatement();
	        }
	        return statement;
	    };
	    Parser.prototype.parseBlock = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var block = [];
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            block.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.BlockStatement(block));
	    };
	    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations
	    Parser.prototype.parseLexicalBinding = function (kind, options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, kind);
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (kind === 'const') {
	            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
	                if (this.match('=')) {
	                    this.nextToken();
	                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                }
	                else {
	                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
	                }
	            }
	        }
	        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {
	            this.expect('=');
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseBindingList = function (kind, options) {
	        var list = [this.parseLexicalBinding(kind, options)];
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseLexicalBinding(kind, options));
	        }
	        return list;
	    };
	    Parser.prototype.isLexicalDeclaration = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.scanner.lex();
	        this.scanner.restoreState(state);
	        return (next.type === 3 /* Identifier */) ||
	            (next.type === 7 /* Punctuator */ && next.value === '[') ||
	            (next.type === 7 /* Punctuator */ && next.value === '{') ||
	            (next.type === 4 /* Keyword */ && next.value === 'let') ||
	            (next.type === 4 /* Keyword */ && next.value === 'yield');
	    };
	    Parser.prototype.parseLexicalDeclaration = function (options) {
	        var node = this.createNode();
	        var kind = this.nextToken().value;
	        assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
	        var declarations = this.parseBindingList(kind, options);
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
	    };
	    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
	    Parser.prototype.parseBindingRestElement = function (params, kind) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params, kind);
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseArrayPattern = function (params, kind) {
	        var node = this.createNode();
	        this.expect('[');
	        var elements = [];
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else {
	                if (this.match('...')) {
	                    elements.push(this.parseBindingRestElement(params, kind));
	                    break;
	                }
	                else {
	                    elements.push(this.parsePatternWithDefault(params, kind));
	                }
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayPattern(elements));
	    };
	    Parser.prototype.parsePropertyPattern = function (params, kind) {
	        var node = this.createNode();
	        var computed = false;
	        var shorthand = false;
	        var method = false;
	        var key;
	        var value;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            var keyToken = this.lookahead;
	            key = this.parseVariableIdentifier();
	            var init = this.finalize(node, new Node.Identifier(keyToken.value));
	            if (this.match('=')) {
	                params.push(keyToken);
	                shorthand = true;
	                this.nextToken();
	                var expr = this.parseAssignmentExpression();
	                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
	            }
	            else if (!this.match(':')) {
	                params.push(keyToken);
	                shorthand = true;
	                value = init;
	            }
	            else {
	                this.expect(':');
	                value = this.parsePatternWithDefault(params, kind);
	            }
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.expect(':');
	            value = this.parsePatternWithDefault(params, kind);
	        }
	        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectPattern = function (params, kind) {
	        var node = this.createNode();
	        var properties = [];
	        this.expect('{');
	        while (!this.match('}')) {
	            properties.push(this.parsePropertyPattern(params, kind));
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectPattern(properties));
	    };
	    Parser.prototype.parsePattern = function (params, kind) {
	        var pattern;
	        if (this.match('[')) {
	            pattern = this.parseArrayPattern(params, kind);
	        }
	        else if (this.match('{')) {
	            pattern = this.parseObjectPattern(params, kind);
	        }
	        else {
	            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
	                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
	            }
	            params.push(this.lookahead);
	            pattern = this.parseVariableIdentifier(kind);
	        }
	        return pattern;
	    };
	    Parser.prototype.parsePatternWithDefault = function (params, kind) {
	        var startToken = this.lookahead;
	        var pattern = this.parsePattern(params, kind);
	        if (this.match('=')) {
	            this.nextToken();
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = true;
	            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowYield = previousAllowYield;
	            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
	        }
	        return pattern;
	    };
	    // https://tc39.github.io/ecma262/#sec-variable-statement
	    Parser.prototype.parseVariableIdentifier = function (kind) {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (token.type === 4 /* Keyword */ && token.value === 'yield') {
	            if (this.context.strict) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else if (!this.context.allowYield) {
	                this.throwUnexpectedToken(token);
	            }
	        }
	        else if (token.type !== 3 /* Identifier */) {
	            if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else {
	                if (this.context.strict || token.value !== 'let' || kind !== 'var') {
	                    this.throwUnexpectedToken(token);
	                }
	            }
	        }
	        else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
	            this.tolerateUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseVariableDeclaration = function (options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, 'var');
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (this.match('=')) {
	            this.nextToken();
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
	            this.expect('=');
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseVariableDeclarationList = function (options) {
	        var opt = { inFor: options.inFor };
	        var list = [];
	        list.push(this.parseVariableDeclaration(opt));
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseVariableDeclaration(opt));
	        }
	        return list;
	    };
	    Parser.prototype.parseVariableStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('var');
	        var declarations = this.parseVariableDeclarationList({ inFor: false });
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
	    };
	    // https://tc39.github.io/ecma262/#sec-empty-statement
	    Parser.prototype.parseEmptyStatement = function () {
	        var node = this.createNode();
	        this.expect(';');
	        return this.finalize(node, new Node.EmptyStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-expression-statement
	    Parser.prototype.parseExpressionStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ExpressionStatement(expr));
	    };
	    // https://tc39.github.io/ecma262/#sec-if-statement
	    Parser.prototype.parseIfClause = function () {
	        if (this.context.strict && this.matchKeyword('function')) {
	            this.tolerateError(messages_1.Messages.StrictFunction);
	        }
	        return this.parseStatement();
	    };
	    Parser.prototype.parseIfStatement = function () {
	        var node = this.createNode();
	        var consequent;
	        var alternate = null;
	        this.expectKeyword('if');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            consequent = this.parseIfClause();
	            if (this.matchKeyword('else')) {
	                this.nextToken();
	                alternate = this.parseIfClause();
	            }
	        }
	        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
	    };
	    // https://tc39.github.io/ecma262/#sec-do-while-statement
	    Parser.prototype.parseDoWhileStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('do');
	        var previousInIteration = this.context.inIteration;
	        this.context.inIteration = true;
	        var body = this.parseStatement();
	        this.context.inIteration = previousInIteration;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	        }
	        else {
	            this.expect(')');
	            if (this.match(';')) {
	                this.nextToken();
	            }
	        }
	        return this.finalize(node, new Node.DoWhileStatement(body, test));
	    };
	    // https://tc39.github.io/ecma262/#sec-while-statement
	    Parser.prototype.parseWhileStatement = function () {
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.parseStatement();
	            this.context.inIteration = previousInIteration;
	        }
	        return this.finalize(node, new Node.WhileStatement(test, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-for-statement
	    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
	    Parser.prototype.parseForStatement = function () {
	        var init = null;
	        var test = null;
	        var update = null;
	        var forIn = true;
	        var left, right;
	        var node = this.createNode();
	        this.expectKeyword('for');
	        this.expect('(');
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else {
	            if (this.matchKeyword('var')) {
	                init = this.createNode();
	                this.nextToken();
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                var declarations = this.parseVariableDeclarationList({ inFor: true });
	                this.context.allowIn = previousAllowIn;
	                if (declarations.length === 1 && this.matchKeyword('in')) {
	                    var decl = declarations[0];
	                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
	                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
	                    }
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.expect(';');
	                }
	            }
	            else if (this.matchKeyword('const') || this.matchKeyword('let')) {
	                init = this.createNode();
	                var kind = this.nextToken().value;
	                if (!this.context.strict && this.lookahead.value === 'in') {
	                    init = this.finalize(init, new Node.Identifier(kind));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else {
	                    var previousAllowIn = this.context.allowIn;
	                    this.context.allowIn = false;
	                    var declarations = this.parseBindingList(kind, { inFor: true });
	                    this.context.allowIn = previousAllowIn;
	                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseExpression();
	                        init = null;
	                    }
	                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseAssignmentExpression();
	                        init = null;
	                        forIn = false;
	                    }
	                    else {
	                        this.consumeSemicolon();
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                    }
	                }
	            }
	            else {
	                var initStartToken = this.lookahead;
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                this.context.allowIn = previousAllowIn;
	                if (this.matchKeyword('in')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (this.matchContextualKeyword('of')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    if (this.match(',')) {
	                        var initSeq = [init];
	                        while (this.match(',')) {
	                            this.nextToken();
	                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
	                    }
	                    this.expect(';');
	                }
	            }
	        }
	        if (typeof left === 'undefined') {
	            if (!this.match(';')) {
	                test = this.parseExpression();
	            }
	            this.expect(';');
	            if (!this.match(')')) {
	                update = this.parseExpression();
	            }
	        }
	        var body;
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.isolateCoverGrammar(this.parseStatement);
	            this.context.inIteration = previousInIteration;
	        }
	        return (typeof left === 'undefined') ?
	            this.finalize(node, new Node.ForStatement(init, test, update, body)) :
	            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :
	                this.finalize(node, new Node.ForOfStatement(left, right, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-continue-statement
	    Parser.prototype.parseContinueStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('continue');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            label = id;
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration) {
	            this.throwError(messages_1.Messages.IllegalContinue);
	        }
	        return this.finalize(node, new Node.ContinueStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-break-statement
	    Parser.prototype.parseBreakStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('break');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	            label = id;
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration && !this.context.inSwitch) {
	            this.throwError(messages_1.Messages.IllegalBreak);
	        }
	        return this.finalize(node, new Node.BreakStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-return-statement
	    Parser.prototype.parseReturnStatement = function () {
	        if (!this.context.inFunctionBody) {
	            this.tolerateError(messages_1.Messages.IllegalReturn);
	        }
	        var node = this.createNode();
	        this.expectKeyword('return');
	        var hasArgument = !this.match(';') && !this.match('}') &&
	            !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */;
	        var argument = hasArgument ? this.parseExpression() : null;
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ReturnStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-with-statement
	    Parser.prototype.parseWithStatement = function () {
	        if (this.context.strict) {
	            this.tolerateError(messages_1.Messages.StrictModeWith);
	        }
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('with');
	        this.expect('(');
	        var object = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            body = this.parseStatement();
	        }
	        return this.finalize(node, new Node.WithStatement(object, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-switch-statement
	    Parser.prototype.parseSwitchCase = function () {
	        var node = this.createNode();
	        var test;
	        if (this.matchKeyword('default')) {
	            this.nextToken();
	            test = null;
	        }
	        else {
	            this.expectKeyword('case');
	            test = this.parseExpression();
	        }
	        this.expect(':');
	        var consequent = [];
	        while (true) {
	            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
	                break;
	            }
	            consequent.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.SwitchCase(test, consequent));
	    };
	    Parser.prototype.parseSwitchStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('switch');
	        this.expect('(');
	        var discriminant = this.parseExpression();
	        this.expect(')');
	        var previousInSwitch = this.context.inSwitch;
	        this.context.inSwitch = true;
	        var cases = [];
	        var defaultFound = false;
	        this.expect('{');
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            var clause = this.parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }
	        this.expect('}');
	        this.context.inSwitch = previousInSwitch;
	        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
	    };
	    // https://tc39.github.io/ecma262/#sec-labelled-statements
	    Parser.prototype.parseLabelledStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var statement;
	        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {
	            this.nextToken();
	            var id = expr;
	            var key = '$' + id.name;
	            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
	            }
	            this.context.labelSet[key] = true;
	            var body = void 0;
	            if (this.matchKeyword('class')) {
	                this.tolerateUnexpectedToken(this.lookahead);
	                body = this.parseClassDeclaration();
	            }
	            else if (this.matchKeyword('function')) {
	                var token = this.lookahead;
	                var declaration = this.parseFunctionDeclaration();
	                if (this.context.strict) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
	                }
	                else if (declaration.generator) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
	                }
	                body = declaration;
	            }
	            else {
	                body = this.parseStatement();
	            }
	            delete this.context.labelSet[key];
	            statement = new Node.LabeledStatement(id, body);
	        }
	        else {
	            this.consumeSemicolon();
	            statement = new Node.ExpressionStatement(expr);
	        }
	        return this.finalize(node, statement);
	    };
	    // https://tc39.github.io/ecma262/#sec-throw-statement
	    Parser.prototype.parseThrowStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('throw');
	        if (this.hasLineTerminator) {
	            this.throwError(messages_1.Messages.NewlineAfterThrow);
	        }
	        var argument = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ThrowStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-try-statement
	    Parser.prototype.parseCatchClause = function () {
	        var node = this.createNode();
	        this.expectKeyword('catch');
	        this.expect('(');
	        if (this.match(')')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        var params = [];
	        var param = this.parsePattern(params);
	        var paramMap = {};
	        for (var i = 0; i < params.length; i++) {
	            var key = '$' + params[i].value;
	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
	                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
	            }
	            paramMap[key] = true;
	        }
	        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(param.name)) {
	                this.tolerateError(messages_1.Messages.StrictCatchVariable);
	            }
	        }
	        this.expect(')');
	        var body = this.parseBlock();
	        return this.finalize(node, new Node.CatchClause(param, body));
	    };
	    Parser.prototype.parseFinallyClause = function () {
	        this.expectKeyword('finally');
	        return this.parseBlock();
	    };
	    Parser.prototype.parseTryStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('try');
	        var block = this.parseBlock();
	        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
	        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
	        if (!handler && !finalizer) {
	            this.throwError(messages_1.Messages.NoCatchOrFinally);
	        }
	        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
	    };
	    // https://tc39.github.io/ecma262/#sec-debugger-statement
	    Parser.prototype.parseDebuggerStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('debugger');
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.DebuggerStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
	    Parser.prototype.parseStatement = function () {
	        var statement;
	        switch (this.lookahead.type) {
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	            case 10 /* Template */:
	            case 9 /* RegularExpression */:
	                statement = this.parseExpressionStatement();
	                break;
	            case 7 /* Punctuator */:
	                var value = this.lookahead.value;
	                if (value === '{') {
	                    statement = this.parseBlock();
	                }
	                else if (value === '(') {
	                    statement = this.parseExpressionStatement();
	                }
	                else if (value === ';') {
	                    statement = this.parseEmptyStatement();
	                }
	                else {
	                    statement = this.parseExpressionStatement();
	                }
	                break;
	            case 3 /* Identifier */:
	                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
	                break;
	            case 4 /* Keyword */:
	                switch (this.lookahead.value) {
	                    case 'break':
	                        statement = this.parseBreakStatement();
	                        break;
	                    case 'continue':
	                        statement = this.parseContinueStatement();
	                        break;
	                    case 'debugger':
	                        statement = this.parseDebuggerStatement();
	                        break;
	                    case 'do':
	                        statement = this.parseDoWhileStatement();
	                        break;
	                    case 'for':
	                        statement = this.parseForStatement();
	                        break;
	                    case 'function':
	                        statement = this.parseFunctionDeclaration();
	                        break;
	                    case 'if':
	                        statement = this.parseIfStatement();
	                        break;
	                    case 'return':
	                        statement = this.parseReturnStatement();
	                        break;
	                    case 'switch':
	                        statement = this.parseSwitchStatement();
	                        break;
	                    case 'throw':
	                        statement = this.parseThrowStatement();
	                        break;
	                    case 'try':
	                        statement = this.parseTryStatement();
	                        break;
	                    case 'var':
	                        statement = this.parseVariableStatement();
	                        break;
	                    case 'while':
	                        statement = this.parseWhileStatement();
	                        break;
	                    case 'with':
	                        statement = this.parseWithStatement();
	                        break;
	                    default:
	                        statement = this.parseExpressionStatement();
	                        break;
	                }
	                break;
	            default:
	                statement = this.throwUnexpectedToken(this.lookahead);
	        }
	        return statement;
	    };
	    // https://tc39.github.io/ecma262/#sec-function-definitions
	    Parser.prototype.parseFunctionSourceElements = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var body = this.parseDirectivePrologues();
	        var previousLabelSet = this.context.labelSet;
	        var previousInIteration = this.context.inIteration;
	        var previousInSwitch = this.context.inSwitch;
	        var previousInFunctionBody = this.context.inFunctionBody;
	        this.context.labelSet = {};
	        this.context.inIteration = false;
	        this.context.inSwitch = false;
	        this.context.inFunctionBody = true;
	        while (this.lookahead.type !== 2 /* EOF */) {
	            if (this.match('}')) {
	                break;
	            }
	            body.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        this.context.labelSet = previousLabelSet;
	        this.context.inIteration = previousInIteration;
	        this.context.inSwitch = previousInSwitch;
	        this.context.inFunctionBody = previousInFunctionBody;
	        return this.finalize(node, new Node.BlockStatement(body));
	    };
	    Parser.prototype.validateParam = function (options, param, name) {
	        var key = '$' + name;
	        if (this.context.strict) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        else if (!options.firstRestricted) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            else if (this.scanner.isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictReservedWord;
	            }
	            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        /* istanbul ignore next */
	        if (typeof Object.defineProperty === 'function') {
	            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
	        }
	        else {
	            options.paramSet[key] = true;
	        }
	    };
	    Parser.prototype.parseRestElement = function (params) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params);
	        if (this.match('=')) {
	            this.throwError(messages_1.Messages.DefaultRestParameter);
	        }
	        if (!this.match(')')) {
	            this.throwError(messages_1.Messages.ParameterAfterRestParameter);
	        }
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseFormalParameter = function (options) {
	        var params = [];
	        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
	        for (var i = 0; i < params.length; i++) {
	            this.validateParam(options, params[i], params[i].value);
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	        options.params.push(param);
	    };
	    Parser.prototype.parseFormalParameters = function (firstRestricted) {
	        var options;
	        options = {
	            simple: true,
	            params: [],
	            firstRestricted: firstRestricted
	        };
	        this.expect('(');
	        if (!this.match(')')) {
	            options.paramSet = {};
	            while (this.lookahead.type !== 2 /* EOF */) {
	                this.parseFormalParameter(options);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expect(',');
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return {
	            simple: options.simple,
	            params: options.params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.matchAsyncFunction = function () {
	        var match = this.matchContextualKeyword('async');
	        if (match) {
	            var state = this.scanner.saveState();
	            this.scanner.scanComments();
	            var next = this.scanner.lex();
	            this.scanner.restoreState(state);
	            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Keyword */) && (next.value === 'function');
	        }
	        return match;
	    };
	    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted = null;
	        if (!identifierIsOptional || !this.match('(')) {
	            var token = this.lookahead;
	            id = this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :
	            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
	    };
	    Parser.prototype.parseFunctionExpression = function () {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted;
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        if (!this.match('(')) {
	            var token = this.lookahead;
	            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :
	            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
	    Parser.prototype.parseDirective = function () {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;
	        this.consumeSemicolon();
	        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
	    };
	    Parser.prototype.parseDirectivePrologues = function () {
	        var firstRestricted = null;
	        var body = [];
	        while (true) {
	            var token = this.lookahead;
	            if (token.type !== 8 /* StringLiteral */) {
	                break;
	            }
	            var statement = this.parseDirective();
	            body.push(statement);
	            var directive = statement.directive;
	            if (typeof directive !== 'string') {
	                break;
	            }
	            if (directive === 'use strict') {
	                this.context.strict = true;
	                if (firstRestricted) {
	                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
	                }
	                if (!this.context.allowStrictDirective) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
	                }
	            }
	            else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }
	        return body;
	    };
	    // https://tc39.github.io/ecma262/#sec-method-definitions
	    Parser.prototype.qualifiedPropertyName = function (token) {
	        switch (token.type) {
	            case 3 /* Identifier */:
	            case 8 /* StringLiteral */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 4 /* Keyword */:
	                return true;
	            case 7 /* Punctuator */:
	                return token.value === '[';
	            default:
	                break;
	        }
	        return false;
	    };
	    Parser.prototype.parseGetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = false;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length > 0) {
	            this.tolerateError(messages_1.Messages.BadGetterArity);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseSetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = false;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length !== 1) {
	            this.tolerateError(messages_1.Messages.BadSetterArity);
	        }
	        else if (formalParameters.params[0] instanceof Node.RestElement) {
	            this.tolerateError(messages_1.Messages.BadSetterRestParameter);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseGeneratorMethod = function () {
	        var node = this.createNode();
	        var isGenerator = true;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        this.context.allowYield = false;
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-generator-function-definitions
	    Parser.prototype.isStartOfExpression = function () {
	        var start = true;
	        var value = this.lookahead.value;
	        switch (this.lookahead.type) {
	            case 7 /* Punctuator */:
	                start = (value === '[') || (value === '(') || (value === '{') ||
	                    (value === '+') || (value === '-') ||
	                    (value === '!') || (value === '~') ||
	                    (value === '++') || (value === '--') ||
	                    (value === '/') || (value === '/='); // regular expression literal
	                break;
	            case 4 /* Keyword */:
	                start = (value === 'class') || (value === 'delete') ||
	                    (value === 'function') || (value === 'let') || (value === 'new') ||
	                    (value === 'super') || (value === 'this') || (value === 'typeof') ||
	                    (value === 'void') || (value === 'yield');
	                break;
	            default:
	                break;
	        }
	        return start;
	    };
	    Parser.prototype.parseYieldExpression = function () {
	        var node = this.createNode();
	        this.expectKeyword('yield');
	        var argument = null;
	        var delegate = false;
	        if (!this.hasLineTerminator) {
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = false;
	            delegate = this.match('*');
	            if (delegate) {
	                this.nextToken();
	                argument = this.parseAssignmentExpression();
	            }
	            else if (this.isStartOfExpression()) {
	                argument = this.parseAssignmentExpression();
	            }
	            this.context.allowYield = previousAllowYield;
	        }
	        return this.finalize(node, new Node.YieldExpression(argument, delegate));
	    };
	    // https://tc39.github.io/ecma262/#sec-class-definitions
	    Parser.prototype.parseClassElement = function (hasConstructor) {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var kind = '';
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var isStatic = false;
	        var isAsync = false;
	        if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            var id = key;
	            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
	                token = this.lookahead;
	                isStatic = true;
	                computed = this.match('[');
	                if (this.match('*')) {
	                    this.nextToken();
	                }
	                else {
	                    key = this.parseObjectPropertyKey();
	                }
	            }
	            if ((token.type === 3 /* Identifier */) && !this.hasLineTerminator && (token.value === 'async')) {
	                var punctuator = this.lookahead.value;
	                if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
	                    isAsync = true;
	                    token = this.lookahead;
	                    key = this.parseObjectPropertyKey();
	                    if (token.type === 3 /* Identifier */) {
	                        if (token.value === 'get' || token.value === 'set') {
	                            this.tolerateUnexpectedToken(token);
	                        }
	                        else if (token.value === 'constructor') {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
	                        }
	                    }
	                }
	            }
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */) {
	            if (token.value === 'get' && lookaheadPropertyKey) {
	                kind = 'get';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                this.context.allowYield = false;
	                value = this.parseGetterMethod();
	            }
	            else if (token.value === 'set' && lookaheadPropertyKey) {
	                kind = 'set';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                value = this.parseSetterMethod();
	            }
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        if (!kind && key && this.match('(')) {
	            kind = 'init';
	            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	            method = true;
	        }
	        if (!kind) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        if (kind === 'init') {
	            kind = 'method';
	        }
	        if (!computed) {
	            if (isStatic && this.isPropertyKey(key, 'prototype')) {
	                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
	            }
	            if (!isStatic && this.isPropertyKey(key, 'constructor')) {
	                if (kind !== 'method' || !method || (value && value.generator)) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
	                }
	                if (hasConstructor.value) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
	                }
	                else {
	                    hasConstructor.value = true;
	                }
	                kind = 'constructor';
	            }
	        }
	        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
	    };
	    Parser.prototype.parseClassElementList = function () {
	        var body = [];
	        var hasConstructor = { value: false };
	        this.expect('{');
	        while (!this.match('}')) {
	            if (this.match(';')) {
	                this.nextToken();
	            }
	            else {
	                body.push(this.parseClassElement(hasConstructor));
	            }
	        }
	        this.expect('}');
	        return body;
	    };
	    Parser.prototype.parseClassBody = function () {
	        var node = this.createNode();
	        var elementList = this.parseClassElementList();
	        return this.finalize(node, new Node.ClassBody(elementList));
	    };
	    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Identifier */)) ? null : this.parseVariableIdentifier();
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
	    };
	    Parser.prototype.parseClassExpression = function () {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (this.lookahead.type === 3 /* Identifier */) ? this.parseVariableIdentifier() : null;
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
	    };
	    // https://tc39.github.io/ecma262/#sec-scripts
	    // https://tc39.github.io/ecma262/#sec-modules
	    Parser.prototype.parseModule = function () {
	        this.context.strict = true;
	        this.context.isModule = true;
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Module(body));
	    };
	    Parser.prototype.parseScript = function () {
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Script(body));
	    };
	    // https://tc39.github.io/ecma262/#sec-imports
	    Parser.prototype.parseModuleSpecifier = function () {
	        var node = this.createNode();
	        if (this.lookahead.type !== 8 /* StringLiteral */) {
	            this.throwError(messages_1.Messages.InvalidModuleSpecifier);
	        }
	        var token = this.nextToken();
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    // import {<foo as bar>} ...;
	    Parser.prototype.parseImportSpecifier = function () {
	        var node = this.createNode();
	        var imported;
	        var local;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            imported = this.parseVariableIdentifier();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	        }
	        else {
	            imported = this.parseIdentifierName();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.ImportSpecifier(local, imported));
	    };
	    // {foo, bar as bas}
	    Parser.prototype.parseNamedImports = function () {
	        this.expect('{');
	        var specifiers = [];
	        while (!this.match('}')) {
	            specifiers.push(this.parseImportSpecifier());
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return specifiers;
	    };
	    // import <foo> ...;
	    Parser.prototype.parseImportDefaultSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportDefaultSpecifier(local));
	    };
	    // import <* as foo> ...;
	    Parser.prototype.parseImportNamespaceSpecifier = function () {
	        var node = this.createNode();
	        this.expect('*');
	        if (!this.matchContextualKeyword('as')) {
	            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
	        }
	        this.nextToken();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
	    };
	    Parser.prototype.parseImportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalImportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('import');
	        var src;
	        var specifiers = [];
	        if (this.lookahead.type === 8 /* StringLiteral */) {
	            // import 'foo';
	            src = this.parseModuleSpecifier();
	        }
	        else {
	            if (this.match('{')) {
	                // import {bar}
	                specifiers = specifiers.concat(this.parseNamedImports());
	            }
	            else if (this.match('*')) {
	                // import * as foo
	                specifiers.push(this.parseImportNamespaceSpecifier());
	            }
	            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
	                // import foo
	                specifiers.push(this.parseImportDefaultSpecifier());
	                if (this.match(',')) {
	                    this.nextToken();
	                    if (this.match('*')) {
	                        // import foo, * as foo
	                        specifiers.push(this.parseImportNamespaceSpecifier());
	                    }
	                    else if (this.match('{')) {
	                        // import foo, {bar}
	                        specifiers = specifiers.concat(this.parseNamedImports());
	                    }
	                    else {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            src = this.parseModuleSpecifier();
	        }
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
	    };
	    // https://tc39.github.io/ecma262/#sec-exports
	    Parser.prototype.parseExportSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        var exported = local;
	        if (this.matchContextualKeyword('as')) {
	            this.nextToken();
	            exported = this.parseIdentifierName();
	        }
	        return this.finalize(node, new Node.ExportSpecifier(local, exported));
	    };
	    Parser.prototype.parseExportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalExportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('export');
	        var exportDeclaration;
	        if (this.matchKeyword('default')) {
	            // export default ...
	            this.nextToken();
	            if (this.matchKeyword('function')) {
	                // export default function foo () {}
	                // export default function () {}
	                var declaration = this.parseFunctionDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchKeyword('class')) {
	                // export default class foo {}
	                var declaration = this.parseClassDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchContextualKeyword('async')) {
	                // export default async function f () {}
	                // export default async function () {}
	                // export default async x => x
	                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else {
	                if (this.matchContextualKeyword('from')) {
	                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
	                }
	                // export default {};
	                // export default [];
	                // export default (1 + 2);
	                var declaration = this.match('{') ? this.parseObjectInitializer() :
	                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
	                this.consumeSemicolon();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	        }
	        else if (this.match('*')) {
	            // export * from 'foo';
	            this.nextToken();
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            var src = this.parseModuleSpecifier();
	            this.consumeSemicolon();
	            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
	        }
	        else if (this.lookahead.type === 4 /* Keyword */) {
	            // export var f = 1;
	            var declaration = void 0;
	            switch (this.lookahead.value) {
	                case 'let':
	                case 'const':
	                    declaration = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'var':
	                case 'class':
	                case 'function':
	                    declaration = this.parseStatementListItem();
	                    break;
	                default:
	                    this.throwUnexpectedToken(this.lookahead);
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else if (this.matchAsyncFunction()) {
	            var declaration = this.parseFunctionDeclaration();
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else {
	            var specifiers = [];
	            var source = null;
	            var isExportFromIdentifier = false;
	            this.expect('{');
	            while (!this.match('}')) {
	                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
	                specifiers.push(this.parseExportSpecifier());
	                if (!this.match('}')) {
	                    this.expect(',');
	                }
	            }
	            this.expect('}');
	            if (this.matchContextualKeyword('from')) {
	                // export {default} from 'foo';
	                // export {foo} from 'foo';
	                this.nextToken();
	                source = this.parseModuleSpecifier();
	                this.consumeSemicolon();
	            }
	            else if (isExportFromIdentifier) {
	                // export {default}; // missing fromClause
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            else {
	                // export {foo};
	                this.consumeSemicolon();
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
	        }
	        return exportDeclaration;
	    };
	    return Parser;
	}());
	exports.Parser = Parser;


/***/ },
/* 9 */
/***/ function(module, exports) {

	"use strict";
	// Ensure the condition is true, otherwise throw an error.
	// This is only to have a better contract semantic, i.e. another safety net
	// to catch a logic error. The condition shall be fulfilled in normal case.
	// Do NOT use this to enforce a certain condition on any user input.
	Object.defineProperty(exports, "__esModule", { value: true });
	function assert(condition, message) {
	    /* istanbul ignore if */
	    if (!condition) {
	        throw new Error('ASSERT: ' + message);
	    }
	}
	exports.assert = assert;


/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	/* tslint:disable:max-classes-per-file */
	Object.defineProperty(exports, "__esModule", { value: true });
	var ErrorHandler = (function () {
	    function ErrorHandler() {
	        this.errors = [];
	        this.tolerant = false;
	    }
	    ErrorHandler.prototype.recordError = function (error) {
	        this.errors.push(error);
	    };
	    ErrorHandler.prototype.tolerate = function (error) {
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    ErrorHandler.prototype.constructError = function (msg, column) {
	        var error = new Error(msg);
	        try {
	            throw error;
	        }
	        catch (base) {
	            /* istanbul ignore else */
	            if (Object.create && Object.defineProperty) {
	                error = Object.create(base);
	                Object.defineProperty(error, 'column', { value: column });
	            }
	        }
	        /* istanbul ignore next */
	        return error;
	    };
	    ErrorHandler.prototype.createError = function (index, line, col, description) {
	        var msg = 'Line ' + line + ': ' + description;
	        var error = this.constructError(msg, col);
	        error.index = index;
	        error.lineNumber = line;
	        error.description = description;
	        return error;
	    };
	    ErrorHandler.prototype.throwError = function (index, line, col, description) {
	        throw this.createError(index, line, col, description);
	    };
	    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
	        var error = this.createError(index, line, col, description);
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    return ErrorHandler;
	}());
	exports.ErrorHandler = ErrorHandler;


/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// Error messages should be identical to V8.
	exports.Messages = {
	    BadGetterArity: 'Getter must not have any formal parameters',
	    BadSetterArity: 'Setter must have exactly one formal parameter',
	    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
	    ConstructorIsAsync: 'Class constructor may not be an async method',
	    ConstructorSpecialMethod: 'Class constructor may not be an accessor',
	    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
	    DefaultRestParameter: 'Unexpected token =',
	    DuplicateBinding: 'Duplicate binding %0',
	    DuplicateConstructor: 'A class may only have one constructor',
	    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
	    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
	    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
	    IllegalBreak: 'Illegal break statement',
	    IllegalContinue: 'Illegal continue statement',
	    IllegalExportDeclaration: 'Unexpected token',
	    IllegalImportDeclaration: 'Unexpected token',
	    IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
	    IllegalReturn: 'Illegal return statement',
	    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
	    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
	    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	    InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
	    InvalidModuleSpecifier: 'Unexpected token',
	    InvalidRegExp: 'Invalid regular expression',
	    LetInLexicalBinding: 'let is disallowed as a lexically bound name',
	    MissingFromClause: 'Unexpected token',
	    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	    NewlineAfterThrow: 'Illegal newline after throw',
	    NoAsAfterImportNamespace: 'Unexpected token',
	    NoCatchOrFinally: 'Missing catch or finally after try',
	    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
	    Redeclaration: '%0 \'%1\' has already been declared',
	    StaticPrototype: 'Classes may not have static property named prototype',
	    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	    StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
	    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictModeWith: 'Strict mode code may not include a with statement',
	    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	    StrictReservedWord: 'Use of future reserved word in strict mode',
	    StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
	    UnexpectedEOS: 'Unexpected end of input',
	    UnexpectedIdentifier: 'Unexpected identifier',
	    UnexpectedNumber: 'Unexpected number',
	    UnexpectedReserved: 'Unexpected reserved word',
	    UnexpectedString: 'Unexpected string',
	    UnexpectedTemplate: 'Unexpected quasi %0',
	    UnexpectedToken: 'Unexpected token %0',
	    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
	    UnknownLabel: 'Undefined label \'%0\'',
	    UnterminatedRegExp: 'Invalid regular expression: missing /'
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var character_1 = __webpack_require__(4);
	var messages_1 = __webpack_require__(11);
	function hexValue(ch) {
	    return '0123456789abcdef'.indexOf(ch.toLowerCase());
	}
	function octalValue(ch) {
	    return '01234567'.indexOf(ch);
	}
	var Scanner = (function () {
	    function Scanner(code, handler) {
	        this.source = code;
	        this.errorHandler = handler;
	        this.trackComment = false;
	        this.length = code.length;
	        this.index = 0;
	        this.lineNumber = (code.length > 0) ? 1 : 0;
	        this.lineStart = 0;
	        this.curlyStack = [];
	    }
	    Scanner.prototype.saveState = function () {
	        return {
	            index: this.index,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart
	        };
	    };
	    Scanner.prototype.restoreState = function (state) {
	        this.index = state.index;
	        this.lineNumber = state.lineNumber;
	        this.lineStart = state.lineStart;
	    };
	    Scanner.prototype.eof = function () {
	        return this.index >= this.length;
	    };
	    Scanner.prototype.throwUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    Scanner.prototype.tolerateUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    // https://tc39.github.io/ecma262/#sec-comments
	    Scanner.prototype.skipSingleLineComment = function (offset) {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - offset;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - offset
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            ++this.index;
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (this.trackComment) {
	                    loc.end = {
	                        line: this.lineNumber,
	                        column: this.index - this.lineStart - 1
	                    };
	                    var entry = {
	                        multiLine: false,
	                        slice: [start + offset, this.index - 1],
	                        range: [start, this.index - 1],
	                        loc: loc
	                    };
	                    comments.push(entry);
	                }
	                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                return comments;
	            }
	        }
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: false,
	                slice: [start + offset, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        return comments;
	    };
	    Scanner.prototype.skipMultiLineComment = function () {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - 2;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - 2
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                ++this.index;
	                this.lineStart = this.index;
	            }
	            else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (this.source.charCodeAt(this.index + 1) === 0x2F) {
	                    this.index += 2;
	                    if (this.trackComment) {
	                        loc.end = {
	                            line: this.lineNumber,
	                            column: this.index - this.lineStart
	                        };
	                        var entry = {
	                            multiLine: true,
	                            slice: [start + 2, this.index - 2],
	                            range: [start, this.index],
	                            loc: loc
	                        };
	                        comments.push(entry);
	                    }
	                    return comments;
	                }
	                ++this.index;
	            }
	            else {
	                ++this.index;
	            }
	        }
	        // Ran off the end of the file - the whole thing is a comment
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: true,
	                slice: [start + 2, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        this.tolerateUnexpectedToken();
	        return comments;
	    };
	    Scanner.prototype.scanComments = function () {
	        var comments;
	        if (this.trackComment) {
	            comments = [];
	        }
	        var start = (this.index === 0);
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isWhiteSpace(ch)) {
	                ++this.index;
	            }
	            else if (character_1.Character.isLineTerminator(ch)) {
	                ++this.index;
	                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                start = true;
	            }
	            else if (ch === 0x2F) {
	                ch = this.source.charCodeAt(this.index + 1);
	                if (ch === 0x2F) {
	                    this.index += 2;
	                    var comment = this.skipSingleLineComment(2);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                    start = true;
	                }
	                else if (ch === 0x2A) {
	                    this.index += 2;
	                    var comment = this.skipMultiLineComment();
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (start && ch === 0x2D) {
	                // U+003E is '>'
	                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    this.index += 3;
	                    var comment = this.skipSingleLineComment(3);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (ch === 0x3C) {
	                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
	                    this.index += 4; // `<!--`
	                    var comment = this.skipSingleLineComment(4);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else {
	                break;
	            }
	        }
	        return comments;
	    };
	    // https://tc39.github.io/ecma262/#sec-future-reserved-words
	    Scanner.prototype.isFutureReservedWord = function (id) {
	        switch (id) {
	            case 'enum':
	            case 'export':
	            case 'import':
	            case 'super':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isStrictModeReservedWord = function (id) {
	        switch (id) {
	            case 'implements':
	            case 'interface':
	            case 'package':
	            case 'private':
	            case 'protected':
	            case 'public':
	            case 'static':
	            case 'yield':
	            case 'let':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isRestrictedWord = function (id) {
	        return id === 'eval' || id === 'arguments';
	    };
	    // https://tc39.github.io/ecma262/#sec-keywords
	    Scanner.prototype.isKeyword = function (id) {
	        switch (id.length) {
	            case 2:
	                return (id === 'if') || (id === 'in') || (id === 'do');
	            case 3:
	                return (id === 'var') || (id === 'for') || (id === 'new') ||
	                    (id === 'try') || (id === 'let');
	            case 4:
	                return (id === 'this') || (id === 'else') || (id === 'case') ||
	                    (id === 'void') || (id === 'with') || (id === 'enum');
	            case 5:
	                return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                    (id === 'class') || (id === 'super');
	            case 6:
	                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                    (id === 'switch') || (id === 'export') || (id === 'import');
	            case 7:
	                return (id === 'default') || (id === 'finally') || (id === 'extends');
	            case 8:
	                return (id === 'function') || (id === 'continue') || (id === 'debugger');
	            case 10:
	                return (id === 'instanceof');
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.codePointAt = function (i) {
	        var cp = this.source.charCodeAt(i);
	        if (cp >= 0xD800 && cp <= 0xDBFF) {
	            var second = this.source.charCodeAt(i + 1);
	            if (second >= 0xDC00 && second <= 0xDFFF) {
	                var first = cp;
	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            }
	        }
	        return cp;
	    };
	    Scanner.prototype.scanHexEscape = function (prefix) {
	        var len = (prefix === 'u') ? 4 : 2;
	        var code = 0;
	        for (var i = 0; i < len; ++i) {
	            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                code = code * 16 + hexValue(this.source[this.index++]);
	            }
	            else {
	                return null;
	            }
	        }
	        return String.fromCharCode(code);
	    };
	    Scanner.prototype.scanUnicodeCodePointEscape = function () {
	        var ch = this.source[this.index];
	        var code = 0;
	        // At least, one hex digit is required.
	        if (ch === '}') {
	            this.throwUnexpectedToken();
	        }
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
	                break;
	            }
	            code = code * 16 + hexValue(ch);
	        }
	        if (code > 0x10FFFF || ch !== '}') {
	            this.throwUnexpectedToken();
	        }
	        return character_1.Character.fromCodePoint(code);
	    };
	    Scanner.prototype.getIdentifier = function () {
	        var start = this.index++;
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            else if (ch >= 0xD800 && ch < 0xDFFF) {
	                // Need to handle surrogate pairs.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            if (character_1.Character.isIdentifierPart(ch)) {
	                ++this.index;
	            }
	            else {
	                break;
	            }
	        }
	        return this.source.slice(start, this.index);
	    };
	    Scanner.prototype.getComplexIdentifier = function () {
	        var cp = this.codePointAt(this.index);
	        var id = character_1.Character.fromCodePoint(cp);
	        this.index += id.length;
	        // '\u' (U+005C, U+0075) denotes an escaped character.
	        var ch;
	        if (cp === 0x5C) {
	            if (this.source.charCodeAt(this.index) !== 0x75) {
	                this.throwUnexpectedToken();
	            }
	            ++this.index;
	            if (this.source[this.index] === '{') {
	                ++this.index;
	                ch = this.scanUnicodeCodePointEscape();
	            }
	            else {
	                ch = this.scanHexEscape('u');
	                if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken();
	                }
	            }
	            id = ch;
	        }
	        while (!this.eof()) {
	            cp = this.codePointAt(this.index);
	            if (!character_1.Character.isIdentifierPart(cp)) {
	                break;
	            }
	            ch = character_1.Character.fromCodePoint(cp);
	            id += ch;
	            this.index += ch.length;
	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (cp === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (this.source.charCodeAt(this.index) !== 0x75) {
	                    this.throwUnexpectedToken();
	                }
	                ++this.index;
	                if (this.source[this.index] === '{') {
	                    ++this.index;
	                    ch = this.scanUnicodeCodePointEscape();
	                }
	                else {
	                    ch = this.scanHexEscape('u');
	                    if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                        this.throwUnexpectedToken();
	                    }
	                }
	                id += ch;
	            }
	        }
	        return id;
	    };
	    Scanner.prototype.octalToDecimal = function (ch) {
	        // \0 is not octal escape sequence
	        var octal = (ch !== '0');
	        var code = octalValue(ch);
	        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	            octal = true;
	            code = code * 8 + octalValue(this.source[this.index++]);
	            // 3 digits are only allowed when string starts
	            // with 0, 1, 2, 3
	            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                code = code * 8 + octalValue(this.source[this.index++]);
	            }
	        }
	        return {
	            code: code,
	            octal: octal
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    Scanner.prototype.scanIdentifier = function () {
	        var type;
	        var start = this.index;
	        // Backslash (U+005C) starts an escaped character.
	        var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();
	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = 3 /* Identifier */;
	        }
	        else if (this.isKeyword(id)) {
	            type = 4 /* Keyword */;
	        }
	        else if (id === 'null') {
	            type = 5 /* NullLiteral */;
	        }
	        else if (id === 'true' || id === 'false') {
	            type = 1 /* BooleanLiteral */;
	        }
	        else {
	            type = 3 /* Identifier */;
	        }
	        if (type !== 3 /* Identifier */ && (start + id.length !== this.index)) {
	            var restore = this.index;
	            this.index = start;
	            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
	            this.index = restore;
	        }
	        return {
	            type: type,
	            value: id,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-punctuators
	    Scanner.prototype.scanPunctuator = function () {
	        var start = this.index;
	        // Check for most common single-character punctuators.
	        var str = this.source[this.index];
	        switch (str) {
	            case '(':
	            case '{':
	                if (str === '{') {
	                    this.curlyStack.push('{');
	                }
	                ++this.index;
	                break;
	            case '.':
	                ++this.index;
	                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
	                    // Spread operator: ...
	                    this.index += 2;
	                    str = '...';
	                }
	                break;
	            case '}':
	                ++this.index;
	                this.curlyStack.pop();
	                break;
	            case ')':
	            case ';':
	            case ',':
	            case '[':
	            case ']':
	            case ':':
	            case '?':
	            case '~':
	                ++this.index;
	                break;
	            default:
	                // 4-character punctuator.
	                str = this.source.substr(this.index, 4);
	                if (str === '>>>=') {
	                    this.index += 4;
	                }
	                else {
	                    // 3-character punctuators.
	                    str = str.substr(0, 3);
	                    if (str === '===' || str === '!==' || str === '>>>' ||
	                        str === '<<=' || str === '>>=' || str === '**=') {
	                        this.index += 3;
	                    }
	                    else {
	                        // 2-character punctuators.
	                        str = str.substr(0, 2);
	                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
	                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
	                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
	                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
	                            str === '<=' || str === '>=' || str === '=>' || str === '**') {
	                            this.index += 2;
	                        }
	                        else {
	                            // 1-character punctuators.
	                            str = this.source[this.index];
	                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
	                                ++this.index;
	                            }
	                        }
	                    }
	                }
	        }
	        if (this.index === start) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 7 /* Punctuator */,
	            value: str,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    Scanner.prototype.scanHexLiteral = function (start) {
	        var num = '';
	        while (!this.eof()) {
	            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt('0x' + num, 16),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanBinaryLiteral = function (start) {
	        var num = '';
	        var ch;
	        while (!this.eof()) {
	            ch = this.source[this.index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            // only 0b or 0B
	            this.throwUnexpectedToken();
	        }
	        if (!this.eof()) {
	            ch = this.source.charCodeAt(this.index);
	            /* istanbul ignore else */
	            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
	                this.throwUnexpectedToken();
	            }
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 2),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanOctalLiteral = function (prefix, start) {
	        var num = '';
	        var octal = false;
	        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
	            octal = true;
	            num = '0' + this.source[this.index++];
	        }
	        else {
	            ++this.index;
	        }
	        while (!this.eof()) {
	            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (!octal && num.length === 0) {
	            // only 0o or 0O
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 8),
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.isImplicitOctalLiteral = function () {
	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (var i = this.index + 1; i < this.length; ++i) {
	            var ch = this.source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                return true;
	            }
	        }
	        return true;
	    };
	    Scanner.prototype.scanNumericLiteral = function () {
	        var start = this.index;
	        var ch = this.source[start];
	        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
	        var num = '';
	        if (ch !== '.') {
	            num = this.source[this.index++];
	            ch = this.source[this.index];
	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (num === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++this.index;
	                    return this.scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++this.index;
	                    return this.scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O') {
	                    return this.scanOctalLiteral(ch, start);
	                }
	                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                    if (this.isImplicitOctalLiteral()) {
	                        return this.scanOctalLiteral(ch, start);
	                    }
	                }
	            }
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === '.') {
	            num += this.source[this.index++];
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === 'e' || ch === 'E') {
	            num += this.source[this.index++];
	            ch = this.source[this.index];
	            if (ch === '+' || ch === '-') {
	                num += this.source[this.index++];
	            }
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                    num += this.source[this.index++];
	                }
	            }
	            else {
	                this.throwUnexpectedToken();
	            }
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseFloat(num),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-string-literals
	    Scanner.prototype.scanStringLiteral = function () {
	        var start = this.index;
	        var quote = this.source[start];
	        assert_1.assert((quote === '\'' || quote === '"'), 'String literal must starts with a quote');
	        ++this.index;
	        var octal = false;
	        var str = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === quote) {
	                quote = '';
	                break;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                str += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var unescaped_1 = this.scanHexEscape(ch);
	                                if (unescaped_1 === null) {
	                                    this.throwUnexpectedToken();
	                                }
	                                str += unescaped_1;
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            str += unescaped;
	                            break;
	                        case 'n':
	                            str += '\n';
	                            break;
	                        case 'r':
	                            str += '\r';
	                            break;
	                        case 't':
	                            str += '\t';
	                            break;
	                        case 'b':
	                            str += '\b';
	                            break;
	                        case 'f':
	                            str += '\f';
	                            break;
	                        case 'v':
	                            str += '\x0B';
	                            break;
	                        case '8':
	                        case '9':
	                            str += ch;
	                            this.tolerateUnexpectedToken();
	                            break;
	                        default:
	                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                var octToDec = this.octalToDecimal(ch);
	                                octal = octToDec.octal || octal;
	                                str += String.fromCharCode(octToDec.code);
	                            }
	                            else {
	                                str += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            }
	            else {
	                str += ch;
	            }
	        }
	        if (quote !== '') {
	            this.index = start;
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 8 /* StringLiteral */,
	            value: str,
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
	    Scanner.prototype.scanTemplate = function () {
	        var cooked = '';
	        var terminated = false;
	        var start = this.index;
	        var head = (this.source[start] === '`');
	        var tail = false;
	        var rawOffset = 2;
	        ++this.index;
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === '`') {
	                rawOffset = 1;
	                tail = true;
	                terminated = true;
	                break;
	            }
	            else if (ch === '$') {
	                if (this.source[this.index] === '{') {
	                    this.curlyStack.push('${');
	                    ++this.index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'n':
	                            cooked += '\n';
	                            break;
	                        case 'r':
	                            cooked += '\r';
	                            break;
	                        case 't':
	                            cooked += '\t';
	                            break;
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                cooked += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var restore = this.index;
	                                var unescaped_2 = this.scanHexEscape(ch);
	                                if (unescaped_2 !== null) {
	                                    cooked += unescaped_2;
	                                }
	                                else {
	                                    this.index = restore;
	                                    cooked += ch;
	                                }
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            cooked += unescaped;
	                            break;
	                        case 'b':
	                            cooked += '\b';
	                            break;
	                        case 'f':
	                            cooked += '\f';
	                            break;
	                        case 'v':
	                            cooked += '\v';
	                            break;
	                        default:
	                            if (ch === '0') {
	                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                                    // Illegal: \01 \02 and so on
	                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                                }
	                                cooked += '\0';
	                            }
	                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                // Illegal: \1 \2
	                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                            }
	                            else {
	                                cooked += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.lineNumber;
	                if (ch === '\r' && this.source[this.index] === '\n') {
	                    ++this.index;
	                }
	                this.lineStart = this.index;
	                cooked += '\n';
	            }
	            else {
	                cooked += ch;
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken();
	        }
	        if (!head) {
	            this.curlyStack.pop();
	        }
	        return {
	            type: 10 /* Template */,
	            value: this.source.slice(start + 1, this.index - rawOffset),
	            cooked: cooked,
	            head: head,
	            tail: tail,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	    Scanner.prototype.testRegExp = function (pattern, flags) {
	        // The BMP character to use as a replacement for astral symbols when
	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
	        // approximation.
	        // Note: replacing with '\uFFFF' enables false positives in unlikely
	        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
	        // pattern that would not be detected by this substitution.
	        var astralSubstitute = '\uFFFF';
	        var tmp = pattern;
	        var self = this;
	        if (flags.indexOf('u') >= 0) {
	            tmp = tmp
	                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
	                var codePoint = parseInt($1 || $2, 16);
	                if (codePoint > 0x10FFFF) {
	                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	                }
	                if (codePoint <= 0xFFFF) {
	                    return String.fromCharCode(codePoint);
	                }
	                return astralSubstitute;
	            })
	                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
	        }
	        // First, detect invalid regular expressions.
	        try {
	            RegExp(tmp);
	        }
	        catch (e) {
	            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	        }
	        // Return a regular expression object for this pattern-flag pair, or
	        // `null` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        }
	        catch (exception) {
	            /* istanbul ignore next */
	            return null;
	        }
	    };
	    Scanner.prototype.scanRegExpBody = function () {
	        var ch = this.source[this.index];
	        assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
	        var str = this.source[this.index++];
	        var classMarker = false;
	        var terminated = false;
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = this.source[this.index++];
	                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	            }
	            else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            }
	            else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                }
	                else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	        }
	        // Exclude leading and trailing slash.
	        return str.substr(1, str.length - 2);
	    };
	    Scanner.prototype.scanRegExpFlags = function () {
	        var str = '';
	        var flags = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index];
	            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }
	            ++this.index;
	            if (ch === '\\' && !this.eof()) {
	                ch = this.source[this.index];
	                if (ch === 'u') {
	                    ++this.index;
	                    var restore = this.index;
	                    var char = this.scanHexEscape('u');
	                    if (char !== null) {
	                        flags += char;
	                        for (str += '\\u'; restore < this.index; ++restore) {
	                            str += this.source[restore];
	                        }
	                    }
	                    else {
	                        this.index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    this.tolerateUnexpectedToken();
	                }
	                else {
	                    str += '\\';
	                    this.tolerateUnexpectedToken();
	                }
	            }
	            else {
	                flags += ch;
	                str += ch;
	            }
	        }
	        return flags;
	    };
	    Scanner.prototype.scanRegExp = function () {
	        var start = this.index;
	        var pattern = this.scanRegExpBody();
	        var flags = this.scanRegExpFlags();
	        var value = this.testRegExp(pattern, flags);
	        return {
	            type: 9 /* RegularExpression */,
	            value: '',
	            pattern: pattern,
	            flags: flags,
	            regex: value,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.lex = function () {
	        if (this.eof()) {
	            return {
	                type: 2 /* EOF */,
	                value: '',
	                lineNumber: this.lineNumber,
	                lineStart: this.lineStart,
	                start: this.index,
	                end: this.index
	            };
	        }
	        var cp = this.source.charCodeAt(this.index);
	        if (character_1.Character.isIdentifierStart(cp)) {
	            return this.scanIdentifier();
	        }
	        // Very common: ( and ) and ;
	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
	            return this.scanPunctuator();
	        }
	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (cp === 0x27 || cp === 0x22) {
	            return this.scanStringLiteral();
	        }
	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (cp === 0x2E) {
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
	                return this.scanNumericLiteral();
	            }
	            return this.scanPunctuator();
	        }
	        if (character_1.Character.isDecimalDigit(cp)) {
	            return this.scanNumericLiteral();
	        }
	        // Template literals start with ` (U+0060) for template head
	        // or } (U+007D) for template middle or template tail.
	        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${')) {
	            return this.scanTemplate();
	        }
	        // Possible identifier start in a surrogate pair.
	        if (cp >= 0xD800 && cp < 0xDFFF) {
	            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
	                return this.scanIdentifier();
	            }
	        }
	        return this.scanPunctuator();
	    };
	    return Scanner;
	}());
	exports.Scanner = Scanner;


/***/ },
/* 13 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TokenName = {};
	exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
	exports.TokenName[2 /* EOF */] = '<end>';
	exports.TokenName[3 /* Identifier */] = 'Identifier';
	exports.TokenName[4 /* Keyword */] = 'Keyword';
	exports.TokenName[5 /* NullLiteral */] = 'Null';
	exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
	exports.TokenName[7 /* Punctuator */] = 'Punctuator';
	exports.TokenName[8 /* StringLiteral */] = 'String';
	exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
	exports.TokenName[10 /* Template */] = 'Template';


/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	// Generated by generate-xhtml-entities.js. DO NOT MODIFY!
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.XHTMLEntities = {
	    quot: '\u0022',
	    amp: '\u0026',
	    apos: '\u0027',
	    gt: '\u003E',
	    nbsp: '\u00A0',
	    iexcl: '\u00A1',
	    cent: '\u00A2',
	    pound: '\u00A3',
	    curren: '\u00A4',
	    yen: '\u00A5',
	    brvbar: '\u00A6',
	    sect: '\u00A7',
	    uml: '\u00A8',
	    copy: '\u00A9',
	    ordf: '\u00AA',
	    laquo: '\u00AB',
	    not: '\u00AC',
	    shy: '\u00AD',
	    reg: '\u00AE',
	    macr: '\u00AF',
	    deg: '\u00B0',
	    plusmn: '\u00B1',
	    sup2: '\u00B2',
	    sup3: '\u00B3',
	    acute: '\u00B4',
	    micro: '\u00B5',
	    para: '\u00B6',
	    middot: '\u00B7',
	    cedil: '\u00B8',
	    sup1: '\u00B9',
	    ordm: '\u00BA',
	    raquo: '\u00BB',
	    frac14: '\u00BC',
	    frac12: '\u00BD',
	    frac34: '\u00BE',
	    iquest: '\u00BF',
	    Agrave: '\u00C0',
	    Aacute: '\u00C1',
	    Acirc: '\u00C2',
	    Atilde: '\u00C3',
	    Auml: '\u00C4',
	    Aring: '\u00C5',
	    AElig: '\u00C6',
	    Ccedil: '\u00C7',
	    Egrave: '\u00C8',
	    Eacute: '\u00C9',
	    Ecirc: '\u00CA',
	    Euml: '\u00CB',
	    Igrave: '\u00CC',
	    Iacute: '\u00CD',
	    Icirc: '\u00CE',
	    Iuml: '\u00CF',
	    ETH: '\u00D0',
	    Ntilde: '\u00D1',
	    Ograve: '\u00D2',
	    Oacute: '\u00D3',
	    Ocirc: '\u00D4',
	    Otilde: '\u00D5',
	    Ouml: '\u00D6',
	    times: '\u00D7',
	    Oslash: '\u00D8',
	    Ugrave: '\u00D9',
	    Uacute: '\u00DA',
	    Ucirc: '\u00DB',
	    Uuml: '\u00DC',
	    Yacute: '\u00DD',
	    THORN: '\u00DE',
	    szlig: '\u00DF',
	    agrave: '\u00E0',
	    aacute: '\u00E1',
	    acirc: '\u00E2',
	    atilde: '\u00E3',
	    auml: '\u00E4',
	    aring: '\u00E5',
	    aelig: '\u00E6',
	    ccedil: '\u00E7',
	    egrave: '\u00E8',
	    eacute: '\u00E9',
	    ecirc: '\u00EA',
	    euml: '\u00EB',
	    igrave: '\u00EC',
	    iacute: '\u00ED',
	    icirc: '\u00EE',
	    iuml: '\u00EF',
	    eth: '\u00F0',
	    ntilde: '\u00F1',
	    ograve: '\u00F2',
	    oacute: '\u00F3',
	    ocirc: '\u00F4',
	    otilde: '\u00F5',
	    ouml: '\u00F6',
	    divide: '\u00F7',
	    oslash: '\u00F8',
	    ugrave: '\u00F9',
	    uacute: '\u00FA',
	    ucirc: '\u00FB',
	    uuml: '\u00FC',
	    yacute: '\u00FD',
	    thorn: '\u00FE',
	    yuml: '\u00FF',
	    OElig: '\u0152',
	    oelig: '\u0153',
	    Scaron: '\u0160',
	    scaron: '\u0161',
	    Yuml: '\u0178',
	    fnof: '\u0192',
	    circ: '\u02C6',
	    tilde: '\u02DC',
	    Alpha: '\u0391',
	    Beta: '\u0392',
	    Gamma: '\u0393',
	    Delta: '\u0394',
	    Epsilon: '\u0395',
	    Zeta: '\u0396',
	    Eta: '\u0397',
	    Theta: '\u0398',
	    Iota: '\u0399',
	    Kappa: '\u039A',
	    Lambda: '\u039B',
	    Mu: '\u039C',
	    Nu: '\u039D',
	    Xi: '\u039E',
	    Omicron: '\u039F',
	    Pi: '\u03A0',
	    Rho: '\u03A1',
	    Sigma: '\u03A3',
	    Tau: '\u03A4',
	    Upsilon: '\u03A5',
	    Phi: '\u03A6',
	    Chi: '\u03A7',
	    Psi: '\u03A8',
	    Omega: '\u03A9',
	    alpha: '\u03B1',
	    beta: '\u03B2',
	    gamma: '\u03B3',
	    delta: '\u03B4',
	    epsilon: '\u03B5',
	    zeta: '\u03B6',
	    eta: '\u03B7',
	    theta: '\u03B8',
	    iota: '\u03B9',
	    kappa: '\u03BA',
	    lambda: '\u03BB',
	    mu: '\u03BC',
	    nu: '\u03BD',
	    xi: '\u03BE',
	    omicron: '\u03BF',
	    pi: '\u03C0',
	    rho: '\u03C1',
	    sigmaf: '\u03C2',
	    sigma: '\u03C3',
	    tau: '\u03C4',
	    upsilon: '\u03C5',
	    phi: '\u03C6',
	    chi: '\u03C7',
	    psi: '\u03C8',
	    omega: '\u03C9',
	    thetasym: '\u03D1',
	    upsih: '\u03D2',
	    piv: '\u03D6',
	    ensp: '\u2002',
	    emsp: '\u2003',
	    thinsp: '\u2009',
	    zwnj: '\u200C',
	    zwj: '\u200D',
	    lrm: '\u200E',
	    rlm: '\u200F',
	    ndash: '\u2013',
	    mdash: '\u2014',
	    lsquo: '\u2018',
	    rsquo: '\u2019',
	    sbquo: '\u201A',
	    ldquo: '\u201C',
	    rdquo: '\u201D',
	    bdquo: '\u201E',
	    dagger: '\u2020',
	    Dagger: '\u2021',
	    bull: '\u2022',
	    hellip: '\u2026',
	    permil: '\u2030',
	    prime: '\u2032',
	    Prime: '\u2033',
	    lsaquo: '\u2039',
	    rsaquo: '\u203A',
	    oline: '\u203E',
	    frasl: '\u2044',
	    euro: '\u20AC',
	    image: '\u2111',
	    weierp: '\u2118',
	    real: '\u211C',
	    trade: '\u2122',
	    alefsym: '\u2135',
	    larr: '\u2190',
	    uarr: '\u2191',
	    rarr: '\u2192',
	    darr: '\u2193',
	    harr: '\u2194',
	    crarr: '\u21B5',
	    lArr: '\u21D0',
	    uArr: '\u21D1',
	    rArr: '\u21D2',
	    dArr: '\u21D3',
	    hArr: '\u21D4',
	    forall: '\u2200',
	    part: '\u2202',
	    exist: '\u2203',
	    empty: '\u2205',
	    nabla: '\u2207',
	    isin: '\u2208',
	    notin: '\u2209',
	    ni: '\u220B',
	    prod: '\u220F',
	    sum: '\u2211',
	    minus: '\u2212',
	    lowast: '\u2217',
	    radic: '\u221A',
	    prop: '\u221D',
	    infin: '\u221E',
	    ang: '\u2220',
	    and: '\u2227',
	    or: '\u2228',
	    cap: '\u2229',
	    cup: '\u222A',
	    int: '\u222B',
	    there4: '\u2234',
	    sim: '\u223C',
	    cong: '\u2245',
	    asymp: '\u2248',
	    ne: '\u2260',
	    equiv: '\u2261',
	    le: '\u2264',
	    ge: '\u2265',
	    sub: '\u2282',
	    sup: '\u2283',
	    nsub: '\u2284',
	    sube: '\u2286',
	    supe: '\u2287',
	    oplus: '\u2295',
	    otimes: '\u2297',
	    perp: '\u22A5',
	    sdot: '\u22C5',
	    lceil: '\u2308',
	    rceil: '\u2309',
	    lfloor: '\u230A',
	    rfloor: '\u230B',
	    loz: '\u25CA',
	    spades: '\u2660',
	    clubs: '\u2663',
	    hearts: '\u2665',
	    diams: '\u2666',
	    lang: '\u27E8',
	    rang: '\u27E9'
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var error_handler_1 = __webpack_require__(10);
	var scanner_1 = __webpack_require__(12);
	var token_1 = __webpack_require__(13);
	var Reader = (function () {
	    function Reader() {
	        this.values = [];
	        this.curly = this.paren = -1;
	    }
	    // A function following one of those tokens is an expression.
	    Reader.prototype.beforeFunctionExpression = function (t) {
	        return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	            'return', 'case', 'delete', 'throw', 'void',
	            // assignment operators
	            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',
	            '&=', '|=', '^=', ',',
	            // binary/unary operators
	            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
	    };
	    // Determine if forward slash (/) is an operator or part of a regular expression
	    // https://github.com/mozilla/sweet.js/wiki/design
	    Reader.prototype.isRegexStart = function () {
	        var previous = this.values[this.values.length - 1];
	        var regex = (previous !== null);
	        switch (previous) {
	            case 'this':
	            case ']':
	                regex = false;
	                break;
	            case ')':
	                var keyword = this.values[this.paren - 1];
	                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');
	                break;
	            case '}':
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                regex = false;
	                if (this.values[this.curly - 3] === 'function') {
	                    // Anonymous function, e.g. function(){} /42
	                    var check = this.values[this.curly - 4];
	                    regex = check ? !this.beforeFunctionExpression(check) : false;
	                }
	                else if (this.values[this.curly - 4] === 'function') {
	                    // Named function, e.g. function f(){} /42/
	                    var check = this.values[this.curly - 5];
	                    regex = check ? !this.beforeFunctionExpression(check) : true;
	                }
	                break;
	            default:
	                break;
	        }
	        return regex;
	    };
	    Reader.prototype.push = function (token) {
	        if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
	            if (token.value === '{') {
	                this.curly = this.values.length;
	            }
	            else if (token.value === '(') {
	                this.paren = this.values.length;
	            }
	            this.values.push(token.value);
	        }
	        else {
	            this.values.push(null);
	        }
	    };
	    return Reader;
	}());
	var Tokenizer = (function () {
	    function Tokenizer(code, config) {
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;
	        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;
	        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;
	        this.buffer = [];
	        this.reader = new Reader();
	    }
	    Tokenizer.prototype.errors = function () {
	        return this.errorHandler.errors;
	    };
	    Tokenizer.prototype.getNextToken = function () {
	        if (this.buffer.length === 0) {
	            var comments = this.scanner.scanComments();
	            if (this.scanner.trackComment) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
	                    var comment = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: value
	                    };
	                    if (this.trackRange) {
	                        comment.range = e.range;
	                    }
	                    if (this.trackLoc) {
	                        comment.loc = e.loc;
	                    }
	                    this.buffer.push(comment);
	                }
	            }
	            if (!this.scanner.eof()) {
	                var loc = void 0;
	                if (this.trackLoc) {
	                    loc = {
	                        start: {
	                            line: this.scanner.lineNumber,
	                            column: this.scanner.index - this.scanner.lineStart
	                        },
	                        end: {}
	                    };
	                }
	                var startRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();
	                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
	                this.reader.push(token);
	                var entry = {
	                    type: token_1.TokenName[token.type],
	                    value: this.scanner.source.slice(token.start, token.end)
	                };
	                if (this.trackRange) {
	                    entry.range = [token.start, token.end];
	                }
	                if (this.trackLoc) {
	                    loc.end = {
	                        line: this.scanner.lineNumber,
	                        column: this.scanner.index - this.scanner.lineStart
	                    };
	                    entry.loc = loc;
	                }
	                if (token.type === 9 /* RegularExpression */) {
	                    var pattern = token.pattern;
	                    var flags = token.flags;
	                    entry.regex = { pattern: pattern, flags: flags };
	                }
	                this.buffer.push(entry);
	            }
	        }
	        return this.buffer.shift();
	    };
	    return Tokenizer;
	}());
	exports.Tokenizer = Tokenizer;


/***/ }
/******/ ])
});
;
},{}],52:[function(require,module,exports){
'use strict'
var readonlyProxies = new WeakMap
var currentSandbox = undefined
var GLOBAL = new Function('return this')()
var unscopablesSymbol = Symbol.unscopables
var FunctionConstructor = 0..constructor.constructor

function compileExpression(src) {
	if (typeof src !== 'string') {
		throw new TypeError('Expected argument to be a string.')
	}
	
	new FunctionConstructor('"use strict"; return ' + src) // Tests for syntax errors without running the code
	var code = new FunctionConstructor('sandbox', 'with (sandbox) {return (function () {"use strict"; return ' + src + '}).call(this)}')
	
	return function (sandbox) {
		if (!isObject(sandbox)) {
			throw new TypeError('Expected argument to be an object or function.')
		}
		if (currentSandbox) {
			throw new Error('You cannot run sandboxed code inside an already-running sandbox.')
		}
		var sandboxProxy = getProxy(sandbox)
		var result, error
		
		currentSandbox = sandbox
		try {
			result = code.call(sandboxProxy, sandboxProxy)
			currentSandbox = undefined
		} catch (ex) {
			currentSandbox = undefined
			if (ex instanceof Error) {
				error = new ex.constructor('' + ex.message)
				error.stack = '' + ex.stack
				throw error
			}
			throw new Error(String(ex))
		}
		if (isObject(result)) {
			throw TypeError('Sandboxes are only allowed to return primitive values.')
		}
		return result
	}
}
module.exports = compileExpression

var traps = {
	get: function (target, key, receiver) {
		if (currentSandbox) {
			if (key === unscopablesSymbol && target === currentSandbox) {
				return undefined
			}
			if (!notPrivate(key)) {
				return undefined
			}
			return getProxyOrPrimitive(Reflect.get(target, key, receiver))
		}
		return Reflect.get(target, key, receiver)
	},
	set: function (target, key, value, receiver) {
		if (currentSandbox) {
			throw new TypeError('You cannot set properties on a sandboxed object.')
		}
		return Reflect.set(target, key, value, receiver)
	},
	has: function (target, key) {
		if (currentSandbox) {
			if (target === currentSandbox) {
				return true
			}
			if (!notPrivate(key)) {
				return false
			}
			return getProxyOrPrimitive(Reflect.has(target, key))
		}
		return Reflect.has(target, key)
	},
	getPrototypeOf: function (target) {
		if (currentSandbox) {
			return getProxyOrPrimitive(Reflect.getPrototypeOf(target))
		}
		return Reflect.getPrototypeOf(target)
	},
	setPrototypeOf: function (target, proto) {
		if (currentSandbox) {
			throw new TypeError('You cannot set the prototype of a sandboxed object.')
		}
		return Reflect.setPrototypeOf(target, proto)
	},
	isExtensible: function (target) {
		if (currentSandbox) {
			return getProxyOrPrimitive(Reflect.isExtensible(target))
		}
		return Reflect.isExtensible(target)
	},
	preventExtensions: function (target) {
		if (currentSandbox) {
			throw new TypeError('You cannot change the extensibility of a sandboxed object.')
		}
		return Reflect.preventExtensions(target)
	},
	getOwnPropertyDescriptor: function (target, key) {
		if (currentSandbox) {
			if (key === Symbol.unscopables && target === currentSandbox) {
				return undefined
			}
			if (!notPrivate(key)) {
				return undefined
			}
			return getProxyOrPrimitive(Reflect.getOwnPropertyDescriptor(target, key))
		}
		return Reflect.getOwnPropertyDescriptor(target, key)
	},
	defineProperty: function (target, key, descriptor) {
		if (currentSandbox) {
			throw new TypeError('You cannot define properties on a sandboxed object.')
		}
		return Reflect.defineProperty(target, key, descriptor)
	},
	deleteProperty: function (target, key) {
		if (currentSandbox) {
			throw new TypeError('You cannot delete properties on a sandboxed object.')
		}
		return Reflect.deleteProperty(target, key)
	},
	ownKeys: function (target) {
		if (currentSandbox) {
			return getProxyOrPrimitive(Reflect.ownKeys(target).filter(notPrivate))
		}
		return Reflect.ownKeys(target)
	},
	apply: function (target, thisArg, argumentsList) {
		if (currentSandbox) {
			if (target === FunctionConstructor || target === FunctionConstructorProxy) {
				throw new TypeError('You cannot use the Function constructor in a sandboxed context.')
			}
			return getProxyOrPrimitive(Reflect.apply(target, thisArg, argumentsList))
		}
		return Reflect.apply(target, thisArg, argumentsList)
	},
	construct: function (target, argumentsList, newTarget) {
		if (currentSandbox) {
			if (target === FunctionConstructor || target === FunctionConstructorProxy) {
				throw new TypeError('You cannot use the Function constructor in a sandboxed context.')
			}
			return getProxyOrPrimitive(Reflect.construct(target, argumentsList, newTarget))
		}
		return Reflect.construct(target, argumentsList, newTarget)
	}
}

function isObject(value) {
	return typeof value === 'function' || (value !== null && typeof value === 'object')
}

function getProxyOrPrimitive(value) {
	if (isObject(value)) {
		return safeObjects.indexOf(value) >= 0 ? value : getProxy(value)
	}
	return value
}

function getProxy(object, hideOriginal) {
	if (object === GLOBAL) {
		throw new TypeError('The global object is forbidden from entering a sandboxed context.')
	}
	if (object === evalFunction) {
		throw new TypeError('The eval function is forbidden from entering a sandboxed context.')
	}
	var proxy = readonlyProxies.get(object)
	if (typeof proxy === 'undefined') {
		proxy = new Proxy(object, traps)
		readonlyProxies.set(hideOriginal ? proxy : object, proxy)
	}
	return proxy
}

function notPrivate(key) {
	return typeof key !== 'string' || key[0] !== '_'
}

// Freeze and proxy anything that is accessible through JavaScript syntax alone
// This should include any value that you can get from JavaScript syntax itself.
// For example:
//     "my string".foobar
//     try {throw 1} catch (err) {err.foobar}
// Symbols are included here because they are not protected by our proxying
// because they are primitives.
var safeObjects = require('./lib/make-safe')([
	Boolean.prototype,
	Number.prototype,
	String.prototype,
	Symbol.prototype,
	Function.prototype,
	Object.prototype,
	Array.prototype,
	RegExp.prototype,
	Error.prototype,
	EvalError.prototype,
	RangeError.prototype,
	ReferenceError.prototype,
	SyntaxError.prototype,
	TypeError.prototype,
	URIError.prototype,
	Promise.prototype,
	Object.getPrototypeOf(function*(){}),
	Object.getPrototypeOf(function*(){}())
], isObject, getProxy, GLOBAL)

var evalFunction = GLOBAL.eval
var FunctionConstructorProxy = 0..constructor.constructor

module.exports.equals = function (a, b) {
	return a === b || (readonlyProxies.get(a) || a) === (readonlyProxies.get(b) || b)
}



},{"./lib/make-safe":53}],53:[function(require,module,exports){
'use strict'

module.exports = function (unsafeObjects, isObject, getProxy, GLOBAL) {
	var proxies = []
	var safeObjects = []
	var returnsSafeValues = [
		Function.prototype[Symbol.hasInstance]
	]
	var globalKeys = Object.getOwnPropertyNames(GLOBAL).filter(function (key) {return key !== 'root' && key !== 'GLOBAL' && key !== 'global' && key !== 'window' && key !== 'self'})
	var globalValues = globalKeys.map(function (key) {return this[key]}, GLOBAL)
	
	while (unsafeObjects.length) {
		makeSafe(unsafeObjects.shift())
	}
	
	function makeSafe(object) {
		if (isSafe(object)) {
			return
		}
		
		var reachable = Object.getOwnPropertyNames(object)
			.concat(Object.getOwnPropertySymbols(object))
		
		if (object === Function.prototype) {
			reachable = reachable.filter(ignoredKeys)
		}
		
		reachable.forEach(replaceWithProxy, object)
		Object.freeze(object)
		safeObjects.push(object)
		
		unsafeObjects.push(Object.getPrototypeOf(object))
	}
	
	function ignoredKeys(key) {
		return key !== 'caller' && key !== 'arguments'
	}
	
	function isSafe(value) {
		return !isObject(value) || proxies.indexOf(value) >= 0 || safeObjects.indexOf(value) >= 0
	}
	
	function replaceWithProxy(key) {
		var d = Object.getOwnPropertyDescriptor(this, key)
		if (!('value' in d)) {
			if (key === '__proto__' && isSafe(this[key])) {
				return
			}
			if (!d.configurable) {
				d.get && unsafeObjects.push(d.get)
				d.set && unsafeObjects.push(d.set)
				// This getter/setter could potentially return a non-proxied object
				console.warn('Potentially vulnerable getter/setter at %s in %s', key, this)
				return
			}
			var getter = d.get && getProxy(d.get, true)
			var setter = d.set && getProxy(d.set, true)
			Object.defineProperty(this, key, {
				get: getter,
				set: setter,
				enumerable: d.enumerable,
				configurable: false
			})
			getter && proxies.push(getter)
			setter && proxies.push(setter)
			return
		}
		
		var value = this[key]
		if (isSafe(value)) {
			return
		}
		
		if (d.writable) {
			var proxy = getProxy(value, true)
			proxies.push(this[key] = proxy)
			replaceInGlobal(value, proxy)
			return
		}
		
		if (d.configurable) {
			var proxy = getProxy(value, true)
			Object.defineProperty(this, key, {
				value: proxy,
				writable: false,
				enumerable: d.enumerable,
				configurable: false
			})
			replaceInGlobal(value, proxy)
			proxies.push(proxy)
			return
		}
		
		unsafeObjects.push(value)
		if (typeof value === 'function' && returnsSafeValues.indexOf(value) === -1) {
			// This function could potentially return a non-proxied object
			console.warn('Potentially vulnerable function at %s in %s', key, this)
		}
	}
	
	function replaceInGlobal(value, proxy) {
		var index = globalValues.indexOf(value)
		if (index >= 0) {
			var key = globalKeys[index]
			var d = Object.getOwnPropertyDescriptor(GLOBAL, key)
			if (d.writable) {
				GLOBAL[key] = proxy
			} else if (d.configurable) {
				Object.defineProperty(GLOBAL, key, {
					value: proxy,
					writable: false,
					enumerable: d.enumerable,
					configurable: false
				})
			} else {
				console.warn('Was not able to replace %s in global object', key)
			}
		}
	}
	
	return safeObjects
}

},{}],54:[function(require,module,exports){
'use strict';
var ansiRegex = require('ansi-regex');
var re = new RegExp(ansiRegex().source); // remove the `g` flag
module.exports = re.test.bind(re);

},{"ansi-regex":45}],55:[function(require,module,exports){
(function (global){
/**
 * © Copyright IBM Corp. 2016, 2017 All Rights Reserved
 *   Project name: JSONata
 *   This project is licensed under the MIT License, see LICENSE
 */

/**
 * @module JSONata
 * @description JSON query and transformation language
 */

/**
 * jsonata
 * @function
 * @param {Object} expr - JSONata expression
 * @returns {{evaluate: evaluate, assign: assign}} Evaluated expression
 */
var jsonata = (function() {
    'use strict';

    var operators = {
        '.': 75,
        '[': 80,
        ']': 0,
        '{': 70,
        '}': 0,
        '(': 80,
        ')': 0,
        ',': 0,
        '@': 75,
        '#': 70,
        ';': 80,
        ':': 80,
        '?': 20,
        '+': 50,
        '-': 50,
        '*': 60,
        '/': 60,
        '%': 60,
        '|': 20,
        '=': 40,
        '<': 40,
        '>': 40,
        '^': 40,
        '**': 60,
        '..': 20,
        ':=': 10,
        '!=': 40,
        '<=': 40,
        '>=': 40,
        '~>': 40,
        'and': 30,
        'or': 25,
        'in': 40,
        '&': 50,
        '!': 0,   // not an operator, but needed as a stop character for name tokens
        '~': 0   // not an operator, but needed as a stop character for name tokens
    };

    var escapes = {  // JSON string escape sequences - see json.org
        '"': '"',
        '\\': '\\',
        '/': '/',
        'b': '\b',
        'f': '\f',
        'n': '\n',
        'r': '\r',
        't': '\t'
    };

    // Tokenizer (lexer) - invoked by the parser to return one token at a time
    var tokenizer = function (path) {
        var position = 0;
        var length = path.length;

        var create = function (type, value) {
            var obj = {type: type, value: value, position: position};
            return obj;
        };

        var scanRegex = function() {
            // the prefix '/' will have been previously scanned. Find the end of the regex.
            // search for closing '/' ignoring any that are escaped, or within brackets
            var start = position;
            var depth = 0;
            var pattern;
            var flags;
            while(position < length) {
                var currentChar = path.charAt(position);
                if(currentChar === '/' && path.charAt(position - 1) !== '\\' && depth === 0) {
                    // end of regex found
                    pattern = path.substring(start, position);
                    if(pattern === '') {
                        throw {
                            code: "S0301",
                            stack: (new Error()).stack,
                            position: position
                        };
                    }
                    position++;
                    currentChar = path.charAt(position);
                    // flags
                    start = position;
                    while(currentChar === 'i' || currentChar === 'm') {
                        position++;
                        currentChar = path.charAt(position);
                    }
                    flags = path.substring(start, position) + 'g';
                    return new RegExp(pattern, flags);
                }
                if((currentChar === '(' || currentChar === '[' || currentChar === '{') && path.charAt(position - 1) !== '\\' ) {
                    depth++;
                }
                if((currentChar === ')' || currentChar === ']' || currentChar === '}') && path.charAt(position - 1) !== '\\' ) {
                    depth--;
                }

                position++;
            }
            throw {
                code: "S0302",
                stack: (new Error()).stack,
                position: position
            };
        };

        var next = function (prefix) {
            if (position >= length) return null;
            var currentChar = path.charAt(position);
            // skip whitespace
            while (position < length && ' \t\n\r\v'.indexOf(currentChar) > -1) {
                position++;
                currentChar = path.charAt(position);
            }
            // test for regex
            if (prefix !== true && currentChar === '/') {
                position++;
                return create('regex', scanRegex());
            }
            // handle double-char operators
            if (currentChar === '.' && path.charAt(position + 1) === '.') {
                // double-dot .. range operator
                position += 2;
                return create('operator', '..');
            }
            if (currentChar === ':' && path.charAt(position + 1) === '=') {
                // := assignment
                position += 2;
                return create('operator', ':=');
            }
            if (currentChar === '!' && path.charAt(position + 1) === '=') {
                // !=
                position += 2;
                return create('operator', '!=');
            }
            if (currentChar === '>' && path.charAt(position + 1) === '=') {
                // >=
                position += 2;
                return create('operator', '>=');
            }
            if (currentChar === '<' && path.charAt(position + 1) === '=') {
                // <=
                position += 2;
                return create('operator', '<=');
            }
            if (currentChar === '*' && path.charAt(position + 1) === '*') {
                // **  descendant wildcard
                position += 2;
                return create('operator', '**');
            }
            if (currentChar === '~' && path.charAt(position + 1) === '>') {
                // ~>  chain function
                position += 2;
                return create('operator', '~>');
            }
            // test for single char operators
            if (operators.hasOwnProperty(currentChar)) {
                position++;
                return create('operator', currentChar);
            }
            // test for string literals
            if (currentChar === '"' || currentChar === "'") {
                var quoteType = currentChar;
                // double quoted string literal - find end of string
                position++;
                var qstr = "";
                while (position < length) {
                    currentChar = path.charAt(position);
                    if (currentChar === '\\') { // escape sequence
                        position++;
                        currentChar = path.charAt(position);
                        if (escapes.hasOwnProperty(currentChar)) {
                            qstr += escapes[currentChar];
                        } else if (currentChar === 'u') {
                            // \u should be followed by 4 hex digits
                            var octets = path.substr(position + 1, 4);
                            if (/^[0-9a-fA-F]+$/.test(octets)) {
                                var codepoint = parseInt(octets, 16);
                                qstr += String.fromCharCode(codepoint);
                                position += 4;
                            } else {
                                throw {
                                    code: "S0104",
                                    stack: (new Error()).stack,
                                    position: position
                                };
                            }
                        } else {
                            // illegal escape sequence
                            throw {
                                code: "S0103",
                                stack: (new Error()).stack,
                                position: position,
                                token: currentChar
                            };

                        }
                    } else if (currentChar === quoteType) {
                        position++;
                        return create('string', qstr);
                    } else {
                        qstr += currentChar;
                    }
                    position++;
                }
                throw {
                    code: "S0101",
                    stack: (new Error()).stack,
                    position: position
                };
            }
            // test for numbers
            var numregex = /^-?(0|([1-9][0-9]*))(\.[0-9]+)?([Ee][-+]?[0-9]+)?/;
            var match = numregex.exec(path.substring(position));
            if (match !== null) {
                var num = parseFloat(match[0]);
                if (!isNaN(num) && isFinite(num)) {
                    position += match[0].length;
                    return create('number', num);
                } else {
                    throw {
                        code: "S0102",
                        stack: (new Error()).stack,
                        position: position,
                        token: match[0]
                    };
                }
            }
            // test for quoted names (backticks)
            var name;
            if(currentChar === '`') {
                // scan for closing quote
                position++;
                var end = path.indexOf('`', position);
                if(end !== -1) {
                    name = path.substring(position, end);
                    position = end + 1;
                    return create('name', name);
                }
                position = length;
                throw {
                    code: "S0105",
                    stack: (new Error()).stack,
                    position: position
                };
            }
            // test for names
            var i = position;
            var ch;
            for (;;) {
                ch = path.charAt(i);
                if (i === length || ' \t\n\r\v'.indexOf(ch) > -1 || operators.hasOwnProperty(ch)) {
                    if (path.charAt(position) === '$') {
                        // variable reference
                        name = path.substring(position + 1, i);
                        position = i;
                        return create('variable', name);
                    } else {
                        name = path.substring(position, i);
                        position = i;
                        switch (name) {
                            case 'or':
                            case 'in':
                            case 'and':
                                return create('operator', name);
                            case 'true':
                                return create('value', true);
                            case 'false':
                                return create('value', false);
                            case 'null':
                                return create('value', null);
                            default:
                                if (position === length && name === '') {
                                    // whitespace at end of input
                                    return null;
                                }
                                return create('name', name);
                        }
                    }
                } else {
                    i++;
                }
            }
        };

        return next;
    };

    /**
     * Parses a function signature definition and returns a validation function
     * @param {string} signature - the signature between the <angle brackets>
     * @returns {Function} validation function
     */
    function parseSignature(signature) {
        // create a Regex that represents this signature and return a function that when invoked,
        // returns the validated (possibly fixed-up) arguments, or throws a validation error
        // step through the signature, one symbol at a time
        var position = 1;
        var params = [];
        var param = {};
        var prevParam = param;
        while (position < signature.length) {
            var symbol = signature.charAt(position);
            if(symbol === ':') {
                // TODO figure out what to do with the return type
                // ignore it for now
                break;
            }

            var next = function() {
                params.push(param);
                prevParam = param;
                param = {};
            };

            var findClosingBracket = function(str, start, openSymbol, closeSymbol) {
                // returns the position of the closing symbol (e.g. bracket) in a string
                // that balances the opening symbol at position start
                var depth = 1;
                var position = start;
                while(position < str.length) {
                    position++;
                    symbol = str.charAt(position);
                    if(symbol === closeSymbol) {
                        depth--;
                        if(depth === 0) {
                            // we're done
                            break; // out of while loop
                        }
                    } else if(symbol === openSymbol) {
                        depth++;
                    }
                }
                return position;
            };

            switch (symbol) {
                case 's': // string
                case 'n': // number
                case 'b': // boolean
                case 'l': // not so sure about expecting null?
                case 'o': // object
                    param.regex = '[' + symbol + 'm]';
                    param.type = symbol;
                    next();
                    break;
                case 'a': // array
                    //  normally treat any value as singleton array
                    param.regex = '[asnblfom]';
                    param.type = symbol;
                    param.array = true;
                    next();
                    break;
                case 'f': // function
                    param.regex = 'f';
                    param.type = symbol;
                    next();
                    break;
                case 'j': // any JSON type
                    param.regex = '[asnblom]';
                    param.type = symbol;
                    next();
                    break;
                case 'x': // any type
                    param.regex = '[asnblfom]';
                    param.type = symbol;
                    next();
                    break;
                case '-': // use context if param not supplied
                    prevParam.context = true;
                    prevParam.contextRegex = new RegExp(prevParam.regex); // pre-compiled to test the context type at runtime
                    prevParam.regex += '?';
                    break;
                case '?': // optional param
                case '+': // one or more
                    prevParam.regex += symbol;
                    break;
                case '(': // choice of types
                    // search forward for matching ')'
                    var endParen = findClosingBracket(signature, position, '(', ')');
                    var choice = signature.substring(position + 1, endParen);
                    if(choice.indexOf('<') === -1) {
                        // no parameterized types, simple regex
                        param.regex = '[' + choice + 'm]';
                    } else {
                        // TODO harder
                        throw {
                            code: "S0402",
                            stack: (new Error()).stack,
                            value: choice,
                            offset: position
                        };
                    }
                    param.type = '(' + choice + ')';
                    position = endParen;
                    next();
                    break;
                case '<': // type parameter - can only be applied to 'a' and 'f'
                    if(prevParam.type === 'a' || prevParam.type === 'f') {
                        // search forward for matching '>'
                        var endPos = findClosingBracket(signature, position, '<', '>');
                        prevParam.subtype = signature.substring(position + 1, endPos);
                        position = endPos;
                    } else {
                        throw {
                            code: "S0401",
                            stack: (new Error()).stack,
                            value: prevParam.type,
                            offset: position
                        };
                    }
                    break;
            }
            position++;
        }
        var regexStr = '^' +
          params.map(function(param) {
              return '(' + param.regex + ')';
          }).join('') +
          '$';
        var regex = new RegExp(regexStr);
        var getSymbol = function(value) {
            var symbol;
            if(isFunction(value)) {
                symbol = 'f';
            } else {
                var type = typeof value;
                switch (type) {
                    case 'string':
                        symbol = 's';
                        break;
                    case 'number':
                        symbol = 'n';
                        break;
                    case 'boolean':
                        symbol = 'b';
                        break;
                    case 'object':
                        if (value === null) {
                            symbol = 'l';
                        } else if (Array.isArray(value)) {
                            symbol = 'a';
                        } else {
                            symbol = 'o';
                        }
                        break;
                    case 'undefined':
                        // any value can be undefined, but should be allowed to match
                        symbol = 'm'; // m for missing
                }
            }
            return symbol;
        };

        var throwValidationError = function(badArgs, badSig) {
            // to figure out where this went wrong we need apply each component of the
            // regex to each argument until we get to the one that fails to match
            var partialPattern = '^';
            var goodTo = 0;
            for(var index = 0; index < params.length; index++) {
                partialPattern += params[index].regex;
                var match = badSig.match(partialPattern);
                if(match === null) {
                    // failed here
                    throw {
                        code: "T0410",
                        stack: (new Error()).stack,
                        value: badArgs[goodTo],
                        index: goodTo + 1
                    };
                }
                goodTo = match[0].length;
            }
            // if it got this far, it's probably because of extraneous arguments (we
            // haven't added the trailing '$' in the regex yet.
            throw {
                code: "T0410",
                stack: (new Error()).stack,
                value: badArgs[goodTo],
                index: goodTo + 1
            };
        };

        return {
            definition: signature,
            validate: function(args, context) {
                var suppliedSig = '';
                args.forEach(function(arg) {
                    suppliedSig += getSymbol(arg);
                });
                var isValid = regex.exec(suppliedSig);
                if(isValid) {
                    var validatedArgs = [];
                    var argIndex = 0;
                    params.forEach(function(param, index) {
                        var arg = args[argIndex];
                        var match = isValid[index + 1];
                        if(match === '') {
                            if (param.context) {
                                // substitute context value for missing arg
                                // first check that the context value is the right type
                                var contextType = getSymbol(context);
                                // test contextType against the regex for this arg (without the trailing ?)
                                if(param.contextRegex.test(contextType)) {
                                    validatedArgs.push(context);
                                } else {
                                    // context value not compatible with this argument
                                    throw {
                                        code: "T0411",
                                        stack: (new Error()).stack,
                                        value: context,
                                        index: argIndex + 1
                                    };
                                }
                            } else {
                                validatedArgs.push(arg);
                                argIndex++;
                            }
                        } else {
                            // may have matched multiple args (if the regex ends with a '+'
                            // split into single tokens
                            match.split('').forEach(function(single) {
                                if (param.type === 'a') {
                                    if (single === 'm') {
                                        // missing (undefined)
                                        arg = undefined;
                                    } else {
                                        arg = args[argIndex];
                                        var arrayOK = true;
                                        // is there type information on the contents of the array?
                                        if (typeof param.subtype !== 'undefined') {
                                            if (single !== 'a' && match !== param.subtype) {
                                                arrayOK = false;
                                            } else if (single === 'a') {
                                                if (arg.length > 0) {
                                                    var itemType = getSymbol(arg[0]);
                                                    if (itemType !== param.subtype.charAt(0)) { // TODO recurse further
                                                        arrayOK = false;
                                                    } else {
                                                        // make sure every item in the array is this type
                                                        var differentItems = arg.filter(function (val) {
                                                            return (getSymbol(val) !== itemType);
                                                        });
                                                        arrayOK = (differentItems.length === 0);
                                                    }
                                                }
                                            }
                                        }
                                        if (!arrayOK) {
                                            throw {
                                                code: "T0412",
                                                stack: (new Error()).stack,
                                                value: arg,
                                                index: argIndex + 1,
                                                type: param.subtype // TODO translate symbol to type name
                                            };
                                        }
                                        // the function expects an array. If it's not one, make it so
                                        if (single !== 'a') {
                                            arg = [arg];
                                        }
                                    }
                                    validatedArgs.push(arg);
                                    argIndex++;
                                } else {
                                    validatedArgs.push(arg);
                                    argIndex++;
                                }
                            });
                        }
                    });
                    return validatedArgs;
                }
                throwValidationError(args, suppliedSig);
            }
        };
    }

    // This parser implements the 'Top down operator precedence' algorithm developed by Vaughan R Pratt; http://dl.acm.org/citation.cfm?id=512931.
    // and builds on the Javascript framework described by Douglas Crockford at http://javascript.crockford.com/tdop/tdop.html
    // and in 'Beautiful Code', edited by Andy Oram and Greg Wilson, Copyright 2007 O'Reilly Media, Inc. 798-0-596-51004-6

    var parser = function (source, recover) {
        var node;
        var lexer;

        var symbol_table = {};
        var errors = [];

        var remainingTokens = function() {
            var remaining = [];
            if(node.id !== '(end)') {
                remaining.push({type: node.type, value: node.value, position: node.position});
            }
            var nxt = lexer();
            while(nxt !== null) {
                remaining.push(nxt);
                nxt = lexer();
            }
            return remaining;
        };

        var base_symbol = {
            nud: function () {
                // error - symbol has been invoked as a unary operator
                var err = {
                    code: 'S0211',
                    token: this.value,
                    position: this.position
                };

                if(recover) {
                    err.remaining = remainingTokens();
                    err.type = 'error';
                    errors.push(err);
                    return err;
                } else {
                    err.stack = (new Error()).stack;
                    throw err;
                }
            }
        };

        var symbol = function (id, bp) {
            var s = symbol_table[id];
            bp = bp || 0;
            if (s) {
                if (bp >= s.lbp) {
                    s.lbp = bp;
                }
            } else {
                s = Object.create(base_symbol);
                s.id = s.value = id;
                s.lbp = bp;
                symbol_table[id] = s;
            }
            return s;
        };

        var handleError = function(err) {
            if(recover) {
                // tokenize the rest of the buffer and add it to an error token
                err.remaining = remainingTokens();
                errors.push(err);
                var symbol = symbol_table["(error)"];
                node = Object.create(symbol);
                node.error = err;
                node.type = "(error)";
                return node;
            } else {
                err.stack = (new Error()).stack;
                throw err;
            }
        };

        var advance = function (id, infix) {
            if (id && node.id !== id) {
                var code;
                if(node.id === '(end)') {
                    // unexpected end of buffer
                    code = "S0203";
                } else {
                    code = "S0202";
                }
                var err = {
                    code: code,
                    position: node.position,
                    token: node.value,
                    value: id
                };
                return handleError(err);
            }
            var next_token = lexer(infix);
            if (next_token === null) {
                node = symbol_table["(end)"];
                node.position = source.length;
                return node;
            }
            var value = next_token.value;
            var type = next_token.type;
            var symbol;
            switch (type) {
                case 'name':
                case 'variable':
                    symbol = symbol_table["(name)"];
                    break;
                case 'operator':
                    symbol = symbol_table[value];
                    if (!symbol) {
                        return handleError( {
                            code: "S0204",
                            stack: (new Error()).stack,
                            position: next_token.position,
                            token: value
                        });
                    }
                    break;
                case 'string':
                case 'number':
                case 'value':
                    type = "literal";
                    symbol = symbol_table["(literal)"];
                    break;
                case 'regex':
                    type = "regex";
                    symbol = symbol_table["(regex)"];
                    break;
                    /* istanbul ignore next */
                default:
                    return handleError( {
                        code: "S0205",
                        stack: (new Error()).stack,
                        position: next_token.position,
                        token: value
                    });
            }

            node = Object.create(symbol);
            node.value = value;
            node.type = type;
            node.position = next_token.position;
            return node;
        };

        // Pratt's algorithm
        var expression = function (rbp) {
            var left;
            var t = node;
            advance(null, true);
            left = t.nud();
            while (rbp < node.lbp) {
                t = node;
                advance();
                left = t.led(left);
            }
            return left;
        };

        var terminal = function(id) {
            var s = symbol(id, 0);
            s.nud = function() {
                return this;
            };
        };

        // match infix operators
        // <expression> <operator> <expression>
        // left associative
        var infix = function (id, bp, led) {
            var bindingPower = bp || operators[id];
            var s = symbol(id, bindingPower);
            s.led = led || function (left) {
                this.lhs = left;
                this.rhs = expression(bindingPower);
                this.type = "binary";
                return this;
            };
            return s;
        };

        // match infix operators
        // <expression> <operator> <expression>
        // right associative
        var infixr = function (id, bp, led) {
            var bindingPower = bp || operators[id];
            var s = symbol(id, bindingPower);
            s.led = led || function (left) {
                this.lhs = left;
                this.rhs = expression(bindingPower - 1); // subtract 1 from bindingPower for right associative operators
                this.type = "binary";
                return this;
            };
            return s;
        };

        // match prefix operators
        // <operator> <expression>
        var prefix = function (id, nud) {
            var s = symbol(id);
            s.nud = nud || function () {
                this.expression = expression(70);
                this.type = "unary";
                return this;
            };
            return s;
        };

        terminal("(end)");
        terminal("(name)");
        terminal("(literal)");
        terminal("(regex)");
        symbol(":");
        symbol(";");
        symbol(",");
        symbol(")");
        symbol("]");
        symbol("}");
        symbol(".."); // range operator
        infix("."); // field reference
        infix("+"); // numeric addition
        infix("-"); // numeric subtraction
        infix("*"); // numeric multiplication
        infix("/"); // numeric division
        infix("%"); // numeric modulus
        infix("="); // equality
        infix("<"); // less than
        infix(">"); // greater than
        infix("!="); // not equal to
        infix("<="); // less than or equal
        infix(">="); // greater than or equal
        infix("&"); // string concatenation
        infix("and"); // Boolean AND
        infix("or"); // Boolean OR
        infix("in"); // is member of array
        terminal("and"); // the 'keywords' can also be used as terminals (field names)
        terminal("or"); //
        terminal("in"); //
        infixr(":="); // bind variable
        prefix("-"); // unary numeric negation
        infix("~>"); // function application

        infixr("(error)", 10, function(left) {
            this.lhs = left;

            this.error = node.error;
            this.remaining = remainingTokens();
            this.type = 'error';
            return this;
        });

        // field wildcard (single level)
        prefix('*', function () {
            this.type = "wildcard";
            return this;
        });

        // descendant wildcard (multi-level)
        prefix('**', function () {
            this.type = "descendant";
            return this;
        });

        // function invocation
        infix("(", operators['('], function (left) {
            // left is is what we are trying to invoke
            this.procedure = left;
            this.type = 'function';
            this.arguments = [];
            if (node.id !== ')') {
                for (;;) {
                    if (node.type === 'operator' && node.id === '?') {
                        // partial function application
                        this.type = 'partial';
                        this.arguments.push(node);
                        advance('?');
                    } else {
                        this.arguments.push(expression(0));
                    }
                    if (node.id !== ',') break;
                    advance(',');
                }
            }
            advance(")", true);
            // if the name of the function is 'function' or λ, then this is function definition (lambda function)
            if (left.type === 'name' && (left.value === 'function' || left.value === '\u03BB')) {
                // all of the args must be VARIABLE tokens
                this.arguments.forEach(function (arg, index) {
                    if (arg.type !== 'variable') {
                        return handleError( {
                            code: "S0208",
                            stack: (new Error()).stack,
                            position: arg.position,
                            token: arg.value,
                            value: index + 1
                        });
                    }
                });
                this.type = 'lambda';
                // is the next token a '<' - if so, parse the function signature
                if(node.id === '<') {
                    var sigPos = node.position;
                    var depth = 1;
                    var sig = '<';
                    while(depth > 0 && node.id !== '{' && node.id !== '(end)') {
                        var tok = advance();
                        if(tok.id === '>') {
                            depth--;
                        } else if(tok.id === '<') {
                            depth++;
                        }
                        sig += tok.value;
                    }
                    advance('>');
                    try {
                        this.signature = parseSignature(sig);
                    } catch(err) {
                        // insert the position into this error
                        err.position = sigPos + err.offset;
                        return handleError( err );
                    }
                }
                // parse the function body
                advance('{');
                this.body = expression(0);
                advance('}');
            }
            return this;
        });

        // parenthesis - block expression
        prefix("(", function () {
            var expressions = [];
            while (node.id !== ")") {
                expressions.push(expression(0));
                if (node.id !== ";") {
                    break;
                }
                advance(";");
            }
            advance(")", true);
            this.type = 'block';
            this.expressions = expressions;
            return this;
        });

        // array constructor
        prefix("[", function () {
            var a = [];
            if (node.id !== "]") {
                for (;;) {
                    var item = expression(0);
                    if (node.id === "..") {
                        // range operator
                        var range = {type: "binary", value: "..", position: node.position, lhs: item};
                        advance("..");
                        range.rhs = expression(0);
                        item = range;
                    }
                    a.push(item);
                    if (node.id !== ",") {
                        break;
                    }
                    advance(",");
                }
            }
            advance("]", true);
            this.expressions = a;
            this.type = "unary";
            return this;
        });

        // filter - predicate or array index
        infix("[", operators['['], function (left) {
            if(node.id === "]") {
                // empty predicate means maintain singleton arrays in the output
                var step = left;
                while(step && step.type === 'binary' && step.value === '[') {
                    step = step.lhs;
                }
                step.keepArray = true;
                advance("]");
                return left;
            } else {
                this.lhs = left;
                this.rhs = expression(operators[']']);
                this.type = 'binary';
                advance("]", true);
                return this;
            }
        });

        // order-by
        infix("^", operators['^'], function (left) {
            advance("(");
            var terms = [];
            for(;;) {
                var term = {
                    descending: false
                };
                if (node.id === "<") {
                    // ascending sort
                    advance("<");
                } else if (node.id === ">") {
                    // descending sort
                    term.descending = true;
                    advance(">");
                } else {
                    //unspecified - default to ascending
                }
                term.expression = expression(0);
                terms.push(term);
                if(node.id !== ",") {
                    break;
                }
                advance(",");
            }
            advance(")");
            this.lhs = left;
            this.rhs = terms;
            this.type = 'binary';
            return this;
        });

        var objectParser = function (left) {
            var a = [];
            if (node.id !== "}") {
                for (;;) {
                    var n = expression(0);
                    advance(":");
                    var v = expression(0);
                    a.push([n, v]); // holds an array of name/value expression pairs
                    if (node.id !== ",") {
                        break;
                    }
                    advance(",");
                }
            }
            advance("}", true);
            if(typeof left === 'undefined') {
                // NUD - unary prefix form
                this.lhs = a;
                this.type = "unary";
            } else {
                // LED - binary infix form
                this.lhs = left;
                this.rhs = a;
                this.type = 'binary';
            }
            return this;
        };

        // object constructor
        prefix("{", objectParser);

        // object grouping
        infix("{", operators['{'], objectParser);

        // if/then/else ternary operator ?:
        infix("?", operators['?'], function (left) {
            this.type = 'condition';
            this.condition = left;
            this.then = expression(0);
            if (node.id === ':') {
                // else condition
                advance(":");
                this.else = expression(0);
            }
            return this;
        });

        // object transformer
        prefix("|", function () {
            this.type = 'transform';
            this.pattern = expression(0);
            advance('|');
            this.update = expression(0);
            if(node.id === ',') {
                advance(',');
                this.delete = expression(0);
            }
            advance('|');
            return this;
        });

        // tail call optimization
        // this is invoked by the post parser to analyse lambda functions to see
        // if they make a tail call.  If so, it is replaced by a thunk which will
        // be invoked by the trampoline loop during function application.
        // This enables tail-recursive functions to be written without growing the stack
        var tail_call_optimize = function(expr) {
            var result;
            if(expr.type === 'function') {
                var thunk = {type: 'lambda', thunk: true, arguments: [], position: expr.position};
                thunk.body = expr;
                result = thunk;
            } else if(expr.type === 'condition') {
                // analyse both branches
                expr.then = tail_call_optimize(expr.then);
                if(typeof expr.else !== 'undefined') {
                    expr.else = tail_call_optimize(expr.else);
                }
                result = expr;
            } else if(expr.type === 'block') {
                // only the last expression in the block
                var length = expr.expressions.length;
                if(length > 0) {
                    expr.expressions[length - 1] = tail_call_optimize(expr.expressions[length - 1]);
                }
                result = expr;
            } else {
                result = expr;
            }
            return result;
        };

        // post-parse stage
        // the purpose of this is flatten the parts of the AST representing location paths,
        // converting them to arrays of steps which in turn may contain arrays of predicates.
        // following this, nodes containing '.' and '[' should be eliminated from the AST.
        var ast_optimize = function (expr) {
            var result;
            switch (expr.type) {
                case 'binary':
                    switch (expr.value) {
                        case '.':
                            var lstep = ast_optimize(expr.lhs);
                            result = {type: 'path', steps: []};
                            if (lstep.type === 'path') {
                                Array.prototype.push.apply(result.steps, lstep.steps);
                            } else {
                                result.steps = [lstep];
                            }
                            var rest = ast_optimize(expr.rhs);
                            if(rest.type === 'function' &&
                              rest.procedure.type === 'path' &&
                              rest.procedure.steps.length === 1 &&
                              rest.procedure.steps[0].type === 'name' &&
                              result.steps[result.steps.length-1].type === 'function') {
                                // next function in chain of functions - will override a thenable
                                result.steps[result.steps.length-1].nextFunction = rest.procedure.steps[0].value;
                            }
                            if(rest.type !== 'path') {
                                rest = {type: 'path', steps: [rest]};
                            }
                            Array.prototype.push.apply(result.steps, rest.steps);
                            // any steps within a path that are literals, should be changed to 'name'
                            result.steps.filter(function(step) {
                                return step.type === 'literal';
                            }).forEach(function(lit) {
                                lit.type = 'name';
                            });
                            // any step that signals keeping a singleton array, should be flagged on the path
                            if(result.steps.filter(function(step) { return step.keepArray === true;}).length > 0) {
                                result.keepSingletonArray = true;
                            }
                            // if first step is a path constructor, flag it for special handling
                            if(result.steps[0].type === 'unary' && result.steps[0].value === '[') {
                                result.steps[0].consarray = true;
                            }
                            break;
                        case '[':
                            // predicated step
                            // LHS is a step or a predicated step
                            // RHS is the predicate expr
                            result = ast_optimize(expr.lhs);
                            var step = result;
                            if(result.type === 'path') {
                                step = result.steps[result.steps.length - 1];
                            }
                            if (typeof step.group !== 'undefined') {
                                throw {
                                    code: "S0209",
                                    stack: (new Error()).stack,
                                    position: expr.position
                                };
                            }
                            if (typeof step.predicate === 'undefined') {
                                step.predicate = [];
                            }
                            step.predicate.push(ast_optimize(expr.rhs));
                            break;
                        case '{':
                            // group-by
                            // LHS is a step or a predicated step
                            // RHS is the object constructor expr
                            result = ast_optimize(expr.lhs);
                            if (typeof result.group !== 'undefined') {
                                throw {
                                    code: "S0210",
                                    stack: (new Error()).stack,
                                    position: expr.position
                                };
                            }
                            // object constructor - process each pair
                            result.group = {
                                lhs: expr.rhs.map(function (pair) {
                                    return [ast_optimize(pair[0]), ast_optimize(pair[1])];
                                }),
                                position: expr.position
                            };
                            break;
                        case '^':
                            // order-by
                            // LHS is the array to be ordered
                            // RHS defines the terms
                            result = {type: 'sort', value: expr.value, position: expr.position};
                            result.lhs = ast_optimize(expr.lhs);
                            result.rhs = expr.rhs.map(function (terms) {
                                return {
                                    descending: terms.descending,
                                    expression: ast_optimize(terms.expression)
                                };
                            });
                            break;
                        case ':=':
                            result = {type: 'bind', value: expr.value, position: expr.position};
                            result.lhs = ast_optimize(expr.lhs);
                            result.rhs = ast_optimize(expr.rhs);
                            break;
                        case '~>':
                            result = {type: 'apply', value: expr.value, position: expr.position};
                            result.lhs = ast_optimize(expr.lhs);
                            result.rhs = ast_optimize(expr.rhs);
                            break;
                        default:
                            result = {type: expr.type, value: expr.value, position: expr.position};
                            result.lhs = ast_optimize(expr.lhs);
                            result.rhs = ast_optimize(expr.rhs);
                    }
                    break;
                case 'unary':
                    result = {type: expr.type, value: expr.value, position: expr.position};
                    if (expr.value === '[') {
                        // array constructor - process each item
                        result.expressions = expr.expressions.map(function (item) {
                            return ast_optimize(item);
                        });
                    } else if (expr.value === '{') {
                        // object constructor - process each pair
                        result.lhs = expr.lhs.map(function (pair) {
                            return [ast_optimize(pair[0]), ast_optimize(pair[1])];
                        });
                    } else {
                        // all other unary expressions - just process the expression
                        result.expression = ast_optimize(expr.expression);
                        // if unary minus on a number, then pre-process
                        if (expr.value === '-' && result.expression.type === 'literal' && isNumeric(result.expression.value)) {
                            result = result.expression;
                            result.value = -result.value;
                        }
                    }
                    break;
                case 'function':
                case 'partial':
                    result = {type: expr.type, name: expr.name, value: expr.value, position: expr.position};
                    result.arguments = expr.arguments.map(function (arg) {
                        return ast_optimize(arg);
                    });
                    result.procedure = ast_optimize(expr.procedure);
                    break;
                case 'lambda':
                    result = {type: expr.type, arguments: expr.arguments, signature: expr.signature, position: expr.position};
                    var body = ast_optimize(expr.body);
                    result.body = tail_call_optimize(body);
                    break;
                case 'condition':
                    result = {type: expr.type, position: expr.position};
                    result.condition = ast_optimize(expr.condition);
                    result.then = ast_optimize(expr.then);
                    if (typeof expr.else !== 'undefined') {
                        result.else = ast_optimize(expr.else);
                    }
                    break;
                case 'transform':
                    result = {type: expr.type, position: expr.position};
                    result.pattern = ast_optimize(expr.pattern);
                    result.update = ast_optimize(expr.update);
                    if(typeof expr.delete !== 'undefined') {
                        result.delete = ast_optimize(expr.delete);
                    }
                    break;
                case 'block':
                    result = {type: expr.type, position: expr.position};
                    // array of expressions - process each one
                    result.expressions = expr.expressions.map(function (item) {
                        return ast_optimize(item);
                    });
                    // TODO scan the array of expressions to see if any of them assign variables
                    // if so, need to mark the block as one that needs to create a new frame
                    break;
                case 'name':
                    result = {type: 'path', steps: [expr]};
                    if(expr.keepArray) {
                        result.keepSingletonArray = true;
                    }
                    break;
                case 'literal':
                case 'wildcard':
                case 'descendant':
                case 'variable':
                case 'regex':
                    result = expr;
                    break;
                case 'operator':
                    // the tokens 'and' and 'or' might have been used as a name rather than an operator
                    if (expr.value === 'and' || expr.value === 'or' || expr.value === 'in') {
                        expr.type = 'name';
                        result = ast_optimize(expr);
                    } else /* istanbul ignore else */ if (expr.value === '?') {
                        // partial application
                        result = expr;
                    } else {
                        throw {
                            code: "S0201",
                            stack: (new Error()).stack,
                            position: expr.position,
                            token: expr.value
                        };
                    }
                    break;
                case 'error':
                    result = expr;
                    if(expr.lhs) {
                        result = ast_optimize(expr.lhs);
                    }
                    break;
                default:
                    var code = "S0206";
                    /* istanbul ignore else */
                    if (expr.id === '(end)') {
                        code = "S0207";
                    }
                    var err = {
                        code: code,
                        position: expr.position,
                        token: expr.value
                    };
                    if(recover) {
                        errors.push(err);
                        return {type: 'error', error: err};
                    } else {
                        err.stack = (new Error()).stack;
                        throw err;
                    }
            }
            return result;
        };

        // now invoke the tokenizer and the parser and return the syntax tree
        lexer = tokenizer(source);
        advance();
        // parse the tokens
        var expr = expression(0);
        if (node.id !== '(end)') {
            var err = {
                code: "S0201",
                position: node.position,
                token: node.value
            };
            handleError(err);
        }
        expr = ast_optimize(expr);

        if(errors.length > 0) {
            expr.errors = errors;
        }

        return expr;
    };

    // Start of Evaluator code

    var staticFrame = createFrame(null);

    /**
     * Check if value is a finite number
     * @param {float} n - number to evaluate
     * @returns {boolean} True if n is a finite number
     */
    function isNumeric(n) {
        var isNum = false;
        if(typeof n === 'number') {
            var num = parseFloat(n);
            isNum = !isNaN(num);
            if (isNum && !isFinite(num)) {
                throw {
                    code: "D1001",
                    value: n,
                    stack: (new Error()).stack
                };
            }
        }
        return isNum;
    }

    /**
     * Returns true if the arg is an array of strings
     * @param {*} arg - the item to test
     * @returns {boolean} True if arg is an array of strings
     */
    function isArrayOfStrings(arg) {
        var result = false;
        /* istanbul ignore else */
        if(Array.isArray(arg)) {
            result = (arg.filter(function(item){return typeof item !== 'string';}).length === 0);
        }
        return result;
    }

    /**
     * Returns true if the arg is an array of numbers
     * @param {*} arg - the item to test
     * @returns {boolean} True if arg is an array of numbers
     */
    function isArrayOfNumbers(arg) {
        var result = false;
        if(Array.isArray(arg)) {
            result = (arg.filter(function(item){return !isNumeric(item);}).length === 0);
        }
        return result;
    }

    // Polyfill
    /* istanbul ignore next */
    Number.isInteger = Number.isInteger || function(value) {
        return typeof value === "number" &&
          isFinite(value) &&
          Math.floor(value) === value;
    };

    /**
     * Evaluate expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluate(expr, input, environment) {
        var result;

        var entryCallback = environment.lookup('__evaluate_entry');
        if(entryCallback) {
            entryCallback(expr, input, environment);
        }

        switch (expr.type) {
            case 'path':
                result = yield * evaluatePath(expr.steps, input, environment);
                result = normalizeSequence(result, expr.keepSingletonArray);
                break;
            case 'binary':
                result = yield * evaluateBinary(expr, input, environment);
                break;
            case 'unary':
                result = yield * evaluateUnary(expr, input, environment);
                break;
            case 'name':
                result = evaluateName(expr, input, environment);
                break;
            case 'literal':
                result = evaluateLiteral(expr, input, environment);
                break;
            case 'wildcard':
                result = evaluateWildcard(expr, input, environment);
                break;
            case 'descendant':
                result = evaluateDescendants(expr, input, environment);
                break;
            case 'condition':
                result = yield * evaluateCondition(expr, input, environment);
                break;
            case 'block':
                result = yield * evaluateBlock(expr, input, environment);
                break;
            case 'bind':
                result = yield * evaluateBindExpression(expr, input, environment);
                break;
            case 'regex':
                result = evaluateRegex(expr, input, environment);
                break;
            case 'function':
                result = yield * evaluateFunction(expr, input, environment);
                break;
            case 'variable':
                result = evaluateVariable(expr, input, environment);
                break;
            case 'lambda':
                result = evaluateLambda(expr, input, environment);
                break;
            case 'partial':
                result = yield * evaluatePartialApplication(expr, input, environment);
                break;
            case 'apply':
                result = yield * evaluateApplyExpression(expr, input, environment);
                break;
            case 'sort':
                result = yield * evaluateSortExpression(expr, input, environment);
                break;
            case 'transform':
                result = evaluateTransformExpression(expr, input, environment);
                break;
        }

        if(environment.lookup('__jsonata_async') &&
          (typeof result === 'undefined' || result === null || typeof result.then !== 'function')) {
            result = Promise.resolve(result);
        }
        if(environment.lookup('__jsonata_async') && typeof result.then === 'function' && expr.nextFunction && typeof result[expr.nextFunction] === 'function') {
            // although this is a 'thenable', it is chaining a different function
            // so don't yield since yielding will trigger the .then()
        } else {
            result = yield result;
        }


        if (expr.hasOwnProperty('predicate')) {
            result = yield * applyPredicates(expr.predicate, result, environment);
            result = normalizeSequence(result);

        }
        if (expr.hasOwnProperty('group')) {
            result = yield * evaluateGroupExpression(expr.group, result, environment);
        }

        var exitCallback = environment.lookup('__evaluate_exit');
        if(exitCallback) {
            exitCallback(expr, input, environment, result);
        }

        return result;
    }

    /**
     * Evaluate path expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluatePath(expr, input, environment) {
        var inputSequence;
        // expr is an array of steps
        // if the first step is a variable reference ($...), including root reference ($$),
        //   then the path is absolute rather than relative
        if (expr[0].type === 'variable') {
            inputSequence = [input]; // dummy singleton sequence for first (absolute) step
        } else if (Array.isArray(input)) {
            inputSequence = input;
        } else {
            // if input is not an array, make it so
            inputSequence = [input];
        }

        var resultSequence;

        // evaluate each step in turn
        for(var ii = 0; ii < expr.length; ii++) {
            var step = expr[ii];

            // if the first step is an explicit array constructor, then just evaluate that (i.e. don't iterate over a context array)
            if(ii === 0 && step.consarray) {
                resultSequence = yield * evaluate(step, inputSequence, environment);
            } else {
                resultSequence = yield * evaluateStep(step, inputSequence, environment);
            }

            if(typeof resultSequence === 'undefined' || resultSequence.length === 0) {
                break;
            }
            inputSequence = resultSequence;
        }

        return resultSequence;
    }

    /**
     * Normalize a JSONata sequence - singleton arrays become atomic values
     * @param {Array} sequence - input sequence
     * @param {Boolean} keepSingleton - keep singleton sequences as arrays
     * @returns {*} normalized sequence
     */
    function normalizeSequence(sequence, keepSingleton) {
        var result;
        if(typeof sequence === 'undefined') {
            result = undefined;
        } else if(!Array.isArray(sequence)) {
            result = sequence;
        } else if (sequence.length === 1) {
            if(keepSingleton) {
                result = sequence;
            } else {
                result = sequence[0];
            }
        } else if (sequence.length > 1) {
            result = sequence;
        }
        return result;
    }

    /**
     * Evaluate a step within a path
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateStep(expr, input, environment) {
        var result = [];


        for(var ii = 0; ii < input.length; ii++) {
            var res = yield * evaluate(expr, input[ii], environment);
            if (!(Array.isArray(res) && (expr.value !== '[' )) && !expr.consarray) {
                res = [res];
            }
            // is res an array - if so, flatten it into the parent array
            res.forEach(function (innerRes) {
                if (typeof innerRes !== 'undefined') {
                    result.push(innerRes);
                }
            });
        }
        return result;
    }

    /**
     * Apply predicates to input data
     * @param {Object} predicates - Predicates
     * @param {Object} input - Input data to apply predicates against
     * @param {Object} environment - Environment
     * @returns {*} Result after applying predicates
     */
    function* applyPredicates(predicates, input, environment) {
        var inputSequence = input;
        // lhs potentially holds an array
        // we want to iterate over the array, and only keep the items that are
        // truthy when applied to the predicate.
        // if the predicate evaluates to an integer, then select that index

        var results = [];
        for(var ii = 0; ii < predicates.length; ii++) {
            var predicate = predicates[ii];
            // if it's not an array, turn it into one
            // since in XPath >= 2.0 an item is equivalent to a singleton sequence of that item
            // if input is not an array, make it so
            if (!Array.isArray(inputSequence)) {
                inputSequence = [inputSequence];
            }
            results = [];
            if (predicate.type === 'literal' && isNumeric(predicate.value)) {
                var index = predicate.value;
                if (!Number.isInteger(index)) {
                    // round it down
                    index = Math.floor(index);
                }
                if (index < 0) {
                    // count in from end of array
                    index = inputSequence.length + index;
                }
                results = inputSequence[index];
            } else {
                results = yield * evaluateFilter(predicate, inputSequence, environment);
            }
            inputSequence = results;
        }
        return results;
    }

    /**
     * Apply filter predicate to input data
     * @param {Object} predicate - filter expression
     * @param {Object} input - Input data to apply predicates against
     * @param {Object} environment - Environment
     * @returns {*} Result after applying predicates
     */
    function* evaluateFilter(predicate, input, environment) {
        var results = [];
        for(var index = 0; index < input.length; index++) {
            var item = input[index];
            var res = yield * evaluate(predicate, item, environment);
            if (isNumeric(res)) {
                res = [res];
            }
            if(isArrayOfNumbers(res)) {
                res.forEach(function(ires) {
                    if (!Number.isInteger(ires)) {
                        // round it down
                        ires = Math.floor(ires);
                    }
                    if (ires < 0) {
                        // count in from end of array
                        ires = input.length + ires;
                    }
                    if (ires === index) {
                        results.push(item);
                    }
                });
            } else if (functionBoolean(res)) { // truthy
                results.push(item);
            }
        }
        return results;
    }

    /**
     * Evaluate binary expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function * evaluateBinary(expr, input, environment) {
        var result;
        var lhs = yield * evaluate(expr.lhs, input, environment);
        var rhs = yield * evaluate(expr.rhs, input, environment);
        var op = expr.value;

        try {
            switch (op) {
                case '+':
                case '-':
                case '*':
                case '/':
                case '%':
                    result = evaluateNumericExpression(lhs, rhs, op);
                    break;
                case '=':
                case '!=':
                case '<':
                case '<=':
                case '>':
                case '>=':
                    result = evaluateComparisonExpression(lhs, rhs, op);
                    break;
                case '&':
                    result = evaluateStringConcat(lhs, rhs);
                    break;
                case 'and':
                case 'or':
                    result = evaluateBooleanExpression(lhs, rhs, op);
                    break;
                case '..':
                    result = evaluateRangeExpression(lhs, rhs);
                    break;
                case 'in':
                    result = evaluateIncludesExpression(lhs, rhs);
                    break;
            }
        } catch(err) {
            err.position = expr.position;
            err.token = op;
            throw err;
        }
        return result;
    }

    /**
     * Evaluate unary expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateUnary(expr, input, environment) {
        var result;

        switch (expr.value) {
            case '-':
                result = yield * evaluate(expr.expression, input, environment);
                if (isNumeric(result)) {
                    result = -result;
                } else {
                    throw {
                        code: "D1002",
                        stack: (new Error()).stack,
                        position: expr.position,
                        token: expr.value,
                        value: result
                    };
                }
                break;
            case '[':
                // array constructor - evaluate each item
                result = [];
                for(var ii = 0; ii < expr.expressions.length; ii++) {
                    var item = expr.expressions[ii];
                    var value = yield * evaluate(item, input, environment);
                    if (typeof value !== 'undefined') {
                        if(item.value === '[') {
                            result.push(value);
                        } else {
                            result = functionAppend(result, value);
                        }
                    }
                }
                break;
            case '{':
                // object constructor - apply grouping
                result = yield * evaluateGroupExpression(expr, input, environment);
                break;

        }
        return result;
    }

    /**
     * Evaluate name object against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function evaluateName(expr, input, environment) {
        // lookup the 'name' item in the input
        var result;
        if (Array.isArray(input)) {
            result = [];
            for(var ii = 0; ii < input.length; ii++) {
                var res =  evaluateName(expr, input[ii], environment);
                if (typeof res !== 'undefined') {
                    result.push(res);
                }
            }
        } else if (input !== null && typeof input === 'object') {
            result = input[expr.value];
        }
        result = normalizeSequence(result);
        return result;
    }

    /**
     * Evaluate literal against input data
     * @param {Object} expr - JSONata expression
     * @returns {*} Evaluated input data
     */
    function evaluateLiteral(expr) {
        return expr.value;
    }

    /**
     * Evaluate wildcard against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @returns {*} Evaluated input data
     */
    function evaluateWildcard(expr, input) {
        var result;
        var results = [];
        if (input !== null && typeof input === 'object') {
            Object.keys(input).forEach(function (key) {
                var value = input[key];
                if(Array.isArray(value)) {
                    value = flatten(value);
                    results = functionAppend(results, value);
                } else {
                    results.push(value);
                }
            });
        }

        result = normalizeSequence(results);
        return result;
    }

    /**
     * Returns a flattened array
     * @param {Array} arg - the array to be flatten
     * @param {Array} flattened - carries the flattened array - if not defined, will initialize to []
     * @returns {Array} - the flattened array
     */
    function flatten(arg, flattened) {
        if(typeof flattened === 'undefined') {
            flattened = [];
        }
        if(Array.isArray(arg)) {
            arg.forEach(function (item) {
                flatten(item, flattened);
            });
        } else {
            flattened.push(arg);
        }
        return flattened;
    }

    /**
     * Evaluate descendants against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @returns {*} Evaluated input data
     */
    function evaluateDescendants(expr, input) {
        var result;
        var resultSequence = [];
        if (typeof input !== 'undefined') {
            // traverse all descendants of this object/array
            recurseDescendants(input, resultSequence);
            if (resultSequence.length === 1) {
                result = resultSequence[0];
            } else {
                result = resultSequence;
            }
        }
        return result;
    }

    /**
     * Recurse through descendants
     * @param {Object} input - Input data
     * @param {Object} results - Results
     */
    function recurseDescendants(input, results) {
        // this is the equivalent of //* in XPath
        if (!Array.isArray(input)) {
            results.push(input);
        }
        if (Array.isArray(input)) {
            input.forEach(function (member) {
                recurseDescendants(member, results);
            });
        } else if (input !== null && typeof input === 'object') {
            Object.keys(input).forEach(function (key) {
                recurseDescendants(input[key], results);
            });
        }
    }

    /**
     * Evaluate numeric expression against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @param {Object} op - opcode
     * @returns {*} Result
     */
    function evaluateNumericExpression(lhs, rhs, op) {
        var result;

        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {
            // if either side is undefined, the result is undefined
            return result;
        }

        if (!isNumeric(lhs)) {
            throw {
                code: "T2001",
                stack: (new Error()).stack,
                value: lhs
            };
        }
        if (!isNumeric(rhs)) {
            throw {
                code: "T2002",
                stack: (new Error()).stack,
                value: rhs
            };
        }

        switch (op) {
            case '+':
                result = lhs + rhs;
                break;
            case '-':
                result = lhs - rhs;
                break;
            case '*':
                result = lhs * rhs;
                break;
            case '/':
                result = lhs / rhs;
                break;
            case '%':
                result = lhs % rhs;
                break;
        }
        return result;
    }

    /**
     * Evaluate comparison expression against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @param {Object} op - opcode
     * @returns {*} Result
     */
    function evaluateComparisonExpression(lhs, rhs, op) {
        var result;

        // type checks
        var ltype = typeof lhs;
        var rtype = typeof rhs;

        if (ltype === 'undefined' || rtype === 'undefined') {
            // if either side is undefined, the result is false
            return false;
        }

        var validate = function() {
            // if aa or bb are not string or numeric values, then throw an error
            if (!(ltype === 'string' || ltype === 'number') || !(rtype === 'string' || rtype === 'number')) {
                throw {
                    code: "T2010",
                    stack: (new Error()).stack,
                    value: !(ltype === 'string' || ltype === 'number') ? lhs : rhs
                };
            }

            //if aa and bb are not of the same type
            if (ltype !== rtype) {
                throw {
                    code: "T2009",
                    stack: (new Error()).stack,
                    value: lhs,
                    value2: rhs
                };
            }
        };

        switch (op) {
            case '=':
                result = lhs === rhs;
                break;
            case '!=':
                result = (lhs !== rhs);
                break;
            case '<':
                validate();
                result = lhs < rhs;
                break;
            case '<=':
                validate();
                result = lhs <= rhs;
                break;
            case '>':
                validate();
                result = lhs > rhs;
                break;
            case '>=':
                validate();
                result = lhs >= rhs;
                break;
        }
        return result;
    }

    /**
     * Inclusion operator - in
     *
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @returns {boolean} - true if lhs is a member of rhs
     */
    function evaluateIncludesExpression(lhs, rhs) {
        var result = false;

        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {
            // if either side is undefined, the result is false
            return false;
        }

        if(!Array.isArray(rhs)) {
            rhs = [rhs];
        }

        for(var i = 0; i < rhs.length; i++) {
            if(rhs[i] === lhs) {
                result = true;
                break;
            }
        }

        return result;
    }

    /**
     * Evaluate boolean expression against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @param {Object} op - opcode
     * @returns {*} Result
     */
    function evaluateBooleanExpression(lhs, rhs, op) {
        var result;

        switch (op) {
            case 'and':
                result = functionBoolean(lhs) && functionBoolean(rhs);
                break;
            case 'or':
                result = functionBoolean(lhs) || functionBoolean(rhs);
                break;
        }
        return result;
    }

    /**
     * Evaluate string concatenation against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @returns {string|*} Concatenated string
     */
    function evaluateStringConcat(lhs, rhs) {
        var result;

        var lstr = '';
        var rstr = '';
        if (typeof lhs !== 'undefined') {
            lstr = functionString(lhs);
        }
        if (typeof rhs !== 'undefined') {
            rstr = functionString(rhs);
        }

        result = lstr.concat(rstr);
        return result;
    }

    /**
     * Evaluate group expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {{}} Evaluated input data
     */
    function* evaluateGroupExpression(expr, input, environment) {
        var result = {};
        var groups = {};
        // group the input sequence by 'key' expression
        if (!Array.isArray(input)) {
            input = [input];
        }
        for(var itemIndex = 0; itemIndex < input.length; itemIndex++) {
            var item = input[itemIndex];
            for(var pairIndex = 0; pairIndex < expr.lhs.length; pairIndex++) {
                var pair = expr.lhs[pairIndex];
                var key = yield * evaluate(pair[0], item, environment);
                // key has to be a string
                if (typeof  key !== 'string') {
                    throw {
                        code: "T1003",
                        stack: (new Error()).stack,
                        position: expr.position,
                        value: key
                    };
                }
                var entry = {data: item, expr: pair[1]};
                if (groups.hasOwnProperty(key)) {
                    // a value already exists in this slot
                    // append it as an array
                    groups[key].data = functionAppend(groups[key].data, item);
                } else {
                    groups[key] = entry;
                }
            }
        }

        // iterate over the groups to evaluate the 'value' expression
        for (key in groups) {
            entry = groups[key];
            var value = yield * evaluate(entry.expr, entry.data, environment);
            if(typeof value !== 'undefined') {
                result[key] = value;
            }
        }

        return result;
    }

    /**
     * Evaluate range expression against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @returns {Array} Resultant array
     */
    function evaluateRangeExpression(lhs, rhs) {
        var result;

        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {
            // if either side is undefined, the result is undefined
            return result;
        }

        if (lhs > rhs) {
            // if the lhs is greater than the rhs, return undefined
            return result;
        }

        if (!Number.isInteger(lhs)) {
            throw {
                code: "T2003",
                stack: (new Error()).stack,
                value: lhs
            };
        }
        if (!Number.isInteger(rhs)) {
            throw {
                code: "T2004",
                stack: (new Error()).stack,
                value: rhs
            };
        }

        result = new Array(rhs - lhs + 1);
        for (var item = lhs, index = 0; item <= rhs; item++, index++) {
            result[index] = item;
        }
        return result;
    }

    /**
     * Evaluate bind expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateBindExpression(expr, input, environment) {
        // The RHS is the expression to evaluate
        // The LHS is the name of the variable to bind to - should be a VARIABLE token
        var value = yield * evaluate(expr.rhs, input, environment);
        if (expr.lhs.type !== 'variable') {
            throw {
                code: "D2005",
                stack: (new Error()).stack,
                position: expr.position,
                token: expr.value,
                value: expr.lhs.type === 'path' ? expr.lhs.steps[0].value : expr.lhs.value
            };
        }
        environment.bind(expr.lhs.value, value);
        return value;
    }

    /**
     * Evaluate condition against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateCondition(expr, input, environment) {
        var result;
        var condition = yield * evaluate(expr.condition, input, environment);
        if (functionBoolean(condition)) {
            result = yield * evaluate(expr.then, input, environment);
        } else if (typeof expr.else !== 'undefined') {
            result = yield * evaluate(expr.else, input, environment);
        }
        return result;
    }

    /**
     * Evaluate block against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateBlock(expr, input, environment) {
        var result;
        // create a new frame to limit the scope of variable assignments
        // TODO, only do this if the post-parse stage has flagged this as required
        var frame = createFrame(environment);
        // invoke each expression in turn
        // only return the result of the last one
        for(var ii = 0; ii < expr.expressions.length; ii++) {
            result = yield * evaluate(expr.expressions[ii], input, frame);
        }

        return result;
    }

    /**
     * Prepare a regex
     * @param {Object} expr - expression containing regex
     * @returns {Function} Higher order function representing prepared regex
     */
    function evaluateRegex(expr) {
        expr.value.lastIndex = 0;
        var closure = function(str) {
            var re = expr.value;
            var result;
            var match = re.exec(str);
            if(match !== null) {
                result = {
                    match: match[0],
                    start: match.index,
                    end: match.index + match[0].length,
                    groups: []
                };
                if(match.length > 1) {
                    for(var i = 1; i < match.length; i++) {
                        result.groups.push(match[i]);
                    }
                }
                result.next = function() {
                    if(re.lastIndex >= str.length) {
                        return undefined;
                    } else {
                        var next = closure(str);
                        if(next && next.match === '' && re.lastIndex === expr.value.lastIndex) {
                            // matches zero length string; this will never progress
                            throw {
                                code: "D1004",
                                stack: (new Error()).stack,
                                position: expr.position,
                                value: expr.value.source
                            };
                        }
                        return next;
                    }
                };
            }

            return result;
        };
        return closure;
    }

    /**
     * Evaluate variable against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function evaluateVariable(expr, input, environment) {
        // lookup the variable value in the environment
        var result;
        // if the variable name is empty string, then it refers to context value
        if (expr.value === '') {
            result = input;
        } else {
            result = environment.lookup(expr.value);
        }
        return result;
    }

    /**
     * sort / order-by operator
     * @param {Object} expr - AST for operator
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Ordered sequence
     */
    function* evaluateSortExpression(expr, input, environment) {
        var result;

        // evaluate the lhs, then sort the results in order according to rhs expression
        var lhs = yield * evaluate(expr.lhs, input, environment);

        // sort the lhs array
        // use comparator function
        var comparator = function(a, b) {
            // expr.rhs is an array of order-by in priority order
            var comp = 0;
            for(var index = 0; comp === 0 && index < expr.rhs.length; index++) {
                var term = expr.rhs[index];
                //evaluate the rhs expression in the context of a
                var aa = driveGenerator(term.expression, a, environment);
                //evaluate the rhs expression in the context of b
                var bb = driveGenerator(term.expression, b, environment);

                // type checks
                var atype = typeof aa;
                var btype = typeof bb;
                // undefined should be last in sort order
                if(atype === 'undefined') {
                    // swap them, unless btype is also undefined
                    comp = (btype === 'undefined') ? 0 : 1;
                    continue;
                }
                if(btype === 'undefined') {
                    comp = -1;
                    continue;
                }

                // if aa or bb are not string or numeric values, then throw an error
                if(!(atype === 'string' || atype === 'number') || !(btype === 'string' || btype === 'number')) {
                    throw {
                        code: "T2008",
                        stack: (new Error()).stack,
                        position: expr.position,
                        value: !(atype === 'string' || atype === 'number') ? aa : bb
                    };
                }

                //if aa and bb are not of the same type
                if(atype !== btype) {
                    throw {
                        code: "T2007",
                        stack: (new Error()).stack,
                        position: expr.position,
                        value: aa,
                        value2: bb
                    };
                }
                if(aa === bb) {
                    // both the same - move on to next term
                    continue;
                } else if (aa < bb) {
                    comp = -1;
                } else {
                    comp = 1;
                }
                if(term.descending === true) {
                    comp = -comp;
                }
            }
            // only swap a & b if comp equals 1
            return comp === 1;
        };

        result = functionSort(lhs, comparator);

        return result;
    }

    /**
     * create a transformer function
     * @param {Object} expr - AST for operator
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} tranformer function
     */
    function evaluateTransformExpression(expr, input, environment) {
        // create a function to implement the transform definition
        var transformer = function*(obj) { // signature <(oa):o>
            // undefined inputs always return undefined
            if(typeof obj === 'undefined') {
                return undefined;
            }

            // this function returns a copy of obj with changes specified by the pattern/operation
            var cloneFunction = environment.lookup('clone');
            if(!isFunction(cloneFunction)) {
                // throw type error
                throw {
                    code: "T2013",
                    stack: (new Error()).stack,
                    position: expr.position
                };
            }
            var result = yield * apply(cloneFunction, [obj], environment);
            var matches = yield * evaluate(expr.pattern, result, environment);
            if(typeof matches !== 'undefined') {
                if(!Array.isArray(matches)) {
                    matches = [matches];
                }
                for(var ii = 0; ii < matches.length; ii++) {
                    var match = matches[ii];
                    // evaluate the update value for each match
                    var update = yield * evaluate(expr.update, match, environment);
                    // update must be an object
                    var updateType = typeof update;
                    if(updateType !== 'undefined') {
                        if(updateType !== 'object' || update === null) {
                            // throw type error
                            throw {
                                code: "T2011",
                                stack: (new Error()).stack,
                                position: expr.update.position,
                                value: update
                            };
                        }
                        // merge the update
                        for(var prop in update) {
                            match[prop] = update[prop];
                        }
                    }

                    // delete, if specified, must be an array of strings (or single string)
                    if(typeof expr.delete !== 'undefined') {
                        var deletions = yield * evaluate(expr.delete, match, environment);
                        if(typeof deletions !== 'undefined') {
                            var val = deletions;
                            if (!Array.isArray(deletions)) {
                                deletions = [deletions];
                            }
                            if (!isArrayOfStrings(deletions)) {
                                // throw type error
                                throw {
                                    code: "T2012",
                                    stack: (new Error()).stack,
                                    position: expr.delete.position,
                                    value: val
                                };
                            }
                            for (var jj = 0; jj < deletions.length; jj++) {
                                delete match[deletions[jj]];
                            }
                        }
                    }
                }
            }

            return result;
        };

        return defineFunction(transformer, '<(oa):o>');
    }

    /**
     * Evaluate an expression by driving the generator to completion
     * Used when it's not possible to yield
     * @param {Object} expr - AST
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} result
     */
    function driveGenerator(expr, input, environment) {
        var gen = evaluate(expr, input, environment);
        // returns a generator - so iterate over it
        var comp = gen.next();
        while (!comp.done) {
            comp = gen.next(comp.value);
        }
        return comp.value;
    }

    var chain = driveGenerator(parser('function($f, $g) { function($x){ $g($f($x)) } }'), null, staticFrame);

    /**
     * Apply the function on the RHS using the sequence on the LHS as the first argument
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateApplyExpression(expr, input, environment) {
        var result;


        if(expr.rhs.type === 'function') {
            // this is a function _invocation_; invoke it with lhs expression as the first argument
            expr.rhs.arguments.unshift(expr.lhs);
            result = yield * evaluateFunction(expr.rhs, input, environment);
            expr.rhs.arguments.shift();
        } else {
            var lhs = yield * evaluate(expr.lhs, input, environment);
            var func = yield * evaluate(expr.rhs, input, environment);

            if(!isFunction(func)) {
                throw {
                    code: "T2006",
                    stack: (new Error()).stack,
                    position: expr.position,
                    value: func
                };
            }

            if(isFunction(lhs)) {
                // this is function chaining (func1 ~> func2)
                // λ($f, $g) { λ($x){ $g($f($x)) } }
                result = yield * apply(chain, [lhs, func], environment, null);
            } else {
                result = yield * apply(func, [lhs], environment, null);
            }

        }

        return result;
    }

    /**
     *
     * @param {Object} arg - expression to test
     * @returns {boolean} - true if it is a function (lambda or built-in)
     */
    function isFunction(arg) {
        return ((arg && (arg._jsonata_function === true || arg._jsonata_lambda === true)) || typeof arg === 'function');
    }

    /**
     * Tests whether arg is a lambda function
     * @param {*} arg - the value to test
     * @returns {boolean} - true if it is a lambda function
     */
    function isLambda(arg) {
        return arg && arg._jsonata_lambda === true;
    }

    /**
     * @param {Object} arg - expression to test
     * @returns {boolean} - true if it is a generator i.e. the result from calling a
     * generator function
     */
    function isGenerator(arg) {
        return (
            typeof arg === 'object' &&
            arg !== null &&
            Symbol.iterator in arg &&
            typeof arg[Symbol.iterator] === 'function' &&
            'next' in arg &&
            typeof arg.next === 'function'
        );
    }

    /**
     * Evaluate function against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @param {Object} [applyto] - LHS of ~> operator
     * @returns {*} Evaluated input data
     */
    function* evaluateFunction(expr, input, environment) {
        var result;

        // create the procedure
        // can't assume that expr.procedure is a lambda type directly
        // could be an expression that evaluates to a function (e.g. variable reference, parens expr etc.
        // evaluate it generically first, then check that it is a function.  Throw error if not.
        var proc = yield * evaluate(expr.procedure, input, environment);

        if (typeof proc === 'undefined' && expr.procedure.type === 'path' && environment.lookup(expr.procedure.steps[0].value)) {
            // help the user out here if they simply forgot the leading $
            throw {
                code: "T1005",
                stack: (new Error()).stack,
                position: expr.position,
                token: expr.procedure.steps[0].value
            };
        }

        var evaluatedArgs = [];
        // eager evaluation - evaluate the arguments
        for (var jj = 0; jj < expr.arguments.length; jj++) {
            // only evaluate 'eager' arguments at this stage; wrap the 'lazy' ones in a closure
            evaluatedArgs.push(yield* evaluate(expr.arguments[jj], input, environment));
        }
        // apply the procedure
        try {
            // if(input instanceof Object) {
            //     Object.defineProperty(input, '__env__', {
            //         enumerable: false,
            //         configurable: true,
            //         get: function () {
            //             return environment;
            //         }
            //     });
            // }
            result = yield * apply(proc, evaluatedArgs, input);
        } catch (err) {
            // add the position field to the error
            err.position = expr.position;
            // and the function identifier
            err.token = expr.procedure.type === 'path' ? expr.procedure.steps[0].value : expr.procedure.value;
            throw err;
        }
        return result;
    }

    /**
     * Apply procedure or function
     * @param {Object} proc - Procedure
     * @param {Array} args - Arguments
     * @param {Object} self - Self
     * @returns {*} Result of procedure
     */
    function* apply(proc, args, self) {
        var result;
        result = yield * applyInner(proc, args, self);
        while(isLambda(result) && result.thunk === true) {
            // trampoline loop - this gets invoked as a result of tail-call optimization
            // the function returned a tail-call thunk
            // unpack it, evaluate its arguments, and apply the tail call
            var next = yield * evaluate(result.body.procedure, result.input, result.environment);
            var evaluatedArgs = [];
            for(var ii = 0; ii < result.body.arguments.length; ii++) {
                evaluatedArgs.push(yield * evaluate(result.body.arguments[ii], result.input, result.environment));
            }

            result = yield * applyInner(next, evaluatedArgs, self);
        }
        return result;
    }

    /**
     * Apply procedure or function
     * @param {Object} proc - Procedure
     * @param {Array} args - Arguments
     * @param {Object} self - Self
     * @returns {*} Result of procedure
     */
    function* applyInner(proc, args, self) {
        var result;
        var validatedArgs = args;
        if(proc) {
            validatedArgs = validateArguments(proc.signature, args, self);
        }
        if (isLambda(proc)) {
            result = yield * applyProcedure(proc, validatedArgs);
        } else if (proc && proc._jsonata_function === true) {
            result = proc.implementation.apply(self, validatedArgs);
            // `proc.implementation` might be a generator function
            // and `result` might be a generator - if so, yield
            if(isGenerator(result)) {
                result = yield *result;
            }
        } else if (typeof proc === 'function') {
            result = proc.apply(self, validatedArgs);
            /* istanbul ignore next */
            if(isGenerator(result)) {
                result = yield *result;
            }
        } else {
            throw {
                code: "T1006",
                stack: (new Error()).stack
            };
        }
        return result;
    }

    /**
     * Evaluate lambda against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {{lambda: boolean, input: *, environment: *, arguments: *, body: *}} Evaluated input data
     */
    function evaluateLambda(expr, input, environment) {
        // make a function (closure)
        var procedure = {
            _jsonata_lambda: true,
            input: input,
            environment: environment,
            arguments: expr.arguments,
            signature: expr.signature,
            body: expr.body
        };
        if(expr.thunk === true) {
            procedure.thunk = true;
        }
        return procedure;
    }

    /**
     * Evaluate partial application
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluatePartialApplication(expr, input, environment) {
        // partially apply a function
        var result;
        // evaluate the arguments
        var evaluatedArgs = [];
        for(var ii = 0; ii < expr.arguments.length; ii++) {
            var arg = expr.arguments[ii];
            if (arg.type === 'operator' && arg.value === '?') {
                evaluatedArgs.push(arg);
            } else {
                evaluatedArgs.push(yield * evaluate(arg, input, environment));
            }
        }
        // lookup the procedure
        var proc = yield * evaluate(expr.procedure, input, environment);
        if (typeof proc === 'undefined' && expr.procedure.type === 'path' && environment.lookup(expr.procedure.steps[0].value)) {
            // help the user out here if they simply forgot the leading $
            throw {
                code: "T1007",
                stack: (new Error()).stack,
                position: expr.position,
                token: expr.procedure.steps[0].value
            };
        }
        if (isLambda(proc)) {
            result = partialApplyProcedure(proc, evaluatedArgs);
        } else if (proc && proc._jsonata_function === true) {
            result = partialApplyNativeFunction(proc.implementation, evaluatedArgs);
        } else if (typeof proc === 'function') {
            result = partialApplyNativeFunction(proc, evaluatedArgs);
        } else {
            throw {
                code: "T1008",
                stack: (new Error()).stack,
                position: expr.position,
                token: expr.procedure.type === 'path' ? expr.procedure.steps[0].value : expr.procedure.value
            };
        }
        return result;
    }

    /**
     * Validate the arguments against the signature validator (if it exists)
     * @param {Function} signature - validator function
     * @param {Array} args - function arguments
     * @param {*} context - context value
     * @returns {Array} - validated arguments
     */
    function validateArguments(signature, args, context) {
        if(typeof signature === 'undefined') {
            // nothing to validate
            return args;
        }
        var validatedArgs = signature.validate(args, context);
        return validatedArgs;
    }

    /**
     * Apply procedure
     * @param {Object} proc - Procedure
     * @param {Array} args - Arguments
     * @returns {*} Result of procedure
     */
    function* applyProcedure(proc, args) {
        var result;
        var env = createFrame(proc.environment);
        proc.arguments.forEach(function (param, index) {
            env.bind(param.value, args[index]);
        });
        if (typeof proc.body === 'function') {
            // this is a lambda that wraps a native function - generated by partially evaluating a native
            result = yield * applyNativeFunction(proc.body, env);
        } else {
            result = yield * evaluate(proc.body, proc.input, env);
        }
        return result;
    }

    /**
     * Partially apply procedure
     * @param {Object} proc - Procedure
     * @param {Array} args - Arguments
     * @returns {{lambda: boolean, input: *, environment: {bind, lookup}, arguments: Array, body: *}} Result of partially applied procedure
     */
    function partialApplyProcedure(proc, args) {
        // create a closure, bind the supplied parameters and return a function that takes the remaining (?) parameters
        var env = createFrame(proc.environment);
        var unboundArgs = [];
        proc.arguments.forEach(function (param, index) {
            var arg = args[index];
            if (arg && arg.type === 'operator' && arg.value === '?') {
                unboundArgs.push(param);
            } else {
                env.bind(param.value, arg);
            }
        });
        var procedure = {
            _jsonata_lambda: true,
            input: proc.input,
            environment: env,
            arguments: unboundArgs,
            body: proc.body
        };
        return procedure;
    }

    /**
     * Partially apply native function
     * @param {Function} native - Native function
     * @param {Array} args - Arguments
     * @returns {{lambda: boolean, input: *, environment: {bind, lookup}, arguments: Array, body: *}} Result of partially applying native function
     */
    function partialApplyNativeFunction(native, args) {
        // create a lambda function that wraps and invokes the native function
        // get the list of declared arguments from the native function
        // this has to be picked out from the toString() value
        var sigArgs = getNativeFunctionArguments(native);
        sigArgs = sigArgs.map(function (sigArg) {
            return '$' + sigArg.trim();
        });
        var body = 'function(' + sigArgs.join(', ') + '){ _ }';

        var bodyAST = parser(body);
        bodyAST.body = native;

        var partial = partialApplyProcedure(bodyAST, args);
        return partial;
    }

    /**
     * Apply native function
     * @param {Object} proc - Procedure
     * @param {Object} env - Environment
     * @returns {*} Result of applying native function
     */
    function* applyNativeFunction(proc, env) {
        var sigArgs = getNativeFunctionArguments(proc);
        // generate the array of arguments for invoking the function - look them up in the environment
        var args = sigArgs.map(function (sigArg) {
            return env.lookup(sigArg.trim());
        });

        var result = proc.apply(null, args);
        if(isGenerator(result)) {
            result = yield * result;
        }
        return result;
    }

    /**
     * Get native function arguments
     * @param {Function} func - Function
     * @returns {*|Array} Native function arguments
     */
    function getNativeFunctionArguments(func) {
        var signature = func.toString();
        var sigParens = /\(([^)]*)\)/.exec(signature)[1]; // the contents of the parens
        var sigArgs = sigParens.split(',');
        return sigArgs;
    }

    /**
     * Creates a function definition
     * @param {Function} func - function implementation in Javascript
     * @param {string} signature - JSONata function signature definition
     * @returns {{implementation: *, signature: *}} function definition
     */
    function defineFunction(func, signature) {
        var definition = {
            _jsonata_function: true,
            implementation: func
        };
        if(typeof signature !== 'undefined') {
            definition.signature = parseSignature(signature);
        }
        return definition;
    }

    /**
     * Sum function
     * @param {Object} args - Arguments
     * @returns {number} Total value of arguments
     */
    function functionSum(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined') {
            return undefined;
        }

        var total = 0;
        args.forEach(function(num){total += num;});
        return total;
    }

    /**
     * Count function
     * @param {Object} args - Arguments
     * @returns {number} Number of elements in the array
     */
    function functionCount(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined') {
            return 0;
        }

        return args.length;
    }

    /**
     * Max function
     * @param {Object} args - Arguments
     * @returns {number} Max element in the array
     */
    function functionMax(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined' || args.length === 0) {
            return undefined;
        }

        return Math.max.apply(Math, args);
    }

    /**
     * Min function
     * @param {Object} args - Arguments
     * @returns {number} Min element in the array
     */
    function functionMin(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined' || args.length === 0) {
            return undefined;
        }

        return Math.min.apply(Math, args);
    }

    /**
     * Average function
     * @param {Object} args - Arguments
     * @returns {number} Average element in the array
     */
    function functionAverage(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined' || args.length === 0) {
            return undefined;
        }

        var total = 0;
        args.forEach(function(num){total += num;});
        return total/args.length;
    }

    /**
     * Stingify arguments
     * @param {Object} arg - Arguments
     * @returns {String} String from arguments
     */
    function functionString(arg) {
        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        var str;

        if (typeof arg === 'string') {
            // already a string
            str = arg;
        } else if(isFunction(arg)) {
            // functions (built-in and lambda convert to empty string
            str = '';
        } else if (typeof arg === 'number' && !isFinite(arg)) {
            throw {
                code: "D3001",
                value: arg,
                stack: (new Error()).stack
            };
        } else
            str = JSON.stringify(arg, function (key, val) {
                return (typeof val !== 'undefined' && val !== null && val.toPrecision && isNumeric(val)) ? Number(val.toPrecision(13)) :
                    (val && isFunction(val)) ? '' : val;
            });
        return str;
    }

    /**
     * Create substring based on character number and length
     * @param {String} str - String to evaluate
     * @param {Integer} start - Character number to start substring
     * @param {Integer} [length] - Number of characters in substring
     * @returns {string|*} Substring
     */
    function functionSubstring(str, start, length) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        return str.substr(start, length);
    }

    /**
     * Create substring up until a character
     * @param {String} str - String to evaluate
     * @param {String} chars - Character to define substring boundary
     * @returns {*} Substring
     */
    function functionSubstringBefore(str, chars) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        var pos = str.indexOf(chars);
        if (pos > -1) {
            return str.substr(0, pos);
        } else {
            return str;
        }
    }

    /**
     * Create substring after a character
     * @param {String} str - String to evaluate
     * @param {String} chars - Character to define substring boundary
     * @returns {*} Substring
     */
    function functionSubstringAfter(str, chars) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        var pos = str.indexOf(chars);
        if (pos > -1) {
            return str.substr(pos + chars.length);
        } else {
            return str;
        }
    }

    /**
     * Lowercase a string
     * @param {String} str - String to evaluate
     * @returns {string} Lowercase string
     */
    function functionLowercase(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        return str.toLowerCase();
    }

    /**
     * Uppercase a string
     * @param {String} str - String to evaluate
     * @returns {string} Uppercase string
     */
    function functionUppercase(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        return str.toUpperCase();
    }

    /**
     * length of a string
     * @param {String} str - string
     * @returns {Number} The number of characters in the string
     */
    function functionLength(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        return str.length;
    }

    /**
     * Normalize and trim whitespace within a string
     * @param {string} str - string to be trimmed
     * @returns {string} - trimmed string
     */
    function functionTrim(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        // normalize whitespace
        var result = str.replace(/[ \t\n\r]+/gm, ' ');
        if(result.charAt(0) === ' ') {
            // strip leading space
            result = result.substring(1);
        }
        if(result.charAt(result.length - 1) === ' ') {
            // strip trailing space
            result = result.substring(0, result.length - 1);
        }
        return result;
    }

    /**
     * Pad a string to a minimum width by adding characters to the start or end
     * @param {string} str - string to be padded
     * @param {number} width - the minimum width; +ve pads to the right, -ve pads to the left
     * @param {string} [char] - the pad character(s); defaults to ' '
     * @returns {string} - padded string
     */
    function functionPad(str, width, char) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        if(typeof char === 'undefined' || char.length === 0) {
            char = ' ';
        }

        var result;
        var padLength = Math.abs(width) - str.length;
        if(padLength > 0) {
            var padding = (new Array(padLength + 1)).join(char);
            if(char.length > 1) {
                padding = padding.substring(0, padLength);
            }
            if(width > 0) {
                result = str + padding;
            } else {
                result = padding + str;
            }
        } else {
            result = str;
        }
        return result;
    }

    /**
     * Tests if the str contains the token
     * @param {String} str - string to test
     * @param {String} token - substring or regex to find
     * @returns {Boolean} - true if str contains token
     */
    function functionContains(str, token) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        var result;

        if(typeof token === 'string') {
            result = (str.indexOf(token) !== -1);
        } else {
            var matches = token(str);
            result = (typeof matches !== 'undefined');
        }

        return result;
    }

    /**
     * Match a string with a regex returning an array of object containing details of each match
     * @param {String} str - string
     * @param {String} regex - the regex applied to the string
     * @param {Integer} [limit] - max number of matches to return
     * @returns {Array} The array of match objects
     */
    function functionMatch(str, regex, limit) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        // limit, if specified, must be a non-negative number
        if(limit < 0) {
            throw {
                stack: (new Error()).stack,
                value: limit,
                code: 'D3040',
                index: 3
            };
        }

        var result = [];

        if(typeof limit === 'undefined' || limit > 0) {
            var count = 0;
            var matches = regex(str);
            if (typeof matches !== 'undefined') {
                while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {
                    result.push({
                        match: matches.match,
                        index: matches.start,
                        groups: matches.groups
                    });
                    matches = matches.next();
                    count++;
                }
            }
        }

        return result;
    }

    /**
     * Match a string with a regex returning an array of object containing details of each match
     * @param {String} str - string
     * @param {String} pattern - the substring/regex applied to the string
     * @param {String} replacement - text to replace the matched substrings
     * @param {Integer} [limit] - max number of matches to return
     * @returns {Array} The array of match objects
     */
    function* functionReplace(str, pattern, replacement, limit) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        // pattern cannot be an empty string
        if(pattern === '') {
            throw {
                code: "D3010",
                stack: (new Error()).stack,
                value: pattern,
                index: 2
            };
        }

        // limit, if specified, must be a non-negative number
        if(limit < 0) {
            throw {
                code: "D3011",
                stack: (new Error()).stack,
                value: limit,
                index: 4
            };
        }

        var replacer;
        if(typeof replacement === 'string') {
            replacer = function (regexMatch) {
                var substitute = '';
                // scan forward, copying the replacement text into the substitute string
                // and replace any occurrence of $n with the values matched by the regex
                var position = 0;
                var index = replacement.indexOf('$', position);
                while (index !== -1 && position < replacement.length) {
                    substitute += replacement.substring(position, index);
                    position = index + 1;
                    var dollarVal = replacement.charAt(position);
                    if (dollarVal === '$') {
                        // literal $
                        substitute += '$';
                        position++;
                    } else if (dollarVal === '0') {
                        substitute += regexMatch.match;
                        position++;
                    } else {
                        var maxDigits;
                        if(regexMatch.groups.length === 0) {
                            // no sub-matches; any $ followed by a digit will be replaced by an empty string
                            maxDigits = 1;
                        } else {
                            // max number of digits to parse following the $
                            maxDigits = Math.floor(Math.log(regexMatch.groups.length) * Math.LOG10E) + 1;
                        }
                        index = parseInt(replacement.substring(position, position + maxDigits), 10);
                        if(maxDigits > 1 && index > regexMatch.groups.length) {
                            index = parseInt(replacement.substring(position, position + maxDigits - 1), 10);
                        }
                        if (!isNaN(index)) {
                            if(regexMatch.groups.length > 0 ) {
                                var submatch = regexMatch.groups[index - 1];
                                if (typeof submatch !== 'undefined') {
                                    substitute += submatch;
                                }
                            }
                            position += index.toString().length;
                        } else {
                            // not a capture group, treat the $ as literal
                            substitute += '$';
                        }
                    }
                    index = replacement.indexOf('$', position);
                }
                substitute += replacement.substring(position);
                return substitute;
            };
        } else {
            replacer = replacement;
        }

        var result = '';
        var position = 0;

        if(typeof limit === 'undefined' || limit > 0) {
            var count = 0;
            if(typeof pattern === 'string') {
                var index = str.indexOf(pattern, position);
                while(index !== -1 && (typeof limit === 'undefined' || count < limit)) {
                    result += str.substring(position, index);
                    result += replacement;
                    position = index + pattern.length;
                    count++;
                    index = str.indexOf(pattern, position);
                }
                result += str.substring(position);
            } else {
                var matches = pattern(str);
                if (typeof matches !== 'undefined') {
                    while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {
                        result += str.substring(position, matches.start);
                        var replacedWith = yield * apply(replacer, [matches], null);
                        // check replacedWith is a string
                        if(typeof replacedWith === 'string') {
                            result += replacedWith;
                        } else {
                            // not a string - throw error
                            throw {
                                code: "D3012",
                                stack: (new Error()).stack,
                                value: replacedWith
                            };
                        }
                        position = matches.start + matches.match.length;
                        count++;
                        matches = matches.next();
                    }
                    result += str.substring(position);
                } else {
                    result = str;
                }
            }
        } else {
            result = str;
        }

        return result;
    }

    /**
     * Base64 encode a string
     * @param {String} str - string
     * @returns {String} Base 64 encoding of the binary data
     */
    function functionBase64encode(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }
        // Use btoa in a browser, or Buffer in Node.js

        var btoa = typeof window !== 'undefined' ?
            /* istanbul ignore next */ window.btoa :
            function(str) {
                // Simply doing `new Buffer` at this point causes Browserify to pull
                // in the entire Buffer browser library, which is large and unnecessary.
                // Using `global.Buffer` defeats this.
                return new global.Buffer(str, 'binary').toString('base64');
            };
        return btoa(str);
    }

    /**
     * Base64 decode a string
     * @param {String} str - string
     * @returns {String} Base 64 encoding of the binary data
     */
    function functionBase64decode(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }
        // Use btoa in a browser, or Buffer in Node.js
        var atob = typeof window !== 'undefined' ?
            /* istanbul ignore next */ window.atob :
            function(str) {
                // Simply doing `new Buffer` at this point causes Browserify to pull
                // in the entire Buffer browser library, which is large and unnecessary.
                // Using `global.Buffer` defeats this.
                return new global.Buffer(str, 'base64').toString('binary');
            };
        return atob(str);
    }

    /**
     * Split a string into an array of substrings
     * @param {String} str - string
     * @param {String} separator - the token or regex that splits the string
     * @param {Integer} [limit] - max number of substrings
     * @returns {Array} The array of string
     */
    function functionSplit(str, separator, limit) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        // limit, if specified, must be a non-negative number
        if(limit < 0) {
            throw {
                code: "D3020",
                stack: (new Error()).stack,
                value: limit,
                index: 3
            };
        }

        var result = [];

        if(typeof limit === 'undefined' || limit > 0) {
            if (typeof separator === 'string') {
                result = str.split(separator, limit);
            } else {
                var count = 0;
                var matches = separator(str);
                if (typeof matches !== 'undefined') {
                    var start = 0;
                    while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {
                        result.push(str.substring(start, matches.start));
                        start = matches.end;
                        matches = matches.next();
                        count++;
                    }
                    if(typeof limit === 'undefined' || count < limit) {
                        result.push(str.substring(start));
                    }
                } else {
                    result = [str];
                }
            }
        }

        return result;
    }

    /**
     * Join an array of strings
     * @param {Array} strs - array of string
     * @param {String} [separator] - the token that splits the string
     * @returns {String} The concatenated string
     */
    function functionJoin(strs, separator) {
        // undefined inputs always return undefined
        if(typeof strs === 'undefined') {
            return undefined;
        }

        // if separator is not specified, default to empty string
        if(typeof separator === 'undefined') {
            separator = "";
        }

        return strs.join(separator);
    }

    /**
     * Formats a number into a decimal string representation using XPath 3.1 F&O fn:format-number spec
     * @param {number} value - number to format
     * @param {String} picture - picture string definition
     * @param {Object} [options] - override locale defaults
     * @returns {String} The formatted string
     */
    function functionFormatNumber(value, picture, options) {
        var defaults = {
            "decimal-separator": ".",
            "grouping-separator": ",",
            "exponent-separator": "e",
            "infinity": "Infinity",
            "minus-sign": "-",
            "NaN": "NaN",
            "percent": "%",
            "per-mille": "\u2030",
            "zero-digit": "0",
            "digit": "#",
            "pattern-separator": ";"
        };

        // if `options` is specified, then its entries override defaults
        var properties = defaults;
        if(typeof options !== 'undefined') {
            Object.keys(options).forEach(function (key) {
                properties[key] = options[key];
            });
        }

        var decimalDigitFamily = [];
        var zeroCharCode = properties['zero-digit'].charCodeAt(0);
        for(var ii = zeroCharCode; ii < zeroCharCode + 10; ii++) {
            decimalDigitFamily.push(String.fromCharCode(ii));
        }

        var activeChars = decimalDigitFamily.concat([properties['decimal-separator'], properties['exponent-separator'], properties['grouping-separator'], properties.digit, properties['pattern-separator']]);

        var subPictures = picture.split(properties['pattern-separator']);

        if(subPictures.length > 2) {
            throw {
                code: 'D3080',
                stack: (new Error()).stack
            };
        }

        var splitParts = function(subpicture) {
            var prefix = (function() {
                var ch;
                for(var ii = 0; ii < subpicture.length; ii++) {
                    ch = subpicture.charAt(ii);
                    if(activeChars.indexOf(ch) !== -1 && ch !== properties['exponent-separator']) {
                        return subpicture.substring(0, ii);
                    }
                }
            })();
            var suffix = (function() {
                var ch;
                for(var ii = subpicture.length - 1; ii >= 0; ii--) {
                    ch = subpicture.charAt(ii);
                    if(activeChars.indexOf(ch) !== -1 && ch !== properties['exponent-separator']) {
                        return subpicture.substring(ii + 1);
                    }
                }
            })();
            var activePart = subpicture.substring(prefix.length, subpicture.length - suffix.length);
            var mantissaPart, exponentPart, integerPart, fractionalPart;
            var exponentPosition = subpicture.indexOf(properties['exponent-separator'], prefix.length);
            if(exponentPosition === -1 || exponentPosition > subpicture.length - suffix.length) {
                mantissaPart = activePart;
                exponentPart = undefined;
            } else {
                mantissaPart = activePart.substring(0, exponentPosition);
                exponentPart = activePart.substring(exponentPosition + 1);
            }
            var decimalPosition = mantissaPart.indexOf(properties['decimal-separator']);
            if(decimalPosition === -1) {
                integerPart = mantissaPart;
                fractionalPart = suffix;
            } else {
                integerPart = mantissaPart.substring(0, decimalPosition);
                fractionalPart = mantissaPart.substring(decimalPosition + 1);
            }
            return {
                prefix: prefix,
                suffix: suffix,
                activePart: activePart,
                mantissaPart: mantissaPart,
                exponentPart: exponentPart,
                integerPart: integerPart,
                fractionalPart: fractionalPart,
                subpicture: subpicture
            };
        };

        // validate the picture string, F&O 4.7.3
        var validate = function(parts) {
            var error;
            var ii;
            var subpicture = parts.subpicture;
            var decimalPos = subpicture.indexOf(properties['decimal-separator']);
            if(decimalPos !== subpicture.lastIndexOf(properties['decimal-separator'])) {
                error = 'D3081';
            }
            if(subpicture.indexOf(properties.percent) !== subpicture.lastIndexOf(properties.percent)) {
                error = 'D3082';
            }
            if(subpicture.indexOf(properties['per-mille']) !== subpicture.lastIndexOf(properties['per-mille'])) {
                error = 'D3083';
            }
            if(subpicture.indexOf(properties.percent) !== -1 && subpicture.indexOf(properties['per-mille']) !== -1) {
                error = 'D3084';
            }
            var valid = false;
            for(ii = 0; ii < parts.mantissaPart.length; ii++) {
                var ch = parts.mantissaPart.charAt(ii);
                if(decimalDigitFamily.indexOf(ch) !== -1 || ch === properties.digit) {
                    valid = true;
                    break;
                }
            }
            if(!valid) {
                error = 'D3085';
            }
            var charTypes = parts.activePart.split('').map(function(char) {
                return activeChars.indexOf(char) === -1 ? 'p' : 'a';
            }).join('');
            if(charTypes.indexOf('p') !== -1) {
                error = 'D3086';
            }
            if(decimalPos !== -1) {
                if(subpicture.charAt(decimalPos - 1) === properties['grouping-separator'] || subpicture.charAt(decimalPos + 1) === properties['grouping-separator']) {
                    error = 'D3087';
                }
            } else if(parts.integerPart.charAt(parts.integerPart.length - 1) === properties['grouping-separator']) {
                error = 'D3088';
            }
            if(subpicture.indexOf(properties['grouping-separator'] + properties['grouping-separator']) !== -1) {
                error = 'D3089';
            }
            var optionalDigitPos = parts.integerPart.indexOf(properties.digit);
            if(optionalDigitPos !== -1 && parts.integerPart.substring(0, optionalDigitPos).split('').filter(function(char) {
                return decimalDigitFamily.indexOf(char) > -1;
            }).length > 0) {
                error = 'D3090';
            }
            optionalDigitPos = parts.fractionalPart.lastIndexOf(properties.digit);
            if(optionalDigitPos !== -1 && parts.fractionalPart.substring(optionalDigitPos).split('').filter(function(char) {
                return decimalDigitFamily.indexOf(char) > -1;
            }).length > 0) {
                error = 'D3091';
            }
            var exponentExists = (typeof parts.exponentPart === 'string');
            if(exponentExists && parts.exponentPart.length > 0 && (subpicture.indexOf(properties.percent) !== -1 || subpicture.indexOf(properties['per-mille']) !== -1)) {
                error = 'D3092';
            }
            if(exponentExists && (parts.exponentPart.length === 0 || parts.exponentPart.split('').filter(function(char) {
                return decimalDigitFamily.indexOf(char) === -1;
            }).length > 0)) {
                error = 'D3093';
            }
            if(error) {
                throw {
                    code: error,
                    stack: (new Error()).stack
                };
            }
        };

        // analyse the picture string, F&O 4.7.4
        var analyse = function(parts) {
            var getGroupingPositions = function(part, toLeft) {
                var positions = [];
                var groupingPosition = part.indexOf(properties['grouping-separator']);
                while(groupingPosition !== -1) {
                    var charsToTheRight = (toLeft ? part.substring(0, groupingPosition) : part.substring(groupingPosition)).split('').filter(function(char) {
                        return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit;
                    }).length;
                    positions.push(charsToTheRight);
                    groupingPosition = parts.integerPart.indexOf(properties['grouping-separator'], groupingPosition + 1);
                }
                return positions;
            };
            var integerPartGroupingPositions = getGroupingPositions(parts.integerPart);
            var regular = function(indexes) {
                // are the grouping positions regular? i.e. same interval between each of them
                if(indexes.length === 0) {
                    return 0;
                }
                var gcd = function(a, b) {
                    return b === 0 ? a : gcd(b, a % b);
                };
                // find the greatest common divisor of all the positions
                var factor = indexes.reduce(gcd);
                // is every position separated by this divisor? If so, it's regular
                for(var index = 1; index <= indexes.length; index++) {
                    if(indexes.indexOf(index * factor) === -1) {
                        return 0;
                    }
                }
                return factor;
            };

            var regularGrouping = regular(integerPartGroupingPositions);
            var fractionalPartGroupingPositions = getGroupingPositions(parts.fractionalPart, true);

            var minimumIntegerPartSize = parts.integerPart.split('').filter(function(char) { return decimalDigitFamily.indexOf(char) !== -1; }).length;
            var scalingFactor = minimumIntegerPartSize;

            var fractionalPartArray = parts.fractionalPart.split('');
            var minimumFactionalPartSize = fractionalPartArray.filter(function(char) { return decimalDigitFamily.indexOf(char) !== -1; }).length;
            var maximumFactionalPartSize = fractionalPartArray.filter(function(char) { return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit; }).length;
            var exponentPresent = typeof parts.exponentPart === 'string';
            if(minimumIntegerPartSize === 0 && maximumFactionalPartSize === 0) {
                if(exponentPresent) {
                    minimumFactionalPartSize = 1;
                    maximumFactionalPartSize = 1;
                } else {
                    minimumIntegerPartSize = 1;
                }
            }
            if(exponentPresent && minimumIntegerPartSize === 0 && parts.integerPart.indexOf(properties.digit) !== -1) {
                minimumIntegerPartSize = 1;
            }
            if(minimumIntegerPartSize === 0 && minimumFactionalPartSize === 0) {
                minimumFactionalPartSize = 1;
            }
            var minimumExponentSize = 0;
            if(exponentPresent) {
                minimumExponentSize = parts.exponentPart.split('').filter(function(char) { return decimalDigitFamily.indexOf(char) !== -1; }).length;
            }

            return {
                integerPartGroupingPositions: integerPartGroupingPositions,
                regularGrouping: regularGrouping,
                minimumIntegerPartSize: minimumIntegerPartSize,
                scalingFactor: scalingFactor,
                prefix: parts.prefix,
                fractionalPartGroupingPositions: fractionalPartGroupingPositions,
                minimumFactionalPartSize: minimumFactionalPartSize,
                maximumFactionalPartSize: maximumFactionalPartSize,
                minimumExponentSize: minimumExponentSize,
                suffix: parts.suffix,
                picture: parts.subpicture
            };
        };

        var parts = subPictures.map(splitParts);
        parts.forEach(validate);

        var variables = parts.map(analyse);

        if(variables.length === 1) {
            variables.push(JSON.parse(JSON.stringify(variables[0])));
            variables[1].prefix = properties['minus-sign'] + variables[1].prefix;
        }

        // TODO cache the result of the analysis

        // format the number
        // bullet 1: TODO: NaN - not sure we'd ever get this in JSON
        var pic;
        // bullet 2:
        if(value >= 0) {
            pic = variables[0];
        } else {
            pic = variables[1];
        }
        var adjustedNumber;
        // bullet 3:
        if(pic.picture.indexOf(properties.percent) !== -1) {
            adjustedNumber = value * 100;
        } else if(pic.picture.indexOf(properties['per-mille']) !== -1) {
            adjustedNumber = value * 1000;
        } else {
            adjustedNumber = value;
        }
        // bullet 4:
        // TODO: infinity - not sure we'd ever get this in JSON
        // bullet 5:
        var mantissa, exponent;
        if(pic.minimumExponentSize === 0) {
            mantissa = adjustedNumber;
        } else {
            // mantissa * 10^exponent = adjustedNumber
            var maxMantissa = Math.pow(10, pic.scalingFactor);
            var minMantissa = Math.pow(10, pic.scalingFactor - 1);
            mantissa = adjustedNumber;
            exponent = 0;
            while(mantissa < minMantissa) {
                mantissa *= 10;
                exponent -= 1;
            }
            while(mantissa > maxMantissa) {
                mantissa /= 10;
                exponent += 1;
            }
        }
        // bullet 6:
        var roundedNumber = functionRound(mantissa, pic.maximumFactionalPartSize);
        // bullet 7:
        var makeString = function(value, dp) {
            var str = Math.abs(value).toFixed(dp);
            if (properties['zero-digit'] !== '0') {
                str = str.split('').map(function (digit) {
                    if(digit >= '0' && digit <='9') {
                        return decimalDigitFamily[digit.charCodeAt(0) - 48];
                    } else {
                        return digit;
                    }
                }).join('');
            }
            return str;
        };
        var stringValue = makeString(roundedNumber, pic.maximumFactionalPartSize);
        var decimalPos = stringValue.indexOf('.');
        if(decimalPos === -1) {
            stringValue = stringValue + properties['decimal-separator'];
        } else {
            stringValue = stringValue.replace('.', properties['decimal-separator']);
        }
        while(stringValue.charAt(0) === properties['zero-digit']) {
            stringValue = stringValue.substring(1);
        }
        while(stringValue.charAt(stringValue.length - 1) === properties['zero-digit']) {
            stringValue = stringValue.substring(0, stringValue.length - 1);
        }
        // bullets 8 & 9:
        decimalPos = stringValue.indexOf(properties['decimal-separator']);
        var padLeft = pic.minimumIntegerPartSize - decimalPos;
        var padRight = pic.minimumFactionalPartSize - (stringValue.length - decimalPos - 1);
        stringValue = (padLeft > 0 ? new Array(padLeft + 1).join('0') : '') + stringValue;
        stringValue = stringValue + (padRight > 0 ? new Array(padRight + 1).join('0') : '');
        decimalPos = stringValue.indexOf(properties['decimal-separator']);
        // bullet 10:
        if(pic.regularGrouping > 0) {
            var groupCount = Math.floor((decimalPos - 1) / pic.regularGrouping);
            for(var group = 1; group <= groupCount; group++) {
                stringValue = [stringValue.slice(0, decimalPos - group * pic.regularGrouping), properties['grouping-separator'], stringValue.slice(decimalPos - group * pic.regularGrouping)].join('');
            }
        } else {
            pic.integerPartGroupingPositions.forEach(function (pos) {
                stringValue = [stringValue.slice(0, decimalPos - pos), properties['grouping-separator'], stringValue.slice(decimalPos - pos)].join('');
                decimalPos++;
            });
        }
        // bullet 11:
        decimalPos = stringValue.indexOf(properties['decimal-separator']);
        pic.fractionalPartGroupingPositions.forEach(function(pos) {
            stringValue = [stringValue.slice(0, pos + decimalPos + 1), properties['grouping-separator'], stringValue.slice(pos + decimalPos + 1)].join('');
        });
        // bullet 12:
        decimalPos = stringValue.indexOf(properties['decimal-separator']);
        if(pic.picture.indexOf(properties['decimal-separator']) === -1 || decimalPos === stringValue.length - 1) {
            stringValue = stringValue.substring(0, stringValue.length - 1);
        }
        // bullet 13:
        if(typeof exponent !== 'undefined') {
            var stringExponent = makeString(exponent, 0);
            padLeft = pic.minimumExponentSize - stringExponent.length;
            if(padLeft > 0) {
                stringExponent = new Array(padLeft + 1).join('0') + stringExponent;
            }
            stringValue = stringValue + properties['exponent-separator'] + (exponent < 0 ? properties['minus-sign'] : '') + stringExponent;
        }
        // bullet 14:
        stringValue = pic.prefix + stringValue + pic.suffix;
        return stringValue;
    }

    /**
     * Converts a number to a string using a specified number base
     * @param {string} value - the number to convert
     * @param {number} [radix] - the number base; must be between 2 and 36. Defaults to 10
     * @returns {string} - the converted string
     */
    function functionFormatBase(value, radix) {
        // undefined inputs always return undefined
        if(typeof value === 'undefined') {
            return undefined;
        }

        value = functionRound(value);

        if(typeof radix === 'undefined') {
            radix = 10;
        } else {
            radix = functionRound(radix);
        }

        if(radix < 2 || radix > 36) {
            throw {
                code: 'D3100',
                stack: (new Error()).stack,
                value: radix
            };

        }

        var result = value.toString(radix);

        return result;
    }

    /**
     * Cast argument to number
     * @param {Object} arg - Argument
     * @returns {Number} numeric value of argument
     */
    function functionNumber(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        if (typeof arg === 'number') {
            // already a number
            result = arg;
        } else if(typeof arg === 'string' && /^-?(0|([1-9][0-9]*))(\.[0-9]+)?([Ee][-+]?[0-9]+)?$/.test(arg) && !isNaN(parseFloat(arg)) && isFinite(arg)) {
            result = parseFloat(arg);
        } else {
            throw {
                code: "D3030",
                value: arg,
                stack: (new Error()).stack,
                index: 1
            };
        }
        return result;
    }

    /**
     * Absolute value of a number
     * @param {Number} arg - Argument
     * @returns {Number} absolute value of argument
     */
    function functionAbs(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        result = Math.abs(arg);
        return result;
    }

    /**
     * Rounds a number down to integer
     * @param {Number} arg - Argument
     * @returns {Number} rounded integer
     */
    function functionFloor(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        result = Math.floor(arg);
        return result;
    }

    /**
     * Rounds a number up to integer
     * @param {Number} arg - Argument
     * @returns {Number} rounded integer
     */
    function functionCeil(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        result = Math.ceil(arg);
        return result;
    }

    /**
     * Round to half even
     * @param {Number} arg - Argument
     * @param {Number} precision - number of decimal places
     * @returns {Number} rounded integer
     */
    function functionRound(arg, precision) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        if(precision) {
            // shift the decimal place - this needs to be done in a string since multiplying
            // by a power of ten can introduce floating point precision errors which mess up
            // this rounding algorithm - See 'Decimal rounding' in
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round
            // Shift
            var value = arg.toString().split('e');
            arg = +(value[0] + 'e' + (value[1] ? (+value[1] + precision) : precision));

        }

        // round up to nearest int
        result = Math.round(arg);
        var diff = result - arg;
        if(Math.abs(diff) === 0.5 && Math.abs(result % 2) === 1) {
            // rounded the wrong way - adjust to nearest even number
            result = result - 1;
        }
        if(precision) {
            // Shift back
            value = result.toString().split('e');
            /* istanbul ignore next */
            result = +(value[0] + 'e' + (value[1] ? (+value[1] - precision) : -precision));
        }
        if(Object.is(result, -0)) { // ESLint rule 'no-compare-neg-zero' suggests this way
            // JSON doesn't do -0
            result = 0;
        }
        return result;
    }

    /**
     * Square root of number
     * @param {Number} arg - Argument
     * @returns {Number} square root
     */
    function functionSqrt(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        if(arg < 0) {
            throw {
                stack: (new Error()).stack,
                code: "D3060",
                index: 1,
                value: arg
            };
        }

        result = Math.sqrt(arg);

        return result;
    }

    /**
     * Raises number to the power of the second number
     * @param {Number} arg - the base
     * @param {Number} exp - the exponent
     * @returns {Number} rounded integer
     */
    function functionPower(arg, exp) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        result = Math.pow(arg, exp);

        if(!isFinite(result)) {
            throw {
                stack: (new Error()).stack,
                code: "D3061",
                index: 1,
                value: arg,
                exp: exp
            };
        }

        return result;
    }

    /**
     * Returns a random number 0 <= n < 1
     * @returns {number} random number
     */
    function functionRandom() {
        return Math.random();
    }

    /**
     * Evaluate an input and return a boolean
     * @param {*} arg - Arguments
     * @returns {boolean} Boolean
     */
    function functionBoolean(arg) {
        // cast arg to its effective boolean value
        // boolean: unchanged
        // string: zero-length -> false; otherwise -> true
        // number: 0 -> false; otherwise -> true
        // null -> false
        // array: empty -> false; length > 1 -> true
        // object: empty -> false; non-empty -> true
        // function -> false

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        var result = false;
        if (Array.isArray(arg)) {
            if (arg.length === 1) {
                result = functionBoolean(arg[0]);
            } else if (arg.length > 1) {
                var trues = arg.filter(function(val) {return functionBoolean(val);});
                result = trues.length > 0;
            }
        } else if (typeof arg === 'string') {
            if (arg.length > 0) {
                result = true;
            }
        } else if (isNumeric(arg)) {
            if (arg !== 0) {
                result = true;
            }
        } else if (arg !== null && typeof arg === 'object') {
            if (Object.keys(arg).length > 0) {
                // make sure it's not a lambda function
                if (!(isLambda(arg) || arg._jsonata_function)) {
                    result = true;
                }
            }
        } else if (typeof arg === 'boolean' && arg === true) {
            result = true;
        }
        return result;
    }

    /**
     * returns the Boolean NOT of the arg
     * @param {*} arg - argument
     * @returns {boolean} - NOT arg
     */
    function functionNot(arg) {
        return !functionBoolean(arg);
    }

    /**
     * Create a map from an array of arguments
     * @param {Array} [arr] - array to map over
     * @param {Function} func - function to apply
     * @returns {Array} Map array
     */
    function* functionMap(arr, func) {
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        var result = [];
        // do the map - iterate over the arrays, and invoke func
        for (var i = 0; i < arr.length; i++) {
            var func_args = [arr[i]]; // the first arg (value) is required
            // the other two are optional - only supply it if the function can take it
            var length = typeof func === 'function' ? func.length :
                func._jsonata_function === true ? func.implementation.length : func.arguments.length;
            if(length >= 2) {
                func_args.push(i);
            }
            if(length >= 3) {
                func_args.push(arr);
            }
            // invoke func
            var res = yield * apply(func, func_args, null);
            if(typeof res !== 'undefined') {
                result.push(res);
            }
        }

        return result;
    }

    // This generator function does not have a yield(), presumably to make it
    // consistent with other similar functions.
    /**
     * Create a map from an array of arguments
     * @param {Array} [arr] - array to filter
     * @param {Function} func - predicate function
     * @returns {Array} Map array
     */
    function* functionFilter(arr, func) { // eslint-disable-line require-yield
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        var result = [];

        var predicate = function (value, index, array) {
            var it = apply(func, [value, index, array], null);
            // returns a generator - so iterate over it
            var res = it.next();
            while (!res.done) {
                res = it.next(res.value);
            }
            return res.value;
        };

        for(var i = 0; i < arr.length; i++) {
            var entry = arr[i];
            if(functionBoolean(predicate(entry, i, arr))) {
                result.push(entry);
            }
        }

        return result;
    }

    /**
     * Convolves (zips) each value from a set of arrays
     * @param {Array} [args] - arrays to zip
     * @returns {Array} Zipped array
     */
    function functionZip() {
        // this can take a variable number of arguments
        var result = [];
        var args = Array.prototype.slice.call(arguments);
        // length of the shortest array
        var length = Math.min.apply(Math, args.map(function(arg) {
            if(Array.isArray(arg)) {
                return arg.length;
            }
            return 0;
        }));
        for(var i = 0; i < length; i++) {
            var tuple = args.map((arg) => {return arg[i];});
            result.push(tuple);
        }
        return result;
    }

    /**
     * Fold left function
     * @param {Array} sequence - Sequence
     * @param {Function} func - Function
     * @param {Object} init - Initial value
     * @returns {*} Result
     */
    function* functionFoldLeft(sequence, func, init) {
        // undefined inputs always return undefined
        if(typeof sequence === 'undefined') {
            return undefined;
        }

        var result;

        if (!(func.length === 2 || (func._jsonata_function === true && func.implementation.length === 2) || func.arguments.length === 2)) {
            throw {
                stack: (new Error()).stack,
                code: "D3050",
                index: 1
            };
        }

        var index;
        if (typeof init === 'undefined' && sequence.length > 0) {
            result = sequence[0];
            index = 1;
        } else {
            result = init;
            index = 0;
        }

        while (index < sequence.length) {
            result = yield * apply(func, [result, sequence[index]], null);
            index++;
        }

        return result;
    }

    /**
     * Return keys for an object
     * @param {Object} arg - Object
     * @returns {Array} Array of keys
     */
    function functionKeys(arg) {
        var result = [];

        if(Array.isArray(arg)) {
            // merge the keys of all of the items in the array
            var merge = {};
            arg.forEach(function(item) {
                var keys = functionKeys(item);
                if(Array.isArray(keys)) {
                    keys.forEach(function(key) {
                        merge[key] = true;
                    });
                }
            });
            result = functionKeys(merge);
        } else if(arg !== null && typeof arg === 'object' && !(isLambda(arg))) {
            result = Object.keys(arg);
            if(result.length === 0) {
                result = undefined;
            }
        } else {
            result = undefined;
        }
        return result;
    }

    /**
     * Return value from an object for a given key
     * @param {Object} object - Object
     * @param {String} key - Key in object
     * @returns {*} Value of key in object
     */
    function functionLookup(object, key) {
        var result = evaluateName({value: key}, object);
        return result;
    }

    /**
     * Append second argument to first
     * @param {Array|Object} arg1 - First argument
     * @param {Array|Object} arg2 - Second argument
     * @returns {*} Appended arguments
     */
    function functionAppend(arg1, arg2) {
        // disregard undefined args
        if (typeof arg1 === 'undefined') {
            return arg2;
        }
        if (typeof arg2 === 'undefined') {
            return arg1;
        }
        // if either argument is not an array, make it so
        if (!Array.isArray(arg1)) {
            arg1 = [arg1];
        }
        if (!Array.isArray(arg2)) {
            arg2 = [arg2];
        }
        Array.prototype.push.apply(arg1, arg2);
        return arg1;
    }

    /**
     * Determines if the argument is undefined
     * @param {*} arg - argument
     * @returns {boolean} False if argument undefined, otherwise true
     */
    function functionExists(arg){
        if (typeof arg === 'undefined') {
            return false;
        } else {
            return true;
        }
    }

    /**
     * Splits an object into an array of object with one property each
     * @param {*} arg - the object to split
     * @returns {*} - the array
     */
    function functionSpread(arg) {
        var result = [];

        if(Array.isArray(arg)) {
            // spread all of the items in the array
            arg.forEach(function(item) {
                result = functionAppend(result, functionSpread(item));
            });
        } else if(arg !== null && typeof arg === 'object' && !isLambda(arg)) {
            for(var key in arg) {
                var obj = {};
                obj[key] = arg[key];
                result.push(obj);
            }
        } else {
            result = arg;
        }
        return result;
    }

    /**
     * Merges an array of objects into a single object.  Duplicate properties are
     * overridden by entries later in the array
     * @param {*} arg - the objects to merge
     * @returns {*} - the object
     */
    function functionMerge(arg) {
        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        var result = {};

        arg.forEach(function(obj) {
            for(var prop in obj) {
                result[prop] = obj[prop];
            }
        });
        return result;
    }

    /**
     * Reverses the order of items in an array
     * @param {Array} arr - the array to reverse
     * @returns {Array} - the reversed array
     */
    function functionReverse(arr) {
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        if(arr.length <= 1) {
            return arr;
        }

        var length = arr.length;
        var result = new Array(length);
        for(var i = 0; i < length; i++) {
            result[length - i - 1] = arr[i];
        }

        return result;
    }

    /**
     *
     * @param {*} obj - the input object to iterate over
     * @param {*} func - the function to apply to each key/value pair
     * @returns {Array} - the resultant array
     */
    function* functionEach(obj, func) {
        var result = [];

        for(var key in obj) {
            var func_args = [obj[key], key];
            // invoke func
            result.push(yield * apply(func, func_args, null));
        }

        return result;
    }

    /**
     * Implements the merge sort (stable) with optional comparator function
     *
     * @param {Array} arr - the array to sort
     * @param {*} comparator - comparator function
     * @returns {Array} - sorted array
     */
    function functionSort(arr, comparator) {
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        if(arr.length <= 1) {
            return arr;
        }

        var comp;
        if(typeof comparator === 'undefined') {
            // inject a default comparator - only works for numeric or string arrays
            if (!isArrayOfNumbers(arr) && !isArrayOfStrings(arr)) {
                throw {
                    stack: (new Error()).stack,
                    code: "D3070",
                    index: 1
                };
            }

            comp = function (a, b) {
                return a > b;
            };
        } else if(typeof comparator === 'function') {
            // for internal usage of functionSort (i.e. order-by syntax)
            comp = comparator;
        } else {
            comp = function (a, b) {
                var it = apply(comparator, [a, b], null);
                // returns a generator - so iterate over it
                var comp = it.next();
                while (!comp.done) {
                    comp = it.next(comp.value);
                }
                return comp.value;
            };
        }

        var merge = function(l, r) {
            var merge_iter = function(result, left, right) {
                if (left.length === 0) {
                    Array.prototype.push.apply(result, right);
                } else if (right.length === 0) {
                    Array.prototype.push.apply(result, left);
                } else if (comp(left[0], right[0])) { // invoke the comparator function
                    // if it returns true - swap left and right
                    result.push(right[0]);
                    merge_iter(result, left, right.slice(1));
                } else {
                    // otherwise keep the same order
                    result.push(left[0]);
                    merge_iter(result, left.slice(1), right);
                }
            };
            var merged = [];
            merge_iter(merged, l, r);
            return merged;
        };

        var sort = function(array) {
            if(array.length <= 1) {
                return array;
            } else {
                var middle = Math.floor(array.length / 2);
                var left = array.slice(0, middle);
                var right = array.slice(middle);
                left = sort(left);
                right = sort(right);
                return merge(left, right);
            }
        };

        var result = sort(arr);

        return result;
    }

    /**
     * Randomly shuffles the contents of an array
     * @param {Array} arr - the input array
     * @returns {Array} the shuffled array
     */
    function functionShuffle(arr) {
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        if(arr.length <= 1) {
            return arr;
        }

        // shuffle using the 'inside-out' variant of the Fisher-Yates algorithm
        var result = new Array(arr.length);
        for(var i = 0; i < arr.length; i++) {
            var j = Math.floor(Math.random() * (i + 1)); // random integer such that 0 ≤ j ≤ i
            if(i !== j) {
                result[i] = result[j];
            }
            result[j] = arr[i];
        }

        return result;
    }

    /**
     * Applies a predicate function to each key/value pair in an object, and returns an object containing
     * only the key/value pairs that passed the predicate
     *
     * @param {object} arg - the object to be sifted
     * @param {object} func - the predicate function (lambda or native)
     * @returns {object} - sifted object
     */
    function functionSift(arg, func) {
        var result = {};

        var predicate = function (value, key, object) {
            var it = apply(func, [value, key, object], null);
            // returns a generator - so iterate over it
            var res = it.next();
            while (!res.done) {
                res = it.next(res.value);
            }
            return res.value;
        };

        for(var item in arg) {
            var entry = arg[item];
            if(functionBoolean(predicate(entry, item, arg))) {
                result[item] = entry;
            }
        }

        // empty objects should be changed to undefined
        if(Object.keys(result).length === 0) {
            result = undefined;
        }

        return result;
    }

    // Regular expression to match an ISO 8601 formatted timestamp
    var iso8601regex = new RegExp('^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z)$');

    /**
     * Converts an ISO 8601 timestamp to milliseconds since the epoch
     *
     * @param {string} timestamp - the ISO 8601 timestamp to be converted
     * @returns {Number} - milliseconds since the epoch
     */
    function functionToMillis(timestamp) {
        // undefined inputs always return undefined
        if(typeof timestamp === 'undefined') {
            return undefined;
        }

        if(!iso8601regex.test(timestamp)) {
            throw {
                stack: (new Error()).stack,
                code: "D3110",
                value: timestamp
            };
        }

        return Date.parse(timestamp);
    }

    /**
     * Converts milliseconds since the epoch to an ISO 8601 timestamp
     * @param {Number} millis - milliseconds since the epoch to be converted
     * @returns {String} - an ISO 8601 formatted timestamp
     */
    function functionFromMillis(millis) {
        // undefined inputs always return undefined
        if(typeof millis === 'undefined') {
            return undefined;
        }

        return new Date(millis).toISOString();
    }

    /**
     * Clones an object
     * @param {Object} arg - object to clone (deep copy)
     * @returns {*} - the cloned object
     */
    function functionClone(arg) {
        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        return JSON.parse(functionString(arg));
    }

    /**
     * Create frame
     * @param {Object} enclosingEnvironment - Enclosing environment
     * @returns {{bind: bind, lookup: lookup}} Created frame
     */
    function createFrame(enclosingEnvironment) {
        var bindings = {};
        return {
            bind: function (name, value) {
                bindings[name] = value;
            },
            lookup: function (name) {
                var value;
                if(bindings.hasOwnProperty(name)) {
                    value = bindings[name];
                } else if (enclosingEnvironment) {
                    value = enclosingEnvironment.lookup(name);
                }
                return value;
            }
        };
    }

    // Function registration
    staticFrame.bind('sum', defineFunction(functionSum, '<a<n>:n>'));
    staticFrame.bind('count', defineFunction(functionCount, '<a:n>'));
    staticFrame.bind('max', defineFunction(functionMax, '<a<n>:n>'));
    staticFrame.bind('min', defineFunction(functionMin, '<a<n>:n>'));
    staticFrame.bind('average', defineFunction(functionAverage, '<a<n>:n>'));
    staticFrame.bind('string', defineFunction(functionString, '<x-:s>'));
    staticFrame.bind('substring', defineFunction(functionSubstring, '<s-nn?:s>'));
    staticFrame.bind('substringBefore', defineFunction(functionSubstringBefore, '<s-s:s>'));
    staticFrame.bind('substringAfter', defineFunction(functionSubstringAfter, '<s-s:s>'));
    staticFrame.bind('lowercase', defineFunction(functionLowercase, '<s-:s>'));
    staticFrame.bind('uppercase', defineFunction(functionUppercase, '<s-:s>'));
    staticFrame.bind('length', defineFunction(functionLength, '<s-:n>'));
    staticFrame.bind('trim', defineFunction(functionTrim, '<s-:s>'));
    staticFrame.bind('pad', defineFunction(functionPad, '<s-ns?:s>'));
    staticFrame.bind('match', defineFunction(functionMatch, '<s-f<s:o>n?:a<o>>'));
    staticFrame.bind('contains', defineFunction(functionContains, '<s-(sf):b>')); // TODO <s-(sf<s:o>):b>
    staticFrame.bind('replace', defineFunction(functionReplace, '<s-(sf)(sf)n?:s>')); // TODO <s-(sf<s:o>)(sf<o:s>)n?:s>
    staticFrame.bind('split', defineFunction(functionSplit, '<s-(sf)n?:a<s>>')); // TODO <s-(sf<s:o>)n?:a<s>>
    staticFrame.bind('join', defineFunction(functionJoin, '<a<s>s?:s>'));
    staticFrame.bind('formatNumber', defineFunction(functionFormatNumber, '<n-so?:s>'));
    staticFrame.bind('formatBase', defineFunction(functionFormatBase, '<n-n?:s>'));
    staticFrame.bind('number', defineFunction(functionNumber, '<(ns)-:n>'));
    staticFrame.bind('floor', defineFunction(functionFloor, '<n-:n>'));
    staticFrame.bind('ceil', defineFunction(functionCeil, '<n-:n>'));
    staticFrame.bind('round', defineFunction(functionRound, '<n-n?:n>'));
    staticFrame.bind('abs', defineFunction(functionAbs, '<n-:n>'));
    staticFrame.bind('sqrt', defineFunction(functionSqrt, '<n-:n>'));
    staticFrame.bind('power', defineFunction(functionPower, '<n-n:n>'));
    staticFrame.bind('random', defineFunction(functionRandom, '<:n>'));
    staticFrame.bind('boolean', defineFunction(functionBoolean, '<x-:b>'));
    staticFrame.bind('not', defineFunction(functionNot, '<x-:b>'));
    staticFrame.bind('map', defineFunction(functionMap, '<af>'));
    staticFrame.bind('zip', defineFunction(functionZip, '<a+>'));
    staticFrame.bind('filter', defineFunction(functionFilter, '<af>'));
    staticFrame.bind('reduce', defineFunction(functionFoldLeft, '<afj?:j>')); // TODO <f<jj:j>a<j>j?:j>
    staticFrame.bind('sift', defineFunction(functionSift, '<o-f?:o>'));
    staticFrame.bind('keys', defineFunction(functionKeys, '<x-:a<s>>'));
    staticFrame.bind('lookup', defineFunction(functionLookup, '<x-s:x>'));
    staticFrame.bind('append', defineFunction(functionAppend, '<xx:a>'));
    staticFrame.bind('exists', defineFunction(functionExists, '<x:b>'));
    staticFrame.bind('spread', defineFunction(functionSpread, '<x-:a<o>>'));
    staticFrame.bind('merge', defineFunction(functionMerge, '<a<o>:o>'));
    staticFrame.bind('reverse', defineFunction(functionReverse, '<a:a>'));
    staticFrame.bind('each', defineFunction(functionEach, '<o-f:a>'));
    staticFrame.bind('sort', defineFunction(functionSort, '<af?:a>'));
    staticFrame.bind('shuffle', defineFunction(functionShuffle, '<a:a>'));
    staticFrame.bind('base64encode', defineFunction(functionBase64encode, '<s-:s>'));
    staticFrame.bind('base64decode', defineFunction(functionBase64decode, '<s-:s>'));
    staticFrame.bind('toMillis', defineFunction(functionToMillis, '<s-:n>'));
    staticFrame.bind('fromMillis', defineFunction(functionFromMillis, '<n-:s>'));
    staticFrame.bind('clone', defineFunction(functionClone, '<(oa)-:o>'));

    /**
     * Error codes
     *
     */
    var errorCodes = {
        "S0101": "String literal must be terminated by a matching quote",
        "S0102": "Number out of range: {{token}}",
        "S0103": "Unsupported escape sequence: \\{{token}}",
        "S0104": "The escape sequence \\u must be followed by 4 hex digits",
        "S0105": "Quoted property name must be terminated with a backquote (`)",
        "S0201": "Syntax error: {{token}}",
        "S0202": "Expected {{value}}, got {{token}}",
        "S0203": "Expected {{value}} before end of expression",
        "S0204": "Unknown operator: {{token}}",
        "S0205": "Unexpected token: {{token}}",
        "S0206": "Unknown expression type: {{token}}",
        "S0207": "Unexpected end of expression",
        "S0208": "Parameter {{value}} of function definition must be a variable name (start with $)",
        "S0209": "A predicate cannot follow a grouping expression in a step",
        "S0210": "Each step can only have one grouping expression",
        "S0211": "The symbol {{token}} cannot be used as a unary operator",
        "S0301": "Empty regular expressions are not allowed",
        "S0302": "No terminating / in regular expression",
        "S0402": "Choice groups containing parameterized types are not supported",
        "S0401": "Type parameters can only be applied to functions and arrays",
        "S0500": "Attempted to evaluate an expression containing syntax error(s)",
        "T0410": "Argument {{index}} of function {{token}} does not match function signature",
        "T0411": "Context value is not a compatible type with argument {{index}} of function {{token}}",
        "T0412": "Argument {{index}} of function {{token}} must be an array of {{type}}",
        "D1001": "Number out of range: {{value}}",
        "D1002": "Cannot negate a non-numeric value: {{value}}",
        "T1003": "Key in object structure must evaluate to a string; got: {{value}}",
        "D1004": "Regular expression matches zero length string",
        "T1005": "Attempted to invoke a non-function. Did you mean ${{{token}}}?",
        "T1006": "Attempted to invoke a non-function",
        "T1007": "Attempted to partially apply a non-function. Did you mean ${{{token}}}?",
        "T1008": "Attempted to partially apply a non-function",
        "T2001": "The left side of the {{token}} operator must evaluate to a number",
        "T2002": "The right side of the {{token}} operator must evaluate to a number",
        "T2003": "The left side of the range operator (..) must evaluate to an integer",
        "T2004": "The right side of the range operator (..) must evaluate to an integer",
        "D2005": "The left side of := must be a variable name (start with $)",
        "T2006": "The right side of the function application operator ~> must be a function",
        "T2007": "Type mismatch when comparing values {{value}} and {{value2}} in order-by clause",
        "T2008": "The expressions within an order-by clause must evaluate to numeric or string values",
        "T2009": "The values {{value}} and {{value2}} either side of operator {{token}} must be of the same data type",
        "T2010": "The expressions either side of operator {{token}} must evaluate to numeric or string values",
        "T2011": "The insert/update clause of the transform expression must evaluate to an object: {{value}}",
        "T2012": "The delete clause of the transform expression must evaluate to a string or array of strings: {{value}}",
        "T2013": "The transform expression clones the input object using the $clone() function.  This has been overridden in the current scope by a non-function.",
        "D3001": "Attempting to invoke string function on Infinity or NaN",
        "D3010": "Second argument of replace function cannot be an empty string",
        "D3011": "Fourth argument of replace function must evaluate to a positive number",
        "D3012": "Attempted to replace a matched string with a non-string value",
        "D3020": "Third argument of split function must evaluate to a positive number",
        "D3030": "Unable to cast value to a number: {{value}}",
        "D3040": "Third argument of match function must evaluate to a positive number",
        "D3050": "First argument of reduce function must be a function with two arguments",
        "D3060": "The sqrt function cannot be applied to a negative number: {{value}}",
        "D3061": "The power function has resulted in a value that cannot be represented as a JSON number: base={{value}}, exponent={{exp}}",
        "D3070": "The single argument form of the sort function can only be applied to an array of strings or an array of numbers.  Use the second argument to specify a comparison function",
        "D3080": "The picture string must only contain a maximum of two sub-pictures",
        "D3081": "The sub-picture must not contain more than one instance of the 'decimal-separator' character",
        "D3082": "The sub-picture must not contain more than one instance of the 'percent' character",
        "D3083": "The sub-picture must not contain more than one instance of the 'per-mille' character",
        "D3084": "The sub-picture must not contain both a 'percent' and a 'per-mille' character",
        "D3085": "The mantissa part of a sub-picture must contain at least one character that is either an 'optional digit character' or a member of the 'decimal digit family'",
        "D3086": "The sub-picture must not contain a passive character that is preceded by an active character and that is followed by another active character",
        "D3087": "The sub-picture must not contain a 'grouping-separator' character that appears adjacent to a 'decimal-separator' character",
        "D3088": "The sub-picture must not contain a 'grouping-separator' at the end of the integer part",
        "D3089": "The sub-picture must not contain two adjacent instances of the 'grouping-separator' character",
        "D3090": "The integer part of the sub-picture must not contain a member of the 'decimal digit family' that is followed by an instance of the 'optional digit character'",
        "D3091": "The fractional part of the sub-picture must not contain an instance of the 'optional digit character' that is followed by a member of the 'decimal digit family'",
        "D3092": "A sub-picture that contains a 'percent' or 'per-mille' character must not contain a character treated as an 'exponent-separator'",
        "D3093": "The exponent part of the sub-picture must comprise only of one or more characters that are members of the 'decimal digit family'",
        "D3100": "The radix of the formatBase function must be between 2 and 36.  It was given {{value}}",
        "D3110": "The argument of the toMillis function must be an ISO 8601 formatted timestamp. Given {{value}}"
    };

    /**
     * lookup a message template from the catalog and substitute the inserts
     * @param {string} err - error code to lookup
     * @returns {string} message
     */
    function lookupMessage(err) {
        var message = 'Unknown error';
        if(typeof err.message !== 'undefined') {
            message = err.message;
        }
        var template = errorCodes[err.code];
        if(typeof template !== 'undefined') {
            // if there are any handlebars, replace them with the field references
            // triple braces - replace with value
            // double braces - replace with json stringified value
            message = template.replace(/\{\{\{([^}]+)}}}/g, function() {
                return err[arguments[1]];
            });
            message = message.replace(/\{\{([^}]+)}}/g, function() {
                return JSON.stringify(err[arguments[1]]);
            });
        }
        return message;
    }

    /**
     * JSONata
     * @param {Object} expr - JSONata expression
     * @param {boolean} options - recover: attempt to recover on parse error
     * @returns {{evaluate: evaluate, assign: assign}} Evaluated expression
     */
    function jsonata(expr, options) {
        var ast;
        var errors;
        try {
            ast = parser(expr, options && options.recover);
            errors = ast.errors;
            delete ast.errors;
        } catch(err) {
            // insert error message into structure
            err.message = lookupMessage(err);
            throw err;
        }
        var environment = createFrame(staticFrame);

        var timestamp = new Date(); // will be overridden on each call to evalute()
        environment.bind('now', defineFunction(function() {
            return timestamp.toJSON();
        }, '<:s>'));
        environment.bind('millis', defineFunction(function() {
            return timestamp.getTime();
        }, '<:n>'));

        return {
            evaluate: function (input, bindings, callback) {
                // throw if the expression compiled with syntax errors
                if(typeof errors !== 'undefined') {
                    var err = {
                        code: 'S0500',
                        position: 0
                    };
                    err.message = lookupMessage(err);
                    throw err;
                }

                if (typeof bindings !== 'undefined') {
                    var exec_env;
                    // the variable bindings have been passed in - create a frame to hold these
                    exec_env = createFrame(environment);
                    for (var v in bindings) {
                        exec_env.bind(v, bindings[v]);
                    }
                } else {
                    exec_env = environment;
                }
                // put the input document into the environment as the root object
                exec_env.bind('$', input);

                // capture the timestamp and put it in the execution environment
                // the $now() and $millis() functions will return this value - whenever it is called
                timestamp = new Date();

                var result, it;
                // if a callback function is supplied, then drive the generator in a promise chain
                if(typeof callback === 'function') {
                    exec_env.bind('__jsonata_async', true);
                    var thenHandler = function (response) {
                        result = it.next(response);
                        if (result.done) {
                            callback(null, result.value);
                        } else {
                            result.value.then(thenHandler)
                                .catch(function (err) {
                                    err.message = lookupMessage(err);
                                    callback(err, null);
                                });
                        }
                    };
                    it = evaluate(ast, input, exec_env);
                    result = it.next();
                    result.value.then(thenHandler);
                } else {
                    // no callback function - drive the generator to completion synchronously
                    try {
                        it = evaluate(ast, input, exec_env);
                        result = it.next();
                        while (!result.done) {
                            result = it.next(result.value);
                        }
                        return result.value;
                    } catch (err) {
                        // insert error message into structure
                        err.message = lookupMessage(err);
                        throw err;
                    }
                }
            },
            assign: function (name, value) {
                environment.bind(name, value);
            },
            registerFunction: function(name, implementation, signature) {
                var func = defineFunction(implementation, signature);
                environment.bind(name, func);
            },
            ast: function() {
                return ast;
            },
            errors: function() {
                return errors;
            }
        };
    }

    jsonata.parser = parser; // TODO remove this in a future release - use ast() instead

    return jsonata;

})();

// node.js only - export the jsonata and parser functions
// istanbul ignore else
if(typeof module !== 'undefined') {
    module.exports = jsonata;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],56:[function(require,module,exports){
(function (process){
'use strict';

var loglevel = require('loglevel');
var chalk = require('chalk');

var loggers = {};

module.exports = getLogger;

function getLogger() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$level = _ref.level,
      level = _ref$level === undefined ? getDefaultLevel() : _ref$level,
      _ref$prefix = _ref.prefix,
      prefix = _ref$prefix === undefined ? '' : _ref$prefix;

  if (loggers[prefix]) {
    return loggers[prefix];
  }
  var coloredPrefix = prefix ? `${chalk.dim(prefix)} ` : '';
  var levelPrefix = {
    TRACE: chalk.dim('[TRACE]'),
    DEBUG: chalk.cyan('[DEBUG]'),
    INFO: chalk.blue('[INFO]'),
    WARN: chalk.yellow('[WARN]'),
    ERROR: chalk.red('[ERROR]')
  };

  var logger = loglevel.getLogger(`${prefix}-logger`);

  // this is the plugin "api"
  var originalFactory = logger.methodFactory;
  logger.methodFactory = methodFactory;

  var originalSetLevel = logger.setLevel;
  logger.setLevel = setLevel;
  logger.setLevel(level);
  loggers[prefix] = logger;
  return logger;

  function methodFactory() {
    for (var _len = arguments.length, factoryArgs = Array(_len), _key = 0; _key < _len; _key++) {
      factoryArgs[_key] = arguments[_key];
    }

    var logLevel = factoryArgs[0];

    var rawMethod = originalFactory.apply(undefined, factoryArgs);
    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return rawMethod.apply(undefined, [`${coloredPrefix}${levelPrefix[logLevel.toUpperCase()]}:`].concat(args));
    };
  }

  function setLevel(levelToSetTo) {
    var persist = false; // uses browser localStorage
    return originalSetLevel.call(logger, levelToSetTo, persist);
  }
}

function getDefaultLevel() {
  var logLevel = process.env.LOG_LEVEL;

  if (logLevel === 'undefined' || !logLevel) {
    return 'warn';
  }
  return logLevel;
}
}).call(this,require('_process'))

},{"_process":3,"chalk":48,"loglevel":57}],57:[function(require,module,exports){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (typeof define === 'function' && define.amd) {
        define(definition);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = definition();
    } else {
        root.log = definition();
    }
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));

},{}],58:[function(require,module,exports){
(function (global){
var performance = global.performance || {};

var present = (function () {
  var names = ['now', 'webkitNow', 'msNow', 'mozNow', 'oNow'];
  while (names.length) {
    var name = names.shift();
    if (name in performance) {
      return performance[name].bind(performance);
    }
  }

  var dateNow = Date.now || function () { return new Date().getTime(); };
  var navigationStart = (performance.timing || {}).navigationStart || dateNow();
  return function () {
    return dateNow() - navigationStart;
  };
}());

present.performanceNow = performance.now;
present.noConflict = function () {
  performance.now = present.performanceNow;
};
present.conflict = function () {
  performance.now = present;
};
present.conflict();

module.exports = present;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
// Export ./lib/randgen

module.exports = require("./lib/randgen");

},{"./lib/randgen":60}],60:[function(require,module,exports){
/*jslint indent: 2, plusplus: true, sloppy: true */
// Generate uniformly distributed random numbers
// Gives a random number on the interval [min, max).
// If discrete is true, the number will be an integer.
function runif(min, max, discrete) {
  if (min === undefined) {
    min = 0;
  }
  if (max === undefined) {
    max = 1;
  }
  if (discrete === undefined) {
    discrete = false;
  }
  if (discrete) {
    return Math.floor(runif(min, max, false));
  }
  return Math.random() * (max - min) + min;
}

// Generate normally-distributed random nubmers
// Algorithm adapted from:
// http://c-faq.com/lib/gaussian.html
function rnorm(mean, stdev) {
  var u1, u2, v1, v2, s;
  if (mean === undefined) {
    mean = 0.0;
  }
  if (stdev === undefined) {
    stdev = 1.0;
  }
  if (rnorm.v2 === null) {
    do {
      u1 = Math.random();
      u2 = Math.random();

      v1 = 2 * u1 - 1;
      v2 = 2 * u2 - 1;
      s = v1 * v1 + v2 * v2;
    } while (s === 0 || s >= 1);

    rnorm.v2 = v2 * Math.sqrt(-2 * Math.log(s) / s);
    return stdev * v1 * Math.sqrt(-2 * Math.log(s) / s) + mean;
  }

  v2 = rnorm.v2;
  rnorm.v2 = null;
  return stdev * v2 + mean;
}

rnorm.v2 = null;

// Generate Chi-square distributed random numbers
function rchisq(degreesOfFreedom) {
  if (degreesOfFreedom === undefined) {
    degreesOfFreedom = 1;
  }
  var i, z, sum = 0.0;
  for (i = 0; i < degreesOfFreedom; i++) {
    z = rnorm();
    sum += z * z;
  }

  return sum;
}

// Generate Poisson distributed random numbers
function rpoisson(lambda) {
  if (lambda === undefined) {
    lambda = 1;
  }
  var l = Math.exp(-lambda),
    k = 0,
    p = 1.0;
  do {
    k++;
    p *= Math.random();
  } while (p > l);

  return k - 1;
}

// Generate Cauchy distributed random numbers
function rcauchy(loc, scale) {
  if (loc === undefined) {
    loc = 0.0;
  }
  if (scale === undefined) {
    scale = 1.0;
  }
  var n2, n1 = rnorm();
  do {
    n2 = rnorm();
  } while (n2 === 0.0);

  return loc + scale * n1 / n2;
}

// Bernoulli distribution: gives 1 with probability p
function rbernoulli(p) {
  return Math.random() < p ? 1 : 0;
}

// Vectorize a random generator
function vectorize(generator) {
  return function () {
    var n, result, i, args;
    args = [].slice.call(arguments)
    n = args.shift();
    result = [];
    for (i = 0; i < n; i++) {
      result.push(generator.apply(this, args));
    }
    return result;
  };
}

// Generate a histogram from a list of numbers
function histogram(data, binCount) {
  binCount = binCount || 10;

  var bins, i, scaled,
    max = Math.max.apply(this, data),
    min = Math.min.apply(this, data);

  // edge case: max == min
  if (max === min) {
    return [data.length];
  }

  bins = [];

  // zero each bin
  for (i = 0; i < binCount; i++) {
    bins.push(0);
  }

  for (i = 0; i < data.length; i++) {
    // scale it to be between 0 and 1
    scaled = (data[i] - min) / (max - min);

    // scale it up to the histogram size
    scaled *= binCount;

    // drop it in a bin
    scaled = Math.floor(scaled);

    // edge case: the max
    if (scaled === binCount) { scaled--; }

    bins[scaled]++;
  }

  return bins;
}

/**
 * Get a random element from a list
 */
function rlist(list) {
  return list[runif(0, list.length, true)];
}

exports.runif = runif;
exports.rnorm = rnorm;
exports.rchisq = rchisq;
exports.rpoisson = rpoisson;
exports.rcauchy = rcauchy;
exports.rbernoulli = rbernoulli;
exports.rlist = rlist;

exports.rvunif = vectorize(runif);
exports.rvnorm = vectorize(rnorm);
exports.rvchisq = vectorize(rchisq);
exports.rvpoisson = vectorize(rpoisson);
exports.rvcauchy = vectorize(rcauchy);
exports.rvbernoulli = vectorize(rbernoulli);
exports.rvlist = vectorize(rlist);

exports.histogram = histogram;

},{}],61:[function(require,module,exports){
'use strict';
var ansiRegex = require('ansi-regex')();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};

},{"ansi-regex":45}],62:[function(require,module,exports){
/* jshint node: true */
"use strict";
function makeArrayFrom(obj) {
  return Array.prototype.slice.apply(obj);
}
var
  PENDING = "pending",
  RESOLVED = "resolved",
  REJECTED = "rejected";

function SynchronousPromise(handler) {
  this.status = PENDING;
  this._continuations = [];
  this._parent = null;
  this._paused = false;
  if (handler) {
    handler.call(
      this,
      this._continueWith.bind(this),
      this._failWith.bind(this)
    );
  }
}

function looksLikeAPromise(obj) {
  return obj && typeof (obj.then) === "function";
}

SynchronousPromise.prototype = {
  then: function (nextFn, catchFn) {
    var next = SynchronousPromise.unresolved()._setParent(this);
    if (this._isRejected()) {
      if (this._paused) {
        this._continuations.push({
          promise: next,
          nextFn: nextFn,
          catchFn: catchFn
        });
        return next;
      }
      if (catchFn) {
        try {
          var catchResult = catchFn(this._error);
          if (looksLikeAPromise(catchResult)) {
            this._chainPromiseData(catchResult, next);
            return next;
          } else {
            return SynchronousPromise.resolve(catchResult)._setParent(this);
          }
        } catch (e) {
          return SynchronousPromise.reject(e)._setParent(this);
        }
      }
      return SynchronousPromise.reject(this._error)._setParent(this);
    }
    this._continuations.push({
      promise: next,
      nextFn: nextFn,
      catchFn: catchFn
    });
    this._runResolutions();
    return next;
  },
  catch: function (handler) {
    if (this._isResolved()) {
      return SynchronousPromise.resolve(this._data)._setParent(this);
    }
    var next = SynchronousPromise.unresolved()._setParent(this);
    this._continuations.push({
      promise: next,
      catchFn: handler
    });
    this._runRejections();
    return next;
  },
  pause: function () {
    this._paused = true;
    return this;
  },
  resume: function () {
    var firstPaused = this._findFirstPaused();
    if (firstPaused) {
      firstPaused._paused = false;
      firstPaused._runResolutions();
      firstPaused._runRejections();
    }
    return this;
  },
  _findAncestry: function () {
    return this._continuations.reduce(function (acc, cur) {
      if (cur.promise) {
        var node = {
          promise: cur.promise,
          children: cur.promise._findAncestry()
        };
        acc.push(node);
      }
      return acc;
    }, []);
  },
  _setParent: function (parent) {
    if (this._parent) {
      throw new Error("parent already set");
    }
    this._parent = parent;
    return this;
  },
  _continueWith: function (data) {
    var firstPending = this._findFirstPending();
    if (firstPending) {
      firstPending._data = data;
      firstPending._setResolved();
    }
  },
  _findFirstPending: function () {
    return this._findFirstAncestor(function (test) {
      return test._isPending && test._isPending();
    });
  },
  _findFirstPaused: function () {
    return this._findFirstAncestor(function (test) {
      return test._paused;
    });
  },
  _findFirstAncestor: function (matching) {
    var test = this;
    var result;
    while (test) {
      if (matching(test)) {
        result = test;
      }
      test = test._parent;
    }
    return result;
  },
  _failWith: function (error) {
    var firstRejected = this._findFirstPending();
    if (firstRejected) {
      firstRejected._error = error;
      firstRejected._setRejected();
    }
  },
  _takeContinuations: function () {
    return this._continuations.splice(0, this._continuations.length);
  },
  _runRejections: function () {
    if (this._paused || !this._isRejected()) {
      return;
    }
    var
      error = this._error,
      continuations = this._takeContinuations(),
      self = this;
    continuations.forEach(function (cont) {
      if (cont.catchFn) {
        var catchResult = cont.catchFn(error);
        self._handleUserFunctionResult(catchResult, cont.promise);
      } else {
        cont.promise.reject(error);
      }
    });
  },
  _runResolutions: function () {
    if (this._paused || !this._isResolved()) {
      return;
    }
    var continuations = this._takeContinuations();
    if (looksLikeAPromise(this._data)) {
      return this._handleWhenResolvedDataIsPromise(this._data);
    }
    var data = this._data;
    var self = this;
    continuations.forEach(function (cont) {
      if (cont.nextFn) {
        try {
          var result = cont.nextFn(data);
          self._handleUserFunctionResult(result, cont.promise);
        } catch (e) {
          self._handleResolutionError(e, cont);
        }
      } else if (cont.promise) {
        cont.promise.resolve(data);
      }
    });
  },
  _handleResolutionError: function (e, continuation) {
    this._setRejected();
    if (continuation.catchFn) {
      try {
        continuation.catchFn(e);
        return;
      } catch (e2) {
        e = e2;
      }
    }
    if (continuation.promise) {
      continuation.promise.reject(e);
    }
  },
  _handleWhenResolvedDataIsPromise: function (data) {
    var self = this;
    return data.then(function (result) {
      self._data = result;
      self._runResolutions();
    }).catch(function (error) {
      self._error = error;
      self._setRejected();
      self._runRejections();
    });
  },
  _handleUserFunctionResult: function (data, nextSynchronousPromise) {
    if (looksLikeAPromise(data)) {
      this._chainPromiseData(data, nextSynchronousPromise);
    } else {
      nextSynchronousPromise.resolve(data);
    }
  },
  _chainPromiseData: function (promiseData, nextSynchronousPromise) {
    promiseData.then(function (newData) {
      nextSynchronousPromise.resolve(newData);
    }).catch(function (newError) {
      nextSynchronousPromise.reject(newError);
    });
  },
  _setResolved: function () {
    this.status = RESOLVED;
    if (!this._paused) {
      this._runResolutions();
    }
  },
  _setRejected: function () {
    this.status = REJECTED;
    if (!this._paused) {
      this._runRejections();
    }
  },
  _isPending: function () {
    return this.status === PENDING;
  },
  _isResolved: function () {
    return this.status === RESOLVED;
  },
  _isRejected: function () {
    return this.status === REJECTED;
  }
};

SynchronousPromise.resolve = function (result) {
  return new SynchronousPromise(function (resolve, reject) {
    if (looksLikeAPromise(result)) {
      result.then(function (newResult) {
        resolve(newResult);
      }).catch(function (error) {
        reject(error);
      });
    } else {
      resolve(result);
    }
  });
};

SynchronousPromise.reject = function (result) {
  return new SynchronousPromise(function (resolve, reject) {
    reject(result);
  });
};

SynchronousPromise.unresolved = function () {
  return new SynchronousPromise(function (resolve, reject) {
    this.resolve = resolve;
    this.reject = reject;
  });
};

SynchronousPromise.all = function () {
  var args = makeArrayFrom(arguments);
  if (Array.isArray(args[0])) {
    args = args[0];
  }
  if (!args.length) {
    return SynchronousPromise.resolve([]);
  }
  return new SynchronousPromise(function (resolve, reject) {
    var
      allData = [],
      numResolved = 0,
      doResolve = function () {
        if (numResolved === args.length) {
          resolve(allData);
        }
      },
      rejected = false,
      doReject = function (err) {
        if (rejected) {
          return;
        }
        rejected = true;
        reject(err);
      };
    args.forEach(function (arg, idx) {
      SynchronousPromise.resolve(arg).then(function (thisResult) {
        allData[idx] = thisResult;
        numResolved += 1;
        doResolve();
      }).catch(function (err) {
        doReject(err);
      });
    });
  });
};

/* jshint ignore:start */
if (Promise === SynchronousPromise) {
  throw new Error("Please use SynchronousPromise.installGlobally() to install globally");
}
var RealPromise = Promise;
SynchronousPromise.installGlobally = function(__awaiter) {
  if (Promise === SynchronousPromise) {
    return __awaiter;
  } 
  var result = patchAwaiterIfRequired(__awaiter);
  Promise = SynchronousPromise;
  return result;
};

SynchronousPromise.uninstallGlobally = function() {
  if (Promise === SynchronousPromise) {
    Promise = RealPromise;
  }
};

function patchAwaiterIfRequired(__awaiter) {
  if (typeof(__awaiter) === "undefined" || __awaiter.__patched) {
    return __awaiter;
  }
  var originalAwaiter = __awaiter;
  __awaiter = function() {
    var Promise = RealPromise;
    originalAwaiter.apply(this, makeArrayFrom(arguments));
  };
  __awaiter.__patched = true;
  return __awaiter;
}
/* jshint ignore:end */

module.exports = {
  SynchronousPromise: SynchronousPromise
};
},{}],63:[function(require,module,exports){
"use strict";

// Plugin to add 'property' (as in personal property) property to Players when they are initialized. Meant to be used for
// simulations involving personal posessions, for instance economic simulations.

// NashJS engine components
var Engine = require("../lib/engine")

// Game state
var { registry, gamePopulation } = Engine.Backend.State;

// Let's add some PlayerList functionality
var { PlayerList } = Engine.Backend.Classes;


var BalanceSheet = function() {

	// Variables to store settings, and defaults
	var settings = {
		addBalanceSheetOnClaim: true,
		cleanZeros: true,
		negativeAssets: false
	}
	//TODO make negativeAssets (and negativeLiabilities) work


	// Assets Classes

	// Claim parent class
	var Claim = function(claimant, amount) {
		// Add balance sheet if necessary and permitted
		if (!claimant.balanceSheet) {
			if (settings.addBalanceSheetOnClaim) addEntries(registry.players[claimant.id()])
			// Fail if not permitted to add necessary balance sheet.
			else return false;
		}

		this.amount = amount;
		this.claimant = claimant
		claimant.endow(this)
		return true;
	}

	// End ownership claim
	Claim.prototype.erase = function() {
		this.claimant.revoke(this)
		this.claimant = null;
		this.amount = 0
	}

	// Merge claims if they're the same family but different amounts
	Claim.prototype.merge = function(otherClaim) {
		if (this.claimant !== otherClaim.claimant) return false
		// Add amounts
		this.amount = this.amount + otherClaim.amount

		// Remove from balance sheet
		otherClaim.erase();
	}

	// Split this into two separate claims, with different amounts
	Claim.prototype.split = function(newAmount) {
		var clone = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
		clone.amount = newAmount;
		this.amount = this.amount - newAmount;
		this.claimant.endow(clone, false)
		return clone;
	}

	// Transfer to new owner
	Claim.prototype.transfer = function(newClaimant, amount = "all") {
		// Add balance sheet if necessary and permitted
		if (!newClaimant.balanceSheet) {
			if (settings.addBalanceSheetOnClaim) addEntries(registry.players[newClaimant.id()])
			// Fail if not permitted to add necessary balance sheet.
			else return false;
		}

		// Transfer all of it
		if (amount == "all" || amount == this.amount) {
			var oldClaimant = this.claimant;
			this.claimant.revoke(this);
			this.claimant = newClaimant;
			newClaimant.endow(this);

		}
		// or only a portion
		else {
			var newClaim = this.split(amount);
			newClaim.transfer(newClaimant, "all")
			cleanAsset(this)
		}

	}



	// Claims on real things (like cars, houses, gold)
	var RealClaim = function(claimant, good, amount) {
		if (!Claim.call(this, claimant, amount)) return false;
		this.good = good;
	}
	RealClaim.prototype = Object.create(Claim.prototype)
	RealClaim.prototype.constructor = RealClaim

	// Lose value by percentage
	RealClaim.prototype.depreciate = function(rate = .1) {
		this.amount = this.amount * (1 - rate)
	}

	// Add good enforcement to merge
	RealClaim.prototype.merge = function(otherClaim) {
		if (this.good === otherClaim.good) return Claim.prototype.merge.call(this, otherClaim);
	}

	// Replace player object with id when stringifying
	RealClaim.prototype.toJSON = function() {
		return {
			claimant: this.claimant.id(),
			good: this.good,
			amount: this.amount
		}
	}

	// Claims on other entities with balance sheets
	var FinancialClaim = function(claimant, claimed, amount, instrument = "Debt") {
		// Add balance sheet if necessary and permitted
		if (!claimed.balanceSheet) {
			if (settings.addBalanceSheetOnClaim) addEntries(registry.players[claimed.id()])
			// Fail if not permitted to add necessary balance sheet.
			else return false;
		}
		this.claimed = claimed;
		this.instrument = instrument;

		if (!Claim.call(this, claimant, amount)) return false;

		claimed.indebt(this)
	}
	FinancialClaim.prototype = Object.create(Claim.prototype)
	FinancialClaim.prototype.constructor = FinancialClaim

	// Add to erase function, to erase from claimed's balance sheet too
	FinancialClaim.prototype.erase = function() {
		var bs = registry.players[this.claimed.id()].balanceSheet.liabilities
		bs.splice(bs.indexOf(this), 1)
		this.claimed = null;

		return Claim.prototype.erase.call(this)
	}

	// Add claimed enforcement to merge
	FinancialClaim.prototype.merge = function(otherClaim) {
		if (this.claimed === otherClaim.claimed) return Claim.prototype.merge.call(this, otherClaim);
	}


	// Add to split function, to split on claimed's balance sheet too
	FinancialClaim.prototype.split = function(newAmount) {
		var clone = Claim.prototype.split.call(this, newAmount);
		clone.claimed.indebt(clone, false);
		return clone;
	}

	// Replace player object with id when stringifying
	FinancialClaim.prototype.toJSON = function() {
		return {
			claimant: this.claimant.id(),
			claimed: this.claimed.id(),
			instrument: this.instrument,
			amount: this.amount
		}
	}


	// Clean the similar claims on the claimant supplied
	var cleanAsset = function(claim) {
		var bs = registry.players[claim.claimant.id()].balanceSheet.assets;

		var dirty = bs.filter(function(entry) {
			return (entry !== claim && entry.good === claim.good && entry.instrument === claim.instrument);
		})

		dirty.forEach(function(dirt) {
			claim.merge(dirt)
		})

		if (settings.cleanZeros && claim.amount == 0) claim.erase()
	}

	var cleanLiability = function(claim) {
		var bs = registry.players[claim.claimed.id()].balanceSheet.liabilities;

		var dirty = bs.filter(function(entry) {
			return (entry !== claim && entry.claimant === claim.claimant && entry.instrument === claim.instrument);
		})

		dirty.forEach(function(dirt) {
			claim.merge(dirt)
		})

		if (settings.cleanZeros && claim.amount == 0) claim.erase
	}



	// Add balance sheet object and methods to player.
	var addEntries = function(player) {

		//_player properties/methods
		player.balanceSheet = { assets: [], liabilities: [] }

		/*
		var lookup = function(type) {
			this.reduce(function(accumulator, value) {
				if (type === value.good) accumulator += value.amount
				else if (type instanceof Object && type.instrument == value.instrument && (type.claimed === value.claimed))
					accumulator += value.amount
				return accumulator;
			}, 0)
		}
		player.balanceSheet.assets.lookup = lookup;
		player.balanceSheet.liabilities.lookup = lookup;
		*/

		player.netWorth = function() {

			var assets = this.balanceSheet.assets.reduce(function(accumulator, currentValue) {
				return accumulator + currentValue.amount
			}, 0);

			var liabilities = this.balanceSheet.liabilities.reduce(function(accumulator,
				currentValue) {
				return accumulator + currentValue.amount
			}, 0);

			return assets - liabilities;
		}

		// User interface
		player.interface.balanceSheet = function() {
			return JSON.parse(JSON.stringify(registry.players[player.id].balanceSheet));
		}

		player.interface.netWorth = function() {
			return registry.players[player.id].netWorth();
		}

		// TODO validate object.
		player.interface.endow = function(asset, clean = true) {
			if (asset instanceof Claim) {
				registry.players[player.id].balanceSheet.assets.push(asset);
				if (clean) cleanAsset(asset);
			}
		}

		player.interface.indebt = function(liability, clean = true) {
			if (liability instanceof FinancialClaim) {
				registry.players[player.id].balanceSheet.liabilities.push(
					liability);
				if (clean) cleanLiability(liability);
			}
		}

		player.interface.revoke = function(asset) {
			if (asset instanceof Claim) {
				var bs = registry.players[player.id].balanceSheet.assets
				bs.splice(bs.indexOf(asset), 1)
			}
		}

		// TODO convert this over
		player.interface.lend = function(borrower, amount, instrument = "Debt") {
			return new FinancialClaim(player.interface, borrower, amount, instrument)
		}
	}



	// The plugin object.
	var Plugin = {
		name: "balance-sheet-complex",

		settings: function(parameters = {}) {
			Object.assign(settings, parameters)
		},

		// Option to initialize by creating 'property' for a group of players.
		init(players = []) {
			// Add some playerlist functionality
			PlayerList.prototype.balanceSheets = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet();
					else return null;
				})
			};

			PlayerList.prototype.assets = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet().assets;
					else return null;
				})
			};

			PlayerList.prototype.liabilities = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet().liabilities;
					else return null;
				})
			};

			PlayerList.prototype.netWorth = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.netWorth();
					else return null;
				})
			};

			PlayerList.prototype.zeroBalanceSheets = function() {
				this.forEach(function(player) {
					addEntries(player)
				});
				return this;
			}

			// Add bs for specified players
			players.forEach(function(player) {
				addEntries(registry.players[player.id()]);
			})
		},

		// If we've init-ed alredy, just add bs's to the current player list if they don't have already
		require(players = []) {
			players.forEach(function(player) {
				if (!player.balanceSheet) addEntries(registry.players[player.id()]);
			});
		},

		stop() {
			// remove prototype addEntries
			delete PlayerList.prototype.balanceSheets;
			delete PlayerList.prototype.assets;
			delete PlayerList.prototype.liabilities;
			delete PlayerList.prototype.netWorth;

			// delete balance sheet properties from every player and interface.
			gamePopulation().forEach(function(player) {
				delete player.balanceSheet;
				delete player.netWorth;
				delete player.interface.balanceSheet;
				delete player.interface.netWorth;
				delete player.interface.endowAssets;
				delete player.interface.lend;
			})
		},

		// Public classes for asset/liability
		publicIfActive: {
			RealClaim,
			FinancialClaim
		},

		// create property and interface function when player is created
		'player-create': addEntries,

		// Blank property when player is re-initialized
		"player-reinitialize" (player) {
			player.balanceSheet = { assets: [], liabilities: [] }
		}
	}

	return Plugin;
}



module.exports = BalanceSheet;

},{"../lib/engine":6}],64:[function(require,module,exports){
"use strict";

// Plugin to add 'property' (as in personal property) property to Players when they are initialized. Meant to be used for
// simulations involving personal posessions, for instance economic simulations.

// NashJS engine components
var Engine = require("../lib/engine")

// Game state
var { registry, gamePopulation } = Engine.Backend.State;

// Let's add some PlayerList functionality
var { PlayerList } = Engine.Backend.Classes;


var BalanceSheet = function() {

	var addEntries = function(player) {
		//_player properties/methods
		player.balanceSheet = { assets: {}, liabilities: {} }

		player.netWorth = function() {

			var assets = Object.entries(this.balanceSheet.assets).reduce(function(accumulator, currentValue) {
				return accumulator + currentValue[1]
			}, 0);

			var liabilities = Object.entries(this.balanceSheet.liabilities).reduce(function(accumulator,
				currentValue) {
				return accumulator + currentValue[1]
			}, 0);

			return assets - liabilities;
		}

		// User interface
		player.interface.balanceSheet = function() {
			return JSON.parse(JSON.stringify(registry.players[player.id].balanceSheet));
		}

		player.interface.netWorth = function() {
			return registry.players[player.id].netWorth();
		}

		// TODO validate object. Should be of form {apples:2, dogs:1}
		player.interface.endowAssets = function(assetObject) {

			Object.assign(registry.players[player.id].balanceSheet.assets, assetObject)
		}

		player.interface.lend = function(loanObject) {
			//TODO validate object. Should be of form {player1:{mortgage:10}}
			var lender = registry.players[player.id].balanceSheet.assets
			Object.entries(loanObject).forEach(function(loanTo) {
				var debts;
				lender[loanTo[0]] ?
					debts = lender[loanTo[0]] : debts = lender[loanTo[0]] = {};

				Object.entries(loanTo[1]).forEach(function(newLoan) {
					debts[newLoan[0]] ? debts[newLoan[0]] += newLoan[1] : debts[newLoan[0]] = newLoan[1]
					registry.players[loanTo[0]].balanceSheet.liabilities[newLoan[0]] ? registry.players[loanTo[0]].balanceSheet
						.liabilities[newLoan[0]] += newLoan[1] : registry.players[loanTo[0]].balanceSheet.liabilities[
							newLoan[0]] = newLoan[1];
				});
			});
		}
	}



	// The plugin object.
	var Plugin = {
		name: "balance-sheet",

		// Option to initialize by creating 'property' for a group of players.
		init(players = []) {
			// Add some playerlist functionality
			PlayerList.prototype.balanceSheets = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet();
					else return null;
				})
			};

			PlayerList.prototype.assets = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet().assets;
					else return null;
				})
			};

			PlayerList.prototype.liabilities = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet().liabilities;
					else return null;
				})
			};

			PlayerList.prototype.netWorth = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.netWorth();
					else return null;
				})
			};

			PlayerList.prototype.zeroBalanceSheets = function() {
				this.forEach(function(player) {
					addEntries(player)
				});
				return this;
			}

			// Add bs for specified players
			players.forEach(function(player) {
				addEntries(registry.players[player.id()]);
			})
		},

		// If we've init-ed alredy, just add bs's to the current player list if they don't have already
		require(players = []) {
			players.forEach(function(player) {
				if (!player.balanceSheet) addEntries(registry.players[player.id()]);
			});
		},

		stop() {
			// remove prototype addEntries
			delete PlayerList.prototype.balanceSheets;
			delete PlayerList.prototype.assets;
			delete PlayerList.prototype.liabilities;
			delete PlayerList.prototype.netWorth;

			// delete balance sheet properties from every player and interface.
			gamePopulation().forEach(function(player) {
				delete player.balanceSheet;
				delete player.netWorth;
				delete player.interface.balanceSheet;
				delete player.interface.netWorth;
				delete player.interface.endowAssets;
				delete player.interface.lend;
			})
		},

		// create property and interface function when player is created
		'player-create': addEntries,

		// Blank property when player is re-initialized
		"player-reinitialize" (player) {
			player.balanceSheet = { assets: [], liabilities: [] }
		}
	}

	return Plugin;
}


module.exports = BalanceSheet;

},{"../lib/engine":6}],65:[function(require,module,exports){
"use strict";

// game pieces
var prisonerDilemma = require("./iterated-prisoner-dilemma").createGenerator;
var roundRobin = require("./round-robin");

// NashJS engine components
var Engine = require("../lib/engine")

var { Loop } = Engine.Frontend.Playables;

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")
var { generatePopulation } = Engine.Backend.HelperFunctions("tournament");

// Population interfaces
var { Population } = Engine.Frontend.Population;


var AxelrodTournament = gameWrapper(function(players, parameters = {}) {
	var { generatePlayers = true, repeats = 5, gameLength = 200 } = parameters;

	// Either create an entire population
	if (generatePlayers) {
		// Get two sets of players. The second is so players can play themselves
		players = generatePopulation();
		var copies = generatePopulation();
		parameters.copies = copies;
	}

	// or use the supplied players
	else if (players) {
		// do nothing
	} else {
		// or use the players already present
		players = Population().onlyAlive().onlyAvailable();
	}

	// assign parameters and generate the game
	parameters.initializePlayers = players;
	var iteration = roundRobin(players, prisonerDilemma(gameLength), parameters);

	return Loop(iteration, repeats, { id: "Axelrod-Tournament" });
});



module.exports = AxelrodTournament;

},{"../lib/engine":6,"./iterated-prisoner-dilemma":70,"./round-robin":76}],66:[function(require,module,exports){
"use strict";

//base game
var TwoPlayerNormal = require("./simple-normal");

// helper functions
var { gameWrapper } = require("../lib/engine").Backend.HelperFunctions("stock-games")


// Battle of the Sexes
var BattleOfTheSexes = gameWrapper(function(players, parameters = {}) {
	parameters.id = parameters.id || "Battle-of-the-Sexes";

	var choices = [
		["Opera", "Football"],
		["Opera", "Football"]
	];
	var payoffs = [
		[
			[2, 1],
			[0, 0]
		],
		[
			[0, 0],
			[1, 2]
		]
	];

	return TwoPlayerNormal(players, choices, payoffs, parameters);
});

module.exports = BattleOfTheSexes;

},{"../lib/engine":6,"./simple-normal":77}],67:[function(require,module,exports){
"use strict";

// NashJS engine components
var Engine = require("../lib/engine")

// User data
var { Population } = Engine.Frontend

// Playables
var { Lambda, Simultaneous, Sequence, Loop } = Engine.Frontend.Playables;

// Helper functions
var { isFunction } = Engine.Backend.HelperFunctions("general");


//Cultural evolution
//
// TODO: add instructions here
function CulturalEvolution(gameGenerator, numLoops = 1, {
	id = "CulturalEvolution",
	gameProbability = .25,
	pairProbability = .25,
	generatePopulation = null,
	loop = true
} = {}) {

	if (loop && isNaN(numLoops)) throw new Error("CulturalEvolution argument 'numLoops must be a number");
	if (!isFunction(gameGenerator)) throw new Error(
		"CulturalEvolution argument 'gameGenerator' must be a function");
	if (isNaN(gameProbability) || gameProbability < 0 || gameProbability > 1) throw new Error(
		"CulturalEvolution argument 'gameProbability' must be between 0 and 1");
	if (isNaN(pairProbability) || pairProbability < 0 || pairProbability > 1) throw new Error(
		"CulturalEvolution argument 'pairProbability' must be between 0 and 1");

	// Generate population if user wants us to.
	if (isFunction(generatePopulation)) generatePopulation();

	//Reset the scores each round.
	var ResetScores = Lambda(function() {
		Population().onlyAlive().resetScores();
	});

	// Calculate number of matches
	var n = Math.floor(Population().onlyAlive().length * gameProbability);

	// Create matches.
	var matches = [...Array(n)]
	for (var i = 0; i < n; i++) {
		matches[i] = gameGenerator();
		if (!matches[i].play) throw new Error("CulturalEvolution argument 'gameGenerator' must return a Playable");
	}

	//Run all matches simultaneously
	var Round = Simultaneous(matches);

	//Calculate number of pairings
	var n = Math.floor(Population().onlyAlive().length * pairProbability)

	//Create pairings
	var pairings = [...Array(n)];
	for (i = 0; i < n; i++) {

		pairings[i] = Lambda(function() {

			//Find some available players
			var pool = Population().onlyAlive().onlyAvailable();
			var p1 = pool[Math.floor(Math.random() * pool.length)];
			var p2 = pool[Math.floor(Math.random() * pool.length)];

			//Mark them busy
			p1.busy();
			p2.busy();

			// Assign strategy of player with higher score
			if (p1.score() > p2.score()) p2.assign(p1.strategy());
			else if (p1.score() == p2.score()) null;
			else p1.assign(p2.strategy());

			//Return value of player ids, so the log makes some sense.
			return [p1.id(), p2.id()];
		});
	}

	// Run pairings simultaneously
	var Pairing = Simultaneous(pairings);

	// After pairings, mark all players as available.
	var ReleasePlayers = Lambda(function() {
		Population().onlyAlive().release();
	});

	// Define the game.
	Round(ResetScores);
	Pairing(Round);
	ReleasePlayers(Pairing);
	var Iteration = Sequence(ResetScores, ReleasePlayers);

	// User can set loop parameter to false, to avoid wrapping this in a loop.
	if (loop)
		var CE = Loop(Iteration, numLoops, { playableParameters: { initializePlayers: true } });
	else
		var CE = Iteration;

	return CE;
}

//TODO: fix parameters. User should be able to supply parameters which either
// end up as parameters for the Loop or the Sequence.


module.exports = CulturalEvolution;

},{"../lib/engine":6}],68:[function(require,module,exports){
"use strict";

// base game
var TwoPlayerNormal = require("./simple-normal").TwoPlayerNormal;

// NashJS engine components
var Engine = require("../lib/engine")

// Nash engine components
var { Sequence, Lambda } = Engine.Frontend.Playables;

// Game state
var { registry } = Engine.Backend.State

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// We'll need the 'balance-sheet' plugin
var PluginManager = Engine.Backend.PluginManager;

function invertTerms(termsOfTrade) {
	var inverse = {}
	Object.entries(termsOfTrade).forEach(function(term) {
		if (term[0] == "borrow") {
			inverse.lend = term[1]
		} else if (term[0] == "lend") {
			inverse.borrow = term[1]
		} else {
			inverse[term[0]] = term[1] * -1
		}
	});
	return inverse;
}

// termsOfTrade should be an object reflecting the outcomes for player 1.
// Example {apple:2, orange:-2}. To borrow or lend, create a sub-object describing the loan terms.
// eg {apple:2, borrow:{IOU:5}}, or {couch:-10, lend:{'credit card':50}}
var Exchange = gameWrapper(function(players, termsOfTrade = {}, parameters = {}) {
	var { utilityFunctions, utilityMode = "absolute", initialEndowment = [{}, {}] } = parameters //utilityFunctions should be an array of 2 functions, which take a results object and return a change in utility
	parameters.id = "Exchange" || parameters.id;




	// To play this game, players will need a balance sheet. This plugin will add balance sheets to the players,
	// as well as ensure that new players are created with one, and that they are re-initialized properly.
	var balanceSheet = PluginManager.package("balance-sheet-complex").require(players);
	balanceSheet.settings({ cleanZeros: false })

	var p1 = registry.players[players[0].id()];
	var p2 = registry.players[players[1].id()];

	// Do initial endowments if there are any. Format same as for terms of trade.
	initialEndowment.forEach(function(endowment, index) {
		var player = players[index]
		var invertPlayer = players[Number(!index)]
		Object.entries(endowment).forEach(function(term) {
			if (term[0] == "borrow") {
				var loanTerms = Object.entries(term[1])[0]
				new balanceSheet.FinancialClaim(invertPlayer, player, loanTerms[1], loanTerms[0])
			} else if (term[0] == "lend") {
				var loanTerms = Object.entries(term[1])[0]
				new balanceSheet.FinancialClaim(player, invertPlayer, loanTerms[1], loanTerms[0])
			} else {
				new balanceSheet.RealClaim(player, term[0], term[1])
			}
		})
	})

	// The actual playable
	var Decision = TwoPlayerNormal(players, [
		["Accept", "Reject"],
		["Accept", "Reject"]
	], null, {
		id: "Decision",
		informationFilter: function(info) { //TODO might need to wrap user-supplied informationFilter?
			info.termsOfTrade = {
				[p1.id]: termsOfTrade,
				[p2.id]: invertTerms(termsOfTrade)
			}
			return info;
		}
	})

	// Distribute the goods
	var Distribute = Lambda(function() {

		var results = [];

		Object.entries(termsOfTrade).forEach(function(term) {
			if (term[0] == "borrow") {
				var loanTerms = Object.entries(term[1])[0]
				var loan = new balanceSheet.FinancialClaim(p2.interface, p1.interface, loanTerms[1], loanTerms[0])

				results.push({
					player: p1.id,
					borrow: {
						[loanTerms[0]]: loanTerms[1]
					}
				});

				results.push({
					player: p2.id,
					lend: {
						[p1.id]: {
							[loanTerms[0]]: loanTerms[1]
						}
					}
				});

			} else if (term[0] == "lend") {
				var loanTerms = Object.entries(term[1])[0]
				var loan = new balanceSheet.FinancialClaim(p1.interface, p2.interface, loanTerms[1], loanTerms[0])

				results.push({
					player: p2.id,
					borrow: {
						[loanTerms[0]]: loanTerms[1]
					}
				});

				results.push({
					player: p1.id,
					lend: {
						[p2.id]: {
							[loanTerms[0]]: loanTerms[1]
						}
					}
				});

			} else {
				var good = new balanceSheet.RealClaim(p1.interface, term[0], 0)
				good.transfer(p2.interface, term[1] * -1)

				results.push({ player: p1.id, [term[0]]: term[1] });
				results.push({ player: p2.id, [term[0]]: -1 * term[1] });
			}
		});


		if (utilityFunctions) {

			p1.score = utilityMode.toLowerCase() == "relative" ? p1.score + utilityFunctions[0](results) :
				utilityFunctions[0](results)
			p2.score = utilityMode.toLowerCase() == "relative" ? p2.score + utilityFunctions[1](results) :
				utilityFunctions[1](results)
		}

		return results;
	}, { id: "Distribution" });

	//But only do it if the trade goes through.
	Distribute(Decision.Accept.Accept())



	return Sequence(Decision, Distribute, parameters);
}, {
	argumentValidator(players, termsOfTrade) {
		// TODO: validate parameters
		return true;
	}

});

module.exports = Exchange;

},{"../lib/engine":6,"./simple-normal":77}],69:[function(require,module,exports){
"use strict";

var StockGames = {
	//Game skeletons
	"Two-Player Normal": require("./simple-normal").TwoPlayerNormal,
	"Normal": require("./simple-normal").Normal,
	"Simple Zero-Sum": require("./simple-zero-sum"),

	// Classic games
	"Battle Of The Sexes": require("./battle-of-the-sexes"),
	"Matching Pennies": require("./matching-pennies"),
	"Prisoner's Dilemma": require("./prisoner-dilemma"),
	"Rock-Paper-Scissors": require("./rock-paper-scissors"),

	// Iterated games
	"Iterated": require("./iterated"),
	"Iterated Prisoner's Dilemma": require("./iterated-prisoner-dilemma"),

	// Evolutionary games
	"Cultural Evolution": require("./cultural-evolution"),

	//Tournaments
	"Round Robin": require("./round-robin"),
	"Axelrod Tournament": require("./axelrod-tournament"),

	// Probability Theory
	"Monty Hall": require("./monty-hall"),

	//Neoclassical economics
	"Exchange": require("./exchange-complex"),

	// Function to display loaded query shortcuts.
	queries() {
		return Object.keys(registry.queries).map(function(query) {
			return {
				[query]: registry.queries[query].description
			}
		})
	}
};



module.exports = StockGames;

},{"./axelrod-tournament":65,"./battle-of-the-sexes":66,"./cultural-evolution":67,"./exchange-complex":68,"./iterated":71,"./iterated-prisoner-dilemma":70,"./matching-pennies":72,"./monty-hall":73,"./prisoner-dilemma":74,"./rock-paper-scissors":75,"./round-robin":76,"./simple-normal":77,"./simple-zero-sum":78}],70:[function(require,module,exports){
"use strict";

// Base game
var prisonerDilemma = require("./prisoner-dilemma").createGenerator();

// NashJS engine components
var Engine = require("../lib/engine")

// game engine
var { Loop } = Engine.Frontend.Playables;

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// Game utility
var Iterated = require("./iterated")



var IteratedPrisonerDilemma = gameWrapper(function(players, numberIterations = 50, parameters = {}) {
	return Iterated(players, prisonerDilemma, "Prisoner-Dilemma", numberIterations, parameters)
}, {
	queries: [{
			shortcut: "@IPD-choices",
			query: "$map($.[action].results, function($l){$l.result})",
			description: "Results, organized by round."
		},
		{
			shortcut: "@IPD-players",
			query: "$map($.[action].results, function($l){$l.player})",
			description: "Players, organized by round."
		},
		{
			shortcut: "@IPD-payouts",
			query: "$.action.payouts",
			description: "Payouts, as array of objects."
		}
	],
	strategyLoader() {
		return [{
				name: "Tit For Tat",
				description: "Do whatever your opponent did last turn. Cooperate if this is the first turn.",
				strategy: function titForTat() {
					this.choose = function(choices, information) {
						if (information.opponent.history.length) return information.opponent.history[information.opponent
								.history.length - 1]
							.result
						else return "Cooperate";
					}
				}
			},
			{
				name: "Grudger",
				description: "Cooperate until your opponent doesn't, then Defect.",
				strategy: function grudger() {
					this.cooperating = true

					this.choose = function(choices, information) {

						// If opponent just defected, then stop cooperating
						if (information.opponent.history.length) {
							if (information.opponent.history[information.opponent.history.length - 1].result == "Defect") this
								.cooperating = false;
						}

						if (this.cooperating) return "Cooperate";
						else return "Defect";
					}
				}
			},

			{
				name: "Naive Prober",
				description: "Like Tit For Tat, but occasionally Defects with small probability",
				strategy: function prober(probability = 0.1) {
					this.choose = function(choices, information) {
						if (Math.random() < probability) return "Defect";

						if (information.opponent.history.length) return information.opponent.history[information.opponent
								.history.length - 1]
							.result
						else return "Cooperate";
					}
				}
			},

			{
				name: "Tit For Two Tats",
				description: "Cooperates on the first move, then Defects only when the opponent Defects two times",
				strategy: function TF2T() {
					this.choose = function(choices, information) {
						if (information.opponent.history.length > 1) {
							if (information.opponent.history[information.opponent.history.length - 1].result == "Defect" &&
								information.opponent.history[information.opponent.history.length - 2].result == "Defect") return "Defect";
							else return "Cooperate";
						} else return "Cooperate";
					}
				}
			}

		]
	}
});
// TODO validate arguments

module.exports = IteratedPrisonerDilemma

},{"../lib/engine":6,"./iterated":71,"./prisoner-dilemma":74}],71:[function(require,module,exports){
"use strict";

// NashJS engine components
var Engine = require("../lib/engine")

// game engine
var { Loop } = Engine.Frontend.Playables;

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")


var Iterated = gameWrapper(function(players, gameGenerator, gameName, numberIterations = 50, parameters = {}) {

	var { parameters: gameParameters = {} } = parameters

	gameParameters.id = gameParameters.id || gameName
	parameters.id = parameters.id || "Iterated-" + gameName;

	return Loop(gameGenerator(players, gameParameters), numberIterations, parameters);
})

// TODO validate arguments

module.exports = Iterated;

},{"../lib/engine":6}],72:[function(require,module,exports){
"use strict";

// base game
var SimpleZeroSum = require("./simple-zero-sum");

// NashJS engine components
var Engine = require("../lib/engine")

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// Play-time logic
var { Expression } = Engine.Frontend


var MatchingPennies = gameWrapper(function(players, parameters = {}) {
	parameters.id = parameters.id || "Matching-Pennies";
	payoff = parameters.payoff || 1;

	var win = payoff;
	var lose = Expression(function() {
		return -payoff;
	});

	var choices = [
		["Heads", "Tails"],
		["Heads", "Tails"]
	];

	var payoffs = [
		[win, lose],
		[lose, win]
	];

	return SimpleZeroSum(players, choices, payoffs, parameters);
});

// Matching Pennies
module.exports = MatchingPennies;

},{"../lib/engine":6,"./simple-zero-sum":78}],73:[function(require,module,exports){
"use strict"

// NashJS engine components
var Engine = require("../lib/engine");

// Playables
var { Choice, Lambda } = Engine.Frontend.Playables;

// logic
var { Variable, ComplexVariable } = Engine.Frontend

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games");


var MontyHall = gameWrapper(function(player, parameters = {}) {
	parameters.id = parameters.id || "Monty-Hall"
	var numDoors = parameters.numDoors || 3;
	var numPrizes = parameters.numPrizes || 1;
	var numReveals = parameters.numReveals || 1;
	var prize = parameters.prize || 5;

	// Allow array or single player
	if (Array.isArray(player)) player = player[0]

	//Generate list of doors
	var doors = [];
	for (var i = 0; i < numDoors; i++) {
		doors.push("Door " + i.toString())
	}

	var Choose = Choice(player, doors, { id: "Choose" });


	var prizes
	var scores = Array.apply(null, Array(doors.length)).map(function() {
		return Variable(0)
	})

	//Need to set this here in order for scoring to work
	var doors2 = ComplexVariable(doors.slice());

	var Reveal = Lambda(function({ history }) {

		// Re-initialize payoffs.
		prizes = []
		for (var i = 0; i < scores.length; i++) {
			scores[i].set(0)
		}

		// What door did the player open?
		var playerChoice = history.log.query("$[choice='" + Choose.id() + "'][-1]").result // TODO does this work?

		// Select which doors have prizes
		var revealFrom = doors.slice(); // Copy the doors list
		for (var i = 0; i < numPrizes; i++) {
			var prizeIndex = Math.floor(Math.random() * revealFrom.length) // Select a door from the doors copy
			prizes.push(revealFrom[prizeIndex]) // Add the prize to the lists
			scores[prizeIndex].set(prize) // Set payoffs appropriately
			revealFrom.splice(prizeIndex, 1) // Remove the prized door from the doors copy, so that we don't select it more than once
		}

		//Remove player choice from doors copy
		var playerChoiceIndex = revealFrom.indexOf(playerChoice)
		if (playerChoiceIndex > -1) revealFrom.splice(playerChoiceIndex, 1)

		// Choose doors to reveal
		var reveal = [];
		for (var i = 0; i < numReveals; i++) {
			reveal.push(revealFrom[Math.floor(Math.random()) * revealFrom.length])
		}

		// Copy doors list to send onward, then remove the revealed doors from list
		doors2.set(doors.slice()); // Need to set this here so revealing to work
		for (var i = 0; i < reveal.length; i++) {
			let index = doors2.indexOf(reveal[i])
			doors2().splice(index, 1)
		}

		return reveal.length == 1 ? reveal[0] : reveal;
	}, { id: "Reveal" })

	var SecondChoice = Choice(player, doors2, { id: "Stay-or-Switch", usePayoffs: true });
	SecondChoice.setAllPayoffs(scores)

	Reveal(Choose)
	SecondChoice(Reveal)

	return Sequence(Choose, SecondChoice, parameters);
}, {

	strategyLoader() {
		return [{
				name: "Always Switch",
				description: "Randomly select a door. Then, always switch to a different one.",

				strategy: function alwaysSwitch() {

					this.door = null;

					this.choose = function(options, information) {
						var choice
						if (this.door) {
							options.splice(options.indexOf(this.door), 1)
							this.door = null;
							choice = options[Math.floor(Math.random() * options.length)]
						} else {
							choice = options[Math.floor(Math.random() * options.length)]
							this.door = choice
						}

						return choice
					}
				}
			},
			{
				name: "Always Stay",
				description: "Randomly select a door. Then, always stay with that door.",

				strategy: function alwaysStay() {
					this.door = null;

					//TODO add strategy description feature
					this.choose = function(options, information) {
						var choice
						if (this.door) {
							choice = this.door
							this.door = null;

						} else {
							choice = options[Math.floor(Math.random() * options.length)]
							this.door = choice
						}

						return choice
					}
				}
			}
		]
	}
})

module.exports = MontyHall

},{"../lib/engine":6}],74:[function(require,module,exports){
"use strict";

// base game
var TwoPlayerNormal = require("./simple-normal").TwoPlayerNormal;

//NashJS engine components
var Engine = require("../lib/engine")

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games");

// play-time logic
var { Variable, Expression } = Engine.Frontend;


var prisonerDilemma = gameWrapper(function(players, parameters = {}) {
	parameters.id = parameters.id || "Prisoner-Dilemma";
	var payoffs = parameters.payoffs || [Variable(1), Variable(2), Variable(3), Variable(4)];


	// sort numbers because the wrong order would screw up the game
	payoffs.sort()
	var sucker = payoffs[0]
	var punishment = payoffs[1]
	var reward = payoffs[2]
	var temptation = payoffs[3]


	var choices = [
		["Cooperate", "Defect"],
		["Cooperate", "Defect"]
	];
	var gamePayoffs = [
		[
			[reward, reward],
			[sucker, temptation]
		],
		[
			[temptation, sucker],
			[punishment, punishment]
		]
	];

	return TwoPlayerNormal(players, choices, gamePayoffs, parameters);
});


module.exports = prisonerDilemma;

},{"../lib/engine":6,"./simple-normal":77}],75:[function(require,module,exports){
"use strict";

// base game
var SimpleZeroSum = require("./simple-zero-sum");

var Engine = require("../lib/engine")

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// Play-time logic
var { Expression } = Engine.Frontend


// Rock-Paper-Scissors
var RockPaperScissors = gameWrapper(function(players, parameters = {}) {
	parameters.id = parameters.id || "Rock-Paper-Scissors";
	parameters.payoff = parameters.payoff || 1;

	var win = parameters.payoff;
	var lose = Expression(function() {
		return -payoff;
	});

	var choices = [
		["Rock", "Paper", "Scissors"],
		["Rock", "Paper", "Scissors"]
	];
	var payoffs = [
		[0, lose, win],
		[win, 0, lose],
		[lose, win, 0]
	];

	return SimpleZeroSum(players, choices, payoffs, parameters);
});

module.exports = RockPaperScissors

},{"../lib/engine":6,"./simple-zero-sum":78}],76:[function(require,module,exports){
"use strict";

//NashJS Engine
var Engine = require("../lib/engine")

// helper function
var { shuffle } = Engine.Backend.HelperFunctions("general");
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// nashJS engine component
var { Sequence, Simultaneous } = Engine.Frontend.Playables;

//for information mechanics
var { Information, History, PlayerList } = Engine.Backend.Classes;


// gameGenerator should be a function whose first argument is an array of players
var RoundRobin = gameWrapper(function(players, gameGenerator, parameters = {}) {
	parameters.id = parameters.id || "Round-Robin";
	parameters.initializePlayers = parameters.initializePlayers && true;

	// Create array of each combination of players
	var matches = [];

	players.forEach(function(player1, index1) {
		for (var index2 = 0; index2 < index1; index2++) {
			matches.push([players[index2], player1]);
		}

		// optional parameter 'copies.' Pass an extra copy of each player, to play themselves
		if (parameters.copies) matches.push([parameters.copies[index1], player1]);
	});

	//randomize the order
	shuffle(matches);

	// Track scores
	var scoresRecord = [];

	//
	var addRound = function(players, parameters = {}) {
		// information mechanics and other parameters
		var population = new PlayerList(players).generator
		parameters.compartmentalize = { population }
		parameters.initializePlayers = population;

		// generate round
		var round = gameGenerator(players, parameters);

		// track the scores
		var recordScores = Lambda(function() {
			var score = {}
			for (let [strategy, scores] of Object.entries(population().scoresByStrategy())) {
				if (Array.isArray(scores)) {
					if (scores.length == 1) scores = scores[0]
					score[strategy] = scores;
				}
			}
			scoresRecord.push(score);

			//return score for history
			return score;
		}, { id: "Record-Scores" });

		//Chain together
		recordScores(round);

		// return both
		return [round, recordScores
			// ,Sequence(round, recordScores) // Uncomment for Simultaneous implementation
		];
	};



	// Sequential implementation
	// load the first match manually
	var [firstRound, firstRecord] = addRound(
		matches.shift(),
		parameters.parameters
	);

	//then load subsequent matches
	var record = firstRecord;
	var lastRecord, lastRound;

	matches.forEach(function(match) {
		[lastRound, lastRecord] = addRound(match, parameters.parameters);

		lastRound(record);
		record = lastRecord;
	});


	return Sequence(firstRound, lastRecord, parameters);

	/* // Simultaneous implementation
	var rounds = [];
	matches.forEach(function(match) {
	  rounds.push(addRound(match, parameters.gameParameters)[2]);
	});

	return Simultaneous(rounds, parameters); */
});

module.exports = RoundRobin;

},{"../lib/engine":6}],77:[function(require,module,exports){
"use strict";

//Game engine
var Engine = require("../lib/engine")

//Helper functions
var { isFunction } = Engine.Backend.HelperFunctions("general")
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// Playables
var { Turn, Choice, RandomPlayerChoice } = Engine.Frontend.Playables;

//Play-time Logic
var { RandomVariable } = Engine.Frontend


var Normal = gameWrapper(function(players, choiceLists, payoffs = null, parameters = {}) {

		//propogate the information filter
		parameters.parameters ? parameters.parameters.informationFilter = parameters.informationFilter :
			parameters.parameters = { informationFilter: parameters.informationFilter }

		// construct the choices
		var choices = choiceLists.map(function(list, index) {
			return players == "random" ? RandomPlayerChoice(list, parameters.parameters) : Choice(players[index],
				list, parameters.parameters);
		});

		var game = Turn(choices, parameters);

		if (payoffs) game.setAllPayoffs(payoffs);

		return game;
	}, {
		queries: [{
				shortcut: "@N-choices",
				query: "$.results{player:result}",
				description: "Normal: Players and their choice."
			},
			{
				shortcut: "@N-payouts",
				query: "$.payouts",
				description: "Normal: Payouts object, by player."
			},
			{
				shortcut: "@N-players",
				query: "$.results.player",
				description: "Normal: Who played."
			}
		],
		strategyLoader: function() {
			return [{
					strategy: function chooseFirst() {
						this.choose = function(choices, information) {
							return choices[0]
						}
					},
					name: "Choose First",
					description: "Always choose first available option."
				},

				{
					strategy: function chooseSecond() {
						this.choose = function(choices, information) {
							return choices[1]
						}
					},
					name: "Choose Second",
					description: "Always choose second available option."
				},

				{
					strategy: function randomize(choices = [0, 1]) {
						// Creating a map will make picking a random value easier
						choices = choices.map(function(item, index) {
							return [index, item]
						});
						var choiceMap = new Map(choices)

						this.choose = function(choices, information) {
							return choices[choiceMap.get(Math.floor(Math.random() * choiceMap.size))];
						}
					},
					name: "Randomize",
					description: "Choose randomly from available options."
				}
			];
		}
	} // 										TODO: validate all arguments
);


var TwoPlayerNormal = gameWrapper(function(players, choices, payoffs = null, parameters = {}) {

	// Information mechanics.. There are only two players, so we can have a 'me' and 'opponent' entry.
	// If user supplied an information filter, wrap that filter in ours.
	var { informationFilter } = parameters;
	if (!isFunction(informationFilter)) informationFilter = null;

	// Wrap the user's filter
	var wrappedFilter = function(information) {
		// Figure out who I am and who the opponent is
		var me = information.me.id
		var players = [information.turn.choices[0].choice.player, information.turn.choices[1].choice.player]
		var opponent = players.splice(players.indexOf(me), 1) && players[0];

		// add entry for opponent
		var opponentDetail = information.population.filter(function(player) {
			return (player.id == opponent)
		})[0];
		information.opponent = opponentDetail;

		// run the user's information filter
		if (informationFilter) information = informationFilter(information);

		return information;
	}

	// Pass the information filter
	parameters.informationFilter = wrappedFilter

	return Normal(players, choices, payoffs, parameters)
}); //				 																												TODO: may want to validate arguments here too



module.exports = { TwoPlayerNormal, Normal };

},{"../lib/engine":6}],78:[function(require,module,exports){
"use strict";

// base game
var TwoPlayerNormal = require("./simple-normal").TwoPlayerNormal;

// NashJS components
var Engine = require("../lib/engine")

// Game state controller
var { registry } = Engine.Backend.State
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games");

// Play-time logic
var { Variable, Expression } = Engine.Frontend;

/* beautify preserve:start */
var SimpleZeroSum = gameWrapper(function(players, choices, payoffs = [[0, 0],	[0, 0]], parameters={}) {
/* beautify preserve:end */

	var game = TwoPlayerNormal(players, choices, null, parameters)

	var e;

	choices[0].forEach(function(choice0, index0) {
		choices[1].forEach(function(choice1, index1) {

			// Set expression
			e = Expression(function() {
				//Return the negative payoff, or zero
				return (0 - registry.turns[game.id()].payoffsImplicit[choice0][choice1][0] || 0);
			});

			//Set payoffs
			game[choice0][choice1]([payoffs[index0][index1], e]);
		});
	});

	return game;
}); //					TODO: validate arguments



module.exports = SimpleZeroSum;

},{"../lib/engine":6,"./simple-normal":77}]},{},[5])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwiLi4vLi4vLi4vLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJpbmRleC5qcyIsImxhYi9sYWIuanMiLCJsaWIvZW5naW5lLmpzIiwibGliL2hlbHBlci1mdW5jdGlvbnMvZ2VuZXJhbC5qcyIsImxpYi9oZWxwZXItZnVuY3Rpb25zL2luZGV4LmpzIiwibGliL2hlbHBlci1mdW5jdGlvbnMvbG9naWMuanMiLCJsaWIvaGVscGVyLWZ1bmN0aW9ucy9wbGF5YWJsZS5qcyIsImxpYi9oZWxwZXItZnVuY3Rpb25zL3BsYXllci5qcyIsImxpYi9oZWxwZXItZnVuY3Rpb25zL3N0YXRlLmpzIiwibGliL2hlbHBlci1mdW5jdGlvbnMvc3RvY2stZ2FtZXMuanMiLCJsaWIvaGVscGVyLWZ1bmN0aW9ucy90b3VybmFtZW50LmpzIiwibGliL2hlbHBlci1mdW5jdGlvbnMvdHVybi5qcyIsImxpYi9oaXN0b3J5LmpzIiwibGliL2luZm9ybWF0aW9uLmpzIiwibGliL2xvZ2dlci5qcyIsImxpYi9sb2dpYy5qcyIsImxpYi9wbGF5YWJsZXMvY2hvaWNlLmpzIiwibGliL3BsYXlhYmxlcy9jb25zZWN1dGl2ZS5qcyIsImxpYi9wbGF5YWJsZXMvaGFsdC1pZi5qcyIsImxpYi9wbGF5YWJsZXMvaW5kZXguanMiLCJsaWIvcGxheWFibGVzL2xhbWJkYS5qcyIsImxpYi9wbGF5YWJsZXMvbG9vcC5qcyIsImxpYi9wbGF5YWJsZXMvcGxheWFibGUuanMiLCJsaWIvcGxheWFibGVzL3BvcHVsYXRpb24tZHluYW1pY3MuanMiLCJsaWIvcGxheWFibGVzL3JhbmRvbS1wbGF5ZXItY2hvaWNlLmpzIiwibGliL3BsYXlhYmxlcy9zZXF1ZW5jZS5qcyIsImxpYi9wbGF5YWJsZXMvc2ltdWx0YW5lb3VzLmpzIiwibGliL3BsYXlhYmxlcy9zdG9jaGFzdGljLWhhbHQuanMiLCJsaWIvcGxheWFibGVzL3N0b2NoYXN0aWNMb29wLmpzIiwibGliL3BsYXlhYmxlcy90dXJuLmpzIiwibGliL3BsYXllci5qcyIsImxpYi9wbHVnaW4tbWFuYWdlci9hc3luYy1jdHguanMiLCJsaWIvcGx1Z2luLW1hbmFnZXIvaW5kZXguanMiLCJsaWIvcGx1Z2luLW1hbmFnZXIvcGx1Z2luLWNhbGxiYWNrLWVycm9yLmpzIiwibGliL3BsdWdpbi1tYW5hZ2VyL3BsdWdpbi1uYW1lLWVycm9yLmpzIiwibGliL3BsdWdpbi1tYW5hZ2VyL3dhdGVyZmFsbC1jdHguanMiLCJsaWIvcG9wdWxhdGlvbi5qcyIsImxpYi9xdWVyeS5qcyIsImxpYi9zdGF0ZS5qcyIsImxpYi9zdHJhdGVneS1sb2FkZXIuanMiLCJsaWIvc3RyYXRlZ3kuanMiLCJub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hbnNpLXN0eWxlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9kaXN0L2FzeW5jLmpzIiwibm9kZV9tb2R1bGVzL2NoYWxrL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NoYWxrL25vZGVfbW9kdWxlcy9zdXBwb3J0cy1jb2xvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lc2NhcGUtc3RyaW5nLXJlZ2V4cC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lc3ByaW1hL2Rpc3QvZXNwcmltYS5qcyIsIm5vZGVfbW9kdWxlcy9leHByZXNzaW9uLXNhbmRib3gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXhwcmVzc2lvbi1zYW5kYm94L2xpYi9tYWtlLXNhZmUuanMiLCJub2RlX21vZHVsZXMvaGFzLWFuc2kvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbmF0YS9qc29uYXRhLmpzIiwibm9kZV9tb2R1bGVzL2xvZ2xldmVsLWNvbG9yZWQtbGV2ZWwtcHJlZml4L2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIiwibm9kZV9tb2R1bGVzL3ByZXNlbnQvbGliL3ByZXNlbnQtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yYW5kZ2VuL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JhbmRnZW4vbGliL3JhbmRnZW4uanMiLCJub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zeW5jaHJvbm91cy1wcm9taXNlL2luZGV4LmpzIiwicGx1Z2lucy9iYWxhbmNlLXNoZWV0LWNvbXBsZXguanMiLCJwbHVnaW5zL2JhbGFuY2Utc2hlZXQuanMiLCJzdG9jay1nYW1lcy9heGVscm9kLXRvdXJuYW1lbnQuanMiLCJzdG9jay1nYW1lcy9iYXR0bGUtb2YtdGhlLXNleGVzLmpzIiwic3RvY2stZ2FtZXMvY3VsdHVyYWwtZXZvbHV0aW9uLmpzIiwic3RvY2stZ2FtZXMvZXhjaGFuZ2UtY29tcGxleC5qcyIsInN0b2NrLWdhbWVzL2luZGV4LmpzIiwic3RvY2stZ2FtZXMvaXRlcmF0ZWQtcHJpc29uZXItZGlsZW1tYS5qcyIsInN0b2NrLWdhbWVzL2l0ZXJhdGVkLmpzIiwic3RvY2stZ2FtZXMvbWF0Y2hpbmctcGVubmllcy5qcyIsInN0b2NrLWdhbWVzL21vbnR5LWhhbGwuanMiLCJzdG9jay1nYW1lcy9wcmlzb25lci1kaWxlbW1hLmpzIiwic3RvY2stZ2FtZXMvcm9jay1wYXBlci1zY2lzc29ycy5qcyIsInN0b2NrLWdhbWVzL3JvdW5kLXJvYmluLmpzIiwic3RvY2stZ2FtZXMvc2ltcGxlLW5vcm1hbC5qcyIsInN0b2NrLWdhbWVzL3NpbXBsZS16ZXJvLXN1bS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6K0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzaU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbDJKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9cmV0dXJuIGV9KSgpIiwiIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPVxuICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xudmFyIHNwbGl0UGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbn07XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGgocGF0aClbM107XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLy9NYWluIG1vZHVsZSBjb2RlXHJcbnZhciBOYXNoSlMgPSByZXF1aXJlKCcuL2xpYi9lbmdpbmUnKS5Gcm9udGVuZDtcclxuXHJcbi8vU3RvY2stZ2FtZXNcclxuTmFzaEpTLlN0b2NrR2FtZXMgPSByZXF1aXJlKCcuL3N0b2NrLWdhbWVzJyk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOYXNoSlM7XHJcbiIsIih7XHJcblx0UGxheWVyLFxyXG5cdF9QbGF5ZXIsXHJcblx0Z2FtZVBvcHVsYXRpb24sXHJcblx0UG9wdWxhdGlvbixcclxuXHRQbGF5ZXJMaXN0LFxyXG5cdHJlZ2lzdGVyU3RyYXRlZ3ksXHJcblx0U3RyYXRlZ2llcyxcclxuXHRzdHJhdGVneUxvYWRlcixcclxuXHRfZXhwb3NlLFxyXG5cdHJlZ2lzdHJ5LFxyXG5cdFZhcmlhYmxlLFxyXG5cdEV4cHJlc3Npb24sXHJcblx0UmFuZG9tVmFyaWFibGUsXHJcblx0Q29tcGxleFZhcmlhYmxlLFxyXG5cdEhpc3RvcnksXHJcblx0UXVlcmllcyxcclxuXHRleGNsdWRlZFBsYXllcnMsXHJcblx0c3RhcnRSRVBMLFxyXG5cdG5oaXN0b3J5LFxyXG5cdEluZm9ybWF0aW9uLFxyXG5cdFBlcmZlY3RJbmZvcm1hdGlvbixcclxuXHRQbHVnaW5NYW5hZ2VyXHJcbn0gPSByZXF1aXJlKFwiLi4vaW5kZXhcIikpO1xyXG4oe1xyXG5cdENob2ljZSxcclxuXHRUdXJuLFxyXG5cdFNlcXVlbmNlLFxyXG5cdENvbnNlY3V0aXZlLFxyXG5cdExvb3AsXHJcblx0U3RvY2hhc3RpY0xvb3AsXHJcblx0SGFsdElmLFxyXG5cdFN0b2NoYXN0aWNIYWx0LFxyXG5cdExhbWJkYSxcclxuXHRSYW5kb21QbGF5ZXJDaG9pY2UsXHJcblx0UG9wdWxhdGlvbkR5bmFtaWNzLFxyXG5cdFNpbXVsdGFuZW91c1xyXG59ID0gcmVxdWlyZShcIi4uL2luZGV4XCIpLlBsYXlhYmxlcyk7XHJcblN0b2NrR2FtZXMgPSByZXF1aXJlKFwiLi4vaW5kZXhcIikuU3RvY2tHYW1lcztcclxuXHJcblxyXG5cclxucDEgPSBQbGF5ZXIoKTtcclxucDIgPSBQbGF5ZXIoKTtcclxucDMgPSBQbGF5ZXIoKTtcclxuaXBkID0gU3RvY2tHYW1lc1tcIkl0ZXJhdGVkIFByaXNvbmVyJ3MgRGlsZW1tYVwiXShbcDEsIHAyXSwgMjApXHJcbi8qXHJcblN0b2NrR2FtZXNbXCJQcmlzb25lcidzIERpbGVtbWFcIl0oW3AxLCBwMl0pXHJcblxyXG5wMS5hc3NpZ24oXCJjaG9vc2VGaXJzdFwiKVxyXG5wMi5hc3NpZ24oXCJyYW5kb21pemVcIik7XHJcblxyXG5wMyA9IFBsYXllcigpO1xyXG5wMy5hc3NpZ24oXCJjaG9vc2VTZWNvbmRcIik7XHJcbnA0ID0gUGxheWVyKCk7XHJcbnA0LmFzc2lnbihcInJhbmRvbWl6ZVwiKVxyXG5cclxuYzEgPSBDaG9pY2UocDEsIFtcImNvb3BlcmF0ZVwiLCBcImRlZmVjdFwiXSk7XHJcbi8vYzFbJ2xlZnQnXSg1KSA7XHJcbi8vYzFbJ3JpZ2h0J10oMik7XHJcbmMyID0gQ2hvaWNlKHAyLCBbXCJDb29wZXJhdGVcIiwgXCJEZWZlY3RcIl0pO1xyXG4vL2MyWyd1cCddKDEpO1xyXG4vL2MyWydkb3duJ10oNyk7XHJcblxyXG50MiA9IFR1cm4oW2MxLCBjMl0pO1xyXG50MyA9IFR1cm4oW2MxLCBjMl0pO1xyXG50NCA9IFR1cm4oW2MxLCBjMl0pO1xyXG50NSA9IFR1cm4oW2MxLCBjMl0pO1xyXG5zMSA9IFNpbXVsdGFuZW91cyhbdDIsIHQzLCB0NCwgdDVdKVxyXG5cclxuYyA9IENvbnNlY3V0aXZlKFtcclxuXHRUdXJuKFtjMSwgYzJdKSxcclxuXHRUdXJuKFtjMiwgYzFdKSxcclxuXHRDaG9pY2UocDEsIFtcImNvb3BlcmF0ZVwiLCBcImRlZmVjdFwiXSksXHJcblx0TGFtYmRhKGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZyhcImhpXCIpIH0pLFxyXG5cdEhhbHRJZihmdW5jdGlvbigpIHsgcmV0dXJuIHRydWUgfSlcclxuXSlcclxuXHJcbmMzID0gUmFuZG9tUGxheWVyQ2hvaWNlKFtcImNvb3BlcmF0ZVwiLCBcImRlZmVjdFwiXSk7XHJcbmM0ID0gUmFuZG9tUGxheWVyQ2hvaWNlKFtcIkNvb3BlcmF0ZVwiLCBcIkRlZmVjdFwiXSk7XHJcblxyXG50MSA9IFR1cm4oW2MzLCBjNF0pO1xyXG5cclxudjEgPSBuZXcgVmFyaWFibGUoMyk7XHJcblxyXG50MS5kZWZlY3QuRGVmZWN0KFsyLCAyXSk7XHJcbnQxLmRlZmVjdC5Db29wZXJhdGUoWzQsIDFdKTtcclxudDEuY29vcGVyYXRlLkRlZmVjdChbMSwgNF0pO1xyXG50MS5jb29wZXJhdGUuQ29vcGVyYXRlKFt2MSwgdjFdKTtcclxuXHJcbkwxID0gTGFtYmRhKGZ1bmN0aW9uKCkge1xyXG5cdHYxLnNldCh2MSArIDEpO1xyXG59KTtcclxuXHJcbnBkMSA9IFBvcHVsYXRpb25EeW5hbWljcygxLjUsIDEpO1xyXG5cclxuaDIgPSBIYWx0SWYoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFBvcHVsYXRpb24oKS5vbmx5QWxpdmUoKS5sZW5ndGggPT0gMDtcclxufSk7XHJcblxyXG5MMSh0MSk7XHJcbnBkMShMMSk7XHJcbmgyKHBkMSk7XHJcblxyXG4vL3MxID0gU2VxdWVuY2UodDEsIGgyKTtcclxuXHJcbi8vbDEgPSBMb29wKHMxLCAxMCwgeyBsb2dDb250aW51ZTogdHJ1ZSB9KTtcclxuXHJcbi8vY29uc29sZS5sb2coX2V4cG9zZSh0MSkubmV4dClcclxuLy9jb25zb2xlLmxvZyhfZXhwb3NlKHQxKS5uZXh0LmNvb3BlcmF0ZS5Db29wZXJhdGUpXHJcblxyXG5oMiA9IEhhbHRJZihmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gUG9wdWxhdGlvbigpLm9ubHlBbGl2ZSgpLmxlbmd0aCA9PSAwO1xyXG59KTtcclxuXHJcbkwyID0gTGFtYmRhKGZ1bmN0aW9uKCkge1xyXG5cdHAxLmtpbGwoKTtcclxufSk7XHJcblxyXG50MihMMik7XHJcblxyXG5nZW5lcmF0ZVBvcHVsYXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHRmb3IgKGkgPSAwOyBpIDwgMzA7IGkrKykge1xyXG5cdFx0UGxheWVyKHsgYXNzaWduOiBcImNob29zZUZpcnN0XCIgfSk7XHJcblx0fVxyXG5cdGZvciAoaSA9IDA7IGkgPCAzMDsgaSsrKSB7XHJcblx0XHRQbGF5ZXIoeyBhc3NpZ246IFwiY2hvb3NlU2Vjb25kXCIgfSk7XHJcblx0fVxyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2FtZUdlbmVyYXRvcigpIHtcclxuXHR2YXIgdCA9IFR1cm4oW1xyXG5cdFx0UmFuZG9tUGxheWVyQ2hvaWNlKFtcImNvb3BlcmF0ZVwiLCBcImRlZmVjdFwiXSksXHJcblx0XHRSYW5kb21QbGF5ZXJDaG9pY2UoW1wiQ29vcGVyYXRlXCIsIFwiRGVmZWN0XCJdKVxyXG5cdF0pO1xyXG5cclxuXHR0LmRlZmVjdC5EZWZlY3QoWzIsIDJdKTtcclxuXHR0LmRlZmVjdC5Db29wZXJhdGUoWzQsIDFdKTtcclxuXHR0LmNvb3BlcmF0ZS5EZWZlY3QoWzEsIDRdKTtcclxuXHR0LmNvb3BlcmF0ZS5Db29wZXJhdGUoWzMsIDNdKTtcclxuXHJcblx0cmV0dXJuIHQ7XHJcbn1cclxuLy9cclxuLy9cclxuLy9cclxuXHJcbi8vQ0UgPSBTdG9ja0dhbWVzW1wiQ3VsdHVyYWwgRXZvbHV0aW9uXCJdKGdhbWVHZW5lcmF0b3IsIDEsIHtnZW5lcmF0ZVBvcHVsYXRpb259KTtcclxuXHJcbi8vbiA9IFN0b2NrR2FtZXNbXCJUd28tUGxheWVyIE5vcm1hbFwiXShwMSxwMixbW1wibGVmdFwiLFwicmlnaHRcIl0sW1widXBcIixcImRvd25cIl1dKTtcclxuLy9wZDEgPSBTdG9ja0dhbWVzW1wiUHJpc29uZXIncyBEaWxlbW1hXCJdKFtwMSwgcDJdKTtcclxuLy9wZDIgPSBTdG9ja0dhbWVzW1wiUHJpc29uZXIncyBEaWxlbW1hXCJdKFtwMywgcDRdKTtcclxuXHJcbi8vcyA9IFNpbXVsdGFuZW91cyhbcGQxLCBwZDJdKVxyXG5cclxudjIgPSBWYXJpYWJsZSgxKTtcclxuXHJcbi8vbiA9IFN0b2NrR2FtZXNbXCJTaW1wbGUgWmVyby1TdW1cIl0ocDEscDIsW1tcImxlZnRcIixcInJpZ2h0XCJdLFtcInVwXCIsXCJkb3duXCJdXSwgW1t2MiwyXSxbMyw0XV0pO1xyXG5cclxuLy9ycGMgPSBTdG9ja0dhbWVzW1wiUm9jay1QYXBlci1TY2lzc29yc1wiXShbcDEsIHAyXSk7XHJcbi8vdCA9IFN0b2NrR2FtZXNbXCJBeGVscm9kIFRvdXJuYW1lbnRcIl07XHJcbi8vdCA9IFN0b2NrR2FtZXNbXCJJdGVyYXRlZCBQcmlzb25lcidzIERpbGVtbWFcIl0oW3AxLCBwMl0pO1xyXG4vL1RoZSBjb2RlIGJlbG93IGlzIHRvIHJ1biB0aGUgcmVwbCBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cclxuLy92YXIgdG9SZXBsID0ge19leHBvc2UsIHJlZ2lzdHJ5LFBsYXllcixDaG9pY2UsVHVybixTZXF1ZW5jZSxMb29wLFN0b2NoYXN0aWNMb29wLEhhbHRJZiwgU3RvY2hhc3RpY0hhbHQsIExhbWJkYSwgcDEsYzEsYzIsdDF9O1xyXG4vL3N0YXJ0UkVQTCh0b1JlcGwpO1xyXG4qL1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIFN0YXJ0IHBsdWctaW4gbWFuYWdlclxyXG52YXIgUGx1Z2luTWFuYWdlciA9IHJlcXVpcmUoXCIuL3BsdWdpbi1tYW5hZ2VyXCIpXHJcblBsdWdpbk1hbmFnZXIuc3RhcnQoZnVuY3Rpb24oKSB7fSlcclxuXHJcblxyXG4vL0xvZ2dpbmdcclxudmFyIGxvZyA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcclxubG9nLnNldExldmVsKFwiaW5mb1wiKTtcclxubG9nKFwiaW5mb1wiLCBcIlN0YXJ0aW5nIE5hc2hKU1wiKTtcclxuXHJcblxyXG4vL0dhbWUgc3RhdGUgY29udHJvbGxlcnNcclxudmFyIHsgcmVnaXN0cnksIGlkQ291bnRlcnMgfSA9IHJlcXVpcmUoJy4vc3RhdGUnKTtcclxuXHJcblxyXG4vLyBRdWVyeSBsYW5ndWFnZSBhbmQgc2hvcnRjdXRzXHJcbnZhciB7IFF1ZXJpZXMsIFF1ZXJ5LCBRdWVyeVJlc3VsdCwgZXZhbHVhdGVRdWVyeSwgcmVnaXN0ZXJRdWVyeU9iamVjdCB9ID0gcmVxdWlyZShcIi4vcXVlcnlcIik7XHJcblxyXG5cclxuLy8gSGlzdG9yeVxyXG52YXIgeyBnYW1lSGlzdG9yeSwgdXNlckdhbWVIaXN0b3J5LCBIaXN0b3J5LCBVc2VySGlzdG9yeSB9ID0gcmVxdWlyZSgnLi9oaXN0b3J5Jyk7XHJcblxyXG5cclxuLy9QbGF5ZXJzXHJcbnZhciB7IF9QbGF5ZXIsIFBsYXllciB9ID0gcmVxdWlyZSgnLi9wbGF5ZXInKTtcclxucmVnaXN0cnkuX2FkZFR5cGVfKFwicGxheWVyc1wiKTtcclxuaWRDb3VudGVycy5fYWRkVHlwZV8oXCJwbGF5ZXJcIik7XHJcblxyXG5cclxuLy9Qb3B1bGF0aW9uXHJcbnZhciB7IGdhbWVQb3B1bGF0aW9uLCBQb3B1bGF0aW9uLCBQbGF5ZXJMaXN0LCBVc2VyUGxheWVyTGlzdCB9ID0gcmVxdWlyZSgnLi9wb3B1bGF0aW9uJyk7XHJcblxyXG5cclxuLy9JbmZvcm1hdGlvbiBtZWNoYW5pY3NcclxudmFyIHsgSW5mb3JtYXRpb24sIFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0gcmVxdWlyZShcIi4vaW5mb3JtYXRpb25cIik7XHJcblxyXG5cclxuLy9QbGF5YWJsZXNcclxudmFyIHsgcGxheWFibGVDbGFzc2VzLCBwbGF5YWJsZUludGVyZmFjZXMgfSA9IHJlcXVpcmUoJy4vcGxheWFibGVzLycpXHJcbmZvciAodmFyIF9jbGFzcyBpbiBwbGF5YWJsZUNsYXNzZXMpIHtcclxuXHRyZWdpc3RyeS5fYWRkVHlwZV8ocGxheWFibGVDbGFzc2VzW19jbGFzc10ucmVnaXN0cnlOYW1lKTtcclxuXHRpZENvdW50ZXJzLl9hZGRUeXBlXyhwbGF5YWJsZUNsYXNzZXNbX2NsYXNzXS5jb3VudGVyTmFtZSk7XHJcbn1cclxuXHJcbi8vU3ltYm9saWMgTG9naWNcclxudmFyIHtcclxuXHR2YXJpYWJsZVByb3RvdHlwZSxcclxuXHRWYXJpYWJsZSxcclxuXHRleHByZXNzaW9uUHJvdG90eXBlLFxyXG5cdEV4cHJlc3Npb24sXHJcblx0UmFuZG9tVmFyaWFibGUsXHJcblx0Q29tcGxleFZhcmlhYmxlXHJcbn0gPSByZXF1aXJlKFwiLi9sb2dpY1wiKTtcclxuXHJcblxyXG4vL1N0cmF0ZWdpZXNcclxucmVnaXN0cnkuX2FkZFR5cGVfKFwic3RyYXRlZ2llc1wiKTtcclxuaWRDb3VudGVycy5fYWRkVHlwZV8oXCJzdHJhdGVneVwiKTtcclxuXHJcbnZhciB7IHJlZ2lzdGVyU3RyYXRlZ3ksIHJlZ2lzdGVyU3RyYXRlZ3lPYmplY3QsIFN0cmF0ZWdpZXMgfSA9IHJlcXVpcmUoJy4vc3RyYXRlZ3knKTtcclxudmFyIHsgbG9hZFN0cmF0ZWd5LCBsb2FkU3RyYXRlZ3lGb2xkZXIgfSA9IHJlcXVpcmUoJy4vc3RyYXRlZ3ktbG9hZGVyJyk7XHJcblxyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIGxvYWRlclxyXG52YXIgSGVscGVyRnVuY3Rpb25zID0gcmVxdWlyZSgnLi9oZWxwZXItZnVuY3Rpb25zJyk7XHJcblxyXG5cclxuLy9USElTIEZVTkNUSU9OIElTIE9OTFkgRk9SIERFQlVHR0lORy4gUkVNT1ZFIElUIEZST00gTU9EVUxFIEVYUE9SVFMgV0hFTiBQVUJMSVNISU5HXHJcbmZ1bmN0aW9uIEV4cG9zZShpbnRlcmZhY2VQbGF5YWJsZSkge1xyXG5cdHJldHVybiByZWdpc3RyeS5wbGF5YWJsZXNbaW50ZXJmYWNlUGxheWFibGUuaWQoKV07XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBzdGFydFJFUEwodG9SRVBMKSB7XHJcblx0dmFyIHJlcGwgPSByZXF1aXJlKFwicmVwbFwiKTtcclxuXHJcblx0dmFyIHJlcGxTZXJ2ZXIgPSByZXBsLnN0YXJ0KHtcclxuXHRcdHByb21wdDogXCJOYXNoID4+IFwiXHJcblx0fSk7XHJcblxyXG5cdE9iamVjdC5hc3NpZ24ocmVwbFNlcnZlci5jb250ZXh0LCB0b1JFUEwpO1xyXG59XHJcblxyXG5cclxuXHJcbnZhciBFbmdpbmUgPSB7XHJcblx0RnJvbnRlbmQ6IHtcclxuXHRcdFBsYXllcixcclxuXHRcdF9QbGF5ZXIsIC8vUkVNT1ZFIFRISVMgTElORSBXSEVOIFBVQkxJU0hJTkdcclxuXHRcdGdhbWVQb3B1bGF0aW9uLCAvL1JFTU9WRSBUSElTIExJTkUgV0hFTiBQVUJMSVNISU5HXHJcblx0XHQnUGxheWVyTGlzdCc6IFVzZXJQbGF5ZXJMaXN0LFxyXG5cdFx0UG9wdWxhdGlvbixcclxuXHRcdC8vSW5mb3JtYXRpb24sIC8vUkVNT1ZFIFRISVMgTElORSBXSEVOIFBVQkxJU0hJTkdcclxuXHRcdC8vUGVyZmVjdEluZm9ybWF0aW9uLCAvL1JFTU9WRSBUSElTIExJTkUgV0hFTiBQVUJMSVNISU5HXHJcblx0XHQnUGxheWFibGVzJzogcGxheWFibGVJbnRlcmZhY2VzLFxyXG5cdFx0cmVnaXN0ZXJTdHJhdGVneSxcclxuXHRcdHJlZ2lzdGVyU3RyYXRlZ3lPYmplY3QsXHJcblx0XHRTdHJhdGVnaWVzLFxyXG5cdFx0bG9hZFN0cmF0ZWd5LFxyXG5cdFx0bG9hZFN0cmF0ZWd5Rm9sZGVyLFxyXG5cdFx0SGlzdG9yeTogdXNlckdhbWVIaXN0b3J5LFxyXG5cdFx0UXVlcmllcyxcclxuXHRcdC8vRXhwb3NlLCAvL1JFTU9WRSBUSElTIExJTkUgV0hFTiBQVUJMSVNISU5HXHJcblx0XHQvL3JlZ2lzdHJ5LCAvL1JFTU9WRSBUSElTIExJTkUgV0hFTiBQVUJMSVNISU5HXHJcblx0XHRzdGFydFJFUEwsIC8vU2hvdWxkIHRoaXMgbGluZSBiZSByZW1vdmVkIHdoZW4gcHVibGlzaGluZz9cclxuXHRcdFZhcmlhYmxlLFxyXG5cdFx0RXhwcmVzc2lvbixcclxuXHRcdFJhbmRvbVZhcmlhYmxlLFxyXG5cdFx0Q29tcGxleFZhcmlhYmxlLFxyXG5cdFx0Ly9QbHVnaW5NYW5hZ2VyIC8vUkVNT1ZFIFRISVMgTElORSBXSEVOIFBVQkxJU0hJTkdcclxuXHR9LFxyXG5cclxuXHRCYWNrZW5kOiB7XHJcblx0XHRsb2dnZXI6IGxvZyxcclxuXHRcdFN0YXRlOiB7IHJlZ2lzdHJ5LCBpZENvdW50ZXJzLCBnYW1lSGlzdG9yeSwgZ2FtZVBvcHVsYXRpb24sIFBlcmZlY3RJbmZvcm1hdGlvbiB9LFxyXG5cdFx0Q2xhc3Nlczoge1xyXG5cdFx0XHRQbGF5ZXI6IF9QbGF5ZXIsXHJcblx0XHRcdEhpc3RvcnksXHJcblx0XHRcdFVzZXJIaXN0b3J5LFxyXG5cdFx0XHRQbGF5ZXJMaXN0LFxyXG5cdFx0XHRVc2VyUGxheWVyTGlzdCxcclxuXHRcdFx0SW5mb3JtYXRpb24sXHJcblx0XHRcdFBsYXlhYmxlQ2xhc3NlczogeyBwbGF5YWJsZUNsYXNzZXMgfSxcclxuXHRcdFx0UXVlcnksXHJcblx0XHRcdFF1ZXJ5UmVzdWx0LFxyXG5cdFx0XHR2YXJpYWJsZVByb3RvdHlwZSxcclxuXHRcdFx0ZXhwcmVzc2lvblByb3RvdHlwZVxyXG5cdFx0fSxcclxuXHRcdEhlbHBlckZ1bmN0aW9ucyxcclxuXHRcdFBsdWdpbk1hbmFnZXIsXHJcblx0XHRyZWdpc3RlclF1ZXJ5T2JqZWN0LFxyXG5cdFx0RXhwb3NlXHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVuZ2luZTtcclxuIiwidmFyIGdlbmVyYWwgPSB7XHJcblx0Ly9DaGVjayBpZiB2YXJpYWJsZSBpcyBhbiBPYmplY3RcclxuXHRpc09iamVjdChhKSB7XHJcblx0XHRyZXR1cm4gISFhICYmIGEuY29uc3RydWN0b3IgPT09IE9iamVjdDtcclxuXHR9LFxyXG5cclxuXHQvL1doYXQgZG8geW91IHRoaW5rP1xyXG5cdGlzRnVuY3Rpb24oYSkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBhID09PSBcImZ1bmN0aW9uXCI7XHJcblx0fSxcclxuXHJcblx0Ly9Qcm92aWRlIGEgZnVuY3Rpb24sIGEgY29udGV4dCAoJ3RoaXMnKSwgYW5kIGFuIGFyZ3VtZW50IGFycmF5LlxyXG5cdC8vUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZC5cclxuXHRhcHBseUJpbmQoZnVuYywgdGhhdCwgYXJnQXJyYXkpIHtcclxuXHRcdHJldHVybiBmdW5jLmJpbmQuYXBwbHkoZnVuYywgW3RoYXRdLmNvbmNhdChhcmdBcnJheSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vV3JhcHMgYSBmdW5jdGlvbiB0byBlbnN1cmUgaXQgb25seSBnZXRzIGNhbGxlZCBvbmUgdGltZS5cclxuXHRvbmNlKGZuLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgcmVzdWx0O1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcclxuXHRcdFx0aWYgKGZuKSB7XHJcblx0XHRcdFx0cmVzdWx0ID0gZm4uYXBwbHkoY29udGV4dCB8fCB0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRcdGZuID0gbnVsbDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gUmFuZG9tbHkgcmUtb3JkZXIgYXJyYXlcclxuXHRzaHVmZmxlKGFycmF5KSB7XHJcblx0XHR2YXIgY3VycmVudEluZGV4ID0gYXJyYXkubGVuZ3RoLFxyXG5cdFx0XHR0ZW1wb3JhcnlWYWx1ZSxcclxuXHRcdFx0cmFuZG9tSW5kZXg7XHJcblxyXG5cdFx0Ly8gV2hpbGUgdGhlcmUgcmVtYWluIGVsZW1lbnRzIHRvIHNodWZmbGUuLi5cclxuXHRcdHdoaWxlICgwICE9PSBjdXJyZW50SW5kZXgpIHtcclxuXHRcdFx0Ly8gUGljayBhIHJlbWFpbmluZyBlbGVtZW50Li4uXHJcblx0XHRcdHJhbmRvbUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY3VycmVudEluZGV4KTtcclxuXHRcdFx0Y3VycmVudEluZGV4IC09IDE7XHJcblxyXG5cdFx0XHQvLyBBbmQgc3dhcCBpdCB3aXRoIHRoZSBjdXJyZW50IGVsZW1lbnQuXHJcblx0XHRcdHRlbXBvcmFyeVZhbHVlID0gYXJyYXlbY3VycmVudEluZGV4XTtcclxuXHRcdFx0YXJyYXlbY3VycmVudEluZGV4XSA9IGFycmF5W3JhbmRvbUluZGV4XTtcclxuXHRcdFx0YXJyYXlbcmFuZG9tSW5kZXhdID0gdGVtcG9yYXJ5VmFsdWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cdH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhbDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcclxuXHJcbmxvZyhcImRlYnVnXCIsIFwiaGVscGVyRnVuY3Rpb25zLWluZGV4OiBMb2FkaW5nIGhlbHBlciBmdW5jdGlvbnMgbG9hZGVyLlwiKTtcclxuXHJcbi8qXHJcbnZhciBnZW5lcmFsICA9IHJlcXVpcmUoJy4vZ2VuZXJhbCcpO1xyXG52YXIgcGxheWVyICAgPSByZXF1aXJlKCcuL3BsYXllcicpO1xyXG52YXIgcGxheWFibGUgPSByZXF1aXJlKCcuL3BsYXlhYmxlJyk7XHJcbnZhciB0dXJuIFx0ID0gcmVxdWlyZSgnLi90dXJuJyk7XHJcbnZhciBzdGF0ZSBcdCA9IHJlcXVpcmUoJy4vc3RhdGUnKTsgXHJcbiovXHJcblxyXG5mdW5jdGlvbiBsb2FkZXIoZmlsZSkge1xyXG5cdHJldHVybiByZXF1aXJlKFwiLi9cIiArIGZpbGUgKyBcIi5qc1wiKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBsb2FkZXI7XHJcbi8vbW9kdWxlLmV4cG9ydHMgPSB7Z2VuZXJhbCwgcGxheWVyLCBwbGF5YWJsZSwgdHVybiwgc3RhdGV9O1xyXG5cclxuLy8gSGFjayB0byBjb21waWxlIEdsb2IgZmlsZXMgKGluIGJyb3dzZXJpZnkpLiBEb27CtHQgY2FsbCB0aGlzIGZ1bmN0aW9uIVxyXG4oZnVuY3Rpb24oKSB7XHJcblx0cmVxdWlyZSgnLi9nZW5lcmFsLmpzJyk7cmVxdWlyZSgnLi9pbmRleC5qcycpO3JlcXVpcmUoJy4vbG9naWMuanMnKTtyZXF1aXJlKCcuL3BsYXlhYmxlLmpzJyk7cmVxdWlyZSgnLi9wbGF5ZXIuanMnKTtyZXF1aXJlKCcuL3N0YXRlLmpzJyk7cmVxdWlyZSgnLi9zdG9jay1nYW1lcy5qcycpO3JlcXVpcmUoJy4vdG91cm5hbWVudC5qcycpO3JlcXVpcmUoJy4vdHVybi5qcycpO1xyXG59KTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9naWMgPSB7XHJcblxyXG5cdC8vIENoZWNrIHRvIHNlZSBpZiBvYmplY3QgaXMgVmFyaWFibGUvRXhwcmVzc2lvbiBvciBub3QuIFJldHVybnMgdHJ1ZS9mYWxzZVxyXG5cdGlzTG9naWMobG9naWMpIHtcclxuXHJcblx0XHRpZiAobG9naWMgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBsb2dpYyA9PSBsb2dpYyAqIDEpIHJldHVybiB0cnVlXHJcblx0XHRlbHNlIHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGxvZ2ljO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciB7IFN5bmNocm9ub3VzUHJvbWlzZSB9ID0gcmVxdWlyZSgnc3luY2hyb25vdXMtcHJvbWlzZScpO1xyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKCcuLi9zdGF0ZScpO1xyXG5cclxudmFyIHBsYXlhYmxlID0ge1xyXG5cdC8vIEdlbmVyYXRlcyB0aGUgZnVuY3Rpb24gdGhhdCBnZXRzIHJldHVybmVkIHdoZW4gYSBQbGF5YWJsZSBpcyBjYWxsZWQsIHdoaWNoIGNhbiB0aGVuIGJlIGNhbGxlZCB0byBjaGFpbiBwbGF5YWJsZXMgdG9nZXRoZXIuXHJcblx0Y2hhaW5lckdlbmVyYXRvcihleHRlcm5hbE9iaiwgaW50ZXJuYWxPYmopIHtcclxuXHRcdGV4dGVybmFsT2JqID0gdGhpcztcclxuXHRcdHJldHVybiBmdW5jdGlvbihzb3VyY2UpIHtcclxuXHRcdFx0dmFyIHByZXZpb3VzUGxheWFibGUsIHBhdGg7XHJcblxyXG5cdFx0XHQvL1RPRE86IHZlcmlmeSB0aGF0IHNvdXJjZSBpcyB0aGUgcmlnaHQgdHlwZVxyXG5cclxuXHRcdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5hbGwoW2Z1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmIChzb3VyY2UgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHNvdXJjZSBpbnN0YW5jZW9mIFN5bmNocm9ub3VzUHJvbWlzZSkge1xyXG5cdFx0XHRcdFx0c291cmNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdFx0XHRcdHByZXZpb3VzUGxheWFibGUgPSByZWdpc3RyeS5wbGF5YWJsZXNbcmVzdWx0LnBsYXlhYmxlLmlkKCldO1xyXG5cdFx0XHRcdFx0XHRwYXRoID0gcmVzdWx0LnBhdGhcclxuXHRcdFx0XHRcdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKCk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKClcclxuXHRcdFx0fSgpLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHNvdXJjZSBpbnN0YW5jZW9mIFN5bmNocm9ub3VzUHJvbWlzZSkpIHtcclxuXHRcdFx0XHRcdHByZXZpb3VzUGxheWFibGUgPSByZWdpc3RyeS5wbGF5YWJsZXNbc291cmNlLmlkKCldO1xyXG5cdFx0XHRcdFx0cGF0aCA9IHNvdXJjZS5wYXRoO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoKTtcclxuXHRcdFx0fSgpXSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHJcblx0XHRcdFx0aWYgKHBhdGggPT0gXCJhbGxcIikgcHJldmlvdXNQbGF5YWJsZS5hZGROZXh0KGludGVybmFsT2JqKTtcclxuXHRcdFx0XHRlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRvdXRjb21lVHJlZUdldFZhbHVlKHByZXZpb3VzUGxheWFibGUubmV4dCwgcGF0aCkucHVzaChpbnRlcm5hbE9iaik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL3ByZXZpb3VzUGxheWFibGUubmV4dFtzZWxlY3RlZF0ucHVzaChfY2hvaWNlKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKHtcclxuXHRcdFx0XHRcdCdwbGF5YWJsZSc6IGV4dGVybmFsT2JqLFxyXG5cdFx0XHRcdFx0cGF0aDogXCJhbGxcIlxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblxyXG5cdC8vVXNlIHRvIHNldCBldmVyeSB2YWx1ZSBvZiBhbiBvdXRjb21lIHRyZWVcclxuXHRvdXRjb21lVHJlZUFkZEFsbCh0cmVlLCB2YWx1ZSkge1xyXG5cclxuXHRcdC8vSWYgaXQncyBhbiBhcnJheSwgdGhlbiB3ZSdyZSBhbHJlYWR5IGRvbmUuXHJcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xyXG5cdFx0XHR0cmVlLnB1c2godmFsdWUpOyAvL1VzZSBwdXNoIGhlcmUgYmVjYXVzZSB0aGlzIHdpbGwgYmUgYSB1bmlxdWUgYXJyYXlcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciByZWN1cnNlID0gZnVuY3Rpb24ob2JqLCB2YWwpIHtcclxuXHJcblx0XHRcdFx0Zm9yICh2YXIga2V5cyBpbiBvYmopIHtcclxuXHJcblx0XHRcdFx0XHQvL0lmIG5vIGtleXMgbGVmdCB0byB0cmF2ZXJzZSwgdGhlbiBhc3NpZ24gdmFsdWUuIElmIG5vdCwgcmVjdXJzZS5cclxuXHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KG9ialtrZXlzXSkpIHtcclxuXHRcdFx0XHRcdFx0b2JqW2tleXNdID0gb2JqW2tleXNdLnNsaWNlKCkuY29uY2F0KHZhbCk7IC8vVXNlIHNsaWNlLWNvbmNhdCBoZXJlIGJlY2F1c2UgdGhpcyBtaWdodCBub3QgYmUgYSB1bmlxdWUgYXJyYXkgKHRoZSBjcmVhdGlvbiBwcm9jZXNzIGR1cGxpY2F0ZXMgdGhlbSlcclxuXHRcdFx0XHRcdH0gZWxzZSByZWN1cnNlKG9ialtrZXlzXSwgdmFsKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0XHRyZWN1cnNlKHRyZWUsIHZhbHVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0Ly9UcmF2ZXJzZSBhbiBvdXRjb21lIHRyZWUgdG8gb2J0YWluIHRoZSB2YWx1ZSBmb3IgYSBkZXNpcmVkIGtleS1zZXRcclxuXHQvL0FyZ3VtZW50IG9uZSBpcyBhIG5lc3RlZCBvYmplY3QsIHdoaWxlIGFyZ3VtZW50IDIgaXMgYW4gYXJyYXkgb2Yga2V5cyBmb3IgdGhlIG9iamVjdCwgMSBsYXllciBhdCBhIHRpbWUuXHJcblx0b3V0Y29tZVRyZWVHZXRWYWx1ZSh0cmVlLCBzZWxlY3Rvcikge1xyXG5cclxuXHRcdC8vRmluZCB0aGUgbmV4dCBpdGVtIGluIHRoZSBjaGFpbiBhc3NvY2lhdGVkIHdpdGggdGhlIHJlc3VsdGFudCBvdXRjb21lXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZWN0b3IubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dHJlZSA9IHRyZWVbc2VsZWN0b3JbaV1dO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cmVlO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvL1RyYXZlcnNlIGFuIG91dGNvbWUgdHJlZSB0byBzZXQgdGhlIHZhbHVlIGZvciBhIGRlc2lyZWQga2V5LXNldFxyXG5cdC8vQXJndW1lbnQgb25lIGlzIGEgbmVzdGVkIG9iamVjdCwgd2hpbGUgYXJndW1lbnQgMiBpcyBhbiBhcnJheSBvZiBrZXlzIGZvciB0aGUgb2JqZWN0LCAxIGxheWVyIGF0IGEgdGltZS5cclxuXHRvdXRjb21lVHJlZVNldFZhbHVlKHRyZWUsIHNlbGVjdG9yLCB2YWx1ZSkge1xyXG5cclxuXHRcdC8vRmluZCB0aGUgbmV4dCBpdGVtIGluIHRoZSBjaGFpbiBhc3NvY2lhdGVkIHdpdGggdGhlIHJlc3VsdGFudCBvdXRjb21lXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZWN0b3IubGVuZ3RoIC0gMTsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRyZWUgPSB0cmVlW3NlbGVjdG9yW2ldXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJlZVtzZWxlY3RvcltpXV0gPSB2YWx1ZTtcclxuXHR9XHJcbn1cclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBwbGF5YWJsZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyAgR2FtZSBzdGF0ZVxyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZShcIi4uL3N0YXRlXCIpO1xyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uXHJcbnZhciB7IGlzRnVuY3Rpb24gfSA9IHJlcXVpcmUoXCIuL2dlbmVyYWxcIik7XHJcblxyXG4vLyBQbGF5ZXIgY2xhYXNzXHJcbnZhciB7IF9QbGF5ZXIgfSA9IHJlcXVpcmUoXCIuLi9wbGF5ZXJcIik7XHJcblxyXG4vLyBQb3B1bGF0aW9uXHJcbnZhciB7IGdhbWVQb3B1bGF0aW9uIH0gPSByZXF1aXJlKFwiLi4vcG9wdWxhdGlvblwiKVxyXG5cclxuLy8gUGx1Z2luc1xyXG52YXIgUGx1Z2luTWFuYWdlciA9IHJlcXVpcmUoXCIuLi9wbHVnaW4tbWFuYWdlci9cIilcclxuXHJcbnZhciBwbGF5ZXIgPSB7XHJcblxyXG5cdC8vcmVzZXQgYWxsIHBsYXllcnMuIFJlY3JlYXRlIGZyb20gY2xhc3MsIHJlLWFzc2lnbiBzdHJhdGVneSwgbG9vcCB0aHJvdWdoIG9iamVjdHMgdGhhdCByZWZlcmVuY2UgcGxheWVyIHRvIHNldCBuZXcgcmVmZXJlbmNlLiByZXN1bHQgYXJndW1lbnQgaXMgb25seSBmb3IgcGFzcy10aHJvdWdoLlxyXG5cdHJlaW5pdGlhbGl6ZVBsYXllcnMocG9wdWxhdGlvbiA9IFwiYWxsXCIsIHJlc3VsdCA9IG51bGwpIHtcclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgb2xkUGxheWVyLCBzdHJhdGVneSwgc3RyYXRlZ3lBcmdzLCBwYXJhbWV0ZXJzO1xyXG5cclxuXHRcdFx0Ly8gaWYgbm8gcG9wdWxhdGlvbiBpcyBzdXBwbGllZCwgZmV0Y2ggZXZlcnlib2R5XHJcblx0XHRcdGlmIChwb3B1bGF0aW9uID09PSBcImFsbFwiKSBwb3B1bGF0aW9uID0gT2JqZWN0LmtleXMocmVnaXN0cnkucGxheWVycylcclxuXHRcdFx0ZWxzZShwb3B1bGF0aW9uID0gcG9wdWxhdGlvbi5pZHMoKSlcclxuXHJcblx0XHRcdC8vUmVkZWZpbmUgZWFjaCBwbGF5ZXJcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb3B1bGF0aW9uLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIHBsYXllciA9IHBvcHVsYXRpb25baV07XHJcblxyXG5cdFx0XHRcdG9sZFBsYXllciA9IHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyXTtcclxuXHRcdFx0XHRzdHJhdGVneSA9IG9sZFBsYXllci5zdHJhdGVneSA/IG9sZFBsYXllci5zdHJhdGVneS5faWQgOiBudWxsO1xyXG5cdFx0XHRcdHN0cmF0ZWd5QXJncyA9IHN0cmF0ZWd5ID8gb2xkUGxheWVyLnN0cmF0ZWd5Ll9hcmdzIDogW107XHJcblx0XHRcdFx0cGFyYW1ldGVycyA9IHt9OyAvL1RPRE86IHdoZW4gYWRkaW5nIHBsYXllciBwYXJhbWV0ZXJzLCBiZSBzdXJlIHRoZXkncmUgaW5jbHVkZWQgaGVyZVxyXG5cclxuXHRcdFx0XHRyZWdpc3RyeS5wbGF5ZXJzW3BsYXllcl0gPSBuZXcgX1BsYXllcihvbGRQbGF5ZXIuaWQsIHBhcmFtZXRlcnMpO1xyXG5cdFx0XHRcdHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyXS5pbnRlcmZhY2UgPSBvbGRQbGF5ZXIuaW50ZXJmYWNlO1xyXG5cdFx0XHRcdHN0cmF0ZWd5ICYmIHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyXS5hc3NpZ24oc3RyYXRlZ3ksIC4uLnN0cmF0ZWd5QXJncyk7XHJcblxyXG5cdFx0XHRcdC8vIFBsdWdpbiwgdG8gYWx0ZXIgcGxheWVycyBpbiByZS1pbml0aWFsaXphdGlvblxyXG5cdFx0XHRcdFBsdWdpbk1hbmFnZXIucnVuKFwicGxheWVyLXJlaW5pdGlhbGl6ZVwiLCByZWdpc3RyeS5wbGF5ZXJzW3BsYXllcl0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL0ZvciBlYWNoIGNob2ljZSwgcmVjcmVhdGUgcGxheWVyIHJlZmVyZW5jZXNcclxuXHRcdFx0Zm9yICh2YXIgY2hvaWNlIGluIHJlZ2lzdHJ5LmNob2ljZXMpIHtcclxuXHRcdFx0XHRpZiAocmVnaXN0cnkuY2hvaWNlc1tjaG9pY2VdLnBsYXllcilcclxuXHRcdFx0XHRcdHJlZ2lzdHJ5LmNob2ljZXNbY2hvaWNlXS5wbGF5ZXIgPSByZWdpc3RyeS5wbGF5ZXJzW3JlZ2lzdHJ5LmNob2ljZXNbY2hvaWNlXS5wbGF5ZXIuaWRdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHBsYXllcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XHJcblxyXG4vLyBTdGF0ZSB2YXJpYWJsZXNcclxudmFyIHtpZENvdW50ZXJzLCByZWdpc3RyeX0gPSByZXF1aXJlKCcuLi9zdGF0ZScpO1xyXG5cclxudmFyIHN0YXRlID0ge1xyXG5cdFxyXG5cdC8vSGFuZGxlIElEIHNldHRpbmcgZm9yIGFsbCBvYmplY3RzIHRoYXQgZ2V0IHN0b3JlZCBpbiB0aGUgcmVnaXN0cnlcclxuXHRpZEhhbmRsZXI6IGZ1bmN0aW9uIGlkSGFuZGxlcihpZCwgdHlwZSwgcmVjdXJzaW5nPWZhbHNlKXtcclxuXHRcdC8vQXNzaWduIGlkXHJcblx0XHRcclxuXHRcdGlkQ291bnRlcnNbdHlwZV0rKztcclxuXHRcdHZhciBjb3VudGVyID0gaWRDb3VudGVyc1t0eXBlXTtcclxuXHRcdFxyXG5cdFx0aWYgKCFpZCkge1xyXG5cdFx0XHRyZXR1cm4gdHlwZSArIGNvdW50ZXIudG9TdHJpbmcoKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gQ2hlY2sgdGhhdCBpZCBpc24ndCB0YWtlbi4gSWYgaXQgaXMsIGNvbnN0cnVjdCBhIG5ldyBvbmUuXHJcblx0XHRcdFxyXG5cdFx0XHQvL0NvbnN0cnVjdCBsaXN0IG9mIGFsbCBvYmplY3RzIGJ5IGV4dHJhY3RpbmcgYWxsIHJlZ2lzdHJ5IGVudHJpZXNcclxuXHRcdFx0dmFyIGl0ZW1zID0gW11cclxuXHRcdFx0T2JqZWN0LmtleXMocmVnaXN0cnkpLmZvckVhY2goZnVuY3Rpb24ocmVnKXtpdGVtcy5wdXNoLmFwcGx5KGl0ZW1zLCBPYmplY3Qua2V5cyhyZWdpc3RyeVtyZWddKSl9KVxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gaWYgaWQgaXMgYWxyZWFkeSB0YWtlbiwgZ2VuZXJhdGUgYSBuZXcgb25lIGJ5IGFkZGluZyBhIG51bWJlciBhdCB0aGUgZW5kLlxyXG5cdFx0XHRpZiAoaXRlbXMuaW5kZXhPZihpZCkgPiAtMSkge1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdHZhciBtYXRjaCwgb2xkTnVtLCBleHAsIG5ld0lkO1xyXG5cdFx0XHRcdHZhciBvbGRJZCA9IGlkO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGRvIHtcclxuXHRcdFx0XHRcdC8vIFRoaXMgZmluZHMgYSBudW1iZXIgYXQgdGhlIGVuZCwgYW5kIGluY3JlbWVudHMgaXQsIG9yIHN0YXJ0cyB3aXRoIDEgaWYgdGhlcmUgd2Fzbid0IG9uZS5cclxuXHRcdFx0XHRcdG1hdGNoID0gL1xcZCskLy5leGVjKGlkKTtcclxuXHRcdFx0XHRcdG9sZE51bSA9IG1hdGNoID8gbWF0Y2hbMF0gOiBcIlwiO1xyXG5cdFx0XHRcdFx0ZXhwID0gbmV3IFJlZ0V4cChvbGROdW0gKyBcIiRcIik7XHJcblx0XHRcdFx0XHRpZCA9IGlkLnJlcGxhY2UoZXhwLCBOdW1iZXIob2xkTnVtKSArIDEpXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0fVx0XHJcblx0XHRcdFx0d2hpbGUgKGl0ZW1zLmluZGV4T2YoaWQpID4tMSlcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBMb2cgd2FybmluZ1xyXG5cdFx0XHRcdGxvZyhcIndhcm5cIiwgXCJJRCBcIiArIG9sZElkICsgXCIgaXMgdGFrZW4uIFVzaW5nIGluc3RlYWQgXCIgKyBpZCk7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdHJldHVybiBpZFxyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc3RhdGU7IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBTdHJhdGVneSByZWdpc3RyYXRpb25cclxudmFyIHsgcmVnaXN0ZXJTdHJhdGVneU9iamVjdCB9ID0gcmVxdWlyZShcIi4uL2VuZ2luZVwiKS5Gcm9udGVuZDtcclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgaXNGdW5jdGlvbiwgb25jZSB9ID0gcmVxdWlyZShcIi4vZ2VuZXJhbFwiKTtcclxuXHJcbi8vRXh0ZXJuYWwgZGVwZW5kZW5jeVxyXG52YXIgZXNwcmltYSA9IHJlcXVpcmUoXCJlc3ByaW1hXCIpO1xyXG5cclxuXHJcbi8vIEZvciBoYW5kbGluZyBxdWVyaWVzXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKFwiLi4vZW5naW5lXCIpLkJhY2tlbmQuU3RhdGVcclxudmFyIHsgcmVnaXN0ZXJRdWVyeU9iamVjdCB9ID0gcmVxdWlyZShcIi4uL2VuZ2luZVwiKS5CYWNrZW5kXHJcbnZhciB7IGlkSGFuZGxlciB9ID0gcmVxdWlyZShcIi4vc3RhdGVcIilcclxuXHJcblxyXG5cclxudmFyIHN0b2NrR2FtZXMgPSB7XHJcblx0Ly8gdXRpbGl0eSBmdW5jdGlvbiB0byBjcmVhdGUgdHdvIHdheXMgdG8gY2FsbCBhIGdhbWUsIGVpdGhlciB3aXRoIGFsbCB0aGUgYXJndW1lbnRzLCBvciBjdXJyaWVkLCB3aGVyZSB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gdGFrZXMgcGxheWVycyBhbmQgcGFyYW1ldGVyc1xyXG5cdC8vIFRoZSBjb21iaW5lUGFyYW1ldGVycyBzZXR0aW5nIHdpbGxcclxuXHRnYW1lV3JhcHBlcihnYW1lLCB7XHJcblx0XHRhcmd1bWVudFZhbGlkYXRvciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSxcclxuXHRcdGNvbWJpbmVQYXJhbWV0ZXJzID0gdHJ1ZSxcclxuXHRcdGdhbWVEZXNjcmlwdGlvbiA9IFwiTm8gZGVzY3JpcHRpb24gZ2l2ZW4uXCIsXHJcblx0XHRzdHJhdGVneUxvYWRlciA9IG51bGwsXHJcblx0XHRxdWVyaWVzID0gbnVsbFxyXG5cdH0gPSB7fSkge1xyXG5cclxuXHRcdHZhciBnZW5lcmF0ZTtcclxuXHJcblx0XHQvLyBJZiB0aGVyZSdzIGEgc3RyYXRlZ3kgbG9hZGVyLCBtYWtlIHN1cmUgaXQgb25seSBydW5zIG9uY2VcclxuXHRcdHZhciBsb2FkU3RyYXRlZ2llc1xyXG5cdFx0aWYgKGlzRnVuY3Rpb24oc3RyYXRlZ3lMb2FkZXIpKSBsb2FkU3RyYXRlZ2llcyA9IG9uY2UoZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiByZWdpc3RlclN0cmF0ZWd5T2JqZWN0KHN0cmF0ZWd5TG9hZGVyKCkpO1xyXG5cdFx0fSk7XHJcblx0XHRlbHNlIGxvYWRTdHJhdGVnaWVzID0gZnVuY3Rpb24oKSB7fVxyXG5cclxuXHRcdC8vIElmIHRoZXJlJ3MgYSBxdWVyeSBsb2FkZXIsIG1ha2Ugc3VyZSBpdCBvbmx5IHJ1bnMgb25jZVxyXG5cdFx0dmFyIGxvYWRRdWVyaWVzXHJcblx0XHRpZiAocXVlcmllcykgbG9hZFF1ZXJpZXMgPSBvbmNlKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gcmVnaXN0ZXJRdWVyeU9iamVjdChxdWVyaWVzKTtcclxuXHRcdH0pO1xyXG5cdFx0ZWxzZSBsb2FkUXVlcmllcyA9IGZ1bmN0aW9uKCkge31cclxuXHJcblx0XHQvLyBydW4gdGhlIGdhbWUuIE9wdGlvbmFsbHksIHZhbGlkYXRlIHRoZSBhcmd1bWVudHMgYW5kIGxvYWQgc3RyYWdlaWVzIGZpcnN0XHJcblx0XHRnZW5lcmF0ZSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcclxuXHRcdFx0dmFyIHJlc3VsdCA9IGFyZ3VtZW50VmFsaWRhdG9yKC4uLmFyZ3MpXHJcblx0XHRcdGlmIChyZXN1bHQgPT09IHRydWUpIHtcclxuXHRcdFx0XHRsb2FkU3RyYXRlZ2llcygpO1xyXG5cdFx0XHRcdGxvYWRRdWVyaWVzKCk7XHJcblx0XHRcdFx0cmV0dXJuIGdhbWUoLi4uYXJncyk7XHJcblx0XHRcdH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IocmVzdWx0KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjcmVhdGVzIGEgd3JhcHBlciBhcm91bmQgdGhlIGdhbWUsIHdoaWNoIGFjY2VwdHMgdGhlIGZpcnN0IGFyZ3VtZW50IChwbGF5ZXJzKSBhbmQgbGFzdCBhcmd1bWVudCAocGFyYW1ldGVycyksIGFuZCBwYXNzZXMgaXQgZm9yd2FyZC5cclxuXHRcdC8vIElmIGNvbWJpbmVQYXJhbWV0ZXJzIGlzIHNldCB0byB0cnVlLCB0aGVuIHRoZSBzZWNvbmQgYXJndW1lbnQgb2YgdGhlIHJldHVybmVkIGZ1bmN0aW9uIHdpbGwgZ2V0IG1lcmdlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50XHJcblx0XHQvLyBnaXZlbiB3aGVuIGdlbmVyYXRvciBpcyBjYWxsZWQuXHJcblx0XHRnZW5lcmF0ZS5jcmVhdGVHZW5lcmF0b3IgPSBmdW5jdGlvbiguLi5hcmdzKSB7XHJcblxyXG5cdFx0XHR2YXIgZ2FtZUNvZGUgPSBlc3ByaW1hLnBhcnNlU2NyaXB0KFwiKFwiICsgZ2FtZS50b1N0cmluZygpICsgXCIpXCIpXHJcblxyXG5cdFx0XHR2YXIgZ2FtZUFyZ3MgPSBnYW1lQ29kZS5ib2R5WzBdLmV4cHJlc3Npb24ucGFyYW1zXHJcblx0XHRcdHZhciBsYXN0QXJnID0gZ2FtZUFyZ3NbZ2FtZUFyZ3MubGVuZ3RoIC0gMV1cclxuXHJcblx0XHRcdHZhciBvcmlnaW5hbFBhcmFtZXRlcnNcclxuXHRcdFx0aWYgKChsYXN0QXJnLm5hbWUgJiYgbGFzdEFyZy5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwicGFyYW1ldGVyc1wiKSB8fCBsYXN0QXJnLnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiIHx8XHJcblx0XHRcdFx0KGxhc3RBcmcudHlwZSA9PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIgJiYgbGFzdEFyZy5sZWZ0LnR5cGUgPT0gXCJPYmplY3RQYXR0ZXJuXCIpKSB7XHJcblx0XHRcdFx0Ly8gQ2hlY2sgdGhhdCB0aGUgZ2FtZSBhcmd1bWVudHMgYW5kIGNyZWF0ZUdlbmVyYXRvciBhcmd1bWVudHMgYXJlIHRoZSBjb3JyZWN0IGxlbmd0aHMuIGNyZWF0ZUdlbmVyYXRvciBzaG91bGQgYmVcclxuXHRcdFx0XHQvLyAxIGxlc3MgdGhhbiBnYW1lLCBiZWNhdXNlIHBsYXllcnMgaXMgb21pdHRlZC5cclxuXHRcdFx0XHQvLyBUT0RPOiB1c2UgZXNwcmltYSB0byBhbGxvdyBwbGF5ZXJzIHRvIGJlIGFueXdoZXJlIGluIHRoZSBnYW1lIGRlZmluaXRpb24gKG9yIGV2ZW4gb21pdHRlZCkgcmF0aGVyIHRoYW4gZmlyc3RcclxuXHRcdFx0XHRpZiAoYXJncy5sZW5ndGggPT0gZ2FtZUFyZ3MubGVuZ3RoIC0gMSkgb3JpZ2luYWxQYXJhbWV0ZXJzID0gYXJncy5wb3AoKTtcclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbihwbGF5ZXJzLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHJcblx0XHRcdFx0Ly8gSWYgY29tYmluaW5nIHBhcmFtZXRlcnMsIG1lcmdlIGFuZCByZW1vdmUgZnJvbSBhcmd1bWVudHNcclxuXHRcdFx0XHRpZiAoY29tYmluZVBhcmFtZXRlcnMgJiYgb3JpZ2luYWxQYXJhbWV0ZXJzKSBwYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luYWxQYXJhbWV0ZXJzLFxyXG5cdFx0XHRcdFx0cGFyYW1ldGVycylcclxuXHJcblx0XHRcdFx0cmV0dXJuIGdlbmVyYXRlKHBsYXllcnMsIC4uLmFyZ3MsIHBhcmFtZXRlcnMpXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBBbGxvdyBmb3IgZ2FtZSBkZXNjcmlwdGlvbiBmZWF0dXJlXHJcblx0XHRnZW5lcmF0ZS5kZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gZ2FtZURlc2NyaXB0aW9uO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBEaXNwbGF5IGFueSBxdWVyaWVzXHJcblx0XHRnZW5lcmF0ZS5xdWVyaWVzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiBxdWVyaWVzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBnZW5lcmF0ZTtcclxuXHR9XHJcblxyXG5cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBzdG9ja0dhbWVzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIFN0cmF0ZWdpZXNcclxudmFyIHsgU3RyYXRlZ2llcyB9ID0gcmVxdWlyZShcIi4uL3N0cmF0ZWd5XCIpO1xyXG5cclxuLy8gUGxheWVyc1xyXG52YXIgeyBQbGF5ZXIgfSA9IHJlcXVpcmUoXCIuLi9wbGF5ZXJcIik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHQvLyBDcmVhdGUgYSBwbGF5ZXIgZm9yIGVhY2ggYXZhaWxhYmxlIHN0cmF0ZWd5XHJcblx0Z2VuZXJhdGVQb3B1bGF0aW9uKCkge1xyXG5cdFx0dmFyIHBsYXllcnMgPSBbXTtcclxuXHJcblx0XHRTdHJhdGVnaWVzKCkuZm9yRWFjaChmdW5jdGlvbihzdHJhdGVneSkge1xyXG5cdFx0XHRwbGF5ZXJzLnB1c2goUGxheWVyKHsgYXNzaWduOiBzdHJhdGVneSB9KSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gcGxheWVycztcclxuXHR9XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIHtTeW5jaHJvbm91c1Byb21pc2V9ID0gcmVxdWlyZSgnc3luY2hyb25vdXMtcHJvbWlzZScpO1xyXG5cclxudmFyIHR1cm4gPSB7XHJcblx0XHJcblx0Ly9SZWN1cnNlIHRocm91Z2ggdGhlIG9wdGlvbnMgaW4gaW5wdXQsIGFuZCB3cml0ZSB2YWwgdG8gb3V0cHV0LiBcclxuXHRyZWN1cnNlIDogZnVuY3Rpb24gcmVjdXJzZShpbnB1dCwgb3V0cHV0LCB2YWwsIHZhbEdlbmVyYXRvcj1mdW5jdGlvbigpe30sIHBhdGg9W10pe1xyXG5cdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKHBhdGgpLnRoZW4oZnVuY3Rpb24ocGF0aCl7XHJcblx0XHRcdFxyXG5cdFx0XHQvL1NpbmNlIHdlIHNsaWNlIHRoZSBhcnJheSBlYWNoIHRpbWUsIGlmIHRoZXJlIGFyZSBubyBtb3JlIGVudHJpZXMgbGVmdCB0aGVuIHdlJ3JlIGRvbmUgd2l0aCB0aGlzIGJyYW5jaC5cclxuXHRcdFx0aWYgKGlucHV0Lmxlbmd0aCA9PSAwKSByZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUocGF0aClcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHQvL0Ftb25nIGFsbCB2YWx1ZXMgZnJvbSB0aGUgYXJyYXlcclxuXHRcdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5hbGwoaW5wdXRbMF0ubWFwKGZ1bmN0aW9uKGl0ZW0pe1xyXG5cdFx0XHRcdHZhciB2YWx1ZTtcclxuXHRcdFx0XHR2YXIgc3BsaXRQYXRoID0gcGF0aC5zbGljZSgwKS5jb25jYXQoaXRlbSk7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly9JZiB0aGVyZSBhcmUgbW9yZSBpdGVtcyB0byBpdGVyYXRlIG92ZXIsIGluY2x1ZGUgdGhlbSBpbiB0aGUgb3V0cHV0IHRoZW4gcmVjdXJzZS5cclxuXHRcdFx0XHQvL0lmIG5vdCwgcHV0IGluIHRoZSBuZXcgdmFsdWUuXHJcblx0XHRcdFx0aWYgKGlucHV0Lmxlbmd0aCA9PSAxKSB7XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdC8vSWYgdmFsIGlzIGEgZnVuY3Rpb24sIHdyYXAgaXQgaW4gYSBmdW5jdGlvbiB0aGF0IHdpbGwgZ2V0IHN1cHBsaWVkIGFuIGFyZ3VtZW50IHdpdGggd2hlcmUgd2UgYXJlXHRcdFx0XHRcclxuXHRcdFx0XHRcdGlmICh0eXBlb2YgdmFsID09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGZ1bmN0aW9uKCl7XHRcclxuXHRcdFx0XHRcdFx0XHR2YXIgYXJncyA9IFtzcGxpdFBhdGhdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB2YWx1ZSA9IHZhbCB8fCB2YWxHZW5lcmF0b3Ioc3BsaXRQYXRoKTtcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0b3V0cHV0W2l0ZW1dID0gdmFsdWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Ugb3V0cHV0W2l0ZW1dID0ge307XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0cmV0dXJuIHJlY3Vyc2UoaW5wdXQuc2xpY2UoMSksb3V0cHV0W2l0ZW1dLCB2YWwsIHZhbEdlbmVyYXRvciwgc3BsaXRQYXRoKTtcclxuXHRcdFx0fSkpO1x0XHRcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHR1cm47IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgeyBldmFsdWF0ZVF1ZXJ5IH0gPSByZXF1aXJlKFwiLi9xdWVyeVwiKVxyXG5cclxudmFyIHsgcmVnaXN0cnkgfSA9IHJlcXVpcmUoXCIuL3N0YXRlXCIpXHJcblxyXG52YXIgeyBpc09iamVjdCwgaXNGdW5jdGlvbiB9ID0gcmVxdWlyZShcIi4vaGVscGVyLWZ1bmN0aW9uc1wiKShcImdlbmVyYWxcIik7XHJcblxyXG4vL0V4dGVuc2lvbiBvZiBhcnJheSB0byBoYW5kbGUgaGlzdG9yeSBsaXN0cy5cclxuZnVuY3Rpb24gSGlzdG9yeSguLi5hcmdzKSB7XHJcblx0aWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIGFyZ3MgPSBhcmdzWzBdO1xyXG5cclxuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJncywgSGlzdG9yeS5wcm90b3R5cGUpO1xyXG5cclxuXHRhcmdzLmxvZyA9IGFyZ3Muc2xpY2UoKTtcclxuXHRhcmdzLmxvZy50cmVlID0gYXJncztcclxuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJncy5sb2csIEhpc3RvcnkucHJvdG90eXBlKTtcclxuXHJcblx0YXJncy5zY29yZXMgPSBbXTtcclxuXHRhcmdzLnNjb3Jlcy50cmVlID0gYXJncztcclxuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJncy5zY29yZXMsIEhpc3RvcnkucHJvdG90eXBlKTtcclxuXHJcblx0cmV0dXJuIGFyZ3M7XHJcbn1cclxuXHJcbkhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBcnJheS5wcm90b3R5cGUpO1xyXG5IaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhpc3Rvcnk7XHJcblxyXG4vL1RvIGFkZCBlbnRyeVxyXG5IaXN0b3J5LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihlbnRyeSkge1xyXG5cdC8vQWRkIHRvIGhpc3RvcnkgYW5kIHRvIGxvZ1xyXG5cdHRoaXMucHVzaChlbnRyeSk7XHJcblx0aWYgKHRoaXMubG9nKSB0aGlzLmxvZy5wdXNoKGVudHJ5KTtcclxuXHJcblx0Ly9DeWNsZSB1cCB0aGUgcGFyZW50IHRyZWUsIGFkZCB0byBlYWNoIGxvZ1xyXG5cdHZhciBjaGVjayA9IHRoaXM7XHJcblx0aWYgKGNoZWNrLnRyZWUgaW5zdGFuY2VvZiBIaXN0b3J5ICYmIGNoZWNrLnRyZWUucGFyZW50IGluc3RhbmNlb2YgSGlzdG9yeSkge1xyXG5cdFx0Y2hlY2sudHJlZS5wYXJlbnQubG9nLmFkZChlbnRyeSk7XHJcblx0fVxyXG5cdGlmIChjaGVjay5wYXJlbnQgaW5zdGFuY2VvZiBIaXN0b3J5KSB7XHJcblx0XHRjaGVjay5wYXJlbnQubG9nLmFkZChlbnRyeSk7XHJcblx0fVxyXG5cclxuXHQvL0lmIHdlJ3JlIGJlaW5nIGNhbGxlZCBmclxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vVG8gYWRkIGVudHJ5IHdpdGhvdXQgbG9nZ2luZyAoZm9yIHBsYXlhYmxlcyB0aGF0IHdvdWxkIGxpa2UgdGhlIHRyZWUgaGlzdG9yeVxyXG4vL3RvIGJlIHN0cnVjdHVyZWQgZGlmZmVyZW50bHkgdGhhbiB0aGUgbG9nIGhpc3RvcnkuXHJcbkhpc3RvcnkucHJvdG90eXBlLmFkZE5vTG9nID0gZnVuY3Rpb24oZW50cnkpIHtcclxuXHR0aGlzLnB1c2goZW50cnkpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuXHJcbkhpc3RvcnkucHJvdG90eXBlLmFkZFNjb3JlcyA9IGZ1bmN0aW9uKGVudHJ5KSB7XHJcblx0Ly9BZGQgdG8gaGlzdG9yeVxyXG5cdHRoaXMuc2NvcmVzLnB1c2goZW50cnkpO1xyXG5cclxuXHQvL0N5Y2xlIHVwIHRoZSBwYXJlbnQgdHJlZSwgYWRkIHRvIGVhY2ggbG9nXHJcblx0dmFyIGNoZWNrID0gdGhpcztcclxuXHRpZiAoY2hlY2sucGFyZW50IGluc3RhbmNlb2YgSGlzdG9yeSkge1xyXG5cdFx0Y2hlY2sucGFyZW50LmFkZFNjb3JlcyhlbnRyeSk7XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuXHJcbi8vQSB0ZW1wb3JhcnkgSGlzdG9yeSB0aGF0IGNhbiBiZSBtZXJnZWQgYmFjayBpbiBsYXRlci4gVGhlIGNoaWxkIGFuZCBwYXJlbnQgYXJlIGxpbmtlZCB1bnRpbCAub3JwaGFuKCkgaXMgY2FsbGVkLlxyXG5IaXN0b3J5LnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uKHBhcmVudCA9IHRoaXMpIHtcclxuXHR2YXIgaCA9IG5ldyBIaXN0b3J5KCk7XHJcblx0aC5wYXJlbnQgPSBwYXJlbnQ7XHJcblx0cmV0dXJuIGg7XHJcbn07XHJcblxyXG4vL1NhbWUgYXMgLmNoaWxkIGV4Y2VwdCBpbmNsdWRlcyBwcmlvciBwYXJlbnQgaGlzdG9yeSB3aGVuIC5wcmludCgpIGlzIGNhbGxlZC5cclxuSGlzdG9yeS5wcm90b3R5cGUuY2hpbGRXaXRoQ29udGVudCA9IGZ1bmN0aW9uKHBhcmVudCA9IHRoaXMpIHtcclxuXHR2YXIgc3RvcmVkTG9nID0gcGFyZW50LnNsaWNlKCk7XHJcblx0dmFyIHN0b3JlZFNjb3JlcyA9IHBhcmVudC5zbGljZSgpO1xyXG5cclxuXHR2YXIgaCA9IG5ldyBIaXN0b3J5KCk7XHJcblxyXG5cclxuXHRoLmxvZy5wcmludCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0SGlzdG9yeS5wcm90b3R5cGUucHJpbnQuY2FsbChzdG9yZWRMb2cuY29uY2F0KGgubG9nKSlcclxuXHR9XHJcblx0aC5zY29yZXMucHJpbnQgPSBmdW5jdGlvbigpIHtcclxuXHRcdEhpc3RvcnkucHJvdG90eXBlLnByaW50LmNhbGwoc3RvcmVkU2NvcmVzLmNvbmNhdChoLnNjb3JlcykpXHJcblx0fVxyXG5cclxuXHRoLnBhcmVudCA9IHBhcmVudDtcclxuXHRyZXR1cm4gaDtcclxufTtcclxuXHJcbi8vVGhpcyBzZXZlcnMgdGhlIGxpbmsgYmV0d2VlbiB0aGUgdGVtcG9yYXJ5IGhpc3RvcnkgYW5kIGl0cyBwYXJlbnQuIFVzZSB0aGlzIHdoZW4gbWVyZ2luZyBjb21wb3NpdGUgZW50cmllcy5cclxuSGlzdG9yeS5wcm90b3R5cGUub3JwaGFuID0gZnVuY3Rpb24oKSB7XHJcblx0ZGVsZXRlIHRoaXMucGFyZW50O1xyXG5cdGRlbGV0ZSB0aGlzLmxvZztcclxuXHRkZWxldGUgdGhpcy5zY29yZXM7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vL0NsZWFyIGhpc3RvcnlcclxuSGlzdG9yeS5wcm90b3R5cGUuY2xlYXJIaXN0b3J5ID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5zcGxpY2UoMCwgdGhpcy5sZW5ndGgpO1xyXG5cdGlmICh0aGlzLmxvZykgdGhpcy5sb2cuc3BsaWNlKDAsIHRoaXMubG9nLmxlbmd0aCk7XHJcblx0aWYgKHRoaXMuc2NvcmVzKSB0aGlzLnNjb3Jlcy5zcGxpY2UoMCwgdGhpcy5zY29yZXMubGVuZ3RoKTtcclxuXHRkZWxldGUgdGhpcy5wYXJlbnQ7XHJcbn07XHJcblxyXG4vL0VuZCB0aGUgZ2FtZS5cclxuSGlzdG9yeS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5zdG9wID0gdHJ1ZTtcclxuXHRpZiAodGhpcy5wYXJlbnQpIHRoaXMucGFyZW50LmVuZCgpO1xyXG59O1xyXG5cclxuLy9HZXQgYSBwYXJ0aWN1bGFyIHNvcnQgb2YgZW50cnksIGVnLiBUdXJuLlxyXG5IaXN0b3J5LnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24odHlwZSkge1xyXG5cdHJldHVybiBuZXcgSGlzdG9yeShcclxuXHRcdHRoaXMuZmlsdGVyKGZ1bmN0aW9uKGVudHJ5KSB7XHJcblx0XHRcdC8vSWYgaXQncyBub3QgYW4gb2JqZWN0LCBkb24ndCBldmVuIGJvdGhlci5cclxuXHRcdFx0aWYgKCFpc09iamVjdChlbnRyeSkpIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdGZvciAodmFyIGtleSBpbiBlbnRyeSkge1xyXG5cdFx0XHRcdGlmIChrZXkgPT0gdHlwZSkgcmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH0pXHJcblx0KTtcclxufTtcclxuXHJcbkhpc3RvcnkucHJvdG90eXBlLm1vc3RSZWNlbnQgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpc1t0aGlzLmxlbmd0aCAtIDFdXHJcbn1cclxuXHJcbi8vSGVscCByZWFkIHRoZSBoaXN0b3J5IGluIENocm9tZSB3aXRoIGxlc3MgY2x1dHRlci5cclxuSGlzdG9yeS5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgaGlzdG9yeSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcykpO1xyXG5cdGhpc3RvcnkucXVlcnkgPSBIaXN0b3J5LnByb3RvdHlwZS5xdWVyeVxyXG5cdHJldHVybiBoaXN0b3J5O1xyXG59O1xyXG5cclxuSGlzdG9yeS5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbihxdWVyeVN0cmluZywgLi4uYXJncykge1xyXG5cdHJldHVybiBldmFsdWF0ZVF1ZXJ5KHF1ZXJ5U3RyaW5nLCB0aGlzLCAuLi5hcmdzKVxyXG59XHJcblxyXG4vL1N1cHBseSBhbiBlbnRyeSwgaXQgd2lsbCBjaGVjayBmb3IgYSBwcm9wZXJ0eSB0aGF0IGlzIGEgSGlzdG9yeVxyXG5IaXN0b3J5LnByb3RvdHlwZS5yZWN1cnNlID0gZnVuY3Rpb24odHlwZSkge1xyXG5cdHZhciBsaXN0ID0gdGhpcztcclxuXHJcblx0cmV0dXJuIG5ldyBIaXN0b3J5KFxyXG5cdFx0bGlzdC5tYXAoZnVuY3Rpb24oZW50cnkpIHtcclxuXHRcdFx0Zm9yICh2YXIga2V5IGluIGVudHJ5KSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coa2V5LCBlbnRyeSk7XHJcblx0XHRcdFx0aWYgKGVudHJ5W2tleV0gaW5zdGFuY2VvZiBIaXN0b3J5KSByZXR1cm4gZW50cnlba2V5XS5yZWN1cnNlKHR5cGUpO1xyXG5cdFx0XHRcdGVsc2UgaWYgKGtleSA9PSB0eXBlKSByZXR1cm4gZW50cnk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9KVxyXG5cdCk7XHJcbn07XHJcblxyXG4vL0FjY2VwdCBhIEhpc3RvcnkgYW5kIHJldHVybiBvbmUgc3VpdGFibGUgZm9yIHRoZSB1c2VyXHJcbmZ1bmN0aW9uIFVzZXJIaXN0b3J5KGhpc3RvcnkpIHtcclxuXHR2YXIgdXNlckhpc3RvcnkgPSBoaXN0b3J5Lm1hcChmdW5jdGlvbihlbnRyeSkge1xyXG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZW50cnkpKTtcclxuXHR9KTtcclxuXHRpZiAoaGlzdG9yeS5sb2cpIHtcclxuXHRcdHVzZXJIaXN0b3J5LmxvZyA9IG5ldyBVc2VySGlzdG9yeShoaXN0b3J5LmxvZylcclxuXHR9O1xyXG5cdGlmIChoaXN0b3J5LnNjb3Jlcykge1xyXG5cdFx0dXNlckhpc3Rvcnkuc2NvcmVzID0gbmV3IFVzZXJIaXN0b3J5KGhpc3Rvcnkuc2NvcmVzKVxyXG5cdH1cclxuXHJcblx0T2JqZWN0LnNldFByb3RvdHlwZU9mKHVzZXJIaXN0b3J5LCBVc2VySGlzdG9yeS5wcm90b3R5cGUpO1xyXG5cclxuXHQvL0F0dGFjaCBtZXRob2RzIGZyb20gSGlzdG9yeSwgd3JhcHBlZCBpbiBhIGZ1bmN0aW9uLiBJZiB0aG9zZSBtZXRob2RzIHJldHVybiBhIGhpc3RvcnksXHJcblx0Ly90aGVuIHRoZSBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgdGhhdCB0byBhIHVzZXJIaXN0b3J5LlxyXG5cdGZvciAodmFyIG1ldGhvZCBpbiBIaXN0b3J5LnByb3RvdHlwZSkge1xyXG5cdFx0aWYgKGlzRnVuY3Rpb24oaGlzdG9yeVttZXRob2RdKSkge1xyXG5cdFx0XHRpZiAobWV0aG9kICE9IFwiY29uc3RydWN0b3JcIilcclxuXHRcdFx0XHR1c2VySGlzdG9yeVttZXRob2RdID0gKGZ1bmN0aW9uKG1ldGhvZCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gaGlzdG9yeVttZXRob2RdLmFwcGx5KGhpc3RvcnksIGFyZ3VtZW50cyk7XHJcblx0XHRcdFx0XHRcdGlmIChyZXN1bHQgaW5zdGFuY2VvZiBIaXN0b3J5KSByZXR1cm4gbmV3IFVzZXJIaXN0b3J5KHJlc3VsdCk7XHJcblx0XHRcdFx0XHRcdGVsc2UgaWYgKGlzT2JqZWN0KHJlc3VsdCkpXHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XHJcblx0XHRcdFx0XHRcdGVsc2UgcmV0dXJuIHJlc3VsdDtcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fSkobWV0aG9kKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB1c2VySGlzdG9yeTtcclxufVxyXG5cclxuVXNlckhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShIaXN0b3J5LnByb3RvdHlwZSk7XHJcblVzZXJIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVzZXJIaXN0b3J5O1xyXG5cclxudmFyIGdhbWVIaXN0b3J5ID0gbmV3IEhpc3RvcnkoKTsgLy9UT0RPOiBhZGQgY2hvaWNlLW9ubHkgaGlzdG9yeVxyXG5cclxudmFyIHVzZXJHYW1lSGlzdG9yeSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgVXNlckhpc3RvcnkoZ2FtZUhpc3RvcnkpXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBIaXN0b3J5LCBVc2VySGlzdG9yeSwgZ2FtZUhpc3RvcnksIHVzZXJHYW1lSGlzdG9yeSB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vV2hlbiBhIHN0cmF0ZWd5J3MgLmNob29zZSgpIGZ1bmN0aW9uIGlzIGNhbGxlZCwgaXQgaXMgZ2l2ZW4gYW4gaW5mb3JtYXRpb24gc2V0LiBUaGF0IGRhdGEgaXMgYSBsaW1pdGVkIG1hcCBvZiB0aGUgaW50ZXJuYWwgb2JqZWN0cyBvZiB0aGUgZ2FtZSBlbmdpbmUsIGluY2x1ZGluZyBpbmZvcm1hdGlvbiBvbiB0aGUgZ2FtZSBoaXN0b3J5IGFuZCB0aGUgcGxheWVycy4gVGhpcyBpcyB0aHJlYWRlZCB0aHJvdWdoIHBsYXlhYmxlcywgbXVjaCBsaWtlIEhpc3RvcnksIHNvIHRoYXQgYSBwYXJlbnQgcGxheWFibGUgY2FuIHNwZWNpZnkgYW4gaW5mb3JtYXRpb24gc2V0IGZvciB0aGUgcGxheWFibGVzIGl0IGNhbGxzLCBvciBlbHNlIHRoZSBkZWZhdWx0IGNvbnN0cnVjdGlvbiB3aWxsIGJlIHVzZWQuIEFkZGl0aW9uYWxseSwgdGhlIHVzZXIgY2FuIHByb3ZpZGUgYSBmaWx0ZXIgZnVuY3Rpb24sIHRvIHNlbGVjdGl2ZWx5IGRlbGV0ZSAob3IgYWRkKSBpbmZvcm1hdGlvbiBlbGVtZW50cyBiZWZvcmUgdGhleSBhcmUgcGFzc2VkIHRvIC5jaG9vc2UoKS5cclxuXHJcbi8vSGlzdG9yeSBmdW5jdGlvbnNcclxudmFyIHsgZ2FtZUhpc3RvcnksIEhpc3RvcnkgfSA9IHJlcXVpcmUoJy4vaGlzdG9yeScpO1xyXG5cclxuLy9Qb3B1bGF0aW9uIGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lUG9wdWxhdGlvbiwgUGxheWVyTGlzdCB9ID0gcmVxdWlyZSgnLi9wb3B1bGF0aW9uJyk7XHJcblxyXG5cclxuZnVuY3Rpb24gSW5mb3JtYXRpb24oaGlzdG9yeSA9IGdhbWVIaXN0b3J5LCBwb3B1bGF0aW9uID0gZ2FtZVBvcHVsYXRpb24sIHsgcGFyZW50SGlzdG9yeSA9IFtdIH0gPSB7fSkge1xyXG5cdHRoaXMuaGlzdG9yeSA9IGhpc3Rvcnk7XHJcblx0dGhpcy5wb3B1bGF0aW9uID0gcG9wdWxhdGlvbjtcclxuXHJcblx0Ly8gUmVjb3JkIGFueSBoaXN0b3J5IGVudHJpZXMgdGhhdCBuZWVkIHRvIGJlIGFkZGVkIHRvIHRoZSByZWNvcmRzXHJcblx0dGhpcy5wYXJlbnRIaXN0b3J5ID0gcGFyZW50SGlzdG9yeS5zbGljZSgwKTtcclxuXHJcblx0dGhpcy5hZGRpdGlvbmFsID0gW107XHJcblxyXG5cdHRoaXMudXBkYXRlKCk7XHJcbn07XHJcblxyXG4vL0NoZWNrIHRoZSBzb3VyY2UgdGhlbiBjYWNoZSBhIGhhcmQtY29weS5cclxuSW5mb3JtYXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHBsYXllciwgbG9jYWwpIHtcclxuXHR0aGlzLmluZm9Qb3B1bGF0aW9uID0gdGhpcy5wb3B1bGF0aW9uKCkuaW5mbygpO1xyXG5cclxuXHR0aGlzLmluZm9IaXN0b3J5ID0geyBsb2c6IHRoaXMucGFyZW50SGlzdG9yeS5jb25jYXQodGhpcy5oaXN0b3J5LmxvZykuc2xpY2UoMCksIHNjb3JlczogdGhpcy5oaXN0b3J5LnNjb3Jlc1xyXG5cdFx0XHQuc2xpY2UoMCkgfTtcclxuXHJcblx0dGhpcy5hZGRpdGlvbmFsID0gW107XHJcblxyXG5cdC8vUmV0dXJuIHZhbHVlLiBNaW1pY3MgLmRlbGl2ZXIoKVxyXG5cdHZhciBpbmZvcm1hdGlvbiA9IHtcclxuXHRcdGhpc3Rvcnk6IHsgbG9nOiB0aGlzLmluZm9IaXN0b3J5LmxvZywgc2NvcmVzOiB0aGlzLmluZm9IaXN0b3J5LnNjb3JlcyB9LFxyXG5cdFx0cG9wdWxhdGlvbjogdGhpc1xyXG5cdFx0XHQuaW5mb1BvcHVsYXRpb25cclxuXHR9XHJcblx0aWYgKHBsYXllcikgaW5mb3JtYXRpb24ubWUgPSBpbmZvcm1hdGlvbi5wb3B1bGF0aW9uLmdldChwbGF5ZXIuaWQpO1xyXG5cdGlmIChsb2NhbCkgT2JqZWN0LmFzc2lnbihpbmZvcm1hdGlvbiwgbG9jYWwpO1xyXG5cclxuXHRyZXR1cm4gaW5mb3JtYXRpb247XHJcbn07XHJcblxyXG4vL0Nsb25lIHRoZSBjYWNoZWQgY29waWVzIGFuZCBwcm92aWRlIHRoZW0uIFdpbGwgZGVsaXZlciB0aGUgc2FtZSB0aGluZyBldmVyeSB0aW1lIHVudGlsIHVwZGF0ZSBpcyBjYWxsZWQuXHJcbkluZm9ybWF0aW9uLnByb3RvdHlwZS5kZWxpdmVyID0gZnVuY3Rpb24ocGxheWVyLCBsb2NhbCkge1xyXG5cdHZhciBpbmZvcm1hdGlvbiA9IHtcclxuXHRcdGhpc3Rvcnk6IHsgbG9nOiB0aGlzLmluZm9IaXN0b3J5LmxvZywgc2NvcmVzOiB0aGlzLmluZm9IaXN0b3J5LnNjb3JlcyB9LFxyXG5cdFx0cG9wdWxhdGlvbjogdGhpc1xyXG5cdFx0XHQuaW5mb1BvcHVsYXRpb25cclxuXHR9XHJcblxyXG5cclxuXHRpZiAocGxheWVyKSBpbmZvcm1hdGlvbi5tZSA9IGluZm9ybWF0aW9uLnBvcHVsYXRpb24uZ2V0KHBsYXllci5pZCk7XHJcblx0aWYgKGxvY2FsKSBPYmplY3QuYXNzaWduKGluZm9ybWF0aW9uLCBsb2NhbCk7XHJcblx0aWYgKHRoaXMuYWRkaXRpb25hbCkgdGhpcy5hZGRpdGlvbmFsLmZvckVhY2goZnVuY3Rpb24oZW50cnkpIHsgT2JqZWN0LmFzc2lnbihpbmZvcm1hdGlvbiwgZW50cnkpIH0pO1xyXG5cclxuXHRyZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbmZvcm1hdGlvbikpO1xyXG59O1xyXG5cclxuLy9UaGlzIHByb2JhYmx5IGRvZXNuJ3QgbmVlZCB0byBiZSBhIHNlcGFyYXRlIGZ1bmN0aW9uLCBidXQgYWRkaW5nIGl0IGluIGNhc2UgaXQgZXhwYW5kcyBsYXRlci5cclxuSW5mb3JtYXRpb24ucHJvdG90eXBlLmFkZEFkZGl0aW9uYWwgPSBmdW5jdGlvbihlbnRyeSA9IG51bGwpIHtcclxuXHRpZiAoZW50cnkpIHRoaXMuYWRkaXRpb25hbC5wdXNoKGVudHJ5KTtcclxufTtcclxuXHJcbi8vTWFrZSBjb3B5IG9mIHRoaXMgaW5mb3JtYXRpb24gZnVuY3Rpb24sIHdoaWNoIGFsbG93cyBmb3IgdXBkYXRpbmcgYW5kIGZyZWV6aW5nLlxyXG5JbmZvcm1hdGlvbi5wcm90b3R5cGUuY2hpbGQgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgaW5mb3JtYXRpb24gPSBuZXcgSW5mb3JtYXRpb24odGhpcy5oaXN0b3J5LCB0aGlzLnBvcHVsYXRpb24sIHsgcGFyZW50SGlzdG9yeTogdGhpcy5wYXJlbnRIaXN0b3J5IH0pO1xyXG5cclxuXHRyZXR1cm4gaW5mb3JtYXRpb247XHJcbn07XHJcblxyXG5cclxuXHJcbi8vR2FtZSBzdGF0ZSwgYW5hbG9nb3VzIHRvIGdhbWVIaXN0b3J5XHJcbnZhciBQZXJmZWN0SW5mb3JtYXRpb24gPSBuZXcgSW5mb3JtYXRpb24oZ2FtZUhpc3RvcnksIGdhbWVQb3B1bGF0aW9uKTtcclxuXHJcbi8vT3ZlcndyaXRlIC5kZWxpdmVyKCkuIFBlcmZlY3RJbmZvcm1hdGlvbiBpcyBhbHdheXMgdXAtdG8tZGF0ZSEgVGh1cyBubyBuZWVkIHRvIGRvIGEgMm5kIEpTT04uc3RyaW5naWZ5LlxyXG5QZXJmZWN0SW5mb3JtYXRpb24uZGVsaXZlciA9IGZ1bmN0aW9uKHBsYXllciwgbG9jYWwpIHtcclxuXHJcblx0dmFyIGluZm9ybWF0aW9uID0gdGhpcy51cGRhdGUocGxheWVyLCBsb2NhbCk7XHJcblxyXG5cdGlmIChwbGF5ZXIpIGluZm9ybWF0aW9uLm1lID0gaW5mb3JtYXRpb24ucG9wdWxhdGlvbi5nZXQocGxheWVyLmlkKTtcclxuXHRpZiAobG9jYWwpIE9iamVjdC5hc3NpZ24oaW5mb3JtYXRpb24sIGxvY2FsKTtcclxuXHJcblx0cmV0dXJuIGluZm9ybWF0aW9uO1xyXG59O1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBJbmZvcm1hdGlvbiwgUGVyZmVjdEluZm9ybWF0aW9uIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbnZhciBsb2dnZXIgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYXJncyA9IFsuLi5hcmd1bWVudHNdO1xyXG5cdHZhciBsZXZlbCA9IChhcmdzWzBdID09IFwic2lsbHlcIiB8fCAhYXJnc1swXSkgPyBcInRyYWNlXCIgOiBhcmdzWzBdO1xyXG5cdHZhciBsZXZlbCA9IGxldmVsID09IFwid2FybmluZ1wiID8gXCJ3YXJuXCIgOiBsZXZlbDtcclxuXHRhcmdzLnNoaWZ0KCk7XHJcblxyXG5cdGxvZ2dlci5sb2dnZXJbbGV2ZWxdLmFwcGx5KGxvZ2dlci5sb2dnZXIsIGFyZ3MpO1xyXG59O1xyXG5cclxuLy9sb2dnZXIubG9nZ2VyID0gY29uc29sZTtcdFx0XHRcdFx0Ly9UT0RPIGNsZWFuIHRoaXMgYWxsIHVwIGEgbG90LlxyXG5cclxudmFyIGdldExvZ2dlciA9IHJlcXVpcmUoXCJsb2dsZXZlbC1jb2xvcmVkLWxldmVsLXByZWZpeFwiKTtcclxudmFyIG9wdGlvbnMgPSB7IHByZWZpeDogJ25hc2hKUycsIGxldmVsOiAndHJhY2UnIH1cclxubG9nZ2VyLmxvZ2dlciA9IGdldExvZ2dlcihvcHRpb25zKVxyXG5cclxubG9nZ2VyLnNldExldmVsID0gZnVuY3Rpb24obGV2ZWwpIHtcclxuXHRsb2dnZXIubG9nZ2VyLmxldmVsID0gbGV2ZWw7XHJcblx0bG9nZ2VyLmxvZ2dlci5zZXRMZXZlbChsZXZlbClcclxufTtcclxuXHJcbi8qXHJcbmxvZ2dlci51c2VXaW5zdG9uID0gZnVuY3Rpb24oKXtcclxuXHJcblx0dmFyIHdpbnN0b24gPSByZXF1aXJlKCd3aW5zdG9uJyk7XHJcblx0dmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XHJcblxyXG5cdHdpbnN0b24ubGV2ZWwgPSBcIndhcm5cIjtcclxuXHJcblx0d2luc3Rvbi5jbGVhcigpXHJcblx0d2luc3Rvbi5hZGQod2luc3Rvbi50cmFuc3BvcnRzLkNvbnNvbGUsIHtcclxuXHRcdGxldmVsOiAndHJhY2UnLFxyXG5cdFx0cHJldHR5UHJpbnQ6ICBmdW5jdGlvbiAoIG9iamVjdCApe1xyXG5cdFx0XHRyZXR1cm4gdXRpbC5pbnNwZWN0KG9iamVjdCk7XHJcblx0XHR9LFxyXG5cdFx0Y29sb3JpemU6IHRydWUsXHJcblx0XHRzaWxlbnQ6IGZhbHNlLFxyXG5cdFx0dGltZXN0YW1wOiBmYWxzZVxyXG5cdH0pO1xyXG5cclxuXHR0aGlzLmxvZ2dlciA9IHdpbnN0b247XHJcbn07XHJcbiovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGxvZ2dlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZShcIi4vbG9nZ2VyXCIpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlzRnVuY3Rpb24gfSA9IHJlcXVpcmUoXCIuL2hlbHBlci1mdW5jdGlvbnNcIikoXCJnZW5lcmFsXCIpO1xyXG5cclxuLy8gRXh0ZW5kIGZ1bmN0aW9uLCB0aGUgc25lYWt5IHdheS5cclxudmFyIHZhcmlhYmxlUHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGdW5jdGlvbi5wcm90b3R5cGUpO1xyXG5cclxudmFyaWFibGVQcm90b3R5cGUuY29uc3RydWN0b3IgPSBmdW5jdGlvbih2YWx1ZSwgeyBlbmZvcmNlTnVtYmVyID0gdHJ1ZSB9ID0ge30pIHtcclxuXHR2YXIgdmFyaWFibGUgPSB0aGlzO1xyXG5cdHZhcmlhYmxlLnZhbHVlID0gZW5mb3JjZU51bWJlciA/IHZhbHVlICogMSA6IHZhbHVlO1xyXG5cdHZhcmlhYmxlLmVuZm9yY2VOdW1iZXIgPSBlbmZvcmNlTnVtYmVyXHJcblxyXG5cdHRoaXMuaWQgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBfcGxheWFibGUuaWQ7XHJcblx0fTsgLy9UT0RPOiB3b3JrIG9uIGlkcyBhbmQgcmVnaXN0cmF0aW9uXHJcbn07XHJcblxyXG52YXJpYWJsZVByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMudmFsdWU7XHJcbn07XHJcblxyXG52YXJpYWJsZVByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5jYWxsKCk7XHJcbn07XHJcbnZhcmlhYmxlUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuY2FsbCgpO1xyXG59O1xyXG52YXJpYWJsZVByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuY2FsbCgpO1xyXG59O1xyXG5cclxudmFyaWFibGVQcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmV3VmFsdWUpIHtcclxuXHR0aGlzLnZhbHVlID0gdGhpcy5lbmZvcmNlTnVtYmVyID8gbmV3VmFsdWUgKiAxIDogbmV3VmFsdWVcclxuXHRyZXR1cm4gdGhpcy52YWx1ZTtcclxufTtcclxuXHJcbi8vUmVwdXJwb3NlIHRoZSB2ZXJ5LXNpbWlsYXIgY29kZSBmb3IgVmFyaWFibGUsIGJ1dCByZS13cml0ZSBjZXJ0YWluIGtleXNcclxudmFyIGV4cHJlc3Npb25Qcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZ1bmN0aW9uLnByb3RvdHlwZSk7XHJcblxyXG5leHByZXNzaW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZnVuY3Rpb24oZXhwcmVzc2lvbikge1xyXG5cdGlmICghaXNGdW5jdGlvbihleHByZXNzaW9uKSkgbG9nKFwiZXJyb3JcIiwgXCJFeHByZXNzaW9uIG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XHJcblxyXG5cdHZhciB2YWx1ZSA9IGV4cHJlc3Npb24oKTtcclxuXHRpZiAoaXNOYU4odmFsdWUpKSBsb2coXCJlcnJvclwiLCBcIkV4cHJlc3Npb24gbXVzdCByZXR1cm4gYSBudW1iZXJcIik7IC8vVE9ETzogc2hvdWxkIEV4cHJlc3Npb25zL1ZhcmlhYmxlcyBhbGxvdyBzdHJpbmdzP1xyXG5cclxuXHR0aGlzLnZhbHVlID0gZXhwcmVzc2lvbjtcclxuXHJcblx0cmV0dXJuIHZhbHVlO1xyXG59O1xyXG5cclxuZXhwcmVzc2lvblByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMudmFsdWUoKSAqIDE7XHJcbn07XHJcblxyXG5leHByZXNzaW9uUHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmNhbGwoKTtcclxufTtcclxuZXhwcmVzc2lvblByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmNhbGwoKTtcclxufTtcclxuZXhwcmVzc2lvblByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuY2FsbCgpO1xyXG59O1xyXG5cclxuZXhwcmVzc2lvblByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuZXdFeHByZXNzaW9uKSB7XHJcblx0aWYgKCFpc0Z1bmN0aW9uKG5ld0V4cHJlc3Npb24pKVxyXG5cdFx0bG9nKFwiZXJyb3JcIiwgXCJFeHByZXNzaW9uIG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XHJcblxyXG5cdHZhciB2YWx1ZSA9IG5ld0V4cHJlc3Npb24oKTtcclxuXHR0aGlzLnZhbHVlID0gbmV3RXhwcmVzc2lvbjtcclxuXHJcblx0cmV0dXJuIHZhbHVlO1xyXG59O1xyXG5cclxuLy9Qcm9kdWNlcyB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIHByb2R1Y2UgdGhlIGVuZCByZXN1bHQuIFRoaXMgcGFydCBpcyByZXVzYWJsZSBpZiB5b3UgbmVlZCB0byBkbyB0aGlzIGFnYWluLlxyXG52YXIgY2xhc3NGYWN0b3J5ID0gZnVuY3Rpb24ocHJvdG8pIHtcclxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgZiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gZi5jYWxsLmFwcGx5KGYsIGFyZ3VtZW50cyk7XHJcblx0XHR9O1xyXG5cclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcImNvbnN0cnVjdG9yXCIsIHtcclxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxyXG5cdFx0XHR3cml0YWJsZTogdHJ1ZVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJjYWxsXCIsIHtcclxuXHRcdFx0d3JpdGFibGU6IHRydWVcclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwidG9TdHJpbmdcIiwge1xyXG5cdFx0XHR3cml0YWJsZTogdHJ1ZVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJ2YWx1ZU9mXCIsIHtcclxuXHRcdFx0d3JpdGFibGU6IHRydWVcclxuXHRcdH0pO1xyXG5cclxuXHRcdE9iamVjdC5rZXlzKHByb3RvKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG5cdFx0XHRmW2tleV0gPSBwcm90b1trZXldO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Zi5jb25zdHJ1Y3Rvci5hcHBseShmLCBhcmd1bWVudHMpO1xyXG5cclxuXHRcdHJldHVybiBmO1xyXG5cdH07XHJcbn07XHJcblxyXG52YXIgVmFyaWFibGUgPSBjbGFzc0ZhY3RvcnkodmFyaWFibGVQcm90b3R5cGUpO1xyXG52YXIgRXhwcmVzc2lvbiA9IGNsYXNzRmFjdG9yeShleHByZXNzaW9uUHJvdG90eXBlKTtcclxuLy8gY2FsbGVkIGFzOiB2YXIgaW5zdGFuY2UgPSBWYXJpYWJsZSgpO1xyXG5cclxuLy8gQSBwcmUtYnVpbHQgRXhwcmVzc2lvbiBnZW5lcmF0b3IsIGZvciBnZW5lcmF0aW5nIHJhbmRvbSBudW1iZXJzXHJcbnZhciBSYW5kb21WYXJpYWJsZSA9IGZ1bmN0aW9uKHsgbG93ZXJib3VuZCA9IDAsIHVwcGVyYm91bmQgPSAxMCwgZ2VuZXJhdG9yID0gXCJ1bmlmb3JtXCIgfSkge1xyXG5cclxuXHRpZiAoaXNGdW5jdGlvbihnZW5lcmF0b3IpKSB7XHJcblx0XHR2YXIgZXhwcmVzc2lvbiA9IEV4cHJlc3Npb24oZ2VuZXJhdG9yKTtcclxuXHRcdGV4cHJlc3Npb24uZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xyXG5cdFx0cmV0dXJuIGV4cHJlc3Npb247XHJcblxyXG5cdH0gZWxzZSBpZiAoZ2VuZXJhdG9yLnRvTG93ZXJDYXNlKCkgPT0gXCJ1bmlmb3JtXCIpIHtcclxuXHRcdGdlbmVyYXRvciA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHVwcGVyYm91bmQgLSBsb3dlcmJvdW5kICsgMSkgKyBsb3dlcmJvdW5kKTtcclxuXHRcdH07XHJcblx0XHQvL1x0VE9ETzogYWRkIG1vcmUgZGlzdHJpYnV0aW9ucyBoZXJlLlxyXG5cdH1cclxuXHJcblx0cmV0dXJuIEV4cHJlc3Npb24oZ2VuZXJhdG9yKTtcclxufTtcclxuXHJcblxyXG5cclxuLy8gQSB3YXkgdG8gaGF2ZSBWYXJpYWJsZXMgd2hpY2ggYXJlIG1vcmUgY29tcGxpY2F0ZWQgdGhpbmdzLCBsaWtlIGFycmF5cyBvciBvYmVjdHNcclxudmFyIENvbXBsZXhWYXJpYWJsZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0dmFyIHZhcmlhYmxlID0gVmFyaWFibGUodmFsdWUsIHsgZW5mb3JjZU51bWJlcjogZmFsc2UgfSlcclxuXHJcblx0dmFyIGV4Y2x1ZGVMaXN0ID0gW1wic2V0XCIsIFwiY2FsbFwiLCBcInRvSlNPTlwiLCBcInRvU3RyaW5nXCIsIFwidmFsdWVPZlwiXVxyXG5cclxuXHR2YXIgaGFuZGxlciA9IHtcclxuXHRcdGdldCh0YXJnZXQsIGtleSkge1xyXG5cdFx0XHR2YXIgcHJvcDtcclxuXHRcdFx0aWYgKGV4Y2x1ZGVMaXN0LmluZGV4T2Yoa2V5KSA+IC0xKSBwcm9wID0gdGFyZ2V0W2tleV0uYmluZCh0YXJnZXQpO1xyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRwcm9wID0gdGFyZ2V0LnZhbHVlW2tleV1cclxuXHRcdFx0XHRpZiAoaXNGdW5jdGlvbihwcm9wKSkgcHJvcCA9IHByb3AuYmluZCh0YXJnZXQudmFsdWUpXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBwcm9wXHJcblx0XHR9LFxyXG5cdFx0c2V0KHRhcmdldCwga2V5LCBwcm9wKSB7XHJcblx0XHRcdHRhcmdldC52YWx1ZVtrZXldID0gcHJvcDtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBuZXcgUHJveHkodmFyaWFibGUsIGhhbmRsZXIpXHJcbn1cclxuXHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdHZhcmlhYmxlUHJvdG90eXBlLFxyXG5cdFZhcmlhYmxlLFxyXG5cdGV4cHJlc3Npb25Qcm90b3R5cGUsXHJcblx0RXhwcmVzc2lvbixcclxuXHRSYW5kb21WYXJpYWJsZSxcclxuXHRDb21wbGV4VmFyaWFibGVcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBDaG9pY2VcIik7XHJcblxyXG4vLyBFeHRlcm5hbCBkZXBlbmRlbmN5XHJcbnZhciB7IFN5bmNocm9ub3VzUHJvbWlzZSB9ID0gcmVxdWlyZShcInN5bmNocm9ub3VzLXByb21pc2VcIik7XHJcblxyXG4vL0dhbWUgc3RhdGUgY29udHJvbGxlcnNcclxudmFyIHsgcmVnaXN0cnkgfSA9IHJlcXVpcmUoXCIuLi9zdGF0ZVwiKTtcclxudmFyIHsgZ2FtZUhpc3RvcnkgfSA9IHJlcXVpcmUoXCIuLi9oaXN0b3J5XCIpO1xyXG52YXIgeyBQZXJmZWN0SW5mb3JtYXRpb24gfSA9IHJlcXVpcmUoXCIuLi9pbmZvcm1hdGlvblwiKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXItZnVuY3Rpb25zXCIpKFwic3RhdGVcIik7XHJcbnZhciB7IGlzRnVuY3Rpb24gfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXItZnVuY3Rpb25zXCIpKFwiZ2VuZXJhbFwiKTtcclxudmFyIHsgY2hhaW5lckdlbmVyYXRvciB9ID0gcmVxdWlyZShcIi4uL2hlbHBlci1mdW5jdGlvbnNcIikoXCJwbGF5YWJsZVwiKTtcclxuXHJcbi8vUGFyZW50IGNsYXNzXHJcbnZhciB7IF9QbGF5YWJsZSwgUGxheWFibGUgfSA9IHJlcXVpcmUoXCIuL3BsYXlhYmxlXCIpO1xyXG5cclxuLy9CYWNrZW5kIGZ1bmN0aW9uIGNsYXNzIGZvciBDaG9pY2VcclxuZnVuY3Rpb24gX0Nob2ljZShpZCwgcGxheWVyLCBvcHRpb25zLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRfUGxheWFibGUuY2FsbCh0aGlzLCBpZCk7XHJcblxyXG5cdHRoaXMubmV4dCA9IHt9O1xyXG5cclxuXHR0aGlzLnBsYXllciA9IHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyXTtcclxuXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG5cdHRoaXMuZGVmYXVsdE9wdGlvbiA9IHBhcmFtZXRlcnMuZGVmYXVsdE9wdGlvbiB8fCBvcHRpb25zWzBdOyAvL1RPRE86IG1ha2UgZGVmYXVsdE9wdGlvbiBmdW5jdGlvbmFsXHJcblx0dGhpcy5pbmZvcm1hdGlvbkZpbHRlciA9IHBhcmFtZXRlcnMuaW5mb3JtYXRpb25GaWx0ZXIgfHwgbnVsbDtcclxuXHR0aGlzLnVzZVBheW9mZnMgPSBwYXJhbWV0ZXJzLnVzZVBheW9mZnMgfHwgZmFsc2U7XHJcblxyXG5cdHJlZ2lzdHJ5LmNob2ljZXNbaWRdID0gdGhpcztcclxuXHJcblx0dmFyIGNob2ljZSA9IHRoaXM7XHJcblx0dGhpcy5vcHRpb25zLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG5cdFx0Y2hvaWNlLm5leHRbaXRlbV0gPSBbXTtcclxuXHR9KTtcclxufVxyXG5cclxuX0Nob2ljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9QbGF5YWJsZS5wcm90b3R5cGUpO1xyXG5fQ2hvaWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9DaG9pY2U7XHJcblxyXG5fQ2hvaWNlLnJlZ2lzdHJ5TmFtZSA9IFwiY2hvaWNlc1wiO1xyXG5fQ2hvaWNlLmNvdW50ZXJOYW1lID0gXCJjaG9pY2VcIjtcclxuXHJcbl9DaG9pY2UucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7XHJcblx0dXNlUGF5b2ZmcyA9IHRoaXMudXNlUGF5b2ZmcyxcclxuXHRoaXN0b3J5ID0gZ2FtZUhpc3RvcnksXHJcblx0aW5mb3JtYXRpb246IHJhd0luZm9ybWF0aW9uID0gUGVyZmVjdEluZm9ybWF0aW9uLFxyXG5cdHJlbGVhc2VQbGF5ZXIgPSB0cnVlLFxyXG5cdGluZm9ybWF0aW9uRmlsdGVyID0gdGhpcy5pbmZvcm1hdGlvbkZpbHRlcixcclxuXHRfY29tcGlsZUluZm9ybWF0aW9uID0gbnVsbFxyXG59ID0ge30pIHtcclxuXHR2YXIgY2hvaWNlID0gdGhpcztcclxuXHJcblx0aWYgKCFjaG9pY2UucGxheWVyLmFsaXZlKVxyXG5cdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KHtcclxuXHRcdFx0cmVzdWx0OiBjaG9pY2UuaWQgKyBcIjogUGxheWVyIFwiICsgY2hvaWNlLnBsYXllci5pZCArIFwiIGlzIGRlYWQuXCJcclxuXHRcdH0pO1xyXG5cclxuXHQvL1doaWxlIHRoaXMgY2hvaWNlIGlzIGhhcHBlbmluZywgZG9uJ3QgYWxsb3cgb3RoZXIgY2hvaWNlcyB0byB1c2UgdGhpcyBwbGF5ZXIuXHJcblx0Y2hvaWNlLnBsYXllci5hdmFpbGFibGUgPSBmYWxzZTtcclxuXHJcblx0Ly9JbmZvcm1hdGlvbiBtZWNoYW5pY3MuIElmIHdlJ3JlIGRlYWxpbmcgd2l0aCBQZXJmZWN0SW5mb3JtYXRpb24sIHRoaXMgd29uJ3QgZ2V0IGRlbGl2ZXJlZCwgc28gd2UnbGwgaW5jbHVkZSBpdCBpbiB0aGUgY2FsbCB0byAuZGVsaXZlcigpLiBJZiB3ZSdyZSB1c2luZyBhbiBpbmZvcm1hdGlvbiBzdXBwbGllZCBmcm9tIHNvbWUgb3RoZXIgcGxheWFibGUsIHRoZW4gdGhleSBjYW4gZG8gd2hhdCB0aGV5IGxpa2Ugd2l0aCBpdC5cclxuXHR2YXIgY2hvaWNlSW5mbyA9IHtcclxuXHRcdGNob2ljZToge1xyXG5cdFx0XHRpZDogY2hvaWNlLmlkLFxyXG5cdFx0XHRwbGF5ZXI6IGNob2ljZS5wbGF5ZXIuaWQsXHJcblx0XHRcdG9wdGlvbnM6IGNob2ljZS5vcHRpb25zXHJcblx0XHR9XHJcblx0fTtcclxuXHRyYXdJbmZvcm1hdGlvbi5hZGRBZGRpdGlvbmFsKGNob2ljZUluZm8pO1xyXG5cdC8vUGVyZm9ybSBzb21lIGRhdGEgcHJvY2Vzc2luZyBpZiBvdGhlciBwbGF5YWJsZXMgbmVlZCBpdC5cclxuXHRpZiAoX2NvbXBpbGVJbmZvcm1hdGlvbikgX2NvbXBpbGVJbmZvcm1hdGlvbihyYXdJbmZvcm1hdGlvbik7XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxyXG5cdFx0LnRoZW4oZnVuY3Rpb24oKSB7XHJcblx0XHRcdC8vUHJlcCBpbmZvcm1hdGlvblxyXG5cdFx0XHR2YXIgaW5mb3JtYXRpb24gPSByYXdJbmZvcm1hdGlvbi5kZWxpdmVyKGNob2ljZS5wbGF5ZXIsIGNob2ljZUluZm8pO1xyXG5cdFx0XHRpZiAoaW5mb3JtYXRpb25GaWx0ZXIpIGluZm9ybWF0aW9uID0gaW5mb3JtYXRpb25GaWx0ZXIoaW5mb3JtYXRpb24pO1xyXG5cclxuXHRcdFx0cmV0dXJuIGNob2ljZS5wbGF5ZXIuY2hvb3NlKGNob2ljZS5vcHRpb25zLnNsaWNlKDApLCBpbmZvcm1hdGlvbik7XHJcblx0XHR9KVxyXG5cdFx0LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdHZhciBwbGF5ZXIgPSBjaG9pY2UucGxheWVyO1xyXG5cdFx0XHR2YXIgaWQgPSBjaG9pY2UuaWQ7XHJcblxyXG5cdFx0XHQvL0FkZCB0byBwbGF5ZXIncyBpbmRpdmlkdWFsIGhpc3Rvcnk7XHJcblx0XHRcdHBsYXllci5oaXN0b3J5LnB1c2goe1xyXG5cdFx0XHRcdGNob2ljZTogaWQsXHJcblx0XHRcdFx0b3B0aW9uczogY2hvaWNlLm9wdGlvbnMsXHJcblx0XHRcdFx0cmVzdWx0XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0cmVzdWx0ID0gcmVzdWx0IHx8IGNob2ljZS5kZWZhdWx0T3B0aW9uO1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdE9iamVjdCA9IHtcclxuXHRcdFx0XHRyZXN1bHQsXHJcblx0XHRcdFx0aGlzdG9yeUVudHJ5OiB7XHJcblx0XHRcdFx0XHRjaG9pY2U6IGlkLFxyXG5cdFx0XHRcdFx0cGxheWVyOiBwbGF5ZXIuaWQsXHJcblx0XHRcdFx0XHRyZXN1bHRcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHQvL1RoaXMgd2lsbCBwcm9iYWJseSBvbmx5IGhhcHBlbiBpZiBpdCdzIGEgc2luZ2xlLXBsYXllciBnYW1lLCBvdGhlcndpc2Ugd2UnbGwgdXNlIHBsYXlvZmZzIGRlZmluZWQgaW4gYSBUdXJuXHJcblx0XHRcdGlmICh1c2VQYXlvZmZzKSB7XHJcblx0XHRcdFx0dmFyIHBheW91dCA9IGNob2ljZS5wYXlvZmZzW3Jlc3VsdF07XHJcblxyXG5cdFx0XHRcdHBsYXllci5zY29yZSArPSBwYXlvdXQ7XHJcblxyXG5cdFx0XHRcdC8vdHJhY2sgdGhlIHBheW9mZlxyXG5cdFx0XHRcdHZhciBzY29yZUVudHJ5ID0ge1xyXG5cdFx0XHRcdFx0Y2hvaWNlOiBpZCxcclxuXHRcdFx0XHRcdHBheW91dHM6IHtcclxuXHRcdFx0XHRcdFx0W3BsYXllci5pZF06IE51bWJlcihwYXlvdXQpXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0aGlzdG9yeS5hZGRTY29yZXMoc2NvcmVFbnRyeSk7XHJcblx0XHRcdFx0cmVzdWx0T2JqZWN0Lmhpc3RvcnlFbnRyeS5wYXlvdXRzID0ge1xyXG5cdFx0XHRcdFx0W3BsYXllci5pZF06IHBheW91dFxyXG5cdFx0XHRcdH07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxvZyhcclxuXHRcdFx0XHRcInNpbGx5XCIsXHJcblx0XHRcdFx0XCJfQ2hvaWNlLnBsYXk6IHJlbW92aW5nIGZyb20gb2NjdXBpZWRQbGF5ZXJzOiBcIixcclxuXHRcdFx0XHRjaG9pY2UucGxheWVyLmlkXHJcblx0XHRcdCk7XHJcblx0XHRcdGlmIChyZWxlYXNlUGxheWVyKSBjaG9pY2UucmVsZWFzZVBsYXllcigpO1xyXG5cclxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRPYmplY3QpOyAvL1RPRE86IGFkZCBpbmZvcm1hdGlvbiBtZWNoYW5pc21zXHJcblx0XHR9KTtcclxufTtcclxuXHJcbi8vUmVsZWFzZSBwbGF5ZXIgZnJvbSBleGNsdWRlZCBwbGF5ZXJzIGxpc3QsIHNvIHRoYXQgb3RoZXIgb2JqZWN0cyBjYW4gdXNlIGl0LlxyXG5fQ2hvaWNlLnByb3RvdHlwZS5yZWxlYXNlUGxheWVyID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5wbGF5ZXIuYXZhaWxhYmxlID0gdHJ1ZTtcclxufTtcclxuXHJcbl9DaG9pY2UucHJvdG90eXBlLmZpbmROZXh0ID0gZnVuY3Rpb24oeyByZXN1bHQgfSA9IHt9KSB7XHJcblx0cmV0dXJuIHRoaXMubmV4dFtyZXN1bHQucmVzdWx0XTtcclxufTtcclxuXHJcbl9DaG9pY2UucHJvdG90eXBlLmdlbmVyYXRlQ2hhaW5pbmdGdW5jdGlvbnMgPSBmdW5jdGlvbihjaG9pY2UpIHtcclxuXHR2YXIgX2Nob2ljZSA9IHRoaXM7XHJcblxyXG5cdF9jaG9pY2Uub3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKG9wdGlvbikge1xyXG5cdFx0X2Nob2ljZS5wYXlvZmZzW29wdGlvbl0gPSAwOyAvL1N0YXJ0IHBheW9mZnMgYXQgemVyb1xyXG5cclxuXHRcdGNob2ljZVtvcHRpb25dID0gZnVuY3Rpb24ocGF5b2ZmKSB7XHJcblx0XHRcdC8vQ3JlYXRlIGZ1bmN0aW9ucyBmb3IgdXNlciB0byBhc3NpZ24gcGF5b2Zmc1xyXG5cdFx0XHRpZiAoIWlzTmFOKHBheW9mZikpIF9jaG9pY2UucGF5b2Zmc1tvcHRpb25dID0gcGF5b2ZmO1xyXG5cdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoe1xyXG5cdFx0XHRcdHBsYXlhYmxlOiBjaG9pY2UsXHJcblx0XHRcdFx0cGF0aDogW29wdGlvbl1cclxuXHRcdFx0fSk7XHJcblx0XHR9O1xyXG5cdH0pO1xyXG59O1xyXG5cclxuX0Nob2ljZS5wcm90b3R5cGUuc3VtbWFyeVRoaXMgPSBmdW5jdGlvbihzdW1tYXJ5KSB7XHJcblx0c3VtbWFyeS5wbGF5ZXIgPSB0aGlzLnBsYXllci5pZDtcclxuXHRzdW1tYXJ5Lm9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2xpY2UoKTtcclxuXHJcblx0cmV0dXJuIHN1bW1hcnk7XHJcbn07XHJcblxyXG4vL1RPRE86IHVuLWZ1Y2sgdGhpcy5cclxuX0Nob2ljZS5wcm90b3R5cGUuc3VtbWFyeU5leHQgPSBmdW5jdGlvbihcclxuXHRzdW1tYXJ5LFxyXG5cdGVudHJpZXMgPSB7fSxcclxuXHRzaG9ydENpcmN1aXQgPSBmYWxzZSxcclxuXHRtYXhFbnRyaWVzID0gMTBcclxuKSB7XHJcblx0Ly8gQ29weSBvdmVyIHRoZSBjaG9pY2Ugb3B0aW9uc1xyXG5cdHN1bW1hcnkubmV4dCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMubmV4dCk7XHJcblxyXG5cdC8vIExvb3AgdGhyb3VnaCB0aGVtIGFuZCBzdW1tYXJpemUgYXQgZWFjaCBzdGVwLlxyXG5cdHZhciBjb3VudCA9IDA7XHJcblx0Zm9yICh2YXIga2V5IGluIHN1bW1hcnkubmV4dCkge1xyXG5cdFx0c3VtbWFyeS5uZXh0W2tleV0gPSBzdW1tYXJ5Lm5leHRba2V5XS5tYXAoZnVuY3Rpb24ocGxheWFibGUpIHtcclxuXHRcdFx0Y291bnQrKztcclxuXHRcdFx0cmV0dXJuIHBsYXlhYmxlLnN1bW1hcml6ZSh7fSwgZW50cmllcyk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8vIElmIHRoZXJlIHdlcmVuJ3QgYW55IG5leHQgc3RlcHMsIGRlbGV0ZSB0aGUgbmV4dCBrZXksIHRvIHJlZHVjZSBjbHV0dGVyLlxyXG5cdGlmIChjb3VudCA9PSAwKSBkZWxldGUgc3VtbWFyeS5uZXh0O1xyXG5cclxuXHRyZXR1cm4gc3VtbWFyeTtcclxufTtcclxuXHJcbi8vU2V0IGFsbCBwYXlvZmZzIHRvIHplcm8uXHJcbl9DaG9pY2UucHJvdG90eXBlLnplcm9QYXlvZmZzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGNob2ljZSA9IHRoaXM7XHJcblxyXG5cdGNob2ljZS5wYXlvZmZzID0ge307XHJcblxyXG5cdGNob2ljZS5vcHRpb25zLmZvckVhY2goZnVuY3Rpb24ob3B0aW9uKSB7XHJcblx0XHRjaG9pY2UucGF5b2Zmc1tvcHRpb25dID0gMDtcclxuXHR9KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIENob2ljZShwbGF5ZXIsIG9wdGlvbnMsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihwYXJhbWV0ZXJzLmlkLCBcImNob2ljZVwiKTtcclxuXHJcblx0Ly9JZiBpbmZvcm1hdGlvbkZpbHRlciB3YXMgc3VwcGxpZWQsIGl0IG11c3QgYmUgYSBmdW5jdGlvblxyXG5cdGlmIChwYXJhbWV0ZXJzLmluZm9ybWF0aW9uRmlsdGVyICYmICFpc0Z1bmN0aW9uKHBhcmFtZXRlcnMuaW5mb3JtYXRpb25GaWx0ZXIpKVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiaW5mb3JtYXRpb25GaWx0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIGNob2ljZSBvYmplY3RcclxuXHR2YXIgX2Nob2ljZSA9IG5ldyBfQ2hvaWNlKGlkLCBwbGF5ZXIuaWQoKSwgb3B0aW9ucywgcGFyYW1ldGVycyk7XHJcblxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgY2hvaWNlID0gUGxheWFibGUoX2Nob2ljZSk7XHJcblxyXG5cdC8vSW50ZXJmYWNlIHRvIHNwZWNpZnkgc2luZ2xlLXBsYXllciBwYXlvZmZzIGluIHNpbmdsZS1wbGF5ZXIvc2luZ2xlLWNob2ljZSBnYW1lc1xyXG5cdF9jaG9pY2UuemVyb1BheW9mZnMoKTtcclxuXHJcblx0X2Nob2ljZS5nZW5lcmF0ZUNoYWluaW5nRnVuY3Rpb25zKGNob2ljZSk7XHJcblxyXG5cdC8qXHJcblx0b3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKG9wdGlvbil7XHJcblx0XHRfY2hvaWNlLnBheW9mZnNbb3B0aW9uXSA9IDA7XHRcdFx0Ly9TdGFydCBwYXlvZmZzIGF0IHplcm9cclxuXHJcblx0XHRjaG9pY2Vbb3B0aW9uXSA9IGZ1bmN0aW9uKHBheW9mZil7XHRcdFx0XHRcdC8vQ3JlYXRlIGZ1bmN0aW9ucyBmb3IgdXNlciB0byBhc3NpZ24gcGF5b2Zmc1xyXG5cdFx0XHRpZiAoIWlzTmFOKHBheW9mZikpX2Nob2ljZS5wYXlvZmZzW29wdGlvbl0gPSBwYXlvZmY7XHJcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xyXG5cdFx0XHRcdHBsYXlhYmxlOmNob2ljZSxcclxuXHRcdFx0XHRwYXRoOltvcHRpb25dXHJcblx0XHRcdH0pXHJcblx0XHR9O1xyXG5cdH0pO1xyXG5cdCovXHJcblxyXG5cdC8vRnVuY3Rpb24gdG8gc2V0IGFsbCBwYXlvZmZzIGF0IG9uY2VcclxuXHRjaG9pY2Uuc2V0QWxsUGF5b2ZmcyA9IGZ1bmN0aW9uKHBheW9mZnMpIHtcclxuXHRcdGlmICghQXJyYXkuaXNBcnJheShwYXlvZmZzKSkgdGhyb3cgbmV3IEVycm9yKFwiUGF5b2ZmcyBtdXN0IGJlIGFycmF5XCIpXHJcblx0XHRpZiAocGF5b2Zmcy5sZW5ndGggIT0gcmVnaXN0cnkuY2hvaWNlc1tpZF0ub3B0aW9ucy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcclxuXHRcdFx0XCJQYXlvZmZzIG11c3QgYmUgc2FtZSBkaW1lbnNpb25zIGFzIGNob2ljZSBvcHRpb25zXCIpXHJcblxyXG5cdFx0cGF5b2Zmcy5mb3JFYWNoKGZ1bmN0aW9uKHBheW9mZiwgaW5kZXgpIHtcclxuXHRcdFx0cmVnaXN0cnkuY2hvaWNlc1tpZF0ucGF5b2Zmc1tvcHRpb25zW2luZGV4XV0gPSBwYXlvZmY7XHJcblx0XHR9KVxyXG5cdFx0Ly9UT0RPOiBtYWtlIHRoaXMgd29yay4gSW5jbHVkZSBlcnJvciBoYW5kbGluZyBpZiBhcnJheSBnaXZlbiBpc24ndCBleHBlY3RlZCBkaW1lbnNpb25zLlxyXG5cdH07XHJcblxyXG5cdC8vV2F5IGZvciB1c2VyIHRvIGludGVyYWN0IHdpdGggcGF5b2Zmc1xyXG5cdGNob2ljZS5wYXlvZmZzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gcmVnaXN0cnkuY2hvaWNlc1tpZF0ucGF5b2ZmcztcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gY2hvaWNlO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX0Nob2ljZSwgQ2hvaWNlIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XHJcbmxvZyhcImRlYnVnXCIsIFwiTG9hZGluZyBDbGFzczogQ29uc2VjdXRpdmVcIik7XHJcblxyXG4vL0dhbWUgc3RhdGUgY29udHJvbGxlcnNcclxudmFyIHsgcmVnaXN0cnkgfSA9IHJlcXVpcmUoXCIuLi9zdGF0ZVwiKTtcclxudmFyIHsgZ2FtZUhpc3RvcnkgfSA9IHJlcXVpcmUoXCIuLi9oaXN0b3J5XCIpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlkSGFuZGxlciB9ID0gcmVxdWlyZShcIi4uL2hlbHBlci1mdW5jdGlvbnNcIikoXCJzdGF0ZVwiKTtcclxuXHJcbi8vSW5mb3JtYXRpb25cclxudmFyIHsgSW5mb3JtYXRpb24sIFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0gcmVxdWlyZShcIi4uL2luZm9ybWF0aW9uXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9ID0gcmVxdWlyZShcIi4vcGxheWFibGVcIik7XHJcblxyXG4vL0JhY2tlbmQgZnVuY3Rpb24gY2xhc3MgZm9yIENvbnNlY3V0aXZlXHJcbmZ1bmN0aW9uIF9Db25zZWN1dGl2ZShpZCwgcGxheWFibGVzQXJyYXksIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdF9QbGF5YWJsZS5jYWxsKHRoaXMsIGlkLCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0cGxheWFibGVzQXJyYXkgPSBwbGF5YWJsZXNBcnJheS5tYXAoZnVuY3Rpb24ocGxheWFibGUpIHtcclxuXHRcdHJldHVybiByZWdpc3RyeS5wbGF5YWJsZXNbcGxheWFibGUuaWQoKV1cclxuXHR9KVxyXG5cdHRoaXMucGxheWFibGVzQXJyYXkgPSBwbGF5YWJsZXNBcnJheVxyXG5cclxuXHRyZWdpc3RyeS5jb25zZWN1dGl2ZXNbaWRdID0gdGhpcztcclxufVxyXG5fQ29uc2VjdXRpdmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfUGxheWFibGUucHJvdG90eXBlKTtcclxuX0NvbnNlY3V0aXZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9Db25zZWN1dGl2ZTtcclxuXHJcbl9Db25zZWN1dGl2ZS5yZWdpc3RyeU5hbWUgPSBcImNvbnNlY3V0aXZlc1wiO1xyXG5fQ29uc2VjdXRpdmUuY291bnRlck5hbWUgPSBcImNvbnNlY3V0aXZlXCI7XHJcblxyXG5fQ29uc2VjdXRpdmUucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7XHJcblx0aGlzdG9yeSA9IGdhbWVIaXN0b3J5LFxyXG5cdGluZm9ybWF0aW9uID0gdGhpcy5pbmZvcm1hdGlvbiB8fFxyXG5cdFBlcmZlY3RJbmZvcm1hdGlvblxyXG59ID0ge30pIHtcclxuXHJcblx0dmFyIGNvbnNlY3V0aXZlID0gdGhpcztcclxuXHJcblx0Ly9Mb2cgdGhlIGhpc3RvcnkgYXBwcm9wcmlhdGVseVxyXG5cdHZhciBzdGFydEVudHJ5ID0ge1xyXG5cdFx0Y29uc2VjdXRpdmU6IGNvbnNlY3V0aXZlLmlkLFxyXG5cdFx0YWN0aW9uOiBcInN0YXJ0XCJcclxuXHR9O1xyXG5cdGhpc3RvcnkubG9nLmFkZChzdGFydEVudHJ5KTtcclxuXHJcblx0Ly9IaXN0b3J5IG9iamVjdCB0byBnaXZlIHRvIGNvbnNlY3V0aXZlZCBwbGF5YWJsZXMuXHJcblx0dmFyIGNvbnNlY3V0aXZlSGlzdG9yeSA9IGhpc3RvcnkuY2hpbGQoKTtcclxuXHJcblx0Ly9jb21wYXJ0bWVudGFsaXplIGlmIHNldC4gXCJjb21wYXJ0bWVudGFsaXplXCIgbWVhbnMgcGFzcyBvbiBpbmZvcm1hdGlvbiBhcyBpZiB0aGlzIHBsYXlhYmxlIGlzIHRoZSBlbnRpcmUgZ2FtZS5cclxuXHRpZiAoY29uc2VjdXRpdmUuY29tcGFydG1lbnRhbGl6ZSkge1xyXG5cdFx0aW5mb3JtYXRpb24gPSBuZXcgSW5mb3JtYXRpb24oY29uc2VjdXRpdmUuY29tcGFydG1lbnRhbGl6ZS5oaXN0b3J5IHx8IGNvbnNlY3V0aXZlSGlzdG9yeSxcclxuXHRcdFx0Y29uc2VjdXRpdmUuY29tcGFydG1lbnRhbGl6ZS5wb3B1bGF0aW9uIHx8IGluZm9ybWF0aW9uLnBvcHVsYXRpb24pO1xyXG5cdH1cclxuXHJcblx0dmFyIGFjdGlvbiA9IGZ1bmN0aW9uIGFjdGlvbihwbGF5YWJsZXNBcnJheSkge1xyXG5cdFx0Ly9TdG9wIGlmIHRoZSBnYW1lIGlzIG92ZXIuXHJcblx0XHRpZiAoaGlzdG9yeS5zdG9wKSByZXR1cm4geyBwbGF5YWJsZTogY29uc2VjdXRpdmUgfTtcclxuXHJcblx0XHRpZiAocGxheWFibGVzQXJyYXkubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRyZXR1cm4gcGxheWFibGVzQXJyYXkuc2hpZnQoKS5wbGF5KHsgc2hvcnRDaXJjdWl0OiB0cnVlLCBoaXN0b3J5OiBjb25zZWN1dGl2ZUhpc3RvcnksIGluZm9ybWF0aW9uIH0pXHJcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gYWN0aW9uKHBsYXlhYmxlc0FycmF5KSB8fCByZXN1bHRcclxuXHRcdFx0XHR9KVxyXG5cdFx0fSBlbHNlIHJldHVybiBmYWxzZVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGFjdGlvbihjb25zZWN1dGl2ZS5wbGF5YWJsZXNBcnJheS5zbGljZSgpKVxyXG5cdFx0LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdHJlc3VsdC5oaXN0b3J5RW50cnkgPSB7XHJcblx0XHRcdFx0Y29uc2VjdXRpdmU6IGNvbnNlY3V0aXZlLmlkLFxyXG5cdFx0XHRcdGFjdGlvbjogY29uc2VjdXRpdmVIaXN0b3J5Lm9ycGhhbigpXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHQvL1RPRE86IGFkZCBpbmZvcm1hdGlvbiBtZWNoYW5pc21zXHJcblxyXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcblx0XHR9KTtcclxufTtcclxuXHJcbi8vT3ZlcndyaXRlIGhpc3RvcnkgaGFuZGxlciBzbyB0aGF0IHRyZWUgZG9lc24ndCBoYXZlIFwic3RhcnRcIiBhbmQgXCJmaW5pc2hcIiBlbnRyaWVzLlxyXG5fQ29uc2VjdXRpdmUucHJvdG90eXBlLmhhbmRsZUhpc3RvcnkgPSBmdW5jdGlvbih7IGhpc3RvcnkgPSBnYW1lSGlzdG9yeSB9ID0ge30sXHJcblx0cmVzdWx0XHJcbikge1xyXG5cdHZhciBjb25zZWN1dGl2ZSA9IHRoaXM7XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0aGlzdG9yeS5sb2cuYWRkKHtcclxuXHRcdFx0Y29uc2VjdXRpdmU6IGNvbnNlY3V0aXZlLmlkLFxyXG5cdFx0XHRhY3Rpb246IFwiZmluaXNoXCIsXHJcblx0XHRcdGR1cmF0aW9uOiByZXN1bHQuaGlzdG9yeUVudHJ5LmR1cmF0aW9uXHJcblx0XHR9KTtcclxuXHJcblx0XHRoaXN0b3J5LmFkZE5vTG9nKHJlc3VsdC5oaXN0b3J5RW50cnkpO1xyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuLy9UT0RPOiBmaW5pc2ggdGhpcyFcclxuX0NvbnNlY3V0aXZlLnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnksIGVudHJpZXMsIHNob3J0Q2lyY3VpdCkge1xyXG5cdHN1bW1hcnkuYWN0aW9uID0ge307XHJcblxyXG5cdHRoaXMucGxheWFibGVTdGFydC5zdW1tYXJpemUoXHJcblx0XHRzdW1tYXJ5LmFjdGlvbixcclxuXHRcdGVudHJpZXMsXHJcblx0XHQoc2hvcnRDaXJjdWl0ID0gdGhpcy5wbGF5YWJsZUZpbmlzaClcclxuXHQpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gQ29uc2VjdXRpdmUocGxheWFibGVzQXJyYXksIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihwYXJhbWV0ZXJzLmlkLCBcImNvbnNlY3V0aXZlXCIpO1xyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIGxvb3Agb2JqZWN0XHJcblx0dmFyIF9jb25zZWN1dGl2ZSA9IG5ldyBfQ29uc2VjdXRpdmUoaWQsIHBsYXlhYmxlc0FycmF5LCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0Ly9SZXR1cm4gdGhpcyByZWZlcmVuY2Ugb2JqZWN0IHRvIHRoZSB1c2VyLiBSdW4gdGhlIGZ1bmN0aW9uIHRvIHNlbGVjdCBhIHNvdXJjZVxyXG5cdHZhciBjb25zZWN1dGl2ZSA9IFBsYXlhYmxlKF9jb25zZWN1dGl2ZSk7XHJcblxyXG5cdGNvbnNlY3V0aXZlLmlkcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHBsYXlhYmxlc0FycmF5Lm1hcChmdW5jdGlvbihwbGF5YWJsZSkge1xyXG5cdFx0XHRyZXR1cm4gcGxheWFibGUuaWQoKTtcclxuXHRcdH0pXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gY29uc2VjdXRpdmU7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBfQ29uc2VjdXRpdmUsIENvbnNlY3V0aXZlIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgQ2xhc3M6IEhhbHRJZlwiKVxyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7cmVnaXN0cnl9ID0gcmVxdWlyZSgnLi4vc3RhdGUnKTtcclxudmFyIHtnYW1lSGlzdG9yeX0gPSByZXF1aXJlKCcuLi9oaXN0b3J5Jyk7XHJcblxyXG4vL0hlbHBlciBmdW5jdGlvbnNcclxudmFyIHtpc0Z1bmN0aW9ufVx0PSByZXF1aXJlKCcuLi9oZWxwZXItZnVuY3Rpb25zJykoXCJnZW5lcmFsXCIpO1xyXG52YXIge2lkSGFuZGxlcn0gXHQ9IHJlcXVpcmUoJy4uL2hlbHBlci1mdW5jdGlvbnMnKShcInN0YXRlXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHtfUGxheWFibGUsIFBsYXlhYmxlfSA9IHJlcXVpcmUoJy4vcGxheWFibGUnKTtcclxuXHJcblxyXG5cclxuLy9CYWNrZW5kIGZ1bmN0aW9uIGNsYXNzIGZvciBHYW1lXHJcbmZ1bmN0aW9uIF9IYWx0KGlkLHRlc3RDb25kaXRpb24sIHtsb2dDb250aW51ZSA9IGZhbHNlfSl7XHJcblx0X1BsYXlhYmxlLmNhbGwodGhpcyxpZCk7XHJcblx0XHJcblx0dGhpcy50ZXN0Q29uZGl0aW9uID0gdGVzdENvbmRpdGlvbjtcclxuXHR0aGlzLmxvZ0NvbnRpbnVlID0gbG9nQ29udGludWU7XHJcblx0XHJcblx0cmVnaXN0cnkuaGFsdHNbaWRdID0gdGhpcztcclxufVxyXG5cclxuX0hhbHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfUGxheWFibGUucHJvdG90eXBlKTtcclxuX0hhbHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gX0hhbHQ7XHJcblxyXG5fSGFsdC5yZWdpc3RyeU5hbWUgPSBcImhhbHRzXCI7XHJcbl9IYWx0LmNvdW50ZXJOYW1lID0gXCJoYWx0SWZcIjtcclxuXHJcbl9IYWx0LnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oe2luaXRpYWxpemVQbGF5ZXJzPWZhbHNlLCBzaG9ydENpcmN1aXQ9ZmFsc2UsIGhpc3Rvcnk9Z2FtZUhpc3Rvcnl9PXt9KXtcclxuXHRcclxuXHR2YXIgaGFsdCA9IHRoaXM7XHJcblx0XHJcblx0dmFyIHJlc3VsdE9iamVjdCA9IHtcclxuXHRcdCdwbGF5YWJsZSc6aGFsdCxcclxuXHRcdCdoaXN0b3J5RW50cnknOntcclxuXHRcdFx0J2hhbHQnOmhhbHQuaWRcclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdHZhciB0ZXN0ID0gaGFsdC50ZXN0Q29uZGl0aW9uKCk7XHJcblx0XHJcblx0XHJcblx0aWYgKHRlc3QpIHtcclxuXHRcdGxvZyhcImluZm9cIiwgXCJIYWx0aW5nIGF0IFwiICsgaGFsdC5pZClcclxuXHRcdFxyXG5cdFx0cmVzdWx0T2JqZWN0Lmhpc3RvcnlFbnRyeS5hY3Rpb24gPSBcImhhbHRcIjtcclxuXHRcdHJlc3VsdE9iamVjdC5yZXN1bHQgPSBcIkhhbHRcIjtcclxuXHRcclxuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdChyZXN1bHRPYmplY3QpO1xyXG5cdH1cclxuXHRcclxuXHQvL0hhbHQgcHJvYmFibHkgZ2V0cyB1c2VkIGZvciBsb29wcywgYW5kIHdlIG1pZ2h0IG5vdCB3YW50IHRvIHNlZSBsb3RzIG9mIGNvbnRpbnVlIG1lc3NhZ2VzLCBzbyBcImxvZ0NvbnRpbnVlXCIgd2lsbCBvbWl0IHRoZW0uXHJcblx0aWYgKGhhbHQubG9nQ29udGludWUpIHtcclxuXHRcdHJlc3VsdE9iamVjdC5oaXN0b3J5RW50cnkuYWN0aW9uID0gXCJjb250aW51ZVwiO1xyXG5cdH1cclxuXHRlbHNlIGRlbGV0ZSByZXN1bHRPYmplY3QuaGlzdG9yeUVudHJ5XHJcblx0XHJcblx0XHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRPYmplY3QpXHJcbn07XHJcblxyXG5cclxuX0hhbHQucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSl7XHJcblx0c3VtbWFyeS5jb25kaXRpb24gPSB0aGlzLnRlc3RDb25kaXRpb24udG9TdHJpbmcoKTtcclxufVxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBIYWx0SWYodGVzdENvbmRpdGlvbj1mdW5jdGlvbigpe30sIHtpZD1udWxsLCBsb2dDb250aW51ZT1mYWxzZX09e30pe1xyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihpZCxcImhhbHRJZlwiKVxyXG5cdFxyXG5cdGlmICghaXNGdW5jdGlvbih0ZXN0Q29uZGl0aW9uKSkgbG9nKFwid2FyblwiLGlkICsgXCI6IHRlc3RDb25kaXRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24sIG9yIGVsc2UgZ2FtZSB3aWxsIG5vdCBoYWx0LlwiKVxyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIGxvb3Agb2JqZWN0XHJcblx0dmFyIF9oYWx0ID0gbmV3IF9IYWx0KGlkLCB0ZXN0Q29uZGl0aW9uLCB7bG9nQ29udGludWV9KTtcclxuXHRcclxuXHRcclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIGhhbHQgPSBQbGF5YWJsZShfaGFsdCk7XHRcclxuXHRyZXR1cm4gaGFsdDtcdFxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7X0hhbHQsIEhhbHRJZn07IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vL0xvYWRzIHRoZSBwbGF5YWJsZXMgdGhhdCB3aWxsIGJlIHVzZWQgYnkgTmFzaC4gVGhpcyBpcyBiYXNpY2FsbHkgdGhlIGNvbnRyb2xsZXIgbGlzdDogaWYgaXQncyBub3QgaW4gdGhlc2UgbGlzdHMsXHJcbi8vIHRoZW4gaXQgd29uJ3QgYmUgYXZhaWxhYmxlIGZvciB1cy5cclxuXHJcbi8vRXh0ZXJuYWwgZGVwZW5kZW5jeVxyXG52YXIgcHJlc2VudCA9IHJlcXVpcmUoXCJwcmVzZW50XCIpO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XHJcblxyXG52YXIgeyBhcHBseUJpbmQgfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXItZnVuY3Rpb25zXCIpKFwiZ2VuZXJhbFwiKTtcclxuXHJcbmxvZyhcImRlYnVnXCIsIFwiTG9hZGluZyBQbGF5YWJsZSBDbGFzc2VzOiBcIik7XHJcblxyXG4vL1BsYXlhYmxlc1xyXG52YXIgeyBfUGxheWFibGUgfSA9IHJlcXVpcmUoXCIuL3BsYXlhYmxlXCIpO1xyXG52YXIgeyBfQ2hvaWNlLCBDaG9pY2UgfSA9IHJlcXVpcmUoXCIuL2Nob2ljZVwiKTtcclxudmFyIHsgX1R1cm4sIFR1cm4gfSA9IHJlcXVpcmUoXCIuL3R1cm5cIik7XHJcbnZhciB7IF9TZXF1ZW5jZSwgU2VxdWVuY2UgfSA9IHJlcXVpcmUoXCIuL3NlcXVlbmNlXCIpO1xyXG52YXIgeyBfQ29uc2VjdXRpdmUsIENvbnNlY3V0aXZlIH0gPSByZXF1aXJlKFwiLi9jb25zZWN1dGl2ZVwiKTtcclxudmFyIHsgX0xvb3AsIExvb3AgfSA9IHJlcXVpcmUoXCIuL2xvb3BcIik7XHJcbnZhciB7IF9TTG9vcCwgU3RvY2hhc3RpY0xvb3AgfSA9IHJlcXVpcmUoXCIuL3N0b2NoYXN0aWNMb29wXCIpO1xyXG52YXIgeyBfSGFsdCwgSGFsdElmIH0gPSByZXF1aXJlKFwiLi9oYWx0LWlmXCIpO1xyXG52YXIgeyBfU0hhbHQsIFN0b2NoYXN0aWNIYWx0IH0gPSByZXF1aXJlKFwiLi9zdG9jaGFzdGljLWhhbHRcIik7XHJcbnZhciB7IF9MYW1iZGEsIExhbWJkYSB9ID0gcmVxdWlyZShcIi4vbGFtYmRhXCIpO1xyXG52YXIgeyBfUlBDaG9pY2UsIFJhbmRvbVBsYXllckNob2ljZSB9ID0gcmVxdWlyZShcIi4vcmFuZG9tLXBsYXllci1jaG9pY2VcIik7XHJcbnZhciB7IF9Qb3B1bGF0aW9uRHluYW1pY3MsIFBvcHVsYXRpb25EeW5hbWljcyB9ID0gcmVxdWlyZShcIi4vcG9wdWxhdGlvbi1keW5hbWljc1wiKTtcclxudmFyIHsgX1NpbXVsdGFuZW91cywgU2ltdWx0YW5lb3VzIH0gPSByZXF1aXJlKFwiLi9zaW11bHRhbmVvdXNcIik7XHJcblxyXG4vL1J1bnMgd2hlbiBsb2FkaW5nIFBsYXlhYmxlIGNsYXNzZXMuXHJcbmZ1bmN0aW9uIGluaXRpYWxpemVQbGF5YWJsZUNsYXNzKHBsYXlhYmxlQ2xhc3MpIHtcclxuXHQvL1JlcGxhY2UgdGhlIC5wbGF5KCkgbWV0aG9kIHdpdGggYSB3cmFwcGVyIHdoaWNoIGNhbGxzIGl0IGFuZCBhIGZldyBvdGhlciBmdW5jdGlvbnNcclxuXHRpZiAocGxheWFibGVDbGFzcy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoXCJwbGF5XCIpKSB7XHJcblx0XHRwbGF5YWJsZUNsYXNzLnByb3RvdHlwZS5wbGF5ID0gKGZ1bmN0aW9uKHBsYXkpIHtcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHsgaGlzdG9yeSA9IGdhbWVIaXN0b3J5IH0gPSB7fSkge1xyXG5cdFx0XHRcdHZhciBwbGF5YWJsZSA9IHRoaXM7XHJcblx0XHRcdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcblxyXG5cdFx0XHRcdC8vIFNldCBvdXIgaGlzdG9yeVxyXG5cdFx0XHRcdGFyZ3NbMF0uaGlzdG9yeSA/IG51bGwgOiBhcmdzWzBdLmhpc3RvcnkgPSB0aGlzLmhpc3RvcnkgfHwgZ2FtZUhpc3RvcnlcclxuXHJcblx0XHRcdFx0Ly8gaG93IHRvIGhhbHQgdGhlIGdhbWUgd2l0aG91dCBlcnJvcnMuIFRPRE8gdGhpcyBpcyBwcm9iYWJseSBmdWNrZWRcclxuXHRcdFx0XHRpZiAoaGlzdG9yeS5zdG9wKSByZXR1cm4geyBwbGF5YWJsZSB9O1xyXG5cclxuXHJcblx0XHRcdFx0cmV0dXJuIF9QbGF5YWJsZS5wcm90b3R5cGUuX3N0YXJ0VGltZXJcclxuXHRcdFx0XHRcdC5hcHBseShwbGF5YWJsZSwgYXJncylcclxuXHRcdFx0XHRcdC50aGVuKGFwcGx5QmluZChwbGF5YWJsZS5jaGVja0luaXQsIHBsYXlhYmxlLCBhcmdzKSlcclxuXHRcdFx0XHRcdC50aGVuKGFwcGx5QmluZChwbGF5YWJsZS5wcmVQbGF5LCBwbGF5YWJsZSwgYXJncykpXHJcblx0XHRcdFx0XHQudGhlbihhcHBseUJpbmQocGxheSwgcGxheWFibGUsIGFyZ3MpKVxyXG5cdFx0XHRcdFx0LnRoZW4oYXBwbHlCaW5kKHBsYXlhYmxlLnBvc3RQbGF5LCBwbGF5YWJsZSwgYXJncykpXHJcblx0XHRcdFx0XHQudGhlbihhcHBseUJpbmQoX1BsYXlhYmxlLnByb3RvdHlwZS5fc3RvcFRpbWVyLCBwbGF5YWJsZSwgYXJncykpXHJcblx0XHRcdFx0XHQudGhlbihhcHBseUJpbmQocGxheWFibGUuaGFuZGxlSGlzdG9yeSwgcGxheWFibGUsIGFyZ3MpKVxyXG5cdFx0XHRcdFx0LnRoZW4oYXBwbHlCaW5kKF9QbGF5YWJsZS5wcm90b3R5cGUucHJvY2VlZCwgcGxheWFibGUsIGFyZ3MpKTtcclxuXHRcdFx0fTtcclxuXHRcdH0pKHBsYXlhYmxlQ2xhc3MucHJvdG90eXBlLnBsYXkpO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0cy5wbGF5YWJsZUNsYXNzZXMgPSB7XHJcblx0X1BsYXlhYmxlLFxyXG5cdF9DaG9pY2UsXHJcblx0X1R1cm4sXHJcblx0X1NlcXVlbmNlLFxyXG5cdF9Db25zZWN1dGl2ZSxcclxuXHRfTG9vcCxcclxuXHRfU0xvb3AsXHJcblx0X0hhbHQsXHJcblx0X1NIYWx0LFxyXG5cdF9MYW1iZGEsXHJcblx0X1JQQ2hvaWNlLFxyXG5cdF9Qb3B1bGF0aW9uRHluYW1pY3MsXHJcblx0X1NpbXVsdGFuZW91c1xyXG59O1xyXG5leHBvcnRzLnBsYXlhYmxlSW50ZXJmYWNlcyA9IHtcclxuXHRDaG9pY2UsXHJcblx0VHVybixcclxuXHRTZXF1ZW5jZSxcclxuXHRDb25zZWN1dGl2ZSxcclxuXHRMb29wLFxyXG5cdFN0b2NoYXN0aWNMb29wLFxyXG5cdEhhbHRJZixcclxuXHRTdG9jaGFzdGljSGFsdCxcclxuXHRMYW1iZGEsXHJcblx0UmFuZG9tUGxheWVyQ2hvaWNlLFxyXG5cdFBvcHVsYXRpb25EeW5hbWljcyxcclxuXHRTaW11bHRhbmVvdXNcclxufTtcclxuXHJcbmZvciAodmFyIHBsYXlhYmxlQ2xhc3MgaW4gZXhwb3J0cy5wbGF5YWJsZUNsYXNzZXMpIHtcclxuXHRpZiAocGxheWFibGVDbGFzcyAhPSBcIl9QbGF5YWJsZVwiKVxyXG5cdFx0aW5pdGlhbGl6ZVBsYXlhYmxlQ2xhc3MoZXhwb3J0cy5wbGF5YWJsZUNsYXNzZXNbcGxheWFibGVDbGFzc10pO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgQ2xhc3M6IExhbWJkYVwiKVxyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5LCBnYW1lSGlzdG9yeSB9ID0gcmVxdWlyZSgnLi4vc3RhdGUnKTtcclxuXHJcbi8vIEluZm9ybWF0aW9uIG1lY2hhbmljc1xyXG52YXIgeyBQZXJmZWN0SW5mb3JtYXRpb24gfSA9IHJlcXVpcmUoXCIuLi9pbmZvcm1hdGlvblwiKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpc0Z1bmN0aW9uIH0gPSByZXF1aXJlKCcuLi9oZWxwZXItZnVuY3Rpb25zJykoXCJnZW5lcmFsXCIpO1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoJy4uL2hlbHBlci1mdW5jdGlvbnMnKShcInN0YXRlXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9ID0gcmVxdWlyZSgnLi9wbGF5YWJsZScpO1xyXG5cclxuXHJcblxyXG4vL0JhY2tlbmQgZnVuY3Rpb24gY2xhc3MgZm9yIEdhbWVcclxuZnVuY3Rpb24gX0xhbWJkYShpZCwgYWN0aW9uLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRfUGxheWFibGUuY2FsbCh0aGlzLCBpZCk7XHJcblxyXG5cdHRoaXMuYWN0aW9uID0gYWN0aW9uO1xyXG5cclxuXHRyZWdpc3RyeS5sYW1iZGFzW2lkXSA9IHRoaXM7XHJcbn1cclxuX0xhbWJkYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9QbGF5YWJsZS5wcm90b3R5cGUpO1xyXG5fTGFtYmRhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9MYW1iZGFcclxuXHJcbl9MYW1iZGEucmVnaXN0cnlOYW1lID0gXCJsYW1iZGFzXCI7XHJcbl9MYW1iZGEuY291bnRlck5hbWUgPSBcImxhbWJkYVwiO1xyXG5cclxuXHJcbl9MYW1iZGEucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7IGluaXRpYWxpemVQbGF5ZXJzID0gZmFsc2UsIHNob3J0Q2lyY3VpdCA9IGZhbHNlLCBoaXN0b3J5ID0gZ2FtZUhpc3RvcnksXHJcblx0aW5mb3JtYXRpb24gPSBQZXJmZWN0SW5mb3JtYXRpb24gfSA9IHt9KSB7XHJcblxyXG5cdHZhciBsYW1iZGEgPSB0aGlzO1xyXG5cclxuXHR2YXIgcmVzdWx0ID0gbGFtYmRhLmFjdGlvbih7IGhpc3RvcnksIGluZm9ybWF0aW9uIH0pXHJcblxyXG5cdHZhciByZXN1bHRPYmplY3QgPSB7XHJcblx0XHRyZXN1bHQsXHJcblx0XHQncGxheWFibGUnOiBsYW1iZGEsXHJcblx0XHRoaXN0b3J5RW50cnk6IHtcclxuXHRcdFx0bGFtYmRhOiBsYW1iZGEuaWQsXHJcblx0XHRcdHJlc3VsdFxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0T2JqZWN0KVxyXG59O1xyXG5cclxuLy8gU2ltcGxlIGhlbHBlciB0byBqdXN0IHJ1biBzeW5jaHJvbm91c2x5IHdoYXRldmVyIHRoZSBMYW1iZGEgaXMuIFVzZWZ1bCBmb3IgZGVidWdnaW5nLlxyXG5fTGFtYmRhLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5hY3Rpb24oKTtcclxufVxyXG5cclxuX0xhbWJkYS5wcm90b3R5cGUuc3VtbWFyeVRoaXMgPSBmdW5jdGlvbihzdW1tYXJ5KSB7XHJcblx0c3VtbWFyeS5hY3Rpb24gPSB0aGlzLmFjdGlvbi50b1N0cmluZygpO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gTGFtYmRhKGFjdGlvbiA9IGZ1bmN0aW9uKCkge30sIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihwYXJhbWV0ZXJzLmlkLCBcImxhbWJkYVwiKVxyXG5cclxuXHRpZiAoIWlzRnVuY3Rpb24oYWN0aW9uKSkgbG9nKFwid2FyblwiLCBpZCArIFwiOiBhY3Rpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24uXCIpXHJcblxyXG5cdC8vQ3JlYXRlIGJhY2tlbmQgbGFtYmRhIG9iamVjdFxyXG5cdHZhciBfbGFtYmRhID0gbmV3IF9MYW1iZGEoaWQsIGFjdGlvbiwgcGFyYW1ldGVycyk7XHJcblxyXG5cclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIGxhbWJkYSA9IFBsYXlhYmxlKF9sYW1iZGEpO1xyXG5cclxuXHJcblx0bGFtYmRhLnJ1biA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIF9sYW1iZGEucnVuKCk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbGFtYmRhO1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IF9MYW1iZGEsIExhbWJkYSB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgQ2xhc3M6IExvb3BcIik7XHJcblxyXG4vL0dhbWUgc3RhdGUgY29udHJvbGxlcnNcclxudmFyIHsgcmVnaXN0cnkgfSA9IHJlcXVpcmUoXCIuLi9zdGF0ZVwiKTtcclxudmFyIHsgZ2FtZUhpc3RvcnksIEhpc3RvcnkgfSA9IHJlcXVpcmUoXCIuLi9oaXN0b3J5XCIpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlkSGFuZGxlciB9ID0gcmVxdWlyZShcIi4uL2hlbHBlci1mdW5jdGlvbnNcIikoXCJzdGF0ZVwiKTtcclxudmFyIHsgY2hhaW5lckdlbmVyYXRvciB9ID0gcmVxdWlyZShcIi4uL2hlbHBlci1mdW5jdGlvbnNcIikoXCJwbGF5YWJsZVwiKTtcclxuXHJcbi8vIEluZm9ybWF0aW9uIG1lY2hhbmljc1xyXG52YXIgeyBJbmZvcm1hdGlvbiwgUGVyZmVjdEluZm9ybWF0aW9uIH0gPSByZXF1aXJlKFwiLi4vaW5mb3JtYXRpb25cIik7XHJcbnZhciB7IGdhbWVQb3B1bGF0aW9uIH0gPSByZXF1aXJlKFwiLi4vcG9wdWxhdGlvblwiKTtcclxuXHJcbi8vUGFyZW50IGNsYXNzXHJcbnZhciB7IF9QbGF5YWJsZSwgUGxheWFibGUgfSA9IHJlcXVpcmUoXCIuL3BsYXlhYmxlXCIpO1xyXG5cclxuLy9CYWNrZW5kIGZ1bmN0aW9uIGNsYXNzIGZvciBMb29wXHJcblxyXG5mdW5jdGlvbiBfTG9vcChpZCwgcGxheWFibGUsIGNvdW50LCBwYXJhbWV0ZXJzKSB7XHJcblx0X1BsYXlhYmxlLmNhbGwodGhpcywgaWQsIHBhcmFtZXRlcnMpO1xyXG5cclxuXHR2YXIgeyBsb2dDb250aW51ZSA9IHRydWUsIHBsYXlhYmxlUGFyYW1ldGVycyA9IHt9IH0gPSBwYXJhbWV0ZXJzO1xyXG5cclxuXHR0aGlzLnBsYXlhYmxlID0gcmVnaXN0cnkucGxheWFibGVzW3BsYXlhYmxlLmlkKCldO1xyXG5cdHRoaXMubG9nQ29udGludWUgPSBsb2dDb250aW51ZTtcclxuXHR0aGlzLnBsYXlhYmxlUGFyYW1ldGVycyA9IHBsYXlhYmxlUGFyYW1ldGVycztcclxuXHJcblx0dGhpcy5jb3VudCA9IGNvdW50O1xyXG5cclxuXHRyZWdpc3RyeS5sb29wc1tpZF0gPSB0aGlzO1xyXG59XHJcbl9Mb29wLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX1BsYXlhYmxlLnByb3RvdHlwZSk7XHJcbl9Mb29wLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9Mb29wO1xyXG5cclxuX0xvb3AucmVnaXN0cnlOYW1lID0gXCJsb29wc1wiO1xyXG5fTG9vcC5jb3VudGVyTmFtZSA9IFwibG9vcFwiO1xyXG5cclxuX0xvb3AucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7XHJcblx0aGlzdG9yeSA9IHRoaXMuaGlzdG9yeSB8fCBnYW1lSGlzdG9yeSxcclxuXHRpbmZvcm1hdGlvbiA9IHRoaXMuaW5mb3JtYXRpb24gfHwgUGVyZmVjdEluZm9ybWF0aW9uLFxyXG5cdHBsYXlhYmxlUGFyYW1ldGVycyA9IHRoaXMucGxheWFibGVQYXJhbWV0ZXJzXHJcbn0gPSB7fSkge1xyXG5cclxuXHR2YXIgbG9vcCA9IHRoaXM7XHJcblx0bG9vcC5jb3VudGVyID0gMDtcclxuXHJcblx0Ly8gU3BsaXQgdGhlIGhpc3RvcnkgZW50cnlcclxuXHR2YXIgbG9vcEhpc3RvcnkgPSBoaXN0b3J5LmNoaWxkKCk7XHJcblxyXG5cdC8vIGluZm9ybWF0aW9uIG1lY2hhbmljcy5cclxuXHQvL2NvbXBhcnRtZW50YWxpemUgSWYgc2V0XHJcblx0aWYgKGxvb3AuY29tcGFydG1lbnRhbGl6ZSkge1xyXG5cdFx0aW5mb3JtYXRpb24gPSBuZXcgSW5mb3JtYXRpb24obG9vcC5jb21wYXJ0bWVudGFsaXplLmhpc3RvcnkgfHwgbG9vcEhpc3RvcnksXHJcblx0XHRcdGxvb3AuY29tcGFydG1lbnRhbGl6ZS5wb3B1bGF0aW9uIHx8IGluZm9ybWF0aW9uLnBvcHVsYXRpb24pO1xyXG5cdH1cclxuXHQvLyBQYXNzIGFsb25nXHJcblx0cGxheWFibGVQYXJhbWV0ZXJzLmluZm9ybWF0aW9uID0gaW5mb3JtYXRpb25cclxuXHJcblxyXG5cdHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcblxyXG5cdHZhciBhY3Rpb24gPSBmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdC8vSWYgdGhlIGdhbWUgaGFzIGJlZW4gZW5kZWQgZWFybHksIGRvbid0IGNvbnRpbnVlLlxyXG5cdFx0aWYgKGhpc3Rvcnkuc3RvcCkgcmV0dXJuIHsgcGxheWFibGU6IGxvb3AgfTtcclxuXHJcblx0XHRsb29wLmNvdW50ZXIrKztcclxuXHRcdGlmICghcmVzdWx0KSByZXN1bHQgPSB7fTtcclxuXHJcblx0XHQvL0RlYWwgd2l0aCBoaXN0b3J5XHJcblx0XHRoaXN0b3J5LmxvZy5hZGQoe1xyXG5cdFx0XHRsb29wOiBsb29wLmlkLFxyXG5cdFx0XHRsb29wVG86IGxvb3AucGxheWFibGUuaWQsXHJcblx0XHRcdGNvdW50OiBsb29wLmNvdW50ZXJcclxuXHRcdH0pO1xyXG5cclxuXHRcdHBsYXlhYmxlUGFyYW1ldGVycy5zaG9ydENpcmN1aXQgPSB0cnVlO1xyXG5cdFx0cGxheWFibGVQYXJhbWV0ZXJzLmhpc3RvcnkgPSBsb29wSGlzdG9yeTtcclxuXHJcblx0XHRyZXR1cm4gbG9vcC5wbGF5YWJsZS5wbGF5KHBsYXlhYmxlUGFyYW1ldGVycykudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0Ly9SZS1mb3JtYXQgcmVzdWx0LCByZXBsYWNlIHBsYXlhYmxlIHdpdGggTG9vcCBwbGF5YWJsZVxyXG5cdFx0XHRyZXN1bHQucGxheWFibGUgPSBsb29wO1xyXG5cclxuXHRcdFx0Ly9UT0RPOiBhZGQgaW5mb3JtYXRpb24gbWVjaGFuaXNtc1xyXG5cclxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0Ly9SZXBlYXQgdGhlIHBsYXlhYmxlIGxvb3AuY291bnQgdGltZXMsIGJ5IGNoYWluaW5nIHByb21pc2VzLlxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbG9vcC5jb3VudDsgaSsrKSB7XHJcblx0XHRwcm9taXNlID0gcHJvbWlzZS50aGVuKGFjdGlvbik7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0cmVzdWx0Lmhpc3RvcnlFbnRyeSA9IHtcclxuXHRcdFx0bG9vcDogbG9vcC5pZCxcclxuXHRcdFx0Y291bnQ6IGxvb3AuY291bnRlcixcclxuXHRcdFx0YWN0aW9uOiBsb29wSGlzdG9yeS5vcnBoYW4oKVxyXG5cdFx0fTtcclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vT3ZlcndyaXRlIGhpc3RvcnkgaGFuZGxlciB0byBwcmV2ZW50IFwibG9vcCBmaW5pc2hlZFwiIGVudHJ5IGZyb20gaGl0dGluZyB0aGUgdHJlZS5cclxuX0xvb3AucHJvdG90eXBlLmhhbmRsZUhpc3RvcnkgPSBmdW5jdGlvbih7XHJcblx0XHRoaXN0b3J5ID0gdGhpcy5oaXN0b3J5IHx8IGdhbWVIaXN0b3J5LFxyXG5cdFx0aW5mb3JtYXRpb24gPSB0aGlzLmluZm9ybWF0aW9uIHx8IFBlcmZlY3RJbmZvcm1hdGlvbixcclxuXHRcdGxvZ0NvbnRpbnVlID0gdGhpcy5sb2dDb250aW51ZVxyXG5cdH0gPSB7fSxcclxuXHRyZXN1bHRcclxuKSB7XHJcblx0dmFyIGxvb3AgPSB0aGlzO1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdC8vV3JpdGUgZmluYWwgZW50cnkgaWYgbG9nQ29udGludWUgaXMgc2V0IHRvIHRydWVcclxuXHRcdGlmIChsb2dDb250aW51ZSkge1xyXG5cdFx0XHRoaXN0b3J5LmxvZy5hZGQoe1xyXG5cdFx0XHRcdGxvb3A6IGxvb3AuaWQsXHJcblx0XHRcdFx0bG9vcFRvOiBcIkxvb3AgZmluaXNoZWQuXCIsXHJcblx0XHRcdFx0Y291bnQ6IGxvb3AuY291bnRlclxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRoaXN0b3J5LmFkZE5vTG9nKHJlc3VsdC5oaXN0b3J5RW50cnkpO1xyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fSk7XHJcbn07XHJcblxyXG4vLyBBZGQgZGV0YWlsL25lc3RpbmcgdG8gc3VtbWFyeS5cclxuX0xvb3AucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSwgZW50cmllcykge1xyXG5cdHN1bW1hcnkuY291bnQgPSB0aGlzLmNvdW50O1xyXG5cclxuXHRzdW1tYXJ5LmFjdGlvbiA9IHt9O1xyXG5cdHRoaXMucGxheWFibGUuc3VtbWFyaXplKHN1bW1hcnkuYWN0aW9uLCBlbnRyaWVzLCB0cnVlKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIExvb3AocGxheWFibGUsIGNvdW50ID0gMSwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHBhcmFtZXRlcnMuaWQsIFwibG9vcFwiKTtcclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBsb29wIG9iamVjdFxyXG5cdHZhciBfbG9vcCA9IG5ldyBfTG9vcChpZCwgcGxheWFibGUsIGNvdW50LCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0Ly9SZXR1cm4gdGhpcyByZWZlcmVuY2Ugb2JqZWN0IHRvIHRoZSB1c2VyLiBSdW4gdGhlIGZ1bmN0aW9uIHRvIHNlbGVjdCBhIHNvdXJjZVxyXG5cdHZhciBsb29wID0gUGxheWFibGUoX2xvb3ApO1xyXG5cdHJldHVybiBsb29wO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX0xvb3AsIExvb3AgfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBQbGF5YWJsZVwiKTtcclxuXHJcbnZhciB7IFN5bmNocm9ub3VzUHJvbWlzZSB9ID0gcmVxdWlyZShcInN5bmNocm9ub3VzLXByb21pc2VcIik7XHJcbnZhciBwcmVzZW50ID0gcmVxdWlyZShcInByZXNlbnRcIik7XHJcblxyXG4vL0dhbWUgc3RhdGUgY29udHJvbGxlcnNcclxudmFyIHsgcmVnaXN0cnksIGlkQ291bnRlcnMgfSA9IHJlcXVpcmUoXCIuLi9zdGF0ZVwiKTtcclxudmFyIHsgZ2FtZUhpc3RvcnksIEhpc3RvcnkgfSA9IHJlcXVpcmUoXCIuLi9oaXN0b3J5XCIpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlzRnVuY3Rpb24gfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXItZnVuY3Rpb25zXCIpKFwiZ2VuZXJhbFwiKTtcclxudmFyIHsgb3V0Y29tZVRyZWVBZGRBbGwsIG91dGNvbWVUcmVlR2V0VmFsdWUgfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXItZnVuY3Rpb25zXCIpKFwicGxheWFibGVcIik7XHJcbnZhciB7IHJlaW5pdGlhbGl6ZVBsYXllcnMgfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXItZnVuY3Rpb25zXCIpKFwicGxheWVyXCIpO1xyXG5cclxuLy9UbyByZXR1cm4gdG8gdXNlclxyXG52YXIgeyBQb3B1bGF0aW9uLCBQbGF5ZXJMaXN0IH0gPSByZXF1aXJlKFwiLi4vcG9wdWxhdGlvblwiKTtcclxuXHJcbi8vX3BsYXlhYmxlIGNsYXNzLCBzdXBlcmNsYXNzIGZvciBvYmplY3RzIHdoaWNoIGNhbiBleGVjdXRlIGdhbWUgc3RlcHMgKGNob2ljZSwgdHVybiwgZ2FtZSlcclxuZnVuY3Rpb24gX1BsYXlhYmxlKGlkLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHR0aGlzLmlkID0gaWQ7XHJcblx0dGhpcy5uZXh0ID0gW107XHJcblx0cmVnaXN0cnkucGxheWFibGVzW2lkXSA9IHRoaXM7XHJcblx0aWRDb3VudGVycy5wbGF5YWJsZSsrO1xyXG5cclxuXHRwYXJhbWV0ZXJzLmNvbXBhcnRtZW50YWxpemUgPyB0aGlzLmNvbXBhcnRtZW50YWxpemUgPSBwYXJhbWV0ZXJzLmNvbXBhcnRtZW50YWxpemUgOiBudWxsO1xyXG5cdHBhcmFtZXRlcnMuaGlzdG9yeSA/ICh0aGlzLmhpc3RvcnkgPSBwYXJhbWV0ZXJzLmhpc3RvcnkpIDogbnVsbDtcclxuXHRwYXJhbWV0ZXJzLmluZm9ybWF0aW9uID8gKHRoaXMuaW5mb3JtYXRpb24gPSBwYXJhbWV0ZXJzLmluZm9ybWF0aW9uKSA6IG51bGw7XHJcblx0cGFyYW1ldGVycy5pbml0aWFsaXplUGxheWVycyA/ICh0aGlzLmluaXRpYWxpemVQbGF5ZXJzID0gcGFyYW1ldGVycy5pbml0aWFsaXplUGxheWVycykgOiBudWxsO1xyXG59XHJcblxyXG5fUGxheWFibGUucmVnaXN0cnlOYW1lID0gXCJwbGF5YWJsZXNcIjtcclxuX1BsYXlhYmxlLmNvdW50ZXJOYW1lID0gXCJwbGF5YWJsZVwiO1xyXG5cclxuLy9BZGQgcmVmZXJlbmNlIHRvIG5leHQgcGxheWFibGUgYnJhbmNoLCB0byBjaGFpbiBwbGF5YWJsZXMgdG9nZXRoZXIuXHJcbl9QbGF5YWJsZS5wcm90b3R5cGUuYWRkTmV4dCA9IGZ1bmN0aW9uKG5leHRQbGF5YWJsZSkge1xyXG5cdG91dGNvbWVUcmVlQWRkQWxsKHRoaXMubmV4dCwgbmV4dFBsYXlhYmxlKTtcclxufTtcclxuXHJcbi8vQ2FsbGVkIGJlZm9yZSAucGxheSgpIHRvIHN0YXJ0IHRpbWluZy5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5fc3RhcnRUaW1lciA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuX3RpbWVyID0gcHJlc2VudCgpO1xyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxufTtcclxuXHJcbi8vQ2FsbGVkIGJlZm9yZSBwcmVQbGF5LCBpbml0aWFsaXplIHBsYXllcnMgaWYgdHJ1ZS5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5jaGVja0luaXQgPSBmdW5jdGlvbih7IGluaXRpYWxpemVQbGF5ZXJzID0gdGhpcy5pbml0aWFsaXplUGxheWVycyB9ID0ge30sIHJlc3VsdCkge1xyXG5cdC8vIGlmIHdlIGdldCBzb21ldGhpbmdcclxuXHRpZiAoaW5pdGlhbGl6ZVBsYXllcnMpIHtcclxuXHRcdC8vIGlmIGl0J3MganVzdCB0cnVlLCB0aGVuIHJlaW5pdGlhbGl6ZSBldmVyeWJvZHlcclxuXHRcdGlmIChpbml0aWFsaXplUGxheWVycyA9PT0gdHJ1ZSkgcmV0dXJuIHJlaW5pdGlhbGl6ZVBsYXllcnMoXCJhbGxcIiwgcmVzdWx0KVxyXG5cclxuXHRcdC8vIGlmIGl0J3MgYSBwbGF5ZXJMaXN0LCB1c2UgdGhhdFxyXG5cdFx0ZWxzZSBpZiAoaW5pdGlhbGl6ZVBsYXllcnMgaW5zdGFuY2VvZiBQbGF5ZXJMaXN0KSByZXR1cm4gcmVpbml0aWFsaXplUGxheWVycyhpbml0aWFsaXplUGxheWVycylcclxuXHJcblx0XHQvLyBpZiB3ZSBnZXQgYSBmdW5jdGlvbiwgdGhlbiBydW4gdGhlIGZ1bmN0aW9uIGFuZCBjaGVjayB0aGF0IGl0J3MgcmV0dXJuaW5nIGEgcGxheWVyTGlzdFxyXG5cdFx0ZWxzZSBpZiAoaXNGdW5jdGlvbihpbml0aWFsaXplUGxheWVycykpIHtcclxuXHRcdFx0dmFyIGxpc3QgPSBpbml0aWFsaXplUGxheWVycygpXHJcblx0XHRcdGlmIChsaXN0IGluc3RhbmNlb2YgUGxheWVyTGlzdCkgcmV0dXJuIHJlaW5pdGlhbGl6ZVBsYXllcnMobGlzdCwgcmVzdWx0KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvdGhlcndpc2UsIGNvbnZlcnQgaXQgdG8gYSBwbGF5ZXJMaXN0IGFuZCBsZXQgUGxheWVyTGlzdCBkZWFsIHdpdGggaXQuXHJcblx0XHRlbHNlIHJldHVybiByZWluaXRpYWxpemVQbGF5ZXJzKG5ldyBQbGF5ZXJMaXN0KGluaXRpYWxpemVQbGF5ZXJzKSwgcmVzdWx0KTtcclxuXHR9XHJcblxyXG5cdC8vIGlmIHdlIGRpZG4ndCBnZXQgYW55dGhpbmcgb3IgZ290IGZhbHNlLCB3ZSdyZSBkb25lIGhlcmUuXHJcblx0ZWxzZSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcbn07XHJcblxyXG5cclxuLy9DYWxsZWQgYmVmb3JlIC5wbGF5KCkgYnV0IGFmdGVyIF9zdGFydFRpbWVyXHJcbl9QbGF5YWJsZS5wcm90b3R5cGUucHJlUGxheSA9IGZ1bmN0aW9uKHt9ID0ge30sIHJlc3VsdCkge1xyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxufTtcclxuXHJcbi8vQ2FsbGVkIGFmdGVyIC5wbGF5KCksIG92ZXJ3cml0YWJsZS5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5wb3N0UGxheSA9IGZ1bmN0aW9uKHt9ID0ge30sIHJlc3VsdCkge1xyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxufTtcclxuXHJcbi8vQ2FsbGVkIGFmdGVyIC5wb3N0UGxheSgpIHRvIHN0b3AgdGltZXIgYW5kIGxvZy5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5fc3RvcFRpbWVyID0gZnVuY3Rpb24oe30gPSB7fSwgcmVzdWx0KSB7XHJcblx0aWYgKHJlc3VsdC5oaXN0b3J5RW50cnkpXHJcblx0XHRyZXN1bHQuaGlzdG9yeUVudHJ5LmR1cmF0aW9uID0gcHJlc2VudCgpIC0gdGhpcy5fdGltZXI7XHJcblx0ZGVsZXRlIHRoaXMuX3RpbWVyO1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcbn07XHJcblxyXG4vL0NhbGxlZCBhZnRlciB0aW1lciBzdG9wcywgdG8gd3JpdGUgbG9nLiBPdmVyd2l0ZWFibGUgaWYgcGxheWFibGUgaGFzIHNwZWNpZmljIGxvZ2dpbmcgYmVoYXZpb3IuXHJcbl9QbGF5YWJsZS5wcm90b3R5cGUuaGFuZGxlSGlzdG9yeSA9IGZ1bmN0aW9uKHsgaGlzdG9yeSA9IGdhbWVIaXN0b3J5IH0gPSB7fSxcclxuXHRyZXN1bHRcclxuKSB7XHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRpZiAocmVzdWx0Lmhpc3RvcnlFbnRyeSkgaGlzdG9yeS5hZGQocmVzdWx0Lmhpc3RvcnlFbnRyeSk7XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcblx0fSk7XHJcbn07XHJcblxyXG4vL0RldGVybWluZSB3aGV0aGVyIHRvIHBsYXkgbmV4dCwgYW5kIGlmIHNvLCBkby5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5wcm9jZWVkID0gZnVuY3Rpb24oeyBzaG9ydENpcmN1aXQgfSA9IHt9LCByZXN1bHQpIHtcclxuXHR2YXIgcGxheWFibGUgPSB0aGlzO1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdC8vUmVwbGFjZSByZXBvcnRlZCBwbGF5YWJsZSB3aXRoIGxhdGVzdCBydW5uaW5nIHBsYXlhYmxlICh0aGlzIGlzIG5lY2Vzc2FyeSBmb3Igc2hvcnQtY2lyY3VpdCBsb2dpYylcclxuXHRcdHJlc3VsdC5wbGF5YWJsZSA9IHBsYXlhYmxlO1xyXG5cclxuXHRcdC8vU2hvcnQtY2lyY3VpdCBsb2dpYyBhbGxvd3MgaGlnaGVyLW9yZGVyIHBsYXlhYmxlIHRvIGZpZ3VyZSBvdXQgd2hhdCB0byBkbyBuZXh0LlxyXG5cdFx0aWYgKHNob3J0Q2lyY3VpdCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cclxuXHRcdHJldHVybiBwbGF5YWJsZS5wbGF5TmV4dChyZXN1bHQpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuLy9QbGF5IG5leHQuXHJcbl9QbGF5YWJsZS5wcm90b3R5cGUucGxheU5leHQgPSBmdW5jdGlvbihyZXN1bHQsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHZhciBwbGF5YWJsZSA9IHRoaXM7XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0Ly9GaW5kIG91dCB3aGVyZSB0byBnbyBuZXh0XHJcblx0XHR2YXIgbmV4dCA9IHBsYXlhYmxlLmZpbmROZXh0KHsgcmVzdWx0IH0pO1xyXG5cclxuXHRcdC8vSWYgdGhlcmUncyBzb21ld2hlcmUgdG8gZ28sIHRoZW4gZ28uXHJcblx0XHRpZiAobmV4dFswXSBpbnN0YW5jZW9mIF9QbGF5YWJsZSlcclxuXHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKFxyXG5cdFx0XHRcdG5leHQubWFwKGZ1bmN0aW9uKHBsYXlhYmxlKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gcGxheWFibGUucGxheShwYXJhbWV0ZXJzKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdC8vT3RoZXJ3aXNlLCB3ZSdyZSBkb25lIGhlcmVcclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vIFJldHVybiB0aGUgbmV4dCBwbGF5YWJsZSBpbiB0aGUgc2VxdWVuY2UuIE92ZXJ3cml0ZWFibGUgZm9yIHBsYXlhYmxlcyB3aXRoIG1vcmUgY29tcGxpY2F0ZWQgYnJhbmNoaW5nLlxyXG5fUGxheWFibGUucHJvdG90eXBlLmZpbmROZXh0ID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMubmV4dDtcclxufTtcclxuXHJcbl9QbGF5YWJsZS5wcm90b3R5cGUuX3N1bW1hcml6ZSA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4vLyBTdW1tYXJpemUgdGhlIGdhbWUgc3RydWN0dXJlLiBDYWxscyBzdW1tYXJ5VGhpcyBhbmQgc3VtbWFyeU5leHQsIHdoaWNoIGFyZSBvdmVyd3JpdGFibGUuXHJcbl9QbGF5YWJsZS5wcm90b3R5cGUuc3VtbWFyaXplID0gZnVuY3Rpb24oXHJcblx0c3VtbWFyeSA9IHt9LFxyXG5cdGVudHJpZXMgPSB7fSxcclxuXHRzaG9ydENpcmN1aXQgPSBmYWxzZSxcclxuXHRtYXhFbnRyaWVzID0gMTBcclxuKSB7XHJcblx0Ly8gU3RhcnQgc3VtbWFyeSBmb3IgdGhpcyBwbGF5YWJsZVxyXG5cdHN1bW1hcnlbdGhpcy5jb25zdHJ1Y3Rvci5jb3VudGVyTmFtZV0gPSB0aGlzLmlkO1xyXG5cclxuXHQvLyBUcmFjayBob3cgbWFueSB0aW1lcyB3ZSd2ZSBiZWVuIGhlcmUgYmVmb3JlLCB0byBhdm9pZCBjaXJjdWxhciByZWN1cnNpb25cclxuXHRlbnRyaWVzW3RoaXMuaWRdID8gKytlbnRyaWVzW3RoaXMuaWRdIDogKGVudHJpZXNbdGhpcy5pZF0gPSAxKTtcclxuXHRpZiAoZW50cmllc1t0aGlzLmlkXSA+IG1heEVudHJpZXMpIHNob3J0Q2lyY3VpdCA9IHRydWU7XHJcblxyXG5cdC8vIEFkZCBzdW1tYXJ5XHJcblx0dGhpcy5zdW1tYXJ5VGhpcyhzdW1tYXJ5LCBlbnRyaWVzKTtcclxuXHJcblx0Ly8gUHJvY2VlZCB0byBuZXh0IHN0ZXBzXHJcblx0aWYgKCFzaG9ydENpcmN1aXQgfHwgc2hvcnRDaXJjdWl0ICE9PSB0aGlzKVxyXG5cdFx0dGhpcy5zdW1tYXJ5TmV4dChzdW1tYXJ5LCBlbnRyaWVzKTtcclxuXHJcblx0cmV0dXJuIHN1bW1hcnk7XHJcbn07XHJcblxyXG4vLyBBZGRzIHRoZSBzdW1tYXJ5IGluZm9ybWF0aW9uIG9uIHRoaXMgcGxheWFibGUuIE92ZXJ3cml0ZSB0aGlzIGluIG9yZGVyIHRvIGFkZCBzcGVjaWZpYyBpbmZvcm1hdGlvbi5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnkgPSB7fSwgZW50cmllcyA9IHt9KSB7XHJcblx0cmV0dXJuIHN1bW1hcnk7XHJcbn07XHJcblxyXG4vLyBBZGRzIHN1bW1hcnkgaW5mb3JtYXRpb24gZG93biB0aGUgbmV4dC1wYXRoLiBPdmVyd2l0ZSB0aGlzIGZvciBwbGF5YWJsZXMgd2l0aCBtb3JlIGNvbXBsZXggYnJhbmNoaW5nLlxyXG5fUGxheWFibGUucHJvdG90eXBlLnN1bW1hcnlOZXh0ID0gZnVuY3Rpb24oc3VtbWFyeSA9IHt9LCBlbnRyaWVzID0ge30pIHtcclxuXHQvLyBJZiB0aGVyZSdzIGEgbmV4dC1lbnRyeVxyXG5cdGlmICh0aGlzLm5leHQubGVuZ3RoID4gMCkge1xyXG5cdFx0Ly8gTG9vcCBvdmVyIGVhY2ggbmV4dC1pdGVtLCBhbmQgc3VtbWFyaXplIGl0LlxyXG5cdFx0c3VtbWFyeS5uZXh0ID0gdGhpcy5uZXh0Lm1hcChmdW5jdGlvbihwbGF5YWJsZSkge1xyXG5cdFx0XHRyZXR1cm4gcGxheWFibGUuc3VtbWFyaXplKHt9LCBlbnRyaWVzKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIElmIHRoZXJlJ3Mgb25seSBvbmUgaXRlbSwgbm8gbmVlZCBmb3IgYW4gYXJyYXkuXHJcblx0XHRpZiAoc3VtbWFyeS5uZXh0Lmxlbmd0aCA9PSAxKSBzdW1tYXJ5Lm5leHQgPSBzdW1tYXJ5Lm5leHRbMF07XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbi8vQ29udm9sdXRlZCBjb2RlIGhlcmUgdG8gcHJvZHVjZSB0aGUgb2JqZWN0IHRoYXQgdXNlciBpbnRlcmFjdHMgd2l0aCAoaWUgYzEgaW4gJ2MxID0gQ2hvaWNlKCknKVxyXG4vL1RoaXMgbWltaWNzIGNyZWF0aW5nIGEgY2xhc3MgdGhhdCBpbmhlcml0cyBmcm9tIEZ1bmN0aW9uLiBGaXJzdCBkZWZpbmUgdGhlIFwicHJvdG90eXBlXCIsIHdoaWNoIGluY2x1ZGVzXHJcbi8vYSBcImNvbnN0cnVjdG9yXCIsIGEgXCJjYWxsXCIgbWV0aG9kIHRoYXQgd2lsbCBnZXQgY2FsbGVkLCBhbmQgYW55IG90aGVyIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXHJcbi8vVGhlbiAnY2xhc3NGYWN0b3J5JyBwcm9kdWNlcyB0aGUgY2xhc3MvY29uc3RydWN0aW5nIG9iamVjdCAoc2VlIGJlbG93KSwgd2hpY2ggeW91IGNhbiB1c2UgdG9cclxuLy9wcm9kdWNlIHRoZSBhY3R1YWwgb2JqZWN0cy5cclxuXHJcbnZhciBwbGF5YWJsZVByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRnVuY3Rpb24ucHJvdG90eXBlKTtcclxuXHJcbnBsYXlhYmxlUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZnVuY3Rpb24oX3BsYXlhYmxlKSB7XHJcblx0dmFyIHBsYXlhYmxlID0gdGhpcztcclxuXHJcblx0Ly9UYWctYmFjay4gU3RvcmUgdGhlIGZyb250LWVuZCBvYmplY3QgaW4gdGhlIGJhY2stZW5kIG9iamVjdCwgZm9yIHJldHJpZXZhbFxyXG5cdF9wbGF5YWJsZS5pbnRlcmZhY2UgPSBwbGF5YWJsZTtcclxuXHJcblx0dGhpcy5jYWxsID0gZnVuY3Rpb24oc291cmNlKSB7XHJcblx0XHR2YXIgcHJldmlvdXNQbGF5YWJsZSwgcGF0aDtcclxuXHJcblx0XHQvL1RPRE86IHZlcmlmeSB0aGF0IHNvdXJjZSBpcyB0aGUgcmlnaHQgdHlwZVxyXG5cclxuXHRcdHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UuYWxsKFtcclxuXHRcdFx0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmIChzb3VyY2UgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHNvdXJjZSBpbnN0YW5jZW9mIFN5bmNocm9ub3VzUHJvbWlzZSkge1xyXG5cdFx0XHRcdFx0c291cmNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdFx0XHRcdHByZXZpb3VzUGxheWFibGUgPSByZWdpc3RyeS5wbGF5YWJsZXNbcmVzdWx0LnBsYXlhYmxlLmlkKCldO1xyXG5cdFx0XHRcdFx0XHRwYXRoID0gcmVzdWx0LnBhdGg7XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKHBhdGgpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoKTtcclxuXHRcdFx0fSkoKSxcclxuXHRcdFx0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFByb21pc2UgfHwgc291cmNlIGluc3RhbmNlb2YgU3luY2hyb25vdXNQcm9taXNlKSkge1xyXG5cdFx0XHRcdFx0cHJldmlvdXNQbGF5YWJsZSA9IHJlZ2lzdHJ5LnBsYXlhYmxlc1tzb3VyY2UuaWQoKV07XHJcblx0XHRcdFx0XHRwYXRoID0gc291cmNlLnBhdGg7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoKTtcclxuXHRcdFx0fSkoKVxyXG5cdFx0XSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0Y29uc29sZS5sb2cocGF0aCk7XHJcblx0XHRcdGxvZyhcclxuXHRcdFx0XHRcImRlYnVnXCIsXHJcblx0XHRcdFx0XCJBZGRpbmcgbmV4dCBwbGF5YWJsZSB0byBcIiArXHJcblx0XHRcdFx0cHJldmlvdXNQbGF5YWJsZS5pZCArXHJcblx0XHRcdFx0XCIsIG5vZGUgXCIgK1xyXG5cdFx0XHRcdF9wbGF5YWJsZS5pZFxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0aWYgKHBhdGggPT0gXCJhbGxcIikgcHJldmlvdXNQbGF5YWJsZS5hZGROZXh0KF9wbGF5YWJsZSk7XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdG91dGNvbWVUcmVlR2V0VmFsdWUocHJldmlvdXNQbGF5YWJsZS5uZXh0LCBwYXRoKS5wdXNoKF9wbGF5YWJsZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxvZyhcInNpbGx5XCIsIHByZXZpb3VzUGxheWFibGUubmV4dCk7XHJcblx0XHRcdC8vcHJldmlvdXNQbGF5YWJsZS5uZXh0W3NlbGVjdGVkXS5wdXNoKF9jaG9pY2UpO1xyXG5cclxuXHRcdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKHtcclxuXHRcdFx0XHRwbGF5YWJsZTogcGxheWFibGUsXHJcblx0XHRcdFx0cGF0aDogXCJhbGxcIlxyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdHRoaXMuaWQgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBfcGxheWFibGUuaWQ7XHJcblx0fTtcclxuXHJcblx0dGhpcy5wbGF5ID0gZnVuY3Rpb24oe1xyXG5cdFx0aW5pdGlhbGl6ZVBsYXllcnMgPSBmYWxzZSxcclxuXHRcdHVzZVBheW9mZnMgPSB0cnVlLFxyXG5cdFx0c2hvcnRDaXJjdWl0ID0gZmFsc2UsXHJcblx0XHR3cml0ZUhpc3RvcnkgPSB0cnVlLFxyXG5cdFx0Y2xlYXJIaXN0b3J5ID0gdHJ1ZSxcclxuXHRcdHJlbGVhc2VQbGF5ZXJzID0gdHJ1ZVxyXG5cdH0gPSB7fSkge1xyXG5cclxuXHRcdGlmIChjbGVhckhpc3RvcnkpIGdhbWVIaXN0b3J5LmNsZWFySGlzdG9yeSgpO1xyXG5cclxuXHRcdHZhciBoaXN0b3J5ID0gd3JpdGVIaXN0b3J5ID9cclxuXHRcdFx0X3BsYXlhYmxlLmhpc3RvcnkgfHwgZ2FtZUhpc3RvcnkgOlxyXG5cdFx0XHRuZXcgSGlzdG9yeSgpO1xyXG5cclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxyXG5cdFx0XHQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0XHRyZXR1cm4gX3BsYXlhYmxlLnBsYXkoeyBpbml0aWFsaXplUGxheWVycywgdXNlUGF5b2Zmcywgc2hvcnRDaXJjdWl0LCBoaXN0b3J5LCByZWxlYXNlUGxheWVycyB9KTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmNhdGNoKGZ1bmN0aW9uKHJlYXNvbikge1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKHJlYXNvbik7XHJcblxyXG5cdFx0XHRcdC8vSWYgdGhlIGdhbWUgd2FzIHN0b3BwZWQgYnkgYSBIYWx0IHBsYXlhYmxlIG9yIGV2ZXJ5Ym9keSdzIGRlYWQsIHdlJ2xsIGVuZCB1cCBoZXJlLCBhbmQgdGhpbmdzIGFyZSBmaW5lLiBKdXN0IGxvZyBpdC5cclxuXHRcdFx0XHRpZiAocmVhc29uLnJlc3VsdCA9PSBcIkhhbHRcIikge1xyXG5cdFx0XHRcdFx0Z2FtZUhpc3RvcnkuYWRkKHJlYXNvbi5oaXN0b3J5RW50cnkpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFzb24ucmVzdWx0KTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHJlYXNvbi5yZXN1bHQgPT0gXCJQb3B1bGF0aW9uIENvbGxhcHNlXCIpXHJcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYXNvbi5yZXN1bHQpO1xyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0aGlzdG9yeS5sb2cuYWRkKHsgZXJyb3I6IHJlYXNvbiB9KTtcclxuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSlcclxuXHRcdFx0LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdFx0Ly9SZXBsYWNlIHJlc3VsdCwgc28gdGhhdCB1c2VyIGNhbid0IGdldCBhY2Nlc3MgdG8gX3BsYXlhYmxlc1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcclxuXHRcdFx0XHRcdFBvcHVsYXRpb246IFBvcHVsYXRpb24oKSxcclxuXHRcdFx0XHRcdGdhbWVIaXN0b3J5XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdHRoaXMuc3VtbWFyaXplID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gX3BsYXlhYmxlLnN1bW1hcml6ZSh7fSk7XHJcblx0fTtcclxufTtcclxuXHJcbnBsYXlhYmxlUHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbigpIHtcclxuXHQvL1RoaXMgd2lsbCBnZXQgb3ZlcndyaXR0ZW4gd2hlbiB0aGUgXCJjb25zdHJ1Y3RvclwiIGlzIGNhbGxlZCwgYnV0IGxlYXZpbmcgaXQgaGVyZSBzbyB5b3UgY2FuIGZpZ3VyZSBvdXQgaG93IHRoZSBoZWxsIHRoaXMgd29ya3MuXHJcbn07XHJcblxyXG5wbGF5YWJsZVByb3RvdHlwZS5wYXRoID0gXCJhbGxcIjtcclxuXHJcbi8vUHJvZHVjZXMgdGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBwcm9kdWNlIHRoZSBlbmQgcmVzdWx0LiBUaGlzIHBhcnQgaXMgcmV1c2FibGUgaWYgeW91IG5lZWQgdG8gZG8gdGhpcyBhZ2Fpbi5cclxudmFyIGNsYXNzRmFjdG9yeSA9IGZ1bmN0aW9uKHByb3RvKSB7XHJcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGYgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIGYuY2FsbC5hcHBseShmLCBhcmd1bWVudHMpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJjb25zdHJ1Y3RvclwiLCB7XHJcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuXHRcdFx0d3JpdGFibGU6IHRydWVcclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwiY2FsbFwiLCB7IHdyaXRhYmxlOiB0cnVlIH0pO1xyXG5cclxuXHRcdE9iamVjdC5rZXlzKHByb3RvKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG5cdFx0XHRmW2tleV0gPSBwcm90b1trZXldO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Zi5jb25zdHJ1Y3Rvci5hcHBseShmLCBhcmd1bWVudHMpO1xyXG5cclxuXHRcdGRlbGV0ZSBmLmNvbnN0cnVjdG9yOyAvL0FkZGVkIHRoaXMgYml0IGhlcmUsIHRvIHByZXZlbnQgdGhlIHVzZXIgZnJvbSB0cnlpbmcgdG8gY3JlYXRlIG5ldyBvYmplY3RzLlxyXG5cclxuXHRcdHJldHVybiBmO1xyXG5cdH07XHJcbn07XHJcblxyXG52YXIgUGxheWFibGUgPSBjbGFzc0ZhY3RvcnkocGxheWFibGVQcm90b3R5cGUpO1xyXG4vLyBjYWxsZWQgYXM6IHZhciBpbnN0YW5jZSA9IFBsYXlhYmxlKC8qIHNvbWUgaW50ZXJuYWwgb2JqZWN0IGxpa2UgX2Nob2ljZSAqLyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxuXHJcbi8vRXh0ZXJuYWwgZGVwZW5kZW5jeVxyXG52YXIgcG9pc3NvbiA9IHJlcXVpcmUoJ3JhbmRnZW4nKS5ycG9pc3NvbjtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIge3JlZ2lzdHJ5LCBnYW1lSGlzdG9yeX0gPSByZXF1aXJlKCcuLi9zdGF0ZScpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7aXNGdW5jdGlvbn1cdD0gcmVxdWlyZSgnLi4vaGVscGVyLWZ1bmN0aW9ucycpKFwiZ2VuZXJhbFwiKTtcclxudmFyIHtpZEhhbmRsZXJ9IFx0PSByZXF1aXJlKCcuLi9oZWxwZXItZnVuY3Rpb25zJykoXCJzdGF0ZVwiKTtcclxuXHJcbi8vUGFyZW50IGNsYXNzXHJcbnZhciB7X1BsYXlhYmxlLCBQbGF5YWJsZX0gPSByZXF1aXJlKCcuL3BsYXlhYmxlJyk7XHJcblxyXG4vL1BsYXllciBjb250cm9sbGVyc1xyXG52YXIge19QbGF5ZXIsIFBsYXllcn0gPSByZXF1aXJlKCcuLi9wbGF5ZXInKTtcclxudmFyIHtQbGF5ZXJMaXN0LCBVc2VyUGxheWVyTGlzdCwgZ2FtZVBvcHVsYXRpb24sIFBvcHVsYXRpb259ID0gcmVxdWlyZSgnLi4vcG9wdWxhdGlvbicpO1xyXG5cclxuLy9VcGRhdGUgdGhpcyBlYWNoIHRpbWUgLnBsYXkgaXMgY2FsbGVkLCBidXQgbGVhdmUgaXQgYXZhaWxhYmxlIHRvIHRoZSB3aG9sZSBzY29wZSBzbyB0aGF0IFxyXG4vL2dyb3d0aCBhbmQgZGVjYXkgY2FuIGFjY2VzcyBpdFxyXG52YXIgcG9wdWxhdGlvbjtcclxuXHJcbi8vRGVmYXVsdCBncm93dGggZnVuY3Rpb25cclxudmFyIGdyb3d0aERlZmF1bHQgPSBmdW5jdGlvbiBncm93dGgocGxheWVyLCBwb3B1bGF0aW9uLCBiaXJ0aFJhdGUsIHNlbGVjdGl2ZU11bHRpcGxpZXIpIHtcclxuXHR2YXIgc2NvcmUgPSBwbGF5ZXIuc2NvcmU7XHJcblx0dmFyIG1lYW4gPSBwb3B1bGF0aW9uLnNjb3Jlc01lYW4oKTtcclxuXHR2YXIgc3RkID0gcG9wdWxhdGlvbi5zY29yZXNTdGQoKTtcclxuXHRcclxuXHR2YXIgWiA9ICEoaXNOYU4oc3RkKSB8fCBzdGQ9PTApID8gKHNjb3JlLW1lYW4pL3N0ZCA6IDBcclxuXHRcclxuXHRjb25zb2xlLmxvZyhzY29yZSwgbWVhbiwgc3RkLFopO1xyXG5cdFxyXG5cdHZhciByYXRlID0gYmlydGhSYXRlICsgc2VsZWN0aXZlTXVsdGlwbGllcipaO1xyXG5cclxuXHR2YXIgZ2VuZXJhdGVkID0gcG9pc3NvbihyYXRlKTtcclxuXHRsb2coXCJzaWxseVwiLFwiZ3Jvd3RoRGVmYXVsdDogZ2VuZXJhdGVkIHJhbmRvbSBudW1iZXIgXCIgKyBnZW5lcmF0ZWQudG9TdHJpbmcoKSsgXCIgdXNpbmcgcmF0ZSBcIisgcmF0ZS50b1N0cmluZygpKTtcclxuXHRcclxuXHRyZXR1cm4gZ2VuZXJhdGVkO1xyXG59XHJcblxyXG4vL0RlZmF1bHQgZGVjYXkgZnVuY3Rpb25cclxudmFyIGRlY2F5RGVmYXVsdCA9IGZ1bmN0aW9uIGRlY2F5KHBsYXllciwgcG9wdWxhdGlvbiwgZGVhdGhSYXRlLCBzZWxlY3RpdmVNdWx0aXBsaWVyKSB7XHJcblx0dmFyIHNjb3JlID0gcGxheWVyLnNjb3JlO1xyXG5cdHZhciBtZWFuID0gcG9wdWxhdGlvbi5zY29yZXNNZWFuKCk7XHJcblx0dmFyIHN0ZCA9IHBvcHVsYXRpb24uc2NvcmVzU3RkKCk7XHJcblx0XHJcblx0Y29uc29sZS5sb2coc2NvcmUsIG1lYW4sIHN0ZCk7XHJcblx0XHJcblx0dmFyIFogPSAgIShpc05hTihzdGQpfHxzdGQ9PTApID8gKHNjb3JlLW1lYW4pL3N0ZCA6IDA7XHJcblx0XHJcblx0Y29uc29sZS5sb2coWilcclxuXHR2YXIgcmF0ZSA9IGRlYXRoUmF0ZSAtIHNlbGVjdGl2ZU11bHRpcGxpZXIqWjtcclxuXHRcclxuXHR2YXIgZ2VuZXJhdGVkID0gcG9pc3NvbihyYXRlKTtcclxuXHRsb2coXCJzaWxseVwiLFwiZGVjYXlEZWZhdWx0OiBnZW5lcmF0ZWQgcmFuZG9tIG51bWJlciBcIiArIGdlbmVyYXRlZC50b1N0cmluZygpKyBcIiB1c2luZyByYXRlIFwiKyByYXRlLnRvU3RyaW5nKCkpO1xyXG5cdHJldHVybiBnZW5lcmF0ZWQ7XHJcbn1cclxuXHJcblxyXG5cclxuLy9CYWNrZW5kIGZ1bmN0aW9uIGNsYXNzIGZvciBQb3B1bGF0aW9uRHluYW1pY3NcclxuZnVuY3Rpb24gX1BvcHVsYXRpb25EeW5hbWljcyhpZCwgYmlydGhSYXRlLGRlYXRoUmF0ZSwge2dyb3d0aEZ1bmN0aW9uPWdyb3d0aERlZmF1bHQsIGRlY2F5RnVuY3Rpb249ZGVjYXlEZWZhdWx0LCBzZWxlY3RpdmVNdWx0aXBsaWVyPSAuNSwgcGxheWVyUGFyYW1ldGVycz17fX09e30pe1xyXG5cdF9QbGF5YWJsZS5jYWxsKHRoaXMsaWQpO1xyXG5cdFxyXG5cdHZhciBwZCA9IHRoaXM7XHJcblx0XHJcblx0dGhpcy5iaXJ0aFJhdGUgPSBiaXJ0aFJhdGU7XHJcblx0dGhpcy5kZWF0aFJhdGUgPSBkZWF0aFJhdGU7XHJcblx0dGhpcy5zZWxlY3RpdmVNdWx0aXBsaWVyID0gc2VsZWN0aXZlTXVsdGlwbGllcjtcclxuXHRcclxuXHQvL1dyYXAgdGhlIGdyb3d0aCBhbmQgZGVjYXkgZnVuY3Rpb25zLCBzbyB0aGF0IHRoZSB1c2VyIGRvZXNuJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCBjYWxsaW5nIHRoaXMuYmlydGhSYXRlIG9yIHRoaXMuZGVhdGhSYXRlXHJcblx0dGhpcy5ncm93dGggPSBmdW5jdGlvbihwbGF5ZXIpe1xyXG5cdFx0bG9nKFwic2lsbHlcIixcIl9wZC5ncm93dGg6IENoZWNraW5nIGdyb3cgY29uZGl0aW9uXCIpO1xyXG5cdFx0cmV0dXJuIGdyb3d0aEZ1bmN0aW9uKHBsYXllciwgcG9wdWxhdGlvbiwgcGQuYmlydGhSYXRlLCBwZC5zZWxlY3RpdmVNdWx0aXBsaWVyKVxyXG5cdH07XHJcblx0dGhpcy5kZWNheSA9IGZ1bmN0aW9uKHBsYXllcil7XHJcblx0XHRsb2coXCJzaWxseVwiLFwiX3BkLmRlY2F5OiBDaGVja2luZyBkZWNheSBjb25kaXRpb25cIik7XHJcblx0XHRyZXR1cm4gZGVjYXlGdW5jdGlvbihwbGF5ZXIsIHBvcHVsYXRpb24sIHBkLmRlYXRoUmF0ZSwgcGQuc2VsZWN0aXZlTXVsdGlwbGllcik7XHJcblx0fTtcclxuXHRcclxuXHR0aGlzLnBsYXllclBhcmFtZXRlcnMgPSBwbGF5ZXJQYXJhbWV0ZXJzO1xyXG5cdFxyXG5cdHJlZ2lzdHJ5LmNvbnRyb2xsZXJzW2lkXSA9IHRoaXM7XHJcbn1cclxuX1BvcHVsYXRpb25EeW5hbWljcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9QbGF5YWJsZS5wcm90b3R5cGUpO1xyXG5fUG9wdWxhdGlvbkR5bmFtaWNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9Qb3B1bGF0aW9uRHluYW1pY3M7XHJcblxyXG5fUG9wdWxhdGlvbkR5bmFtaWNzLnJlZ2lzdHJ5TmFtZSA9IFwiY29udHJvbGxlcnNcIjtcclxuX1BvcHVsYXRpb25EeW5hbWljcy5jb3VudGVyTmFtZSA9IFwicG9wdWxhdGlvbkR5bmFtaWNzXCI7XHJcblxyXG5cclxuX1BvcHVsYXRpb25EeW5hbWljcy5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKHtpbml0aWFsaXplUGxheWVycz1mYWxzZSwgc2hvcnRDaXJjdWl0PWZhbHNlLCBoaXN0b3J5PWdhbWVIaXN0b3J5fT17fSl7XHJcblx0XHJcblx0dmFyIHBkID0gdGhpcztcclxuXHRcclxuXHR2YXIgYmlydGhzID0gMDtcclxuXHR2YXIgZGVhdGhzID0gMDtcclxuXHRcclxuXHQvL1VwZGF0ZSBwb3B1bGF0aW9uIHVzaW5nIHdob2V2ZXIncyBhbGl2ZSBjdXJyZW50bHlcclxuXHRwb3B1bGF0aW9uID0gZ2FtZVBvcHVsYXRpb24oKS5vbmx5QWxpdmUoKTtcclxuXHRcdFxyXG5cdFxyXG5cdC8vS2lsbCBjeWNsZVxyXG5cdHZhciBraWxsZWQgPSBuZXcgUGxheWVyTGlzdChbXSk7XHJcblx0cG9wdWxhdGlvbi5mb3JFYWNoKGZ1bmN0aW9uKHBsYXllcil7XHJcblx0XHQvLyBJZiB0aGUgZGVjYXkgZnVuY3Rpb24gaXMgcmV0dXJucyB0cnV0aHksIGtpbGwuXHJcblx0XHRcclxuXHRcdGlmIChwZC5kZWNheShwbGF5ZXIpKSB7XHJcblx0XHRcdGxvZyhcInNpbGx5XCIsXCJtdXN0IGtpbGwuLi5cIilcclxuXHRcdFx0cGxheWVyLmtpbGwoKTtcclxuXHRcdFx0ZGVhdGhzKys7XHJcblx0XHRcdGtpbGxlZC5wdXNoKHBsYXllcik7XHJcblx0XHRcdGxvZyhcInNpbGx5XCIsXCJkZWFkXCIpO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRcclxuXHR9KTtcclxuXHRcclxuXHQvL1VwZGF0ZSB1cGRhdGUgYWdhaW4gdG8gcHJldmVudCB0aGUgcmVjZW50bHkgZGVjZWFzZWQgZnJvbSByZXByb2R1Y2luZ1xyXG5cdHBvcHVsYXRpb24gPSBnYW1lUG9wdWxhdGlvbigpLm9ubHlBbGl2ZSgpO1xyXG5cdFxyXG5cdGlmIChwb3B1bGF0aW9uLmxlbmd0aCA9PSAwKSB7XHJcblx0XHQvL0V2ZXJ5Ym9keSdzIGRlYWQuIExldCdzIHdyYXAgaXQgdXAuXHJcblx0XHR2YXIgcmVhc29uID0ge3Jlc3VsdDpcIlBvcHVsYXRpb24gQ29sbGFwc2VcIiwgcGxheWFibGU6cGR9O1xyXG5cdFx0aGlzdG9yeS5lbmQoKTtcclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhc29uKTtcclxuXHR9XHJcblx0XHJcblx0Ly9CaXJ0aCBjeWNsZVxyXG5cdHZhciBib3JuID0gbmV3IFVzZXJQbGF5ZXJMaXN0KFtdKTtcclxuXHRwb3B1bGF0aW9uLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKXtcclxuXHRcdC8vQmlydGggd2hhdGV2ZXIgbnVtYmVyIGlzIHJldHVybmVkXHJcblx0XHR2YXIgbnVtQmlydGggPSBwZC5ncm93dGgocGxheWVyKVxyXG5cdFx0Y29uc29sZS5sb2cobnVtQmlydGgpO1xyXG5cdFx0Zm9yICh2YXIgaT0xOyBpPD1udW1CaXJ0aDsgaSsrKXtcclxuXHRcdFx0bG9nKFwic2lsbHlcIiwgXCJQbGF5ZXIgXCIgKyBwbGF5ZXIuaWQgK1wiIGdpdmluZyBiaXJ0aCFcIik7XHJcblx0XHRcdFxyXG5cdFx0XHR2YXIgcGxheWVyUGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30se1xyXG5cdFx0XHRcdFx0YXNzaWduOnBsYXllci5zdHJhdGVneSA/IHBsYXllci5zdHJhdGVneS5faWQgOiBcIlwiLFxyXG5cdFx0XHRcdFx0cGFyZW50OnBsYXllci5pZH1cclxuXHRcdFx0XHQscGQucGxheWVyUGFyYW1ldGVycyk7XHJcblx0XHRcdFxyXG5cdFx0XHRib3JuLnB1c2goUGxheWVyKHBsYXllclBhcmFtZXRlcnMpKTtcclxuXHRcdH1cdFxyXG5cdH0pO1xyXG5cdFxyXG5cdFxyXG5cdHZhciByZXN1bHQgPSB7YmlydGhzLCBkZWF0aHN9O1xyXG5cdFxyXG5cdHZhciByZXN1bHRPYmplY3QgPSB7XHJcblx0XHRyZXN1bHQsXHJcblx0XHQncGxheWFibGUnOnBkLFxyXG5cdFx0aGlzdG9yeUVudHJ5OntcclxuXHRcdFx0cG9wdWxhdGlvbkR5bmFtaWNzOnBkLmlkLFxyXG5cdFx0XHRyZXN1bHRcclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0T2JqZWN0KTtcclxufTtcclxuXHJcblxyXG5cclxuZnVuY3Rpb24gUG9wdWxhdGlvbkR5bmFtaWNzKGJpcnRoUmF0ZT0uMDUsIGRlYXRoUmF0ZSA9IC4wNSwgcGFyYW1ldGVycz17fSl7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHBhcmFtZXRlcnMuaWQsXCJwb3B1bGF0aW9uRHluYW1pY3NcIilcclxuXHRcclxuXHRpZiAocGFyYW1ldGVycy5ncm93dGggJiYgIWlzRnVuY3Rpb24oZ3Jvd3RoKSkgbG9nKFwiZXJyb3JcIixpZCArIFwiOiBncm93dGggc2hvdWxkIGJlIGEgZnVuY3Rpb24uXCIpO1xyXG5cdGlmIChwYXJhbWV0ZXJzLmRlY2F5ICYmICFpc0Z1bmN0aW9uKGRlY2F5KSkgICBsb2coXCJlcnJvclwiLGlkICsgXCI6IGRlY2F5IHNob3VsZCBiZSBhIGZ1bmN0aW9uLlwiKTtcclxuXHRcdFxyXG5cdC8vQ3JlYXRlIGJhY2tlbmQgbGFtYmRhIG9iamVjdFxyXG5cdHZhciBfcGQgPSBuZXcgX1BvcHVsYXRpb25EeW5hbWljcyhpZCwgYmlydGhSYXRlLCBkZWF0aFJhdGUsIHBhcmFtZXRlcnMpO1xyXG5cdFxyXG5cdFxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgcGQgPSBQbGF5YWJsZShfcGQpO1x0XHJcblx0cmV0dXJuIHBkO1x0XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtfUG9wdWxhdGlvbkR5bmFtaWNzLCBQb3B1bGF0aW9uRHluYW1pY3N9OyIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgQ2xhc3M6IFJhbmRvbVBsYXllckNob2ljZVwiKVxyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5LCBnYW1lSGlzdG9yeSwgb2NjdXBpZWRQbGF5ZXJzIH0gPSByZXF1aXJlKCcuLi9zdGF0ZScpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlkSGFuZGxlciB9ID0gcmVxdWlyZSgnLi4vaGVscGVyLWZ1bmN0aW9ucycpKFwic3RhdGVcIik7XHJcbnZhciB7IGNoYWluZXJHZW5lcmF0b3IgfSA9IHJlcXVpcmUoJy4uL2hlbHBlci1mdW5jdGlvbnMnKShcInBsYXlhYmxlXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9ID0gcmVxdWlyZSgnLi9wbGF5YWJsZScpO1xyXG52YXIgeyBfQ2hvaWNlLCBDaG9pY2UgfSA9IHJlcXVpcmUoJy4vY2hvaWNlJyk7XHJcblxyXG4vL1BvcHVsYXRpb24gaGVscGVyc1xyXG52YXIgeyBQbGF5ZXJMaXN0IH0gPSByZXF1aXJlKCcuLi9wb3B1bGF0aW9uJyk7XHJcblxyXG5cclxuLy9CYWNrZW5kIGZ1bmN0aW9uIGNsYXNzIGZvciBSUENob2ljZVxyXG5mdW5jdGlvbiBfUlBDaG9pY2UoaWQsIG9wdGlvbnMsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cclxuXHQvL0lmIHRoZXkgc3BlY2lmeSBwbGF5ZXJzIHRvIGRyYXcgZnJvbSwgdXNlIG9ubHkgdGhhdCBsaXN0LiBPdGhlcndpc2UsIHVzZSB3aG9ldmVyJ3MgYXJvdW5kLlxyXG5cdHRoaXMuaW5jbHVkZVBsYXllcnMgPSBwYXJhbWV0ZXJzLmluY2x1ZGVQbGF5ZXJzIHx8IFwiYWxsXCI7XHJcblxyXG5cdHRoaXMuZXhjbHVkZVBsYXllcnMgPSBwYXJhbWV0ZXJzLmV4Y2x1ZGVQbGF5ZXJzID8gbmV3IFBsYXllckxpc3QocGFyYW1ldGVycy5leGNsdWRlUGxheWVycykgOiBuZXcgUGxheWVyTGlzdCgpXHJcblxyXG5cdHRoaXMuZ2VuZXJhdG9yID0gTWF0aC5yYW5kb207XHJcblxyXG5cdHZhciBwbGF5ZXIgPSBudWxsO1xyXG5cclxuXHJcblx0X0Nob2ljZS5jYWxsKHRoaXMsIGlkLCBwbGF5ZXIsIG9wdGlvbnMsIHBhcmFtZXRlcnMpO1xyXG59XHJcblxyXG5fUlBDaG9pY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfQ2hvaWNlLnByb3RvdHlwZSk7XHJcbl9SUENob2ljZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBfUlBDaG9pY2U7XHJcblxyXG5fUlBDaG9pY2UucmVnaXN0cnlOYW1lID0gXCJjaG9pY2VzXCI7XHJcbl9SUENob2ljZS5jb3VudGVyTmFtZSA9IFwicmFuZG9tUGxheWVyQ2hvaWNlXCI7XHJcblxyXG5cclxuXHJcbi8vU2VsZWN0IHRoZSBwbGF5ZXIgdG8gbWFrZSB0aGUgY2hvaWNlXHJcbl9SUENob2ljZS5wcm90b3R5cGUuY2hvb3NlUGxheWVyID0gZnVuY3Rpb24gY2hvb3NlUGxheWVyKCkge1xyXG5cclxuXHR2YXIgcnBDaG9pY2UgPSB0aGlzO1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcclxuXHJcblx0XHQvL0ZpbmQgcGxheWVycyB0byBjaG9vc2UgZnJvbVxyXG5cdFx0dmFyIHBvb2wgPSBuZXcgUGxheWVyTGlzdChycENob2ljZS5pbmNsdWRlUGxheWVycykub25seUFsaXZlKCkub25seUF2YWlsYWJsZSgpLmV4Y2x1ZGUocnBDaG9pY2UuZXhjbHVkZVBsYXllcnMpXHJcblx0XHRpZiAocG9vbC5sZW5ndGggPT0gMCkgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiTm8gYXZhaWxhYmxlIHBsYXllcnMuXCIpO1xyXG5cclxuXHRcdGxvZyhcInNpbGx5XCIsIFwicnBDaG9pY2UuY2hvb3NlUGxheWVyOiBjaG9vc2luZyBmcm9vbSBwb29sOiBcIiArIHBvb2wuaWRzKCkpO1xyXG5cclxuXHRcdHZhciByYW5kb21OdW1iZXIgPSBNYXRoLmZsb29yKHJwQ2hvaWNlLmdlbmVyYXRvcigpICogcG9vbC5sZW5ndGgpO1xyXG5cdFx0dmFyIGNhbmRpZGF0ZSA9IHBvb2xbcmFuZG9tTnVtYmVyXTtcclxuXHJcblxyXG5cdFx0bG9nKFwic2lsbHlcIiwgXCJycENob2ljZS5jaG9vc2VQbGF5ZXI6IHNlbGVjdGluZyBwbGF5ZXIgXCIsIGNhbmRpZGF0ZS5pZClcclxuXHJcblx0XHRycENob2ljZS5wbGF5ZXIgPSBjYW5kaWRhdGU7XHJcblx0XHRjYW5kaWRhdGUuYXZhaWxhYmxlID0gZmFsc2U7XHJcblxyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShjYW5kaWRhdGUuaWQpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuX1JQQ2hvaWNlLnByb3RvdHlwZS5wcmVQbGF5ID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuY2hvb3NlUGxheWVyKCk7XHJcbn07XHJcblxyXG5cclxuX1JQQ2hvaWNlLnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnkpIHtcclxuXHRzdW1tYXJ5Lm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbn07XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIFJhbmRvbVBsYXllckNob2ljZShvcHRpb25zLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHR2YXIgeyBpZCA9IG51bGwsIGV4Y2x1ZGVQbGF5ZXJzID0gW10sIHBsYXllckxpc3QgPSBudWxsIH0gPSBwYXJhbWV0ZXJzXHJcblxyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihpZCwgXCJyYW5kb21QbGF5ZXJDaG9pY2VcIilcclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBjaG9pY2Ugb2JqZWN0XHJcblx0dmFyIF9ycENob2ljZSA9IG5ldyBfUlBDaG9pY2UoaWQsIG9wdGlvbnMsIHBhcmFtZXRlcnMpO1xyXG5cclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIHJwQ2hvaWNlID0gUGxheWFibGUoX3JwQ2hvaWNlKVxyXG5cclxuXHRycENob2ljZS5wbGF5ZXJMaXN0ID0gZnVuY3Rpb24ocGxheWVyTGlzdCkge1xyXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkocGxheWVyTGlzdCkpIF9ycENob2ljZS5wbGF5ZXJMaXN0ID0gcGxheWVyTGlzdDtcclxuXHRcdHJldHVybiBfcnBDaG9pY2UucGxheWVyTGlzdFxyXG5cdH07XHJcblxyXG5cdHJwQ2hvaWNlLmV4Y2x1ZGVQbGF5ZXJzID0gZnVuY3Rpb24oZXhjbHVkZVBsYXllcnMpIHtcclxuXHRcdGlmIChBcnJheS5pc0FycmF5KGV4Y2x1ZGVQbGF5ZXJzKSkge1xyXG5cdFx0XHRfcnBDaG9pY2UuZXhjbHVkZVBsYXllcnMgPSBbXTtcclxuXHJcblx0XHRcdGV4Y2x1ZGVQbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0X3JwQ2hvaWNlLmV4Y2x1ZGVQbGF5ZXJzLnB1c2gocGxheWVyLmlkKCkpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gX3JwQ2hvaWNlLmV4Y2x1ZGVQbGF5ZXJzXHJcblx0fTtcclxuXHJcblx0Ly9JbnRlcmZhY2UgdG8gc3BlY2lmeSBzaW5nbGUtcGxheWVyIHBheW9mZnMgaW4gc2luZ2xlLXBsYXllci9zaW5nbGUtY2hvaWNlIGdhbWVzXHJcblx0X3JwQ2hvaWNlLnplcm9QYXlvZmZzKCk7XHJcblxyXG5cdF9ycENob2ljZS5nZW5lcmF0ZUNoYWluaW5nRnVuY3Rpb25zKHJwQ2hvaWNlKTtcclxuXHJcblx0Ly9GdW5jdGlvbiB0byBzZXQgYWxsIHBheW9mZnMgYXQgb25jZVxyXG5cdHJwQ2hvaWNlLnNldEFsbFBheW9mZnMgPSBmdW5jdGlvbihwYXlvZmZzKSB7XHJcblx0XHQvL1RPRE86IG1ha2UgdGhpcyB3b3JrLiBJbmNsdWRlIGVycm9yIGhhbmRsaW5nIGlmIGFycmF5IGdpdmVuIGlzbid0IGV4cGVjdGVkIGRpbWVuc2lvbnMuXHJcblx0fTtcclxuXHJcblxyXG5cdC8vV2F5IGZvciB1c2VyIHRvIGludGVyYWN0IHdpdGggcGF5b2Zmc1xyXG5cdHJwQ2hvaWNlLnBheW9mZnMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHJlZ2lzdHJ5LmNob2ljZXNbaWRdLnBheW9mZnM7IH07XHJcblxyXG5cdHJldHVybiBycENob2ljZTtcclxufVxyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX1JQQ2hvaWNlLCBSYW5kb21QbGF5ZXJDaG9pY2UgfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBTZXF1ZW5jZVwiKTtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZShcIi4uL3N0YXRlXCIpO1xyXG52YXIgeyBnYW1lSGlzdG9yeSB9ID0gcmVxdWlyZShcIi4uL2hpc3RvcnlcIik7XHJcblxyXG4vL0hlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgaWRIYW5kbGVyIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyLWZ1bmN0aW9uc1wiKShcInN0YXRlXCIpO1xyXG5cclxuLy9JbmZvcm1hdGlvblxyXG52YXIgeyBJbmZvcm1hdGlvbiwgUGVyZmVjdEluZm9ybWF0aW9uIH0gPSByZXF1aXJlKFwiLi4vaW5mb3JtYXRpb25cIik7XHJcblxyXG4vL1BhcmVudCBjbGFzc1xyXG52YXIgeyBfUGxheWFibGUsIFBsYXlhYmxlIH0gPSByZXF1aXJlKFwiLi9wbGF5YWJsZVwiKTtcclxuXHJcbi8vQmFja2VuZCBmdW5jdGlvbiBjbGFzcyBmb3IgU2VxdWVuY2VcclxuZnVuY3Rpb24gX1NlcXVlbmNlKGlkLCBwbGF5YWJsZVN0YXJ0LCBwbGF5YWJsZUZpbmlzaCwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0X1BsYXlhYmxlLmNhbGwodGhpcywgaWQsIHBhcmFtZXRlcnMpO1xyXG5cclxuXHR0aGlzLnBsYXlhYmxlU3RhcnQgPSByZWdpc3RyeS5wbGF5YWJsZXNbcGxheWFibGVTdGFydC5pZCgpXTtcclxuXHR0aGlzLnBsYXlhYmxlRmluaXNoID0gcmVnaXN0cnkucGxheWFibGVzW3BsYXlhYmxlRmluaXNoLmlkKCldO1xyXG5cclxuXHRyZWdpc3RyeS5zZXF1ZW5jZXNbaWRdID0gdGhpcztcclxufVxyXG5fU2VxdWVuY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfUGxheWFibGUucHJvdG90eXBlKTtcclxuX1NlcXVlbmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9TZXF1ZW5jZTtcclxuXHJcbl9TZXF1ZW5jZS5yZWdpc3RyeU5hbWUgPSBcInNlcXVlbmNlc1wiO1xyXG5fU2VxdWVuY2UuY291bnRlck5hbWUgPSBcInNlcXVlbmNlXCI7XHJcblxyXG5fU2VxdWVuY2UucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7XHJcblx0aGlzdG9yeSA9IGdhbWVIaXN0b3J5LFxyXG5cdGluZm9ybWF0aW9uID0gdGhpcy5pbmZvcm1hdGlvbiB8fFxyXG5cdFBlcmZlY3RJbmZvcm1hdGlvblxyXG59ID0ge30pIHtcclxuXHJcblx0dmFyIHNlcXVlbmNlID0gdGhpcztcclxuXHJcblx0Ly9Mb2cgdGhlIGhpc3RvcnkgYXBwcm9wcmlhdGVseVxyXG5cdHZhciBzdGFydEVudHJ5ID0ge1xyXG5cdFx0c2VxdWVuY2U6IHNlcXVlbmNlLmlkLFxyXG5cdFx0YWN0aW9uOiBcInN0YXJ0XCJcclxuXHR9O1xyXG5cdGhpc3RvcnkubG9nLmFkZChzdGFydEVudHJ5KTtcclxuXHJcblx0Ly9IaXN0b3J5IG9iamVjdCB0byBnaXZlIHRvIHNlcXVlbmNlZCBwbGF5YWJsZXMuXHJcblx0dmFyIHNlcXVlbmNlSGlzdG9yeSA9IGhpc3RvcnkuY2hpbGQoKTtcclxuXHJcblx0Ly9jb21wYXJ0bWVudGFsaXplIGlmIHNldC4gXCJjb21wYXJ0bWVudGFsaXplXCIgbWVhbnMgcGFzcyBvbiBpbmZvcm1hdGlvbiBhcyBpZiB0aGlzIHBsYXlhYmxlIGlzIHRoZSBlbnRpcmUgZ2FtZS5cclxuXHRpZiAoc2VxdWVuY2UuY29tcGFydG1lbnRhbGl6ZSkge1xyXG5cdFx0aW5mb3JtYXRpb24gPSBuZXcgSW5mb3JtYXRpb24oc2VxdWVuY2UuY29tcGFydG1lbnRhbGl6ZS5oaXN0b3J5IHx8IHNlcXVlbmNlSGlzdG9yeSxcclxuXHRcdFx0c2VxdWVuY2UuY29tcGFydG1lbnRhbGl6ZS5wb3B1bGF0aW9uIHx8IGluZm9ybWF0aW9uLnBvcHVsYXRpb24pO1xyXG5cdH1cclxuXHJcblx0Ly8gUmVjdXJzaW9uIGRvd24gdGhlIGNoYWluIG9mIHBsYXlhYmxlc1xyXG5cdHZhciBhY3Rpb24gPSBmdW5jdGlvbiBhY3Rpb24ocmVzdWx0KSB7XHJcblx0XHQvL1N0b3AgaWYgdGhlIGdhbWUgaXMgb3Zlci5cclxuXHRcdGlmIChoaXN0b3J5LnN0b3ApIHJldHVybiB7IHBsYXlhYmxlOiBzZXF1ZW5jZSB9O1xyXG5cclxuXHRcdC8vT3RoZXJ3aXNlLCByZWN1cnNlIHRvIGZpZ3VyZSBvdXQgd2hhdCB0byBkbyBuZXh0LlxyXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xyXG5cdFx0XHRsb2coXCJzaWxseVwiLCBcInNlcXVlbmNlLnBsYXk6IE5leHQtaXRlbSBpcyBhbiBhcnJheSwgc3BsaXR0aW5nIGludG8gcGllY2VzLlwiKTtcclxuXHJcblx0XHRcdHJldHVybiBQcm9taXNlLmFsbChcclxuXHRcdFx0XHRyZXN1bHQubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdFx0XHRcdGxvZyhcInNpbGx5XCIsIFwic2VxdWVuY2UucGxheTogcmVjdXJzaW5nIG9uXCIsIGl0ZW0pO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGFjdGlvbihpdGVtKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChyZXN1bHQucGxheWFibGUgIT09IHNlcXVlbmNlLnBsYXlhYmxlRmluaXNoKSB7XHJcblx0XHRcdGxvZyhcInNpbGx5XCIsIHJlc3VsdCk7XHJcblxyXG5cdFx0XHRpZiAocmVzdWx0LnBsYXlhYmxlLmZpbmROZXh0KHsgcmVzdWx0IH0pLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRsb2coXCJzaWxseVwiLCBcIlBsYXlhYmxlIGhhcyBuZXh0LWl0ZW0sIGNvbnRpbnVpbmcgZG93biBjaGFpbi5cIik7XHJcblxyXG5cdFx0XHRcdHJldHVybiByZXN1bHQucGxheWFibGUucGxheU5leHQocmVzdWx0LCB7IHNob3J0Q2lyY3VpdDogdHJ1ZSwgaGlzdG9yeTogc2VxdWVuY2VIaXN0b3J5LCBpbmZvcm1hdGlvbiB9KVxyXG5cdFx0XHRcdFx0LnRoZW4oYWN0aW9uKTsgLy9SZXBlYXQgZm9yIG5leHQgcGxheWFibGUgaW4gY2hhaW5cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIHNlcXVlbmNlLnBsYXlhYmxlU3RhcnRcclxuXHRcdC5wbGF5KHsgc2hvcnRDaXJjdWl0OiB0cnVlLCBoaXN0b3J5OiBzZXF1ZW5jZUhpc3RvcnksIGluZm9ybWF0aW9uIH0pXHJcblx0XHQudGhlbihhY3Rpb24pXHJcblx0XHQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0cmVzdWx0Lmhpc3RvcnlFbnRyeSA9IHtcclxuXHRcdFx0XHRzZXF1ZW5jZTogc2VxdWVuY2UuaWQsXHJcblx0XHRcdFx0YWN0aW9uOiBzZXF1ZW5jZUhpc3Rvcnkub3JwaGFuKClcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdC8vVE9ETzogYWRkIGluZm9ybWF0aW9uIG1lY2hhbmlzbXNcclxuXHJcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHRcdH0pO1xyXG59O1xyXG5cclxuLy9PdmVyd3JpdGUgaGlzdG9yeSBoYW5kbGVyIHNvIHRoYXQgdHJlZSBkb2Vzbid0IGhhdmUgXCJzdGFydFwiIGFuZCBcImZpbmlzaFwiIGVudHJpZXMuXHJcbl9TZXF1ZW5jZS5wcm90b3R5cGUuaGFuZGxlSGlzdG9yeSA9IGZ1bmN0aW9uKHsgaGlzdG9yeSA9IGdhbWVIaXN0b3J5IH0gPSB7fSxcclxuXHRyZXN1bHRcclxuKSB7XHJcblx0dmFyIHNlcXVlbmNlID0gdGhpcztcclxuXHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRoaXN0b3J5LmxvZy5hZGQoe1xyXG5cdFx0XHRzZXF1ZW5jZTogc2VxdWVuY2UuaWQsXHJcblx0XHRcdGFjdGlvbjogXCJmaW5pc2hcIixcclxuXHRcdFx0ZHVyYXRpb246IHJlc3VsdC5oaXN0b3J5RW50cnkuZHVyYXRpb25cclxuXHRcdH0pO1xyXG5cclxuXHRcdGhpc3RvcnkuYWRkTm9Mb2cocmVzdWx0Lmhpc3RvcnlFbnRyeSk7XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcblx0fSk7XHJcbn07XHJcblxyXG4vL1RPRE86IGZpbmlzaCB0aGlzIVxyXG5fU2VxdWVuY2UucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSwgZW50cmllcywgc2hvcnRDaXJjdWl0KSB7XHJcblx0c3VtbWFyeS5hY3Rpb24gPSB7fTtcclxuXHJcblx0dGhpcy5wbGF5YWJsZVN0YXJ0LnN1bW1hcml6ZShcclxuXHRcdHN1bW1hcnkuYWN0aW9uLFxyXG5cdFx0ZW50cmllcyxcclxuXHRcdChzaG9ydENpcmN1aXQgPSB0aGlzLnBsYXlhYmxlRmluaXNoKVxyXG5cdCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBTZXF1ZW5jZShwbGF5YWJsZVN0YXJ0LCBwbGF5YWJsZUZpbmlzaCwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHBhcmFtZXRlcnMuaWQsIFwic2VxdWVuY2VcIik7XHJcblxyXG5cdC8vQ3JlYXRlIGJhY2tlbmQgbG9vcCBvYmplY3RcclxuXHR2YXIgX3NlcXVlbmNlID0gbmV3IF9TZXF1ZW5jZShpZCwgcGxheWFibGVTdGFydCwgcGxheWFibGVGaW5pc2gsIHBhcmFtZXRlcnMpO1xyXG5cclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIHNlcXVlbmNlID0gUGxheWFibGUoX3NlcXVlbmNlKTtcclxuXHRyZXR1cm4gc2VxdWVuY2U7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBfU2VxdWVuY2UsIFNlcXVlbmNlIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlzT2JqZWN0IH0gPSByZXF1aXJlKCcuLi9oZWxwZXItZnVuY3Rpb25zJykoXCJnZW5lcmFsXCIpO1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoJy4uL2hlbHBlci1mdW5jdGlvbnMnKShcInN0YXRlXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9ID0gcmVxdWlyZSgnLi9wbGF5YWJsZScpO1xyXG5cclxuLy8gSW5mb3JtYXRpb24gbWVjaGFuaWNzXHJcbnZhciB7IEluZm9ybWF0aW9uLCBQZXJmZWN0SW5mb3JtYXRpb24gfSA9IHJlcXVpcmUoJy4uL2luZm9ybWF0aW9uJyk7XHJcblxyXG5cclxuLy9CYWNrZW5kIGNsYXNzXHJcbmZ1bmN0aW9uIF9TaW11bHRhbmVvdXMoaWQsIHBsYXlhYmxlQXJyYXksIHsgcGxheWFibGVQYXJhbWV0ZXJzID0ge30gfSA9IHt9KSB7XHJcblx0X1BsYXlhYmxlLmNhbGwodGhpcywgaWQpO1xyXG5cclxuXHR0aGlzLnBsYXlhYmxlQXJyYXkgPSBwbGF5YWJsZUFycmF5O1xyXG5cdHRoaXMucGxheWFibGVQYXJhbWV0ZXJzID0gcGxheWFibGVQYXJhbWV0ZXJzO1xyXG5cclxuXHRyZWdpc3RyeS5jb250cm9sbGVyc1tpZF0gPSB0aGlzO1xyXG59XHJcblxyXG5fU2ltdWx0YW5lb3VzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX1BsYXlhYmxlLnByb3RvdHlwZSk7XHJcbl9TaW11bHRhbmVvdXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gX1NpbXVsdGFuZW91cztcclxuXHJcbl9TaW11bHRhbmVvdXMucmVnaXN0cnlOYW1lID0gXCJjb250cm9sbGVyc1wiO1xyXG5fU2ltdWx0YW5lb3VzLmNvdW50ZXJOYW1lID0gXCJzaW11bHRhbmVvdXNcIjtcclxuXHJcblxyXG4vL1NpbXVsdGFuZW91cyBQcm9taXNlLmFsbCdzIHRoZSBwbGF5YWJsZXMsIHdoaWNoIGNhdXNlcyB0aGVtIHRvIHJ1biBtZXNoZWQuXHJcbl9TaW11bHRhbmVvdXMucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7IGhpc3RvcnkgPSBnYW1lSGlzdG9yeSwgaW5mb3JtYXRpb24gPSBQZXJmZWN0SW5mb3JtYXRpb24gfSA9IHt9KSB7XHJcblxyXG5cdHZhciBzaW11bHRhbmVvdXMgPSB0aGlzO1xyXG5cclxuXHQvLyBEZWFsIHdpdGggaGlzdG9yeS4gTG9nIHN0YXJ0LCB0aGVuIHNwbGl0IGhpc3RvcnkgZm9yIGNoaWxkcmVuIHBsYXlhYmxlcyB0byBmaWxsIGluLlxyXG5cdGhpc3RvcnkubG9nLmFkZCh7XHJcblx0XHRzaW11bHRhbmVvdXM6IHNpbXVsdGFuZW91cy5pZCxcclxuXHRcdGFjdGlvbjogXCJTaW11bHRhbmVvdXMgc3RhcnQuXCJcclxuXHR9KTtcclxuXHR2YXIgc2ltdWx0YW5lb3VzSGlzdG9yeSA9IFtdXHJcblxyXG5cclxuXHJcblx0Ly9UT0RPOiBpcyBpbmZvcm1hdGlvbiBtZWNoYW5pY3MgY29ycmVjdD9cclxuXHJcblx0cmV0dXJuIFByb21pc2UuYWxsKHNpbXVsdGFuZW91cy5wbGF5YWJsZUFycmF5Lm1hcChmdW5jdGlvbihwbGF5YWJsZSkge1xyXG5cclxuXHRcdHZhciBicmFuY2hIaXN0b3J5ID0gaGlzdG9yeS5jaGlsZCgpO1xyXG5cdFx0c2ltdWx0YW5lb3VzSGlzdG9yeS5wdXNoKGJyYW5jaEhpc3RvcnkpXHJcblxyXG5cdFx0Ly8gSW5mb3JtYXRpb24gbWVjaGFuaWNzXHJcblx0XHR2YXIgaW5mb1BvcHVsYXRpb24sIHBhcmVudEhpc3RvcnksIGluZm9IaXN0b3J5ID0gYnJhbmNoSGlzdG9yeTtcclxuXHRcdC8vY29tcGFydG1lbnRhbGl6ZSBpZiBzZXQuIFwiY29tcGFydG1lbnRhbGl6ZVwiIG1lYW5zIHBhc3Mgb24gaW5mb3JtYXRpb24gYXMgaWYgdGhpcyBwbGF5YWJsZSBpcyB0aGUgZW50aXJlIGdhbWUuXHJcblx0XHRpZiAoc2ltdWx0YW5lb3VzLmNvbXBhcnRtZW50YWxpemUpIHtcclxuXHRcdFx0aW5mb1BvcHVsYXRpb24gPSBzaW11bHRhbmVvdXMuY29tcGFydG1lbnRhbGl6ZS5wb3B1bGF0aW9uIHx8IGluZm9ybWF0aW9uLnBvcHVsYXRpb247XHJcblx0XHRcdHBhcmVudEhpc3RvcnkgPSBzaW11bHRhbmVvdXMuY29tcGFydG1lbnRhbGl6ZS5oaXN0b3J5IHx8IGluZm9ybWF0aW9uLmhpc3Rvcnk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpbmZvUG9wdWxhdGlvbiA9IGluZm9ybWF0aW9uLnBvcHVsYXRpb247XHJcblx0XHRcdHBhcmVudEhpc3RvcnkgPSBpbmZvcm1hdGlvbi5oaXN0b3J5XHJcblx0XHR9XHJcblx0XHR2YXIgc2ltdWx0YW5lb3VzSW5mb3JtYXRpb24gPSBuZXcgSW5mb3JtYXRpb24oaW5mb0hpc3RvcnksIGluZm9Qb3B1bGF0aW9uLCB7IHBhcmVudEhpc3RvcnkgfSk7XHJcblxyXG5cclxuXHJcblx0XHRyZXR1cm4gcGxheWFibGUucGxheSh7IGhpc3Rvcnk6IGJyYW5jaEhpc3RvcnksIGluZm9ybWF0aW9uOiBzaW11bHRhbmVvdXNJbmZvcm1hdGlvbiB9KTtcclxuXHR9KSkudGhlbihmdW5jdGlvbihyZXN1bHRBcnJheSkge1xyXG5cclxuXHRcdHZhciByZXN1bHRPYmplY3QgPSB7XHJcblx0XHRcdHJlc3VsdEFycmF5LFxyXG5cdFx0XHRwbGF5YWJsZTogc2ltdWx0YW5lb3VzLFxyXG5cdFx0XHRoaXN0b3J5RW50cnk6IHtcclxuXHRcdFx0XHRzaW11bHRhbmVvdXM6IHNpbXVsdGFuZW91cy5pZCxcclxuXHRcdFx0XHRhY3Rpb246IHNpbXVsdGFuZW91c0hpc3RvcnkubWFwKGZ1bmN0aW9uKGhpc3RvcnkpIHtcclxuXHRcdFx0XHRcdHJldHVybiBoaXN0b3J5Lm9ycGhhbigpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0XHRyZXR1cm4gcmVzdWx0T2JqZWN0O1xyXG5cdH0pO1xyXG59O1xyXG5cclxuXHJcbl9TaW11bHRhbmVvdXMucHJvdG90eXBlLmhhbmRsZUhpc3RvcnkgPSBmdW5jdGlvbih7IGhpc3RvcnkgPSBnYW1lSGlzdG9yeSB9ID0ge30sIHJlc3VsdCkge1xyXG5cclxuXHRoaXN0b3J5LmxvZy5hZGQoe1xyXG5cdFx0c2ltdWx0YW5lb3VzOiB0aGlzLmlkLFxyXG5cdFx0YWN0aW9uOiBcIlNpbXVsdGFuZW91cyBjb21wbGV0ZS5cIlxyXG5cdH0pO1xyXG5cclxuXHRoaXN0b3J5LmFkZE5vTG9nKHJlc3VsdC5oaXN0b3J5RW50cnkpO1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcbn07XHJcblxyXG5fU2ltdWx0YW5lb3VzLnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnksIGVudHJpZXMpIHtcclxuXHRzdW1tYXJ5LmFjdGlvbiA9IFtdO1xyXG5cclxuXHR0aGlzLnBsYXlhYmxlQXJyYXkuZm9yRWFjaChmdW5jdGlvbihwbGF5YWJsZSwgaW5kZXgpIHtcclxuXHRcdHN1bW1hcnkuYWN0aW9uW2luZGV4XSA9IHt9XHJcblx0XHRwbGF5YWJsZS5zdW1tYXJpemUoc3VtbWFyeS5hY3Rpb25baW5kZXhdLCBlbnRyaWVzKTtcclxuXHR9KTtcclxufVxyXG5cclxuXHJcbi8vRnJvbnRlbmQgY2xhc3NcclxuZnVuY3Rpb24gU2ltdWx0YW5lb3VzKHBsYXlhYmxlQXJyYXksIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihwYXJhbWV0ZXJzLmlkLCBcInNpbXVsdGFuZW91c1wiKVxyXG5cclxuXHRwbGF5YWJsZUFycmF5ID0gcGxheWFibGVBcnJheS5tYXAoZnVuY3Rpb24ocGxheWFibGUpIHtcclxuXHRcdHJldHVybiByZWdpc3RyeS5wbGF5YWJsZXNbcGxheWFibGUuaWQoKV07XHJcblx0fSk7XHJcblxyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIGluc3RhbmNlLlxyXG5cdHZhciBfc2ltdWx0YW5lb3VzID0gbmV3IF9TaW11bHRhbmVvdXMoaWQsIHBsYXlhYmxlQXJyYXksIHBhcmFtZXRlcnMpO1xyXG5cclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIHNpbXVsdGFuZW91cyA9IFBsYXlhYmxlKF9zaW11bHRhbmVvdXMpO1xyXG5cdHJldHVybiBzaW11bHRhbmVvdXM7XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX1NpbXVsdGFuZW91cywgU2ltdWx0YW5lb3VzIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgQ2xhc3M6IFN0b2NoYXN0aWMtSGFsdFwiKVxyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7cmVnaXN0cnksIGdhbWVIaXN0b3J5fSA9IHJlcXVpcmUoJy4uL3N0YXRlJyk7XHJcblxyXG4vL0hlbHBlciBmdW5jdGlvbnNcclxudmFyIHtpc0Z1bmN0aW9ufVx0PSByZXF1aXJlKCcuLi9oZWxwZXItZnVuY3Rpb25zJykoXCJnZW5lcmFsXCIpO1xyXG52YXIge2lkSGFuZGxlcn0gXHQ9IHJlcXVpcmUoJy4uL2hlbHBlci1mdW5jdGlvbnMnKShcInN0YXRlXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHtfUGxheWFibGUsIFBsYXlhYmxlfSBcdD0gcmVxdWlyZSgnLi9wbGF5YWJsZScpO1xyXG52YXIge19IYWx0LCBIYWx0fVx0XHRcdD0gcmVxdWlyZSgnLi9oYWx0LWlmJyk7XHJcblxyXG5cclxuLy9CYWNrZW5kIGZ1bmN0aW9uIGNsYXNzIGZvciBTSGFsdFxyXG5mdW5jdGlvbiBfU0hhbHQoaWQsIHByb2JhYmlsaXR5LCBwYXJhbWV0ZXJzKXtcclxuXHRfSGFsdC5jYWxsKHRoaXMsaWQsbnVsbCxwYXJhbWV0ZXJzKTtcclxuXHRcclxuXHR2YXIgc0hhbHQgPSB0aGlzO1xyXG5cdFxyXG5cdHRoaXMucHJvYmFiaWxpdHkgPSBwcm9iYWJpbGl0eTtcclxuXHR0aGlzLmdlbmVyYXRvciA9IE1hdGgucmFuZG9tO1x0XHRcdFx0Ly9UT0RPOiBhbGxvdyB1c2VyIHRvIHNwZWNpZnkgcmFuZG9tIG51bWJlciBnZW5lcmF0b3JcclxuXHRcclxuXHR0aGlzLnRlc3RDb25kaXRpb24gPSBmdW5jdGlvbigpe1xyXG5cdFx0aWYgKHNIYWx0LmdlbmVyYXRvcigpIDwgc0hhbHQucHJvYmFiaWxpdHkpIHJldHVybiB0cnVlO1xyXG5cdH07XHJcblx0XHJcblx0XHJcblx0cmVnaXN0cnkuc0hhbHRzW2lkXSA9IHRoaXM7XHJcbn1cclxuX1NIYWx0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX0hhbHQucHJvdG90eXBlKTtcclxuX1NIYWx0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9TSGFsdDtcclxuXHJcbl9TSGFsdC5yZWdpc3RyeU5hbWUgPSBcInNIYWx0c1wiO1xyXG5fU0hhbHQuY291bnRlck5hbWUgPSBcInN0b2NoYXN0aWNIYWx0XCI7XHJcblxyXG4vKlxyXG5fU0hhbHQucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7aW5pdGlhbGl6ZVBsYXllcnM9ZmFsc2UsIHNob3J0Q2lyY3VpdD1mYWxzZX09e30pe1xyXG5cdFxyXG5cdHZhciBzSGFsdCA9IHRoaXM7XHJcblx0dmFyIHRlc3QgPSBzSGFsdC50ZXN0Q29uZGl0aW9uKCk7XHJcblx0XHJcblx0aWYgKHRlc3QpIHtcclxuXHRcdGxvZyhcImluZm9cIiwgXCJIYWx0aW5nIGF0IFwiICsgc0hhbHQuaWQpXHJcblx0XHRcclxuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdCh7XHJcblx0XHRcdHJlc3VsdDpcIkhhbHRcIixcclxuXHRcdFx0cGxheWFibGU6c0hhbHRcclxuXHRcdH0pO1xyXG5cdH1cclxuXHRcclxuXHR2YXIgcmVzdWx0T2JqZWN0ID0ge1xyXG5cdFx0J3Jlc3VsdCc6XCJDb250aW51ZWRcIixcclxuXHRcdCdwbGF5YWJsZSc6c0hhbHRcclxuXHR9O1xyXG5cdFxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0T2JqZWN0KVxyXG5cdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XHRcclxuXHRcdFxyXG5cdFx0Ly9UT0RPOiBhZGQgaW5mb3JtYXRpb24gbWVjaGFuaXNtc1xyXG5cdFx0XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdClcdFx0XHJcblx0fSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xyXG5cdFx0XHJcblx0XHRyZXR1cm4gc0hhbHQucHJvY2VlZChyZXN1bHQsIHNob3J0Q2lyY3VpdCk7XHJcblx0fSk7XHJcbn07XHJcbiovXHJcblxyXG5fU0hhbHQucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSwgZW50cmllcyl7XHJcblx0c3VtbWFyeS5wcm9iYWJpbGl0eSA9IHRoaXMucHJvYmFiaWxpdHk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBTdG9jaGFzdGljSGFsdChwcm9iYWJpbGl0eSwge2lkPW51bGwsIGxvZ0NvbnRpbnVlPWZhbHNlfT17fSl7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKGlkLFwic3RvY2hhc3RpY0hhbHRcIilcclxuXHRcclxuXHRpZiAoaXNOYU4ocHJvYmFiaWxpdHkpIHx8IHByb2JhYmlsaXR5IDwgMCB8fCBwcm9iYWJpbGl0eSA+IDEpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcm9iYWJpbGl0eScpO1xyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIHNIYWx0IG9iamVjdHNcclxuXHR2YXIgX3NIYWx0ID0gbmV3IF9TSGFsdChpZCwgcHJvYmFiaWxpdHksIHtsb2dDb250aW51ZX0pO1xyXG5cdFxyXG5cdFxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgc0hhbHQgPSBQbGF5YWJsZShfc0hhbHQpO1x0XHJcblx0cmV0dXJuIHNIYWx0O1x0XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtfU0hhbHQsIFN0b2NoYXN0aWNIYWx0fTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBTdG9jaGFzdGljTG9vcFwiKVxyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5LCBnYW1lSGlzdG9yeSB9ID0gcmVxdWlyZSgnLi4vc3RhdGUnKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoJy4uL2hlbHBlci1mdW5jdGlvbnMnKShcInN0YXRlXCIpO1xyXG52YXIgeyBjaGFpbmVyR2VuZXJhdG9yIH0gPSByZXF1aXJlKCcuLi9oZWxwZXItZnVuY3Rpb25zJykoXCJwbGF5YWJsZVwiKTtcclxuXHJcbi8vUGFyZW50IGNsYXNzZXNcclxudmFyIHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9ID0gcmVxdWlyZSgnLi9wbGF5YWJsZScpO1xyXG52YXIgeyBfTG9vcCwgTG9vcCB9ID0gcmVxdWlyZSgnLi9sb29wJyk7XHJcblxyXG5cclxuLy9CYWNrZW5kIGZ1bmN0aW9uIGNsYXNzIGZvciBTdG9jaGFzdGljTG9vcFxyXG5mdW5jdGlvbiBfU0xvb3AoaWQsIHBsYXlhYmxlLCBwcm9iYWJpbGl0eSwgcGFyYW1ldGVycykge1xyXG5cdF9Mb29wLmNhbGwodGhpcywgaWQsIHBsYXlhYmxlLCBudWxsLCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0dGhpcy5wbGF5YWJsZSA9IHJlZ2lzdHJ5LnBsYXlhYmxlc1twbGF5YWJsZS5pZCgpXTtcclxuXHJcblx0Ly9UaGlzIGluaGVyaXRzIGZyb20gTG9vcCB3aGljaCB1c2VzIGEgY291bnQuIERlbGV0ZSB0aGF0IGFuZCByZXBsYWNlIHdpdGggcHJvYmFiaWxpdHkuXHJcblx0ZGVsZXRlIHRoaXMuY291bnQ7XHJcblx0dGhpcy5wcm9iYWJpbGl0eSA9IHByb2JhYmlsaXR5O1xyXG5cclxuXHR0aGlzLmdlbmVyYXRvciA9IE1hdGgucmFuZG9tOyAvL1RPRE86IGFsbG93IHVzZXIgdG8gc3BlY2lmeSByYW5kb20gbnVtYmVyIGdlbmVyYXRvclxyXG5cclxuXHRyZWdpc3RyeS5zTG9vcHNbaWRdID0gdGhpcztcclxufVxyXG5fU0xvb3AucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfTG9vcC5wcm90b3R5cGUpO1xyXG5fU0xvb3AucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gX1NMb29wO1xyXG5cclxuX1NMb29wLnJlZ2lzdHJ5TmFtZSA9IFwic0xvb3BzXCI7XHJcbl9TTG9vcC5jb3VudGVyTmFtZSA9IFwic3RvY2hhc3RpY0xvb3BcIjtcclxuXHJcblxyXG5fU0xvb3AucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7XHJcblx0aW5pdGlhbGl6ZVBsYXllcnMgPSBmYWxzZSxcclxuXHRzaG9ydENpcmN1aXQgPSBmYWxzZSxcclxuXHRoaXN0b3J5ID0gZ2FtZUhpc3RvcnksXHJcblx0aW5mb3JtYXRpb246IFBlcmZlY3RJbmZvcm1hdGlvblxyXG59ID0ge30pIHtcclxuXHJcblx0dmFyIHNMb29wID0gdGhpcztcclxuXHRzTG9vcC5jb3VudGVyID0gMDtcclxuXHR2YXIgbG9vcEhpc3RvcnkgPSBoaXN0b3J5LmNoaWxkKCk7XHJcblxyXG5cdGlmIChzTG9vcC5jb21wYXJ0bWVudGFsaXplKSB7XHJcblx0XHRpbmZvcm1hdGlvbiA9IG5ldyBJbmZvcm1hdGlvbihzTG9vcC5jb21wYXJ0bWVudGFsaXplLmhpc3RvcnkgfHwgbG9vcEhpc3RvcnksXHJcblx0XHRcdHNMb29wLmNvbXBhcnRtZW50YWxpemUucG9wdWxhdGlvbiB8fCBpbmZvcm1hdGlvbi5wb3B1bGF0aW9uKTtcclxuXHR9XHJcblxyXG5cclxuXHR2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh7fSk7XHJcblxyXG5cdC8vU2VjdGlvbiB0aGF0IHdpbGwgYmUgbG9vcGVkXHJcblx0dmFyIGFjdGlvbiA9IGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cclxuXHRcdHNMb29wLmNvdW50ZXIrKztcclxuXHRcdGlmICghcmVzdWx0KSByZXN1bHQgPSB7fTtcclxuXHJcblxyXG5cdFx0Ly9EZWFsIHdpdGggaGlzdG9yeVxyXG5cdFx0aGlzdG9yeS5sb2cuYWRkKHtcclxuXHRcdFx0bG9vcDogc0xvb3AuaWQsXHJcblx0XHRcdGxvb3BUbzogc0xvb3AucGxheWFibGUuaWQsXHJcblx0XHRcdGNvdW50OiBzTG9vcC5jb3VudGVyXHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gc0xvb3AucGxheWFibGUucGxheSh7IHNob3J0Q2lyY3VpdDogdHJ1ZSwgaGlzdG9yeTogbG9vcEhpc3RvcnksIGluZm9ybWF0aW9uIH0pXHJcblx0XHRcdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cclxuXHRcdFx0XHRyZXN1bHQucGxheWFibGUgPSBzTG9vcDtcclxuXHRcdFx0XHQvL1RPRE86IGFkZCBpbmZvcm1hdGlvbiBtZWNoYW5pc21zXHJcblxyXG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KVxyXG5cdFx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHJcblx0Ly9HZW5lcmF0ZSByYW5kb20gbnVtYmVycywgcmVwZWF0IHdoaWxlIG51bWJlciBpcyBhYm92ZSBoYWx0aW5nIHByb2JhYmlsaXR5XHJcblx0d2hpbGUgKHNMb29wLmdlbmVyYXRvcigpID4gc0xvb3AucHJvYmFiaWxpdHkpIHtcclxuXHRcdHByb21pc2UgPSBwcm9taXNlLnRoZW4oYWN0aW9uKTtcclxuXHR9XHJcblxyXG5cclxuXHRyZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cclxuXHRcdHJlc3VsdC5oaXN0b3J5RW50cnkgPSB7XHJcblx0XHRcdGxvb3A6IHNMb29wLmlkLFxyXG5cdFx0XHRjb3VudDogc0xvb3AuY291bnRlcixcclxuXHRcdFx0YWN0aW9uOiBsb29wSGlzdG9yeS5vcnBoYW4oKVxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcblx0fSk7XHJcbn07XHJcblxyXG5fU0xvb3AucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSwgZW50cmllcykge1xyXG5cdHN1bW1hcnkucHJvYmFiaWxpdHkgPSB0aGlzLnByb2JhYmlsaXR5O1xyXG5cclxuXHRzdW1tYXJ5LmFjdGlvbiA9IHt9XHJcblx0dGhpcy5wbGF5YWJsZS5zdW1tYXJpemUoc3VtbWFyeS5hY3Rpb24sIGVudHJpZXMsIHRydWUpXHJcbn1cclxuXHJcblxyXG4vL1VzZXIgaW50ZXJmYWNlXHJcbmZ1bmN0aW9uIFN0b2NoYXN0aWNMb29wKHBsYXlhYmxlLCBwcm9iYWJpbGl0eSA9IC41LCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHR2YXIgaWQgPSBpZEhhbmRsZXIocGFyYW1ldGVycy5pZCwgXCJzdG9jaGFzdGljTG9vcFwiKVxyXG5cclxuXHRpZiAoaXNOYU4ocHJvYmFiaWxpdHkpIHx8IHByb2JhYmlsaXR5IDwgMCB8fCBwcm9iYWJpbGl0eSA+IDEpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcm9iYWJpbGl0eScpO1xyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIHNMb29wIG9iamVjdFxyXG5cdHZhciBfc0xvb3AgPSBuZXcgX1NMb29wKGlkLCBwbGF5YWJsZSwgcHJvYmFiaWxpdHksIHBhcmFtZXRlcnMpO1xyXG5cclxuXHJcblx0Ly9SZXR1cm4gdGhpcyByZWZlcmVuY2Ugb2JqZWN0IHRvIHRoZSB1c2VyLiBSdW4gdGhlIGZ1bmN0aW9uIHRvIHNlbGVjdCBhIHNvdXJjZVxyXG5cdHZhciBzTG9vcCA9IFBsYXlhYmxlKF9zTG9vcCk7XHJcblx0cmV0dXJuIHNMb29wO1xyXG59XHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBfU0xvb3AsIFN0b2NoYXN0aWNMb29wIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XHJcbmxvZyhcImRlYnVnXCIsIFwiTG9hZGluZyBDbGFzczogVHVyblwiKTtcclxuXHJcbi8vRXh0ZXJuYWwgZGVwZW5kZW5jeVxyXG52YXIgeyBTeW5jaHJvbm91c1Byb21pc2UgfSA9IHJlcXVpcmUoXCJzeW5jaHJvbm91cy1wcm9taXNlXCIpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlzT2JqZWN0LCBvbmNlIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyLWZ1bmN0aW9uc1wiKShcImdlbmVyYWxcIik7XHJcbnZhciB7IGNoYWluZXJHZW5lcmF0b3IsIG91dGNvbWVUcmVlR2V0VmFsdWUsIG91dGNvbWVUcmVlU2V0VmFsdWUgfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXItZnVuY3Rpb25zXCIpKFwicGxheWFibGVcIik7XHJcbnZhciB7IHJlY3Vyc2UgfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXItZnVuY3Rpb25zXCIpKFwidHVyblwiKTtcclxudmFyIHsgaWRIYW5kbGVyIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyLWZ1bmN0aW9uc1wiKShcInN0YXRlXCIpO1xyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKFwiLi4vc3RhdGVcIik7XHJcbnZhciB7IGdhbWVIaXN0b3J5IH0gPSByZXF1aXJlKFwiLi4vaGlzdG9yeVwiKTtcclxudmFyIHsgSW5mb3JtYXRpb24sIFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0gcmVxdWlyZShcIi4uL2luZm9ybWF0aW9uXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9ID0gcmVxdWlyZShcIi4vcGxheWFibGVcIik7XHJcblxyXG4vL0JhY2tlbmQgZnVuY3Rpb24gY2xhc3MgZm9yIFR1cm5cclxuZnVuY3Rpb24gX1R1cm4oaWQsIGNob2ljZXMsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdF9QbGF5YWJsZS5jYWxsKHRoaXMsIGlkKTtcclxuXHJcblx0dGhpcy5wYXlvZmZzSW1wbGljaXQgPSB7fTtcclxuXHR0aGlzLnBheW9mZnNFeHBsaWNpdCA9IHt9O1xyXG5cclxuXHR0aGlzLm5leHQgPSB7fTtcclxuXHJcblx0dGhpcy5jaG9pY2VzID0gY2hvaWNlcy5tYXAoZnVuY3Rpb24oY2hvaWNlKSB7XHJcblx0XHRyZXR1cm4gcmVnaXN0cnkuY2hvaWNlc1tjaG9pY2UuaWQoKV07XHJcblx0fSk7XHJcblxyXG5cdHJlZ2lzdHJ5LnR1cm5zW2lkXSA9IHRoaXM7XHJcblxyXG5cdHZhciB0dXJuID0gdGhpcztcclxuXHJcblx0dGhpcy5jaG9pY2VNYXAgPSB0aGlzLmNob2ljZXMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdHJldHVybiBpdGVtLm9wdGlvbnM7XHJcblx0fSk7XHJcblxyXG5cdHJlY3Vyc2UodHVybi5jaG9pY2VNYXAsIHR1cm4ucGF5b2Zmc0ltcGxpY2l0LCBudWxsLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIEFycmF5KHR1cm4uY2hvaWNlTWFwLmxlbmd0aCkuZmlsbCgwKTtcclxuXHRcdH0pXHJcblx0XHQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0bG9nKFwic2lsbHlcIiwgXCJBZGRlZCBpbXBsaWNpdCBwYXlvZmZzIG1hcCB0byB0dXJuLlwiKTtcclxuXHRcdFx0cmV0dXJuIHJlY3Vyc2UodHVybi5jaG9pY2VNYXAsIHR1cm4ucGF5b2Zmc0V4cGxpY2l0LCB7fSk7XHJcblx0XHR9KVxyXG5cdFx0LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdGxvZyhcInNpbGx5XCIsIFwiQWRkZWQgZXhwbGljaXQgcGF5b2ZmcyBtYXAgdG8gdHVybi5cIik7XHJcblx0XHRcdHJldHVybiByZWN1cnNlKHR1cm4uY2hvaWNlTWFwLCB0dXJuLm5leHQsIG51bGwsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBbXTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KVxyXG5cdFx0LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdGxvZyhcInNpbGx5XCIsIFwiQWRkZWQgYmxhbmsgbmV4dCBtYXAgdG8gdHVybi5cIik7XHJcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHRcdH0pXHJcblx0XHQuY2F0Y2goZnVuY3Rpb24ocmVhc29uKSB7XHJcblx0XHRcdGxvZyhcImVycm9yXCIsIHJlYXNvbik7XHJcblx0XHR9KTsgLy9UT0RPOiBlcnJvciBoYW5kbGluZyBoZXJlXHJcbn1cclxuX1R1cm4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfUGxheWFibGUucHJvdG90eXBlKTtcclxuX1R1cm4ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gX1R1cm47XHJcblxyXG5fVHVybi5yZWdpc3RyeU5hbWUgPSBcInR1cm5zXCI7XHJcbl9UdXJuLmNvdW50ZXJOYW1lID0gXCJ0dXJuXCI7XHJcblxyXG5cclxuX1R1cm4ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7XHJcblx0dXNlUGF5b2ZmcyA9IHRydWUsXHJcblx0aGlzdG9yeSA9IGdhbWVIaXN0b3J5LFxyXG5cdGluZm9ybWF0aW9uID0gUGVyZmVjdEluZm9ybWF0aW9uLFxyXG5cdHJlbGVhc2VQbGF5ZXJzID0gdHJ1ZVxyXG59ID0ge30pIHtcclxuXHJcblx0dmFyIHR1cm4gPSB0aGlzO1xyXG5cdHZhciBjaG9pY2VIaXN0b3J5ID0gaGlzdG9yeS5jaGlsZCgpO1xyXG5cdHZhciBjaG9pY2VJbmZvcm1hdGlvbiA9IGluZm9ybWF0aW9uLmNoaWxkKCk7XHJcblxyXG5cdGlmICh0dXJuLmNvbXBhcnRtZW50YWxpemUpIHtcclxuXHRcdGNob2ljZUluZm9ybWF0aW9uID0gbmV3IEluZm9ybWF0aW9uKHR1cm4uY29tcGFydG1lbnRhbGl6ZS5oaXN0b3J5IHx8IGNob2ljZUhpc3RvcnksXHJcblx0XHRcdHR1cm4uY29tcGFydG1lbnRhbGl6ZS5wb3B1bGF0aW9uIHx8IGluZm9ybWF0aW9uLnBvcHVsYXRpb24pO1xyXG5cdH1cclxuXHJcblx0aGlzdG9yeS5sb2cuYWRkKHtcclxuXHRcdHR1cm46IHR1cm4uaWQsXHJcblx0XHRjaG9pY2VzOiB0dXJuLmNob2ljZXMubWFwKGZ1bmN0aW9uKGNob2ljZSkge1xyXG5cdFx0XHRyZXR1cm4gY2hvaWNlLmlkO1xyXG5cdFx0fSlcclxuXHR9KTtcclxuXHJcblx0dmFyIGNvbXBpbGVJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uKHJpKSB7XHJcblx0XHQvL0lmIHRoZXJlJ3Mgbm8gdHVybiBlbnRyeSwgY3JlYXRlIG9uZS5cclxuXHRcdGlmICghY2hvaWNlSW5mb3JtYXRpb24uYWRkaXRpb25hbFswXS50dXJuKSB7XHJcblx0XHRcdHZhciB0dXJuSW5mbyA9IHtcclxuXHRcdFx0XHR0dXJuOiB7XHJcblx0XHRcdFx0XHRpZDogdHVybi5pZCxcclxuXHRcdFx0XHRcdGNob2ljZXM6IFtdLFxyXG5cdFx0XHRcdFx0ZXhjbHVkZShwbGF5ZXIpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY2hvaWNlcy5maWx0ZXIoZnVuY3Rpb24oY2hvaWNlKSB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNob2ljZS5wbGF5ZXIgPT0gcGxheWVyO1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHRcdGNob2ljZUluZm9ybWF0aW9uLmFkZGl0aW9uYWwudW5zaGlmdCh0dXJuSW5mbyk7XHJcblx0XHR9XHJcblx0XHRjaG9pY2VJbmZvcm1hdGlvbi5hZGRpdGlvbmFsWzBdLnR1cm4uY2hvaWNlcy5wdXNoKFxyXG5cdFx0XHRjaG9pY2VJbmZvcm1hdGlvbi5hZGRpdGlvbmFsLnBvcCgpXHJcblx0XHQpO1xyXG5cclxuXHRcdGluZm9ybWF0aW9uLmFkZGl0aW9uYWwuZm9yRWFjaCggLy8gVE9ETzogd2hhdCBkb2VzIHRoaXMgZG8/Pz9cclxuXHRcdFx0Y2hvaWNlSW5mb3JtYXRpb24uYWRkQWRkaXRpb25hbC5iaW5kKGNob2ljZUluZm9ybWF0aW9uKVxyXG5cdFx0KTtcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5hbGwoXHJcblx0XHRcdHR1cm4uY2hvaWNlcy5tYXAoZnVuY3Rpb24oY2hvaWNlKSB7XHJcblx0XHRcdFx0cmV0dXJuIGNob2ljZS5wbGF5KHtcclxuXHRcdFx0XHRcdHNob3J0Q2lyY3VpdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGhpc3Rvcnk6IGNob2ljZUhpc3RvcnksXHJcblx0XHRcdFx0XHRpbmZvcm1hdGlvbjogY2hvaWNlSW5mb3JtYXRpb24sXHJcblx0XHRcdFx0XHRfY29tcGlsZUluZm9ybWF0aW9uOiBjb21waWxlSW5mb3JtYXRpb24sXHJcblx0XHRcdFx0XHRyZWxlYXNlUGxheWVyczogZmFsc2VcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSlcclxuXHRcdClcclxuXHRcdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHQvL1JlLWZvcm1hdCBvdXRwdXQgZnJvbSBhcnJheSBvZiBDaG9pY2UgcmVzdWx0cyB0byBzaW5nbGUgVHVybiByZXN1bHRcclxuXHRcdFx0Ly9BbmQgcmVsZWFzZSBwbGF5ZXJzXHJcblx0XHRcdHZhciByZXN1bHRQYXRoID0gcmVzdWx0Lm1hcChmdW5jdGlvbihjaG9pY2UsIGluZGV4KSB7XHJcblx0XHRcdFx0aWYgKHJlbGVhc2VQbGF5ZXJzKSB0dXJuLmNob2ljZXNbaW5kZXhdLnJlbGVhc2VQbGF5ZXIoKTtcclxuXHRcdFx0XHRyZXR1cm4gY2hvaWNlLnJlc3VsdDtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvL1Bhc3MgYWxvbmcgcmVzdWx0cyBhbmQgcmVjb3JkIGhpc3RvcnlcclxuXHRcdFx0dmFyIHJlc3VsdE9iamVjdCA9IHtcclxuXHRcdFx0XHRyZXN1bHQ6IHJlc3VsdFBhdGgsXHJcblx0XHRcdFx0cGxheWFibGU6IHR1cm4sXHJcblx0XHRcdFx0aGlzdG9yeUVudHJ5OiB7XHJcblx0XHRcdFx0XHR0dXJuOiB0dXJuLmlkLFxyXG5cdFx0XHRcdFx0cmVzdWx0czogY2hvaWNlSGlzdG9yeS5vcnBoYW4oKSxcclxuXHRcdFx0XHRcdHBheW91dHM6IHt9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRPYmplY3QpO1xyXG5cdFx0fSlcclxuXHRcdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHQvL0ltcGxlbWVudCBwYXlvZmZzXHJcblx0XHRcdGlmICh1c2VQYXlvZmZzKSB7XHJcblx0XHRcdFx0dmFyIGltcGxpY2l0UGF5b2ZmcyA9IG91dGNvbWVUcmVlR2V0VmFsdWUoXHJcblx0XHRcdFx0XHR0dXJuLnBheW9mZnNJbXBsaWNpdCxcclxuXHRcdFx0XHRcdHJlc3VsdC5yZXN1bHRcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHRcdHZhciBleHBsaWNpdFBheW9mZnMgPSBvdXRjb21lVHJlZUdldFZhbHVlKFxyXG5cdFx0XHRcdFx0dHVybi5wYXlvZmZzRXhwbGljaXQsXHJcblx0XHRcdFx0XHRyZXN1bHQucmVzdWx0XHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0Ly8gRm9yIHRoZSBsb2dcclxuXHRcdFx0XHR2YXIgcGF5b3V0cyA9IHt9O1xyXG5cclxuXHRcdFx0XHRpbXBsaWNpdFBheW9mZnMuZm9yRWFjaChmdW5jdGlvbihwYXlvZmYsIGluZGV4KSB7XHJcblx0XHRcdFx0XHQvLyBEbyBub3RoaW5nIGlmIHBheW9mZiBpcyB6ZXJvLlxyXG5cdFx0XHRcdFx0aWYgKHBheW9mZiA9PSAwKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdFx0Ly8gZmV0Y2ggcGxheWVyIGFuZCBpbmNyZW1lbnQgc2NvcmVcclxuXHRcdFx0XHRcdHZhciBwbGF5ZXIgPSB0dXJuLmNob2ljZXNbaW5kZXhdLnBsYXllcjtcclxuXHRcdFx0XHRcdHBsYXllci5zY29yZSArPSBwYXlvZmY7XHJcblxyXG5cdFx0XHRcdFx0Ly9BbmQgaW5jbHVkZSBpdCBpbiB0aGUgbG9nIGVudHJ5XHJcblx0XHRcdFx0XHRwYXlvdXRzW3BsYXllci5pZF0gPSBOdW1iZXIocGF5b2ZmKTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0Zm9yICh2YXIgcGxheWVyIGluIGV4cGxpY2l0UGF5b2Zmcykge1xyXG5cdFx0XHRcdFx0cmVnaXN0cnkucGxheWVyc1twbGF5ZXJdLnNjb3JlICs9IGV4cGxpY2l0UGF5b2Zmc1twbGF5ZXJdO1xyXG5cclxuXHRcdFx0XHRcdC8vQW5kIGluY2x1ZGUgaXQgaW4gdGhlIGxvZyBlbnRyeVxyXG5cdFx0XHRcdFx0cGF5b3V0c1twbGF5ZXJdID0gTnVtYmVyKGV4cGxpY2l0UGF5b2Zmc1twbGF5ZXJdKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vTG9nIGZvciB0aGUgc2NvcmVzIGxvZ1xyXG5cdFx0XHRcdHZhciBzY29yZUVudHJ5ID0ge1xyXG5cdFx0XHRcdFx0dHVybjogdHVybi5pZCxcclxuXHRcdFx0XHRcdHJlc3VsdDogcmVzdWx0LnJlc3VsdCxcclxuXHRcdFx0XHRcdHBheW91dHM6IHBheW91dHNcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdGhpc3RvcnkuYWRkU2NvcmVzKHNjb3JlRW50cnkpO1xyXG5cclxuXHJcblx0XHRcdFx0Ly8gTG9nIGZvciB0aGUgZ2FtZSBoaXN0b3J5XHJcblx0XHRcdFx0cmVzdWx0Lmhpc3RvcnlFbnRyeS5wYXlvdXRzID0gcGF5b3V0cztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpOyAvL1RPRE86IGFkZCBpbmZvcm1hdGlvbiBtZWNoYW5pc21zXHJcblx0XHR9KTtcclxufTtcclxuXHJcbi8vT3ZlcndyaXRlIGRlZmF1bHQgaGlzdG9yeSBoYW5kbGVyLCBiZWNhdXNlIHdlIGRvbid0IHdhbnQgYSBzZWNvbmQgZW50cnkgaW4gdGhlIHRyZWVcclxuX1R1cm4ucHJvdG90eXBlLmhhbmRsZUhpc3RvcnkgPSBmdW5jdGlvbih7IGhpc3RvcnkgPSBnYW1lSGlzdG9yeSB9ID0ge30sXHJcblx0cmVzdWx0XHJcbikge1xyXG5cdGhpc3RvcnkuYWRkTm9Mb2cocmVzdWx0Lmhpc3RvcnlFbnRyeSk7XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxufTtcclxuXHJcbl9UdXJuLnByb3RvdHlwZS5maW5kTmV4dCA9IGZ1bmN0aW9uKHsgcmVzdWx0IH0gPSB7fSkge1xyXG5cdHJldHVybiBvdXRjb21lVHJlZUdldFZhbHVlKHRoaXMubmV4dCwgcmVzdWx0LnJlc3VsdCk7XHJcbn07XHJcblxyXG5fVHVybi5wcm90b3R5cGUuZ2VuZXJhdGVDaGFpbmluZ0Z1bmN0aW9ucyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBfdHVybiA9IHRoaXM7XHJcblx0dmFyIHR1cm4gPSBfdHVybi5pbnRlcmZhY2U7XHJcblxyXG5cdC8vQ3JlYXRlIHBheW9mZiBzZXR0ZXIvYnJhbmNoIHJvdXRlciBmdW5jdGlvbnMuXHJcblx0Ly9yZWN1cnNlIGFkZHMgYSB3cmFwcGVyIGFyb3VuZCB0aGlzIGZ1bmN0aW9uIHdoaWNoIHN1cHBsaWVzIHRoZSBwYXRoLlxyXG5cdHJlY3Vyc2UoX3R1cm4uY2hvaWNlTWFwLCB0dXJuLCBmdW5jdGlvbihwYXRoLCBwYXlvZmZzKSB7XHJcblx0XHQvL0lmIHVzZXIgc3VwcGxpZWQgcGF5b2ZmcyBpbiBhcnJheSBmb3JtLCB0aGVuIHRyYW5zbGF0ZSB0byBvYmplY3QgYmFzZWQgb24gd2hpY2ggcGxheWVycyBhcmUgaW52b2x2ZWQgaW4gdGhlIGNob2ljZXNcclxuXHRcdGlmIChBcnJheS5pc0FycmF5KHBheW9mZnMpKSB7XHJcblx0XHRcdGlmIChwYXlvZmZzLmxlbmd0aCAhPT0gX3R1cm4uY2hvaWNlcy5sZW5ndGgpIHtcclxuXHRcdFx0XHQvL0lmIGFycmF5IGlzbid0IHJpZ2h0IGxlbmd0aCwgdGhlbiB0aGlzIGlzIHVuaW50ZWxsaWdpYmxlLlxyXG5cdFx0XHRcdGxvZyhcclxuXHRcdFx0XHRcdFwiZXJyb3JcIixcclxuXHRcdFx0XHRcdFwiUGF5b2ZmIGFycmF5IGRvZXMgbm90IG1hdGNoIFR1cm4gZGltZW5zaW9ucywgY2Fubm90IGFzc2lnbiBwYXlvZmZzLlwiXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiUGF5b2ZmIGFycmF5IGlzIG5vdCBjb3JyZWN0IGxlbmd0aFwiKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBvcmlnaW5hbFBheW9mZnMgPSBwYXlvZmZzLnNsaWNlKCk7XHJcblx0XHRcdHBheW9mZnMgPSB7fTtcclxuXHJcblx0XHRcdG91dGNvbWVUcmVlU2V0VmFsdWUoX3R1cm4ucGF5b2Zmc0ltcGxpY2l0LCBwYXRoLCBvcmlnaW5hbFBheW9mZnMpO1xyXG5cdFx0fSBlbHNlIGlmIChpc09iamVjdChwYXlvZmZzKSkge1xyXG5cdFx0XHRwYXlvZmZzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwYXlvZmZzKSk7XHJcblx0XHRcdG91dGNvbWVUcmVlU2V0VmFsdWUoX3R1cm4ucGF5b2Zmc0V4cGxpY2l0LCBwYXRoLCBwYXlvZmZzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoe1xyXG5cdFx0XHRwbGF5YWJsZTogdHVybixcclxuXHRcdFx0cGF0aDogcGF0aFxyXG5cdFx0fSk7XHJcblx0fSk7XHJcbn07XHJcblxyXG5fVHVybi5wcm90b3R5cGUuc2V0QWxsUGF5b2ZmcyA9IGZ1bmN0aW9uKHBheW9mZkFycmF5KSB7XHJcblx0dmFyIHR1cm4gPSB0aGlzO1xyXG5cclxuXHQvL1JlY3Vyc2UgdGhyb3VnaCB0aGUgb3B0aW9ucyBpbiBpbnB1dCwgdG8gY29tZSB1cCB3aXRoIGEgcGF0aCB0byBldmVyeSBjb21iaW5hdGlvbiBvZiBvcHRpb25zIGluIHRoZSBhcnJheSBvZiBhcnJheXMuXHJcblx0ZnVuY3Rpb24gcmVjdXJzZShpbnB1dCwgbnVtUGxheWVycywgcGF5b2ZmcywgcGF0aCA9IFtdLCBjb29yZGluYXRlcyA9IFtdKSB7XHJcblx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUocGF0aCkudGhlbihmdW5jdGlvbihwYXRoKSB7XHJcblx0XHRcdC8vU2luY2Ugd2Ugc2xpY2UgdGhlIGFycmF5IGVhY2ggdGltZSwgaWYgdGhlcmUgYXJlIG5vIG1vcmUgZW50cmllcyBsZWZ0IHRoZW4gd2UncmUgZG9uZSB3aXRoIHRoaXMgYnJhbmNoLlxyXG5cdFx0XHRpZiAoaW5wdXQubGVuZ3RoID09IDApIHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZShwYXRoKTtcclxuXHJcblx0XHRcdC8vQW1vbmcgYWxsIHZhbHVlcyBmcm9tIHRoZSBhcnJheVxyXG5cdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLmFsbChcclxuXHRcdFx0XHRpbnB1dFswXS5tYXAoZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcclxuXHRcdFx0XHRcdHZhciBzcGxpdFBhdGggPSBwYXRoLnNsaWNlKDApLmNvbmNhdChpdGVtKTtcclxuXHRcdFx0XHRcdHZhciBzcGxpdENvb3JkaW5hdGVzID0gY29vcmRpbmF0ZXMuc2xpY2UoMCkuY29uY2F0KGluZGV4KTtcclxuXHRcdFx0XHRcdHZhciBzcGxpdFBheW9mZnMgPSBwYXlvZmZzW2luZGV4XTtcclxuXHJcblx0XHRcdFx0XHQvL0lmIHdlJ3JlIGF0IHRoZSBsYXN0IHBvc2l0aW9uIGluIHRoZSBhcnJheSBvZiBvcHRpb25zLCB0aGVuIHdlIGhhdmUgYSBjb21wbGV0ZSBwYXRoLlxyXG5cdFx0XHRcdFx0aWYgKGlucHV0Lmxlbmd0aCA9PSAxKSB7XHJcblx0XHRcdFx0XHRcdC8qIHlvdSBtaWdodCBuZWVkIHRoZXNlIGxhdGVyXHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcInBhdGggXCIsIHNwbGl0UGF0aCk7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcImNvb3JkaW5hdGVzIFwiLCBzcGxpdENvb3JkaW5hdGVzKVxyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJwYXlvZmYgXCIsc3BsaXRQYXlvZmZzKVxyXG5cdFx0XHRcdFx0Ki9cclxuXHJcblx0XHRcdFx0XHRcdHNwbGl0UGF5b2ZmcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc3BsaXRQYXlvZmZzKSk7XHJcblxyXG5cdFx0XHRcdFx0XHQvL0FsbG93IHRoZSBmaXJzdCBmZXcgYXJyYXkgZWxlbWVudHMgdG8gYmUgaW1wbGljaXQgcGF5b2Zmcy4gQ2hlY2sgdGhhdCB0aGV5IGFyZSBhY3R1YWxseSB0aGVyZSBhbmQgYXJlIG51bWJlcnNcclxuXHRcdFx0XHRcdFx0dmFyIGltcGxpY2l0ID0gc3BsaXRQYXlvZmZzLnNsaWNlKDAsIG51bVBsYXllcnMpO1xyXG5cdFx0XHRcdFx0XHRpZiAoXHJcblx0XHRcdFx0XHRcdFx0aW1wbGljaXQubGVuZ3RoID09IG51bVBsYXllcnMgJiZcclxuXHRcdFx0XHRcdFx0XHRpbXBsaWNpdC5ldmVyeShmdW5jdGlvbihwYXlvZmYpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAhaXNOYU4ocGF5b2ZmKTtcclxuXHRcdFx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdFx0XHQpIHtcclxuXHRcdFx0XHRcdFx0XHRvdXRjb21lVHJlZVNldFZhbHVlKHR1cm4ucGF5b2Zmc0ltcGxpY2l0LCBzcGxpdFBhdGgsIGltcGxpY2l0KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Ly9BbnkgcmVtYWluaW5nIHNob3VsZCBiZSBhc3NpZ25lZCBhcyBleHBsaWNpdCBwYXlvZmZzLCBpZiB0aGV5J3JlIG9iamVjdHMuXHJcblx0XHRcdFx0XHRcdHNwbGl0UGF5b2Zmcy5zbGljZShudW1QbGF5ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKGV4cGxpY2l0KSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGlzT2JqZWN0KGV4cGxpY2l0KSlcclxuXHRcdFx0XHRcdFx0XHRcdG91dGNvbWVUcmVlU2V0VmFsdWUodHVybi5wYXlvZmZzRXhwbGljaXQsIHNwbGl0UGF0aCwgZXhwbGljaXQpO1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvL0lmIHRoZXJlIGFyZSBtb3JlIGl0ZW1zIHRvIGl0ZXJhdGUgb3ZlciwgaW5jbHVkZSB0aGVtIGluIHRoZSBvdXRwdXQgdGhlbiByZWN1cnNlLlxyXG5cdFx0XHRcdFx0cmV0dXJuIHJlY3Vyc2UoXHJcblx0XHRcdFx0XHRcdGlucHV0LnNsaWNlKDEpLFxyXG5cdFx0XHRcdFx0XHRudW1QbGF5ZXJzLFxyXG5cdFx0XHRcdFx0XHRzcGxpdFBheW9mZnMsXHJcblx0XHRcdFx0XHRcdHNwbGl0UGF0aCxcclxuXHRcdFx0XHRcdFx0c3BsaXRDb29yZGluYXRlc1xyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHQpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVjdXJzZSh0dXJuLmNob2ljZU1hcCwgdHVybi5jaG9pY2VzLmxlbmd0aCwgcGF5b2ZmQXJyYXkpLmNhdGNoKFxyXG5cdFx0ZnVuY3Rpb24ocmVhc29uKSB7XHJcblx0XHRcdGxvZyhcImVycm9yXCIsIHJlYXNvbik7XHJcblx0XHR9XHJcblx0KTtcclxufTtcclxuXHJcbi8vIEFkZGluZyBtb3JlIGNvbXBsaWNhdGVkIHN1bW1hcnkgZW50cnlcclxuX1R1cm4ucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSwgZW50cmllcywgc2hvcnRDaXJjdWl0ID0gZmFsc2UpIHtcclxuXHQvLyBGZXRjaCBzdW1tYXJpZXMgZm9yIGVhY2ggY2hvaWNlLlxyXG5cdHN1bW1hcnkuY2hvaWNlcyA9IFtdO1xyXG5cdHRoaXMuY2hvaWNlcy5mb3JFYWNoKGZ1bmN0aW9uKGNob2ljZSwgaW5kZXgpIHtcclxuXHRcdHN1bW1hcnkuY2hvaWNlc1tpbmRleF0gPSBjaG9pY2Uuc3VtbWFyaXplKFxyXG5cdFx0XHRzdW1tYXJ5LmNob2ljZXNbaW5kZXhdLFxyXG5cdFx0XHRlbnRyaWVzLFxyXG5cdFx0XHR0cnVlXHJcblx0XHQpO1xyXG5cdH0pO1xyXG5cclxuXHQvLyBJbmNsdWRlIHBheW9mZnNcclxuXHRzdW1tYXJ5LnBheW9mZnMgPSBKU09OLnBhcnNlKFxyXG5cdFx0SlNPTi5zdHJpbmdpZnkoe1xyXG5cdFx0XHRpbXBsaWNpdDogdGhpcy5wYXlvZmZzSW1wbGljaXQsXHJcblx0XHRcdGV4cGxpY2l0OiB0aGlzLnBheW9mZnNFeHBsaWNpdFxyXG5cdFx0fSlcclxuXHQpO1xyXG5cclxuXHRyZXR1cm4gc3VtbWFyeTtcclxufTtcclxuXHJcbi8vXHJcbl9UdXJuLnByb3RvdHlwZS5zdW1tYXJ5TmV4dCA9IGZ1bmN0aW9uKHN1bW1hcnksIGVudHJpZXMpIHtcclxuXHR2YXIgdHVybiA9IHRoaXM7XHJcblxyXG5cdC8vIENyZWF0ZSBtYXBcclxuXHRzdW1tYXJ5Lm5leHQgPSB7fTtcclxuXHR2YXIgY291bnQgPSAwO1xyXG5cdHJlY3Vyc2UodGhpcy5jaG9pY2VNYXAsIHN1bW1hcnkubmV4dCwgbnVsbCwgZnVuY3Rpb24ocGF0aCkge1xyXG5cdFx0cmV0dXJuIG91dGNvbWVUcmVlR2V0VmFsdWUodHVybi5uZXh0LCBwYXRoKS5tYXAoZnVuY3Rpb24ocGxheWFibGUpIHtcclxuXHRcdFx0Kytjb3VudDtcclxuXHRcdFx0cmV0dXJuIHBsYXlhYmxlLnN1bW1hcml6ZSgpO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblxyXG5cdC8vIElmIHRoZXJlIGlzIG5vIG5leHQsIGRlbGV0ZSB0aGUga2V5LlxyXG5cdGlmIChjb3VudCA9PSAwKSBkZWxldGUgc3VtbWFyeS5uZXh0O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gVHVybihjaG9pY2VzLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHR2YXIgaWQgPSBpZEhhbmRsZXIocGFyYW1ldGVycy5pZCwgXCJ0dXJuXCIpO1xyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIGNob2ljZSBvYmplY3RcclxuXHR2YXIgX3R1cm4gPSBuZXcgX1R1cm4oaWQsIGNob2ljZXMsIHBhcmFtZXRlcnMpO1xyXG5cclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIHR1cm4gPSBQbGF5YWJsZShfdHVybik7XHJcblxyXG5cdF90dXJuLmdlbmVyYXRlQ2hhaW5pbmdGdW5jdGlvbnMoKTtcclxuXHJcblx0Ly9GdW5jdGlvbiB0byBzZXQgYWxsIHBheW9mZnMgYXQgb25jZVxyXG5cdHR1cm4uc2V0QWxsUGF5b2ZmcyA9IGZ1bmN0aW9uKHBheW9mZnMpIHtcclxuXHRcdC8vVE9ETzogSW5jbHVkZSBlcnJvciBoYW5kbGluZyBpZiBhcnJheSBnaXZlbiBpc24ndCBleHBlY3RlZCBkaW1lbnNpb25zLlxyXG5cdFx0X3R1cm4uc2V0QWxsUGF5b2ZmcyhwYXlvZmZzKTtcclxuXHR9O1xyXG5cclxuXHQvL1dheSBmb3IgdXNlciB0byBpbnRlcmFjdCB3aXRoIHBheW9mZnNcclxuXHR0dXJuLnBheW9mZnMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBKU09OLnBhcnNlKFxyXG5cdFx0XHRKU09OLnN0cmluZ2lmeSh7XHJcblx0XHRcdFx0aW1wbGljaXQ6IF90dXJuLnBheW9mZnNJbXBsaWNpdCxcclxuXHRcdFx0XHRleHBsaWNpdDogX3R1cm4ucGF5b2Zmc0V4cGxpY2l0XHJcblx0XHRcdH0pXHJcblx0XHQpO1xyXG5cdH07XHJcblxyXG5cdC8vIFJldHVybnMgdGhlIHBheW9mZnMgaW4gbmVzdGVkIGFycmF5IGZvcm0sIHRvIG1ha2UgY2xvbmluZyBlYXNpZXIsIGllLiB0Mi5zZXRBbGxQYXlvZmZzKHQxLnBheW9mZnNNYXRyaXgoKSlcclxuXHR0dXJuLnBheW9mZnNNYXRyaXggPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHQvLyByZWN1cnNpb24gdG8gY29uc3RydWN0IHBheW9mZiBtYXRyaXhcclxuXHRcdHZhciBtYXBwZXIgPSBmdW5jdGlvbihvYmosIHBhdGggPSBbXSkge1xyXG5cdFx0XHQvL0lmIGl0J3MgYW4gYXJyYXksIHRoZW4gd2UndmUgcmVhY2hlZCB0aGUgcGF5b2Zmc1xyXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcblx0XHRcdFx0dmFyIHBheW9mZiA9IG9iai5zbGljZSgwKVxyXG5cdFx0XHRcdC8vIEFkZCBleHBsaWNpdCBwYXlvZmZzIHRvb1xyXG5cdFx0XHRcdHZhciBleHBsaWNpdCA9IG91dGNvbWVUcmVlR2V0VmFsdWUoX3R1cm4ucGF5b2Zmc0V4cGxpY2l0LCBwYXRoKTtcclxuXHJcblx0XHRcdFx0Ly8gT25seSBhZGQgYW4gZW50cnkgaWYgdGhlIGV4cGxpY2l0IHBheW9mZnMgb2JqZWN0IGlzIG5vdCBlbXB0eVxyXG5cdFx0XHRcdHJldHVybiBPYmplY3Qua2V5cyhleHBsaWNpdCkubGVuZ3RoID4gMCA/IHBheW9mZi5jb25jYXQoW291dGNvbWVUcmVlR2V0VmFsdWUoX3R1cm4ucGF5b2Zmc0V4cGxpY2l0LFxyXG5cdFx0XHRcdFx0cGF0aCldKSA6IHBheW9mZlxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBPdGhlcndpc2UsIGRpZyBpbiBkZWVwZXJcclxuXHRcdFx0ZWxzZSByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24oa2V5KSB7IHJldHVybiBtYXBwZXIob2JqW2tleV0sIHBhdGguc2xpY2UoMCkuY29uY2F0KFtrZXldKSkgfSlcclxuXHRcdH1cclxuXHRcdHJldHVybiBtYXBwZXIoX3R1cm4ucGF5b2Zmc0ltcGxpY2l0KVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHR1cm47XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBfVHVybiwgVHVybiB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKCcuL3N0YXRlJyk7XHJcblxyXG4vL0hlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgaWRIYW5kbGVyIH0gPSByZXF1aXJlKCcuL2hlbHBlci1mdW5jdGlvbnMnKShcInN0YXRlXCIpO1xyXG52YXIgeyBjaGFpbmVyR2VuZXJhdG9yIH0gPSByZXF1aXJlKCcuL2hlbHBlci1mdW5jdGlvbnMnKShcInBsYXlhYmxlXCIpO1xyXG5cclxudmFyIHsgVXNlckhpc3RvcnkgfSA9IHJlcXVpcmUoJy4vaGlzdG9yeScpO1xyXG5cclxuLy8gUGx1Z2luc1xyXG52YXIgUGx1Z2luTWFuYWdlciA9IHJlcXVpcmUoXCIuL3BsdWdpbi1tYW5hZ2VyXCIpXHJcblxyXG4vL0JhY2tlbmQgZm9yIFBsYXllclxyXG5mdW5jdGlvbiBfUGxheWVyKGlkLCB7IG5hbWUgPSBcIlwiLCBhc3NpZ24gPSBudWxsIH0gPSB7fSkge1xyXG5cdGxvZygnc2lsbHknLCAnQ3JlYXRpbmcgaW50ZXJhbCBwbGF5ZXIgb2JqZWN0LicpO1xyXG5cclxuXHR0aGlzLmlkID0gaWRcclxuXHR0aGlzLnNjb3JlID0gMFxyXG5cdHRoaXMubmFtZSA9IG5hbWU7XHJcblxyXG5cdHRoaXMuaGlzdG9yeSA9IFtdO1xyXG5cclxuXHRpZiAoYXNzaWduKSB0aGlzLmFzc2lnbihhc3NpZ24pO1xyXG5cclxuXHR0aGlzLmFsaXZlID0gdHJ1ZTtcclxuXHR0aGlzLmF2YWlsYWJsZSA9IHRydWU7XHJcblxyXG5cdHJlZ2lzdHJ5LnBsYXllcnNbaWRdID0gdGhpcztcclxufVxyXG5cclxuXHJcbi8vTWFrZSBhIGNvcHkgb2YgdGhlIHBsYXllciwgaW4gb3JkZXIgdG8gdGFrZSBhIHNuYXBzaG90LiAvLy8vVE9ETyB0cnkgdGhpcyBhZ2FpbiBzb21ldGltZS5cclxuLypcclxuX1BsYXllci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpe1xyXG5cdC8vTWFrZSBuZXcgY29weS4gRG9uJ3Qga2VlcCBtb3JlIHRoYW4gb25lLlxyXG5cdGRlbGV0ZSB0aGlzLmNvcHlcclxuXHJcblx0dmFyIGNsb25lID0gbmV3IF9QbGF5ZXIodGhpcy5pZCk7XHJcblxyXG5cdC8vTG9vcCB0aHJvdWdoIHByb3BlcnRpZXMgYW5kIGFzc2lnbiB0aGVtLlxyXG5cdGZvciAodmFyIGtleSBpbiB0aGlzKXtcclxuXHRcdGNsb25lW2tleV0gPSB0aGlzW2tleV07XHJcblx0fVxyXG5cdC8vRG8gbm90IGFkZCB0byByZWdpc3RyeS4gVGhpcyB3aWxsIGtlZXAgZHVwbGljYXRlcyBvdXQgb2YgcG9wdWxhdGlvbi5cclxuXHJcblx0Ly9EbyBhZGQgcmVmZXJlbmNlIHNvIHdlIGNhbiBmaW5kIGl0IGFnYWluLlxyXG5cdHRoaXMuY29weSA9IGNsb25lO1xyXG5cclxuXHRyZXR1cm4gY2xvbmU7XHJcbn07XHJcbiovXHJcblxyXG5cclxuLy9Bc3NpZ24gc3RyYXRlZ3kgdG8gcGxheWVyXHJcbl9QbGF5ZXIucHJvdG90eXBlLmFzc2lnbiA9IGZ1bmN0aW9uKHN0cmF0ZWd5LCAuLi5hcmdzKSB7XHJcblxyXG5cdC8vVE9ETzogdmVyaWZ5IHN0cmF0ZWd5IHR5cGVcclxuXHRpZiAocmVnaXN0cnkuc3RyYXRlZ2llc1tzdHJhdGVneV0pIHtcclxuXHRcdHRoaXMuc3RyYXRlZ3kgPSBuZXcgcmVnaXN0cnkuc3RyYXRlZ2llc1tzdHJhdGVneV0oLi4uYXJncyk7XHJcblx0XHR0aGlzLnN0cmF0ZWd5Ll9pZCA9IHN0cmF0ZWd5XHJcblx0XHR0aGlzLnN0cmF0ZWd5Ll9hcmdzID0gYXJnc1xyXG5cdH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJTdHJhdGVneSAnXCIgKyBzdHJhdGVneSArIFwiJyBpcyBub3QgZGVmaW5lZFwiKTtcclxufTtcclxuXHJcblxyXG4vL0NhbGwgc3RyYXRlZ3kgdG8gbWFrZSBhIGNob2ljZVxyXG5fUGxheWVyLnByb3RvdHlwZS5jaG9vc2UgPSBmdW5jdGlvbihvcHRpb25zLCBpbmZvcm1hdGlvbiA9IHt9KSB7IC8vVE9ETzogY2hlY2sgdGhhdCB0aGVyZSdzIGEgc3RyYXRlZ3kgYXNzaWduZWQgYmVmb3JlIHRyeWluZyB0byBwbGF5XHJcblx0dmFyIHBsYXllciA9IHRoaXM7XHJcblx0aWYgKHBsYXllci5zdHJhdGVneSkge1xyXG5cdFx0bGV0IHJlc3VsdCA9IHBsYXllci5zdHJhdGVneS5jaG9vc2Uob3B0aW9ucywgaW5mb3JtYXRpb24pXHJcblx0XHRpZiAocmVzdWx0KSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdC50b1N0cmluZygpKTtcclxuXHRcdC8vIElmIG5vIHJlc3BvbnNlLCBnaXZlIHdhcm5pbmdcclxuXHRcdGVsc2UgbG9nKFwid2FybmluZ1wiLCBcIk5vIHJlc3BvbnNlIGZyb20gcGxheWVyIFwiICsgcGxheWVyLmlkICsgXCIuIFVzaW5nIGRlZmF1bHQgb3B0aW9uLlwiKVxyXG5cdH1cclxuXHQvLyBJZiBubyBzdHJhdGVneSwgZ2l2ZSB3YXJuaW5nXHJcblx0ZWxzZVxyXG5cdFx0bG9nKFwid2FybmluZ1wiLCBcIk5vIHN0cmF0ZWd5IGFzc2lnbmVkIHRvIHBsYXllciBcIiArIHBsYXllci5pZCArIFwiLiBVc2luZyBkZWZhdWx0IG9wdGlvbi5cIik7XHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcclxufTtcclxuXHJcblxyXG4vL1Rha2VzIGEgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSgpKSBjb3B5IG9mIF9wbGF5ZXIuIFJldHVybnMgYSBjbGVhbmVkIHVwIHZlcnNpb25cclxuX1BsYXllci5wcm90b3R5cGUuaW5mb0NsZWFuID0gZnVuY3Rpb24oaW5mb09iamVjdCkge1xyXG5cdGRlbGV0ZSBpbmZvT2JqZWN0LmludGVyZmFjZTtcclxuXHRpbmZvT2JqZWN0LnN0cmF0ZWd5ID0gaW5mb09iamVjdC5zdHJhdGVneSA/IGluZm9PYmplY3Quc3RyYXRlZ3kuX2lkIDogbnVsbDtcclxuXHJcblx0cmV0dXJuIGluZm9PYmplY3Q7XHJcbn07XHJcblxyXG5cclxuLy9LaWxsIHBsYXllci4gVE9ETzogYWRkIHBsYXllciB0byBzb21lIHNvcnQgb2YgXCJkZWFkXCIgbGlzdCB0byBhdm9pZCBiZWluZyBwaWNrZWQgdG8gZG8gdGhpbmdzLlxyXG5fUGxheWVyLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5hbGl2ZSA9IGZhbHNlO1xyXG59O1xyXG5cclxuXHJcblxyXG4vL0NsYXNzIHRoYXQgaXMgdGhlIHJlZmVyZW5jZSBmb3IgdGhlIHVzZXIgdG8gaG9sZCBvbnRvXHJcbmZ1bmN0aW9uIHBsYXllcigpIHt9XHJcblxyXG5cclxuLy9Gcm9udGVuZCBmb3IgUGxheWVyXHJcbmZ1bmN0aW9uIFBsYXllcihwYXJhbWV0ZXJzID0ge30pIHtcclxuXHR2YXIgaWQgPSBpZEhhbmRsZXIocGFyYW1ldGVycy5pZCwgXCJwbGF5ZXJcIik7XHJcblxyXG5cdC8vQ3JlYXRlIGJhY2tlbmQgcGxheWVyIG9iamVjdFxyXG5cdHZhciBfcGxheWVyID0gbmV3IF9QbGF5ZXIoaWQsIHBhcmFtZXRlcnMpO1xyXG5cclxuXHJcblx0Ly9SZXR1cm4gdGhpcyByZWZlcmVuY2Ugb2JqZWN0IHRvIHRoZSB1c2VyXHJcblx0dmFyIHBsYXllckludGVyZmFjZSA9IG5ldyBwbGF5ZXIoKTsgLy9Qcm9iYWJseSBhZGQgZnVuY3Rpb25hbGl0eSBoZXJlXHJcblxyXG5cdC8vVGFnLWJhY2suIFN0b3JlIHRoZSBmcm9udC1lbmQgb2JqZWN0IGluIHRoZSBiYWNrLWVuZCBvYmplY3QsIGZvciByZXRyaWV2YWxcclxuXHRfcGxheWVyLmludGVyZmFjZSA9IHBsYXllckludGVyZmFjZTtcclxuXHJcblx0cGxheWVySW50ZXJmYWNlLmFsaXZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gcmVnaXN0cnkucGxheWVyc1tpZF0uYWxpdmU7XHJcblx0fVxyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2UuYXNzaWduID0gZnVuY3Rpb24oc3RyYXRlZ3ksIC4uLmFyZ3MpIHtcclxuXHRcdHJlZ2lzdHJ5LnBsYXllcnNbaWRdLmFzc2lnbihzdHJhdGVneSwgLi4uYXJncyk7XHJcblx0fTtcclxuXHJcblx0cGxheWVySW50ZXJmYWNlLmF2YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHJlZ2lzdHJ5LnBsYXllcnNbaWRdLmF2YWlsYWJsZVxyXG5cdH07XHJcblxyXG5cdHBsYXllckludGVyZmFjZS5idXN5ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZWdpc3RyeS5wbGF5ZXJzW2lkXS5hdmFpbGFibGUgPSBmYWxzZTtcclxuXHR9O1xyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2UuaGlzdG9yeSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBVc2VySGlzdG9yeShyZWdpc3RyeS5wbGF5ZXJzW2lkXS5oaXN0b3J5KTtcclxuXHR9O1xyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2UuaWQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGlkOyB9O1xyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2Uua2lsbCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmVnaXN0cnkucGxheWVyc1tpZF0ua2lsbCgpO1xyXG5cdH1cclxuXHJcblx0cGxheWVySW50ZXJmYWNlLnJlbGVhc2UgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJlZ2lzdHJ5LnBsYXllcnNbaWRdLmF2YWlsYWJsZSA9IHRydWU7XHJcblx0fTtcclxuXHJcblx0cGxheWVySW50ZXJmYWNlLnJlc2V0U2NvcmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJlZ2lzdHJ5LnBsYXllcnNbaWRdLnNjb3JlID0gMDtcclxuXHR9XHJcblxyXG5cdHBsYXllckludGVyZmFjZS5zY29yZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHJlZ2lzdHJ5LnBsYXllcnNbaWRdLnNjb3JlO1xyXG5cdH07XHJcblxyXG5cdHBsYXllckludGVyZmFjZS5zdHJhdGVneSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHJlZ2lzdHJ5LnBsYXllcnNbaWRdLnN0cmF0ZWd5Ll9pZDtcclxuXHR9O1xyXG5cclxuXHQvLyBQTFVHSU46IHJ1biBhZnRlciBwbGF5ZXIgY3JlYXRpb25cclxuXHRQbHVnaW5NYW5hZ2VyLnJ1bihcInBsYXllci1jcmVhdGVcIiwgX3BsYXllcilcclxuXHJcblx0cmV0dXJuIHBsYXllckludGVyZmFjZVxyXG59XHJcblxyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX1BsYXllciwgUGxheWVyIH07XHJcbiIsIi8qKlxyXG4gKlxyXG4gKiBAdHlwZSB7e319XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gQXN5bmNDdHgoY2FsbGJhY2spIHtcclxuXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XHJcblx0dGhpcy5zeW5jID0gdHJ1ZTtcclxufVxyXG5cclxuQXN5bmNDdHgucHJvdG90eXBlLmFzeW5jID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5zeW5jID0gZmFsc2U7XHJcblx0cmV0dXJuIHRoaXMuY2FsbGJhY2s7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBpcyBhbiBBUEkgbWVhbnQgdG8gYmUgdXNlZCBvbmx5IGZyb20gc3luY2hyb25vdXNcclxuICogY2FsbGJhY2tzIGludG8gYW4gYXN5bmNocm9ub3VzIGxpa2UgaG9vay5cclxuICpcclxuICogaXQgcmVwcmVzZW50IGNvbnRpbnVpdHkgZnJvbSB0aGUgXCJzeW5jKClcIiBvciBcIndhdGVyZmFsbCgpXCJcclxuICogcGx1Z2luIG1hbmFnZW1lbnRcclxuICovXHJcbkFzeW5jQ3R4LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGNhbGxiYWNrID0gdGhpcy5hc3luYygpO1xyXG5cdGNhbGxiYWNrKHRydWUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBc3luY0N0eDsiLCIvLyBTdG9sZW4gbGliZXJhbGx5IGFuZCBicmF6ZW5seSBmcm9tIFwicG9saXRlLXBsdWdpbi1tYW5hZ2VyXCIuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuY29uc3QgcGx1Z2luRGlyZWN0b3J5UGF0aCA9IFwiLi4vLi4vcGx1Z2lucy9cIlxyXG4vLyBIYWNrIHRvIGNvbXBpbGUgR2xvYiBmaWxlcyBmb3IgYnJvd3NlcmlmeS4gRG9uwrR0IGNhbGwgdGhpcyBmdW5jdGlvbiFcclxuZnVuY3Rpb24gJF9ET05PVENBTEwoKSB7XHJcblx0cmVxdWlyZSgnLi4vLi4vcGx1Z2lucy9iYWxhbmNlLXNoZWV0LWNvbXBsZXguanMnKTtyZXF1aXJlKCcuLi8uLi9wbHVnaW5zL2JhbGFuY2Utc2hlZXQuanMnKVxyXG59XHJcblxyXG4vKipcclxuICogUG9saXRlIFBsdWdpbiBNYW5hZ2VyXHJcbiAqIHJlZ2lzdGVyIGFuZCBydW4gaG9va3MgZ3JhbnRpbmcgZXh0ZW5kYWJpbGl0eVxyXG4gKlxyXG4gKi9cclxuXHJcblxyXG4vLyBHbG9iYWwgRGVwZW5kZW5jaWVzXHJcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyksXHJcblx0cGF0aCA9IHJlcXVpcmUoJ3BhdGgnKSxcclxuXHRhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyksXHJcblxyXG5cdC8vIExvY2FsIE1vZHVsZXNcclxuXHRBc3luY0N0eCA9IHJlcXVpcmUoJy4vYXN5bmMtY3R4JyksXHJcblx0V2F0ZXJmYWxsQ3R4ID0gcmVxdWlyZSgnLi93YXRlcmZhbGwtY3R4JyksXHJcblx0UGx1Z2luTmFtZUVycm9yID0gcmVxdWlyZSgnLi9wbHVnaW4tbmFtZS1lcnJvcicpLFxyXG5cdFBsdWdpbkNhbGxiYWNrRXJyb3IgPSByZXF1aXJlKCcuL3BsdWdpbi1jYWxsYmFjay1lcnJvcicpO1xyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG4vLyAtLS1bWyAgIEMgTyBOIFMgVCBSIFUgQyBUIE8gUiAgIEEgTiBEICAgTCBJIEYgRSBDIFkgQyBMIEUgICBVIFQgSSBMIEkgVCBJIEUgUyAgIF1dLS0gLy9cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblxyXG52YXIgUGx1Z2luTWFuYWdlciA9IHt9LFxyXG5cdHBhY2thZ2VzID0gW10sXHJcblx0cGFja2FnZU5hbWVzID0gW10sXHJcblx0aG9va3MgPSB7fSxcclxuXHRza2lwUHJvcHMgPSBbJ21vZHVsZScsICduYW1lJywgJ3ByaW9yaXR5JywgJ2FjdGl2ZScsICdpbml0JywgJ3JlcXVpcmUnLCAnc3RvcCcsICdwdWJsaWMnLCAnc2V0dGluZ3MnXTtcclxuXHJcblxyXG5cclxuUGx1Z2luTWFuYWdlci5yZXNldCA9IGZ1bmN0aW9uKCkge1xyXG5cdHBhY2thZ2VzID0gW107XHJcblx0cGFja2FnZU5hbWVzID0gW107XHJcblx0aG9va3MgPSB7fTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBcHBseSBwYWNrYWdlIHNvcnRpbmcsXHJcbiAqIHJlZ2lzdGVyIHBhY2thZ2VzIGludG8gaG9va3MsXHJcbiAqIHJ1biBwYWNrYWdlcyBpbml0KCkgbWV0aG9kXHJcbiAqL1xyXG5QbHVnaW5NYW5hZ2VyLnN0YXJ0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHJcblx0dmFyIHNlbGYgPSB0aGlzLFxyXG5cdFx0aW5pdHMgPSBbXTtcclxuXHJcblx0Ly8gc29ydCBieSBwcmlvcml0aWVzXHJcblx0cGFja2FnZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XHJcblx0XHRyZXR1cm4gYS5wcmlvcml0eSA+IGIucHJpb3JpdHk7XHJcblx0fSk7XHJcblxyXG5cdC8vIHJlZ2lzdGVyIGluaXQgJiBob29rc1xyXG5cdC8vIGhvb2tzIGFyZSBhbGwgZnVuY3Rpb25zIHdobyBhcmUgbm90IHNwZWNpYWwgcHJvcGVydGllc1xyXG5cdC8vIGlkZW50aWZpZWQgYnkgXCJza2lwUHJvcHNcIiBsaXN0XHJcblx0cGFja2FnZXMuZm9yRWFjaChmdW5jdGlvbihwa2cpIHtcclxuXHRcdGlmIChwa2cuaW5pdCkge1xyXG5cdFx0XHRpbml0cy5wdXNoKHBrZy5pbml0KTtcclxuXHRcdH1cclxuXHRcdGZvciAodmFyIHByb3AgaW4gcGtnKSB7XHJcblx0XHRcdGlmIChza2lwUHJvcHMuaW5kZXhPZihwcm9wKSA9PT0gLTEgJiYgdHlwZW9mIHBrZ1twcm9wXSA9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0UGx1Z2luTWFuYWdlci5yZWdpc3Rlckhvb2socHJvcCwgcGtnW3Byb3BdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvLyBydW4gYWxsIHBhY2thZ2UuaW5pdCgpIG1ldGhvZCBpbiBzZXJpZXMhXHJcblx0aWYgKGluaXRzLmxlbmd0aCkge1xyXG5cdFx0YXN5bmMuZWFjaFNlcmllcyhpbml0cywgZnVuY3Rpb24oZm4sIGRvbmUpIHtcclxuXHJcblx0XHRcdHZhciBjb250ZXh0ID0gbmV3IEFzeW5jQ3R4KGRvbmUpLFxyXG5cdFx0XHRcdHJlc3VsdCA9IGZuLmFwcGx5KGNvbnRleHQpO1xyXG5cclxuXHRcdFx0Ly8gc3luYyBmYWxzZSBzdG9wIGluaXRpYWxpemF0aW9uIGN5Y2xlIVxyXG5cdFx0XHRpZiAoY29udGV4dC5zeW5jKSB7XHJcblx0XHRcdFx0aWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoc2VsZik7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGRvbmUocmVzdWx0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHR9LCBjYWxsYmFjay5iaW5kKHRoaXMpKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Y2FsbGJhY2suY2FsbChzZWxmKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuXHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcbi8vIC0tLVtbICAgSCBPIE8gSyBTICAgQSBQIEkgICBdXS0tLSAvL1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHJcblBsdWdpbk1hbmFnZXIucmVnaXN0ZXJIb29rID0gZnVuY3Rpb24oaG9va05hbWUsIGhvb2tGbiwgaG9va1ByaW9yaXR5ID0gMTAwKSB7XHJcblx0aG9va0ZuLnByaW9yaXR5ID0gaG9va1ByaW9yaXR5O1xyXG5cclxuXHRpZiAoIWhvb2tzW2hvb2tOYW1lXSkge1xyXG5cdFx0aG9va3NbaG9va05hbWVdID0gW107XHJcblx0fVxyXG5cclxuXHRob29rc1tob29rTmFtZV0ucHVzaChob29rRm4pO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuXHJcblBsdWdpbk1hbmFnZXIuaXNFbXB0eSA9IGZ1bmN0aW9uKGhvb2tOYW1lKSB7XHJcblx0aWYgKGhvb2tzW2hvb2tOYW1lXSAmJiBob29rc1tob29rTmFtZV0ubGVuZ3RoKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJ1biByZWdpc3RlcmVkIGhvb2sgY2FsbGJhY2tzIGluIHNlcmllc1xyXG4gKiAoaXQgc3VwcG9ydHMgYXN5bmNocm9ub3VzIGNhbGxiYWNrcylcclxuICovXHJcblBsdWdpbk1hbmFnZXIucnVuID0gZnVuY3Rpb24oaG9va05hbWUsIC4uLmFyZ3MpIHtcclxuXHJcblx0Ly8gVXNlIHRoZSBydW5XaXRoQ2FsbGJhY2sgYnV0IHdpdGggYmxhbmsgY2FsbGJhY2suXHJcblx0UGx1Z2luTWFuYWdlci5ydW5XaXRoQ2FsbGJhY2soaG9va05hbWUsIC4uLmFyZ3MsIGZ1bmN0aW9uKCkge30pXHJcbn07XHJcblxyXG4vLyBTYW1lIGFzIGFib3ZlLCBidXQgdXNlIGxhc3QgYXJndW1lbnQgYXMgY2FsbGJhY2tcclxuUGx1Z2luTWFuYWdlci5ydW5XaXRoQ2FsbGJhY2sgPSBmdW5jdGlvbihob29rTmFtZSwgLi4uYXJncykge1xyXG5cclxuXHQvLyBjb2xsZWN0IGhvb2tOYW1lIHByb3BlcnR5XHJcblx0aWYgKCFob29rTmFtZSkgdGhyb3cgbmV3IFBsdWdpbk5hbWVFcnJvcignbWlzc2luZyBwbHVnaW4gbmFtZSEnKTtcclxuXHJcblx0Ly8gb2J0YWluIGFzeW5jIGNhbGxiYWNrXHJcblx0aWYgKCFhcmdzLmxlbmd0aCB8fCB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdICE9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHR0aHJvdyBuZXcgUGx1Z2luQ2FsbGJhY2tFcnJvcignWycgKyBob29rTmFtZSArICddIG1pc3NpbmcgY2FsbGJhY2sgZm9yIGFzeW5jIHBsdWdpbiEnKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcclxuXHR9XHJcblxyXG5cclxuXHQvLyBjaGVjayBmb3Igc29tZSBjYWxsYmFja3MgZXhpc3RhbmNlXHJcblx0Ly8gWz8/P10gbWF5IGdpdmUgb3V0IGFuIGV4Y2VwdGlvbiB3aGVuIG5vIGNhbGxiYWNrcyB3ZXJlIGZvdW5kIVxyXG5cdGlmICghaG9va3NbaG9va05hbWVdIHx8ICFob29rc1tob29rTmFtZV0ubGVuZ3RoKSB7XHJcblx0XHRjYWxsYmFjayhmYWxzZSk7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvLyBTb3J0IGhvb2tzIGJ5IHByaW9yaXR5XHJcblx0aG9va3NbaG9va05hbWVdLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0cmV0dXJuIGEucHJpb3JpdHkgPiBiLnByaW9yaXR5XHJcblx0fSlcclxuXHJcblx0Ly8gcnVuIGFzeW5jIHF1ZXF1ZVxyXG5cdC8vIE5PVEU6IGEgc3RlcCBmdW5jdGlvbiBzaG91bGQgc3RvcCB0aGUgcXVlcXVlIGJ5IGRvbmUodHJ1ZSlcclxuXHRhc3luYy5lYWNoU2VyaWVzKGhvb2tzW2hvb2tOYW1lXSwgZnVuY3Rpb24oZm4sIGRvbmUpIHtcclxuXHRcdHZhciBjb250ZXh0ID0gbmV3IEFzeW5jQ3R4KGRvbmUpLFxyXG5cdFx0XHRyZXN1bHQgPSBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuXHJcblx0XHRpZiAoY29udGV4dC5zeW5jKSB7XHJcblx0XHRcdGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XHJcblx0XHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRkb25lKHJlc3VsdCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LCBjYWxsYmFjayk7XHJcblxyXG5cdHJldHVybiB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogUnVuIHJlZ2lzdGVyZWQgaG9vayBjYWxsYmFja3MgaW4gcGFyYWxsZWxcclxuICogKGl0IHN1cHBvcnRzIGFzeW5jaHJvbm91cyBjYWxsYmFja3MpXHJcbiAqIEBwYXJhbSBob29rTmFtZVxyXG4gKi9cclxuXHJcblBsdWdpbk1hbmFnZXIucGFyYWxsZWwgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dmFyIGhvb2tOYW1lID0gJycsXHJcblx0XHRjYWxsYmFjayA9IG51bGwsXHJcblx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuXHJcblx0Ly8gY29sbGVjdCBob29rTmFtZSBwcm9wZXJ0eVxyXG5cdGlmICghYXJncy5sZW5ndGgpIHtcclxuXHRcdHRocm93IG5ldyBQbHVnaW5OYW1lRXJyb3IoJ21pc3NpbmcgcGx1Z2luIG5hbWUhJyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGhvb2tOYW1lID0gYXJncy5zaGlmdCgpO1xyXG5cdH1cclxuXHJcblx0Ly8gb2J0YWluIGFzeW5jIGNhbGxiYWNrXHJcblx0aWYgKCFhcmdzLmxlbmd0aCB8fCB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdICE9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHR0aHJvdyBuZXcgUGx1Z2luQ2FsbGJhY2tFcnJvcignWycgKyBob29rTmFtZSArICddIG1pc3NpbmcgY2FsbGJhY2sgZm9yIGFzeW5jIHBsdWdpbiEnKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Y2FsbGJhY2sgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XHJcblx0fVxyXG5cclxuXHQvLyBjaGVjayBmb3Igc29tZSBjYWxsYmFja3MgZXhpc3RhbmNlXHJcblx0Ly8gWz8/P10gbWF5IGdpdmUgb3V0IGFuIGV4Y2VwdGlvbiB3aGVuIG5vIGNhbGxiYWNrcyB3ZXJlIGZvdW5kIVxyXG5cdGlmICghaG9va3NbaG9va05hbWVdIHx8ICFob29rc1tob29rTmFtZV0ubGVuZ3RoKSB7XHJcblx0XHRjYWxsYmFjayhmYWxzZSk7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvLyBydW4gYXN5bmMgaW4gcGFyYWxsZWxcclxuXHQvLyBOT1RFOiBhIHN0ZXAgZnVuY3Rpb24gc2hvdWxkIHN0b3AgdGhlIHF1ZXF1ZSBieSBkb25lKHRydWUpXHJcblx0YXN5bmMuZWFjaChob29rc1tob29rTmFtZV0sIGZ1bmN0aW9uKGZuLCBkb25lKSB7XHJcblx0XHR2YXIgY29udGV4dCA9IG5ldyBBc3luY0N0eChkb25lKSxcclxuXHRcdFx0cmVzdWx0ID0gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblxyXG5cdFx0Ly8gaGFuZGxlIHN5bmMgY2FsbGJhY2tzXHJcblx0XHRpZiAoY29udGV4dC5zeW5jKSB7XHJcblx0XHRcdGRvbmUocmVzdWx0KTtcclxuXHRcdH1cclxuXHR9LCBjYWxsYmFjayk7XHJcblxyXG5cdHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBXQVRFUkZBTExcclxuICogUnVuIGEgaG9vayBhcyBhIG5vcm1hbCBmdW5jdGlvbiBpbiBhIGZ1bGx5IHN5bmNyb25vdXMgbW9kZVxyXG4gKiBFYWNoIGhvb2tGbiBzaG91bGQgcmV0dXJuIGEgdmFsdWUgd2hvJ3MgZm9yd2FyZCBhcyBmaXJzdCBhcmd1bWVudCBmb3IgdGhlIG5leHQgb25lXHJcbiAqIGxhc3QgaG9va0ZuIHJldHVybiB2YWx1ZSBpcyB0aGUgZmluYWwgb3V0cHV0XHJcbiAqL1xyXG5QbHVnaW5NYW5hZ2VyLndhdGVyZmFsbCA9IGZ1bmN0aW9uKGhvb2tOYW1lKSB7XHJcblxyXG5cdGlmICghaG9va05hbWUpIHtcclxuXHRcdHRocm93IG5ldyBQbHVnaW5OYW1lRXJyb3IoJ21pc3NpbmcgcGx1Z2luIG5hbWUhJyk7XHJcblx0fVxyXG5cclxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcblx0YXJncy5zaGlmdCgpO1xyXG5cclxuXHRpZiAoaG9va3NbaG9va05hbWVdKSB7XHJcblx0XHQvLyB1c2Uga25vd24gZXhjZXB0aW9uIHRvIGV4aXQgZm9yRWFjaCBjeWNsZSBpbXBsZW1lbnRpbmcgYSBzdG9wcGFibGUgd2F0ZWZhbGxcclxuXHRcdC8vIChodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI2NDEzNDcvaG93LXRvLXNob3J0LWNpcmN1aXQtYXJyYXktZm9yZWFjaC1saWtlLWNhbGxpbmctYnJlYWs/YW5zd2VydGFiPXZvdGVzI3RhYi10b3ApXHJcblx0XHR2YXIgV2F0ZXJmYWxsQnJlYWtFeGNlcHRpb24gPSB7fTtcclxuXHRcdHRyeSB7XHJcblx0XHRcdGhvb2tzW2hvb2tOYW1lXS5mb3JFYWNoKGZ1bmN0aW9uKGZuKSB7XHJcblx0XHRcdFx0dmFyIGNvbnRleHQgPSBuZXcgV2F0ZXJmYWxsQ3R4KCksXHJcblx0XHRcdFx0XHRyZXN1bHQgPSBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuXHJcblx0XHRcdFx0aWYgKGFyZ3MubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRhcmdzWzBdID0gcmVzdWx0O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGNvbnRleHQuc3RvcHBlZCkge1xyXG5cdFx0XHRcdFx0dGhyb3cgV2F0ZXJmYWxsQnJlYWtFeGNlcHRpb247XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSk7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdGlmIChlICE9PSBXYXRlcmZhbGxCcmVha0V4Y2VwdGlvbikgdGhyb3cgZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGlmIChhcmdzLmxlbmd0aCkge1xyXG5cdFx0cmV0dXJuIGFyZ3NbMF07XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuLy8gLS0tW1sgICBQIEEgQyBLIEEgRyBFIFMgICBBIFAgSSAgIF1dLS0tIC8vXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG5cclxuZnVuY3Rpb24gZ2V0UGFja2FnZUJ5TmFtZShuYW1lKSB7XHJcblx0dmFyIGxpc3QgPSBwYWNrYWdlcy5maWx0ZXIoZnVuY3Rpb24ocGtnKSB7IHJldHVybiAocGtnLm5hbWUgPT09IG5hbWUpIH0pXHJcblx0aWYgKGxpc3QubGVuZ3RoID09IDEpIHJldHVybiBsaXN0WzBdXHJcblx0ZWxzZSByZXR1cm4gbGlzdDtcclxufVxyXG5cclxuLy8gUGFja2FnZSBjbGFzc1xyXG5mdW5jdGlvbiBQYWNrYWdlKG1vZHVsZSwgbmFtZSA9IG51bGwsIGNvbnRleHQgPSBudWxsKSB7XHJcblx0Ly8gQmFzaWMgYXNzaWdubWVudCBhbmQgZGVmYXVsdCB2YWx1ZXNcclxuXHRPYmplY3QuYXNzaWduKHRoaXMsIHtcclxuXHRcdG1vZHVsZSxcclxuXHRcdG5hbWUsXHJcblx0XHRwcmlvcml0eTogMTAwLFxyXG5cdFx0YWN0aXZlOiBmYWxzZSxcclxuXHRcdGluaXQ6IGZ1bmN0aW9uKCkge30sXHJcblx0XHRyZXF1aXJlOiBmdW5jdGlvbigpIHt9LFxyXG5cdFx0c3RvcDogZnVuY3Rpb24oKSB7fSxcclxuXHRcdHNldHRpbmdzOiBmdW5jdGlvbigpIHt9LFxyXG5cdFx0cHVibGljOiB7fVxyXG5cdH0pXHJcblx0Ly8gUGFja2FnZS1kZWZpbmVkIHZhbHVlcyBhbmQgaG9va3NcclxuXHRPYmplY3QuYXNzaWduKHRoaXMsIG1vZHVsZShjb250ZXh0IHx8IHt9KSlcclxuXHJcblx0Ly8gYWRkIHRvIHJlZ2lzdHJ5XHJcblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgdGhlIHNhbWUgbW9kdWxlIGJlaW5nIGxvYWRlZCB0d2ljZSwgb3IgZGlmZmVyZW50IG1vZHVsZXMgd2l0aCB0aGUgc2FtZSBuYW1lXHJcblx0aWYgKHBhY2thZ2VOYW1lcy5pbmNsdWRlcyh0aGlzLm5hbWUpKSB7XHJcblx0XHRpZiAodGhpcy5tb2R1bGUgPT09IGdldFBhY2thZ2VCeU5hbWUodGhpcy5uYW1lKS5tb2R1bGUpIHtcclxuXHRcdFx0Ly8gU2FtZSBtb2R1bGUuIERvIG5vdGhpbmdcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIERpZmZlcmVudCBtb2R1bGVzIHdpdGggc2FtZSBuYW1lLCBoYW5kbGUgbmFtZSBjb25mbGljdC5cclxuXHRcdFx0Ly9UT0RPOiBmaWd1cmUgb3V0IGhvdyB0byBoYW5kbGUgbmFtZSBjb25mbGljdC5cclxuXHRcdH1cclxuXHR9XHJcblx0Ly8gTm8gbmFtZSBjb25mbGljdCwgYWRkIHRvIHJlZ2lzdHJ5XHJcblx0ZWxzZSB7XHJcblx0XHRwYWNrYWdlcy5wdXNoKHRoaXMpO1xyXG5cdFx0cGFja2FnZU5hbWVzLnB1c2godGhpcy5uYW1lKVxyXG5cdH1cclxufVxyXG5cclxuUGFja2FnZS5wcm90b3R5cGUucmVnaXN0ZXJIb29rcyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBwa2cgPSB0aGlzO1xyXG5cdGZvciAodmFyIHByb3AgaW4gcGtnKSB7XHJcblx0XHRpZiAoc2tpcFByb3BzLmluZGV4T2YocHJvcCkgPT09IC0xICYmIHR5cGVvZiBwa2dbcHJvcF0gPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRQbHVnaW5NYW5hZ2VyLnJlZ2lzdGVySG9vayhwcm9wLCBwa2dbcHJvcF0pO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gQ3JlYXRlIGludGVyZmFjZSBmb3IgdXNlciB0byBpbnRlcmFjdCB3aXRoIHBhY2thZ2UuXHJcbmZ1bmN0aW9uIFBhY2thZ2VJbnRlcmZhY2UocGtnKSB7XHJcblxyXG5cdC8vIE1lcmdlIGFueSBwdWJsaWMgaXRlbXMgc3BlY2lmaWVkIGJ5IHRoZSBwYWNrYWdlIHdpdGggdGhpcyBpbnRlcmZhY2UgZm9ybWF0XHJcblx0cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHBrZy5wdWJsaWMsIHtcclxuXHRcdG5hbWU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gcGtnLm5hbWUgfSxcclxuXHRcdHByaW9yaXR5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHBrZy5wcmlvcml0eSB9LFxyXG5cdFx0YWN0aXZlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHBrZy5hY3RpdmUgfSxcclxuXHJcblx0XHRpbml0OiBmdW5jdGlvbiguLi5hcmdzKSB7XHJcblx0XHRcdHBrZy5pbml0KC4uLmFyZ3MpO1xyXG5cdFx0XHRwa2cucmVnaXN0ZXJIb29rcygpO1xyXG5cdFx0XHRwa2cuYWN0aXZlID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24odGhpcywgcGtnLnB1YmxpY0lmQWN0aXZlKTtcclxuXHRcdH0sXHJcblx0XHRyZXF1aXJlOiBmdW5jdGlvbiguLi5hcmdzKSB7XHJcblx0XHRcdGlmIChwa2cuYWN0aXZlKSBwa2cucmVxdWlyZSguLi5hcmdzKTtcclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0cGtnLmluaXQoLi4uYXJncyk7XHJcblx0XHRcdFx0cGtnLnJlZ2lzdGVySG9va3MoKTtcclxuXHRcdFx0XHRPYmplY3QuYXNzaWduKHRoaXMsIHBrZy5wdWJsaWNJZkFjdGl2ZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cGtnLmFjdGl2ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblx0XHRzdG9wOiBmdW5jdGlvbiguLi5hcmdzKSB7XHJcblx0XHRcdGlmIChwa2cuYWN0aXZlKSBwa2cuc3RvcCguLi5hcmdzKTtcclxuXHRcdFx0cGtnLmFjdGl2ZSA9IGZhbHNlO1xyXG5cdFx0fSxcclxuXHRcdHNldHRpbmdzOiBmdW5jdGlvbiguLi5hcmdzKSB7XHJcblx0XHRcdHJldHVybiBwa2cuc2V0dGluZ3MoLi4uYXJncyk7XHJcblx0XHR9XHJcblxyXG5cdH0sIHBrZy5hY3RpdmUgPyBwa2cucHVibGljSWZBY3RpdmUgOiBudWxsKTtcclxufVxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIExvYWQgYSBwbHVnaW4gcGFja2FnZSBieSBmb2xkZXIgcGF0aFxyXG4gKiBAcGFyYW0gc291cmNlRm9sZGVyXHJcbiAqL1xyXG5QbHVnaW5NYW5hZ2VyLnBhY2thZ2UgPSBmdW5jdGlvbihzb3VyY2UsIGNvbnRleHQpIHtcclxuXHRpZiAocGFja2FnZU5hbWVzLmluY2x1ZGVzKHNvdXJjZSkpIHtcclxuXHRcdC8vIEFscmVhZHkgbG9hZGVkIG1vZHVsZSwganVzdCByZXR1cm4gaXRcclxuXHRcdHJldHVybiBQYWNrYWdlSW50ZXJmYWNlKGdldFBhY2thZ2VCeU5hbWUoc291cmNlKSlcclxuXHR9IGVsc2Uge1xyXG5cdFx0dmFyIG5hbWUgPSBwYXRoLmJhc2VuYW1lKHNvdXJjZSksXHJcblx0XHRcdG1vZHVsZSA9IHJlcXVpcmUocGx1Z2luRGlyZWN0b3J5UGF0aCArIHNvdXJjZSArICcuanMnKVxyXG5cclxuXHRcdC8vIG9idGFpbiBwYWNrYWdlIGluZm9ybWF0aW9ucyBhbmQgYXBwbHkgc29tZSBkZWZhdWx0IHZhbHVlc1xyXG5cdFx0dmFyIHBrZyA9IG5ldyBQYWNrYWdlKG1vZHVsZSwgbmFtZSwgY29udGV4dClcclxuXHRcdHJldHVybiBQYWNrYWdlSW50ZXJmYWNlKHBrZylcclxuXHR9XHJcbn1cclxuXHJcbi8qXHJcblx0XHRcdGxvYWQ6IGZ1bmN0aW9uKGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7fSwgLi4uaW5pdEFyZ3MpIHtcclxuXHRcdFx0XHR2YXIgc2VsZiA9IHBtLFxyXG5cdFx0XHRcdFx0aW5pdHMgPSBbXSxcclxuXHJcblxyXG5cdFx0XHRcdFx0Ly8gcmVnaXN0ZXIgaW5pdCAmIGhvb2tzXHJcblx0XHRcdFx0XHQvLyBob29rcyBhcmUgYWxsIGZ1bmN0aW9ucyB3aG8gYXJlIG5vdCBzcGVjaWFsIHByb3BlcnRpZXNcclxuXHRcdFx0XHRcdC8vIGlkZW50aWZpZWQgYnkgXCJza2lwUHJvcHNcIiBsaXN0XHJcblxyXG5cdFx0XHRcdFx0aWYgKHBrZy5pbml0KSB7XHJcblx0XHRcdFx0XHRcdGluaXRzLnB1c2gocGtnLmluaXQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdFx0Ly8gcnVuIGFsbCBwYWNrYWdlLmluaXQoKSBtZXRob2QgaW4gc2VyaWVzISAvL0VESVQ6IHdpbGwgb25seSBiZSB0aGUgb25lXHJcblx0XHRcdFx0aWYgKGluaXRzLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0YXN5bmMuZWFjaFNlcmllcyhpbml0cywgZnVuY3Rpb24oZm4sIGRvbmUpIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBjb250ZXh0ID0gbmV3IEFzeW5jQ3R4KGRvbmUpLFxyXG5cdFx0XHRcdFx0XHRcdHJlc3VsdCA9IGZuLmFwcGx5KGNvbnRleHQsIGluaXRBcmdzKTtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHN5bmMgZmFsc2Ugc3RvcCBpbml0aWFsaXphdGlvbiBjeWNsZSFcclxuXHRcdFx0XHRcdFx0aWYgKGNvbnRleHQuc3luYykge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHNlbGYpO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRkb25lKHJlc3VsdCk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSwgY2FsbGJhY2suYmluZChzZWxmKSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoc2VsZik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gc2VsZjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblx0fTtcclxuKi9cclxuXHJcbi8qKiBUT0RPOiB0aGlzIGRvZXNuJ3Qgd29yayByaWdodCBub3dcclxuICogTG9hZCBhbGwgcGFja2FnZXMgZnJvbSBhIGdpdmVuIGZvbGRlciBwYXRoXHJcbiAqIChzeW5jcm9ub3VzKVxyXG4gKi9cclxuUGx1Z2luTWFuYWdlci5yZWdpc3Rlck1hbnkgPSBmdW5jdGlvbihzb3VyY2VGb2xkZXIsIGNvbnRleHQpIHtcclxuXHR2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG5cdGlmIChmcy5leGlzdHNTeW5jKHNvdXJjZUZvbGRlcikpIHtcclxuXHRcdGZzLnJlYWRkaXJTeW5jKHNvdXJjZUZvbGRlcikuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRcdHZhciBpdGVtUGF0aCA9IHNvdXJjZUZvbGRlciArICcvJyArIGl0ZW0sXHJcblx0XHRcdFx0aXRlbVN0YXQgPSBmcy5sc3RhdFN5bmMoaXRlbVBhdGgpO1xyXG5cclxuXHRcdFx0aWYgKGl0ZW1TdGF0LmlzRGlyZWN0b3J5KCkpIHtcclxuXHRcdFx0XHRzZWxmLmxvYWRQYWNrYWdlKGl0ZW1QYXRoLCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGx1Z2luTWFuYWdlclxyXG4iLCJcclxuZnVuY3Rpb24gUGx1Z2luQ2FsbGJhY2tFcnJvcihtZXNzYWdlKSB7XHJcblx0dGhpcy5uYW1lID0gXCJQbHVnaW5DYWxsYmFja0Vycm9yXCI7XHJcblx0dGhpcy5tZXNzYWdlID0gKG1lc3NhZ2UgfHwgXCJcIik7XHJcbn1cclxuXHJcblxyXG5QbHVnaW5DYWxsYmFja0Vycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xyXG5QbHVnaW5DYWxsYmFja0Vycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsdWdpbkNhbGxiYWNrRXJyb3I7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBsdWdpbkNhbGxiYWNrRXJyb3I7IiwiXHJcbmZ1bmN0aW9uIFBsdWdpbk5hbWVFcnJvcihtZXNzYWdlKSB7XHJcblx0dGhpcy5uYW1lID0gXCJQbHVnaW5OYW1lRXJyb3JcIjtcclxuXHR0aGlzLm1lc3NhZ2UgPSAobWVzc2FnZSB8fCBcIlwiKTtcclxufVxyXG5cclxuXHJcblBsdWdpbk5hbWVFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcclxuUGx1Z2luTmFtZUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsdWdpbk5hbWVFcnJvcjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUGx1Z2luTmFtZUVycm9yOyIsIi8qKlxyXG4gKlxyXG4gKiBAdHlwZSB7e319XHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gV2F0ZXJmYWxsQ3R4KCkge1xyXG5cdHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xyXG59XHJcblxyXG5XYXRlcmZhbGxDdHgucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLnN0b3BwZWQgPSB0cnVlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXYXRlcmZhbGxDdHg7IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZShcIi4vbG9nZ2VyXCIpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlzRnVuY3Rpb24sIGlzT2JqZWN0IH0gPSByZXF1aXJlKFwiLi9oZWxwZXItZnVuY3Rpb25zXCIpKFwiZ2VuZXJhbFwiKTtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZShcIi4vc3RhdGVcIik7XHJcblxyXG52YXIgeyBfUGxheWVyIH0gPSByZXF1aXJlKFwiLi9wbGF5ZXJcIik7XHJcblxyXG4vL0NsYXNzIFBsYXllckxpc3QgaXMgYSBsaXN0IG9mIHBsYXllcnMgd2hpY2ggaW5jbHVkZXMgc29tZSBleHRyYSBmdW5jdGlvbmFsaXR5LiBVc2VyUGxheWVyTGlzdCB0YWtlcyBhIHBsYXllckxpc3QgYW5kXHJcbi8vc2FuaXRpemVzIGl0IGZvciB0aGUgdXNlciAoaWUgcmV0dXJucyAuaW50ZXJmYWNlIGZvciBlYWNoIHBsYXllcikuXHJcblxyXG5mdW5jdGlvbiBQbGF5ZXJMaXN0KC4uLmFyZ3MpIHtcclxuXHRpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkgYXJncyA9IGFyZ3NbMF0uc2xpY2UoMCk7XHJcblx0aWYgKGFyZ3MgPT0gXCJhbGxcIikgcmV0dXJuIGdhbWVQb3B1bGF0aW9uKCk7XHJcblxyXG5cdC8vIFdlJ2xsIG5lZWQgdG8gcmV0YWluIHRoZSBvcmlnaW5hbCBhcmd1bWVudHMgaW4gb3JkZXIgdG8gY3JlYXRlIHRoZSBnZW5lcmF0b3JcclxuXHR2YXIgb3JpZ2luYWxBcmdzID0gW11cclxuXHJcblx0Ly8gTG9vcCBvdmVyIHRoZSBhcmd1bWVudHMsIHNhdmUgdGhlIG9yaWdpbmFscywgcGFyc2UgdGhlbSB0byBfcGxheWVyc1xyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRvcmlnaW5hbEFyZ3MucHVzaChhcmdzW2ldKTtcclxuXHRcdGlmIChpc0Z1bmN0aW9uKGFyZ3NbaV0uaWQpKSBhcmdzW2ldID0gcmVnaXN0cnkucGxheWVyc1thcmdzW2ldLmlkKCldO1xyXG5cdFx0ZWxzZSBpZiAodHlwZW9mIGFyZ3NbaV0gPT09ICdzdHJpbmcnKSBhcmdzW2ldID0gcmVnaXN0cnkucGxheWVyc1thcmdzW2ldXVxyXG5cdH1cclxuXHJcblx0T2JqZWN0LnNldFByb3RvdHlwZU9mKGFyZ3MsIFBsYXllckxpc3QucHJvdG90eXBlKTtcclxuXHJcblx0Ly8gcmV0dXJucyB0aGUgc2FtZSBwbGF5ZXJsaXN0LCBidXQgdXBkYXRlZCwgdXNpbmcgdGhlIG9yaWdpbmFsIGFyZ3MuXHJcblx0YXJncy5nZW5lcmF0b3IgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBuZXcgUGxheWVyTGlzdChvcmlnaW5hbEFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdHJldHVybiBhcmdzO1xyXG59XHJcblxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXJyYXkucHJvdG90eXBlKTtcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbGF5ZXJMaXN0O1xyXG5cclxuXHJcbi8vIEFzc2lnbiBhIHN0cmF0ZWd5IGVuIG1hc3NlXHJcblBsYXllckxpc3QucHJvdG90eXBlLmFzc2lnbiA9IGZ1bmN0aW9uKHN0cmF0ZWd5TmFtZSkge1xyXG5cdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHBsYXllci5hc3NpZ24oc3RyYXRlZ3lOYW1lKVxyXG5cdH0pXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcblxyXG4vL1JldHVybiBhIFBsYXllckxpc3QgbWludXMgdGhlIHNwZWNpZmllZCBwbGF5ZXJzLlxyXG4vL0FyZ3VtZW50IGNhbiBiZSBfcGxheWVyLCBpbnRlcmZhY2UsIG9yIGEgcGxheWVyJ3MgaWQuXHJcblBsYXllckxpc3QucHJvdG90eXBlLmV4Y2x1ZGUgPSBmdW5jdGlvbihwbGF5ZXJBcmcpIHtcclxuXHRpZiAoQXJyYXkuaXNBcnJheShwbGF5ZXJBcmcpKVxyXG5cdFx0cmV0dXJuIHBsYXllckFyZy5yZWR1Y2UoZnVuY3Rpb24ocnVubmluZywgaXRlbSkge1xyXG5cdFx0XHRyZXR1cm4gcnVubmluZy5leGNsdWRlKGl0ZW0pO1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdHJldHVybiBuZXcgUGxheWVyTGlzdChcclxuXHRcdHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRpZiAoXHJcblx0XHRcdFx0cGxheWVyQXJnID09PSBwbGF5ZXIgfHxcclxuXHRcdFx0XHRwbGF5ZXJBcmcgPT0gcGxheWVyLmludGVyZmFjZSB8fFxyXG5cdFx0XHRcdHBsYXllckFyZyA9PSBwbGF5ZXIuaWQgfHxcclxuXHRcdFx0XHQoaXNPYmplY3QocGxheWVyQXJnKSAmJiBwbGF5ZXJBcmcuaWQgPT0gcGxheWVyLmlkKVxyXG5cdFx0XHQpXHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRlbHNlIHJldHVybiB0cnVlO1xyXG5cdFx0fSlcclxuXHQpO1xyXG59O1xyXG5cclxuXHJcbi8vIFBsYWNlaG9sZGVyIGZvciBnZW5lcmF0b3IgbWV0aG9kLlxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5nZW5lcmF0b3IgPSBmdW5jdGlvbigpIHtcclxuXHQvLyBUaGlzIHdpbGwgZ2V0IHNoYWRvd2VkIHdoZW4gdGhlIGNvbnN0cnVjdG9yIGlzIGNhbGxlZCwgYnV0IGl0IG5lZWRzIHRvIGJlIGhlcmUgc28gdGhhdCB0aGVcclxuXHQvLyBVc2VyUGxheWVyTGlzdCBhbmQgSW5mb1BsYXllckxpc3QgY29uc3RydWN0b3JzIGNhbiBzZWUgaXQuXHJcbn1cclxuXHJcblxyXG4vL0NyZWF0ZSBhbiBJbmZvUGxheWVyTGlzdCBvdXQgb2YgdGhpcyBQbGF5ZXJMaXN0LiBVc2VmdWwgZm9yIGdldHRpbmcgc3VtbWFyeSB2aWV3LlxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBJbmZvUGxheWVyTGlzdCh0aGlzKTtcclxufTtcclxuXHJcblxyXG4vL1JldHVybiBhcnJheSBvZiBpZHMgb2YgZWFjaCBwbGF5ZXIgaW4gdGhlIGxpc3RcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuaWRzID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0cmV0dXJuIHBsYXllci5pZDtcclxuXHR9KTtcclxufTtcclxuXHJcblxyXG4vL0tpbGwgYWxsIHBsYXllcnMgaW4gdGhlIHBsYXllckxpc3RcclxuUGxheWVyTGlzdC5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHBsYXllci5raWxsKCk7XHJcblx0fSk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5cclxuLy9SZXR1cm5zIHRoZSBzaW5nbGUgcGxheWVyIHdpdGggdGhlIGhpZ2hlc3Qgc2NvcmVcclxuUGxheWVyTGlzdC5wcm90b3R5cGUubGVhZGVyID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIHBsYXllcnMgPSB0aGlzLnNsaWNlKCk7XHJcblxyXG5cdHBsYXllcnMuc29ydChmdW5jdGlvbihhLCBiKSB7XHJcblx0XHRyZXR1cm4gYi5zY29yZSAtIGEuc2NvcmU7XHJcblx0fSk7XHJcblxyXG5cdHBsYXllcnMgPSBwbGF5ZXJzLmZpbHRlcihmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHJldHVybiBwbGF5ZXIuc2NvcmUgPT0gcGxheWVyc1swXS5zY29yZVxyXG5cdH0pXHJcblxyXG5cclxuXHRyZXR1cm4gcGxheWVycy5sZW5ndGggPiAxID8gbmV3IFBsYXllckxpc3QocGxheWVycykgOiBwbGF5ZXJzWzBdO1xyXG59O1xyXG5cclxuXHJcblBsYXllckxpc3QucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRwbGF5ZXIuYXZhaWxhYmxlID0gdHJ1ZTtcclxuXHR9KTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG5cclxuLy9SZXR1cm4gYSBwbGF5ZXJMaXN0IHdpdGggb25seSB0aGUgcGxheWVycyB3aG8gYXJlIGF2YWlsYWJsZVxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5vbmx5QWxpdmUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFBsYXllckxpc3QoXHJcblx0XHR0aGlzLmZpbHRlcihmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0cmV0dXJuIHBsYXllci5hbGl2ZTtcclxuXHRcdH0pXHJcblx0KTtcclxufTtcclxuXHJcblxyXG4vL1JldHVybiBhIHBsYXllckxpc3Qgd2l0aCBvbmx5IHRoZSBwbGF5ZXJzIHdobyBhcmUgYXZhaWxhYmxlXHJcblBsYXllckxpc3QucHJvdG90eXBlLm9ubHlBdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFBsYXllckxpc3QoXHJcblx0XHR0aGlzLmZpbHRlcihmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0cmV0dXJuIHBsYXllci5hdmFpbGFibGU7XHJcblx0XHR9KVxyXG5cdCk7XHJcbn07XHJcblxyXG5cclxuLy9SZXR1cm5zIGFuIGFycmF5IG9mIHNjb3JlcyBvZiBlYWNoIHBsYXllciBpbiB0aGUgbGlzdFxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5zY29yZXMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0gW107XHJcblxyXG5cdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHNjb3Jlcy5wdXNoKHBsYXllci5zY29yZSk7IC8vVXNlIHRoZSBpbnRlcmZhY2UgZnVuY3Rpb24gdG8gYXZvaWQgdXNlcnMgcmUtYXNzaWduaW5nIHRoZSByZWZlcmVuY2VcclxuXHR9KTtcclxuXHRyZXR1cm4gc2NvcmVzO1xyXG59O1xyXG5cclxuXHJcbi8vIFJldHVybnMgYW4gb2JqZWN0IHdoZXJlIGVhY2gga2V5IGlzIGEgc3RyYXRlZ3kgYW5kIGVhY2ggdmFsdWUgaXMgYW4gYXJyYXkgb2YgdGhlIHNjb3JlcyBvZiBwbGF5ZXJzIHdpdGggdGhhdCBzdHJhdGVneS5cclxuLy8gVE9ETzogZmluaXNoIC50b3RhbCgpIG1ldGhvZCwgd2hpY2ggd2lsbCBzdW0gdGhlIGFycmF5cyAoZHVwbGljYXRpbmcgLnNjb3Jlc0J5U3RyYXRlZ3lUb3RhbHMpXHJcblBsYXllckxpc3QucHJvdG90eXBlLnNjb3Jlc0J5U3RyYXRlZ3kgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0ge307XHJcblx0dmFyIGxpc3QgPSB0aGlzO1xyXG5cclxuXHRsaXN0LnN0cmF0ZWdpZXMoKS5tYXAoZnVuY3Rpb24oc3RyYXRlZ3kpIHtcclxuXHRcdHNjb3Jlc1tzdHJhdGVneV0gPSBsaXN0LnVzaW5nU3RyYXRlZ3koc3RyYXRlZ3kpLnNjb3JlcygpO1xyXG5cdH0pO1xyXG5cclxuXHRzY29yZXMudG90YWwgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBzY29yZSA9IHt9O1xyXG5cdFx0dmFyIHNjb3JlcyA9IHRoaXM7XHJcblx0XHRPYmplY3Qua2V5cyhzY29yZXMpLmZvckVhY2goZnVuY3Rpb24oc3RyYXRlZ3kpIHtcclxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoc2NvcmVzW3N0cmF0ZWd5XSkpIHNjb3JlW3N0cmF0ZWd5XSA9IHNjb3Jlc1tzdHJhdGVneV0ucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdFx0XHRyZXR1cm4gYSArIGI7XHJcblx0XHRcdH0sIDApO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gc2NvcmU7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIHNjb3JlcztcclxufTtcclxuXHJcbi8vIFJldHVybnMgYW4gb2JqZWN0IHdoZXJlIGVhY2gga2V5IGlzIGEgc3RyYXRlZ3kgYW5kIGVhY2ggdmFsdWUgaXMgdGhlIHN1bSBvZiBzY29yZXMgb2YgYWxsIHBsYXllcnMgd2l0aCB0aGF0IHZhbHVlXHJcblBsYXllckxpc3QucHJvdG90eXBlLnNjb3Jlc0J5U3RyYXRlZ3lUb3RhbHMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0ge307XHJcblx0dmFyIGxpc3QgPSB0aGlzO1xyXG5cclxuXHRsaXN0LnN0cmF0ZWdpZXMoKS5tYXAoZnVuY3Rpb24oc3RyYXRlZ3kpIHtcclxuXHRcdHNjb3Jlc1tzdHJhdGVneV0gPSBsaXN0XHJcblx0XHRcdC51c2luZ1N0cmF0ZWd5KHN0cmF0ZWd5KVxyXG5cdFx0XHQuc2NvcmVzKClcclxuXHRcdFx0LnJlZHVjZShmdW5jdGlvbihhLCBiKSB7XHJcblx0XHRcdFx0cmV0dXJuIGEgKyBiO1xyXG5cdFx0XHR9LCAwKTtcclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIHNjb3JlcztcclxufTtcclxuXHJcbi8vUmV0dXJucyBhbiBvYmplY3Qgd2hlcmUgdGhlIGtleXMgYXJlIHRoZSBwbGF5ZXIgaWRzIGFuZCB0aGUgdmFsdWVzXHJcbi8vYXJlIHRoZSBwbGF5ZXJzJyBzY29yZVxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5zY29yZXNPYmplY3QgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0ge307XHJcblxyXG5cdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHNjb3Jlc1twbGF5ZXIuaWRdID0gcGxheWVyLnNjb3JlO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gc2NvcmVzO1xyXG59O1xyXG5cclxuLy9NZWFuIG9mIHRoZSBzY29yZXNcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuc2NvcmVzTWVhbiA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBzY29yZXMgPSB0aGlzLnNjb3JlcygpO1xyXG5cclxuXHR2YXIgbWVhbiA9XHJcblx0XHRzY29yZXMucmVkdWNlKGZ1bmN0aW9uKHN1bSwgdmFsdWUpIHtcclxuXHRcdFx0cmV0dXJuIHN1bSArIHZhbHVlO1xyXG5cdFx0fSwgMCkgLyBzY29yZXMubGVuZ3RoO1xyXG5cclxuXHRyZXR1cm4gbWVhbjtcclxufTtcclxuXHJcbi8vQXJyYXkgd2l0aCAyIGVudHJpZXMsIHRoZSBsb3dlc3QgYW5kIGhpZ2hlc3Qgc2NvcmVcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuc2NvcmVzUmFuZ2UgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0gdGhpcy5zY29yZXMoKTtcclxuXHJcblx0c2NvcmVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0cmV0dXJuIGEgLSBiO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gW3Njb3Jlc1swXSwgc2NvcmVzW3Njb3Jlcy5sZW5ndGggLSAxXV07XHJcbn07XHJcblxyXG4vL1RoZSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgdGhlIHNjb3Jlc1xyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5zY29yZXNTdGQgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0gdGhpcy5zY29yZXMoKTtcclxuXHR2YXIgbWVhbiA9IHRoaXMuc2NvcmVzTWVhbigpO1xyXG5cclxuXHR2YXIgdmFyaWFuY2UgPVxyXG5cdFx0c2NvcmVzLnJlZHVjZShmdW5jdGlvbihzdW0sIHZhbHVlKSB7XHJcblx0XHRcdHJldHVybiBzdW0gKyBNYXRoLnBvdyh2YWx1ZSAtIG1lYW4sIDIpO1xyXG5cdFx0fSwgMCkgLyBzY29yZXMubGVuZ3RoO1xyXG5cclxuXHR2YXIgc3RkID0gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcclxuXHJcblx0cmV0dXJuIHN0ZDtcclxufTtcclxuXHJcblxyXG4vL1JldHVybiBhbiBhcnJheSBvZiB0aGUgc3RyYXRlZ3kgb2YgZWFjaCBwbGF5ZXIgaW4gdGhlIGxpc3RcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuc3RyYXRlZ2llcyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHJldHVybiBwbGF5ZXIuc3RyYXRlZ3kgPyBwbGF5ZXIuc3RyYXRlZ3kuX2lkIDogXCJcIjtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vUmV0dXJuIGEgUGxheWVyTGlzdCB3aXRoIG9ubHkgcGxheWVycyB1c2luZyBhIGdpdmVuIHN0cmF0ZWd5XHJcblBsYXllckxpc3QucHJvdG90eXBlLnVzaW5nU3RyYXRlZ3kgPSBmdW5jdGlvbihzdHJhdGVneSkge1xyXG5cdHJldHVybiBuZXcgUGxheWVyTGlzdChcclxuXHRcdHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRpZiAoXHJcblx0XHRcdFx0cGxheWVyLnN0cmF0ZWd5ID09IHN0cmF0ZWd5IHx8XHJcblx0XHRcdFx0cGxheWVyLnN0cmF0ZWd5Ll9pZCA9PSBzdHJhdGVneSB8fFxyXG5cdFx0XHRcdChpc0Z1bmN0aW9uKHN0cmF0ZWd5KSAmJiBwbGF5ZXIuc3RyYXRlZ3kgaW5zdGFuY2VvZiBzdHJhdGVneSlcclxuXHRcdFx0KVxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRlbHNlIHJldHVybiBmYWxzZTtcclxuXHRcdH0pXHJcblx0KTtcclxufTtcclxuXHJcbi8qXHJcblxyXG5UT0RPIGZpZ3VyZSBvdXQgaG93IHRvIG1ha2UgdGhpcyB3b3JrXHJcblxyXG4vL1JldHVybnMgYW4gb2JqZWN0IHdoZXJlIHRoZSBrZXlzIGFyZSBzdHJhdGVneSBuYW1lcyBhbmQgdGhlIHZhbHVlcyBhcmUgYXJyYXlzIG9mIHBsYXllcnMuXHJcbi8vVGhpcyBuZWVkcyB0byBiZSBvdmVycmlkZGVuIG9uIHRoZSBVc2VyUGxheWVyTGlzdCBwcm90b3R5cGUsIGJlY2F1c2UgdGhlIG5vcm1hbCB3cmFwcGVyIGxvZ2ljXHJcbi8vZm9yIFVzZXJQbGF5ZXJMaXN0IGNhbm5vdCBzYW5pdGl6ZSB0aGlzLlxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5ieVN0cmF0ZWd5ID0gZnVuY3Rpb24oKXtcclxuXHR2YXIgbGlzdCA9IHRoaXM7XHJcblx0dmFyIGRhdGEgPSB7fTtcclxuXHJcblx0T2JqZWN0LmtleXMocmVnaXN0cnkuc3RyYXRlZ2llcykuZm9yRWFjaChmdW5jdGlvbihzdHJhdGVneSl7XHJcblx0XHRkYXRhW3N0cmF0ZWd5XSA9IGxpc3QudXNpbmdTdHJhdGVneShzdHJhdGVneSk7XHJcblx0fSk7XHJcblxyXG5cdHJldHVybiBkYXRhO1xyXG59O1xyXG4qL1xyXG5cclxuLy9SZXR1cm5zIGFuIG9iamVjdCB3aGVyZSB0aGUga2V5cyBhcmUgZWFjaCBzdHJhdGVneSBhbmQgdGhlIHZhbHVlc1xyXG4vL2FyZSB0aGUgbnVtYmVyIG9mIHBsYXllcnMgaW4gdGhlIGxpc3Qgd2hvIGFyZSB1c2luZyBpdC5cclxuUGxheWVyTGlzdC5wcm90b3R5cGUuc3RyYXRlZ3lEaXN0cmlidXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgY291bnRzID0ge307XHJcblxyXG5cdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHZhciBzID0gcGxheWVyLnN0cmF0ZWd5Ll9pZDtcclxuXHRcdGNvdW50c1tzXSA9IChjb3VudHNbc10gfHwgMCkgKyAxO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gY291bnRzO1xyXG59O1xyXG5cclxuXHJcblxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5yZXNldFNjb3JlcyA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHBsYXllci5zY29yZSA9IDA7XHJcblx0fSk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vL0FjY2VwdCBhIFBsYXllckxpc3QgYW5kIHJldHVybiBvbmUgc3VpdGFibGUgZm9yIHRoZSB1c2VyLCBvciBjcmVhdGUgYSBwbGF5ZXJsaXN0IGFuZCByZXR1cm4gb25lIHN1aXRhYmxlIGZvciB0aGUgdXNlclxyXG5mdW5jdGlvbiBVc2VyUGxheWVyTGlzdCguLi5wbGF5ZXJMaXN0KSB7XHJcblx0aWYgKEFycmF5LmlzQXJyYXkocGxheWVyTGlzdFswXSkpIHBsYXllckxpc3QgPSBwbGF5ZXJMaXN0WzBdO1xyXG5cclxuXHQvLyBJZiB3ZSd2ZSBnb3QgYSBwbGF5ZXJMaXN0LCByZXR1cm4gdGhlIGludGVyZmFjZSBvZiBlYWNoIHBsYXllclxyXG5cdGlmIChwbGF5ZXJMaXN0IGluc3RhbmNlb2YgUGxheWVyTGlzdCkge1xyXG5cdFx0dmFyIHVzZXJQbGF5ZXJMaXN0ID0gcGxheWVyTGlzdC5tYXAoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdHJldHVybiBwbGF5ZXIuaW50ZXJmYWNlO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cdC8vIElmIG5vdCwgZmlyc3QgY3JlYXRlIGEgcGxheWVyTGlzdCwgdGhlbiBjYWxsIHRoaXMgZnVuY3Rpb24gYWdhaW4gdG8gd3JhcCBpdC5cclxuXHRlbHNlIHJldHVybiBuZXcgVXNlclBsYXllckxpc3QobmV3IFBsYXllckxpc3QocGxheWVyTGlzdCkpO1xyXG5cclxuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YodXNlclBsYXllckxpc3QsIFVzZXJQbGF5ZXJMaXN0LnByb3RvdHlwZSk7XHJcblxyXG5cdC8vQXR0YWNoIG1ldGhvZHMgZnJvbSBQbGF5ZXJMaXN0LCB3cmFwcGVkIGluIGEgZnVuY3Rpb24uIElmIHRob3NlIG1ldGhvZHMgcmV0dXJuIGEgcGxheWVyTGlzdCxcclxuXHQvL3RoZW4gdGhlIGZ1bmN0aW9uIHdpbGwgY29udmVydCB0aGF0IHRvIGEgVXNlclBsYXllckxpc3QuXHJcblx0Zm9yICh2YXIgbWV0aG9kIGluIFBsYXllckxpc3QucHJvdG90eXBlKSB7XHJcblx0XHRpZiAoaXNGdW5jdGlvbihwbGF5ZXJMaXN0W21ldGhvZF0pKSB7XHJcblx0XHRcdGlmIChtZXRob2QgIT0gXCJjb25zdHJ1Y3RvclwiKVxyXG5cdFx0XHRcdHVzZXJQbGF5ZXJMaXN0W21ldGhvZF0gPSAoZnVuY3Rpb24obWV0aG9kKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdHZhciByZXN1bHQgPSBwbGF5ZXJMaXN0W21ldGhvZF0uYXBwbHkocGxheWVyTGlzdCwgYXJndW1lbnRzKTtcclxuXHRcdFx0XHRcdFx0aWYgKHJlc3VsdCBpbnN0YW5jZW9mIFBsYXllckxpc3QpIHJldHVybiBuZXcgVXNlclBsYXllckxpc3QocmVzdWx0KTtcclxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAocmVzdWx0IGluc3RhbmNlb2YgX1BsYXllcikgcmV0dXJuIHJlc3VsdC5pbnRlcmZhY2U7XHJcblx0XHRcdFx0XHRcdGVsc2UgcmV0dXJuIHJlc3VsdDtcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fSkobWV0aG9kKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB1c2VyUGxheWVyTGlzdDtcclxufVxyXG5cclxuVXNlclBsYXllckxpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQbGF5ZXJMaXN0LnByb3RvdHlwZSk7XHJcblVzZXJQbGF5ZXJMaXN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVzZXJQbGF5ZXJMaXN0O1xyXG5cclxuLy9BY2NlcHQgYSBQbGF5ZXJMaXN0IGFuZCByZXR1cm4gb25lIHN1aXRhYmxlIGZvciBhIHN0cmF0ZWd5IGluZm9ybWF0aW9uIHNldC5cclxuZnVuY3Rpb24gSW5mb1BsYXllckxpc3QocGxheWVyTGlzdCkge1xyXG5cdHZhciBpbmZvUGxheWVyTGlzdCA9IHBsYXllckxpc3QubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0cmV0dXJuIHBsYXllci5pbmZvQ2xlYW4oSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwbGF5ZXIpKSk7XHJcblx0fSk7XHJcblxyXG5cdE9iamVjdC5zZXRQcm90b3R5cGVPZihpbmZvUGxheWVyTGlzdCwgSW5mb1BsYXllckxpc3QucHJvdG90eXBlKTtcclxuXHJcblx0Ly9BdHRhY2ggc2VsZWN0ZWQgbWV0aG9kcyBmcm9tIFBsYXllckxpc3QsIHdyYXBwZWQgaW4gYSBmdW5jdGlvbi4gSWYgdGhvc2UgbWV0aG9kcyByZXR1cm4gYSBwbGF5ZXJMaXN0LFxyXG5cdC8vdGhlbiB0aGUgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IHRoYXQgdG8gYW4gSW5mb1BsYXllckxpc3QuXHJcblx0dmFyIG1ldGhvZHNUb0luY2x1ZGUgPSBbXHJcblx0XHRcIm9ubHlBbGl2ZVwiLFxyXG5cdFx0XCJvbmx5QXZhaWxhYmxlXCIsXHJcblx0XHRcImlkc1wiLFxyXG5cdFx0XCJleGNsdWRlXCIsXHJcblx0XHRcImdlbmVyYXRvclwiLFxyXG5cdFx0XCJzdHJhdGVnaWVzXCIsXHJcblx0XHRcInVzaW5nU3RyYXRlZ3lcIixcclxuXHRcdFwic3RyYXRlZ3lEaXN0cmlidXRpb25cIixcclxuXHRcdFwic2NvcmVzXCIsXHJcblx0XHRcInNjb3Jlc09iamVjdFwiLFxyXG5cdFx0XCJzY29yZXNNZWFuXCIsXHJcblx0XHRcInNjb3Jlc1JhbmdlXCIsXHJcblx0XHRcInNjb3Jlc1N0ZFwiLFxyXG5cdFx0XCJsZWFkZXJcIlxyXG5cdF07XHJcblxyXG5cdGZvciAodmFyIG1ldGhvZCBpbiBQbGF5ZXJMaXN0LnByb3RvdHlwZSkge1xyXG5cdFx0aWYgKGlzRnVuY3Rpb24ocGxheWVyTGlzdFttZXRob2RdKSkge1xyXG5cdFx0XHRpZiAobWV0aG9kc1RvSW5jbHVkZS5pbmRleE9mKG1ldGhvZCkgPiAtMSlcclxuXHRcdFx0XHRpbmZvUGxheWVyTGlzdFttZXRob2RdID0gKGZ1bmN0aW9uKG1ldGhvZCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gcGxheWVyTGlzdFttZXRob2RdLmFwcGx5KHBsYXllckxpc3QsIGFyZ3VtZW50cyk7XHJcblx0XHRcdFx0XHRcdGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQbGF5ZXJMaXN0KSByZXR1cm4gbmV3IEluZm9QbGF5ZXJMaXN0KHJlc3VsdCk7XHJcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIF9QbGF5ZXIpXHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC5pbmZvQ2xlYW4oSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXN1bHQpKSk7XHJcblx0XHRcdFx0XHRcdGVsc2UgcmV0dXJuIHJlc3VsdDtcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fSkobWV0aG9kKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBpbmZvUGxheWVyTGlzdDtcclxufVxyXG5cclxuSW5mb1BsYXllckxpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBcnJheS5wcm90b3R5cGUpO1xyXG5JbmZvUGxheWVyTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbmZvUGxheWVyTGlzdDtcclxuXHJcbi8vRXh0cmEgbWV0aG9kIHRvIHJldHVybiBhIHNpbmdsZSBwbGF5ZXIgZnJvbSBhbiBpbmZvUGxheWVyTGlzdFxyXG5JbmZvUGxheWVyTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocGxheWVySUQpIHtcclxuXHRyZXR1cm4gdGhpcy5maW5kKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0cmV0dXJuIHBsYXllci5pZCA9PSBwbGF5ZXJJRDtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vR2VuZXJhdGVzIGEgUGxheWVyTGlzdCBjb250YWluaW5nIGFsbCBwbGF5ZXJzLlxyXG52YXIgZ2FtZVBvcHVsYXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgcG9wdWxhdGlvbiA9IFtdO1xyXG5cclxuXHRmb3IgKHZhciBwbGF5ZXIgaW4gcmVnaXN0cnkucGxheWVycykge1xyXG5cdFx0cG9wdWxhdGlvbi5wdXNoKHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyXSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3IFBsYXllckxpc3QocG9wdWxhdGlvbik7XHJcbn07XHJcblxyXG4vL0RvZXMgdGhlIHNhbWUsIGJ1dCBhIFVzZXJQbGF5ZXJMaXN0XHJcbnZhciBQb3B1bGF0aW9uID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBVc2VyUGxheWVyTGlzdChnYW1lUG9wdWxhdGlvbigpKTtcclxufTtcclxuXHJcbi8vRG9lcyB0aGUgc2FtZSwgYnV0IGFuIEluZm9QbGF5ZXJMaXN0XHJcbnZhciBJbmZvUG9wdWxhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgSW5mb1BsYXllckxpc3QoZ2FtZVBvcHVsYXRpb24oKSk7XHJcbn07XHJcblxyXG4vL0Egc2hvcnQtaGFuZCB0byByZXR1cm4gdG90YWwgcG9wdWxhdGlvbiBzaXplIHdpdGhvdXQgY3JlYXRpbmcgYSBQbGF5ZXJMaXN0XHJcblBvcHVsYXRpb24uc2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBPYmplY3Qua2V5cyhyZWdpc3RyeS5wbGF5ZXJzKS5sZW5ndGg7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHRQbGF5ZXJMaXN0LFxyXG5cdFVzZXJQbGF5ZXJMaXN0LFxyXG5cdEluZm9QbGF5ZXJMaXN0LFxyXG5cdGdhbWVQb3B1bGF0aW9uLFxyXG5cdFBvcHVsYXRpb24sXHJcblx0SW5mb1BvcHVsYXRpb25cclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBFeHRlcm5hbCBkZXBlbmRlbmN5XHJcbnZhciBqc29uYXRhID0gcmVxdWlyZShcImpzb25hdGFcIik7XHJcblxyXG4vLyBHYW1lIHN0YXRlXHJcbnZhciB7IHJlZ2lzdHJ5LCBpZENvdW50ZXJzIH0gPSByZXF1aXJlKFwiLi9zdGF0ZVwiKVxyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoJy4vaGVscGVyLWZ1bmN0aW9ucycpKFwic3RhdGVcIik7XHJcbnJlZ2lzdHJ5Ll9hZGRUeXBlXyhcInF1ZXJpZXNcIilcclxuaWRDb3VudGVycy5fYWRkVHlwZV8oXCJxdWVyeVwiKVxyXG5cclxuXHJcbnZhciByZWdpc3RlclF1ZXJ5T2JqZWN0ID0gZnVuY3Rpb24ocXVlcnlPYmplY3QsIGdhbWVOYW1lKSB7XHJcblx0Ly8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIHF1ZXJpZXMsIHJlY3Vyc2VcclxuXHRpZiAoQXJyYXkuaXNBcnJheShxdWVyeU9iamVjdCkpIHJldHVybiBxdWVyeU9iamVjdC5tYXAoZnVuY3Rpb24ocXVlcnkpIHtcclxuXHRcdHJldHVybiByZWdpc3RlclF1ZXJ5T2JqZWN0KHF1ZXJ5KVxyXG5cdH0pO1xyXG5cclxuXHR2YXIgeyBzaG9ydGN1dCwgcXVlcnksIGRlc2NyaXB0aW9uID0gXCJObyBkZXNjcmlwdGlvbiBnaXZlbi5cIiB9ID0gcXVlcnlPYmplY3Q7XHJcblx0Ly8gRW5mb3JjZSBuYW1pbmcgY29udmVudGlvbiwgZmlyc3QgY2hhcmFjdGVyICdAJ1xyXG5cdGlmIChzaG9ydGN1dFswXSAhPSBcIkBcIikgc2hvcnRjdXQgPSBcIkBcIi5jb25jYXQoc2hvcnRjdXQpXHJcblxyXG5cdC8vIENoZWNrIGZvciBkdXBsaWNhdGVzLiBBYm9ydCBpZiBzbywgYnV0IHJldHVybiB0aGUgZGF0YSBmb3IgZGlzcGxheSBwdXJwb3Nlcy5cclxuXHRpZiAocmVnaXN0cnkucXVlcmllc1tzaG9ydGN1dF0gJiYgcmVnaXN0cnkucXVlcmllc1tzaG9ydGN1dF0ucXVlcnkgPT0gcXVlcnkgJiZcclxuXHRcdHJlZ2lzdHJ5LnF1ZXJpZXNbc2hvcnRjdXRdLmRlc2NyaXB0aW9uID09IGRlc2NyaXB0aW9uKVxyXG5cdFx0cmV0dXJuIHsgc2hvcnRjdXQsIGRlc2NyaXB0aW9uIH07XHJcblxyXG5cdC8vIGFzc2lnbiBpZCBhbmQgYWRkIHRvIHJlZ2lzdHJ5XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHNob3J0Y3V0LCBcInF1ZXJ5XCIpXHJcblx0cmVnaXN0cnkucXVlcmllc1tpZF0gPSB7IHF1ZXJ5LCBkZXNjcmlwdGlvbiB9XHJcblxyXG5cdC8vcmV0dXJuIHRoZSBkYXRhIGZvciBkaXNwbGF5IHB1cnBvc2VzXHJcblx0cmV0dXJuIHsgc2hvcnRjdXQ6IGlkLCBkZXNjcmlwdGlvbiB9XHJcbn1cclxuXHJcblxyXG4vLyBUaGUgY29kZSB3aGljaCBldmFsdWF0ZXMgYWxsIHF1ZXJpZXMsIG5vIG1hdHRlciB3aGVyZSB0aGV5IGNvbWUgZnJvbS5cclxuZnVuY3Rpb24gZXZhbHVhdGVRdWVyeShxdWVyeVN0cmluZywgdGFyZ2V0LCAuLi5hcmdzKSB7XHJcblx0Ly8gQ2hlY2sgZm9yIHByZS1wcm9ncmFtbWVkIHF1ZXJ5LCBkZXNpZ25hdGVkIGJ5ICdAJ1xyXG5cdGlmIChxdWVyeVN0cmluZ1swXSA9PSBcIkBcIiAmJiByZWdpc3RyeS5xdWVyaWVzW3F1ZXJ5U3RyaW5nXSkgcXVlcnlTdHJpbmcgPSByZWdpc3RyeS5xdWVyaWVzW3F1ZXJ5U3RyaW5nXS5xdWVyeVxyXG5cdGVsc2UgaWYgKHF1ZXJ5U3RyaW5nWzBdID09IFwiQFwiKSBxdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nLnNsaWNlKDEpXHJcblxyXG5cdHJldHVybiBuZXcgUXVlcnlSZXN1bHQocXVlcnlTdHJpbmcsIGpzb25hdGEocXVlcnlTdHJpbmcpLmV2YWx1YXRlKHRhcmdldCwgLi4uYXJncykpLnBhY2soKTtcclxufVxyXG5cclxuXHJcbi8vIE9iamVjdCB0byBwYXNzIGFyb3VuZCBxdWVyaWVzXHJcbmZ1bmN0aW9uIFF1ZXJ5KHNob3J0Y3V0LCBxdWVyeSwgZGVzY3JpcHRpb24sIGZvcm1hdCA9IFwic2hvcnRjdXRcIikge1xyXG5cclxuXHRpZiAoZm9ybWF0ID09IFwic2F2ZVwiKSB7XHJcblx0XHR0aGlzLnNhdmVTaG9ydGN1dCA9IGZ1bmN0aW9uKHNob3J0Y3V0LCBkZXNjcmlwdGlvbikge1xyXG5cdFx0XHRyZXR1cm4gcmVnaXN0ZXJRdWVyeU9iamVjdCh7IHF1ZXJ5OiB0aGlzLnF1ZXJ5LCBzaG9ydGN1dCwgZGVzY3JpcHRpb24gfSlcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIE9ubHkgaW5jbHVkZSByZXF1ZXN0ZWQgcHJvcGVydGllcywgdG8gYXZvaWQgdmlzdWFsIGNsdXR0ZXJcclxuXHRpZiAoZm9ybWF0ID09IFwiY29kZVwiIHx8IGZvcm1hdCA9PSBcInNhdmVcIiB8fCBmb3JtYXQgPT0gXCJhbGxcIikgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xyXG5cdGlmIChmb3JtYXQgPT0gXCJzaG9ydGN1dFwiIHx8IGZvcm1hdCA9PSBcImFsbFwiKSB7XHJcblx0XHR0aGlzLnNob3J0Y3V0ID0gc2hvcnRjdXRcclxuXHJcblx0XHRpZiAoZm9ybWF0ICE9PSBcImFsbFwiKSB7XHJcblx0XHRcdC8vIE5vcm1hbGx5IHdlJ2QgdXNlIHRoZSBwcm90b3R5cGUgbWV0aG9kIHRvIHNhdmUgbWVtb3J5LCBidXQgaW4gdGhpcyBjYXNlIGl0IHdvbid0IHdvcmssIHNvIGF0dGFjaCBhbm90aGVyXHJcblx0XHRcdHRoaXMuZXZhbHVhdGUgPSBmdW5jdGlvbih0YXJnZXQsIC4uLmFyZ3MpIHtcclxuXHRcdFx0XHRyZXR1cm4gZXZhbHVhdGVRdWVyeShxdWVyeSwgdGFyZ2V0LCAuLi5hcmdzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblx0dGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uXHJcbn1cclxuXHJcblF1ZXJ5LnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKHRhcmdldCwgLi4uYXJncykge1xyXG5cdHJldHVybiBldmFsdWF0ZVF1ZXJ5KHRoaXMucXVlcnksIHRhcmdldCwgLi4uYXJncylcclxufTtcclxuXHJcblxyXG5cclxuLy8gQSBjbGFzcyB0byBzaGFyZSByZXN1bHRzIHdpdGguIEEgc2ltcGxlIFF1ZXJ5UmVzdWx0IGhhcyBhIGByZXN1bHRgIGFuZFxyXG4vLyBhIGBxdWVyeVN0cmluZ2AgcHJvcGVydHksIGFuZCBhIGAucGFja2AgbWV0aG9kLiBDYWxsaW5nIGAucGFja2Agd2lsbFxyXG4vLyBjcmVhdGUgYSBuZXcgb2JqZWN0IHdob3NlIHZhbHVlIGlzIHRoZSBgcmVzdWx0YCBwcm9wZXJ0eSwgYnV0IHdob3NlXHJcbi8vcHJvdG90eXBlIGlzIHRoZSBvcmlnaW5hbCBvYmplY3QuIFRoaXMgZ2l2ZXMgYSBjbGVhbiByZXN1bHQsIHRoYXQgc3RpbGxcclxuLy8gaGFzIGEgYC5xdWVyeVN0cmluZ2AgcHJvcGVydHksIHRvIHZpZXcgdGhlIHN0cmluZyB0aGF0IGdlbmVyYXRlZCBpdC5cclxuZnVuY3Rpb24gUXVlcnlSZXN1bHQocXVlcnksIHJlc3VsdCkge1xyXG5cdC8vIENhbid0IGFkZCBwcm9wZXJ0aWVzIHRvIHVuZGVmaW5lZCwgdG8gY2hhbmdlIHRvIGEgc3RyaW5nXHJcblx0aWYgKHJlc3VsdCA9PSB1bmRlZmluZWQpIHJlc3VsdCA9IHt9XHJcblxyXG5cdHRoaXMucXVlcnkgPSBxdWVyeVxyXG5cdHRoaXMucmVzdWx0ID0gcmVzdWx0XHJcbn1cclxuUXVlcnlSZXN1bHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBcnJheS5wcm90b3R5cGUpXHJcblF1ZXJ5UmVzdWx0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFF1ZXJ5UmVzdWx0O1xyXG5cclxuLy8gUmV0dXJucyBhbiBvYmplY3QgdGhhdCBpcyB0aGUgcmVzdWx0cyBvZiB0aGUgcXVlcnksIGJ1dCB3aG9zZVxyXG4vLyBwcm90b3R5cGUgY29udGFpbnMgLnF1ZXJ5ICh1bmxlc3MgdGhlIHJlc3VsdCB3YXMganVzdCBhIHN0cmluZylcclxuUXVlcnlSZXN1bHQucHJvdG90eXBlLnBhY2sgPSBmdW5jdGlvbigpIHtcclxuXHQvLyBJZiByZXN1bHQgaXMgc3RyaW5nLFxyXG5cdGlmICh0eXBlb2YgdGhpcy5yZXN1bHQgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdHZhciBwYWNrZWQgPSBuZXcgU3RyaW5nKHRoaXMucmVzdWx0KVxyXG5cdFx0cGFja2VkLnF1ZXJ5ID0gdGhpcy5xdWVyeVxyXG5cdFx0cmV0dXJuIHBhY2tlZDtcclxuXHR9XHJcblx0Ly8gSWYgaXQncyBhcnJheVxyXG5cdGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5yZXN1bHQpKSB7XHJcblx0XHR2YXIgcGFja2VkID0gT2JqZWN0LmNyZWF0ZSh0aGlzKVxyXG5cdFx0cGFja2VkLnB1c2goLi4udGhpcy5yZXN1bHQpXHJcblx0XHRyZXR1cm4gcGFja2VkXHJcblx0fVxyXG5cdC8vTm9ybWFsIG9iamVjdFxyXG5cdGVsc2UgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZSh0aGlzKSwgdGhpcy5yZXN1bHQpXHJcbn1cclxuXHJcblxyXG4vLyBVc2VyIG9iamVjdCBmb3IgZGVhbGluZyB3aXRoIHRoZXNlIHRoaW5ncy5cclxuZnVuY3Rpb24gUXVlcmllcyhxdWVyeVN0cmluZywgdGFyZ2V0LCAuLi5hcmdzKSB7XHJcblx0Ly8gSWYgbm8gcXVlcnkgc3RyaW5nLCBkaXNwbGF5IGFsbCBhdmFpbGFibGUgc2hvcnRjdXRzXHJcblx0aWYgKCFxdWVyeVN0cmluZykge1xyXG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKHJlZ2lzdHJ5LnF1ZXJpZXMpLm1hcChmdW5jdGlvbihxdWVyeSkge1xyXG5cdFx0XHR2YXIgcSA9IHJlZ2lzdHJ5LnF1ZXJpZXNbcXVlcnldXHJcblx0XHRcdHJldHVybiBuZXcgUXVlcnkocXVlcnksIHEucXVlcnksIHEuZGVzY3JpcHRpb24sIFwic2hvcnRjdXRcIilcclxuXHRcdH0pXHJcblx0fVxyXG5cdC8vIElmIHF1ZXJ5IHN0cmluZywgZWl0aGVyIHJ1biBxdWVyeSBvciByZXR1cm4gcXVlcnlcclxuXHRlbHNlIHtcclxuXHRcdC8vIElmIG5vIHRhcmdldCwgcmV0dXJuIHF1ZXJ5XHJcblx0XHRpZiAoIXRhcmdldCkge1xyXG5cdFx0XHR2YXIgcSA9IHJlZ2lzdHJ5LnF1ZXJpZXNbcXVlcnlTdHJpbmddXHJcblx0XHRcdGlmIChxKSByZXR1cm4gbmV3IFF1ZXJ5KHF1ZXJ5U3RyaW5nLCBxLnF1ZXJ5LCBxLmRlc2NyaXB0aW9uLCBcImNvZGVcIilcclxuXHRcdFx0ZWxzZSByZXR1cm4gbmV3IFF1ZXJ5KG51bGwsIHF1ZXJ5U3RyaW5nLCBudWxsLCBcInNhdmVcIilcclxuXHRcdH1cclxuXHRcdC8vIElmIHllcyB0YXJnZXQsIHJ1biBxdWVyeSBvbiB0YXJnZXQgYW5kIHJldHVybiByZXN1bHRcclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gZXZhbHVhdGVRdWVyeShxdWVyeVN0cmluZywgdGFyZ2V0LCAuLi5hcmdzKVxyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBRdWVyaWVzLCBRdWVyeSwgUXVlcnlSZXN1bHQsIGV2YWx1YXRlUXVlcnksIHJlZ2lzdGVyUXVlcnlPYmplY3QgfVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xyXG5cclxubG9nKFwiZGVidWdcIiwgXCJzdGF0ZTogQ3JlYXRpbmcgZ2FtZSBzdGF0ZSB2YXJpYWJsZXMuXCIpXHJcblxyXG5cclxudmFyIHJlZ2lzdHJ5ID0ge31cclxucmVnaXN0cnkuX2FkZFR5cGVfID0gZnVuY3Rpb24odHlwZSl7XHRcclxuXHRyZWdpc3RyeVt0eXBlXSA9IHt9O1xyXG5cdGxvZyhcInNpbGx5XCIsIFwic3RhdGU6IGFkZGluZyByZWdpc3RyeSBlbnRyeTogXCIsIHR5cGUpXHJcbn07XHJcblxyXG5cclxudmFyIGlkQ291bnRlcnMgPSB7fVxyXG5pZENvdW50ZXJzLl9hZGRUeXBlXyA9IGZ1bmN0aW9uKHR5cGUpe1xyXG5cdGlkQ291bnRlcnNbdHlwZV0gPSAwXHJcblx0bG9nKFwic2lsbHlcIiwgXCJzdGF0ZTogYWRkaW5nIGNvdW50ZXIgZW50cnk6IFwiLCB0eXBlKVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge3JlZ2lzdHJ5LCBpZENvdW50ZXJzfTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmNvbnN0IG5hc2hOYW1lID0gXCIuL2NvcmVcIjsgLy9DaGFuZ2UgdGhpcyB3aGVuIHB1Ymxpc2hlZCwgcHJvYmFibHkgdG8gJ25hc2gtanMnXHJcblxyXG52YXIgZnMgPSByZXF1aXJlKFwiZnNcIik7XHJcblxyXG52YXIgeyByZWdpc3RlclN0cmF0ZWd5LCByZWdpc3RlclN0cmF0ZWd5T2JqZWN0IH0gPSByZXF1aXJlKCcuL3N0cmF0ZWd5Jyk7XHJcblxyXG4vL0NoZWNrIHRvIHNlZSBpZiBwYXJzZWQgZXhwcmVzc2lvbiBpcyBjYWxsIHRvIHJlcXVpcmUgb3IgZXZhbFxyXG5mdW5jdGlvbiBpc0Jhbm5lZENhbGwobm9kZSkge1xyXG5cdHJldHVybiAobm9kZS50eXBlID09PSAnQ2FsbEV4cHJlc3Npb24nKSAmJlxyXG5cdFx0KG5vZGUuY2FsbGVlLnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykgJiZcclxuXHRcdChub2RlLmNhbGxlZS5vYmplY3QudHlwZSA9PT0gJ0lkZW50aWZpZXInKSAmJlxyXG5cdFx0KChub2RlLmNhbGxlZS5vYmplY3QubmFtZSA9PT0gJ3JlcXVpcmUnKSB8fCAobm9kZS5jYWxsZWUub2JqZWN0Lm5hbWUgPT09ICdldmFsJykpO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlQ2FsbHMoc291cmNlKSB7XHJcblx0Y29uc3QgZW50cmllcyA9IFtdO1xyXG5cdGVzcHJpbWEucGFyc2VTY3JpcHQoc291cmNlLCB7fSwgZnVuY3Rpb24obm9kZSwgbWV0YSkge1xyXG5cdFx0aWYgKGlzQmFubmVkQ2FsbChub2RlKSkge1xyXG5cdFx0XHRlbnRyaWVzLnB1c2goe1xyXG5cdFx0XHRcdHN0YXJ0OiBtZXRhLnN0YXJ0Lm9mZnNldCxcclxuXHRcdFx0XHRlbmQ6IG1ldGEuZW5kLm9mZnNldFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHRlbnRyaWVzLnNvcnQoKGEsIGIpID0+IHsgcmV0dXJuIGIuZW5kIC0gYS5lbmQgfSkuZm9yRWFjaChuID0+IHtcclxuXHRcdHNvdXJjZSA9IHNvdXJjZS5zbGljZSgwLCBuLnN0YXJ0KSArIFwiIG51bGw7IFwiICsgc291cmNlLnNsaWNlKG4uZW5kKTtcclxuXHR9KTtcclxuXHRyZXR1cm4gc291cmNlO1xyXG59XHJcblxyXG5cclxuXHJcbnZhciBsb2FkU3RyYXRlZ3kgPSBmdW5jdGlvbihmaWxlcGF0aCwgdHJ1c3RlZCA9IGZhbHNlKSB7XHJcblx0dmFyIGNvbXBpbGVyID0gcmVxdWlyZSgnZXhwcmVzc2lvbi1zYW5kYm94Jyk7XHJcblxyXG5cdHZhciBzb3VyY2UgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZXBhdGgpO1xyXG5cclxuXHRpZiAoIXRydXN0ZWQpIHtcclxuXHRcdHZhciBvcmlnaW5hbFNvdXJjZSA9IHNvdXJjZTtcclxuXHRcdHZhciBwYXJzZWRTb3VyY2UgPSByZW1vdmVDYWxscyhzb3VyY2UpO1xyXG5cclxuXHRcdGlmIChvcmlnaW5hbFNvdXJjZSAhPSBwYXJzZWRTb3VyY2UpIHRocm93IG5ldyBFcnJvcihcIlN0cmF0ZWd5IFwiICsgZmlsZXBhdGggKyBcIiB1c2VzIHJlcXVpcmUgb3IgZXZhbC5cIik7XHJcblx0fVxyXG5cclxuXHRzb3VyY2UgPSBcIlxcXCJ1c2Ugc3RyaWN0XFxcIjsgXFxuIFwiICsgc291cmNlO1xyXG5cdGNvbXBpbGVyKHNvdXJjZSkoeyByZWdpc3RlclN0cmF0ZWd5LCByZWdpc3RlclN0cmF0ZWd5T2JqZWN0IH0pO1xyXG5cclxufTsgLy9UT0RPOiBjaGFuZ2UgdGhpcyBzbyB0aGF0IHN0cmF0ZWdpZXMgY2FuJ3QgcmVxdWlyZSBhbnkgbW9kdWxlcy5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gbG9hZFN0cmF0ZWd5Rm9sZGVyKHBhdGgsIHRydXN0ZWQgPSBmYWxzZSkge1xyXG5cdHZhciBmaWxlcyA9IGZzLnJlYWRkaXJTeW5jKHBhdGgpO1xyXG5cdGZpbGVzLmZvckVhY2goZnVuY3Rpb24oZmlsZSkge1xyXG5cdFx0dmFyIGZpbGVQYXRoID0gcGF0aCArICcvJyArIGZpbGU7XHJcblx0XHRsb2FkU3RyYXRlZ3koZmlsZXBhdGgpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBsb2FkU3RyYXRlZ3ksIGxvYWRTdHJhdGVneUZvbGRlciB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xyXG5cclxuLy9KYXZhc2NyaXB0IGNvZGUgcGFyc2VyXHJcbnZhciBlc3ByaW1hID0gcmVxdWlyZSgnZXNwcmltYScpO1xyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKCcuL3N0YXRlJyk7XHJcblxyXG4vL0hlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgaWRIYW5kbGVyIH0gPSByZXF1aXJlKCcuL2hlbHBlci1mdW5jdGlvbnMnKShcInN0YXRlXCIpO1xyXG5cclxuXHJcblxyXG4vL1VzZXIgaW50ZXJmYWNlIHRvIGRlY2xhcmUgc3RyYXRlZ3kgdHlwZS5cclxuZnVuY3Rpb24gcmVnaXN0ZXJTdHJhdGVneShzdHJhdGVneSwgbmFtZSwgZGVzY3JpcHRpb24gPSBcIk5vIGRlc2NyaXB0aW9uIGdpdmVuLlwiLCBwbGF5ZXJOYW1lID0gXCJcIikge1xyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihuYW1lLCBcInN0cmF0ZWd5XCIpO1xyXG5cclxuXHRpZiAoaWQgIT09IG5hbWUpIHtcclxuXHRcdC8vVGhlcmUgd2FzIGFscmVhZHkgYSBzdHJhdGVneSByZWdpc3RlcmVkIHdpdGggdGhpcyBuYW1lLlxyXG5cdFx0Ly9DaGVjayB0byBzZWUgaWYgaXQncyB0aGUgc2FtZSBzdHJhdGVneSBvciBub3QuXHJcblx0XHRpZiAoIXJlZ2lzdHJ5LnN0cmF0ZWdpZXNbaWRdID09PSBzdHJhdGVneSkge1xyXG5cdFx0XHQvL1RoZXkncmUgZGlmZmVyZW50LCBzbyB3ZSBoYXZlIGEgbmFtZSBjb25mbGljdC5cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiU3RyYXRlZ3kgbmFtZSBjb25mbGljdCB3aXRoIFwiICsgbmFtZSk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gVGhleSdyZSB0aGUgc2FtZSwgZG8gbm90aGluZy5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBObyBuYW1lIGNvbmZsaWN0IGFuZCBzdHJhdGVneSBub3QgbG9hZGVkIHlldC4gQWRkIHRvIHJlZ2lzdHJ5LlxyXG5cdGxvZyhcImRlYnVnXCIsIFwiTG9hZGluZyBzdHJhdGVneSAnXCIgKyBpZCArIFwiJ1wiKVxyXG5cdHN0cmF0ZWd5LnBsYXllck5hbWUgPSBwbGF5ZXJOYW1lO1xyXG5cdHN0cmF0ZWd5LmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XHJcblx0cmVnaXN0cnkuc3RyYXRlZ2llc1tpZF0gPSBzdHJhdGVneTtcclxuXHRyZXR1cm4gbmFtZTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVnaXN0ZXJTdHJhdGVneU9iamVjdChzdHJhdGVneU9iamVjdCkge1xyXG5cdC8vIElmIG11bHRpcGxlIHN0cmF0ZWdpZXMsIHNwbGl0IGludG8gaW5kaXZpZHVhbHNcclxuXHRpZiAoQXJyYXkuaXNBcnJheShzdHJhdGVneU9iamVjdCkpIHJldHVybiBzdHJhdGVneU9iamVjdC5tYXAocmVnaXN0ZXJTdHJhdGVneU9iamVjdClcclxuXHJcblx0cmV0dXJuIHJlZ2lzdGVyU3RyYXRlZ3koc3RyYXRlZ3lPYmplY3Quc3RyYXRlZ3ksIHN0cmF0ZWd5T2JqZWN0Lm5hbWUsIHN0cmF0ZWd5T2JqZWN0LmRlc2NyaXB0aW9uLFxyXG5cdFx0c3RyYXRlZ3lPYmplY3QucGxheWVyTmFtZSlcclxufVxyXG5cclxuLy9TdHJpcCBvdXQgcmVxdWlyZXMgYW5kIHN1Y2hcclxuZnVuY3Rpb24gc2FuaXRpemVTdHJhdGVneShzdHJhdGVneSkge1xyXG5cdC8vIGNvbnNvbGUubG9nKHgpIG9yIGNvbnNvbGVbJ2Vycm9yJ10oeSlcclxuXHRmdW5jdGlvbiBpc1JlcXVpcmVDYWxsKG5vZGUpIHtcclxuXHRcdHJldHVybiAobm9kZS50eXBlID09PSAnQ2FsbEV4cHJlc3Npb24nKSAmJlxyXG5cdFx0XHQobm9kZS5jYWxsZWUudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKSAmJlxyXG5cdFx0XHQobm9kZS5jYWxsZWUub2JqZWN0LnR5cGUgPT09ICdJZGVudGlmaWVyJykgJiZcclxuXHRcdFx0KG5vZGUuY2FsbGVlLm9iamVjdC5uYW1lID09PSAncmVxdWlyZScpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVtb3ZlQ2FsbHMoc291cmNlKSB7XHJcblx0XHRjb25zdCBlbnRyaWVzID0gW107XHJcblx0XHRlc3ByaW1hLnBhcnNlU2NyaXB0KHNvdXJjZSwge30sIGZ1bmN0aW9uKG5vZGUsIG1ldGEpIHtcclxuXHRcdFx0aWYgKGlzUmVxdWlyZUNhbGwobm9kZSkpIHtcclxuXHRcdFx0XHRlbnRyaWVzLnB1c2goe1xyXG5cdFx0XHRcdFx0c3RhcnQ6IG1ldGEuc3RhcnQub2Zmc2V0LFxyXG5cdFx0XHRcdFx0ZW5kOiBtZXRhLmVuZC5vZmZzZXRcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRlbnRyaWVzLnNvcnQoKGEsIGIpID0+IHsgcmV0dXJuIGIuZW5kIC0gYS5lbmQgfSkuZm9yRWFjaChuID0+IHtcclxuXHRcdFx0c291cmNlID0gc291cmNlLnNsaWNlKDAsIG4uc3RhcnQpICsgc291cmNlLnNsaWNlKG4uZW5kKTtcclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIHNvdXJjZTtcclxuXHR9XHJcblxyXG5cdHJlbW92ZUNhbGxzKHN0cmF0ZWd5LnRvU3RyaW5nKCkpO1xyXG5cclxufVxyXG5cclxuLy9SZXR1cm5zIHRvIHRoZSB1c2VyIGFuIGFycmF5IG9mIGFsbCByZWdpc3RlcmVkIHN0cmF0ZWdpZXMuIFRPRE86IGhhdmUgdGhpcyBtaXJyb3IgUGxheWVyTGlzdCwgdG8gcHJvdmlkZSBmdW5jdGlvbmFsaXR5IGxpa2Ugb25seUFsaXZlIGFuZCBzY29yZXNPYmplY3QuXHJcbmZ1bmN0aW9uIFN0cmF0ZWdpZXMoKSB7XHJcblx0dmFyIHN0cmF0ZWdpZXMgPSBbXTtcclxuXHRmb3IgKHZhciBzdHJhdGVneSBpbiByZWdpc3RyeS5zdHJhdGVnaWVzKSBzdHJhdGVnaWVzLnB1c2goc3RyYXRlZ3kpO1xyXG5cdHJldHVybiBzdHJhdGVnaWVzO1xyXG59O1xyXG5cclxuLy8gRmV0Y2ggdGhlIGRlc2NyaXB0aW9ucyBvZiB0aGUgc3RyYXRlZ2llcy5cclxuU3RyYXRlZ2llcy5kZXNjcmlwdGlvbnMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc3RyYXRlZ2llcyA9IHt9O1xyXG5cdGZvciAodmFyIHN0cmF0ZWd5IGluIHJlZ2lzdHJ5LnN0cmF0ZWdpZXMpIHN0cmF0ZWdpZXNbc3RyYXRlZ3ldID0gcmVnaXN0cnkuc3RyYXRlZ2llc1tzdHJhdGVneV0uZGVzY3JpcHRpb247XHJcblx0cmV0dXJuIHN0cmF0ZWdpZXM7XHJcbn1cclxuXHJcblxyXG4vLyBBIGJ1aWx0LWluIGRlYnVnZ2luZyBzdHJhdGVneS4gQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIGxvYWRzIHRoZSBzdHJhdGVneS5cclxuLy8gVGhlIHN0cmF0ZWd5IGp1c3QgY2FsbGVzICdkZWJ1Z2dlcicgd2hlbiBhc2tlZCB0byBjaG9vc2UuXHJcblN0cmF0ZWdpZXMuZGVidWdnZXIgPSBmdW5jdGlvbigpIHtcclxuXHRyZWdpc3RlclN0cmF0ZWd5KGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5jaG9vc2UgPSBmdW5jdGlvbihvcHRpb25zLCBpbmZvcm1hdGlvbikge1xyXG5cdFx0XHRkZWJ1Z2dlcjtcclxuXHRcdH1cclxuXHR9LCBcImRlYnVnZ2VyXCIpXHJcblx0cmV0dXJuIFwiZGVidWdnZXJcIlxyXG59XHJcblxyXG5TdHJhdGVnaWVzLmxvZ2dlciA9IGZ1bmN0aW9uKCkge1xyXG5cdHJlZ2lzdGVyU3RyYXRlZ3koZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLmNob29zZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGluZm9ybWF0aW9uKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiT3B0aW9uczogXCIsIG9wdGlvbnMpO1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIkluZm9ybWF0aW9uOiBcIiwgaW5mb3JtYXRpb24pXHJcblx0XHR9XHJcblx0fSwgXCJsb2dnZXJcIilcclxuXHRyZXR1cm4gXCJsb2dnZXJcIlxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgcmVnaXN0ZXJTdHJhdGVneSwgcmVnaXN0ZXJTdHJhdGVneU9iamVjdCwgU3RyYXRlZ2llcyB9O1xyXG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIC9bXFx1MDAxYlxcdTAwOWJdW1soKSM7P10qKD86WzAtOV17MSw0fSg/OjtbMC05XXswLDR9KSopP1swLTlBLVBSWmNmLW5xcnk9PjxdL2c7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhc3NlbWJsZVN0eWxlcyAoKSB7XG5cdHZhciBzdHlsZXMgPSB7XG5cdFx0bW9kaWZpZXJzOiB7XG5cdFx0XHRyZXNldDogWzAsIDBdLFxuXHRcdFx0Ym9sZDogWzEsIDIyXSwgLy8gMjEgaXNuJ3Qgd2lkZWx5IHN1cHBvcnRlZCBhbmQgMjIgZG9lcyB0aGUgc2FtZSB0aGluZ1xuXHRcdFx0ZGltOiBbMiwgMjJdLFxuXHRcdFx0aXRhbGljOiBbMywgMjNdLFxuXHRcdFx0dW5kZXJsaW5lOiBbNCwgMjRdLFxuXHRcdFx0aW52ZXJzZTogWzcsIDI3XSxcblx0XHRcdGhpZGRlbjogWzgsIDI4XSxcblx0XHRcdHN0cmlrZXRocm91Z2g6IFs5LCAyOV1cblx0XHR9LFxuXHRcdGNvbG9yczoge1xuXHRcdFx0YmxhY2s6IFszMCwgMzldLFxuXHRcdFx0cmVkOiBbMzEsIDM5XSxcblx0XHRcdGdyZWVuOiBbMzIsIDM5XSxcblx0XHRcdHllbGxvdzogWzMzLCAzOV0sXG5cdFx0XHRibHVlOiBbMzQsIDM5XSxcblx0XHRcdG1hZ2VudGE6IFszNSwgMzldLFxuXHRcdFx0Y3lhbjogWzM2LCAzOV0sXG5cdFx0XHR3aGl0ZTogWzM3LCAzOV0sXG5cdFx0XHRncmF5OiBbOTAsIDM5XVxuXHRcdH0sXG5cdFx0YmdDb2xvcnM6IHtcblx0XHRcdGJnQmxhY2s6IFs0MCwgNDldLFxuXHRcdFx0YmdSZWQ6IFs0MSwgNDldLFxuXHRcdFx0YmdHcmVlbjogWzQyLCA0OV0sXG5cdFx0XHRiZ1llbGxvdzogWzQzLCA0OV0sXG5cdFx0XHRiZ0JsdWU6IFs0NCwgNDldLFxuXHRcdFx0YmdNYWdlbnRhOiBbNDUsIDQ5XSxcblx0XHRcdGJnQ3lhbjogWzQ2LCA0OV0sXG5cdFx0XHRiZ1doaXRlOiBbNDcsIDQ5XVxuXHRcdH1cblx0fTtcblxuXHQvLyBmaXggaHVtYW5zXG5cdHN0eWxlcy5jb2xvcnMuZ3JleSA9IHN0eWxlcy5jb2xvcnMuZ3JheTtcblxuXHRPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwTmFtZSkge1xuXHRcdHZhciBncm91cCA9IHN0eWxlc1tncm91cE5hbWVdO1xuXG5cdFx0T2JqZWN0LmtleXMoZ3JvdXApLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xuXHRcdFx0dmFyIHN0eWxlID0gZ3JvdXBbc3R5bGVOYW1lXTtcblxuXHRcdFx0c3R5bGVzW3N0eWxlTmFtZV0gPSBncm91cFtzdHlsZU5hbWVdID0ge1xuXHRcdFx0XHRvcGVuOiAnXFx1MDAxYlsnICsgc3R5bGVbMF0gKyAnbScsXG5cdFx0XHRcdGNsb3NlOiAnXFx1MDAxYlsnICsgc3R5bGVbMV0gKyAnbSdcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCBncm91cE5hbWUsIHtcblx0XHRcdHZhbHVlOiBncm91cCxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdFx0fSk7XG5cdH0pO1xuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsICdleHBvcnRzJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGFzc2VtYmxlU3R5bGVzXG59KTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC5hc3luYyA9IGdsb2JhbC5hc3luYyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gc2xpY2UoYXJyYXlMaWtlLCBzdGFydCkge1xuICAgIHN0YXJ0ID0gc3RhcnR8MDtcbiAgICB2YXIgbmV3TGVuID0gTWF0aC5tYXgoYXJyYXlMaWtlLmxlbmd0aCAtIHN0YXJ0LCAwKTtcbiAgICB2YXIgbmV3QXJyID0gQXJyYXkobmV3TGVuKTtcbiAgICBmb3IodmFyIGlkeCA9IDA7IGlkeCA8IG5ld0xlbjsgaWR4KyspICB7XG4gICAgICAgIG5ld0FycltpZHhdID0gYXJyYXlMaWtlW3N0YXJ0ICsgaWR4XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0Fycjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29udGludWF0aW9uIGZ1bmN0aW9uIHdpdGggc29tZSBhcmd1bWVudHMgYWxyZWFkeSBhcHBsaWVkLlxuICpcbiAqIFVzZWZ1bCBhcyBhIHNob3J0aGFuZCB3aGVuIGNvbWJpbmVkIHdpdGggb3RoZXIgY29udHJvbCBmbG93IGZ1bmN0aW9ucy4gQW55XG4gKiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBhcmUgYWRkZWQgdG8gdGhlIGFyZ3VtZW50c1xuICogb3JpZ2luYWxseSBwYXNzZWQgdG8gYXBwbHkuXG4gKlxuICogQG5hbWUgYXBwbHlcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB5b3Ugd2FudCB0byBldmVudHVhbGx5IGFwcGx5IGFsbFxuICogYXJndW1lbnRzIHRvLiBJbnZva2VzIHdpdGggKGFyZ3VtZW50cy4uLikuXG4gKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHlcbiAqIHdoZW4gdGhlIGNvbnRpbnVhdGlvbiBpcyBjYWxsZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHRoZSBwYXJ0aWFsbHktYXBwbGllZCBmdW5jdGlvblxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyB1c2luZyBhcHBseVxuICogYXN5bmMucGFyYWxsZWwoW1xuICogICAgIGFzeW5jLmFwcGx5KGZzLndyaXRlRmlsZSwgJ3Rlc3RmaWxlMScsICd0ZXN0MScpLFxuICogICAgIGFzeW5jLmFwcGx5KGZzLndyaXRlRmlsZSwgJ3Rlc3RmaWxlMicsICd0ZXN0MicpXG4gKiBdKTtcbiAqXG4gKlxuICogLy8gdGhlIHNhbWUgcHJvY2VzcyB3aXRob3V0IHVzaW5nIGFwcGx5XG4gKiBhc3luYy5wYXJhbGxlbChbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgZnMud3JpdGVGaWxlKCd0ZXN0ZmlsZTEnLCAndGVzdDEnLCBjYWxsYmFjayk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBmcy53cml0ZUZpbGUoJ3Rlc3RmaWxlMicsICd0ZXN0MicsIGNhbGxiYWNrKTtcbiAqICAgICB9XG4gKiBdKTtcbiAqXG4gKiAvLyBJdCdzIHBvc3NpYmxlIHRvIHBhc3MgYW55IG51bWJlciBvZiBhZGRpdGlvbmFsIGFyZ3VtZW50cyB3aGVuIGNhbGxpbmcgdGhlXG4gKiAvLyBjb250aW51YXRpb246XG4gKlxuICogbm9kZT4gdmFyIGZuID0gYXN5bmMuYXBwbHkoc3lzLnB1dHMsICdvbmUnKTtcbiAqIG5vZGU+IGZuKCd0d28nLCAndGhyZWUnKTtcbiAqIG9uZVxuICogdHdvXG4gKiB0aHJlZVxuICovXG52YXIgYXBwbHkgPSBmdW5jdGlvbihmbi8qLCAuLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKC8qY2FsbEFyZ3MqLykge1xuICAgICAgICB2YXIgY2FsbEFyZ3MgPSBzbGljZShhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoY2FsbEFyZ3MpKTtcbiAgICB9O1xufTtcblxudmFyIGluaXRpYWxQYXJhbXMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC8qLi4uYXJncywgY2FsbGJhY2sqLykge1xuICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgIGZuLmNhbGwodGhpcywgYXJncywgY2FsbGJhY2spO1xuICAgIH07XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxudmFyIGhhc1NldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgJiYgc2V0SW1tZWRpYXRlO1xudmFyIGhhc05leHRUaWNrID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBmYWxsYmFjayhmbikge1xuICAgIHNldFRpbWVvdXQoZm4sIDApO1xufVxuXG5mdW5jdGlvbiB3cmFwKGRlZmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmbi8qLCAuLi5hcmdzKi8pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxudmFyIF9kZWZlcjtcblxuaWYgKGhhc1NldEltbWVkaWF0ZSkge1xuICAgIF9kZWZlciA9IHNldEltbWVkaWF0ZTtcbn0gZWxzZSBpZiAoaGFzTmV4dFRpY2spIHtcbiAgICBfZGVmZXIgPSBwcm9jZXNzLm5leHRUaWNrO1xufSBlbHNlIHtcbiAgICBfZGVmZXIgPSBmYWxsYmFjaztcbn1cblxudmFyIHNldEltbWVkaWF0ZSQxID0gd3JhcChfZGVmZXIpO1xuXG4vKipcbiAqIFRha2UgYSBzeW5jIGZ1bmN0aW9uIGFuZCBtYWtlIGl0IGFzeW5jLCBwYXNzaW5nIGl0cyByZXR1cm4gdmFsdWUgdG8gYVxuICogY2FsbGJhY2suIFRoaXMgaXMgdXNlZnVsIGZvciBwbHVnZ2luZyBzeW5jIGZ1bmN0aW9ucyBpbnRvIGEgd2F0ZXJmYWxsLFxuICogc2VyaWVzLCBvciBvdGhlciBhc3luYyBmdW5jdGlvbnMuIEFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBnZW5lcmF0ZWRcbiAqIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIChleGNlcHQgZm9yIHRoZSBmaW5hbFxuICogY2FsbGJhY2sgYXJndW1lbnQpLiBFcnJvcnMgdGhyb3duIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjay5cbiAqXG4gKiBJZiB0aGUgZnVuY3Rpb24gcGFzc2VkIHRvIGBhc3luY2lmeWAgcmV0dXJucyBhIFByb21pc2UsIHRoYXQgcHJvbWlzZXMnc1xuICogcmVzb2x2ZWQvcmVqZWN0ZWQgc3RhdGUgd2lsbCBiZSB1c2VkIHRvIGNhbGwgdGhlIGNhbGxiYWNrLCByYXRoZXIgdGhhbiBzaW1wbHlcbiAqIHRoZSBzeW5jaHJvbm91cyByZXR1cm4gdmFsdWUuXG4gKlxuICogVGhpcyBhbHNvIG1lYW5zIHlvdSBjYW4gYXN5bmNpZnkgRVMyMDE3IGBhc3luY2AgZnVuY3Rpb25zLlxuICpcbiAqIEBuYW1lIGFzeW5jaWZ5XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgd3JhcFN5bmNcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gVGhlIHN5bmNocm9ub3VzIGZ1bmN0aW9uLCBvciBQcm9taXNlLXJldHVybmluZ1xuICogZnVuY3Rpb24gdG8gY29udmVydCB0byBhbiB7QGxpbmsgQXN5bmNGdW5jdGlvbn0uXG4gKiBAcmV0dXJucyB7QXN5bmNGdW5jdGlvbn0gQW4gYXN5bmNocm9ub3VzIHdyYXBwZXIgb2YgdGhlIGBmdW5jYC4gVG8gYmVcbiAqIGludm9rZWQgd2l0aCBgKGFyZ3MuLi4sIGNhbGxiYWNrKWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIHBhc3NpbmcgYSByZWd1bGFyIHN5bmNocm9ub3VzIGZ1bmN0aW9uXG4gKiBhc3luYy53YXRlcmZhbGwoW1xuICogICAgIGFzeW5jLmFwcGx5KGZzLnJlYWRGaWxlLCBmaWxlbmFtZSwgXCJ1dGY4XCIpLFxuICogICAgIGFzeW5jLmFzeW5jaWZ5KEpTT04ucGFyc2UpLFxuICogICAgIGZ1bmN0aW9uIChkYXRhLCBuZXh0KSB7XG4gKiAgICAgICAgIC8vIGRhdGEgaXMgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIHRoZSB0ZXh0LlxuICogICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwYXJzaW5nIGVycm9yLCBpdCB3b3VsZCBoYXZlIGJlZW4gY2F1Z2h0LlxuICogICAgIH1cbiAqIF0sIGNhbGxiYWNrKTtcbiAqXG4gKiAvLyBwYXNzaW5nIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgcHJvbWlzZVxuICogYXN5bmMud2F0ZXJmYWxsKFtcbiAqICAgICBhc3luYy5hcHBseShmcy5yZWFkRmlsZSwgZmlsZW5hbWUsIFwidXRmOFwiKSxcbiAqICAgICBhc3luYy5hc3luY2lmeShmdW5jdGlvbiAoY29udGVudHMpIHtcbiAqICAgICAgICAgcmV0dXJuIGRiLm1vZGVsLmNyZWF0ZShjb250ZW50cyk7XG4gKiAgICAgfSksXG4gKiAgICAgZnVuY3Rpb24gKG1vZGVsLCBuZXh0KSB7XG4gKiAgICAgICAgIC8vIGBtb2RlbGAgaXMgdGhlIGluc3RhbnRpYXRlZCBtb2RlbCBvYmplY3QuXG4gKiAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBlcnJvciwgdGhpcyBmdW5jdGlvbiB3b3VsZCBiZSBza2lwcGVkLlxuICogICAgIH1cbiAqIF0sIGNhbGxiYWNrKTtcbiAqXG4gKiAvLyBlczIwMTcgZXhhbXBsZSwgdGhvdWdoIGBhc3luY2lmeWAgaXMgbm90IG5lZWRlZCBpZiB5b3VyIEpTIGVudmlyb25tZW50XG4gKiAvLyBzdXBwb3J0cyBhc3luYyBmdW5jdGlvbnMgb3V0IG9mIHRoZSBib3hcbiAqIHZhciBxID0gYXN5bmMucXVldWUoYXN5bmMuYXN5bmNpZnkoYXN5bmMgZnVuY3Rpb24oZmlsZSkge1xuICogICAgIHZhciBpbnRlcm1lZGlhdGVTdGVwID0gYXdhaXQgcHJvY2Vzc0ZpbGUoZmlsZSk7XG4gKiAgICAgcmV0dXJuIGF3YWl0IHNvbWVQcm9taXNlKGludGVybWVkaWF0ZVN0ZXApXG4gKiB9KSk7XG4gKlxuICogcS5wdXNoKGZpbGVzKTtcbiAqL1xuZnVuY3Rpb24gYXN5bmNpZnkoZnVuYykge1xuICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHJlc3VsdCBpcyBQcm9taXNlIG9iamVjdFxuICAgICAgICBpZiAoaXNPYmplY3QocmVzdWx0KSAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2soY2FsbGJhY2ssIG51bGwsIHZhbHVlKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIGludm9rZUNhbGxiYWNrKGNhbGxiYWNrLCBlcnIubWVzc2FnZSA/IGVyciA6IG5ldyBFcnJvcihlcnIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBpbnZva2VDYWxsYmFjayhjYWxsYmFjaywgZXJyb3IsIHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IsIHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZSQxKHJldGhyb3csIGUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmV0aHJvdyhlcnJvcikge1xuICAgIHRocm93IGVycm9yO1xufVxuXG52YXIgc3VwcG9ydHNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBpc0FzeW5jKGZuKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRzU3ltYm9sICYmIGZuW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdBc3luY0Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gd3JhcEFzeW5jKGFzeW5jRm4pIHtcbiAgICByZXR1cm4gaXNBc3luYyhhc3luY0ZuKSA/IGFzeW5jaWZ5KGFzeW5jRm4pIDogYXN5bmNGbjtcbn1cblxuZnVuY3Rpb24gYXBwbHlFYWNoJDEoZWFjaGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZucy8qLCAuLi5hcmdzKi8pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICB2YXIgZ28gPSBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZWFjaGZuKGZucywgZnVuY3Rpb24gKGZuLCBjYikge1xuICAgICAgICAgICAgICAgIHdyYXBBc3luYyhmbikuYXBwbHkodGhhdCwgYXJncy5jb25jYXQoY2IpKTtcbiAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGdvLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdvO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wkMSA9IHJvb3QuU3ltYm9sO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWckMSA9IFN5bWJvbCQxID8gU3ltYm9sJDEudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnJDEpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWckMV07XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kMSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyQxID0gb2JqZWN0UHJvdG8kMS50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZyQxLmNhbGwodmFsdWUpO1xufVxuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJztcbnZhciB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wkMSA/IFN5bWJvbCQxLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJztcbnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbnZhciBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xudmFyIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8vIEEgdGVtcG9yYXJ5IHZhbHVlIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGxvb3Agc2hvdWxkIGJlIGJyb2tlbi5cbi8vIFNlZSAjMTA2NCwgIzEyOTNcbnZhciBicmVha0xvb3AgPSB7fTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxuZnVuY3Rpb24gb25jZShmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChmbiA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICB2YXIgY2FsbEZuID0gZm47XG4gICAgICAgIGZuID0gbnVsbDtcbiAgICAgICAgY2FsbEZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxudmFyIGl0ZXJhdG9yU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG5cbnZhciBnZXRJdGVyYXRvciA9IGZ1bmN0aW9uIChjb2xsKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yU3ltYm9sICYmIGNvbGxbaXRlcmF0b3JTeW1ib2xdICYmIGNvbGxbaXRlcmF0b3JTeW1ib2xdKCk7XG59O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDMgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQyID0gb2JqZWN0UHJvdG8kMy5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90byQzLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eSQyLmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIkMSA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIkMSA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnJDEgPSAnW29iamVjdCBBcmd1bWVudHNdJztcbnZhciBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XSc7XG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJztcbnZhciBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nO1xudmFyIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJztcbnZhciBmdW5jVGFnJDEgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nO1xudmFyIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nO1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xudmFyIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nO1xudmFyIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xudmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xudmFyIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xudmFyIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJztcbnZhciBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc7XG52YXIgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nO1xudmFyIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nO1xudmFyIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nO1xudmFyIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nO1xudmFyIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSc7XG52YXIgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJztcbnZhciB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZyQxXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnJDFdID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMkMSA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUkMSA9IGZyZWVFeHBvcnRzJDEgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyQxID0gZnJlZU1vZHVsZSQxICYmIGZyZWVNb2R1bGUkMS5leHBvcnRzID09PSBmcmVlRXhwb3J0cyQxO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMkMSAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUkMSAmJiBmcmVlTW9kdWxlJDEucmVxdWlyZSAmJiBmcmVlTW9kdWxlJDEucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDIgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQxID0gb2JqZWN0UHJvdG8kMi5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eSQxLmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQ1ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90byQ1O1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQ0ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkMyA9IG9iamVjdFByb3RvJDQuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQzLmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlJdGVyYXRvcihjb2xsKSB7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gY29sbC5sZW5ndGg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHJldHVybiArK2kgPCBsZW4gPyB7dmFsdWU6IGNvbGxbaV0sIGtleTogaX0gOiBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRVMyMDE1SXRlcmF0b3IoaXRlcmF0b3IpIHtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIgaXRlbSA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZW0uZG9uZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpKys7XG4gICAgICAgIHJldHVybiB7dmFsdWU6IGl0ZW0udmFsdWUsIGtleTogaX07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3RJdGVyYXRvcihvYmopIHtcbiAgICB2YXIgb2tleXMgPSBrZXlzKG9iaik7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gb2tleXMubGVuZ3RoO1xuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIga2V5ID0gb2tleXNbKytpXTtcbiAgICAgICAgcmV0dXJuIGkgPCBsZW4gPyB7dmFsdWU6IG9ialtrZXldLCBrZXk6IGtleX0gOiBudWxsO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGl0ZXJhdG9yKGNvbGwpIHtcbiAgICBpZiAoaXNBcnJheUxpa2UoY29sbCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFycmF5SXRlcmF0b3IoY29sbCk7XG4gICAgfVxuXG4gICAgdmFyIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoY29sbCk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yID8gY3JlYXRlRVMyMDE1SXRlcmF0b3IoaXRlcmF0b3IpIDogY3JlYXRlT2JqZWN0SXRlcmF0b3IoY29sbCk7XG59XG5cbmZ1bmN0aW9uIG9ubHlPbmNlKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZm4gPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIHdhcyBhbHJlYWR5IGNhbGxlZC5cIik7XG4gICAgICAgIHZhciBjYWxsRm4gPSBmbjtcbiAgICAgICAgZm4gPSBudWxsO1xuICAgICAgICBjYWxsRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBfZWFjaE9mTGltaXQobGltaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICAgICAgaWYgKGxpbWl0IDw9IDAgfHwgIW9iaikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXh0RWxlbSA9IGl0ZXJhdG9yKG9iaik7XG4gICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgIHZhciBydW5uaW5nID0gMDtcbiAgICAgICAgdmFyIGxvb3BpbmcgPSBmYWxzZTtcblxuICAgICAgICBmdW5jdGlvbiBpdGVyYXRlZUNhbGxiYWNrKGVyciwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJ1bm5pbmcgLT0gMTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IGJyZWFrTG9vcCB8fCAoZG9uZSAmJiBydW5uaW5nIDw9IDApKSB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWxvb3BpbmcpIHtcbiAgICAgICAgICAgICAgICByZXBsZW5pc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxlbmlzaCAoKSB7XG4gICAgICAgICAgICBsb29waW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChydW5uaW5nIDwgbGltaXQgJiYgIWRvbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IG5leHRFbGVtKCk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydW5uaW5nIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnVubmluZyArPSAxO1xuICAgICAgICAgICAgICAgIGl0ZXJhdGVlKGVsZW0udmFsdWUsIGVsZW0ua2V5LCBvbmx5T25jZShpdGVyYXRlZUNhbGxiYWNrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb29waW5nID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXBsZW5pc2goKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZWFjaE9mYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gKiB0aW1lLlxuICpcbiAqIEBuYW1lIGVhY2hPZkxpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5lYWNoT2Zde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNoT2Z9XG4gKiBAYWxpYXMgZm9yRWFjaE9mTGltaXRcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaFxuICogaXRlbSBpbiBgY29sbGAuIFRoZSBga2V5YCBpcyB0aGUgaXRlbSdzIGtleSwgb3IgaW5kZXggaW4gdGhlIGNhc2Ugb2YgYW5cbiAqIGFycmF5LlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBJbnZva2VkIHdpdGggKGVycikuXG4gKi9cbmZ1bmN0aW9uIGVhY2hPZkxpbWl0KGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBfZWFjaE9mTGltaXQobGltaXQpKGNvbGwsIHdyYXBBc3luYyhpdGVyYXRlZSksIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZG9MaW1pdChmbiwgbGltaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZuKGl0ZXJhYmxlLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbiAgICB9O1xufVxuXG4vLyBlYWNoT2YgaW1wbGVtZW50YXRpb24gb3B0aW1pemVkIGZvciBhcnJheS1saWtlc1xuZnVuY3Rpb24gZWFjaE9mQXJyYXlMaWtlKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICBjb21wbGV0ZWQgPSAwLFxuICAgICAgICBsZW5ndGggPSBjb2xsLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yQ2FsbGJhY2soZXJyLCB2YWx1ZSkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9IGVsc2UgaWYgKCgrK2NvbXBsZXRlZCA9PT0gbGVuZ3RoKSB8fCB2YWx1ZSA9PT0gYnJlYWtMb29wKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBpdGVyYXRlZShjb2xsW2luZGV4XSwgaW5kZXgsIG9ubHlPbmNlKGl0ZXJhdG9yQ2FsbGJhY2spKTtcbiAgICB9XG59XG5cbi8vIGEgZ2VuZXJpYyB2ZXJzaW9uIG9mIGVhY2hPZiB3aGljaCBjYW4gaGFuZGxlIGFycmF5LCBvYmplY3QsIGFuZCBpdGVyYXRvciBjYXNlcy5cbnZhciBlYWNoT2ZHZW5lcmljID0gZG9MaW1pdChlYWNoT2ZMaW1pdCwgSW5maW5pdHkpO1xuXG4vKipcbiAqIExpa2UgW2BlYWNoYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9LCBleGNlcHQgdGhhdCBpdCBwYXNzZXMgdGhlIGtleSAob3IgaW5kZXgpIGFzIHRoZSBzZWNvbmQgYXJndW1lbnRcbiAqIHRvIHRoZSBpdGVyYXRlZS5cbiAqXG4gKiBAbmFtZSBlYWNoT2ZcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBhbGlhcyBmb3JFYWNoT2ZcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAc2VlIFthc3luYy5lYWNoXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH1cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2hcbiAqIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGBrZXlgIGlzIHRoZSBpdGVtJ3Mga2V5LCBvciBpbmRleCBpbiB0aGUgY2FzZSBvZiBhbiBhcnJheS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqID0ge2RldjogXCIvZGV2Lmpzb25cIiwgdGVzdDogXCIvdGVzdC5qc29uXCIsIHByb2Q6IFwiL3Byb2QuanNvblwifTtcbiAqIHZhciBjb25maWdzID0ge307XG4gKlxuICogYXN5bmMuZm9yRWFjaE9mKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXksIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMucmVhZEZpbGUoX19kaXJuYW1lICsgdmFsdWUsIFwidXRmOFwiLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gKiAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICogICAgICAgICB0cnkge1xuICogICAgICAgICAgICAgY29uZmlnc1trZXldID0gSlNPTi5wYXJzZShkYXRhKTtcbiAqICAgICAgICAgfSBjYXRjaCAoZSkge1xuICogICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICogICAgICAgICB9XG4gKiAgICAgICAgIGNhbGxiYWNrKCk7XG4gKiAgICAgfSk7XG4gKiB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgaWYgKGVycikgY29uc29sZS5lcnJvcihlcnIubWVzc2FnZSk7XG4gKiAgICAgLy8gY29uZmlncyBpcyBub3cgYSBtYXAgb2YgSlNPTiBkYXRhXG4gKiAgICAgZG9Tb21ldGhpbmdXaXRoKGNvbmZpZ3MpO1xuICogfSk7XG4gKi9cbnZhciBlYWNoT2YgPSBmdW5jdGlvbihjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZWFjaE9mSW1wbGVtZW50YXRpb24gPSBpc0FycmF5TGlrZShjb2xsKSA/IGVhY2hPZkFycmF5TGlrZSA6IGVhY2hPZkdlbmVyaWM7XG4gICAgZWFjaE9mSW1wbGVtZW50YXRpb24oY29sbCwgd3JhcEFzeW5jKGl0ZXJhdGVlKSwgY2FsbGJhY2spO1xufTtcblxuZnVuY3Rpb24gZG9QYXJhbGxlbChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZuKGVhY2hPZiwgb2JqLCB3cmFwQXN5bmMoaXRlcmF0ZWUpLCBjYWxsYmFjayk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gX2FzeW5jTWFwKGVhY2hmbiwgYXJyLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gICAgYXJyID0gYXJyIHx8IFtdO1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuXG4gICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHZhbHVlLCBfLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaW5kZXggPSBjb3VudGVyKys7XG4gICAgICAgIF9pdGVyYXRlZSh2YWx1ZSwgZnVuY3Rpb24gKGVyciwgdikge1xuICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSB2O1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFByb2R1Y2VzIGEgbmV3IGNvbGxlY3Rpb24gb2YgdmFsdWVzIGJ5IG1hcHBpbmcgZWFjaCB2YWx1ZSBpbiBgY29sbGAgdGhyb3VnaFxuICogdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24uIFRoZSBgaXRlcmF0ZWVgIGlzIGNhbGxlZCB3aXRoIGFuIGl0ZW0gZnJvbSBgY29sbGBcbiAqIGFuZCBhIGNhbGxiYWNrIGZvciB3aGVuIGl0IGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nLiBFYWNoIG9mIHRoZXNlIGNhbGxiYWNrXG4gKiB0YWtlcyAyIGFyZ3VtZW50czogYW4gYGVycm9yYCwgYW5kIHRoZSB0cmFuc2Zvcm1lZCBpdGVtIGZyb20gYGNvbGxgLiBJZlxuICogYGl0ZXJhdGVlYCBwYXNzZXMgYW4gZXJyb3IgdG8gaXRzIGNhbGxiYWNrLCB0aGUgbWFpbiBgY2FsbGJhY2tgIChmb3IgdGhlXG4gKiBgbWFwYCBmdW5jdGlvbikgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLlxuICpcbiAqIE5vdGUsIHRoYXQgc2luY2UgdGhpcyBmdW5jdGlvbiBhcHBsaWVzIHRoZSBgaXRlcmF0ZWVgIHRvIGVhY2ggaXRlbSBpblxuICogcGFyYWxsZWwsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyB3aWxsIGNvbXBsZXRlXG4gKiBpbiBvcmRlci4gSG93ZXZlciwgdGhlIHJlc3VsdHMgYXJyYXkgd2lsbCBiZSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbiAqIG9yaWdpbmFsIGBjb2xsYC5cbiAqXG4gKiBJZiBgbWFwYCBpcyBwYXNzZWQgYW4gT2JqZWN0LCB0aGUgcmVzdWx0cyB3aWxsIGJlIGFuIEFycmF5LiAgVGhlIHJlc3VsdHNcbiAqIHdpbGwgcm91Z2hseSBiZSBpbiB0aGUgb3JkZXIgb2YgdGhlIG9yaWdpbmFsIE9iamVjdHMnIGtleXMgKGJ1dCB0aGlzIGNhblxuICogdmFyeSBhY3Jvc3MgSmF2YVNjcmlwdCBlbmdpbmVzKS5cbiAqXG4gKiBAbmFtZSBtYXBcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIGl0ZW0uXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIEFycmF5IG9mIHRoZVxuICogdHJhbnNmb3JtZWQgaXRlbXMgZnJvbSB0aGUgYGNvbGxgLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLm1hcChbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmcy5zdGF0LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAvLyByZXN1bHRzIGlzIG5vdyBhbiBhcnJheSBvZiBzdGF0cyBmb3IgZWFjaCBmaWxlXG4gKiB9KTtcbiAqL1xudmFyIG1hcCA9IGRvUGFyYWxsZWwoX2FzeW5jTWFwKTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBwcm92aWRlZCBhcmd1bWVudHMgdG8gZWFjaCBmdW5jdGlvbiBpbiB0aGUgYXJyYXksIGNhbGxpbmdcbiAqIGBjYWxsYmFja2AgYWZ0ZXIgYWxsIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZC4gSWYgeW91IG9ubHkgcHJvdmlkZSB0aGUgZmlyc3RcbiAqIGFyZ3VtZW50LCBgZm5zYCwgdGhlbiBpdCB3aWxsIHJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIGxldHMgeW91IHBhc3MgaW4gdGhlXG4gKiBhcmd1bWVudHMgYXMgaWYgaXQgd2VyZSBhIHNpbmdsZSBmdW5jdGlvbiBjYWxsLiBJZiBtb3JlIGFyZ3VtZW50cyBhcmVcbiAqIHByb3ZpZGVkLCBgY2FsbGJhY2tgIGlzIHJlcXVpcmVkIHdoaWxlIGBhcmdzYCBpcyBzdGlsbCBvcHRpb25hbC5cbiAqXG4gKiBAbmFtZSBhcHBseUVhY2hcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBmbnMgLSBBIGNvbGxlY3Rpb24gb2Yge0BsaW5rIEFzeW5jRnVuY3Rpb259c1xuICogdG8gYWxsIGNhbGwgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHNcbiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIC0gYW55IG51bWJlciBvZiBzZXBhcmF0ZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGVcbiAqIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIHRoZSBmaW5hbCBhcmd1bWVudCBzaG91bGQgYmUgdGhlIGNhbGxiYWNrLFxuICogY2FsbGVkIHdoZW4gYWxsIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZCBwcm9jZXNzaW5nLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIElmIG9ubHkgdGhlIGZpcnN0IGFyZ3VtZW50LCBgZm5zYCwgaXMgcHJvdmlkZWQsIGl0IHdpbGxcbiAqIHJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIGxldHMgeW91IHBhc3MgaW4gdGhlIGFyZ3VtZW50cyBhcyBpZiBpdCB3ZXJlIGEgc2luZ2xlXG4gKiBmdW5jdGlvbiBjYWxsLiBUaGUgc2lnbmF0dXJlIGlzIGAoLi5hcmdzLCBjYWxsYmFjaylgLiBJZiBpbnZva2VkIHdpdGggYW55XG4gKiBhcmd1bWVudHMsIGBjYWxsYmFja2AgaXMgcmVxdWlyZWQuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLmFwcGx5RWFjaChbZW5hYmxlU2VhcmNoLCB1cGRhdGVTY2hlbWFdLCAnYnVja2V0JywgY2FsbGJhY2spO1xuICpcbiAqIC8vIHBhcnRpYWwgYXBwbGljYXRpb24gZXhhbXBsZTpcbiAqIGFzeW5jLmVhY2goXG4gKiAgICAgYnVja2V0cyxcbiAqICAgICBhc3luYy5hcHBseUVhY2goW2VuYWJsZVNlYXJjaCwgdXBkYXRlU2NoZW1hXSksXG4gKiAgICAgY2FsbGJhY2tcbiAqICk7XG4gKi9cbnZhciBhcHBseUVhY2ggPSBhcHBseUVhY2gkMShtYXApO1xuXG5mdW5jdGlvbiBkb1BhcmFsbGVsTGltaXQoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZm4oX2VhY2hPZkxpbWl0KGxpbWl0KSwgb2JqLCB3cmFwQXN5bmMoaXRlcmF0ZWUpLCBjYWxsYmFjayk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIG1hcExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5tYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCBpdGVtLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyBhbiBhcnJheSBvZiB0aGVcbiAqIHRyYW5zZm9ybWVkIGl0ZW1zIGZyb20gdGhlIGBjb2xsYC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICovXG52YXIgbWFwTGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2FzeW5jTWFwKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBtYXBTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLm1hcF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH1cbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIGl0ZW0uXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5IG9mIHRoZVxuICogdHJhbnNmb3JtZWQgaXRlbXMgZnJvbSB0aGUgYGNvbGxgLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKi9cbnZhciBtYXBTZXJpZXMgPSBkb0xpbWl0KG1hcExpbWl0LCAxKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGFwcGx5RWFjaGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5hcHBseUVhY2h9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBhcHBseUVhY2hTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmFwcGx5RWFjaF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmFwcGx5RWFjaH1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBmbnMgLSBBIGNvbGxlY3Rpb24gb2Yge0BsaW5rIEFzeW5jRnVuY3Rpb259cyB0byBhbGxcbiAqIGNhbGwgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHNcbiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIC0gYW55IG51bWJlciBvZiBzZXBhcmF0ZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGVcbiAqIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIHRoZSBmaW5hbCBhcmd1bWVudCBzaG91bGQgYmUgdGhlIGNhbGxiYWNrLFxuICogY2FsbGVkIHdoZW4gYWxsIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZCBwcm9jZXNzaW5nLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIElmIG9ubHkgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBpdCB3aWxsIHJldHVyblxuICogYSBmdW5jdGlvbiB3aGljaCBsZXRzIHlvdSBwYXNzIGluIHRoZSBhcmd1bWVudHMgYXMgaWYgaXQgd2VyZSBhIHNpbmdsZVxuICogZnVuY3Rpb24gY2FsbC5cbiAqL1xudmFyIGFwcGx5RWFjaFNlcmllcyA9IGFwcGx5RWFjaCQxKG1hcFNlcmllcyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGJlc3Qgb3JkZXIgZm9yIHJ1bm5pbmcgdGhlIHtAbGluayBBc3luY0Z1bmN0aW9ufXMgaW4gYHRhc2tzYCwgYmFzZWQgb25cbiAqIHRoZWlyIHJlcXVpcmVtZW50cy4gRWFjaCBmdW5jdGlvbiBjYW4gb3B0aW9uYWxseSBkZXBlbmQgb24gb3RoZXIgZnVuY3Rpb25zXG4gKiBiZWluZyBjb21wbGV0ZWQgZmlyc3QsIGFuZCBlYWNoIGZ1bmN0aW9uIGlzIHJ1biBhcyBzb29uIGFzIGl0cyByZXF1aXJlbWVudHNcbiAqIGFyZSBzYXRpc2ZpZWQuXG4gKlxuICogSWYgYW55IG9mIHRoZSB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIHBhc3MgYW4gZXJyb3IgdG8gdGhlaXIgY2FsbGJhY2ssIHRoZSBgYXV0b2Agc2VxdWVuY2VcbiAqIHdpbGwgc3RvcC4gRnVydGhlciB0YXNrcyB3aWxsIG5vdCBleGVjdXRlIChzbyBhbnkgb3RoZXIgZnVuY3Rpb25zIGRlcGVuZGluZ1xuICogb24gaXQgd2lsbCBub3QgcnVuKSwgYW5kIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlXG4gKiBlcnJvci5cbiAqXG4gKiB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIGFsc28gcmVjZWl2ZSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVzdWx0cyBvZiBmdW5jdGlvbnMgd2hpY2hcbiAqIGhhdmUgY29tcGxldGVkIHNvIGZhciBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIGlmIHRoZXkgaGF2ZSBkZXBlbmRlbmNpZXMuIElmIGFcbiAqIHRhc2sgZnVuY3Rpb24gaGFzIG5vIGRlcGVuZGVuY2llcywgaXQgd2lsbCBvbmx5IGJlIHBhc3NlZCBhIGNhbGxiYWNrLlxuICpcbiAqIEBuYW1lIGF1dG9cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXNrcyAtIEFuIG9iamVjdC4gRWFjaCBvZiBpdHMgcHJvcGVydGllcyBpcyBlaXRoZXIgYVxuICogZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2YgcmVxdWlyZW1lbnRzLCB3aXRoIHRoZSB7QGxpbmsgQXN5bmNGdW5jdGlvbn0gaXRzZWxmIHRoZSBsYXN0IGl0ZW1cbiAqIGluIHRoZSBhcnJheS4gVGhlIG9iamVjdCdzIGtleSBvZiBhIHByb3BlcnR5IHNlcnZlcyBhcyB0aGUgbmFtZSBvZiB0aGUgdGFza1xuICogZGVmaW5lZCBieSB0aGF0IHByb3BlcnR5LCBpLmUuIGNhbiBiZSB1c2VkIHdoZW4gc3BlY2lmeWluZyByZXF1aXJlbWVudHMgZm9yXG4gKiBvdGhlciB0YXNrcy4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIG9uZSBvciB0d28gYXJndW1lbnRzOlxuICogKiBhIGByZXN1bHRzYCBvYmplY3QsIGNvbnRhaW5pbmcgdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzbHkgZXhlY3V0ZWRcbiAqICAgZnVuY3Rpb25zLCBvbmx5IHBhc3NlZCBpZiB0aGUgdGFzayBoYXMgYW55IGRlcGVuZGVuY2llcyxcbiAqICogYSBgY2FsbGJhY2soZXJyLCByZXN1bHQpYCBmdW5jdGlvbiwgd2hpY2ggbXVzdCBiZSBjYWxsZWQgd2hlbiBmaW5pc2hlZCxcbiAqICAgcGFzc2luZyBhbiBgZXJyb3JgICh3aGljaCBjYW4gYmUgYG51bGxgKSBhbmQgdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24nc1xuICogICBleGVjdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbmN5PUluZmluaXR5XSAtIEFuIG9wdGlvbmFsIGBpbnRlZ2VyYCBmb3JcbiAqIGRldGVybWluaW5nIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0YXNrcyB0aGF0IGNhbiBiZSBydW4gaW4gcGFyYWxsZWwuIEJ5XG4gKiBkZWZhdWx0LCBhcyBtYW55IGFzIHBvc3NpYmxlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICogdGhlIHRhc2tzIGhhdmUgYmVlbiBjb21wbGV0ZWQuIEl0IHJlY2VpdmVzIHRoZSBgZXJyYCBhcmd1bWVudCBpZiBhbnkgYHRhc2tzYFxuICogcGFzcyBhbiBlcnJvciB0byB0aGVpciBjYWxsYmFjay4gUmVzdWx0cyBhcmUgYWx3YXlzIHJldHVybmVkOyBob3dldmVyLCBpZiBhblxuICogZXJyb3Igb2NjdXJzLCBubyBmdXJ0aGVyIGB0YXNrc2Agd2lsbCBiZSBwZXJmb3JtZWQsIGFuZCB0aGUgcmVzdWx0cyBvYmplY3RcbiAqIHdpbGwgb25seSBjb250YWluIHBhcnRpYWwgcmVzdWx0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMgdW5kZWZpbmVkXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLmF1dG8oe1xuICogICAgIC8vIHRoaXMgZnVuY3Rpb24gd2lsbCBqdXN0IGJlIHBhc3NlZCBhIGNhbGxiYWNrXG4gKiAgICAgcmVhZERhdGE6IGFzeW5jLmFwcGx5KGZzLnJlYWRGaWxlLCAnZGF0YS50eHQnLCAndXRmLTgnKSxcbiAqICAgICBzaG93RGF0YTogWydyZWFkRGF0YScsIGZ1bmN0aW9uKHJlc3VsdHMsIGNiKSB7XG4gKiAgICAgICAgIC8vIHJlc3VsdHMucmVhZERhdGEgaXMgdGhlIGZpbGUncyBjb250ZW50c1xuICogICAgICAgICAvLyAuLi5cbiAqICAgICB9XVxuICogfSwgY2FsbGJhY2spO1xuICpcbiAqIGFzeW5jLmF1dG8oe1xuICogICAgIGdldF9kYXRhOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBjb25zb2xlLmxvZygnaW4gZ2V0X2RhdGEnKTtcbiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBnZXQgc29tZSBkYXRhXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdkYXRhJywgJ2NvbnZlcnRlZCB0byBhcnJheScpO1xuICogICAgIH0sXG4gKiAgICAgbWFrZV9mb2xkZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCdpbiBtYWtlX2ZvbGRlcicpO1xuICogICAgICAgICAvLyBhc3luYyBjb2RlIHRvIGNyZWF0ZSBhIGRpcmVjdG9yeSB0byBzdG9yZSBhIGZpbGUgaW5cbiAqICAgICAgICAgLy8gdGhpcyBpcyBydW4gYXQgdGhlIHNhbWUgdGltZSBhcyBnZXR0aW5nIHRoZSBkYXRhXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmb2xkZXInKTtcbiAqICAgICB9LFxuICogICAgIHdyaXRlX2ZpbGU6IFsnZ2V0X2RhdGEnLCAnbWFrZV9mb2xkZXInLCBmdW5jdGlvbihyZXN1bHRzLCBjYWxsYmFjaykge1xuICogICAgICAgICBjb25zb2xlLmxvZygnaW4gd3JpdGVfZmlsZScsIEpTT04uc3RyaW5naWZ5KHJlc3VsdHMpKTtcbiAqICAgICAgICAgLy8gb25jZSB0aGVyZSBpcyBzb21lIGRhdGEgYW5kIHRoZSBkaXJlY3RvcnkgZXhpc3RzLFxuICogICAgICAgICAvLyB3cml0ZSB0aGUgZGF0YSB0byBhIGZpbGUgaW4gdGhlIGRpcmVjdG9yeVxuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZmlsZW5hbWUnKTtcbiAqICAgICB9XSxcbiAqICAgICBlbWFpbF9saW5rOiBbJ3dyaXRlX2ZpbGUnLCBmdW5jdGlvbihyZXN1bHRzLCBjYWxsYmFjaykge1xuICogICAgICAgICBjb25zb2xlLmxvZygnaW4gZW1haWxfbGluaycsIEpTT04uc3RyaW5naWZ5KHJlc3VsdHMpKTtcbiAqICAgICAgICAgLy8gb25jZSB0aGUgZmlsZSBpcyB3cml0dGVuIGxldCdzIGVtYWlsIGEgbGluayB0byBpdC4uLlxuICogICAgICAgICAvLyByZXN1bHRzLndyaXRlX2ZpbGUgY29udGFpbnMgdGhlIGZpbGVuYW1lIHJldHVybmVkIGJ5IHdyaXRlX2ZpbGUuXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6cmVzdWx0cy53cml0ZV9maWxlLCAnZW1haWwnOid1c2VyQGV4YW1wbGUuY29tJ30pO1xuICogICAgIH1dXG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZXJyID0gJywgZXJyKTtcbiAqICAgICBjb25zb2xlLmxvZygncmVzdWx0cyA9ICcsIHJlc3VsdHMpO1xuICogfSk7XG4gKi9cbnZhciBhdXRvID0gZnVuY3Rpb24gKHRhc2tzLCBjb25jdXJyZW5jeSwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNvbmN1cnJlbmN5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGNvbmN1cnJlbmN5IGlzIG9wdGlvbmFsLCBzaGlmdCB0aGUgYXJncy5cbiAgICAgICAgY2FsbGJhY2sgPSBjb25jdXJyZW5jeTtcbiAgICAgICAgY29uY3VycmVuY3kgPSBudWxsO1xuICAgIH1cbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgdmFyIGtleXMkJDEgPSBrZXlzKHRhc2tzKTtcbiAgICB2YXIgbnVtVGFza3MgPSBrZXlzJCQxLmxlbmd0aDtcbiAgICBpZiAoIW51bVRhc2tzKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG4gICAgaWYgKCFjb25jdXJyZW5jeSkge1xuICAgICAgICBjb25jdXJyZW5jeSA9IG51bVRhc2tzO1xuICAgIH1cblxuICAgIHZhciByZXN1bHRzID0ge307XG4gICAgdmFyIHJ1bm5pbmdUYXNrcyA9IDA7XG4gICAgdmFyIGhhc0Vycm9yID0gZmFsc2U7XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHZhciByZWFkeVRhc2tzID0gW107XG5cbiAgICAvLyBmb3IgY3ljbGUgZGV0ZWN0aW9uOlxuICAgIHZhciByZWFkeVRvQ2hlY2sgPSBbXTsgLy8gdGFza3MgdGhhdCBoYXZlIGJlZW4gaWRlbnRpZmllZCBhcyByZWFjaGFibGVcbiAgICAvLyB3aXRob3V0IHRoZSBwb3NzaWJpbGl0eSBvZiByZXR1cm5pbmcgdG8gYW4gYW5jZXN0b3IgdGFza1xuICAgIHZhciB1bmNoZWNrZWREZXBlbmRlbmNpZXMgPSB7fTtcblxuICAgIGJhc2VGb3JPd24odGFza3MsIGZ1bmN0aW9uICh0YXNrLCBrZXkpIHtcbiAgICAgICAgaWYgKCFpc0FycmF5KHRhc2spKSB7XG4gICAgICAgICAgICAvLyBubyBkZXBlbmRlbmNpZXNcbiAgICAgICAgICAgIGVucXVldWVUYXNrKGtleSwgW3Rhc2tdKTtcbiAgICAgICAgICAgIHJlYWR5VG9DaGVjay5wdXNoKGtleSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gdGFzay5zbGljZSgwLCB0YXNrLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgcmVtYWluaW5nRGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzLmxlbmd0aDtcbiAgICAgICAgaWYgKHJlbWFpbmluZ0RlcGVuZGVuY2llcyA9PT0gMCkge1xuICAgICAgICAgICAgZW5xdWV1ZVRhc2soa2V5LCB0YXNrKTtcbiAgICAgICAgICAgIHJlYWR5VG9DaGVjay5wdXNoKGtleSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdW5jaGVja2VkRGVwZW5kZW5jaWVzW2tleV0gPSByZW1haW5pbmdEZXBlbmRlbmNpZXM7XG5cbiAgICAgICAgYXJyYXlFYWNoKGRlcGVuZGVuY2llcywgZnVuY3Rpb24gKGRlcGVuZGVuY3lOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIXRhc2tzW2RlcGVuZGVuY3lOYW1lXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXN5bmMuYXV0byB0YXNrIGAnICsga2V5ICtcbiAgICAgICAgICAgICAgICAgICAgJ2AgaGFzIGEgbm9uLWV4aXN0ZW50IGRlcGVuZGVuY3kgYCcgK1xuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5TmFtZSArICdgIGluICcgK1xuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMuam9pbignLCAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRMaXN0ZW5lcihkZXBlbmRlbmN5TmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZ0RlcGVuZGVuY2llcy0tO1xuICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmdEZXBlbmRlbmNpZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZW5xdWV1ZVRhc2soa2V5LCB0YXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjaGVja0ZvckRlYWRsb2NrcygpO1xuICAgIHByb2Nlc3NRdWV1ZSgpO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZVRhc2soa2V5LCB0YXNrKSB7XG4gICAgICAgIHJlYWR5VGFza3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBydW5UYXNrKGtleSwgdGFzayk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NRdWV1ZSgpIHtcbiAgICAgICAgaWYgKHJlYWR5VGFza3MubGVuZ3RoID09PSAwICYmIHJ1bm5pbmdUYXNrcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlKHJlYWR5VGFza3MubGVuZ3RoICYmIHJ1bm5pbmdUYXNrcyA8IGNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICB2YXIgcnVuID0gcmVhZHlUYXNrcy5zaGlmdCgpO1xuICAgICAgICAgICAgcnVuKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZExpc3RlbmVyKHRhc2tOYW1lLCBmbikge1xuICAgICAgICB2YXIgdGFza0xpc3RlbmVycyA9IGxpc3RlbmVyc1t0YXNrTmFtZV07XG4gICAgICAgIGlmICghdGFza0xpc3RlbmVycykge1xuICAgICAgICAgICAgdGFza0xpc3RlbmVycyA9IGxpc3RlbmVyc1t0YXNrTmFtZV0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhc2tMaXN0ZW5lcnMucHVzaChmbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGFza0NvbXBsZXRlKHRhc2tOYW1lKSB7XG4gICAgICAgIHZhciB0YXNrTGlzdGVuZXJzID0gbGlzdGVuZXJzW3Rhc2tOYW1lXSB8fCBbXTtcbiAgICAgICAgYXJyYXlFYWNoKHRhc2tMaXN0ZW5lcnMsIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2Nlc3NRdWV1ZSgpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gcnVuVGFzayhrZXksIHRhc2spIHtcbiAgICAgICAgaWYgKGhhc0Vycm9yKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHRhc2tDYWxsYmFjayA9IG9ubHlPbmNlKGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gICAgICAgICAgICBydW5uaW5nVGFza3MtLTtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNhZmVSZXN1bHRzID0ge307XG4gICAgICAgICAgICAgICAgYmFzZUZvck93bihyZXN1bHRzLCBmdW5jdGlvbih2YWwsIHJrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNbcmtleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgc2FmZVJlc3VsdHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgdGFza0NvbXBsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJ1bm5pbmdUYXNrcysrO1xuICAgICAgICB2YXIgdGFza0ZuID0gd3JhcEFzeW5jKHRhc2tbdGFzay5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmICh0YXNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRhc2tGbihyZXN1bHRzLCB0YXNrQ2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFza0ZuKHRhc2tDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0ZvckRlYWRsb2NrcygpIHtcbiAgICAgICAgLy8gS2FobidzIGFsZ29yaXRobVxuICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub3BvbG9naWNhbF9zb3J0aW5nI0thaG4uMjdzX2FsZ29yaXRobVxuICAgICAgICAvLyBodHRwOi8vY29ubmFsbGUuYmxvZ3Nwb3QuY29tLzIwMTMvMTAvdG9wb2xvZ2ljYWwtc29ydGluZ2thaG4tYWxnb3JpdGhtLmh0bWxcbiAgICAgICAgdmFyIGN1cnJlbnRUYXNrO1xuICAgICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICAgIHdoaWxlIChyZWFkeVRvQ2hlY2subGVuZ3RoKSB7XG4gICAgICAgICAgICBjdXJyZW50VGFzayA9IHJlYWR5VG9DaGVjay5wb3AoKTtcbiAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgICAgIGFycmF5RWFjaChnZXREZXBlbmRlbnRzKGN1cnJlbnRUYXNrKSwgZnVuY3Rpb24gKGRlcGVuZGVudCkge1xuICAgICAgICAgICAgICAgIGlmICgtLXVuY2hlY2tlZERlcGVuZGVuY2llc1tkZXBlbmRlbnRdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWR5VG9DaGVjay5wdXNoKGRlcGVuZGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY291bnRlciAhPT0gbnVtVGFza3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnYXN5bmMuYXV0byBjYW5ub3QgZXhlY3V0ZSB0YXNrcyBkdWUgdG8gYSByZWN1cnNpdmUgZGVwZW5kZW5jeSdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREZXBlbmRlbnRzKHRhc2tOYW1lKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgYmFzZUZvck93bih0YXNrcywgZnVuY3Rpb24gKHRhc2ssIGtleSkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodGFzaykgJiYgYmFzZUluZGV4T2YodGFzaywgdGFza05hbWUsIDApID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sJDEgPyBTeW1ib2wkMS5wcm90b3R5cGUgOiB1bmRlZmluZWQ7XG52YXIgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gIH1cbiAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5ndGg7XG4gIH1cbiAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICBzdGFydCA+Pj49IDA7XG5cbiAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gKi9cbmZ1bmN0aW9uIGNhc3RTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZDtcbiAgcmV0dXJuICghc3RhcnQgJiYgZW5kID49IGxlbmd0aCkgPyBhcnJheSA6IGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG59XG5cbi8qKlxuICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBzdHJpbmcgc3ltYm9sXG4gKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gKi9cbmZ1bmN0aW9uIGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICB2YXIgaW5kZXggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICB3aGlsZSAoaW5kZXgtLSAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cbiAgcmV0dXJuIGluZGV4O1xufVxuXG4vKipcbiAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1TdGFydGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgc3RyaW5nIHN5bWJvbFxuICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAqL1xuZnVuY3Rpb24gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cbiAgcmV0dXJuIGluZGV4O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xufVxuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJztcbnZhciByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJztcbnZhciByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZic7XG52YXIgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJztcbnZhciByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2U7XG52YXIgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG52YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbn1cblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UkMSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJztcbnZhciByc0NvbWJvTWFya3NSYW5nZSQxID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnO1xudmFyIHJlQ29tYm9IYWxmTWFya3NSYW5nZSQxID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnO1xudmFyIHJzQ29tYm9TeW1ib2xzUmFuZ2UkMSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJztcbnZhciByc0NvbWJvUmFuZ2UkMSA9IHJzQ29tYm9NYXJrc1JhbmdlJDEgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UkMTtcbnZhciByc1ZhclJhbmdlJDEgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSQxICsgJ10nO1xudmFyIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UkMSArICddJztcbnZhciByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJztcbnZhciByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknO1xudmFyIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UkMSArICddJztcbnZhciByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nO1xudmFyIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJztcbnZhciByc1pXSiQxID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JztcbnZhciByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UkMSArICddPyc7XG52YXIgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiQxICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonO1xudmFyIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbjtcbnZhciByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbnZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICA/IHVuaWNvZGVUb0FycmF5KHN0cmluZylcbiAgICA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKlxuICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50cmltKCcgIGFiYyAgJyk7XG4gKiAvLyA9PiAnYWJjJ1xuICpcbiAqIF8udHJpbSgnLV8tYWJjLV8tJywgJ18tJyk7XG4gKiAvLyA9PiAnYWJjJ1xuICpcbiAqIF8ubWFwKFsnICBmb28gICcsICcgIGJhciAgJ10sIF8udHJpbSk7XG4gKiAvLyA9PiBbJ2ZvbycsICdiYXInXVxuICovXG5mdW5jdGlvbiB0cmltKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB9XG4gIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cbiAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICBjaHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShjaGFycyksXG4gICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSxcbiAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykgKyAxO1xuXG4gIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQsIGVuZCkuam9pbignJyk7XG59XG5cbnZhciBGTl9BUkdTID0gL14oPzphc3luY1xccyspPyhmdW5jdGlvbik/XFxzKlteXFwoXSpcXChcXHMqKFteXFwpXSopXFwpL207XG52YXIgRk5fQVJHX1NQTElUID0gLywvO1xudmFyIEZOX0FSRyA9IC8oPS4rKT8oXFxzKikkLztcbnZhciBTVFJJUF9DT01NRU5UUyA9IC8oKFxcL1xcLy4qJCl8KFxcL1xcKltcXHNcXFNdKj9cXCpcXC8pKS9tZztcblxuZnVuY3Rpb24gcGFyc2VQYXJhbXMoZnVuYykge1xuICAgIGZ1bmMgPSBmdW5jLnRvU3RyaW5nKCkucmVwbGFjZShTVFJJUF9DT01NRU5UUywgJycpO1xuICAgIGZ1bmMgPSBmdW5jLm1hdGNoKEZOX0FSR1MpWzJdLnJlcGxhY2UoJyAnLCAnJyk7XG4gICAgZnVuYyA9IGZ1bmMgPyBmdW5jLnNwbGl0KEZOX0FSR19TUExJVCkgOiBbXTtcbiAgICBmdW5jID0gZnVuYy5tYXAoZnVuY3Rpb24gKGFyZyl7XG4gICAgICAgIHJldHVybiB0cmltKGFyZy5yZXBsYWNlKEZOX0FSRywgJycpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuYztcbn1cblxuLyoqXG4gKiBBIGRlcGVuZGVuY3ktaW5qZWN0ZWQgdmVyc2lvbiBvZiB0aGUgW2FzeW5jLmF1dG9de0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5hdXRvfSBmdW5jdGlvbi4gRGVwZW5kZW50XG4gKiB0YXNrcyBhcmUgc3BlY2lmaWVkIGFzIHBhcmFtZXRlcnMgdG8gdGhlIGZ1bmN0aW9uLCBhZnRlciB0aGUgdXN1YWwgY2FsbGJhY2tcbiAqIHBhcmFtZXRlciwgd2l0aCB0aGUgcGFyYW1ldGVyIG5hbWVzIG1hdGNoaW5nIHRoZSBuYW1lcyBvZiB0aGUgdGFza3MgaXRcbiAqIGRlcGVuZHMgb24uIFRoaXMgY2FuIHByb3ZpZGUgZXZlbiBtb3JlIHJlYWRhYmxlIHRhc2sgZ3JhcGhzIHdoaWNoIGNhbiBiZVxuICogZWFzaWVyIHRvIG1haW50YWluLlxuICpcbiAqIElmIGEgZmluYWwgY2FsbGJhY2sgaXMgc3BlY2lmaWVkLCB0aGUgdGFzayByZXN1bHRzIGFyZSBzaW1pbGFybHkgaW5qZWN0ZWQsXG4gKiBzcGVjaWZpZWQgYXMgbmFtZWQgcGFyYW1ldGVycyBhZnRlciB0aGUgaW5pdGlhbCBlcnJvciBwYXJhbWV0ZXIuXG4gKlxuICogVGhlIGF1dG9JbmplY3QgZnVuY3Rpb24gaXMgcHVyZWx5IHN5bnRhY3RpYyBzdWdhciBhbmQgaXRzIHNlbWFudGljcyBhcmVcbiAqIG90aGVyd2lzZSBlcXVpdmFsZW50IHRvIFthc3luYy5hdXRvXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXV0b30uXG4gKlxuICogQG5hbWUgYXV0b0luamVjdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuYXV0b117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmF1dG99XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge09iamVjdH0gdGFza3MgLSBBbiBvYmplY3QsIGVhY2ggb2Ygd2hvc2UgcHJvcGVydGllcyBpcyBhbiB7QGxpbmsgQXN5bmNGdW5jdGlvbn0gb2ZcbiAqIHRoZSBmb3JtICdmdW5jKFtkZXBlbmRlbmNpZXMuLi5dLCBjYWxsYmFjaykuIFRoZSBvYmplY3QncyBrZXkgb2YgYSBwcm9wZXJ0eVxuICogc2VydmVzIGFzIHRoZSBuYW1lIG9mIHRoZSB0YXNrIGRlZmluZWQgYnkgdGhhdCBwcm9wZXJ0eSwgaS5lLiBjYW4gYmUgdXNlZFxuICogd2hlbiBzcGVjaWZ5aW5nIHJlcXVpcmVtZW50cyBmb3Igb3RoZXIgdGFza3MuXG4gKiAqIFRoZSBgY2FsbGJhY2tgIHBhcmFtZXRlciBpcyBhIGBjYWxsYmFjayhlcnIsIHJlc3VsdClgIHdoaWNoIG11c3QgYmUgY2FsbGVkXG4gKiAgIHdoZW4gZmluaXNoZWQsIHBhc3NpbmcgYW4gYGVycm9yYCAod2hpY2ggY2FuIGJlIGBudWxsYCkgYW5kIHRoZSByZXN1bHQgb2ZcbiAqICAgdGhlIGZ1bmN0aW9uJ3MgZXhlY3V0aW9uLiBUaGUgcmVtYWluaW5nIHBhcmFtZXRlcnMgbmFtZSBvdGhlciB0YXNrcyBvblxuICogICB3aGljaCB0aGUgdGFzayBpcyBkZXBlbmRlbnQsIGFuZCB0aGUgcmVzdWx0cyBmcm9tIHRob3NlIHRhc2tzIGFyZSB0aGVcbiAqICAgYXJndW1lbnRzIG9mIHRob3NlIHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiB0aGUgdGFza3MgaGF2ZSBiZWVuIGNvbXBsZXRlZC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgIGFyZ3VtZW50IGlmIGFueSBgdGFza3NgXG4gKiBwYXNzIGFuIGVycm9yIHRvIHRoZWlyIGNhbGxiYWNrLCBhbmQgYSBgcmVzdWx0c2Agb2JqZWN0IHdpdGggYW55IGNvbXBsZXRlZFxuICogdGFzayByZXN1bHRzLCBzaW1pbGFyIHRvIGBhdXRvYC5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gIFRoZSBleGFtcGxlIGZyb20gYGF1dG9gIGNhbiBiZSByZXdyaXR0ZW4gYXMgZm9sbG93czpcbiAqIGFzeW5jLmF1dG9JbmplY3Qoe1xuICogICAgIGdldF9kYXRhOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAvLyBhc3luYyBjb2RlIHRvIGdldCBzb21lIGRhdGFcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RhdGEnLCAnY29udmVydGVkIHRvIGFycmF5Jyk7XG4gKiAgICAgfSxcbiAqICAgICBtYWtlX2ZvbGRlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBjcmVhdGUgYSBkaXJlY3RvcnkgdG8gc3RvcmUgYSBmaWxlIGluXG4gKiAgICAgICAgIC8vIHRoaXMgaXMgcnVuIGF0IHRoZSBzYW1lIHRpbWUgYXMgZ2V0dGluZyB0aGUgZGF0YVxuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZm9sZGVyJyk7XG4gKiAgICAgfSxcbiAqICAgICB3cml0ZV9maWxlOiBmdW5jdGlvbihnZXRfZGF0YSwgbWFrZV9mb2xkZXIsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIG9uY2UgdGhlcmUgaXMgc29tZSBkYXRhIGFuZCB0aGUgZGlyZWN0b3J5IGV4aXN0cyxcbiAqICAgICAgICAgLy8gd3JpdGUgdGhlIGRhdGEgdG8gYSBmaWxlIGluIHRoZSBkaXJlY3RvcnlcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZpbGVuYW1lJyk7XG4gKiAgICAgfSxcbiAqICAgICBlbWFpbF9saW5rOiBmdW5jdGlvbih3cml0ZV9maWxlLCBjYWxsYmFjaykge1xuICogICAgICAgICAvLyBvbmNlIHRoZSBmaWxlIGlzIHdyaXR0ZW4gbGV0J3MgZW1haWwgYSBsaW5rIHRvIGl0Li4uXG4gKiAgICAgICAgIC8vIHdyaXRlX2ZpbGUgY29udGFpbnMgdGhlIGZpbGVuYW1lIHJldHVybmVkIGJ5IHdyaXRlX2ZpbGUuXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6d3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTtcbiAqICAgICB9XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZXJyID0gJywgZXJyKTtcbiAqICAgICBjb25zb2xlLmxvZygnZW1haWxfbGluayA9ICcsIHJlc3VsdHMuZW1haWxfbGluayk7XG4gKiB9KTtcbiAqXG4gKiAvLyBJZiB5b3UgYXJlIHVzaW5nIGEgSlMgbWluaWZpZXIgdGhhdCBtYW5nbGVzIHBhcmFtZXRlciBuYW1lcywgYGF1dG9JbmplY3RgXG4gKiAvLyB3aWxsIG5vdCB3b3JrIHdpdGggcGxhaW4gZnVuY3Rpb25zLCBzaW5jZSB0aGUgcGFyYW1ldGVyIG5hbWVzIHdpbGwgYmVcbiAqIC8vIGNvbGxhcHNlZCB0byBhIHNpbmdsZSBsZXR0ZXIgaWRlbnRpZmllci4gIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHlvdSBjYW5cbiAqIC8vIGV4cGxpY2l0bHkgc3BlY2lmeSB0aGUgbmFtZXMgb2YgdGhlIHBhcmFtZXRlcnMgeW91ciB0YXNrIGZ1bmN0aW9uIG5lZWRzXG4gKiAvLyBpbiBhbiBhcnJheSwgc2ltaWxhciB0byBBbmd1bGFyLmpzIGRlcGVuZGVuY3kgaW5qZWN0aW9uLlxuICpcbiAqIC8vIFRoaXMgc3RpbGwgaGFzIGFuIGFkdmFudGFnZSBvdmVyIHBsYWluIGBhdXRvYCwgc2luY2UgdGhlIHJlc3VsdHMgYSB0YXNrXG4gKiAvLyBkZXBlbmRzIG9uIGFyZSBzdGlsbCBzcHJlYWQgaW50byBhcmd1bWVudHMuXG4gKiBhc3luYy5hdXRvSW5qZWN0KHtcbiAqICAgICAvLy4uLlxuICogICAgIHdyaXRlX2ZpbGU6IFsnZ2V0X2RhdGEnLCAnbWFrZV9mb2xkZXInLCBmdW5jdGlvbihnZXRfZGF0YSwgbWFrZV9mb2xkZXIsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmaWxlbmFtZScpO1xuICogICAgIH1dLFxuICogICAgIGVtYWlsX2xpbms6IFsnd3JpdGVfZmlsZScsIGZ1bmN0aW9uKHdyaXRlX2ZpbGUsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6d3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTtcbiAqICAgICB9XVxuICogICAgIC8vLi4uXG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZXJyID0gJywgZXJyKTtcbiAqICAgICBjb25zb2xlLmxvZygnZW1haWxfbGluayA9ICcsIHJlc3VsdHMuZW1haWxfbGluayk7XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gYXV0b0luamVjdCh0YXNrcywgY2FsbGJhY2spIHtcbiAgICB2YXIgbmV3VGFza3MgPSB7fTtcblxuICAgIGJhc2VGb3JPd24odGFza3MsIGZ1bmN0aW9uICh0YXNrRm4sIGtleSkge1xuICAgICAgICB2YXIgcGFyYW1zO1xuICAgICAgICB2YXIgZm5Jc0FzeW5jID0gaXNBc3luYyh0YXNrRm4pO1xuICAgICAgICB2YXIgaGFzTm9EZXBzID1cbiAgICAgICAgICAgICghZm5Jc0FzeW5jICYmIHRhc2tGbi5sZW5ndGggPT09IDEpIHx8XG4gICAgICAgICAgICAoZm5Jc0FzeW5jICYmIHRhc2tGbi5sZW5ndGggPT09IDApO1xuXG4gICAgICAgIGlmIChpc0FycmF5KHRhc2tGbikpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHRhc2tGbi5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICB0YXNrRm4gPSB0YXNrRm5bdGFza0ZuLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICBuZXdUYXNrc1trZXldID0gcGFyYW1zLmNvbmNhdChwYXJhbXMubGVuZ3RoID4gMCA/IG5ld1Rhc2sgOiB0YXNrRm4pO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc05vRGVwcykge1xuICAgICAgICAgICAgLy8gbm8gZGVwZW5kZW5jaWVzLCB1c2UgdGhlIGZ1bmN0aW9uIGFzLWlzXG4gICAgICAgICAgICBuZXdUYXNrc1trZXldID0gdGFza0ZuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0gcGFyc2VQYXJhbXModGFza0ZuKTtcbiAgICAgICAgICAgIGlmICh0YXNrRm4ubGVuZ3RoID09PSAwICYmICFmbklzQXN5bmMgJiYgcGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF1dG9JbmplY3QgdGFzayBmdW5jdGlvbnMgcmVxdWlyZSBleHBsaWNpdCBwYXJhbWV0ZXJzLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGNhbGxiYWNrIHBhcmFtXG4gICAgICAgICAgICBpZiAoIWZuSXNBc3luYykgcGFyYW1zLnBvcCgpO1xuXG4gICAgICAgICAgICBuZXdUYXNrc1trZXldID0gcGFyYW1zLmNvbmNhdChuZXdUYXNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG5ld1Rhc2socmVzdWx0cywgdGFza0NiKSB7XG4gICAgICAgICAgICB2YXIgbmV3QXJncyA9IGFycmF5TWFwKHBhcmFtcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0c1tuYW1lXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3QXJncy5wdXNoKHRhc2tDYik7XG4gICAgICAgICAgICB3cmFwQXN5bmModGFza0ZuKS5hcHBseShudWxsLCBuZXdBcmdzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYXV0byhuZXdUYXNrcywgY2FsbGJhY2spO1xufVxuXG4vLyBTaW1wbGUgZG91Ymx5IGxpbmtlZCBsaXN0IChodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VibHlfbGlua2VkX2xpc3QpIGltcGxlbWVudGF0aW9uXG4vLyB1c2VkIGZvciBxdWV1ZXMuIFRoaXMgaW1wbGVtZW50YXRpb24gYXNzdW1lcyB0aGF0IHRoZSBub2RlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyIGNhbiBiZSBtb2RpZmllZFxuLy8gdG8gYWRqdXN0IHRoZSBuZXh0IGFuZCBsYXN0IHByb3BlcnRpZXMuIFdlIGltcGxlbWVudCBvbmx5IHRoZSBtaW5pbWFsIGZ1bmN0aW9uYWxpdHlcbi8vIGZvciBxdWV1ZSBzdXBwb3J0LlxuZnVuY3Rpb24gRExMKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBzZXRJbml0aWFsKGRsbCwgbm9kZSkge1xuICAgIGRsbC5sZW5ndGggPSAxO1xuICAgIGRsbC5oZWFkID0gZGxsLnRhaWwgPSBub2RlO1xufVxuXG5ETEwucHJvdG90eXBlLnJlbW92ZUxpbmsgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUucHJldikgbm9kZS5wcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgZWxzZSB0aGlzLmhlYWQgPSBub2RlLm5leHQ7XG4gICAgaWYgKG5vZGUubmV4dCkgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XG4gICAgZWxzZSB0aGlzLnRhaWwgPSBub2RlLnByZXY7XG5cbiAgICBub2RlLnByZXYgPSBub2RlLm5leHQgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoIC09IDE7XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ETEwucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHdoaWxlKHRoaXMuaGVhZCkgdGhpcy5zaGlmdCgpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuRExMLnByb3RvdHlwZS5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uKG5vZGUsIG5ld05vZGUpIHtcbiAgICBuZXdOb2RlLnByZXYgPSBub2RlO1xuICAgIG5ld05vZGUubmV4dCA9IG5vZGUubmV4dDtcbiAgICBpZiAobm9kZS5uZXh0KSBub2RlLm5leHQucHJldiA9IG5ld05vZGU7XG4gICAgZWxzZSB0aGlzLnRhaWwgPSBuZXdOb2RlO1xuICAgIG5vZGUubmV4dCA9IG5ld05vZGU7XG4gICAgdGhpcy5sZW5ndGggKz0gMTtcbn07XG5cbkRMTC5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24obm9kZSwgbmV3Tm9kZSkge1xuICAgIG5ld05vZGUucHJldiA9IG5vZGUucHJldjtcbiAgICBuZXdOb2RlLm5leHQgPSBub2RlO1xuICAgIGlmIChub2RlLnByZXYpIG5vZGUucHJldi5uZXh0ID0gbmV3Tm9kZTtcbiAgICBlbHNlIHRoaXMuaGVhZCA9IG5ld05vZGU7XG4gICAgbm9kZS5wcmV2ID0gbmV3Tm9kZTtcbiAgICB0aGlzLmxlbmd0aCArPSAxO1xufTtcblxuRExMLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICh0aGlzLmhlYWQpIHRoaXMuaW5zZXJ0QmVmb3JlKHRoaXMuaGVhZCwgbm9kZSk7XG4gICAgZWxzZSBzZXRJbml0aWFsKHRoaXMsIG5vZGUpO1xufTtcblxuRExMLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICh0aGlzLnRhaWwpIHRoaXMuaW5zZXJ0QWZ0ZXIodGhpcy50YWlsLCBub2RlKTtcbiAgICBlbHNlIHNldEluaXRpYWwodGhpcywgbm9kZSk7XG59O1xuXG5ETEwucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVhZCAmJiB0aGlzLnJlbW92ZUxpbmsodGhpcy5oZWFkKTtcbn07XG5cbkRMTC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGFpbCAmJiB0aGlzLnJlbW92ZUxpbmsodGhpcy50YWlsKTtcbn07XG5cbkRMTC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyID0gQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIHZhciBjdXJyID0gdGhpcy5oZWFkO1xuICAgIGZvcih2YXIgaWR4ID0gMDsgaWR4IDwgdGhpcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGFycltpZHhdID0gY3Vyci5kYXRhO1xuICAgICAgICBjdXJyID0gY3Vyci5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufTtcblxuRExMLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAodGVzdEZuKSB7XG4gICAgdmFyIGN1cnIgPSB0aGlzLmhlYWQ7XG4gICAgd2hpbGUoISFjdXJyKSB7XG4gICAgICAgIHZhciBuZXh0ID0gY3Vyci5uZXh0O1xuICAgICAgICBpZiAodGVzdEZuKGN1cnIpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpbmsoY3Vycik7XG4gICAgICAgIH1cbiAgICAgICAgY3VyciA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcXVldWUod29ya2VyLCBjb25jdXJyZW5jeSwgcGF5bG9hZCkge1xuICAgIGlmIChjb25jdXJyZW5jeSA9PSBudWxsKSB7XG4gICAgICAgIGNvbmN1cnJlbmN5ID0gMTtcbiAgICB9XG4gICAgZWxzZSBpZihjb25jdXJyZW5jeSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmN1cnJlbmN5IG11c3Qgbm90IGJlIHplcm8nKTtcbiAgICB9XG5cbiAgICB2YXIgX3dvcmtlciA9IHdyYXBBc3luYyh3b3JrZXIpO1xuICAgIHZhciBudW1SdW5uaW5nID0gMDtcbiAgICB2YXIgd29ya2Vyc0xpc3QgPSBbXTtcblxuICAgIHZhciBwcm9jZXNzaW5nU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gX2luc2VydChkYXRhLCBpbnNlcnRBdEZyb250LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGFzayBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIWlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwICYmIHEuaWRsZSgpKSB7XG4gICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xuICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YVtpXSxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2sgfHwgbm9vcFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGluc2VydEF0RnJvbnQpIHtcbiAgICAgICAgICAgICAgICBxLl90YXNrcy51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxLl90YXNrcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm9jZXNzaW5nU2NoZWR1bGVkKSB7XG4gICAgICAgICAgICBwcm9jZXNzaW5nU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX25leHQodGFza3MpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVycil7XG4gICAgICAgICAgICBudW1SdW5uaW5nIC09IDE7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGFza3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc1tpXTtcblxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGJhc2VJbmRleE9mKHdvcmtlcnNMaXN0LCB0YXNrLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2Vyc0xpc3Quc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXJzTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRhc2suY2FsbGJhY2suYXBwbHkodGFzaywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBxLmVycm9yKGVyciwgdGFzay5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChudW1SdW5uaW5nIDw9IChxLmNvbmN1cnJlbmN5IC0gcS5idWZmZXIpICkge1xuICAgICAgICAgICAgICAgIHEudW5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHEuaWRsZSgpKSB7XG4gICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcS5wcm9jZXNzKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgIHZhciBxID0ge1xuICAgICAgICBfdGFza3M6IG5ldyBETEwoKSxcbiAgICAgICAgY29uY3VycmVuY3k6IGNvbmN1cnJlbmN5LFxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICBzYXR1cmF0ZWQ6IG5vb3AsXG4gICAgICAgIHVuc2F0dXJhdGVkOm5vb3AsXG4gICAgICAgIGJ1ZmZlcjogY29uY3VycmVuY3kgLyA0LFxuICAgICAgICBlbXB0eTogbm9vcCxcbiAgICAgICAgZHJhaW46IG5vb3AsXG4gICAgICAgIGVycm9yOiBub29wLFxuICAgICAgICBzdGFydGVkOiBmYWxzZSxcbiAgICAgICAgcGF1c2VkOiBmYWxzZSxcbiAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBfaW5zZXJ0KGRhdGEsIGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIGtpbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHEuZHJhaW4gPSBub29wO1xuICAgICAgICAgICAgcS5fdGFza3MuZW1wdHkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zaGlmdDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBfaW5zZXJ0KGRhdGEsIHRydWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAodGVzdEZuKSB7XG4gICAgICAgICAgICBxLl90YXNrcy5yZW1vdmUodGVzdEZuKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQXZvaWQgdHJ5aW5nIHRvIHN0YXJ0IHRvbyBtYW55IHByb2Nlc3Npbmcgb3BlcmF0aW9ucy4gVGhpcyBjYW4gb2NjdXJcbiAgICAgICAgICAgIC8vIHdoZW4gY2FsbGJhY2tzIHJlc29sdmUgc3luY2hyb25vdXNseSAoIzEyNjcpLlxuICAgICAgICAgICAgaWYgKGlzUHJvY2Vzc2luZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSghcS5wYXVzZWQgJiYgbnVtUnVubmluZyA8IHEuY29uY3VycmVuY3kgJiYgcS5fdGFza3MubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICB2YXIgdGFza3MgPSBbXSwgZGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBsID0gcS5fdGFza3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChxLnBheWxvYWQpIGwgPSBNYXRoLm1pbihsLCBxLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gcS5fdGFza3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgd29ya2Vyc0xpc3QucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKG5vZGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbnVtUnVubmluZyArPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKHEuX3Rhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBxLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG51bVJ1bm5pbmcgPT09IHEuY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2IgPSBvbmx5T25jZShfbmV4dCh0YXNrcykpO1xuICAgICAgICAgICAgICAgIF93b3JrZXIoZGF0YSwgY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHEuX3Rhc2tzLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVJ1bm5pbmc7XG4gICAgICAgIH0sXG4gICAgICAgIHdvcmtlcnNMaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gd29ya2Vyc0xpc3Q7XG4gICAgICAgIH0sXG4gICAgICAgIGlkbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHEuX3Rhc2tzLmxlbmd0aCArIG51bVJ1bm5pbmcgPT09IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBxLnBhdXNlZCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHEucGF1c2VkID09PSBmYWxzZSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgIHEucGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUkMShxLnByb2Nlc3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcTtcbn1cblxuLyoqXG4gKiBBIGNhcmdvIG9mIHRhc2tzIGZvciB0aGUgd29ya2VyIGZ1bmN0aW9uIHRvIGNvbXBsZXRlLiBDYXJnbyBpbmhlcml0cyBhbGwgb2ZcbiAqIHRoZSBzYW1lIG1ldGhvZHMgYW5kIGV2ZW50IGNhbGxiYWNrcyBhcyBbYHF1ZXVlYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnF1ZXVlfS5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhcmdvT2JqZWN0XG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBsZW5ndGggLSBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbnVtYmVyIG9mIGl0ZW1zXG4gKiB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZC4gSW52b2tlIGxpa2UgYGNhcmdvLmxlbmd0aCgpYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwYXlsb2FkIC0gQW4gYGludGVnZXJgIGZvciBkZXRlcm1pbmluZyBob3cgbWFueSB0YXNrc1xuICogc2hvdWxkIGJlIHByb2Nlc3MgcGVyIHJvdW5kLiBUaGlzIHByb3BlcnR5IGNhbiBiZSBjaGFuZ2VkIGFmdGVyIGEgYGNhcmdvYCBpc1xuICogY3JlYXRlZCB0byBhbHRlciB0aGUgcGF5bG9hZCBvbi10aGUtZmx5LlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcHVzaCAtIEFkZHMgYHRhc2tgIHRvIHRoZSBgcXVldWVgLiBUaGUgY2FsbGJhY2sgaXNcbiAqIGNhbGxlZCBvbmNlIHRoZSBgd29ya2VyYCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZyB0aGUgdGFzay4gSW5zdGVhZCBvZiBhXG4gKiBzaW5nbGUgdGFzaywgYW4gYXJyYXkgb2YgYHRhc2tzYCBjYW4gYmUgc3VibWl0dGVkLiBUaGUgcmVzcGVjdGl2ZSBjYWxsYmFjayBpc1xuICogdXNlZCBmb3IgZXZlcnkgdGFzayBpbiB0aGUgbGlzdC4gSW52b2tlIGxpa2UgYGNhcmdvLnB1c2godGFzaywgW2NhbGxiYWNrXSlgLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gc2F0dXJhdGVkIC0gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZVxuICogYHF1ZXVlLmxlbmd0aCgpYCBoaXRzIHRoZSBjb25jdXJyZW5jeSBhbmQgZnVydGhlciB0YXNrcyB3aWxsIGJlIHF1ZXVlZC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVtcHR5IC0gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBsYXN0IGl0ZW1cbiAqIGZyb20gdGhlIGBxdWV1ZWAgaXMgZ2l2ZW4gdG8gYSBgd29ya2VyYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRyYWluIC0gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBsYXN0IGl0ZW1cbiAqIGZyb20gdGhlIGBxdWV1ZWAgaGFzIHJldHVybmVkIGZyb20gdGhlIGB3b3JrZXJgLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaWRsZSAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGZhbHNlIGlmIHRoZXJlIGFyZSBpdGVtc1xuICogd2FpdGluZyBvciBiZWluZyBwcm9jZXNzZWQsIG9yIHRydWUgaWYgbm90LiBJbnZva2UgbGlrZSBgY2FyZ28uaWRsZSgpYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHBhdXNlIC0gYSBmdW5jdGlvbiB0aGF0IHBhdXNlcyB0aGUgcHJvY2Vzc2luZyBvZiB0YXNrc1xuICogdW50aWwgYHJlc3VtZSgpYCBpcyBjYWxsZWQuIEludm9rZSBsaWtlIGBjYXJnby5wYXVzZSgpYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHJlc3VtZSAtIGEgZnVuY3Rpb24gdGhhdCByZXN1bWVzIHRoZSBwcm9jZXNzaW5nIG9mXG4gKiBxdWV1ZWQgdGFza3Mgd2hlbiB0aGUgcXVldWUgaXMgcGF1c2VkLiBJbnZva2UgbGlrZSBgY2FyZ28ucmVzdW1lKClgLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0ga2lsbCAtIGEgZnVuY3Rpb24gdGhhdCByZW1vdmVzIHRoZSBgZHJhaW5gIGNhbGxiYWNrIGFuZFxuICogZW1wdGllcyByZW1haW5pbmcgdGFza3MgZnJvbSB0aGUgcXVldWUgZm9yY2luZyBpdCB0byBnbyBpZGxlLiBJbnZva2UgbGlrZSBgY2FyZ28ua2lsbCgpYC5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgY2FyZ29gIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgcGF5bG9hZC4gVGFza3MgYWRkZWQgdG8gdGhlXG4gKiBjYXJnbyB3aWxsIGJlIHByb2Nlc3NlZCBhbHRvZ2V0aGVyICh1cCB0byB0aGUgYHBheWxvYWRgIGxpbWl0KS4gSWYgdGhlXG4gKiBgd29ya2VyYCBpcyBpbiBwcm9ncmVzcywgdGhlIHRhc2sgaXMgcXVldWVkIHVudGlsIGl0IGJlY29tZXMgYXZhaWxhYmxlLiBPbmNlXG4gKiB0aGUgYHdvcmtlcmAgaGFzIGNvbXBsZXRlZCBzb21lIHRhc2tzLCBlYWNoIGNhbGxiYWNrIG9mIHRob3NlIHRhc2tzIGlzXG4gKiBjYWxsZWQuIENoZWNrIG91dCBbdGhlc2VdKGh0dHBzOi8vY2Ftby5naXRodWJ1c2VyY29udGVudC5jb20vNmJiZDM2ZjRjZjViMzVhMGYxMWE5NmRjZDJlOTc3MTFmZmMyZmIzNy82ODc0NzQ3MDczM2EyZjJmNjYyZTYzNmM2Zjc1NjQyZTY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTczNzM2NTc0NzMyZjMxMzYzNzM2MzgzNzMxMmYzNjM4MzEzMDM4MmY2MjYyNjMzMDYzNjY2MjMwMmQzNTY2MzIzOTJkMzEzMTY1MzIyZDM5MzczNDY2MmQzMzMzMzkzNzYzMzYzNDY0NjMzODM1MzgyZTY3Njk2NikgW2FuaW1hdGlvbnNdKGh0dHBzOi8vY2Ftby5naXRodWJ1c2VyY29udGVudC5jb20vZjQ4MTBlMDBlMWM1ZjVmOGFkZGJlM2U5ZjQ5MDY0ZmQ1ZDEwMjY5OS82ODc0NzQ3MDczM2EyZjJmNjYyZTYzNmM2Zjc1NjQyZTY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTczNzM2NTc0NzMyZjMxMzYzNzM2MzgzNzMxMmYzNjM4MzEzMDMxMmYzODM0NjMzOTMyMzAzNjM2MmQzNTY2MzIzOTJkMzEzMTY1MzIyZDM4MzEzNDY2MmQzOTY0MzM2NDMwMzIzNDMxMzM2MjY2NjQyZTY3Njk2NilcbiAqIGZvciBob3cgYGNhcmdvYCBhbmQgYHF1ZXVlYCB3b3JrLlxuICpcbiAqIFdoaWxlIFtgcXVldWVgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9IHBhc3NlcyBvbmx5IG9uZSB0YXNrIHRvIG9uZSBvZiBhIGdyb3VwIG9mIHdvcmtlcnNcbiAqIGF0IGEgdGltZSwgY2FyZ28gcGFzc2VzIGFuIGFycmF5IG9mIHRhc2tzIHRvIGEgc2luZ2xlIHdvcmtlciwgcmVwZWF0aW5nXG4gKiB3aGVuIHRoZSB3b3JrZXIgaXMgZmluaXNoZWQuXG4gKlxuICogQG5hbWUgY2FyZ29cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnF1ZXVlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHdvcmtlciAtIEFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBmb3IgcHJvY2Vzc2luZyBhbiBhcnJheVxuICogb2YgcXVldWVkIHRhc2tzLiBJbnZva2VkIHdpdGggYCh0YXNrcywgY2FsbGJhY2spYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGF5bG9hZD1JbmZpbml0eV0gLSBBbiBvcHRpb25hbCBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nXG4gKiBob3cgbWFueSB0YXNrcyBzaG91bGQgYmUgcHJvY2Vzc2VkIHBlciByb3VuZDsgaWYgb21pdHRlZCwgdGhlIGRlZmF1bHQgaXNcbiAqIHVubGltaXRlZC5cbiAqIEByZXR1cm5zIHttb2R1bGU6Q29udHJvbEZsb3cuQ2FyZ29PYmplY3R9IEEgY2FyZ28gb2JqZWN0IHRvIG1hbmFnZSB0aGUgdGFza3MuIENhbGxiYWNrcyBjYW5cbiAqIGF0dGFjaGVkIGFzIGNlcnRhaW4gcHJvcGVydGllcyB0byBsaXN0ZW4gZm9yIHNwZWNpZmljIGV2ZW50cyBkdXJpbmcgdGhlXG4gKiBsaWZlY3ljbGUgb2YgdGhlIGNhcmdvIGFuZCBpbm5lciBxdWV1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gY3JlYXRlIGEgY2FyZ28gb2JqZWN0IHdpdGggcGF5bG9hZCAyXG4gKiB2YXIgY2FyZ28gPSBhc3luYy5jYXJnbyhmdW5jdGlvbih0YXNrcywgY2FsbGJhY2spIHtcbiAqICAgICBmb3IgKHZhciBpPTA7IGk8dGFza3MubGVuZ3RoOyBpKyspIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coJ2hlbGxvICcgKyB0YXNrc1tpXS5uYW1lKTtcbiAqICAgICB9XG4gKiAgICAgY2FsbGJhY2soKTtcbiAqIH0sIDIpO1xuICpcbiAqIC8vIGFkZCBzb21lIGl0ZW1zXG4gKiBjYXJnby5wdXNoKHtuYW1lOiAnZm9vJ30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGZvbycpO1xuICogfSk7XG4gKiBjYXJnby5wdXNoKHtuYW1lOiAnYmFyJ30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpO1xuICogfSk7XG4gKiBjYXJnby5wdXNoKHtuYW1lOiAnYmF6J30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJheicpO1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGNhcmdvKHdvcmtlciwgcGF5bG9hZCkge1xuICAgIHJldHVybiBxdWV1ZSh3b3JrZXIsIDEsIHBheWxvYWQpO1xufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZWFjaE9mYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGVhY2hPZlNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZWFjaE9mXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaE9mfVxuICogQGFsaWFzIGZvckVhY2hPZlNlcmllc1xuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICovXG52YXIgZWFjaE9mU2VyaWVzID0gZG9MaW1pdChlYWNoT2ZMaW1pdCwgMSk7XG5cbi8qKlxuICogUmVkdWNlcyBgY29sbGAgaW50byBhIHNpbmdsZSB2YWx1ZSB1c2luZyBhbiBhc3luYyBgaXRlcmF0ZWVgIHRvIHJldHVybiBlYWNoXG4gKiBzdWNjZXNzaXZlIHN0ZXAuIGBtZW1vYCBpcyB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLiBUaGlzIGZ1bmN0aW9uXG4gKiBvbmx5IG9wZXJhdGVzIGluIHNlcmllcy5cbiAqXG4gKiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgaXQgbWF5IG1ha2Ugc2Vuc2UgdG8gc3BsaXQgYSBjYWxsIHRvIHRoaXMgZnVuY3Rpb25cbiAqIGludG8gYSBwYXJhbGxlbCBtYXAsIGFuZCB0aGVuIHVzZSB0aGUgbm9ybWFsIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBvbiB0aGVcbiAqIHJlc3VsdHMuIFRoaXMgZnVuY3Rpb24gaXMgZm9yIHNpdHVhdGlvbnMgd2hlcmUgZWFjaCBzdGVwIGluIHRoZSByZWR1Y3Rpb25cbiAqIG5lZWRzIHRvIGJlIGFzeW5jOyBpZiB5b3UgY2FuIGdldCB0aGUgZGF0YSBiZWZvcmUgcmVkdWNpbmcgaXQsIHRoZW4gaXQnc1xuICogcHJvYmFibHkgYSBnb29kIGlkZWEgdG8gZG8gc28uXG4gKlxuICogQG5hbWUgcmVkdWNlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgaW5qZWN0XG4gKiBAYWxpYXMgZm9sZGxcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0geyp9IG1lbW8gLSBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gYXBwbGllZCB0byBlYWNoIGl0ZW0gaW4gdGhlXG4gKiBhcnJheSB0byBwcm9kdWNlIHRoZSBuZXh0IHN0ZXAgaW4gdGhlIHJlZHVjdGlvbi5cbiAqIFRoZSBgaXRlcmF0ZWVgIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSBuZXh0IHN0YXRlIG9mIHRoZSByZWR1Y3Rpb24uXG4gKiBJZiB0aGUgaXRlcmF0ZWUgY29tcGxldGUgd2l0aCBhbiBlcnJvciwgdGhlIHJlZHVjdGlvbiBpcyBzdG9wcGVkIGFuZCB0aGVcbiAqIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuXG4gKiBJbnZva2VkIHdpdGggKG1lbW8sIGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgaXMgdGhlIHJlZHVjZWQgdmFsdWUuIEludm9rZWQgd2l0aFxuICogKGVyciwgcmVzdWx0KS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMucmVkdWNlKFsxLDIsM10sIDAsIGZ1bmN0aW9uKG1lbW8sIGl0ZW0sIGNhbGxiYWNrKSB7XG4gKiAgICAgLy8gcG9pbnRsZXNzIGFzeW5jOlxuICogICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1lbW8gKyBpdGVtKVxuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgaXMgbm93IGVxdWFsIHRvIHRoZSBsYXN0IHZhbHVlIG9mIG1lbW8sIHdoaWNoIGlzIDZcbiAqIH0pO1xuICovXG5mdW5jdGlvbiByZWR1Y2UoY29sbCwgbWVtbywgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgIGVhY2hPZlNlcmllcyhjb2xsLCBmdW5jdGlvbih4LCBpLCBjYWxsYmFjaykge1xuICAgICAgICBfaXRlcmF0ZWUobWVtbywgeCwgZnVuY3Rpb24oZXJyLCB2KSB7XG4gICAgICAgICAgICBtZW1vID0gdjtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIsIG1lbW8pO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFZlcnNpb24gb2YgdGhlIGNvbXBvc2UgZnVuY3Rpb24gdGhhdCBpcyBtb3JlIG5hdHVyYWwgdG8gcmVhZC4gRWFjaCBmdW5jdGlvblxuICogY29uc3VtZXMgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMgZnVuY3Rpb24uIEl0IGlzIHRoZSBlcXVpdmFsZW50IG9mXG4gKiBbY29tcG9zZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmNvbXBvc2V9IHdpdGggdGhlIGFyZ3VtZW50cyByZXZlcnNlZC5cbiAqXG4gKiBFYWNoIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjb21wb3NlZCBmdW5jdGlvbi5cbiAqXG4gKiBAbmFtZSBzZXFcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmNvbXBvc2Vde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5jb21wb3NlfVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHsuLi5Bc3luY0Z1bmN0aW9ufSBmdW5jdGlvbnMgLSB0aGUgYXN5bmNocm9ub3VzIGZ1bmN0aW9ucyB0byBjb21wb3NlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBjb21wb3NlcyB0aGUgYGZ1bmN0aW9uc2AgaW4gb3JkZXJcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gUmVxdWlyZXMgbG9kYXNoIChvciB1bmRlcnNjb3JlKSwgZXhwcmVzczMgYW5kIGRyZXNlbmRlJ3Mgb3JtMi5cbiAqIC8vIFBhcnQgb2YgYW4gYXBwLCB0aGF0IGZldGNoZXMgY2F0cyBvZiB0aGUgbG9nZ2VkIHVzZXIuXG4gKiAvLyBUaGlzIGV4YW1wbGUgdXNlcyBgc2VxYCBmdW5jdGlvbiB0byBhdm9pZCBvdmVybmVzdGluZyBhbmQgZXJyb3JcbiAqIC8vIGhhbmRsaW5nIGNsdXR0ZXIuXG4gKiBhcHAuZ2V0KCcvY2F0cycsIGZ1bmN0aW9uKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gKiAgICAgdmFyIFVzZXIgPSByZXF1ZXN0Lm1vZGVscy5Vc2VyO1xuICogICAgIGFzeW5jLnNlcShcbiAqICAgICAgICAgXy5iaW5kKFVzZXIuZ2V0LCBVc2VyKSwgIC8vICdVc2VyLmdldCcgaGFzIHNpZ25hdHVyZSAoaWQsIGNhbGxiYWNrKGVyciwgZGF0YSkpXG4gKiAgICAgICAgIGZ1bmN0aW9uKHVzZXIsIGZuKSB7XG4gKiAgICAgICAgICAgICB1c2VyLmdldENhdHMoZm4pOyAgICAgIC8vICdnZXRDYXRzJyBoYXMgc2lnbmF0dXJlIChjYWxsYmFjayhlcnIsIGRhdGEpKVxuICogICAgICAgICB9XG4gKiAgICAgKShyZXEuc2Vzc2lvbi51c2VyX2lkLCBmdW5jdGlvbiAoZXJyLCBjYXRzKSB7XG4gKiAgICAgICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAqICAgICAgICAgICAgIHJlc3BvbnNlLmpzb24oeyBzdGF0dXM6ICdlcnJvcicsIG1lc3NhZ2U6IGVyci5tZXNzYWdlIH0pO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgICAgcmVzcG9uc2UuanNvbih7IHN0YXR1czogJ29rJywgbWVzc2FnZTogJ0NhdHMgZm91bmQnLCBkYXRhOiBjYXRzIH0pO1xuICogICAgICAgICB9XG4gKiAgICAgfSk7XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gc2VxKC8qLi4uZnVuY3Rpb25zKi8pIHtcbiAgICB2YXIgX2Z1bmN0aW9ucyA9IGFycmF5TWFwKGFyZ3VtZW50cywgd3JhcEFzeW5jKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oLyouLi5hcmdzKi8pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMpO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGNiID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodHlwZW9mIGNiID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFyZ3MucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYiA9IG5vb3A7XG4gICAgICAgIH1cblxuICAgICAgICByZWR1Y2UoX2Z1bmN0aW9ucywgYXJncywgZnVuY3Rpb24obmV3YXJncywgZm4sIGNiKSB7XG4gICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBuZXdhcmdzLmNvbmNhdChmdW5jdGlvbihlcnIvKiwgLi4ubmV4dGFyZ3MqLykge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0YXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgY2IoZXJyLCBuZXh0YXJncyk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgY2IuYXBwbHkodGhhdCwgW2Vycl0uY29uY2F0KHJlc3VsdHMpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gd2hpY2ggaXMgYSBjb21wb3NpdGlvbiBvZiB0aGUgcGFzc2VkIGFzeW5jaHJvbm91c1xuICogZnVuY3Rpb25zLiBFYWNoIGZ1bmN0aW9uIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXRcbiAqIGZvbGxvd3MuIENvbXBvc2luZyBmdW5jdGlvbnMgYGYoKWAsIGBnKClgLCBhbmQgYGgoKWAgd291bGQgcHJvZHVjZSB0aGUgcmVzdWx0XG4gKiBvZiBgZihnKGgoKSkpYCwgb25seSB0aGlzIHZlcnNpb24gdXNlcyBjYWxsYmFja3MgdG8gb2J0YWluIHRoZSByZXR1cm4gdmFsdWVzLlxuICpcbiAqIEVhY2ggZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNvbXBvc2VkIGZ1bmN0aW9uLlxuICpcbiAqIEBuYW1lIGNvbXBvc2VcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7Li4uQXN5bmNGdW5jdGlvbn0gZnVuY3Rpb25zIC0gdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMgdG8gY29tcG9zZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zZWRcbiAqIGFzeW5jaHJvbm91cyBgZnVuY3Rpb25zYFxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBhZGQxKG4sIGNhbGxiYWNrKSB7XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIG4gKyAxKTtcbiAqICAgICB9LCAxMCk7XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gbXVsMyhuLCBjYWxsYmFjaykge1xuICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCBuICogMyk7XG4gKiAgICAgfSwgMTApO1xuICogfVxuICpcbiAqIHZhciBhZGQxbXVsMyA9IGFzeW5jLmNvbXBvc2UobXVsMywgYWRkMSk7XG4gKiBhZGQxbXVsMyg0LCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyAxNVxuICogfSk7XG4gKi9cbnZhciBjb21wb3NlID0gZnVuY3Rpb24oLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gc2VxLmFwcGx5KG51bGwsIHNsaWNlKGFyZ3VtZW50cykucmV2ZXJzZSgpKTtcbn07XG5cbnZhciBfY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGNvbmNhdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5jb25jYXR9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGNvbmNhdExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5jb25jYXRde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5jb25jYXR9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCxcbiAqIHdoaWNoIHNob3VsZCB1c2UgYW4gYXJyYXkgYXMgaXRzIHJlc3VsdC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5XG4gKiBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgcmVzdWx0cyBvZiB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbi4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHRzKS5cbiAqL1xudmFyIGNvbmNhdExpbWl0ID0gZnVuY3Rpb24oY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcbiAgICBtYXBMaW1pdChjb2xsLCBsaW1pdCwgZnVuY3Rpb24odmFsLCBjYWxsYmFjaykge1xuICAgICAgICBfaXRlcmF0ZWUodmFsLCBmdW5jdGlvbihlcnIgLyosIC4uLmFyZ3MqLykge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uKGVyciwgbWFwUmVzdWx0cykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwUmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG1hcFJlc3VsdHNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfY29uY2F0LmFwcGx5KHJlc3VsdCwgbWFwUmVzdWx0c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIGBpdGVyYXRlZWAgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCwgY29uY2F0ZW5hdGluZyB0aGUgcmVzdWx0cy4gUmV0dXJuc1xuICogdGhlIGNvbmNhdGVuYXRlZCBsaXN0LiBUaGUgYGl0ZXJhdGVlYHMgYXJlIGNhbGxlZCBpbiBwYXJhbGxlbCwgYW5kIHRoZVxuICogcmVzdWx0cyBhcmUgY29uY2F0ZW5hdGVkIGFzIHRoZXkgcmV0dXJuLiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGVcbiAqIHJlc3VsdHMgYXJyYXkgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgb3JpZ2luYWwgb3JkZXIgb2YgYGNvbGxgIHBhc3NlZCB0byB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb24uXG4gKlxuICogQG5hbWUgY29uY2F0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCxcbiAqIHdoaWNoIHNob3VsZCB1c2UgYW4gYXJyYXkgYXMgaXRzIHJlc3VsdC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2soZXJyKV0gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gYXJyYXlcbiAqIGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRlZCByZXN1bHRzIG9mIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9uLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdHMpLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy5jb25jYXQoWydkaXIxJywnZGlyMicsJ2RpcjMnXSwgZnMucmVhZGRpciwgZnVuY3Rpb24oZXJyLCBmaWxlcykge1xuICogICAgIC8vIGZpbGVzIGlzIG5vdyBhIGxpc3Qgb2YgZmlsZW5hbWVzIHRoYXQgZXhpc3QgaW4gdGhlIDMgZGlyZWN0b3JpZXNcbiAqIH0pO1xuICovXG52YXIgY29uY2F0ID0gZG9MaW1pdChjb25jYXRMaW1pdCwgSW5maW5pdHkpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgY29uY2F0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmNvbmNhdH0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGNvbmNhdFNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuY29uY2F0XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuY29uY2F0fVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYW4gYXJyYXkgYW4gYXJyYXkgb2YgcmVzdWx0cy5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrKGVycildIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5XG4gKiBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgcmVzdWx0cyBvZiB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbi4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHRzKS5cbiAqL1xudmFyIGNvbmNhdFNlcmllcyA9IGRvTGltaXQoY29uY2F0TGltaXQsIDEpO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdoZW4gY2FsbGVkLCBjYWxscy1iYWNrIHdpdGggdGhlIHZhbHVlcyBwcm92aWRlZC5cbiAqIFVzZWZ1bCBhcyB0aGUgZmlyc3QgZnVuY3Rpb24gaW4gYSBbYHdhdGVyZmFsbGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53YXRlcmZhbGx9LCBvciBmb3IgcGx1Z2dpbmcgdmFsdWVzIGluIHRvXG4gKiBbYGF1dG9gXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXV0b30uXG4gKlxuICogQG5hbWUgY29uc3RhbnRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGF1dG9tYXRpY2FsbHkgaW52b2tlXG4gKiBjYWxsYmFjayB3aXRoLlxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdoZW4gaW52b2tlZCwgYXV0b21hdGljYWxseVxuICogaW52b2tlcyB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgcHJldmlvdXMgZ2l2ZW4gYXJndW1lbnRzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy53YXRlcmZhbGwoW1xuICogICAgIGFzeW5jLmNvbnN0YW50KDQyKSxcbiAqICAgICBmdW5jdGlvbiAodmFsdWUsIG5leHQpIHtcbiAqICAgICAgICAgLy8gdmFsdWUgPT09IDQyXG4gKiAgICAgfSxcbiAqICAgICAvLy4uLlxuICogXSwgY2FsbGJhY2spO1xuICpcbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgYXN5bmMuY29uc3RhbnQoZmlsZW5hbWUsIFwidXRmOFwiKSxcbiAqICAgICBmcy5yZWFkRmlsZSxcbiAqICAgICBmdW5jdGlvbiAoZmlsZURhdGEsIG5leHQpIHtcbiAqICAgICAgICAgLy8uLi5cbiAqICAgICB9XG4gKiAgICAgLy8uLi5cbiAqIF0sIGNhbGxiYWNrKTtcbiAqXG4gKiBhc3luYy5hdXRvKHtcbiAqICAgICBob3N0bmFtZTogYXN5bmMuY29uc3RhbnQoXCJodHRwczovL3NlcnZlci5uZXQvXCIpLFxuICogICAgIHBvcnQ6IGZpbmRGcmVlUG9ydCxcbiAqICAgICBsYXVuY2hTZXJ2ZXI6IFtcImhvc3RuYW1lXCIsIFwicG9ydFwiLCBmdW5jdGlvbiAob3B0aW9ucywgY2IpIHtcbiAqICAgICAgICAgc3RhcnRTZXJ2ZXIob3B0aW9ucywgY2IpO1xuICogICAgIH1dLFxuICogICAgIC8vLi4uXG4gKiB9LCBjYWxsYmFjayk7XG4gKi9cbnZhciBjb25zdGFudCA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICB2YXIgdmFsdWVzID0gc2xpY2UoYXJndW1lbnRzKTtcbiAgICB2YXIgYXJncyA9IFtudWxsXS5jb25jYXQodmFsdWVzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC8qLi4uaWdub3JlZEFyZ3MsIGNhbGxiYWNrKi8pIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlVGVzdGVyKGNoZWNrLCBnZXRSZXN1bHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWFjaGZuLCBhcnIsIGl0ZXJhdGVlLCBjYikge1xuICAgICAgICBjYiA9IGNiIHx8IG5vb3A7XG4gICAgICAgIHZhciB0ZXN0UGFzc2VkID0gZmFsc2U7XG4gICAgICAgIHZhciB0ZXN0UmVzdWx0O1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbih2YWx1ZSwgXywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlKHZhbHVlLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoZWNrKHJlc3VsdCkgJiYgIXRlc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVzdFBhc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RSZXN1bHQgPSBnZXRSZXN1bHQodHJ1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBicmVha0xvb3ApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNiKG51bGwsIHRlc3RQYXNzZWQgPyB0ZXN0UmVzdWx0IDogZ2V0UmVzdWx0KGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIF9maW5kR2V0UmVzdWx0KHYsIHgpIHtcbiAgICByZXR1cm4geDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBpbiBgY29sbGAgdGhhdCBwYXNzZXMgYW4gYXN5bmMgdHJ1dGggdGVzdC4gVGhlXG4gKiBgaXRlcmF0ZWVgIGlzIGFwcGxpZWQgaW4gcGFyYWxsZWwsIG1lYW5pbmcgdGhlIGZpcnN0IGl0ZXJhdGVlIHRvIHJldHVyblxuICogYHRydWVgIHdpbGwgZmlyZSB0aGUgZGV0ZWN0IGBjYWxsYmFja2Agd2l0aCB0aGF0IHJlc3VsdC4gVGhhdCBtZWFucyB0aGVcbiAqIHJlc3VsdCBtaWdodCBub3QgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIG9yaWdpbmFsIGBjb2xsYCAoaW4gdGVybXMgb2Ygb3JkZXIpXG4gKiB0aGF0IHBhc3NlcyB0aGUgdGVzdC5cblxuICogSWYgb3JkZXIgd2l0aGluIHRoZSBvcmlnaW5hbCBgY29sbGAgaXMgaW1wb3J0YW50LCB0aGVuIGxvb2sgYXRcbiAqIFtgZGV0ZWN0U2VyaWVzYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdFNlcmllc30uXG4gKlxuICogQG5hbWUgZGV0ZWN0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgZmluZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgcmVzdWx0LlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnlcbiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuXG4gKiBSZXN1bHQgd2lsbCBiZSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgYXJyYXkgdGhhdCBwYXNzZXMgdGhlIHRydXRoIHRlc3RcbiAqIChpdGVyYXRlZSkgb3IgdGhlIHZhbHVlIGB1bmRlZmluZWRgIGlmIG5vbmUgcGFzc2VkLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdCkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLmRldGVjdChbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmdW5jdGlvbihmaWxlUGF0aCwgY2FsbGJhY2spIHtcbiAqICAgICBmcy5hY2Nlc3MoZmlsZVBhdGgsIGZ1bmN0aW9uKGVycikge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKVxuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyB0aGUgZmlyc3QgZmlsZSBpbiB0aGUgbGlzdCB0aGF0IGV4aXN0c1xuICogfSk7XG4gKi9cbnZhciBkZXRlY3QgPSBkb1BhcmFsbGVsKF9jcmVhdGVUZXN0ZXIoaWRlbnRpdHksIF9maW5kR2V0UmVzdWx0KSk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BkZXRlY3RgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZGV0ZWN0fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgZGV0ZWN0TGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmRldGVjdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdH1cbiAqIEBhbGlhcyBmaW5kTGltaXRcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYXMgaXRzIHJlc3VsdC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLlxuICogUmVzdWx0IHdpbGwgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGFycmF5IHRoYXQgcGFzc2VzIHRoZSB0cnV0aCB0ZXN0XG4gKiAoaXRlcmF0ZWUpIG9yIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYCBpZiBub25lIHBhc3NlZC4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHQpLlxuICovXG52YXIgZGV0ZWN0TGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2NyZWF0ZVRlc3RlcihpZGVudGl0eSwgX2ZpbmRHZXRSZXN1bHQpKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGRldGVjdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5kZXRlY3R9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBkZXRlY3RTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmRldGVjdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdH1cbiAqIEBhbGlhcyBmaW5kU2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyByZXN1bHQuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueVxuICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC5cbiAqIFJlc3VsdCB3aWxsIGJlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBhcnJheSB0aGF0IHBhc3NlcyB0aGUgdHJ1dGggdGVzdFxuICogKGl0ZXJhdGVlKSBvciB0aGUgdmFsdWUgYHVuZGVmaW5lZGAgaWYgbm9uZSBwYXNzZWQuIEludm9rZWQgd2l0aFxuICogKGVyciwgcmVzdWx0KS5cbiAqL1xudmFyIGRldGVjdFNlcmllcyA9IGRvTGltaXQoZGV0ZWN0TGltaXQsIDEpO1xuXG5mdW5jdGlvbiBjb25zb2xlRnVuYyhuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmbi8qLCAuLi5hcmdzKi8pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyci8qLCAuLi5hcmdzKi8pIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlFYWNoKGFyZ3MsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlW25hbWVdKHgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB3cmFwQXN5bmMoZm4pLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH07XG59XG5cbi8qKlxuICogTG9ncyB0aGUgcmVzdWx0IG9mIGFuIFtgYXN5bmNgIGZ1bmN0aW9uXXtAbGluayBBc3luY0Z1bmN0aW9ufSB0byB0aGVcbiAqIGBjb25zb2xlYCB1c2luZyBgY29uc29sZS5kaXJgIHRvIGRpc3BsYXkgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHJlc3VsdGluZyBvYmplY3QuXG4gKiBPbmx5IHdvcmtzIGluIE5vZGUuanMgb3IgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGBjb25zb2xlLmRpcmAgYW5kXG4gKiBgY29uc29sZS5lcnJvcmAgKHN1Y2ggYXMgRkYgYW5kIENocm9tZSkuXG4gKiBJZiBtdWx0aXBsZSBhcmd1bWVudHMgYXJlIHJldHVybmVkIGZyb20gdGhlIGFzeW5jIGZ1bmN0aW9uLFxuICogYGNvbnNvbGUuZGlyYCBpcyBjYWxsZWQgb24gZWFjaCBhcmd1bWVudCBpbiBvcmRlci5cbiAqXG4gKiBAbmFtZSBkaXJcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZ1bmN0aW9uIC0gVGhlIGZ1bmN0aW9uIHlvdSB3YW50IHRvIGV2ZW50dWFsbHkgYXBwbHlcbiAqIGFsbCBhcmd1bWVudHMgdG8uXG4gKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gaW4gYSBtb2R1bGVcbiAqIHZhciBoZWxsbyA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwge2hlbGxvOiBuYW1lfSk7XG4gKiAgICAgfSwgMTAwMCk7XG4gKiB9O1xuICpcbiAqIC8vIGluIHRoZSBub2RlIHJlcGxcbiAqIG5vZGU+IGFzeW5jLmRpcihoZWxsbywgJ3dvcmxkJyk7XG4gKiB7aGVsbG86ICd3b3JsZCd9XG4gKi9cbnZhciBkaXIgPSBjb25zb2xlRnVuYygnZGlyJyk7XG5cbi8qKlxuICogVGhlIHBvc3QtY2hlY2sgdmVyc2lvbiBvZiBbYGR1cmluZ2Bde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5kdXJpbmd9LiBUbyByZWZsZWN0IHRoZSBkaWZmZXJlbmNlIGluXG4gKiB0aGUgb3JkZXIgb2Ygb3BlcmF0aW9ucywgdGhlIGFyZ3VtZW50cyBgdGVzdGAgYW5kIGBmbmAgYXJlIHN3aXRjaGVkLlxuICpcbiAqIEFsc28gYSB2ZXJzaW9uIG9mIFtgZG9XaGlsc3RgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuZG9XaGlsc3R9IHdpdGggYXN5bmNocm9ub3VzIGB0ZXN0YCBmdW5jdGlvbi5cbiAqIEBuYW1lIGRvRHVyaW5nXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5kdXJpbmdde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5kdXJpbmd9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZVxuICogYHRlc3RgIHBhc3Nlcy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHRlc3QgLSBhc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGJlZm9yZSBlYWNoXG4gKiBleGVjdXRpb24gb2YgYGZuYC4gSW52b2tlZCB3aXRoICguLi5hcmdzLCBjYWxsYmFjayksIHdoZXJlIGAuLi5hcmdzYCBhcmUgdGhlXG4gKiBub24tZXJyb3IgYXJncyBmcm9tIHRoZSBwcmV2aW91cyBjYWxsYmFjayBvZiBgZm5gLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0XG4gKiBmdW5jdGlvbiBoYXMgZmFpbGVkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGZuYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYFxuICogd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgaWYgb25lIG9jY3VycmVkLCBvdGhlcndpc2UgYG51bGxgLlxuICovXG5mdW5jdGlvbiBkb0R1cmluZyhmbiwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9ubHlPbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoZm4pO1xuICAgIHZhciBfdGVzdCA9IHdyYXBBc3luYyh0ZXN0KTtcblxuICAgIGZ1bmN0aW9uIG5leHQoZXJyLyosIC4uLmFyZ3MqLykge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICBhcmdzLnB1c2goY2hlY2spO1xuICAgICAgICBfdGVzdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVjayhlcnIsIHRydXRoKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICBpZiAoIXRydXRoKSByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIF9mbihuZXh0KTtcbiAgICB9XG5cbiAgICBjaGVjayhudWxsLCB0cnVlKTtcblxufVxuXG4vKipcbiAqIFRoZSBwb3N0LWNoZWNrIHZlcnNpb24gb2YgW2B3aGlsc3RgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cud2hpbHN0fS4gVG8gcmVmbGVjdCB0aGUgZGlmZmVyZW5jZSBpblxuICogdGhlIG9yZGVyIG9mIG9wZXJhdGlvbnMsIHRoZSBhcmd1bWVudHMgYHRlc3RgIGFuZCBgaXRlcmF0ZWVgIGFyZSBzd2l0Y2hlZC5cbiAqXG4gKiBgZG9XaGlsc3RgIGlzIHRvIGB3aGlsc3RgIGFzIGBkbyB3aGlsZWAgaXMgdG8gYHdoaWxlYCBpbiBwbGFpbiBKYXZhU2NyaXB0LlxuICpcbiAqIEBuYW1lIGRvV2hpbHN0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy53aGlsc3Rde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53aGlsc3R9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZWFjaCB0aW1lIGB0ZXN0YFxuICogcGFzc2VzLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRlc3QgLSBzeW5jaHJvbm91cyB0cnV0aCB0ZXN0IHRvIHBlcmZvcm0gYWZ0ZXIgZWFjaFxuICogZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAuIEludm9rZWQgd2l0aCBhbnkgbm9uLWVycm9yIGNhbGxiYWNrIHJlc3VsdHMgb2ZcbiAqIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRlc3RcbiAqIGZ1bmN0aW9uIGhhcyBmYWlsZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgIGhhcyBzdG9wcGVkLlxuICogYGNhbGxiYWNrYCB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciBhbmQgYW55IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZpbmFsXG4gKiBgaXRlcmF0ZWVgJ3MgY2FsbGJhY2suIEludm9rZWQgd2l0aCAoZXJyLCBbcmVzdWx0c10pO1xuICovXG5mdW5jdGlvbiBkb1doaWxzdChpdGVyYXRlZSwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9ubHlPbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgIHZhciBuZXh0ID0gZnVuY3Rpb24oZXJyLyosIC4uLmFyZ3MqLykge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICBpZiAodGVzdC5hcHBseSh0aGlzLCBhcmdzKSkgcmV0dXJuIF9pdGVyYXRlZShuZXh0KTtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgW251bGxdLmNvbmNhdChhcmdzKSk7XG4gICAgfTtcbiAgICBfaXRlcmF0ZWUobmV4dCk7XG59XG5cbi8qKlxuICogTGlrZSBbJ2RvV2hpbHN0J117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmRvV2hpbHN0fSwgZXhjZXB0IHRoZSBgdGVzdGAgaXMgaW52ZXJ0ZWQuIE5vdGUgdGhlXG4gKiBhcmd1bWVudCBvcmRlcmluZyBkaWZmZXJzIGZyb20gYHVudGlsYC5cbiAqXG4gKiBAbmFtZSBkb1VudGlsXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5kb1doaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmRvV2hpbHN0fVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBlYWNoIHRpbWVcbiAqIGB0ZXN0YCBmYWlscy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0ZXN0IC0gc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGFmdGVyIGVhY2hcbiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggYW55IG5vbi1lcnJvciBjYWxsYmFjayByZXN1bHRzIG9mXG4gKiBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0XG4gKiBmdW5jdGlvbiBoYXMgcGFzc2VkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYFxuICogd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgYW5kIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3NcbiAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKTtcbiAqL1xuZnVuY3Rpb24gZG9VbnRpbChpdGVyYXRlZSwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICBkb1doaWxzdChpdGVyYXRlZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBMaWtlIFtgd2hpbHN0YF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH0sIGV4Y2VwdCB0aGUgYHRlc3RgIGlzIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0XG4gKiBpcyBwYXNzZWQgYSBjYWxsYmFjayBpbiB0aGUgZm9ybSBvZiBgZnVuY3Rpb24gKGVyciwgdHJ1dGgpYC4gSWYgZXJyb3IgaXNcbiAqIHBhc3NlZCB0byBgdGVzdGAgb3IgYGZuYCwgdGhlIG1haW4gY2FsbGJhY2sgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlXG4gKiB2YWx1ZSBvZiB0aGUgZXJyb3IuXG4gKlxuICogQG5hbWUgZHVyaW5nXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy53aGlsc3Rde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53aGlsc3R9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHRlc3QgLSBhc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGJlZm9yZSBlYWNoXG4gKiBleGVjdXRpb24gb2YgYGZuYC4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZVxuICogYHRlc3RgIHBhc3Nlcy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRlc3RcbiAqIGZ1bmN0aW9uIGhhcyBmYWlsZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgZm5gIGhhcyBzdG9wcGVkLiBgY2FsbGJhY2tgXG4gKiB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciwgaWYgb25lIG9jY3VycmVkLCBvdGhlcndpc2UgYG51bGxgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgY291bnQgPSAwO1xuICpcbiAqIGFzeW5jLmR1cmluZyhcbiAqICAgICBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAqICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGNvdW50IDwgNSk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAqICAgICAgICAgY291bnQrKztcbiAqICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICAgIC8vIDUgc2Vjb25kcyBoYXZlIHBhc3NlZFxuICogICAgIH1cbiAqICk7XG4gKi9cbmZ1bmN0aW9uIGR1cmluZyh0ZXN0LCBmbiwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9ubHlPbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoZm4pO1xuICAgIHZhciBfdGVzdCA9IHdyYXBBc3luYyh0ZXN0KTtcblxuICAgIGZ1bmN0aW9uIG5leHQoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICBfdGVzdChjaGVjayk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2soZXJyLCB0cnV0aCkge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgaWYgKCF0cnV0aCkgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICBfZm4obmV4dCk7XG4gICAgfVxuXG4gICAgX3Rlc3QoY2hlY2spO1xufVxuXG5mdW5jdGlvbiBfd2l0aG91dEluZGV4KGl0ZXJhdGVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSwgY2FsbGJhY2spO1xuICAgIH07XG59XG5cbi8qKlxuICogQXBwbGllcyB0aGUgZnVuY3Rpb24gYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLCBpbiBwYXJhbGxlbC5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIGNhbGxlZCB3aXRoIGFuIGl0ZW0gZnJvbSB0aGUgbGlzdCwgYW5kIGEgY2FsbGJhY2sgZm9yIHdoZW5cbiAqIGl0IGhhcyBmaW5pc2hlZC4gSWYgdGhlIGBpdGVyYXRlZWAgcGFzc2VzIGFuIGVycm9yIHRvIGl0cyBgY2FsbGJhY2tgLCB0aGVcbiAqIG1haW4gYGNhbGxiYWNrYCAoZm9yIHRoZSBgZWFjaGAgZnVuY3Rpb24pIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZVxuICogZXJyb3IuXG4gKlxuICogTm90ZSwgdGhhdCBzaW5jZSB0aGlzIGZ1bmN0aW9uIGFwcGxpZXMgYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4gcGFyYWxsZWwsXG4gKiB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgaXRlcmF0ZWUgZnVuY3Rpb25zIHdpbGwgY29tcGxldGUgaW4gb3JkZXIuXG4gKlxuICogQG5hbWUgZWFjaFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGFsaWFzIGZvckVhY2hcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG9cbiAqIGVhY2ggaXRlbSBpbiBgY29sbGAuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogVGhlIGFycmF5IGluZGV4IGlzIG5vdCBwYXNzZWQgdG8gdGhlIGl0ZXJhdGVlLlxuICogSWYgeW91IG5lZWQgdGhlIGluZGV4LCB1c2UgYGVhY2hPZmAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBhc3N1bWluZyBvcGVuRmlsZXMgaXMgYW4gYXJyYXkgb2YgZmlsZSBuYW1lcyBhbmQgc2F2ZUZpbGUgaXMgYSBmdW5jdGlvblxuICogLy8gdG8gc2F2ZSB0aGUgbW9kaWZpZWQgY29udGVudHMgb2YgdGhhdCBmaWxlOlxuICpcbiAqIGFzeW5jLmVhY2gob3BlbkZpbGVzLCBzYXZlRmlsZSwgZnVuY3Rpb24oZXJyKXtcbiAqICAgLy8gaWYgYW55IG9mIHRoZSBzYXZlcyBwcm9kdWNlZCBhbiBlcnJvciwgZXJyIHdvdWxkIGVxdWFsIHRoYXQgZXJyb3JcbiAqIH0pO1xuICpcbiAqIC8vIGFzc3VtaW5nIG9wZW5GaWxlcyBpcyBhbiBhcnJheSBvZiBmaWxlIG5hbWVzXG4gKiBhc3luYy5lYWNoKG9wZW5GaWxlcywgZnVuY3Rpb24oZmlsZSwgY2FsbGJhY2spIHtcbiAqXG4gKiAgICAgLy8gUGVyZm9ybSBvcGVyYXRpb24gb24gZmlsZSBoZXJlLlxuICogICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzaW5nIGZpbGUgJyArIGZpbGUpO1xuICpcbiAqICAgICBpZiggZmlsZS5sZW5ndGggPiAzMiApIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCdUaGlzIGZpbGUgbmFtZSBpcyB0b28gbG9uZycpO1xuICogICAgICAgY2FsbGJhY2soJ0ZpbGUgbmFtZSB0b28gbG9uZycpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAvLyBEbyB3b3JrIHRvIHByb2Nlc3MgZmlsZSBoZXJlXG4gKiAgICAgICBjb25zb2xlLmxvZygnRmlsZSBwcm9jZXNzZWQnKTtcbiAqICAgICAgIGNhbGxiYWNrKCk7XG4gKiAgICAgfVxuICogfSwgZnVuY3Rpb24oZXJyKSB7XG4gKiAgICAgLy8gaWYgYW55IG9mIHRoZSBmaWxlIHByb2Nlc3NpbmcgcHJvZHVjZWQgYW4gZXJyb3IsIGVyciB3b3VsZCBlcXVhbCB0aGF0IGVycm9yXG4gKiAgICAgaWYoIGVyciApIHtcbiAqICAgICAgIC8vIE9uZSBvZiB0aGUgaXRlcmF0aW9ucyBwcm9kdWNlZCBhbiBlcnJvci5cbiAqICAgICAgIC8vIEFsbCBwcm9jZXNzaW5nIHdpbGwgbm93IHN0b3AuXG4gKiAgICAgICBjb25zb2xlLmxvZygnQSBmaWxlIGZhaWxlZCB0byBwcm9jZXNzJyk7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCdBbGwgZmlsZXMgaGF2ZSBiZWVuIHByb2Nlc3NlZCBzdWNjZXNzZnVsbHknKTtcbiAqICAgICB9XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gZWFjaExpbWl0KGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGVhY2hPZihjb2xsLCBfd2l0aG91dEluZGV4KHdyYXBBc3luYyhpdGVyYXRlZSkpLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BlYWNoYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGVhY2hMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZWFjaF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9XG4gKiBAYWxpYXMgZm9yRWFjaExpbWl0XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIGFycmF5IGluZGV4IGlzIG5vdCBwYXNzZWQgdG8gdGhlIGl0ZXJhdGVlLlxuICogSWYgeW91IG5lZWQgdGhlIGluZGV4LCB1c2UgYGVhY2hPZkxpbWl0YC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqL1xuZnVuY3Rpb24gZWFjaExpbWl0JDEoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIF9lYWNoT2ZMaW1pdChsaW1pdCkoY29sbCwgX3dpdGhvdXRJbmRleCh3cmFwQXN5bmMoaXRlcmF0ZWUpKSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZWFjaGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZWFjaFNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZWFjaF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9XG4gKiBAYWxpYXMgZm9yRWFjaFNlcmllc1xuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoXG4gKiBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBhcnJheSBpbmRleCBpcyBub3QgcGFzc2VkIHRvIHRoZSBpdGVyYXRlZS5cbiAqIElmIHlvdSBuZWVkIHRoZSBpbmRleCwgdXNlIGBlYWNoT2ZTZXJpZXNgLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICovXG52YXIgZWFjaFNlcmllcyA9IGRvTGltaXQoZWFjaExpbWl0JDEsIDEpO1xuXG4vKipcbiAqIFdyYXAgYW4gYXN5bmMgZnVuY3Rpb24gYW5kIGVuc3VyZSBpdCBjYWxscyBpdHMgY2FsbGJhY2sgb24gYSBsYXRlciB0aWNrIG9mXG4gKiB0aGUgZXZlbnQgbG9vcC4gIElmIHRoZSBmdW5jdGlvbiBhbHJlYWR5IGNhbGxzIGl0cyBjYWxsYmFjayBvbiBhIG5leHQgdGljayxcbiAqIG5vIGV4dHJhIGRlZmVycmFsIGlzIGFkZGVkLiBUaGlzIGlzIHVzZWZ1bCBmb3IgcHJldmVudGluZyBzdGFjayBvdmVyZmxvd3NcbiAqIChgUmFuZ2VFcnJvcjogTWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRgKSBhbmQgZ2VuZXJhbGx5IGtlZXBpbmdcbiAqIFtaYWxnb10oaHR0cDovL2Jsb2cuaXpzLm1lL3Bvc3QvNTkxNDI3NDIxNDMvZGVzaWduaW5nLWFwaXMtZm9yLWFzeW5jaHJvbnkpXG4gKiBjb250YWluZWQuIEVTMjAxNyBgYXN5bmNgIGZ1bmN0aW9ucyBhcmUgcmV0dXJuZWQgYXMtaXMgLS0gdGhleSBhcmUgaW1tdW5lXG4gKiB0byBaYWxnbydzIGNvcnJ1cHRpbmcgaW5mbHVlbmNlcywgYXMgdGhleSBhbHdheXMgcmVzb2x2ZSBvbiBhIGxhdGVyIHRpY2suXG4gKlxuICogQG5hbWUgZW5zdXJlQXN5bmNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gYW4gYXN5bmMgZnVuY3Rpb24sIG9uZSB0aGF0IGV4cGVjdHMgYSBub2RlLXN0eWxlXG4gKiBjYWxsYmFjayBhcyBpdHMgbGFzdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBSZXR1cm5zIGEgd3JhcHBlZCBmdW5jdGlvbiB3aXRoIHRoZSBleGFjdCBzYW1lIGNhbGxcbiAqIHNpZ25hdHVyZSBhcyB0aGUgZnVuY3Rpb24gcGFzc2VkIGluLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBzb21ldGltZXNBc3luYyhhcmcsIGNhbGxiYWNrKSB7XG4gKiAgICAgaWYgKGNhY2hlW2FyZ10pIHtcbiAqICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGNhY2hlW2FyZ10pOyAvLyB0aGlzIHdvdWxkIGJlIHN5bmNocm9ub3VzISFcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBkb1NvbWVJTyhhcmcsIGNhbGxiYWNrKTsgLy8gdGhpcyBJTyB3b3VsZCBiZSBhc3luY2hyb25vdXNcbiAqICAgICB9XG4gKiB9XG4gKlxuICogLy8gdGhpcyBoYXMgYSByaXNrIG9mIHN0YWNrIG92ZXJmbG93cyBpZiBtYW55IHJlc3VsdHMgYXJlIGNhY2hlZCBpbiBhIHJvd1xuICogYXN5bmMubWFwU2VyaWVzKGFyZ3MsIHNvbWV0aW1lc0FzeW5jLCBkb25lKTtcbiAqXG4gKiAvLyB0aGlzIHdpbGwgZGVmZXIgc29tZXRpbWVzQXN5bmMncyBjYWxsYmFjayBpZiBuZWNlc3NhcnksXG4gKiAvLyBwcmV2ZW50aW5nIHN0YWNrIG92ZXJmbG93c1xuICogYXN5bmMubWFwU2VyaWVzKGFyZ3MsIGFzeW5jLmVuc3VyZUFzeW5jKHNvbWV0aW1lc0FzeW5jKSwgZG9uZSk7XG4gKi9cbmZ1bmN0aW9uIGVuc3VyZUFzeW5jKGZuKSB7XG4gICAgaWYgKGlzQXN5bmMoZm4pKSByZXR1cm4gZm47XG4gICAgcmV0dXJuIGluaXRpYWxQYXJhbXMoZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzeW5jID0gdHJ1ZTtcbiAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbm5lckFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgaW5uZXJBcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgaW5uZXJBcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBzeW5jID0gZmFsc2U7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG5vdElkKHYpIHtcbiAgICByZXR1cm4gIXY7XG59XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgZXZlcnkgZWxlbWVudCBpbiBgY29sbGAgc2F0aXNmaWVzIGFuIGFzeW5jIHRlc3QuIElmIGFueVxuICogaXRlcmF0ZWUgY2FsbCByZXR1cm5zIGBmYWxzZWAsIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkLlxuICpcbiAqIEBuYW1lIGV2ZXJ5XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgYWxsXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtXG4gKiBpbiB0aGUgY29sbGVjdGlvbiBpbiBwYXJhbGxlbC5cbiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHJlc3VsdCB2YWx1ZS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYFxuICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuZXZlcnkoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZVBhdGgsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycilcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gaWYgcmVzdWx0IGlzIHRydWUgdGhlbiBldmVyeSBmaWxlIGV4aXN0c1xuICogfSk7XG4gKi9cbnZhciBldmVyeSA9IGRvUGFyYWxsZWwoX2NyZWF0ZVRlc3Rlcihub3RJZCwgbm90SWQpKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGV2ZXJ5YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmV2ZXJ5fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBldmVyeUxpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5ldmVyeV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmV2ZXJ5fVxuICogQGFsaWFzIGFsbExpbWl0XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtXG4gKiBpbiB0aGUgY29sbGVjdGlvbiBpbiBwYXJhbGxlbC5cbiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHJlc3VsdCB2YWx1ZS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYFxuICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqL1xudmFyIGV2ZXJ5TGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2NyZWF0ZVRlc3Rlcihub3RJZCwgbm90SWQpKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGV2ZXJ5YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmV2ZXJ5fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZXZlcnlTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmV2ZXJ5XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZXZlcnl9XG4gKiBAYWxpYXMgYWxsU2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtXG4gKiBpbiB0aGUgY29sbGVjdGlvbiBpbiBzZXJpZXMuXG4gKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiByZXN1bHQgdmFsdWUuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWBcbiAqIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIHRoZSBhc3luYyB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKi9cbnZhciBldmVyeVNlcmllcyA9IGRvTGltaXQoZXZlcnlMaW1pdCwgMSk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbHRlckFycmF5KGVhY2hmbiwgYXJyLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgdHJ1dGhWYWx1ZXMgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGluZGV4LCBjYWxsYmFjaykge1xuICAgICAgICBpdGVyYXRlZSh4LCBmdW5jdGlvbiAoZXJyLCB2KSB7XG4gICAgICAgICAgICB0cnV0aFZhbHVlc1tpbmRleF0gPSAhIXY7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRydXRoVmFsdWVzW2ldKSByZXN1bHRzLnB1c2goYXJyW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZmlsdGVyR2VuZXJpYyhlYWNoZm4sIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgZWFjaGZuKGNvbGwsIGZ1bmN0aW9uICh4LCBpbmRleCwgY2FsbGJhY2spIHtcbiAgICAgICAgaXRlcmF0ZWUoeCwgZnVuY3Rpb24gKGVyciwgdikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7aW5kZXg6IGluZGV4LCB2YWx1ZTogeH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBhcnJheU1hcChyZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgICAgICAgICB9KSwgYmFzZVByb3BlcnR5KCd2YWx1ZScpKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gX2ZpbHRlcihlYWNoZm4sIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWx0ZXIgPSBpc0FycmF5TGlrZShjb2xsKSA/IGZpbHRlckFycmF5IDogZmlsdGVyR2VuZXJpYztcbiAgICBmaWx0ZXIoZWFjaGZuLCBjb2xsLCB3cmFwQXN5bmMoaXRlcmF0ZWUpLCBjYWxsYmFjayB8fCBub29wKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGFsbCB0aGUgdmFsdWVzIGluIGBjb2xsYCB3aGljaCBwYXNzIGFuIGFzeW5jIHRydXRoXG4gKiB0ZXN0LiBUaGlzIG9wZXJhdGlvbiBpcyBwZXJmb3JtZWQgaW4gcGFyYWxsZWwsIGJ1dCB0aGUgcmVzdWx0cyBhcnJheSB3aWxsIGJlXG4gKiBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgb3JpZ2luYWwuXG4gKlxuICogQG5hbWUgZmlsdGVyXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgc2VsZWN0XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy5maWx0ZXIoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZVBhdGgsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycilcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHJlc3VsdHMgbm93IGVxdWFscyBhbiBhcnJheSBvZiB0aGUgZXhpc3RpbmcgZmlsZXNcbiAqIH0pO1xuICovXG52YXIgZmlsdGVyID0gZG9QYXJhbGxlbChfZmlsdGVyKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGZpbHRlcmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYVxuICogdGltZS5cbiAqXG4gKiBAbmFtZSBmaWx0ZXJMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZmlsdGVyXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfVxuICogQGFsaWFzIHNlbGVjdExpbWl0XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICovXG52YXIgZmlsdGVyTGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2ZpbHRlcik7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BmaWx0ZXJgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZmlsdGVyU2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5maWx0ZXJde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9XG4gKiBAYWxpYXMgc2VsZWN0U2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpXG4gKi9cbnZhciBmaWx0ZXJTZXJpZXMgPSBkb0xpbWl0KGZpbHRlckxpbWl0LCAxKTtcblxuLyoqXG4gKiBDYWxscyB0aGUgYXN5bmNocm9ub3VzIGZ1bmN0aW9uIGBmbmAgd2l0aCBhIGNhbGxiYWNrIHBhcmFtZXRlciB0aGF0IGFsbG93cyBpdFxuICogdG8gY2FsbCBpdHNlbGYgYWdhaW4sIGluIHNlcmllcywgaW5kZWZpbml0ZWx5LlxuXG4gKiBJZiBhbiBlcnJvciBpcyBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIHRoZW4gYGVycmJhY2tgIGlzIGNhbGxlZCB3aXRoIHRoZVxuICogZXJyb3IsIGFuZCBleGVjdXRpb24gc3RvcHMsIG90aGVyd2lzZSBpdCB3aWxsIG5ldmVyIGJlIGNhbGxlZC5cbiAqXG4gKiBAbmFtZSBmb3JldmVyXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gYW4gYXN5bmMgZnVuY3Rpb24gdG8gY2FsbCByZXBlYXRlZGx5LlxuICogSW52b2tlZCB3aXRoIChuZXh0KS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJiYWNrXSAtIHdoZW4gYGZuYCBwYXNzZXMgYW4gZXJyb3IgdG8gaXQncyBjYWxsYmFjayxcbiAqIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQsIGFuZCBleGVjdXRpb24gc3RvcHMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuZm9yZXZlcihcbiAqICAgICBmdW5jdGlvbihuZXh0KSB7XG4gKiAgICAgICAgIC8vIG5leHQgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgdG8gdGhpbmdzIHRoYXQgbmVlZCBhIGNhbGxiYWNrKGVyciBbLCB3aGF0ZXZlcl0pO1xuICogICAgICAgICAvLyBpdCB3aWxsIHJlc3VsdCBpbiB0aGlzIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCBhZ2Fpbi5cbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGVycikge1xuICogICAgICAgICAvLyBpZiBuZXh0IGlzIGNhbGxlZCB3aXRoIGEgdmFsdWUgaW4gaXRzIGZpcnN0IHBhcmFtZXRlciwgaXQgd2lsbCBhcHBlYXJcbiAqICAgICAgICAgLy8gaW4gaGVyZSBhcyAnZXJyJywgYW5kIGV4ZWN1dGlvbiB3aWxsIHN0b3AuXG4gKiAgICAgfVxuICogKTtcbiAqL1xuZnVuY3Rpb24gZm9yZXZlcihmbiwgZXJyYmFjaykge1xuICAgIHZhciBkb25lID0gb25seU9uY2UoZXJyYmFjayB8fCBub29wKTtcbiAgICB2YXIgdGFzayA9IHdyYXBBc3luYyhlbnN1cmVBc3luYyhmbikpO1xuXG4gICAgZnVuY3Rpb24gbmV4dChlcnIpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgdGFzayhuZXh0KTtcbiAgICB9XG4gICAgbmV4dCgpO1xufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZ3JvdXBCeWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBncm91cEJ5TGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmdyb3VwQnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGBrZXlgIHRvIGdyb3VwIHRoZSB2YWx1ZSB1bmRlci5cbiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHQgaXMgYW4gYE9iamVjdGAgd2hvc2VzXG4gKiBwcm9wZXJ0aWVzIGFyZSBhcnJheXMgb2YgdmFsdWVzIHdoaWNoIHJldHVybmVkIHRoZSBjb3JyZXNwb25kaW5nIGtleS5cbiAqL1xudmFyIGdyb3VwQnlMaW1pdCA9IGZ1bmN0aW9uKGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7XG4gICAgbWFwTGltaXQoY29sbCwgbGltaXQsIGZ1bmN0aW9uKHZhbCwgY2FsbGJhY2spIHtcbiAgICAgICAgX2l0ZXJhdGVlKHZhbCwgZnVuY3Rpb24oZXJyLCBrZXkpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtrZXk6IGtleSwgdmFsOiB2YWx9KTtcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24oZXJyLCBtYXBSZXN1bHRzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgLy8gZnJvbSBNRE4sIGhhbmRsZSBvYmplY3QgaGF2aW5nIGFuIGBoYXNPd25Qcm9wZXJ0eWAgcHJvcFxuICAgICAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwUmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG1hcFJlc3VsdHNbaV0pIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gbWFwUmVzdWx0c1tpXS5rZXk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IG1hcFJlc3VsdHNbaV0udmFsO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IFt2YWxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgb2JqZWN0LCB3aGVyZSBlYWNoIHZhbHVlIGNvcnJlc3BvbmRzIHRvIGFuIGFycmF5IG9mIGl0ZW1zLCBmcm9tXG4gKiBgY29sbGAsIHRoYXQgcmV0dXJuZWQgdGhlIGNvcnJlc3BvbmRpbmcga2V5LiBUaGF0IGlzLCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0XG4gKiBjb3JyZXNwb25kIHRvIHRoZSB2YWx1ZXMgcGFzc2VkIHRvIHRoZSBgaXRlcmF0ZWVgIGNhbGxiYWNrLlxuICpcbiAqIE5vdGU6IFNpbmNlIHRoaXMgZnVuY3Rpb24gYXBwbGllcyB0aGUgYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4gcGFyYWxsZWwsXG4gKiB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgd2lsbCBjb21wbGV0ZSBpbiBvcmRlci5cbiAqIEhvd2V2ZXIsIHRoZSB2YWx1ZXMgZm9yIGVhY2gga2V5IGluIHRoZSBgcmVzdWx0YCB3aWxsIGJlIGluIHRoZSBzYW1lIG9yZGVyIGFzXG4gKiB0aGUgb3JpZ2luYWwgYGNvbGxgLiBGb3IgT2JqZWN0cywgdGhlIHZhbHVlcyB3aWxsIHJvdWdobHkgYmUgaW4gdGhlIG9yZGVyIG9mXG4gKiB0aGUgb3JpZ2luYWwgT2JqZWN0cycga2V5cyAoYnV0IHRoaXMgY2FuIHZhcnkgYWNyb3NzIEphdmFTY3JpcHQgZW5naW5lcykuXG4gKlxuICogQG5hbWUgZ3JvdXBCeVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGBrZXlgIHRvIGdyb3VwIHRoZSB2YWx1ZSB1bmRlci5cbiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHQgaXMgYW4gYE9iamVjdGAgd2hvc2VzXG4gKiBwcm9wZXJ0aWVzIGFyZSBhcnJheXMgb2YgdmFsdWVzIHdoaWNoIHJldHVybmVkIHRoZSBjb3JyZXNwb25kaW5nIGtleS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuZ3JvdXBCeShbJ3VzZXJJZDEnLCAndXNlcklkMicsICd1c2VySWQzJ10sIGZ1bmN0aW9uKHVzZXJJZCwgY2FsbGJhY2spIHtcbiAqICAgICBkYi5maW5kQnlJZCh1c2VySWQsIGZ1bmN0aW9uKGVyciwgdXNlcikge1xuICogICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAqICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHVzZXIuYWdlKTtcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gcmVzdWx0IGlzIG9iamVjdCBjb250YWluaW5nIHRoZSB1c2VySWRzIGdyb3VwZWQgYnkgYWdlXG4gKiAgICAgLy8gZS5nLiB7IDMwOiBbJ3VzZXJJZDEnLCAndXNlcklkMyddLCA0MjogWyd1c2VySWQyJ119O1xuICogfSk7XG4gKi9cbnZhciBncm91cEJ5ID0gZG9MaW1pdChncm91cEJ5TGltaXQsIEluZmluaXR5KTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGdyb3VwQnlgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZ3JvdXBCeX0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGdyb3VwQnlTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmdyb3VwQnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGBrZXlgIHRvIGdyb3VwIHRoZSB2YWx1ZSB1bmRlci5cbiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHQgaXMgYW4gYE9iamVjdGAgd2hvc2VzXG4gKiBwcm9wZXJ0aWVzIGFyZSBhcnJheXMgb2YgdmFsdWVzIHdoaWNoIHJldHVybmVkIHRoZSBjb3JyZXNwb25kaW5nIGtleS5cbiAqL1xudmFyIGdyb3VwQnlTZXJpZXMgPSBkb0xpbWl0KGdyb3VwQnlMaW1pdCwgMSk7XG5cbi8qKlxuICogTG9ncyB0aGUgcmVzdWx0IG9mIGFuIGBhc3luY2AgZnVuY3Rpb24gdG8gdGhlIGBjb25zb2xlYC4gT25seSB3b3JrcyBpblxuICogTm9kZS5qcyBvciBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgYGNvbnNvbGUubG9nYCBhbmQgYGNvbnNvbGUuZXJyb3JgIChzdWNoXG4gKiBhcyBGRiBhbmQgQ2hyb21lKS4gSWYgbXVsdGlwbGUgYXJndW1lbnRzIGFyZSByZXR1cm5lZCBmcm9tIHRoZSBhc3luY1xuICogZnVuY3Rpb24sIGBjb25zb2xlLmxvZ2AgaXMgY2FsbGVkIG9uIGVhY2ggYXJndW1lbnQgaW4gb3JkZXIuXG4gKlxuICogQG5hbWUgbG9nXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmdW5jdGlvbiAtIFRoZSBmdW5jdGlvbiB5b3Ugd2FudCB0byBldmVudHVhbGx5IGFwcGx5XG4gKiBhbGwgYXJndW1lbnRzIHRvLlxuICogQHBhcmFtIHsuLi4qfSBhcmd1bWVudHMuLi4gLSBBbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGluIGEgbW9kdWxlXG4gKiB2YXIgaGVsbG8gPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdoZWxsbyAnICsgbmFtZSk7XG4gKiAgICAgfSwgMTAwMCk7XG4gKiB9O1xuICpcbiAqIC8vIGluIHRoZSBub2RlIHJlcGxcbiAqIG5vZGU+IGFzeW5jLmxvZyhoZWxsbywgJ3dvcmxkJyk7XG4gKiAnaGVsbG8gd29ybGQnXG4gKi9cbnZhciBsb2cgPSBjb25zb2xlRnVuYygnbG9nJyk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BtYXBWYWx1ZXNgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwVmFsdWVzfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgbWFwVmFsdWVzTGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLm1hcFZhbHVlc117QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcFZhbHVlc31cbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggdmFsdWUgYW5kIGtleVxuICogaW4gYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZSBhcyBpdHMgcmVzdWx0LlxuICogSW52b2tlZCB3aXRoICh2YWx1ZSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gYHJlc3VsdGAgaXMgYSBuZXcgb2JqZWN0IGNvbnNpc3RpbmdcbiAqIG9mIGVhY2gga2V5IGZyb20gYG9iamAsIHdpdGggZWFjaCB0cmFuc2Zvcm1lZCB2YWx1ZSBvbiB0aGUgcmlnaHQtaGFuZCBzaWRlLlxuICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKi9cbmZ1bmN0aW9uIG1hcFZhbHVlc0xpbWl0KG9iaiwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICB2YXIgbmV3T2JqID0ge307XG4gICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7XG4gICAgZWFjaE9mTGltaXQob2JqLCBsaW1pdCwgZnVuY3Rpb24odmFsLCBrZXksIG5leHQpIHtcbiAgICAgICAgX2l0ZXJhdGVlKHZhbCwga2V5LCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBuZXh0KGVycik7XG4gICAgICAgICAgICBuZXdPYmpba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIsIG5ld09iaik7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQSByZWxhdGl2ZSBvZiBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LCBkZXNpZ25lZCBmb3IgdXNlIHdpdGggb2JqZWN0cy5cbiAqXG4gKiBQcm9kdWNlcyBhIG5ldyBPYmplY3QgYnkgbWFwcGluZyBlYWNoIHZhbHVlIG9mIGBvYmpgIHRocm91Z2ggdGhlIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9uLiBUaGUgYGl0ZXJhdGVlYCBpcyBjYWxsZWQgZWFjaCBgdmFsdWVgIGFuZCBga2V5YCBmcm9tIGBvYmpgIGFuZCBhXG4gKiBjYWxsYmFjayBmb3Igd2hlbiBpdCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZy4gRWFjaCBvZiB0aGVzZSBjYWxsYmFja3MgdGFrZXNcbiAqIHR3byBhcmd1bWVudHM6IGFuIGBlcnJvcmAsIGFuZCB0aGUgdHJhbnNmb3JtZWQgaXRlbSBmcm9tIGBvYmpgLiBJZiBgaXRlcmF0ZWVgXG4gKiBwYXNzZXMgYW4gZXJyb3IgdG8gaXRzIGNhbGxiYWNrLCB0aGUgbWFpbiBgY2FsbGJhY2tgIChmb3IgdGhlIGBtYXBWYWx1ZXNgXG4gKiBmdW5jdGlvbikgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLlxuICpcbiAqIE5vdGUsIHRoZSBvcmRlciBvZiB0aGUga2V5cyBpbiB0aGUgcmVzdWx0IGlzIG5vdCBndWFyYW50ZWVkLiAgVGhlIGtleXMgd2lsbFxuICogYmUgcm91Z2hseSBpbiB0aGUgb3JkZXIgdGhleSBjb21wbGV0ZSwgKGJ1dCB0aGlzIGlzIHZlcnkgZW5naW5lLXNwZWNpZmljKVxuICpcbiAqIEBuYW1lIG1hcFZhbHVlc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB2YWx1ZSBhbmQga2V5XG4gKiBpbiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIHZhbHVlIGFzIGl0cyByZXN1bHQuXG4gKiBJbnZva2VkIHdpdGggKHZhbHVlLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBgcmVzdWx0YCBpcyBhIG5ldyBvYmplY3QgY29uc2lzdGluZ1xuICogb2YgZWFjaCBrZXkgZnJvbSBgb2JqYCwgd2l0aCBlYWNoIHRyYW5zZm9ybWVkIHZhbHVlIG9uIHRoZSByaWdodC1oYW5kIHNpZGUuXG4gKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMubWFwVmFsdWVzKHtcbiAqICAgICBmMTogJ2ZpbGUxJyxcbiAqICAgICBmMjogJ2ZpbGUyJyxcbiAqICAgICBmMzogJ2ZpbGUzJ1xuICogfSwgZnVuY3Rpb24gKGZpbGUsIGtleSwgY2FsbGJhY2spIHtcbiAqICAgZnMuc3RhdChmaWxlLCBjYWxsYmFjayk7XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIHJlc3VsdCBpcyBub3cgYSBtYXAgb2Ygc3RhdHMgZm9yIGVhY2ggZmlsZSwgZS5nLlxuICogICAgIC8vIHtcbiAqICAgICAvLyAgICAgZjE6IFtzdGF0cyBmb3IgZmlsZTFdLFxuICogICAgIC8vICAgICBmMjogW3N0YXRzIGZvciBmaWxlMl0sXG4gKiAgICAgLy8gICAgIGYzOiBbc3RhdHMgZm9yIGZpbGUzXVxuICogICAgIC8vIH1cbiAqIH0pO1xuICovXG5cbnZhciBtYXBWYWx1ZXMgPSBkb0xpbWl0KG1hcFZhbHVlc0xpbWl0LCBJbmZpbml0eSk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BtYXBWYWx1ZXNgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwVmFsdWVzfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgbWFwVmFsdWVzU2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5tYXBWYWx1ZXNde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXBWYWx1ZXN9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIHZhbHVlIGFuZCBrZXlcbiAqIGluIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgdmFsdWUgYXMgaXRzIHJlc3VsdC5cbiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGtleSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIGByZXN1bHRgIGlzIGEgbmV3IG9iamVjdCBjb25zaXN0aW5nXG4gKiBvZiBlYWNoIGtleSBmcm9tIGBvYmpgLCB3aXRoIGVhY2ggdHJhbnNmb3JtZWQgdmFsdWUgb24gdGhlIHJpZ2h0LWhhbmQgc2lkZS5cbiAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICovXG52YXIgbWFwVmFsdWVzU2VyaWVzID0gZG9MaW1pdChtYXBWYWx1ZXNMaW1pdCwgMSk7XG5cbmZ1bmN0aW9uIGhhcyhvYmosIGtleSkge1xuICAgIHJldHVybiBrZXkgaW4gb2JqO1xufVxuXG4vKipcbiAqIENhY2hlcyB0aGUgcmVzdWx0cyBvZiBhbiBhc3luYyBmdW5jdGlvbi4gV2hlbiBjcmVhdGluZyBhIGhhc2ggdG8gc3RvcmVcbiAqIGZ1bmN0aW9uIHJlc3VsdHMgYWdhaW5zdCwgdGhlIGNhbGxiYWNrIGlzIG9taXR0ZWQgZnJvbSB0aGUgaGFzaCBhbmQgYW5cbiAqIG9wdGlvbmFsIGhhc2ggZnVuY3Rpb24gY2FuIGJlIHVzZWQuXG4gKlxuICogSWYgbm8gaGFzaCBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIHRoZSBmaXJzdCBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGFzaCBrZXksXG4gKiB3aGljaCBtYXkgd29yayByZWFzb25hYmx5IGlmIGl0IGlzIGEgc3RyaW5nIG9yIGEgZGF0YSB0eXBlIHRoYXQgY29udmVydHMgdG8gYVxuICogZGlzdGluY3Qgc3RyaW5nLiBOb3RlIHRoYXQgb2JqZWN0cyBhbmQgYXJyYXlzIHdpbGwgbm90IGJlaGF2ZSByZWFzb25hYmx5LlxuICogTmVpdGhlciB3aWxsIGNhc2VzIHdoZXJlIHRoZSBvdGhlciBhcmd1bWVudHMgYXJlIHNpZ25pZmljYW50LiBJbiBzdWNoIGNhc2VzLFxuICogc3BlY2lmeSB5b3VyIG93biBoYXNoIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSBjYWNoZSBvZiByZXN1bHRzIGlzIGV4cG9zZWQgYXMgdGhlIGBtZW1vYCBwcm9wZXJ0eSBvZiB0aGUgZnVuY3Rpb25cbiAqIHJldHVybmVkIGJ5IGBtZW1vaXplYC5cbiAqXG4gKiBAbmFtZSBtZW1vaXplXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmbiAtIFRoZSBhc3luYyBmdW5jdGlvbiB0byBwcm94eSBhbmQgY2FjaGUgcmVzdWx0cyBmcm9tLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzaGVyIC0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gZm9yIGdlbmVyYXRpbmcgYSBjdXN0b20gaGFzaFxuICogZm9yIHN0b3JpbmcgcmVzdWx0cy4gSXQgaGFzIGFsbCB0aGUgYXJndW1lbnRzIGFwcGxpZWQgdG8gaXQgYXBhcnQgZnJvbSB0aGVcbiAqIGNhbGxiYWNrLCBhbmQgbXVzdCBiZSBzeW5jaHJvbm91cy5cbiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBhIG1lbW9pemVkIHZlcnNpb24gb2YgYGZuYFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgc2xvd19mbiA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nXG4gKiAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAqIH07XG4gKiB2YXIgZm4gPSBhc3luYy5tZW1vaXplKHNsb3dfZm4pO1xuICpcbiAqIC8vIGZuIGNhbiBub3cgYmUgdXNlZCBhcyBpZiBpdCB3ZXJlIHNsb3dfZm5cbiAqIGZuKCdzb21lIG5hbWUnLCBmdW5jdGlvbigpIHtcbiAqICAgICAvLyBjYWxsYmFja1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZm4sIGhhc2hlcikge1xuICAgIHZhciBtZW1vID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcXVldWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBoYXNoZXIgPSBoYXNoZXIgfHwgaWRlbnRpdHk7XG4gICAgdmFyIF9mbiA9IHdyYXBBc3luYyhmbik7XG4gICAgdmFyIG1lbW9pemVkID0gaW5pdGlhbFBhcmFtcyhmdW5jdGlvbiBtZW1vaXplZChhcmdzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICBpZiAoaGFzKG1lbW8sIGtleSkpIHtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIG1lbW9ba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXMocXVldWVzLCBrZXkpKSB7XG4gICAgICAgICAgICBxdWV1ZXNba2V5XS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlc1trZXldID0gW2NhbGxiYWNrXTtcbiAgICAgICAgICAgIF9mbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChmdW5jdGlvbigvKmFyZ3MqLykge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBtZW1vW2tleV0gPSBhcmdzO1xuICAgICAgICAgICAgICAgIHZhciBxID0gcXVldWVzW2tleV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcVtpXS5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBtZW1vaXplZC5tZW1vID0gbWVtbztcbiAgICBtZW1vaXplZC51bm1lbW9pemVkID0gZm47XG4gICAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vKipcbiAqIENhbGxzIGBjYWxsYmFja2Agb24gYSBsYXRlciBsb29wIGFyb3VuZCB0aGUgZXZlbnQgbG9vcC4gSW4gTm9kZS5qcyB0aGlzIGp1c3RcbiAqIGNhbGxzIGBwcm9jZXNzLm5leHRUaWNrYC4gIEluIHRoZSBicm93c2VyIGl0IHdpbGwgdXNlIGBzZXRJbW1lZGlhdGVgIGlmXG4gKiBhdmFpbGFibGUsIG90aGVyd2lzZSBgc2V0VGltZW91dChjYWxsYmFjaywgMClgLCB3aGljaCBtZWFucyBvdGhlciBoaWdoZXJcbiAqIHByaW9yaXR5IGV2ZW50cyBtYXkgcHJlY2VkZSB0aGUgZXhlY3V0aW9uIG9mIGBjYWxsYmFja2AuXG4gKlxuICogVGhpcyBpcyB1c2VkIGludGVybmFsbHkgZm9yIGJyb3dzZXItY29tcGF0aWJpbGl0eSBwdXJwb3Nlcy5cbiAqXG4gKiBAbmFtZSBuZXh0VGlja1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuc2V0SW1tZWRpYXRlXXtAbGluayBtb2R1bGU6VXRpbHMuc2V0SW1tZWRpYXRlfVxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gYSBsYXRlciBsb29wIGFyb3VuZFxuICogdGhlIGV2ZW50IGxvb3AuIEludm9rZWQgd2l0aCAoYXJncy4uLikuXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MuLi4gLSBhbnkgbnVtYmVyIG9mIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlXG4gKiBjYWxsYmFjayBvbiB0aGUgbmV4dCB0aWNrLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgY2FsbF9vcmRlciA9IFtdO1xuICogYXN5bmMubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gKiAgICAgY2FsbF9vcmRlci5wdXNoKCd0d28nKTtcbiAqICAgICAvLyBjYWxsX29yZGVyIG5vdyBlcXVhbHMgWydvbmUnLCd0d28nXVxuICogfSk7XG4gKiBjYWxsX29yZGVyLnB1c2goJ29uZScpO1xuICpcbiAqIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbiAoYSwgYiwgYykge1xuICogICAgIC8vIGEsIGIsIGFuZCBjIGVxdWFsIDEsIDIsIGFuZCAzXG4gKiB9LCAxLCAyLCAzKTtcbiAqL1xudmFyIF9kZWZlciQxO1xuXG5pZiAoaGFzTmV4dFRpY2spIHtcbiAgICBfZGVmZXIkMSA9IHByb2Nlc3MubmV4dFRpY2s7XG59IGVsc2UgaWYgKGhhc1NldEltbWVkaWF0ZSkge1xuICAgIF9kZWZlciQxID0gc2V0SW1tZWRpYXRlO1xufSBlbHNlIHtcbiAgICBfZGVmZXIkMSA9IGZhbGxiYWNrO1xufVxuXG52YXIgbmV4dFRpY2sgPSB3cmFwKF9kZWZlciQxKTtcblxuZnVuY3Rpb24gX3BhcmFsbGVsKGVhY2hmbiwgdGFza3MsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICAgIHZhciByZXN1bHRzID0gaXNBcnJheUxpa2UodGFza3MpID8gW10gOiB7fTtcblxuICAgIGVhY2hmbih0YXNrcywgZnVuY3Rpb24gKHRhc2ssIGtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgd3JhcEFzeW5jKHRhc2spKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBSdW4gdGhlIGB0YXNrc2AgY29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgaW4gcGFyYWxsZWwsIHdpdGhvdXQgd2FpdGluZyB1bnRpbFxuICogdGhlIHByZXZpb3VzIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQuIElmIGFueSBvZiB0aGUgZnVuY3Rpb25zIHBhc3MgYW4gZXJyb3IgdG9cbiAqIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlXG4gKiBlcnJvci4gT25jZSB0aGUgYHRhc2tzYCBoYXZlIGNvbXBsZXRlZCwgdGhlIHJlc3VsdHMgYXJlIHBhc3NlZCB0byB0aGUgZmluYWxcbiAqIGBjYWxsYmFja2AgYXMgYW4gYXJyYXkuXG4gKlxuICogKipOb3RlOioqIGBwYXJhbGxlbGAgaXMgYWJvdXQga2lja2luZy1vZmYgSS9PIHRhc2tzIGluIHBhcmFsbGVsLCBub3QgYWJvdXRcbiAqIHBhcmFsbGVsIGV4ZWN1dGlvbiBvZiBjb2RlLiAgSWYgeW91ciB0YXNrcyBkbyBub3QgdXNlIGFueSB0aW1lcnMgb3IgcGVyZm9ybVxuICogYW55IEkvTywgdGhleSB3aWxsIGFjdHVhbGx5IGJlIGV4ZWN1dGVkIGluIHNlcmllcy4gIEFueSBzeW5jaHJvbm91cyBzZXR1cFxuICogc2VjdGlvbnMgZm9yIGVhY2ggdGFzayB3aWxsIGhhcHBlbiBvbmUgYWZ0ZXIgdGhlIG90aGVyLiAgSmF2YVNjcmlwdCByZW1haW5zXG4gKiBzaW5nbGUtdGhyZWFkZWQuXG4gKlxuICogKipIaW50OioqIFVzZSBbYHJlZmxlY3RgXXtAbGluayBtb2R1bGU6VXRpbHMucmVmbGVjdH0gdG8gY29udGludWUgdGhlXG4gKiBleGVjdXRpb24gb2Ygb3RoZXIgdGFza3Mgd2hlbiBhIHRhc2sgZmFpbHMuXG4gKlxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byB1c2UgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIEVhY2ggcHJvcGVydHkgd2lsbFxuICogYmUgcnVuIGFzIGEgZnVuY3Rpb24gYW5kIHRoZSByZXN1bHRzIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBmaW5hbCBgY2FsbGJhY2tgXG4gKiBhcyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheS4gVGhpcyBjYW4gYmUgYSBtb3JlIHJlYWRhYmxlIHdheSBvZiBoYW5kbGluZ1xuICogcmVzdWx0cyBmcm9tIHtAbGluayBhc3luYy5wYXJhbGxlbH0uXG4gKlxuICogQG5hbWUgcGFyYWxsZWxcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSB0YXNrcyAtIEEgY29sbGVjdGlvbiBvZlxuICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuLlxuICogRWFjaCBhc3luYyBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBydW4gb25jZSBhbGwgdGhlXG4gKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5XG4gKiAob3Igb2JqZWN0KSBjb250YWluaW5nIGFsbCB0aGUgcmVzdWx0IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHRhc2sgY2FsbGJhY2tzLlxuICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBhc3luYy5wYXJhbGxlbChbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogXSxcbiAqIC8vIG9wdGlvbmFsIGNhbGxiYWNrXG4gKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAvLyB0aGUgcmVzdWx0cyBhcnJheSB3aWxsIGVxdWFsIFsnb25lJywndHdvJ10gZXZlbiB0aG91Z2hcbiAqICAgICAvLyB0aGUgc2Vjb25kIGZ1bmN0aW9uIGhhZCBhIHNob3J0ZXIgdGltZW91dC5cbiAqIH0pO1xuICpcbiAqIC8vIGFuIGV4YW1wbGUgdXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXlcbiAqIGFzeW5jLnBhcmFsbGVsKHtcbiAqICAgICBvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAxKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIHR3bzogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDIpO1xuICogICAgICAgICB9LCAxMDApO1xuICogICAgIH1cbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGVxdWFscyB0bzoge29uZTogMSwgdHdvOiAyfVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHBhcmFsbGVsTGltaXQodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgX3BhcmFsbGVsKGVhY2hPZiwgdGFza3MsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYHBhcmFsbGVsYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnBhcmFsbGVsfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgcGFyYWxsZWxMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMucGFyYWxsZWxde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5wYXJhbGxlbH1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSB0YXNrcyAtIEEgY29sbGVjdGlvbiBvZlxuICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuLlxuICogRWFjaCBhc3luYyBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBydW4gb25jZSBhbGwgdGhlXG4gKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5XG4gKiAob3Igb2JqZWN0KSBjb250YWluaW5nIGFsbCB0aGUgcmVzdWx0IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHRhc2sgY2FsbGJhY2tzLlxuICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICovXG5mdW5jdGlvbiBwYXJhbGxlbExpbWl0JDEodGFza3MsIGxpbWl0LCBjYWxsYmFjaykge1xuICAgIF9wYXJhbGxlbChfZWFjaE9mTGltaXQobGltaXQpLCB0YXNrcywgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIEEgcXVldWUgb2YgdGFza3MgZm9yIHRoZSB3b3JrZXIgZnVuY3Rpb24gdG8gY29tcGxldGUuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBRdWV1ZU9iamVjdFxuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbGVuZ3RoIC0gYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG51bWJlciBvZiBpdGVtc1xuICogd2FpdGluZyB0byBiZSBwcm9jZXNzZWQuIEludm9rZSB3aXRoIGBxdWV1ZS5sZW5ndGgoKWAuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHN0YXJ0ZWQgLSBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCBhbnlcbiAqIGl0ZW1zIGhhdmUgYmVlbiBwdXNoZWQgYW5kIHByb2Nlc3NlZCBieSB0aGUgcXVldWUuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBydW5uaW5nIC0gYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG51bWJlciBvZiBpdGVtc1xuICogY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC4gSW52b2tlIHdpdGggYHF1ZXVlLnJ1bm5pbmcoKWAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB3b3JrZXJzTGlzdCAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBhcnJheSBvZiBpdGVtc1xuICogY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC4gSW52b2tlIHdpdGggYHF1ZXVlLndvcmtlcnNMaXN0KClgLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaWRsZSAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGZhbHNlIGlmIHRoZXJlIGFyZSBpdGVtc1xuICogd2FpdGluZyBvciBiZWluZyBwcm9jZXNzZWQsIG9yIHRydWUgaWYgbm90LiBJbnZva2Ugd2l0aCBgcXVldWUuaWRsZSgpYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb25jdXJyZW5jeSAtIGFuIGludGVnZXIgZm9yIGRldGVybWluaW5nIGhvdyBtYW55IGB3b3JrZXJgXG4gKiBmdW5jdGlvbnMgc2hvdWxkIGJlIHJ1biBpbiBwYXJhbGxlbC4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgY2hhbmdlZCBhZnRlciBhXG4gKiBgcXVldWVgIGlzIGNyZWF0ZWQgdG8gYWx0ZXIgdGhlIGNvbmN1cnJlbmN5IG9uLXRoZS1mbHkuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBwdXNoIC0gYWRkIGEgbmV3IHRhc2sgdG8gdGhlIGBxdWV1ZWAuIENhbGxzIGBjYWxsYmFja2BcbiAqIG9uY2UgdGhlIGB3b3JrZXJgIGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nIHRoZSB0YXNrLiBJbnN0ZWFkIG9mIGEgc2luZ2xlIHRhc2ssXG4gKiBhIGB0YXNrc2AgYXJyYXkgY2FuIGJlIHN1Ym1pdHRlZC4gVGhlIHJlc3BlY3RpdmUgY2FsbGJhY2sgaXMgdXNlZCBmb3IgZXZlcnlcbiAqIHRhc2sgaW4gdGhlIGxpc3QuIEludm9rZSB3aXRoIGBxdWV1ZS5wdXNoKHRhc2ssIFtjYWxsYmFja10pYCxcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVuc2hpZnQgLSBhZGQgYSBuZXcgdGFzayB0byB0aGUgZnJvbnQgb2YgdGhlIGBxdWV1ZWAuXG4gKiBJbnZva2Ugd2l0aCBgcXVldWUudW5zaGlmdCh0YXNrLCBbY2FsbGJhY2tdKWAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSByZW1vdmUgLSByZW1vdmUgaXRlbXMgZnJvbSB0aGUgcXVldWUgdGhhdCBtYXRjaCBhIHRlc3RcbiAqIGZ1bmN0aW9uLiAgVGhlIHRlc3QgZnVuY3Rpb24gd2lsbCBiZSBwYXNzZWQgYW4gb2JqZWN0IHdpdGggYSBgZGF0YWAgcHJvcGVydHksXG4gKiBhbmQgYSBgcHJpb3JpdHlgIHByb3BlcnR5LCBpZiB0aGlzIGlzIGFcbiAqIFtwcmlvcml0eVF1ZXVlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucHJpb3JpdHlRdWV1ZX0gb2JqZWN0LlxuICogSW52b2tlZCB3aXRoIGBxdWV1ZS5yZW1vdmUodGVzdEZuKWAsIHdoZXJlIGB0ZXN0Rm5gIGlzIG9mIHRoZSBmb3JtXG4gKiBgZnVuY3Rpb24gKHtkYXRhLCBwcmlvcml0eX0pIHt9YCBhbmQgcmV0dXJucyBhIEJvb2xlYW4uXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBzYXR1cmF0ZWQgLSBhIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIG51bWJlciBvZlxuICogcnVubmluZyB3b3JrZXJzIGhpdHMgdGhlIGBjb25jdXJyZW5jeWAgbGltaXQsIGFuZCBmdXJ0aGVyIHRhc2tzIHdpbGwgYmVcbiAqIHF1ZXVlZC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVuc2F0dXJhdGVkIC0gYSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBudW1iZXJcbiAqIG9mIHJ1bm5pbmcgd29ya2VycyBpcyBsZXNzIHRoYW4gdGhlIGBjb25jdXJyZW5jeWAgJiBgYnVmZmVyYCBsaW1pdHMsIGFuZFxuICogZnVydGhlciB0YXNrcyB3aWxsIG5vdCBiZSBxdWV1ZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gYnVmZmVyIC0gQSBtaW5pbXVtIHRocmVzaG9sZCBidWZmZXIgaW4gb3JkZXIgdG8gc2F5IHRoYXRcbiAqIHRoZSBgcXVldWVgIGlzIGB1bnNhdHVyYXRlZGAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlbXB0eSAtIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbGFzdCBpdGVtXG4gKiBmcm9tIHRoZSBgcXVldWVgIGlzIGdpdmVuIHRvIGEgYHdvcmtlcmAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkcmFpbiAtIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbGFzdCBpdGVtXG4gKiBmcm9tIHRoZSBgcXVldWVgIGhhcyByZXR1cm5lZCBmcm9tIHRoZSBgd29ya2VyYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVycm9yIC0gYSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIGEgdGFzayBlcnJvcnMuXG4gKiBIYXMgdGhlIHNpZ25hdHVyZSBgZnVuY3Rpb24oZXJyb3IsIHRhc2spYC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcGF1c2VkIC0gYSBib29sZWFuIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBxdWV1ZSBpc1xuICogaW4gYSBwYXVzZWQgc3RhdGUuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBwYXVzZSAtIGEgZnVuY3Rpb24gdGhhdCBwYXVzZXMgdGhlIHByb2Nlc3Npbmcgb2YgdGFza3NcbiAqIHVudGlsIGByZXN1bWUoKWAgaXMgY2FsbGVkLiBJbnZva2Ugd2l0aCBgcXVldWUucGF1c2UoKWAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSByZXN1bWUgLSBhIGZ1bmN0aW9uIHRoYXQgcmVzdW1lcyB0aGUgcHJvY2Vzc2luZyBvZlxuICogcXVldWVkIHRhc2tzIHdoZW4gdGhlIHF1ZXVlIGlzIHBhdXNlZC4gSW52b2tlIHdpdGggYHF1ZXVlLnJlc3VtZSgpYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGtpbGwgLSBhIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgYGRyYWluYCBjYWxsYmFjayBhbmRcbiAqIGVtcHRpZXMgcmVtYWluaW5nIHRhc2tzIGZyb20gdGhlIHF1ZXVlIGZvcmNpbmcgaXQgdG8gZ28gaWRsZS4gTm8gbW9yZSB0YXNrc1xuICogc2hvdWxkIGJlIHB1c2hlZCB0byB0aGUgcXVldWUgYWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLiBJbnZva2Ugd2l0aCBgcXVldWUua2lsbCgpYC5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgcXVldWVgIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgYGNvbmN1cnJlbmN5YC4gVGFza3MgYWRkZWQgdG8gdGhlXG4gKiBgcXVldWVgIGFyZSBwcm9jZXNzZWQgaW4gcGFyYWxsZWwgKHVwIHRvIHRoZSBgY29uY3VycmVuY3lgIGxpbWl0KS4gSWYgYWxsXG4gKiBgd29ya2VyYHMgYXJlIGluIHByb2dyZXNzLCB0aGUgdGFzayBpcyBxdWV1ZWQgdW50aWwgb25lIGJlY29tZXMgYXZhaWxhYmxlLlxuICogT25jZSBhIGB3b3JrZXJgIGNvbXBsZXRlcyBhIGB0YXNrYCwgdGhhdCBgdGFza2AncyBjYWxsYmFjayBpcyBjYWxsZWQuXG4gKlxuICogQG5hbWUgcXVldWVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gd29ya2VyIC0gQW4gYXN5bmMgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZWQgdGFzay5cbiAqIElmIHlvdSB3YW50IHRvIGhhbmRsZSBlcnJvcnMgZnJvbSBhbiBpbmRpdmlkdWFsIHRhc2ssIHBhc3MgYSBjYWxsYmFjayB0b1xuICogYHEucHVzaCgpYC4gSW52b2tlZCB3aXRoICh0YXNrLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbmN5PTFdIC0gQW4gYGludGVnZXJgIGZvciBkZXRlcm1pbmluZyBob3cgbWFueVxuICogYHdvcmtlcmAgZnVuY3Rpb25zIHNob3VsZCBiZSBydW4gaW4gcGFyYWxsZWwuICBJZiBvbWl0dGVkLCB0aGUgY29uY3VycmVuY3lcbiAqIGRlZmF1bHRzIHRvIGAxYC4gIElmIHRoZSBjb25jdXJyZW5jeSBpcyBgMGAsIGFuIGVycm9yIGlzIHRocm93bi5cbiAqIEByZXR1cm5zIHttb2R1bGU6Q29udHJvbEZsb3cuUXVldWVPYmplY3R9IEEgcXVldWUgb2JqZWN0IHRvIG1hbmFnZSB0aGUgdGFza3MuIENhbGxiYWNrcyBjYW5cbiAqIGF0dGFjaGVkIGFzIGNlcnRhaW4gcHJvcGVydGllcyB0byBsaXN0ZW4gZm9yIHNwZWNpZmljIGV2ZW50cyBkdXJpbmcgdGhlXG4gKiBsaWZlY3ljbGUgb2YgdGhlIHF1ZXVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBjcmVhdGUgYSBxdWV1ZSBvYmplY3Qgd2l0aCBjb25jdXJyZW5jeSAyXG4gKiB2YXIgcSA9IGFzeW5jLnF1ZXVlKGZ1bmN0aW9uKHRhc2ssIGNhbGxiYWNrKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2hlbGxvICcgKyB0YXNrLm5hbWUpO1xuICogICAgIGNhbGxiYWNrKCk7XG4gKiB9LCAyKTtcbiAqXG4gKiAvLyBhc3NpZ24gYSBjYWxsYmFja1xuICogcS5kcmFpbiA9IGZ1bmN0aW9uKCkge1xuICogICAgIGNvbnNvbGUubG9nKCdhbGwgaXRlbXMgaGF2ZSBiZWVuIHByb2Nlc3NlZCcpO1xuICogfTtcbiAqXG4gKiAvLyBhZGQgc29tZSBpdGVtcyB0byB0aGUgcXVldWVcbiAqIHEucHVzaCh7bmFtZTogJ2Zvbyd9LCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBmb28nKTtcbiAqIH0pO1xuICogcS5wdXNoKHtuYW1lOiAnYmFyJ30sIGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBiYXInKTtcbiAqIH0pO1xuICpcbiAqIC8vIGFkZCBzb21lIGl0ZW1zIHRvIHRoZSBxdWV1ZSAoYmF0Y2gtd2lzZSlcbiAqIHEucHVzaChbe25hbWU6ICdiYXonfSx7bmFtZTogJ2JheSd9LHtuYW1lOiAnYmF4J31dLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBpdGVtJyk7XG4gKiB9KTtcbiAqXG4gKiAvLyBhZGQgc29tZSBpdGVtcyB0byB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlXG4gKiBxLnVuc2hpZnQoe25hbWU6ICdiYXInfSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpO1xuICogfSk7XG4gKi9cbnZhciBxdWV1ZSQxID0gZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHtcbiAgICB2YXIgX3dvcmtlciA9IHdyYXBBc3luYyh3b3JrZXIpO1xuICAgIHJldHVybiBxdWV1ZShmdW5jdGlvbiAoaXRlbXMsIGNiKSB7XG4gICAgICAgIF93b3JrZXIoaXRlbXNbMF0sIGNiKTtcbiAgICB9LCBjb25jdXJyZW5jeSwgMSk7XG59O1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFthc3luYy5xdWV1ZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnF1ZXVlfSBvbmx5IHRhc2tzIGFyZSBhc3NpZ25lZCBhIHByaW9yaXR5IGFuZFxuICogY29tcGxldGVkIGluIGFzY2VuZGluZyBwcmlvcml0eSBvcmRlci5cbiAqXG4gKiBAbmFtZSBwcmlvcml0eVF1ZXVlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5xdWV1ZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnF1ZXVlfVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB3b3JrZXIgLSBBbiBhc3luYyBmdW5jdGlvbiBmb3IgcHJvY2Vzc2luZyBhIHF1ZXVlZCB0YXNrLlxuICogSWYgeW91IHdhbnQgdG8gaGFuZGxlIGVycm9ycyBmcm9tIGFuIGluZGl2aWR1YWwgdGFzaywgcGFzcyBhIGNhbGxiYWNrIHRvXG4gKiBgcS5wdXNoKClgLlxuICogSW52b2tlZCB3aXRoICh0YXNrLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge251bWJlcn0gY29uY3VycmVuY3kgLSBBbiBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nIGhvdyBtYW55IGB3b3JrZXJgXG4gKiBmdW5jdGlvbnMgc2hvdWxkIGJlIHJ1biBpbiBwYXJhbGxlbC4gIElmIG9taXR0ZWQsIHRoZSBjb25jdXJyZW5jeSBkZWZhdWx0cyB0b1xuICogYDFgLiAgSWYgdGhlIGNvbmN1cnJlbmN5IGlzIGAwYCwgYW4gZXJyb3IgaXMgdGhyb3duLlxuICogQHJldHVybnMge21vZHVsZTpDb250cm9sRmxvdy5RdWV1ZU9iamVjdH0gQSBwcmlvcml0eVF1ZXVlIG9iamVjdCB0byBtYW5hZ2UgdGhlIHRhc2tzLiBUaGVyZSBhcmUgdHdvXG4gKiBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBxdWV1ZWAgYW5kIGBwcmlvcml0eVF1ZXVlYCBvYmplY3RzOlxuICogKiBgcHVzaCh0YXNrLCBwcmlvcml0eSwgW2NhbGxiYWNrXSlgIC0gYHByaW9yaXR5YCBzaG91bGQgYmUgYSBudW1iZXIuIElmIGFuXG4gKiAgIGFycmF5IG9mIGB0YXNrc2AgaXMgZ2l2ZW4sIGFsbCB0YXNrcyB3aWxsIGJlIGFzc2lnbmVkIHRoZSBzYW1lIHByaW9yaXR5LlxuICogKiBUaGUgYHVuc2hpZnRgIG1ldGhvZCB3YXMgcmVtb3ZlZC5cbiAqL1xudmFyIHByaW9yaXR5UXVldWUgPSBmdW5jdGlvbih3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG4gICAgLy8gU3RhcnQgd2l0aCBhIG5vcm1hbCBxdWV1ZVxuICAgIHZhciBxID0gcXVldWUkMSh3b3JrZXIsIGNvbmN1cnJlbmN5KTtcblxuICAgIC8vIE92ZXJyaWRlIHB1c2ggdG8gYWNjZXB0IHNlY29uZCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIHByaW9yaXR5XG4gICAgcS5wdXNoID0gZnVuY3Rpb24oZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsKSBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGFzayBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIWlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xuICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJpb3JpdHkgPSBwcmlvcml0eSB8fCAwO1xuICAgICAgICB2YXIgbmV4dE5vZGUgPSBxLl90YXNrcy5oZWFkO1xuICAgICAgICB3aGlsZSAobmV4dE5vZGUgJiYgcHJpb3JpdHkgPj0gbmV4dE5vZGUucHJpb3JpdHkpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gbmV4dE5vZGUubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFbaV0sXG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKG5leHROb2RlKSB7XG4gICAgICAgICAgICAgICAgcS5fdGFza3MuaW5zZXJ0QmVmb3JlKG5leHROb2RlLCBpdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcS5fdGFza3MucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRJbW1lZGlhdGUkMShxLnByb2Nlc3MpO1xuICAgIH07XG5cbiAgICAvLyBSZW1vdmUgdW5zaGlmdCBmdW5jdGlvblxuICAgIGRlbGV0ZSBxLnVuc2hpZnQ7XG5cbiAgICByZXR1cm4gcTtcbn07XG5cbi8qKlxuICogUnVucyB0aGUgYHRhc2tzYCBhcnJheSBvZiBmdW5jdGlvbnMgaW4gcGFyYWxsZWwsIHdpdGhvdXQgd2FpdGluZyB1bnRpbCB0aGVcbiAqIHByZXZpb3VzIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQuIE9uY2UgYW55IG9mIHRoZSBgdGFza3NgIGNvbXBsZXRlIG9yIHBhc3MgYW5cbiAqIGVycm9yIHRvIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQuIEl0J3NcbiAqIGVxdWl2YWxlbnQgdG8gYFByb21pc2UucmFjZSgpYC5cbiAqXG4gKiBAbmFtZSByYWNlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FycmF5fSB0YXNrcyAtIEFuIGFycmF5IGNvbnRhaW5pbmcgW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn1cbiAqIHRvIHJ1bi4gRWFjaCBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbiBvcHRpb25hbCBgcmVzdWx0YCB2YWx1ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQSBjYWxsYmFjayB0byBydW4gb25jZSBhbnkgb2YgdGhlIGZ1bmN0aW9ucyBoYXZlXG4gKiBjb21wbGV0ZWQuIFRoaXMgZnVuY3Rpb24gZ2V0cyBhbiBlcnJvciBvciByZXN1bHQgZnJvbSB0aGUgZmlyc3QgZnVuY3Rpb24gdGhhdFxuICogY29tcGxldGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHVuZGVmaW5lZFxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy5yYWNlKFtcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICogICAgICAgICB9LCAyMDApO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAqICAgICAgICAgfSwgMTAwKTtcbiAqICAgICB9XG4gKiBdLFxuICogLy8gbWFpbiBjYWxsYmFja1xuICogZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyB0aGUgcmVzdWx0IHdpbGwgYmUgZXF1YWwgdG8gJ3R3bycgYXMgaXQgZmluaXNoZXMgZWFybGllclxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHJhY2UodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgIGlmICghaXNBcnJheSh0YXNrcykpIHJldHVybiBjYWxsYmFjayhuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCB0byByYWNlIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJykpO1xuICAgIGlmICghdGFza3MubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2soKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRhc2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB3cmFwQXN5bmModGFza3NbaV0pKGNhbGxiYWNrKTtcbiAgICB9XG59XG5cbi8qKlxuICogU2FtZSBhcyBbYHJlZHVjZWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWR1Y2V9LCBvbmx5IG9wZXJhdGVzIG9uIGBhcnJheWAgaW4gcmV2ZXJzZSBvcmRlci5cbiAqXG4gKiBAbmFtZSByZWR1Y2VSaWdodFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMucmVkdWNlXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVkdWNlfVxuICogQGFsaWFzIGZvbGRyXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHsqfSBtZW1vIC0gVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIHJlZHVjdGlvbi5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIGFwcGxpZWQgdG8gZWFjaCBpdGVtIGluIHRoZVxuICogYXJyYXkgdG8gcHJvZHVjZSB0aGUgbmV4dCBzdGVwIGluIHRoZSByZWR1Y3Rpb24uXG4gKiBUaGUgYGl0ZXJhdGVlYCBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgbmV4dCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLlxuICogSWYgdGhlIGl0ZXJhdGVlIGNvbXBsZXRlIHdpdGggYW4gZXJyb3IsIHRoZSByZWR1Y3Rpb24gaXMgc3RvcHBlZCBhbmQgdGhlXG4gKiBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLlxuICogSW52b2tlZCB3aXRoIChtZW1vLCBpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IGlzIHRoZSByZWR1Y2VkIHZhbHVlLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdCkuXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZVJpZ2h0IChhcnJheSwgbWVtbywgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJldmVyc2VkID0gc2xpY2UoYXJyYXkpLnJldmVyc2UoKTtcbiAgICByZWR1Y2UocmV2ZXJzZWQsIG1lbW8sIGl0ZXJhdGVlLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogV3JhcHMgdGhlIGFzeW5jIGZ1bmN0aW9uIGluIGFub3RoZXIgZnVuY3Rpb24gdGhhdCBhbHdheXMgY29tcGxldGVzIHdpdGggYVxuICogcmVzdWx0IG9iamVjdCwgZXZlbiB3aGVuIGl0IGVycm9ycy5cbiAqXG4gKiBUaGUgcmVzdWx0IG9iamVjdCBoYXMgZWl0aGVyIHRoZSBwcm9wZXJ0eSBgZXJyb3JgIG9yIGB2YWx1ZWAuXG4gKlxuICogQG5hbWUgcmVmbGVjdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSBUaGUgYXN5bmMgZnVuY3Rpb24geW91IHdhbnQgdG8gd3JhcFxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIEEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcGFzc2VzIG51bGwgdG8gaXQncyBjYWxsYmFjayBhc1xuICogdGhlIGVycm9yLiBUaGUgc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBjYWxsYmFjayB3aWxsIGJlIGFuIGBvYmplY3RgIHdpdGhcbiAqIGVpdGhlciBhbiBgZXJyb3JgIG9yIGEgYHZhbHVlYCBwcm9wZXJ0eS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMucGFyYWxsZWwoW1xuICogICAgIGFzeW5jLnJlZmxlY3QoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gZG8gc29tZSBzdHVmZiAuLi5cbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICogICAgIH0pLFxuICogICAgIGFzeW5jLnJlZmxlY3QoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gZG8gc29tZSBtb3JlIHN0dWZmIGJ1dCBlcnJvciAuLi5cbiAqICAgICAgICAgY2FsbGJhY2soJ2JhZCBzdHVmZiBoYXBwZW5lZCcpO1xuICogICAgIH0pLFxuICogICAgIGFzeW5jLnJlZmxlY3QoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gZG8gc29tZSBtb3JlIHN0dWZmIC4uLlxuICogICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gKiAgICAgfSlcbiAqIF0sXG4gKiAvLyBvcHRpb25hbCBjYWxsYmFja1xuICogZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgLy8gdmFsdWVzXG4gKiAgICAgLy8gcmVzdWx0c1swXS52YWx1ZSA9ICdvbmUnXG4gKiAgICAgLy8gcmVzdWx0c1sxXS5lcnJvciA9ICdiYWQgc3R1ZmYgaGFwcGVuZWQnXG4gKiAgICAgLy8gcmVzdWx0c1syXS52YWx1ZSA9ICd0d28nXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gcmVmbGVjdChmbikge1xuICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoZm4pO1xuICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIHJlZmxlY3RPbihhcmdzLCByZWZsZWN0Q2FsbGJhY2spIHtcbiAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uIGNhbGxiYWNrKGVycm9yLCBjYkFyZykge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVmbGVjdENhbGxiYWNrKG51bGwsIHsgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNiQXJnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVmbGVjdENhbGxiYWNrKG51bGwsIHsgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gX2ZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYW4gYXJyYXkgb3IgYW4gb2JqZWN0IG9mIGZ1bmN0aW9ucyB3aXRoIGByZWZsZWN0YC5cbiAqXG4gKiBAbmFtZSByZWZsZWN0QWxsXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5yZWZsZWN0XXtAbGluayBtb2R1bGU6VXRpbHMucmVmbGVjdH1cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxJdGVyYWJsZX0gdGFza3MgLSBUaGUgY29sbGVjdGlvbiBvZlxuICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gd3JhcCBpbiBgYXN5bmMucmVmbGVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgYXN5bmMgZnVuY3Rpb25zLCBlYWNoIHdyYXBwZWQgaW5cbiAqIGBhc3luYy5yZWZsZWN0YFxuICogQGV4YW1wbGVcbiAqXG4gKiBsZXQgdGFza3MgPSBbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGRvIHNvbWUgbW9yZSBzdHVmZiBidXQgZXJyb3IgLi4uXG4gKiAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignYmFkIHN0dWZmIGhhcHBlbmVkJykpO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAqICAgICAgICAgfSwgMTAwKTtcbiAqICAgICB9XG4gKiBdO1xuICpcbiAqIGFzeW5jLnBhcmFsbGVsKGFzeW5jLnJlZmxlY3RBbGwodGFza3MpLFxuICogLy8gb3B0aW9uYWwgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHZhbHVlc1xuICogICAgIC8vIHJlc3VsdHNbMF0udmFsdWUgPSAnb25lJ1xuICogICAgIC8vIHJlc3VsdHNbMV0uZXJyb3IgPSBFcnJvcignYmFkIHN0dWZmIGhhcHBlbmVkJylcbiAqICAgICAvLyByZXN1bHRzWzJdLnZhbHVlID0gJ3R3bydcbiAqIH0pO1xuICpcbiAqIC8vIGFuIGV4YW1wbGUgdXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXlcbiAqIGxldCB0YXNrcyA9IHtcbiAqICAgICBvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7XG4gKiAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgfSxcbiAqICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKCd0d28nKTtcbiAqICAgICB9LFxuICogICAgIHRocmVlOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3RocmVlJyk7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogfTtcbiAqXG4gKiBhc3luYy5wYXJhbGxlbChhc3luYy5yZWZsZWN0QWxsKHRhc2tzKSxcbiAqIC8vIG9wdGlvbmFsIGNhbGxiYWNrXG4gKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAvLyB2YWx1ZXNcbiAqICAgICAvLyByZXN1bHRzLm9uZS52YWx1ZSA9ICdvbmUnXG4gKiAgICAgLy8gcmVzdWx0cy50d28uZXJyb3IgPSAndHdvJ1xuICogICAgIC8vIHJlc3VsdHMudGhyZWUudmFsdWUgPSAndGhyZWUnXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gcmVmbGVjdEFsbCh0YXNrcykge1xuICAgIHZhciByZXN1bHRzO1xuICAgIGlmIChpc0FycmF5KHRhc2tzKSkge1xuICAgICAgICByZXN1bHRzID0gYXJyYXlNYXAodGFza3MsIHJlZmxlY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgYmFzZUZvck93bih0YXNrcywgZnVuY3Rpb24odGFzaywga2V5KSB7XG4gICAgICAgICAgICByZXN1bHRzW2tleV0gPSByZWZsZWN0LmNhbGwodGhpcywgdGFzayk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gcmVqZWN0JDEoZWFjaGZuLCBhcnIsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIF9maWx0ZXIoZWFjaGZuLCBhcnIsIGZ1bmN0aW9uKHZhbHVlLCBjYikge1xuICAgICAgICBpdGVyYXRlZSh2YWx1ZSwgZnVuY3Rpb24oZXJyLCB2KSB7XG4gICAgICAgICAgICBjYihlcnIsICF2KTtcbiAgICAgICAgfSk7XG4gICAgfSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFRoZSBvcHBvc2l0ZSBvZiBbYGZpbHRlcmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9LiBSZW1vdmVzIHZhbHVlcyB0aGF0IHBhc3MgYW4gYGFzeW5jYCB0cnV0aCB0ZXN0LlxuICpcbiAqIEBuYW1lIHJlamVjdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZmlsdGVyXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYXMgaXRzIGByZXN1bHRgLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy5yZWplY3QoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZVBhdGgsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycilcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHJlc3VsdHMgbm93IGVxdWFscyBhbiBhcnJheSBvZiBtaXNzaW5nIGZpbGVzXG4gKiAgICAgY3JlYXRlRmlsZXMocmVzdWx0cyk7XG4gKiB9KTtcbiAqL1xudmFyIHJlamVjdCA9IGRvUGFyYWxsZWwocmVqZWN0JDEpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgcmVqZWN0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlamVjdH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gKiB0aW1lLlxuICpcbiAqIEBuYW1lIHJlamVjdExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5yZWplY3Rde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWplY3R9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgYHJlc3VsdGAuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKi9cbnZhciByZWplY3RMaW1pdCA9IGRvUGFyYWxsZWxMaW1pdChyZWplY3QkMSk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2ByZWplY3RgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVqZWN0fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgcmVqZWN0U2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5yZWplY3Rde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWplY3R9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgYHJlc3VsdGAuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKi9cbnZhciByZWplY3RTZXJpZXMgPSBkb0xpbWl0KHJlamVjdExpbWl0LCAxKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50JDEodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBnZXQgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIGZyb20gYHRhc2tgIG5vIG1vcmUgdGhhbiBgdGltZXNgIHRpbWVzXG4gKiBiZWZvcmUgcmV0dXJuaW5nIGFuIGVycm9yLiBJZiB0aGUgdGFzayBpcyBzdWNjZXNzZnVsLCB0aGUgYGNhbGxiYWNrYCB3aWxsIGJlXG4gKiBwYXNzZWQgdGhlIHJlc3VsdCBvZiB0aGUgc3VjY2Vzc2Z1bCB0YXNrLiBJZiBhbGwgYXR0ZW1wdHMgZmFpbCwgdGhlIGNhbGxiYWNrXG4gKiB3aWxsIGJlIHBhc3NlZCB0aGUgZXJyb3IgYW5kIHJlc3VsdCAoaWYgYW55KSBvZiB0aGUgZmluYWwgYXR0ZW1wdC5cbiAqXG4gKiBAbmFtZSByZXRyeVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHNlZSBbYXN5bmMucmV0cnlhYmxlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucmV0cnlhYmxlfVxuICogQHBhcmFtIHtPYmplY3R8bnVtYmVyfSBbb3B0cyA9IHt0aW1lczogNSwgaW50ZXJ2YWw6IDB9fCA1XSAtIENhbiBiZSBlaXRoZXIgYW5cbiAqIG9iamVjdCB3aXRoIGB0aW1lc2AgYW5kIGBpbnRlcnZhbGAgb3IgYSBudW1iZXIuXG4gKiAqIGB0aW1lc2AgLSBUaGUgbnVtYmVyIG9mIGF0dGVtcHRzIHRvIG1ha2UgYmVmb3JlIGdpdmluZyB1cC4gIFRoZSBkZWZhdWx0XG4gKiAgIGlzIGA1YC5cbiAqICogYGludGVydmFsYCAtIFRoZSB0aW1lIHRvIHdhaXQgYmV0d2VlbiByZXRyaWVzLCBpbiBtaWxsaXNlY29uZHMuICBUaGVcbiAqICAgZGVmYXVsdCBpcyBgMGAuIFRoZSBpbnRlcnZhbCBtYXkgYWxzbyBiZSBzcGVjaWZpZWQgYXMgYSBmdW5jdGlvbiBvZiB0aGVcbiAqICAgcmV0cnkgY291bnQgKHNlZSBleGFtcGxlKS5cbiAqICogYGVycm9yRmlsdGVyYCAtIEFuIG9wdGlvbmFsIHN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCBvblxuICogICBlcnJvbmVvdXMgcmVzdWx0LiBJZiBpdCByZXR1cm5zIGB0cnVlYCB0aGUgcmV0cnkgYXR0ZW1wdHMgd2lsbCBjb250aW51ZTtcbiAqICAgaWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCB0aGUgcmV0cnkgZmxvdyBpcyBhYm9ydGVkIHdpdGggdGhlIGN1cnJlbnRcbiAqICAgYXR0ZW1wdCdzIGVycm9yIGFuZCByZXN1bHQgYmVpbmcgcmV0dXJuZWQgdG8gdGhlIGZpbmFsIGNhbGxiYWNrLlxuICogICBJbnZva2VkIHdpdGggKGVycikuXG4gKiAqIElmIGBvcHRzYCBpcyBhIG51bWJlciwgdGhlIG51bWJlciBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiB0aW1lcyB0byByZXRyeSxcbiAqICAgd2l0aCB0aGUgZGVmYXVsdCBpbnRlcnZhbCBvZiBgMGAuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHRhc2sgLSBBbiBhc3luYyBmdW5jdGlvbiB0byByZXRyeS5cbiAqIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHRoZVxuICogdGFzayBoYXMgc3VjY2VlZGVkLCBvciBhZnRlciB0aGUgZmluYWwgZmFpbGVkIGF0dGVtcHQuIEl0IHJlY2VpdmVzIHRoZSBgZXJyYFxuICogYW5kIGByZXN1bHRgIGFyZ3VtZW50cyBvZiB0aGUgbGFzdCBhdHRlbXB0IGF0IGNvbXBsZXRpbmcgdGhlIGB0YXNrYC4gSW52b2tlZFxuICogd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFRoZSBgcmV0cnlgIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIGFzIGEgc3RhbmQtYWxvbmUgY29udHJvbCBmbG93IGJ5IHBhc3NpbmdcbiAqIC8vIGEgY2FsbGJhY2ssIGFzIHNob3duIGJlbG93OlxuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCAzIHRpbWVzXG4gKiBhc3luYy5yZXRyeSgzLCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIDMgdGltZXMsIHdhaXRpbmcgMjAwIG1zIGJldHdlZW4gZWFjaCByZXRyeVxuICogYXN5bmMucmV0cnkoe3RpbWVzOiAzLCBpbnRlcnZhbDogMjAwfSwgYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRcbiAqIH0pO1xuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCAxMCB0aW1lcyB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAqIC8vIChpLmUuIGludGVydmFscyBvZiAxMDAsIDIwMCwgNDAwLCA4MDAsIDE2MDAsIC4uLiBtaWxsaXNlY29uZHMpXG4gKiBhc3luYy5yZXRyeSh7XG4gKiAgIHRpbWVzOiAxMCxcbiAqICAgaW50ZXJ2YWw6IGZ1bmN0aW9uKHJldHJ5Q291bnQpIHtcbiAqICAgICByZXR1cm4gNTAgKiBNYXRoLnBvdygyLCByZXRyeUNvdW50KTtcbiAqICAgfVxuICogfSwgYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRcbiAqIH0pO1xuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCB0aGUgZGVmYXVsdCA1IHRpbWVzIG5vIGRlbGF5IGJldHdlZW4gZWFjaCByZXRyeVxuICogYXN5bmMucmV0cnkoYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRcbiAqIH0pO1xuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCBvbmx5IHdoZW4gZXJyb3IgY29uZGl0aW9uIHNhdGlzZmllcywgYWxsIG90aGVyXG4gKiAvLyBlcnJvcnMgd2lsbCBhYm9ydCB0aGUgcmV0cnkgY29udHJvbCBmbG93IGFuZCByZXR1cm4gdG8gZmluYWwgY2FsbGJhY2tcbiAqIGFzeW5jLnJldHJ5KHtcbiAqICAgZXJyb3JGaWx0ZXI6IGZ1bmN0aW9uKGVycikge1xuICogICAgIHJldHVybiBlcnIubWVzc2FnZSA9PT0gJ1RlbXBvcmFyeSBlcnJvcic7IC8vIG9ubHkgcmV0cnkgb24gYSBzcGVjaWZpYyBlcnJvclxuICogICB9XG4gKiB9LCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdG8gcmV0cnkgaW5kaXZpZHVhbCBtZXRob2RzIHRoYXQgYXJlIG5vdCBhcyByZWxpYWJsZSB3aXRoaW4gb3RoZXJcbiAqIC8vIGNvbnRyb2wgZmxvdyBmdW5jdGlvbnMsIHVzZSB0aGUgYHJldHJ5YWJsZWAgd3JhcHBlcjpcbiAqIGFzeW5jLmF1dG8oe1xuICogICAgIHVzZXJzOiBhcGkuZ2V0VXNlcnMuYmluZChhcGkpLFxuICogICAgIHBheW1lbnRzOiBhc3luYy5yZXRyeWFibGUoMywgYXBpLmdldFBheW1lbnRzLmJpbmQoYXBpKSlcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRzXG4gKiB9KTtcbiAqXG4gKi9cbmZ1bmN0aW9uIHJldHJ5KG9wdHMsIHRhc2ssIGNhbGxiYWNrKSB7XG4gICAgdmFyIERFRkFVTFRfVElNRVMgPSA1O1xuICAgIHZhciBERUZBVUxUX0lOVEVSVkFMID0gMDtcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICB0aW1lczogREVGQVVMVF9USU1FUyxcbiAgICAgICAgaW50ZXJ2YWxGdW5jOiBjb25zdGFudCQxKERFRkFVTFRfSU5URVJWQUwpXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlVGltZXMoYWNjLCB0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGFjYy50aW1lcyA9ICt0LnRpbWVzIHx8IERFRkFVTFRfVElNRVM7XG5cbiAgICAgICAgICAgIGFjYy5pbnRlcnZhbEZ1bmMgPSB0eXBlb2YgdC5pbnRlcnZhbCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgdC5pbnRlcnZhbCA6XG4gICAgICAgICAgICAgICAgY29uc3RhbnQkMSgrdC5pbnRlcnZhbCB8fCBERUZBVUxUX0lOVEVSVkFMKTtcblxuICAgICAgICAgICAgYWNjLmVycm9yRmlsdGVyID0gdC5lcnJvckZpbHRlcjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBhY2MudGltZXMgPSArdCB8fCBERUZBVUxUX1RJTUVTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgZm9yIGFzeW5jLnJldHJ5XCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzICYmIHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdGFzayB8fCBub29wO1xuICAgICAgICB0YXNrID0gb3B0cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZVRpbWVzKG9wdGlvbnMsIG9wdHMpO1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0YXNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRzIGZvciBhc3luYy5yZXRyeVwiKTtcbiAgICB9XG5cbiAgICB2YXIgX3Rhc2sgPSB3cmFwQXN5bmModGFzayk7XG5cbiAgICB2YXIgYXR0ZW1wdCA9IDE7XG4gICAgZnVuY3Rpb24gcmV0cnlBdHRlbXB0KCkge1xuICAgICAgICBfdGFzayhmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgJiYgYXR0ZW1wdCsrIDwgb3B0aW9ucy50aW1lcyAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2Ygb3B0aW9ucy5lcnJvckZpbHRlciAhPSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3JGaWx0ZXIoZXJyKSkpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJldHJ5QXR0ZW1wdCwgb3B0aW9ucy5pbnRlcnZhbEZ1bmMoYXR0ZW1wdCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXRyeUF0dGVtcHQoKTtcbn1cblxuLyoqXG4gKiBBIGNsb3NlIHJlbGF0aXZlIG9mIFtgcmV0cnlgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucmV0cnl9LiAgVGhpcyBtZXRob2RcbiAqIHdyYXBzIGEgdGFzayBhbmQgbWFrZXMgaXQgcmV0cnlhYmxlLCByYXRoZXIgdGhhbiBpbW1lZGlhdGVseSBjYWxsaW5nIGl0XG4gKiB3aXRoIHJldHJpZXMuXG4gKlxuICogQG5hbWUgcmV0cnlhYmxlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5yZXRyeV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnJldHJ5fVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtPYmplY3R8bnVtYmVyfSBbb3B0cyA9IHt0aW1lczogNSwgaW50ZXJ2YWw6IDB9fCA1XSAtIG9wdGlvbmFsXG4gKiBvcHRpb25zLCBleGFjdGx5IHRoZSBzYW1lIGFzIGZyb20gYHJldHJ5YFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB0YXNrIC0gdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0byB3cmFwLlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgcmV0dXJuZWQgd3JhcHBlci5cbiAqIEludm9rZWQgd2l0aCAoLi4uYXJncywgY2FsbGJhY2spLlxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFRoZSB3cmFwcGVkIGZ1bmN0aW9uLCB3aGljaCB3aGVuIGludm9rZWQsIHdpbGxcbiAqIHJldHJ5IG9uIGFuIGVycm9yLCBiYXNlZCBvbiB0aGUgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gYG9wdHNgLlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGFjY2VwdCB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIGB0YXNrYC5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuYXV0byh7XG4gKiAgICAgZGVwMTogYXN5bmMucmV0cnlhYmxlKDMsIGdldEZyb21GbGFreVNlcnZpY2UpLFxuICogICAgIHByb2Nlc3M6IFtcImRlcDFcIiwgYXN5bmMucmV0cnlhYmxlKDMsIGZ1bmN0aW9uIChyZXN1bHRzLCBjYikge1xuICogICAgICAgICBtYXliZVByb2Nlc3NEYXRhKHJlc3VsdHMuZGVwMSwgY2IpO1xuICogICAgIH0pXVxuICogfSwgY2FsbGJhY2spO1xuICovXG52YXIgcmV0cnlhYmxlID0gZnVuY3Rpb24gKG9wdHMsIHRhc2spIHtcbiAgICBpZiAoIXRhc2spIHtcbiAgICAgICAgdGFzayA9IG9wdHM7XG4gICAgICAgIG9wdHMgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgX3Rhc2sgPSB3cmFwQXN5bmModGFzayk7XG4gICAgcmV0dXJuIGluaXRpYWxQYXJhbXMoZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGZ1bmN0aW9uIHRhc2tGbihjYikge1xuICAgICAgICAgICAgX3Rhc2suYXBwbHkobnVsbCwgYXJncy5jb25jYXQoY2IpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzKSByZXRyeShvcHRzLCB0YXNrRm4sIGNhbGxiYWNrKTtcbiAgICAgICAgZWxzZSByZXRyeSh0YXNrRm4sIGNhbGxiYWNrKTtcblxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSdW4gdGhlIGZ1bmN0aW9ucyBpbiB0aGUgYHRhc2tzYCBjb2xsZWN0aW9uIGluIHNlcmllcywgZWFjaCBvbmUgcnVubmluZyBvbmNlXG4gKiB0aGUgcHJldmlvdXMgZnVuY3Rpb24gaGFzIGNvbXBsZXRlZC4gSWYgYW55IGZ1bmN0aW9ucyBpbiB0aGUgc2VyaWVzIHBhc3MgYW5cbiAqIGVycm9yIHRvIGl0cyBjYWxsYmFjaywgbm8gbW9yZSBmdW5jdGlvbnMgYXJlIHJ1biwgYW5kIGBjYWxsYmFja2AgaXNcbiAqIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSB2YWx1ZSBvZiB0aGUgZXJyb3IuIE90aGVyd2lzZSwgYGNhbGxiYWNrYFxuICogcmVjZWl2ZXMgYW4gYXJyYXkgb2YgcmVzdWx0cyB3aGVuIGB0YXNrc2AgaGF2ZSBjb21wbGV0ZWQuXG4gKlxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byB1c2UgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIEVhY2ggcHJvcGVydHkgd2lsbFxuICogYmUgcnVuIGFzIGEgZnVuY3Rpb24sIGFuZCB0aGUgcmVzdWx0cyB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZmluYWwgYGNhbGxiYWNrYFxuICogYXMgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIFRoaXMgY2FuIGJlIGEgbW9yZSByZWFkYWJsZSB3YXkgb2YgaGFuZGxpbmdcbiAqICByZXN1bHRzIGZyb20ge0BsaW5rIGFzeW5jLnNlcmllc30uXG4gKlxuICogKipOb3RlKiogdGhhdCB3aGlsZSBtYW55IGltcGxlbWVudGF0aW9ucyBwcmVzZXJ2ZSB0aGUgb3JkZXIgb2Ygb2JqZWN0XG4gKiBwcm9wZXJ0aWVzLCB0aGUgW0VDTUFTY3JpcHQgTGFuZ3VhZ2UgU3BlY2lmaWNhdGlvbl0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTguNilcbiAqIGV4cGxpY2l0bHkgc3RhdGVzIHRoYXRcbiAqXG4gKiA+IFRoZSBtZWNoYW5pY3MgYW5kIG9yZGVyIG9mIGVudW1lcmF0aW5nIHRoZSBwcm9wZXJ0aWVzIGlzIG5vdCBzcGVjaWZpZWQuXG4gKlxuICogU28gaWYgeW91IHJlbHkgb24gdGhlIG9yZGVyIGluIHdoaWNoIHlvdXIgc2VyaWVzIG9mIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWQsXG4gKiBhbmQgd2FudCB0aGlzIHRvIHdvcmsgb24gYWxsIHBsYXRmb3JtcywgY29uc2lkZXIgdXNpbmcgYW4gYXJyYXkuXG4gKlxuICogQG5hbWUgc2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gdGFza3MgLSBBIGNvbGxlY3Rpb24gY29udGFpbmluZ1xuICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuIGluIHNlcmllcy5cbiAqIEVhY2ggZnVuY3Rpb24gY2FuIGNvbXBsZXRlIHdpdGggYW55IG51bWJlciBvZiBvcHRpb25hbCBgcmVzdWx0YCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZVxuICogZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkLiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5IChvciBvYmplY3QpXG4gKiBjb250YWluaW5nIGFsbCB0aGUgcmVzdWx0IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGB0YXNrYCBjYWxsYmFja3MuIEludm9rZWRcbiAqIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEBleGFtcGxlXG4gKiBhc3luYy5zZXJpZXMoW1xuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGRvIHNvbWUgc3R1ZmYgLi4uXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGRvIHNvbWUgbW9yZSBzdHVmZiAuLi5cbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpO1xuICogICAgIH1cbiAqIF0sXG4gKiAvLyBvcHRpb25hbCBjYWxsYmFja1xuICogZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBub3cgZXF1YWwgdG8gWydvbmUnLCAndHdvJ11cbiAqIH0pO1xuICpcbiAqIGFzeW5jLnNlcmllcyh7XG4gKiAgICAgb25lOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMSk7XG4gKiAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgfSxcbiAqICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKXtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDIpO1xuICogICAgICAgICB9LCAxMDApO1xuICogICAgIH1cbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGVxdWFsIHRvOiB7b25lOiAxLCB0d286IDJ9XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gc2VyaWVzKHRhc2tzLCBjYWxsYmFjaykge1xuICAgIF9wYXJhbGxlbChlYWNoT2ZTZXJpZXMsIHRhc2tzLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIGBjb2xsYCBzYXRpc2ZpZXMgYW4gYXN5bmMgdGVzdC5cbiAqIElmIGFueSBpdGVyYXRlZSBjYWxsIHJldHVybnMgYHRydWVgLCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5XG4gKiBjYWxsZWQuXG4gKlxuICogQG5hbWUgc29tZVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGFsaWFzIGFueVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbVxuICogaW4gdGhlIGNvbGxlY3Rpb25zIGluIHBhcmFsbGVsLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiBgcmVzdWx0YCB2YWx1ZS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC5cbiAqIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmNcbiAqIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuc29tZShbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmdW5jdGlvbihmaWxlUGF0aCwgY2FsbGJhY2spIHtcbiAqICAgICBmcy5hY2Nlc3MoZmlsZVBhdGgsIGZ1bmN0aW9uKGVycikge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKVxuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyBpZiByZXN1bHQgaXMgdHJ1ZSB0aGVuIGF0IGxlYXN0IG9uZSBvZiB0aGUgZmlsZXMgZXhpc3RzXG4gKiB9KTtcbiAqL1xudmFyIHNvbWUgPSBkb1BhcmFsbGVsKF9jcmVhdGVUZXN0ZXIoQm9vbGVhbiwgaWRlbnRpdHkpKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYHNvbWVgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgc29tZUxpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5zb21lXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX1cbiAqIEBhbGlhcyBhbnlMaW1pdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbVxuICogaW4gdGhlIGNvbGxlY3Rpb25zIGluIHBhcmFsbGVsLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiBgcmVzdWx0YCB2YWx1ZS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC5cbiAqIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmNcbiAqIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqL1xudmFyIHNvbWVMaW1pdCA9IGRvUGFyYWxsZWxMaW1pdChfY3JlYXRlVGVzdGVyKEJvb2xlYW4sIGlkZW50aXR5KSk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2Bzb21lYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnNvbWV9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBzb21lU2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5zb21lXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX1cbiAqIEBhbGlhcyBhbnlTZXJpZXNcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW1cbiAqIGluIHRoZSBjb2xsZWN0aW9ucyBpbiBzZXJpZXMuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIGByZXN1bHRgIHZhbHVlLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnlcbiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLlxuICogUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIHRoZSBhc3luY1xuICogdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICovXG52YXIgc29tZVNlcmllcyA9IGRvTGltaXQoc29tZUxpbWl0LCAxKTtcblxuLyoqXG4gKiBTb3J0cyBhIGxpc3QgYnkgdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGBjb2xsYCB2YWx1ZSB0aHJvdWdoIGFuIGFzeW5jXG4gKiBgaXRlcmF0ZWVgLlxuICpcbiAqIEBuYW1lIHNvcnRCeVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIHZhbHVlIHRvIHVzZSBhcyB0aGUgc29ydCBjcml0ZXJpYSBhc1xuICogaXRzIGByZXN1bHRgLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyB0aGUgaXRlbXNcbiAqIGZyb20gdGhlIG9yaWdpbmFsIGBjb2xsYCBzb3J0ZWQgYnkgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgYGl0ZXJhdGVlYFxuICogY2FsbHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuc29ydEJ5KFsnZmlsZTEnLCdmaWxlMicsJ2ZpbGUzJ10sIGZ1bmN0aW9uKGZpbGUsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuc3RhdChmaWxlLCBmdW5jdGlvbihlcnIsIHN0YXRzKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKGVyciwgc3RhdHMubXRpbWUpO1xuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBub3cgdGhlIG9yaWdpbmFsIGFycmF5IG9mIGZpbGVzIHNvcnRlZCBieVxuICogICAgIC8vIG1vZGlmaWVkIGRhdGVcbiAqIH0pO1xuICpcbiAqIC8vIEJ5IG1vZGlmeWluZyB0aGUgY2FsbGJhY2sgcGFyYW1ldGVyIHRoZVxuICogLy8gc29ydGluZyBvcmRlciBjYW4gYmUgaW5mbHVlbmNlZDpcbiAqXG4gKiAvLyBhc2NlbmRpbmcgb3JkZXJcbiAqIGFzeW5jLnNvcnRCeShbMSw5LDMsNV0sIGZ1bmN0aW9uKHgsIGNhbGxiYWNrKSB7XG4gKiAgICAgY2FsbGJhY2sobnVsbCwgeCk7XG4gKiB9LCBmdW5jdGlvbihlcnIscmVzdWx0KSB7XG4gKiAgICAgLy8gcmVzdWx0IGNhbGxiYWNrXG4gKiB9KTtcbiAqXG4gKiAvLyBkZXNjZW5kaW5nIG9yZGVyXG4gKiBhc3luYy5zb3J0QnkoWzEsOSwzLDVdLCBmdW5jdGlvbih4LCBjYWxsYmFjaykge1xuICogICAgIGNhbGxiYWNrKG51bGwsIHgqLTEpOyAgICAvLzwtIHgqLTEgaW5zdGVhZCBvZiB4LCB0dXJucyB0aGUgb3JkZXIgYXJvdW5kXG4gKiB9LCBmdW5jdGlvbihlcnIscmVzdWx0KSB7XG4gKiAgICAgLy8gcmVzdWx0IGNhbGxiYWNrXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gc29ydEJ5IChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcbiAgICBtYXAoY29sbCwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9pdGVyYXRlZSh4LCBmdW5jdGlvbiAoZXJyLCBjcml0ZXJpYSkge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7dmFsdWU6IHgsIGNyaXRlcmlhOiBjcml0ZXJpYX0pO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCBhcnJheU1hcChyZXN1bHRzLnNvcnQoY29tcGFyYXRvciksIGJhc2VQcm9wZXJ0eSgndmFsdWUnKSkpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY29tcGFyYXRvcihsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWEsIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTZXRzIGEgdGltZSBsaW1pdCBvbiBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBkb2VzIG5vdCBjYWxsXG4gKiBpdHMgY2FsbGJhY2sgd2l0aGluIHRoZSBzcGVjaWZpZWQgbWlsbGlzZWNvbmRzLCBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFcbiAqIHRpbWVvdXQgZXJyb3IuIFRoZSBjb2RlIHByb3BlcnR5IGZvciB0aGUgZXJyb3Igb2JqZWN0IHdpbGwgYmUgYCdFVElNRURPVVQnYC5cbiAqXG4gKiBAbmFtZSB0aW1lb3V0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBhc3luY0ZuIC0gVGhlIGFzeW5jIGZ1bmN0aW9uIHRvIGxpbWl0IGluIHRpbWUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWlsbGlzZWNvbmRzIC0gVGhlIHNwZWNpZmllZCB0aW1lIGxpbWl0LlxuICogQHBhcmFtIHsqfSBbaW5mb10gLSBBbnkgdmFyaWFibGUgeW91IHdhbnQgYXR0YWNoZWQgKGBzdHJpbmdgLCBgb2JqZWN0YCwgZXRjKVxuICogdG8gdGltZW91dCBFcnJvciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4uXG4gKiBAcmV0dXJucyB7QXN5bmNGdW5jdGlvbn0gUmV0dXJucyBhIHdyYXBwZWQgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB3aXRoIGFueVxuICogb2YgdGhlIGNvbnRyb2wgZmxvdyBmdW5jdGlvbnMuXG4gKiBJbnZva2UgdGhpcyBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMgYXMgeW91IHdvdWxkIGBhc3luY0Z1bmNgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBteUZ1bmN0aW9uKGZvbywgY2FsbGJhY2spIHtcbiAqICAgICBkb0FzeW5jVGFzayhmb28sIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICogICAgICAgICAvLyBoYW5kbGUgZXJyb3JzXG4gKiAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICpcbiAqICAgICAgICAgLy8gZG8gc29tZSBzdHVmZiAuLi5cbiAqXG4gKiAgICAgICAgIC8vIHJldHVybiBwcm9jZXNzZWQgZGF0YVxuICogICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKlxuICogdmFyIHdyYXBwZWQgPSBhc3luYy50aW1lb3V0KG15RnVuY3Rpb24sIDEwMDApO1xuICpcbiAqIC8vIGNhbGwgYHdyYXBwZWRgIGFzIHlvdSB3b3VsZCBgbXlGdW5jdGlvbmBcbiAqIHdyYXBwZWQoeyBiYXI6ICdiYXInIH0sIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICogICAgIC8vIGlmIGBteUZ1bmN0aW9uYCB0YWtlcyA8IDEwMDAgbXMgdG8gZXhlY3V0ZSwgYGVycmBcbiAqICAgICAvLyBhbmQgYGRhdGFgIHdpbGwgaGF2ZSB0aGVpciBleHBlY3RlZCB2YWx1ZXNcbiAqXG4gKiAgICAgLy8gZWxzZSBgZXJyYCB3aWxsIGJlIGFuIEVycm9yIHdpdGggdGhlIGNvZGUgJ0VUSU1FRE9VVCdcbiAqIH0pO1xuICovXG5mdW5jdGlvbiB0aW1lb3V0KGFzeW5jRm4sIG1pbGxpc2Vjb25kcywgaW5mbykge1xuICAgIHZhciBmbiA9IHdyYXBBc3luYyhhc3luY0ZuKTtcblxuICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgdGltZWRPdXQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRpbWVyO1xuXG4gICAgICAgIGZ1bmN0aW9uIHRpbWVvdXRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gYXN5bmNGbi5uYW1lIHx8ICdhbm9ueW1vdXMnO1xuICAgICAgICAgICAgdmFyIGVycm9yICA9IG5ldyBFcnJvcignQ2FsbGJhY2sgZnVuY3Rpb24gXCInICsgbmFtZSArICdcIiB0aW1lZCBvdXQuJyk7XG4gICAgICAgICAgICBlcnJvci5jb2RlID0gJ0VUSU1FRE9VVCc7XG4gICAgICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgICAgIGVycm9yLmluZm8gPSBpbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZWRPdXQgPSB0cnVlO1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGltZWRPdXQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNldHVwIHRpbWVyIGFuZCBjYWxsIG9yaWdpbmFsIGZ1bmN0aW9uXG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCh0aW1lb3V0Q2FsbGJhY2ssIG1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xufVxuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbDtcbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5nZWAgYW5kIGBfLnJhbmdlUmlnaHRgIHdoaWNoIGRvZXNuJ3RcbiAqIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBuYXRpdmVNYXgobmF0aXZlQ2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XG4gICAgc3RhcnQgKz0gc3RlcDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFt0aW1lc117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnRpbWVzfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgdGltZXNMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMudGltZXNde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy50aW1lc31cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gY2FsbCBgbmAgdGltZXMuXG4gKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBzZWUgW2FzeW5jLm1hcF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0uXG4gKi9cbmZ1bmN0aW9uIHRpbWVMaW1pdChjb3VudCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgIG1hcExpbWl0KGJhc2VSYW5nZSgwLCBjb3VudCwgMSksIGxpbWl0LCBfaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBDYWxscyB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbiBgbmAgdGltZXMsIGFuZCBhY2N1bXVsYXRlcyByZXN1bHRzIGluIHRoZSBzYW1lXG4gKiBtYW5uZXIgeW91IHdvdWxkIHVzZSB3aXRoIFttYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LlxuICpcbiAqIEBuYW1lIHRpbWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5tYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gY2FsbCBgbmAgdGltZXMuXG4gKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBzZWUge0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBQcmV0ZW5kIHRoaXMgaXMgc29tZSBjb21wbGljYXRlZCBhc3luYyBmYWN0b3J5XG4gKiB2YXIgY3JlYXRlVXNlciA9IGZ1bmN0aW9uKGlkLCBjYWxsYmFjaykge1xuICogICAgIGNhbGxiYWNrKG51bGwsIHtcbiAqICAgICAgICAgaWQ6ICd1c2VyJyArIGlkXG4gKiAgICAgfSk7XG4gKiB9O1xuICpcbiAqIC8vIGdlbmVyYXRlIDUgdXNlcnNcbiAqIGFzeW5jLnRpbWVzKDUsIGZ1bmN0aW9uKG4sIG5leHQpIHtcbiAqICAgICBjcmVhdGVVc2VyKG4sIGZ1bmN0aW9uKGVyciwgdXNlcikge1xuICogICAgICAgICBuZXh0KGVyciwgdXNlcik7XG4gKiAgICAgfSk7XG4gKiB9LCBmdW5jdGlvbihlcnIsIHVzZXJzKSB7XG4gKiAgICAgLy8gd2Ugc2hvdWxkIG5vdyBoYXZlIDUgdXNlcnNcbiAqIH0pO1xuICovXG52YXIgdGltZXMgPSBkb0xpbWl0KHRpbWVMaW1pdCwgSW5maW5pdHkpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFt0aW1lc117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnRpbWVzfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgdGltZXNTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnRpbWVzXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cudGltZXN9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gY2FsbCBgbmAgdGltZXMuXG4gKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBzZWUge0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LlxuICovXG52YXIgdGltZXNTZXJpZXMgPSBkb0xpbWl0KHRpbWVMaW1pdCwgMSk7XG5cbi8qKlxuICogQSByZWxhdGl2ZSBvZiBgcmVkdWNlYC4gIFRha2VzIGFuIE9iamVjdCBvciBBcnJheSwgYW5kIGl0ZXJhdGVzIG92ZXIgZWFjaFxuICogZWxlbWVudCBpbiBzZXJpZXMsIGVhY2ggc3RlcCBwb3RlbnRpYWxseSBtdXRhdGluZyBhbiBgYWNjdW11bGF0b3JgIHZhbHVlLlxuICogVGhlIHR5cGUgb2YgdGhlIGFjY3VtdWxhdG9yIGRlZmF1bHRzIHRvIHRoZSB0eXBlIG9mIGNvbGxlY3Rpb24gcGFzc2VkIGluLlxuICpcbiAqIEBuYW1lIHRyYW5zZm9ybVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSAtIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSB0cmFuc2Zvcm0uICBJZiBvbWl0dGVkLFxuICogaXQgd2lsbCBkZWZhdWx0IHRvIGFuIGVtcHR5IE9iamVjdCBvciBBcnJheSwgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIGBjb2xsYFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gYXBwbGllZCB0byBlYWNoIGl0ZW0gaW4gdGhlXG4gKiBjb2xsZWN0aW9uIHRoYXQgcG90ZW50aWFsbHkgbW9kaWZpZXMgdGhlIGFjY3VtdWxhdG9yLlxuICogSW52b2tlZCB3aXRoIChhY2N1bXVsYXRvciwgaXRlbSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IGlzIHRoZSB0cmFuc2Zvcm1lZCBhY2N1bXVsYXRvci5cbiAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy50cmFuc2Zvcm0oWzEsMiwzXSwgZnVuY3Rpb24oYWNjLCBpdGVtLCBpbmRleCwgY2FsbGJhY2spIHtcbiAqICAgICAvLyBwb2ludGxlc3MgYXN5bmM6XG4gKiAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAqICAgICAgICAgYWNjLnB1c2goaXRlbSAqIDIpXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwpXG4gKiAgICAgfSk7XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIHJlc3VsdCBpcyBub3cgZXF1YWwgdG8gWzIsIDQsIDZdXG4gKiB9KTtcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLnRyYW5zZm9ybSh7YTogMSwgYjogMiwgYzogM30sIGZ1bmN0aW9uIChvYmosIHZhbCwga2V5LCBjYWxsYmFjaykge1xuICogICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIG9ialtrZXldID0gdmFsICogMjtcbiAqICAgICAgICAgY2FsbGJhY2soKTtcbiAqICAgICB9KVxuICogfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gcmVzdWx0IGlzIGVxdWFsIHRvIHthOiAyLCBiOiA0LCBjOiA2fVxuICogfSlcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtIChjb2xsLCBhY2N1bXVsYXRvciwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMykge1xuICAgICAgICBjYWxsYmFjayA9IGl0ZXJhdGVlO1xuICAgICAgICBpdGVyYXRlZSA9IGFjY3VtdWxhdG9yO1xuICAgICAgICBhY2N1bXVsYXRvciA9IGlzQXJyYXkoY29sbCkgPyBbXSA6IHt9O1xuICAgIH1cbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7XG5cbiAgICBlYWNoT2YoY29sbCwgZnVuY3Rpb24odiwgaywgY2IpIHtcbiAgICAgICAgX2l0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2LCBrLCBjYik7XG4gICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgYWNjdW11bGF0b3IpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEl0IHJ1bnMgZWFjaCB0YXNrIGluIHNlcmllcyBidXQgc3RvcHMgd2hlbmV2ZXIgYW55IG9mIHRoZSBmdW5jdGlvbnMgd2VyZVxuICogc3VjY2Vzc2Z1bC4gSWYgb25lIG9mIHRoZSB0YXNrcyB3ZXJlIHN1Y2Nlc3NmdWwsIHRoZSBgY2FsbGJhY2tgIHdpbGwgYmVcbiAqIHBhc3NlZCB0aGUgcmVzdWx0IG9mIHRoZSBzdWNjZXNzZnVsIHRhc2suIElmIGFsbCB0YXNrcyBmYWlsLCB0aGUgY2FsbGJhY2tcbiAqIHdpbGwgYmUgcGFzc2VkIHRoZSBlcnJvciBhbmQgcmVzdWx0IChpZiBhbnkpIG9mIHRoZSBmaW5hbCBhdHRlbXB0LlxuICpcbiAqIEBuYW1lIHRyeUVhY2hcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSB0YXNrcyAtIEEgY29sbGVjdGlvbiBjb250YWluaW5nIGZ1bmN0aW9ucyB0b1xuICogcnVuLCBlYWNoIGZ1bmN0aW9uIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHJlc3VsdClgIGl0IG11c3QgY2FsbCBvblxuICogY29tcGxldGlvbiB3aXRoIGFuIGVycm9yIGBlcnJgICh3aGljaCBjYW4gYmUgYG51bGxgKSBhbmQgYW4gb3B0aW9uYWwgYHJlc3VsdGBcbiAqIHZhbHVlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIG9uZVxuICogb2YgdGhlIHRhc2tzIGhhcyBzdWNjZWVkZWQsIG9yIGFsbCBoYXZlIGZhaWxlZC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgIGFuZFxuICogYHJlc3VsdGAgYXJndW1lbnRzIG9mIHRoZSBsYXN0IGF0dGVtcHQgYXQgY29tcGxldGluZyB0aGUgYHRhc2tgLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdHMpLlxuICogQGV4YW1wbGVcbiAqIGFzeW5jLnRyeUVhY2goW1xuICogICAgIGZ1bmN0aW9uIGdldERhdGFGcm9tRmlyc3RXZWJzaXRlKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIFRyeSBnZXR0aW5nIHRoZSBkYXRhIGZyb20gdGhlIGZpcnN0IHdlYnNpdGVcbiAqICAgICAgICAgY2FsbGJhY2soZXJyLCBkYXRhKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uIGdldERhdGFGcm9tU2Vjb25kV2Vic2l0ZShjYWxsYmFjaykge1xuICogICAgICAgICAvLyBGaXJzdCB3ZWJzaXRlIGZhaWxlZCxcbiAqICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIGRhdGEgZnJvbSB0aGUgYmFja3VwIHdlYnNpdGVcbiAqICAgICAgICAgY2FsbGJhY2soZXJyLCBkYXRhKTtcbiAqICAgICB9XG4gKiBdLFxuICogLy8gb3B0aW9uYWwgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIE5vdyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS5cbiAqIH0pO1xuICpcbiAqL1xuZnVuY3Rpb24gdHJ5RWFjaCh0YXNrcywgY2FsbGJhY2spIHtcbiAgICB2YXIgZXJyb3IgPSBudWxsO1xuICAgIHZhciByZXN1bHQ7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICAgIGVhY2hTZXJpZXModGFza3MsIGZ1bmN0aW9uKHRhc2ssIGNhbGxiYWNrKSB7XG4gICAgICAgIHdyYXBBc3luYyh0YXNrKShmdW5jdGlvbiAoZXJyLCByZXMvKiwgLi4uYXJncyovKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgIGNhbGxiYWNrKCFlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFVuZG9lcyBhIFttZW1vaXplXXtAbGluayBtb2R1bGU6VXRpbHMubWVtb2l6ZX1kIGZ1bmN0aW9uLCByZXZlcnRpbmcgaXQgdG8gdGhlIG9yaWdpbmFsLFxuICogdW5tZW1vaXplZCBmb3JtLiBIYW5keSBmb3IgdGVzdGluZy5cbiAqXG4gKiBAbmFtZSB1bm1lbW9pemVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLm1lbW9pemVde0BsaW5rIG1vZHVsZTpVdGlscy5tZW1vaXplfVxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSB0aGUgbWVtb2l6ZWQgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIG9yaWdpbmFsIHVubWVtb2l6ZWQgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gdW5tZW1vaXplKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChmbi51bm1lbW9pemVkIHx8IGZuKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qKlxuICogUmVwZWF0ZWRseSBjYWxsIGBpdGVyYXRlZWAsIHdoaWxlIGB0ZXN0YCByZXR1cm5zIGB0cnVlYC4gQ2FsbHMgYGNhbGxiYWNrYCB3aGVuXG4gKiBzdG9wcGVkLCBvciBhbiBlcnJvciBvY2N1cnMuXG4gKlxuICogQG5hbWUgd2hpbHN0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0ZXN0IC0gc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGJlZm9yZSBlYWNoXG4gKiBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYC4gSW52b2tlZCB3aXRoICgpLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBlYWNoIHRpbWVcbiAqIGB0ZXN0YCBwYXNzZXMuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0XG4gKiBmdW5jdGlvbiBoYXMgZmFpbGVkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYFxuICogd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgYW5kIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3NcbiAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKTtcbiAqIEByZXR1cm5zIHVuZGVmaW5lZFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgY291bnQgPSAwO1xuICogYXN5bmMud2hpbHN0KFxuICogICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gY291bnQgPCA1OyB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNvdW50Kys7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBjb3VudCk7XG4gKiAgICAgICAgIH0sIDEwMDApO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24gKGVyciwgbikge1xuICogICAgICAgICAvLyA1IHNlY29uZHMgaGF2ZSBwYXNzZWQsIG4gPSA1XG4gKiAgICAgfVxuICogKTtcbiAqL1xuZnVuY3Rpb24gd2hpbHN0KHRlc3QsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb25seU9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7XG4gICAgaWYgKCF0ZXN0KCkpIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uKGVyci8qLCAuLi5hcmdzKi8pIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIGlmICh0ZXN0KCkpIHJldHVybiBfaXRlcmF0ZWUobmV4dCk7XG4gICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgW251bGxdLmNvbmNhdChhcmdzKSk7XG4gICAgfTtcbiAgICBfaXRlcmF0ZWUobmV4dCk7XG59XG5cbi8qKlxuICogUmVwZWF0ZWRseSBjYWxsIGBpdGVyYXRlZWAgdW50aWwgYHRlc3RgIHJldHVybnMgYHRydWVgLiBDYWxscyBgY2FsbGJhY2tgIHdoZW5cbiAqIHN0b3BwZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gYGNhbGxiYWNrYCB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciBhbmQgYW55XG4gKiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3MgY2FsbGJhY2suXG4gKlxuICogVGhlIGludmVyc2Ugb2YgW3doaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH0uXG4gKlxuICogQG5hbWUgdW50aWxcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLndoaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRlc3QgLSBzeW5jaHJvbm91cyB0cnV0aCB0ZXN0IHRvIHBlcmZvcm0gYmVmb3JlIGVhY2hcbiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggKCkuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZVxuICogYHRlc3RgIGZhaWxzLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciB0aGUgdGVzdFxuICogZnVuY3Rpb24gaGFzIHBhc3NlZCBhbmQgcmVwZWF0ZWQgZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAgaGFzIHN0b3BwZWQuIGBjYWxsYmFja2BcbiAqIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yIGFuZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZmluYWwgYGl0ZXJhdGVlYCdzXG4gKiBjYWxsYmFjay4gSW52b2tlZCB3aXRoIChlcnIsIFtyZXN1bHRzXSk7XG4gKi9cbmZ1bmN0aW9uIHVudGlsKHRlc3QsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHdoaWxzdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0ZXN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwgaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSdW5zIHRoZSBgdGFza3NgIGFycmF5IG9mIGZ1bmN0aW9ucyBpbiBzZXJpZXMsIGVhY2ggcGFzc2luZyB0aGVpciByZXN1bHRzIHRvXG4gKiB0aGUgbmV4dCBpbiB0aGUgYXJyYXkuIEhvd2V2ZXIsIGlmIGFueSBvZiB0aGUgYHRhc2tzYCBwYXNzIGFuIGVycm9yIHRvIHRoZWlyXG4gKiBvd24gY2FsbGJhY2ssIHRoZSBuZXh0IGZ1bmN0aW9uIGlzIG5vdCBleGVjdXRlZCwgYW5kIHRoZSBtYWluIGBjYWxsYmFja2AgaXNcbiAqIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSBlcnJvci5cbiAqXG4gKiBAbmFtZSB3YXRlcmZhbGxcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl9IHRhc2tzIC0gQW4gYXJyYXkgb2YgW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn1cbiAqIHRvIHJ1bi5cbiAqIEVhY2ggZnVuY3Rpb24gc2hvdWxkIGNvbXBsZXRlIHdpdGggYW55IG51bWJlciBvZiBgcmVzdWx0YCB2YWx1ZXMuXG4gKiBUaGUgYHJlc3VsdGAgdmFsdWVzIHdpbGwgYmUgcGFzc2VkIGFzIGFyZ3VtZW50cywgaW4gb3JkZXIsIHRvIHRoZSBuZXh0IHRhc2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZVxuICogZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkLiBUaGlzIHdpbGwgYmUgcGFzc2VkIHRoZSByZXN1bHRzIG9mIHRoZSBsYXN0IHRhc2snc1xuICogY2FsbGJhY2suIEludm9rZWQgd2l0aCAoZXJyLCBbcmVzdWx0c10pLlxuICogQHJldHVybnMgdW5kZWZpbmVkXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScsICd0d28nKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGFyZzEsIGFyZzIsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGFyZzEgbm93IGVxdWFscyAnb25lJyBhbmQgYXJnMiBub3cgZXF1YWxzICd0d28nXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0aHJlZScpO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oYXJnMSwgY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gYXJnMSBub3cgZXF1YWxzICd0aHJlZSdcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RvbmUnKTtcbiAqICAgICB9XG4gKiBdLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyAnZG9uZSdcbiAqIH0pO1xuICpcbiAqIC8vIE9yLCB3aXRoIG5hbWVkIGZ1bmN0aW9uczpcbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgbXlGaXJzdEZ1bmN0aW9uLFxuICogICAgIG15U2Vjb25kRnVuY3Rpb24sXG4gKiAgICAgbXlMYXN0RnVuY3Rpb24sXG4gKiBdLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyAnZG9uZSdcbiAqIH0pO1xuICogZnVuY3Rpb24gbXlGaXJzdEZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScsICd0d28nKTtcbiAqIH1cbiAqIGZ1bmN0aW9uIG15U2Vjb25kRnVuY3Rpb24oYXJnMSwgYXJnMiwgY2FsbGJhY2spIHtcbiAqICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ29uZScgYW5kIGFyZzIgbm93IGVxdWFscyAndHdvJ1xuICogICAgIGNhbGxiYWNrKG51bGwsICd0aHJlZScpO1xuICogfVxuICogZnVuY3Rpb24gbXlMYXN0RnVuY3Rpb24oYXJnMSwgY2FsbGJhY2spIHtcbiAqICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ3RocmVlJ1xuICogICAgIGNhbGxiYWNrKG51bGwsICdkb25lJyk7XG4gKiB9XG4gKi9cbnZhciB3YXRlcmZhbGwgPSBmdW5jdGlvbih0YXNrcywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgaWYgKCFpc0FycmF5KHRhc2tzKSkgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gd2F0ZXJmYWxsIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJykpO1xuICAgIGlmICghdGFza3MubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB2YXIgdGFza0luZGV4ID0gMDtcblxuICAgIGZ1bmN0aW9uIG5leHRUYXNrKGFyZ3MpIHtcbiAgICAgICAgdmFyIHRhc2sgPSB3cmFwQXN5bmModGFza3NbdGFza0luZGV4KytdKTtcbiAgICAgICAgYXJncy5wdXNoKG9ubHlPbmNlKG5leHQpKTtcbiAgICAgICAgdGFzay5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXh0KGVyci8qLCAuLi5hcmdzKi8pIHtcbiAgICAgICAgaWYgKGVyciB8fCB0YXNrSW5kZXggPT09IHRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dFRhc2soc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgbmV4dFRhc2soW10pO1xufTtcblxuLyoqXG4gKiBBbiBcImFzeW5jIGZ1bmN0aW9uXCIgaW4gdGhlIGNvbnRleHQgb2YgQXN5bmMgaXMgYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHdpdGhcbiAqIGEgdmFyaWFibGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMsIHdpdGggdGhlIGZpbmFsIHBhcmFtZXRlciBiZWluZyBhIGNhbGxiYWNrLlxuICogKGBmdW5jdGlvbiAoYXJnMSwgYXJnMiwgLi4uLCBjYWxsYmFjaykge31gKVxuICogVGhlIGZpbmFsIGNhbGxiYWNrIGlzIG9mIHRoZSBmb3JtIGBjYWxsYmFjayhlcnIsIHJlc3VsdHMuLi4pYCwgd2hpY2ggbXVzdCBiZVxuICogY2FsbGVkIG9uY2UgdGhlIGZ1bmN0aW9uIGlzIGNvbXBsZXRlZC4gIFRoZSBjYWxsYmFjayBzaG91bGQgYmUgY2FsbGVkIHdpdGggYVxuICogRXJyb3IgYXMgaXRzIGZpcnN0IGFyZ3VtZW50IHRvIHNpZ25hbCB0aGF0IGFuIGVycm9yIG9jY3VycmVkLlxuICogT3RoZXJ3aXNlLCBpZiBubyBlcnJvciBvY2N1cnJlZCwgaXQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIGBudWxsYCBhcyB0aGUgZmlyc3RcbiAqIGFyZ3VtZW50LCBhbmQgYW55IGFkZGl0aW9uYWwgYHJlc3VsdGAgYXJndW1lbnRzIHRoYXQgbWF5IGFwcGx5LCB0byBzaWduYWxcbiAqIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi5cbiAqIFRoZSBjYWxsYmFjayBtdXN0IGJlIGNhbGxlZCBleGFjdGx5IG9uY2UsIGlkZWFsbHkgb24gYSBsYXRlciB0aWNrIG9mIHRoZVxuICogSmF2YVNjcmlwdCBldmVudCBsb29wLlxuICpcbiAqIFRoaXMgdHlwZSBvZiBmdW5jdGlvbiBpcyBhbHNvIHJlZmVycmVkIHRvIGFzIGEgXCJOb2RlLXN0eWxlIGFzeW5jIGZ1bmN0aW9uXCIsXG4gKiBvciBhIFwiY29udGludWF0aW9uIHBhc3Npbmctc3R5bGUgZnVuY3Rpb25cIiAoQ1BTKS4gTW9zdCBvZiB0aGUgbWV0aG9kcyBvZiB0aGlzXG4gKiBsaWJyYXJ5IGFyZSB0aGVtc2VsdmVzIENQUy9Ob2RlLXN0eWxlIGFzeW5jIGZ1bmN0aW9ucywgb3IgZnVuY3Rpb25zIHRoYXRcbiAqIHJldHVybiBDUFMvTm9kZS1zdHlsZSBhc3luYyBmdW5jdGlvbnMuXG4gKlxuICogV2hlcmV2ZXIgd2UgYWNjZXB0IGEgTm9kZS1zdHlsZSBhc3luYyBmdW5jdGlvbiwgd2UgYWxzbyBkaXJlY3RseSBhY2NlcHQgYW5cbiAqIFtFUzIwMTcgYGFzeW5jYCBmdW5jdGlvbl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvU3RhdGVtZW50cy9hc3luY19mdW5jdGlvbn0uXG4gKiBJbiB0aGlzIGNhc2UsIHRoZSBgYXN5bmNgIGZ1bmN0aW9uIHdpbGwgbm90IGJlIHBhc3NlZCBhIGZpbmFsIGNhbGxiYWNrXG4gKiBhcmd1bWVudCwgYW5kIGFueSB0aHJvd24gZXJyb3Igd2lsbCBiZSB1c2VkIGFzIHRoZSBgZXJyYCBhcmd1bWVudCBvZiB0aGVcbiAqIGltcGxpY2l0IGNhbGxiYWNrLCBhbmQgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIGByZXN1bHRgIHZhbHVlLlxuICogKGkuZS4gYSBgcmVqZWN0ZWRgIG9mIHRoZSByZXR1cm5lZCBQcm9taXNlIGJlY29tZXMgdGhlIGBlcnJgIGNhbGxiYWNrXG4gKiBhcmd1bWVudCwgYW5kIGEgYHJlc29sdmVkYCB2YWx1ZSBiZWNvbWVzIHRoZSBgcmVzdWx0YC4pXG4gKlxuICogTm90ZSwgZHVlIHRvIEphdmFTY3JpcHQgbGltaXRhdGlvbnMsIHdlIGNhbiBvbmx5IGRldGVjdCBuYXRpdmUgYGFzeW5jYFxuICogZnVuY3Rpb25zIGFuZCBub3QgdHJhbnNwaWxpZWQgaW1wbGVtZW50YXRpb25zLlxuICogWW91ciBlbnZpcm9ubWVudCBtdXN0IGhhdmUgYGFzeW5jYC9gYXdhaXRgIHN1cHBvcnQgZm9yIHRoaXMgdG8gd29yay5cbiAqIChlLmcuIE5vZGUgPiB2Ny42LCBvciBhIHJlY2VudCB2ZXJzaW9uIG9mIGEgbW9kZXJuIGJyb3dzZXIpLlxuICogSWYgeW91IGFyZSB1c2luZyBgYXN5bmNgIGZ1bmN0aW9ucyB0aHJvdWdoIGEgdHJhbnNwaWxlciAoZS5nLiBCYWJlbCksIHlvdVxuICogbXVzdCBzdGlsbCB3cmFwIHRoZSBmdW5jdGlvbiB3aXRoIFthc3luY2lmeV17QGxpbmsgbW9kdWxlOlV0aWxzLmFzeW5jaWZ5fSxcbiAqIGJlY2F1c2UgdGhlIGBhc3luYyBmdW5jdGlvbmAgd2lsbCBiZSBjb21waWxlZCB0byBhbiBvcmRpbmFyeSBmdW5jdGlvbiB0aGF0XG4gKiByZXR1cm5zIGEgcHJvbWlzZS5cbiAqXG4gKiBAdHlwZWRlZiB7RnVuY3Rpb259IEFzeW5jRnVuY3Rpb25cbiAqIEBzdGF0aWNcbiAqL1xuXG4vKipcbiAqIEFzeW5jIGlzIGEgdXRpbGl0eSBtb2R1bGUgd2hpY2ggcHJvdmlkZXMgc3RyYWlnaHQtZm9yd2FyZCwgcG93ZXJmdWwgZnVuY3Rpb25zXG4gKiBmb3Igd29ya2luZyB3aXRoIGFzeW5jaHJvbm91cyBKYXZhU2NyaXB0LiBBbHRob3VnaCBvcmlnaW5hbGx5IGRlc2lnbmVkIGZvclxuICogdXNlIHdpdGggW05vZGUuanNdKGh0dHA6Ly9ub2RlanMub3JnKSBhbmQgaW5zdGFsbGFibGUgdmlhXG4gKiBgbnBtIGluc3RhbGwgLS1zYXZlIGFzeW5jYCwgaXQgY2FuIGFsc28gYmUgdXNlZCBkaXJlY3RseSBpbiB0aGUgYnJvd3Nlci5cbiAqIEBtb2R1bGUgYXN5bmNcbiAqIEBzZWUgQXN5bmNGdW5jdGlvblxuICovXG5cblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgYGFzeW5jYCBmdW5jdGlvbnMgZm9yIG1hbmlwdWxhdGluZyBjb2xsZWN0aW9ucywgc3VjaCBhc1xuICogYXJyYXlzIGFuZCBvYmplY3RzLlxuICogQG1vZHVsZSBDb2xsZWN0aW9uc1xuICovXG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGBhc3luY2AgZnVuY3Rpb25zIGZvciBjb250cm9sbGluZyB0aGUgZmxvdyB0aHJvdWdoIGEgc2NyaXB0LlxuICogQG1vZHVsZSBDb250cm9sRmxvd1xuICovXG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGBhc3luY2AgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKiBAbW9kdWxlIFV0aWxzXG4gKi9cblxudmFyIGluZGV4ID0ge1xuICAgIGFwcGx5OiBhcHBseSxcbiAgICBhcHBseUVhY2g6IGFwcGx5RWFjaCxcbiAgICBhcHBseUVhY2hTZXJpZXM6IGFwcGx5RWFjaFNlcmllcyxcbiAgICBhc3luY2lmeTogYXN5bmNpZnksXG4gICAgYXV0bzogYXV0byxcbiAgICBhdXRvSW5qZWN0OiBhdXRvSW5qZWN0LFxuICAgIGNhcmdvOiBjYXJnbyxcbiAgICBjb21wb3NlOiBjb21wb3NlLFxuICAgIGNvbmNhdDogY29uY2F0LFxuICAgIGNvbmNhdExpbWl0OiBjb25jYXRMaW1pdCxcbiAgICBjb25jYXRTZXJpZXM6IGNvbmNhdFNlcmllcyxcbiAgICBjb25zdGFudDogY29uc3RhbnQsXG4gICAgZGV0ZWN0OiBkZXRlY3QsXG4gICAgZGV0ZWN0TGltaXQ6IGRldGVjdExpbWl0LFxuICAgIGRldGVjdFNlcmllczogZGV0ZWN0U2VyaWVzLFxuICAgIGRpcjogZGlyLFxuICAgIGRvRHVyaW5nOiBkb0R1cmluZyxcbiAgICBkb1VudGlsOiBkb1VudGlsLFxuICAgIGRvV2hpbHN0OiBkb1doaWxzdCxcbiAgICBkdXJpbmc6IGR1cmluZyxcbiAgICBlYWNoOiBlYWNoTGltaXQsXG4gICAgZWFjaExpbWl0OiBlYWNoTGltaXQkMSxcbiAgICBlYWNoT2Y6IGVhY2hPZixcbiAgICBlYWNoT2ZMaW1pdDogZWFjaE9mTGltaXQsXG4gICAgZWFjaE9mU2VyaWVzOiBlYWNoT2ZTZXJpZXMsXG4gICAgZWFjaFNlcmllczogZWFjaFNlcmllcyxcbiAgICBlbnN1cmVBc3luYzogZW5zdXJlQXN5bmMsXG4gICAgZXZlcnk6IGV2ZXJ5LFxuICAgIGV2ZXJ5TGltaXQ6IGV2ZXJ5TGltaXQsXG4gICAgZXZlcnlTZXJpZXM6IGV2ZXJ5U2VyaWVzLFxuICAgIGZpbHRlcjogZmlsdGVyLFxuICAgIGZpbHRlckxpbWl0OiBmaWx0ZXJMaW1pdCxcbiAgICBmaWx0ZXJTZXJpZXM6IGZpbHRlclNlcmllcyxcbiAgICBmb3JldmVyOiBmb3JldmVyLFxuICAgIGdyb3VwQnk6IGdyb3VwQnksXG4gICAgZ3JvdXBCeUxpbWl0OiBncm91cEJ5TGltaXQsXG4gICAgZ3JvdXBCeVNlcmllczogZ3JvdXBCeVNlcmllcyxcbiAgICBsb2c6IGxvZyxcbiAgICBtYXA6IG1hcCxcbiAgICBtYXBMaW1pdDogbWFwTGltaXQsXG4gICAgbWFwU2VyaWVzOiBtYXBTZXJpZXMsXG4gICAgbWFwVmFsdWVzOiBtYXBWYWx1ZXMsXG4gICAgbWFwVmFsdWVzTGltaXQ6IG1hcFZhbHVlc0xpbWl0LFxuICAgIG1hcFZhbHVlc1NlcmllczogbWFwVmFsdWVzU2VyaWVzLFxuICAgIG1lbW9pemU6IG1lbW9pemUsXG4gICAgbmV4dFRpY2s6IG5leHRUaWNrLFxuICAgIHBhcmFsbGVsOiBwYXJhbGxlbExpbWl0LFxuICAgIHBhcmFsbGVsTGltaXQ6IHBhcmFsbGVsTGltaXQkMSxcbiAgICBwcmlvcml0eVF1ZXVlOiBwcmlvcml0eVF1ZXVlLFxuICAgIHF1ZXVlOiBxdWV1ZSQxLFxuICAgIHJhY2U6IHJhY2UsXG4gICAgcmVkdWNlOiByZWR1Y2UsXG4gICAgcmVkdWNlUmlnaHQ6IHJlZHVjZVJpZ2h0LFxuICAgIHJlZmxlY3Q6IHJlZmxlY3QsXG4gICAgcmVmbGVjdEFsbDogcmVmbGVjdEFsbCxcbiAgICByZWplY3Q6IHJlamVjdCxcbiAgICByZWplY3RMaW1pdDogcmVqZWN0TGltaXQsXG4gICAgcmVqZWN0U2VyaWVzOiByZWplY3RTZXJpZXMsXG4gICAgcmV0cnk6IHJldHJ5LFxuICAgIHJldHJ5YWJsZTogcmV0cnlhYmxlLFxuICAgIHNlcTogc2VxLFxuICAgIHNlcmllczogc2VyaWVzLFxuICAgIHNldEltbWVkaWF0ZTogc2V0SW1tZWRpYXRlJDEsXG4gICAgc29tZTogc29tZSxcbiAgICBzb21lTGltaXQ6IHNvbWVMaW1pdCxcbiAgICBzb21lU2VyaWVzOiBzb21lU2VyaWVzLFxuICAgIHNvcnRCeTogc29ydEJ5LFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgdGltZXM6IHRpbWVzLFxuICAgIHRpbWVzTGltaXQ6IHRpbWVMaW1pdCxcbiAgICB0aW1lc1NlcmllczogdGltZXNTZXJpZXMsXG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgdHJ5RWFjaDogdHJ5RWFjaCxcbiAgICB1bm1lbW9pemU6IHVubWVtb2l6ZSxcbiAgICB1bnRpbDogdW50aWwsXG4gICAgd2F0ZXJmYWxsOiB3YXRlcmZhbGwsXG4gICAgd2hpbHN0OiB3aGlsc3QsXG5cbiAgICAvLyBhbGlhc2VzXG4gICAgYWxsOiBldmVyeSxcbiAgICBhbGxMaW1pdDogZXZlcnlMaW1pdCxcbiAgICBhbGxTZXJpZXM6IGV2ZXJ5U2VyaWVzLFxuICAgIGFueTogc29tZSxcbiAgICBhbnlMaW1pdDogc29tZUxpbWl0LFxuICAgIGFueVNlcmllczogc29tZVNlcmllcyxcbiAgICBmaW5kOiBkZXRlY3QsXG4gICAgZmluZExpbWl0OiBkZXRlY3RMaW1pdCxcbiAgICBmaW5kU2VyaWVzOiBkZXRlY3RTZXJpZXMsXG4gICAgZm9yRWFjaDogZWFjaExpbWl0LFxuICAgIGZvckVhY2hTZXJpZXM6IGVhY2hTZXJpZXMsXG4gICAgZm9yRWFjaExpbWl0OiBlYWNoTGltaXQkMSxcbiAgICBmb3JFYWNoT2Y6IGVhY2hPZixcbiAgICBmb3JFYWNoT2ZTZXJpZXM6IGVhY2hPZlNlcmllcyxcbiAgICBmb3JFYWNoT2ZMaW1pdDogZWFjaE9mTGltaXQsXG4gICAgaW5qZWN0OiByZWR1Y2UsXG4gICAgZm9sZGw6IHJlZHVjZSxcbiAgICBmb2xkcjogcmVkdWNlUmlnaHQsXG4gICAgc2VsZWN0OiBmaWx0ZXIsXG4gICAgc2VsZWN0TGltaXQ6IGZpbHRlckxpbWl0LFxuICAgIHNlbGVjdFNlcmllczogZmlsdGVyU2VyaWVzLFxuICAgIHdyYXBTeW5jOiBhc3luY2lmeVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gaW5kZXg7XG5leHBvcnRzLmFwcGx5ID0gYXBwbHk7XG5leHBvcnRzLmFwcGx5RWFjaCA9IGFwcGx5RWFjaDtcbmV4cG9ydHMuYXBwbHlFYWNoU2VyaWVzID0gYXBwbHlFYWNoU2VyaWVzO1xuZXhwb3J0cy5hc3luY2lmeSA9IGFzeW5jaWZ5O1xuZXhwb3J0cy5hdXRvID0gYXV0bztcbmV4cG9ydHMuYXV0b0luamVjdCA9IGF1dG9JbmplY3Q7XG5leHBvcnRzLmNhcmdvID0gY2FyZ287XG5leHBvcnRzLmNvbXBvc2UgPSBjb21wb3NlO1xuZXhwb3J0cy5jb25jYXQgPSBjb25jYXQ7XG5leHBvcnRzLmNvbmNhdExpbWl0ID0gY29uY2F0TGltaXQ7XG5leHBvcnRzLmNvbmNhdFNlcmllcyA9IGNvbmNhdFNlcmllcztcbmV4cG9ydHMuY29uc3RhbnQgPSBjb25zdGFudDtcbmV4cG9ydHMuZGV0ZWN0ID0gZGV0ZWN0O1xuZXhwb3J0cy5kZXRlY3RMaW1pdCA9IGRldGVjdExpbWl0O1xuZXhwb3J0cy5kZXRlY3RTZXJpZXMgPSBkZXRlY3RTZXJpZXM7XG5leHBvcnRzLmRpciA9IGRpcjtcbmV4cG9ydHMuZG9EdXJpbmcgPSBkb0R1cmluZztcbmV4cG9ydHMuZG9VbnRpbCA9IGRvVW50aWw7XG5leHBvcnRzLmRvV2hpbHN0ID0gZG9XaGlsc3Q7XG5leHBvcnRzLmR1cmluZyA9IGR1cmluZztcbmV4cG9ydHMuZWFjaCA9IGVhY2hMaW1pdDtcbmV4cG9ydHMuZWFjaExpbWl0ID0gZWFjaExpbWl0JDE7XG5leHBvcnRzLmVhY2hPZiA9IGVhY2hPZjtcbmV4cG9ydHMuZWFjaE9mTGltaXQgPSBlYWNoT2ZMaW1pdDtcbmV4cG9ydHMuZWFjaE9mU2VyaWVzID0gZWFjaE9mU2VyaWVzO1xuZXhwb3J0cy5lYWNoU2VyaWVzID0gZWFjaFNlcmllcztcbmV4cG9ydHMuZW5zdXJlQXN5bmMgPSBlbnN1cmVBc3luYztcbmV4cG9ydHMuZXZlcnkgPSBldmVyeTtcbmV4cG9ydHMuZXZlcnlMaW1pdCA9IGV2ZXJ5TGltaXQ7XG5leHBvcnRzLmV2ZXJ5U2VyaWVzID0gZXZlcnlTZXJpZXM7XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbmV4cG9ydHMuZmlsdGVyTGltaXQgPSBmaWx0ZXJMaW1pdDtcbmV4cG9ydHMuZmlsdGVyU2VyaWVzID0gZmlsdGVyU2VyaWVzO1xuZXhwb3J0cy5mb3JldmVyID0gZm9yZXZlcjtcbmV4cG9ydHMuZ3JvdXBCeSA9IGdyb3VwQnk7XG5leHBvcnRzLmdyb3VwQnlMaW1pdCA9IGdyb3VwQnlMaW1pdDtcbmV4cG9ydHMuZ3JvdXBCeVNlcmllcyA9IGdyb3VwQnlTZXJpZXM7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMubWFwID0gbWFwO1xuZXhwb3J0cy5tYXBMaW1pdCA9IG1hcExpbWl0O1xuZXhwb3J0cy5tYXBTZXJpZXMgPSBtYXBTZXJpZXM7XG5leHBvcnRzLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcbmV4cG9ydHMubWFwVmFsdWVzTGltaXQgPSBtYXBWYWx1ZXNMaW1pdDtcbmV4cG9ydHMubWFwVmFsdWVzU2VyaWVzID0gbWFwVmFsdWVzU2VyaWVzO1xuZXhwb3J0cy5tZW1vaXplID0gbWVtb2l6ZTtcbmV4cG9ydHMubmV4dFRpY2sgPSBuZXh0VGljaztcbmV4cG9ydHMucGFyYWxsZWwgPSBwYXJhbGxlbExpbWl0O1xuZXhwb3J0cy5wYXJhbGxlbExpbWl0ID0gcGFyYWxsZWxMaW1pdCQxO1xuZXhwb3J0cy5wcmlvcml0eVF1ZXVlID0gcHJpb3JpdHlRdWV1ZTtcbmV4cG9ydHMucXVldWUgPSBxdWV1ZSQxO1xuZXhwb3J0cy5yYWNlID0gcmFjZTtcbmV4cG9ydHMucmVkdWNlID0gcmVkdWNlO1xuZXhwb3J0cy5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuZXhwb3J0cy5yZWZsZWN0ID0gcmVmbGVjdDtcbmV4cG9ydHMucmVmbGVjdEFsbCA9IHJlZmxlY3RBbGw7XG5leHBvcnRzLnJlamVjdCA9IHJlamVjdDtcbmV4cG9ydHMucmVqZWN0TGltaXQgPSByZWplY3RMaW1pdDtcbmV4cG9ydHMucmVqZWN0U2VyaWVzID0gcmVqZWN0U2VyaWVzO1xuZXhwb3J0cy5yZXRyeSA9IHJldHJ5O1xuZXhwb3J0cy5yZXRyeWFibGUgPSByZXRyeWFibGU7XG5leHBvcnRzLnNlcSA9IHNlcTtcbmV4cG9ydHMuc2VyaWVzID0gc2VyaWVzO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGUkMTtcbmV4cG9ydHMuc29tZSA9IHNvbWU7XG5leHBvcnRzLnNvbWVMaW1pdCA9IHNvbWVMaW1pdDtcbmV4cG9ydHMuc29tZVNlcmllcyA9IHNvbWVTZXJpZXM7XG5leHBvcnRzLnNvcnRCeSA9IHNvcnRCeTtcbmV4cG9ydHMudGltZW91dCA9IHRpbWVvdXQ7XG5leHBvcnRzLnRpbWVzID0gdGltZXM7XG5leHBvcnRzLnRpbWVzTGltaXQgPSB0aW1lTGltaXQ7XG5leHBvcnRzLnRpbWVzU2VyaWVzID0gdGltZXNTZXJpZXM7XG5leHBvcnRzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbmV4cG9ydHMudHJ5RWFjaCA9IHRyeUVhY2g7XG5leHBvcnRzLnVubWVtb2l6ZSA9IHVubWVtb2l6ZTtcbmV4cG9ydHMudW50aWwgPSB1bnRpbDtcbmV4cG9ydHMud2F0ZXJmYWxsID0gd2F0ZXJmYWxsO1xuZXhwb3J0cy53aGlsc3QgPSB3aGlsc3Q7XG5leHBvcnRzLmFsbCA9IGV2ZXJ5O1xuZXhwb3J0cy5hbGxMaW1pdCA9IGV2ZXJ5TGltaXQ7XG5leHBvcnRzLmFsbFNlcmllcyA9IGV2ZXJ5U2VyaWVzO1xuZXhwb3J0cy5hbnkgPSBzb21lO1xuZXhwb3J0cy5hbnlMaW1pdCA9IHNvbWVMaW1pdDtcbmV4cG9ydHMuYW55U2VyaWVzID0gc29tZVNlcmllcztcbmV4cG9ydHMuZmluZCA9IGRldGVjdDtcbmV4cG9ydHMuZmluZExpbWl0ID0gZGV0ZWN0TGltaXQ7XG5leHBvcnRzLmZpbmRTZXJpZXMgPSBkZXRlY3RTZXJpZXM7XG5leHBvcnRzLmZvckVhY2ggPSBlYWNoTGltaXQ7XG5leHBvcnRzLmZvckVhY2hTZXJpZXMgPSBlYWNoU2VyaWVzO1xuZXhwb3J0cy5mb3JFYWNoTGltaXQgPSBlYWNoTGltaXQkMTtcbmV4cG9ydHMuZm9yRWFjaE9mID0gZWFjaE9mO1xuZXhwb3J0cy5mb3JFYWNoT2ZTZXJpZXMgPSBlYWNoT2ZTZXJpZXM7XG5leHBvcnRzLmZvckVhY2hPZkxpbWl0ID0gZWFjaE9mTGltaXQ7XG5leHBvcnRzLmluamVjdCA9IHJlZHVjZTtcbmV4cG9ydHMuZm9sZGwgPSByZWR1Y2U7XG5leHBvcnRzLmZvbGRyID0gcmVkdWNlUmlnaHQ7XG5leHBvcnRzLnNlbGVjdCA9IGZpbHRlcjtcbmV4cG9ydHMuc2VsZWN0TGltaXQgPSBmaWx0ZXJMaW1pdDtcbmV4cG9ydHMuc2VsZWN0U2VyaWVzID0gZmlsdGVyU2VyaWVzO1xuZXhwb3J0cy53cmFwU3luYyA9IGFzeW5jaWZ5O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGVzY2FwZVN0cmluZ1JlZ2V4cCA9IHJlcXVpcmUoJ2VzY2FwZS1zdHJpbmctcmVnZXhwJyk7XG52YXIgYW5zaVN0eWxlcyA9IHJlcXVpcmUoJ2Fuc2ktc3R5bGVzJyk7XG52YXIgc3RyaXBBbnNpID0gcmVxdWlyZSgnc3RyaXAtYW5zaScpO1xudmFyIGhhc0Fuc2kgPSByZXF1aXJlKCdoYXMtYW5zaScpO1xudmFyIHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xudmFyIGRlZmluZVByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgaXNTaW1wbGVXaW5kb3dzVGVybSA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgJiYgIS9eeHRlcm0vaS50ZXN0KHByb2Nlc3MuZW52LlRFUk0pO1xuXG5mdW5jdGlvbiBDaGFsayhvcHRpb25zKSB7XG5cdC8vIGRldGVjdCBtb2RlIGlmIG5vdCBzZXQgbWFudWFsbHlcblx0dGhpcy5lbmFibGVkID0gIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmFibGVkID09PSB1bmRlZmluZWQgPyBzdXBwb3J0c0NvbG9yIDogb3B0aW9ucy5lbmFibGVkO1xufVxuXG4vLyB1c2UgYnJpZ2h0IGJsdWUgb24gV2luZG93cyBhcyB0aGUgbm9ybWFsIGJsdWUgY29sb3IgaXMgaWxsZWdpYmxlXG5pZiAoaXNTaW1wbGVXaW5kb3dzVGVybSkge1xuXHRhbnNpU3R5bGVzLmJsdWUub3BlbiA9ICdcXHUwMDFiWzk0bSc7XG59XG5cbnZhciBzdHlsZXMgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgcmV0ID0ge307XG5cblx0T2JqZWN0LmtleXMoYW5zaVN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0YW5zaVN0eWxlc1trZXldLmNsb3NlUmUgPSBuZXcgUmVnRXhwKGVzY2FwZVN0cmluZ1JlZ2V4cChhbnNpU3R5bGVzW2tleV0uY2xvc2UpLCAnZycpO1xuXG5cdFx0cmV0W2tleV0gPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGJ1aWxkLmNhbGwodGhpcywgdGhpcy5fc3R5bGVzLmNvbmNhdChrZXkpKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcblxuXHRyZXR1cm4gcmV0O1xufSkoKTtcblxudmFyIHByb3RvID0gZGVmaW5lUHJvcHMoZnVuY3Rpb24gY2hhbGsoKSB7fSwgc3R5bGVzKTtcblxuZnVuY3Rpb24gYnVpbGQoX3N0eWxlcykge1xuXHR2YXIgYnVpbGRlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gYXBwbHlTdHlsZS5hcHBseShidWlsZGVyLCBhcmd1bWVudHMpO1xuXHR9O1xuXG5cdGJ1aWxkZXIuX3N0eWxlcyA9IF9zdHlsZXM7XG5cdGJ1aWxkZXIuZW5hYmxlZCA9IHRoaXMuZW5hYmxlZDtcblx0Ly8gX19wcm90b19fIGlzIHVzZWQgYmVjYXVzZSB3ZSBtdXN0IHJldHVybiBhIGZ1bmN0aW9uLCBidXQgdGhlcmUgaXNcblx0Ly8gbm8gd2F5IHRvIGNyZWF0ZSBhIGZ1bmN0aW9uIHdpdGggYSBkaWZmZXJlbnQgcHJvdG90eXBlLlxuXHQvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXHRidWlsZGVyLl9fcHJvdG9fXyA9IHByb3RvO1xuXG5cdHJldHVybiBidWlsZGVyO1xufVxuXG5mdW5jdGlvbiBhcHBseVN0eWxlKCkge1xuXHQvLyBzdXBwb3J0IHZhcmFncywgYnV0IHNpbXBseSBjYXN0IHRvIHN0cmluZyBpbiBjYXNlIHRoZXJlJ3Mgb25seSBvbmUgYXJnXG5cdHZhciBhcmdzID0gYXJndW1lbnRzO1xuXHR2YXIgYXJnc0xlbiA9IGFyZ3MubGVuZ3RoO1xuXHR2YXIgc3RyID0gYXJnc0xlbiAhPT0gMCAmJiBTdHJpbmcoYXJndW1lbnRzWzBdKTtcblxuXHRpZiAoYXJnc0xlbiA+IDEpIHtcblx0XHQvLyBkb24ndCBzbGljZSBgYXJndW1lbnRzYCwgaXQgcHJldmVudHMgdjggb3B0aW1pemF0aW9uc1xuXHRcdGZvciAodmFyIGEgPSAxOyBhIDwgYXJnc0xlbjsgYSsrKSB7XG5cdFx0XHRzdHIgKz0gJyAnICsgYXJnc1thXTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIXRoaXMuZW5hYmxlZCB8fCAhc3RyKSB7XG5cdFx0cmV0dXJuIHN0cjtcblx0fVxuXG5cdHZhciBuZXN0ZWRTdHlsZXMgPSB0aGlzLl9zdHlsZXM7XG5cdHZhciBpID0gbmVzdGVkU3R5bGVzLmxlbmd0aDtcblxuXHQvLyBUdXJucyBvdXQgdGhhdCBvbiBXaW5kb3dzIGRpbW1lZCBncmF5IHRleHQgYmVjb21lcyBpbnZpc2libGUgaW4gY21kLmV4ZSxcblx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFsay9jaGFsay9pc3N1ZXMvNThcblx0Ly8gSWYgd2UncmUgb24gV2luZG93cyBhbmQgd2UncmUgZGVhbGluZyB3aXRoIGEgZ3JheSBjb2xvciwgdGVtcG9yYXJpbHkgbWFrZSAnZGltJyBhIG5vb3AuXG5cdHZhciBvcmlnaW5hbERpbSA9IGFuc2lTdHlsZXMuZGltLm9wZW47XG5cdGlmIChpc1NpbXBsZVdpbmRvd3NUZXJtICYmIChuZXN0ZWRTdHlsZXMuaW5kZXhPZignZ3JheScpICE9PSAtMSB8fCBuZXN0ZWRTdHlsZXMuaW5kZXhPZignZ3JleScpICE9PSAtMSkpIHtcblx0XHRhbnNpU3R5bGVzLmRpbS5vcGVuID0gJyc7XG5cdH1cblxuXHR3aGlsZSAoaS0tKSB7XG5cdFx0dmFyIGNvZGUgPSBhbnNpU3R5bGVzW25lc3RlZFN0eWxlc1tpXV07XG5cblx0XHQvLyBSZXBsYWNlIGFueSBpbnN0YW5jZXMgYWxyZWFkeSBwcmVzZW50IHdpdGggYSByZS1vcGVuaW5nIGNvZGVcblx0XHQvLyBvdGhlcndpc2Ugb25seSB0aGUgcGFydCBvZiB0aGUgc3RyaW5nIHVudGlsIHNhaWQgY2xvc2luZyBjb2RlXG5cdFx0Ly8gd2lsbCBiZSBjb2xvcmVkLCBhbmQgdGhlIHJlc3Qgd2lsbCBzaW1wbHkgYmUgJ3BsYWluJy5cblx0XHRzdHIgPSBjb2RlLm9wZW4gKyBzdHIucmVwbGFjZShjb2RlLmNsb3NlUmUsIGNvZGUub3BlbikgKyBjb2RlLmNsb3NlO1xuXHR9XG5cblx0Ly8gUmVzZXQgdGhlIG9yaWdpbmFsICdkaW0nIGlmIHdlIGNoYW5nZWQgaXQgdG8gd29yayBhcm91bmQgdGhlIFdpbmRvd3MgZGltbWVkIGdyYXkgaXNzdWUuXG5cdGFuc2lTdHlsZXMuZGltLm9wZW4gPSBvcmlnaW5hbERpbTtcblxuXHRyZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiBpbml0KCkge1xuXHR2YXIgcmV0ID0ge307XG5cblx0T2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0W25hbWVdID0ge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBidWlsZC5jYWxsKHRoaXMsIFtuYW1lXSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG5cblx0cmV0dXJuIHJldDtcbn1cblxuZGVmaW5lUHJvcHMoQ2hhbGsucHJvdG90eXBlLCBpbml0KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBDaGFsaygpO1xubW9kdWxlLmV4cG9ydHMuc3R5bGVzID0gYW5zaVN0eWxlcztcbm1vZHVsZS5leHBvcnRzLmhhc0NvbG9yID0gaGFzQW5zaTtcbm1vZHVsZS5leHBvcnRzLnN0cmlwQ29sb3IgPSBzdHJpcEFuc2k7XG5tb2R1bGUuZXhwb3J0cy5zdXBwb3J0c0NvbG9yID0gc3VwcG9ydHNDb2xvcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhcmd2ID0gcHJvY2Vzcy5hcmd2O1xuXG52YXIgdGVybWluYXRvciA9IGFyZ3YuaW5kZXhPZignLS0nKTtcbnZhciBoYXNGbGFnID0gZnVuY3Rpb24gKGZsYWcpIHtcblx0ZmxhZyA9ICctLScgKyBmbGFnO1xuXHR2YXIgcG9zID0gYXJndi5pbmRleE9mKGZsYWcpO1xuXHRyZXR1cm4gcG9zICE9PSAtMSAmJiAodGVybWluYXRvciAhPT0gLTEgPyBwb3MgPCB0ZXJtaW5hdG9yIDogdHJ1ZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG5cdGlmICgnRk9SQ0VfQ09MT1InIGluIHByb2Nlc3MuZW52KSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoaGFzRmxhZygnbm8tY29sb3InKSB8fFxuXHRcdGhhc0ZsYWcoJ25vLWNvbG9ycycpIHx8XG5cdFx0aGFzRmxhZygnY29sb3I9ZmFsc2UnKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcicpIHx8XG5cdFx0aGFzRmxhZygnY29sb3JzJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj10cnVlJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj1hbHdheXMnKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKHByb2Nlc3Muc3Rkb3V0ICYmICFwcm9jZXNzLnN0ZG91dC5pc1RUWSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoJ0NPTE9SVEVSTScgaW4gcHJvY2Vzcy5lbnYpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmIChwcm9jZXNzLmVudi5URVJNID09PSAnZHVtYicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoL15zY3JlZW58Xnh0ZXJtfF52dDEwMHxjb2xvcnxhbnNpfGN5Z3dpbnxsaW51eC9pLnRlc3QocHJvY2Vzcy5lbnYuVEVSTSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn0pKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXRjaE9wZXJhdG9yc1JlID0gL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0aWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcblx0fVxuXG5cdHJldHVybiBzdHIucmVwbGFjZShtYXRjaE9wZXJhdG9yc1JlLCAnXFxcXCQmJyk7XG59O1xuIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJlc3ByaW1hXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImVzcHJpbWFcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG5cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHQvKlxyXG5cdCAgQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycywgaHR0cHM6Ly9qcy5mb3VuZGF0aW9uL1xyXG5cclxuXHQgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxyXG5cdCAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcblxyXG5cdCAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XHJcblx0ICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG5cdCAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XHJcblx0ICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxyXG5cdCAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcblxyXG5cdCAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcclxuXHQgIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcclxuXHQgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXHJcblx0ICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXHJcblx0ICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xyXG5cdCAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xyXG5cdCAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXHJcblx0ICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxyXG5cdCAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXHJcblx0ICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG5cdCovXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBjb21tZW50X2hhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblx0dmFyIGpzeF9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblx0dmFyIHBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuXHR2YXIgdG9rZW5pemVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcclxuXHRmdW5jdGlvbiBwYXJzZShjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xyXG5cdCAgICB2YXIgY29tbWVudEhhbmRsZXIgPSBudWxsO1xyXG5cdCAgICB2YXIgcHJveHlEZWxlZ2F0ZSA9IGZ1bmN0aW9uIChub2RlLCBtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgaWYgKGRlbGVnYXRlKSB7XHJcblx0ICAgICAgICAgICAgZGVsZWdhdGUobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNvbW1lbnRIYW5kbGVyKSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudEhhbmRsZXIudmlzaXQobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICB2YXIgcGFyc2VyRGVsZWdhdGUgPSAodHlwZW9mIGRlbGVnYXRlID09PSAnZnVuY3Rpb24nKSA/IHByb3h5RGVsZWdhdGUgOiBudWxsO1xyXG5cdCAgICB2YXIgY29sbGVjdENvbW1lbnQgPSBmYWxzZTtcclxuXHQgICAgaWYgKG9wdGlvbnMpIHtcclxuXHQgICAgICAgIGNvbGxlY3RDb21tZW50ID0gKHR5cGVvZiBvcHRpb25zLmNvbW1lbnQgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLmNvbW1lbnQpO1xyXG5cdCAgICAgICAgdmFyIGF0dGFjaENvbW1lbnQgPSAodHlwZW9mIG9wdGlvbnMuYXR0YWNoQ29tbWVudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMuYXR0YWNoQ29tbWVudCk7XHJcblx0ICAgICAgICBpZiAoY29sbGVjdENvbW1lbnQgfHwgYXR0YWNoQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRIYW5kbGVyID0gbmV3IGNvbW1lbnRfaGFuZGxlcl8xLkNvbW1lbnRIYW5kbGVyKCk7XHJcblx0ICAgICAgICAgICAgY29tbWVudEhhbmRsZXIuYXR0YWNoID0gYXR0YWNoQ29tbWVudDtcclxuXHQgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIHBhcnNlckRlbGVnYXRlID0gcHJveHlEZWxlZ2F0ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICB2YXIgaXNNb2R1bGUgPSBmYWxzZTtcclxuXHQgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuc291cmNlVHlwZSA9PT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgIGlzTW9kdWxlID0gKG9wdGlvbnMuc291cmNlVHlwZSA9PT0gJ21vZHVsZScpO1xyXG5cdCAgICB9XHJcblx0ICAgIHZhciBwYXJzZXI7XHJcblx0ICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLmpzeCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMuanN4KSB7XHJcblx0ICAgICAgICBwYXJzZXIgPSBuZXcganN4X3BhcnNlcl8xLkpTWFBhcnNlcihjb2RlLCBvcHRpb25zLCBwYXJzZXJEZWxlZ2F0ZSk7XHJcblx0ICAgIH1cclxuXHQgICAgZWxzZSB7XHJcblx0ICAgICAgICBwYXJzZXIgPSBuZXcgcGFyc2VyXzEuUGFyc2VyKGNvZGUsIG9wdGlvbnMsIHBhcnNlckRlbGVnYXRlKTtcclxuXHQgICAgfVxyXG5cdCAgICB2YXIgcHJvZ3JhbSA9IGlzTW9kdWxlID8gcGFyc2VyLnBhcnNlTW9kdWxlKCkgOiBwYXJzZXIucGFyc2VTY3JpcHQoKTtcclxuXHQgICAgdmFyIGFzdCA9IHByb2dyYW07XHJcblx0ICAgIGlmIChjb2xsZWN0Q29tbWVudCAmJiBjb21tZW50SGFuZGxlcikge1xyXG5cdCAgICAgICAgYXN0LmNvbW1lbnRzID0gY29tbWVudEhhbmRsZXIuY29tbWVudHM7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHBhcnNlci5jb25maWcudG9rZW5zKSB7XHJcblx0ICAgICAgICBhc3QudG9rZW5zID0gcGFyc2VyLnRva2VucztcclxuXHQgICAgfVxyXG5cdCAgICBpZiAocGFyc2VyLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgYXN0LmVycm9ycyA9IHBhcnNlci5lcnJvckhhbmRsZXIuZXJyb3JzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBhc3Q7XHJcblx0fVxyXG5cdGV4cG9ydHMucGFyc2UgPSBwYXJzZTtcclxuXHRmdW5jdGlvbiBwYXJzZU1vZHVsZShjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xyXG5cdCAgICB2YXIgcGFyc2luZ09wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdCAgICBwYXJzaW5nT3B0aW9ucy5zb3VyY2VUeXBlID0gJ21vZHVsZSc7XHJcblx0ICAgIHJldHVybiBwYXJzZShjb2RlLCBwYXJzaW5nT3B0aW9ucywgZGVsZWdhdGUpO1xyXG5cdH1cclxuXHRleHBvcnRzLnBhcnNlTW9kdWxlID0gcGFyc2VNb2R1bGU7XHJcblx0ZnVuY3Rpb24gcGFyc2VTY3JpcHQoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcclxuXHQgICAgdmFyIHBhcnNpbmdPcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQgICAgcGFyc2luZ09wdGlvbnMuc291cmNlVHlwZSA9ICdzY3JpcHQnO1xyXG5cdCAgICByZXR1cm4gcGFyc2UoY29kZSwgcGFyc2luZ09wdGlvbnMsIGRlbGVnYXRlKTtcclxuXHR9XHJcblx0ZXhwb3J0cy5wYXJzZVNjcmlwdCA9IHBhcnNlU2NyaXB0O1xyXG5cdGZ1bmN0aW9uIHRva2VuaXplKGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XHJcblx0ICAgIHZhciB0b2tlbml6ZXIgPSBuZXcgdG9rZW5pemVyXzEuVG9rZW5pemVyKGNvZGUsIG9wdGlvbnMpO1xyXG5cdCAgICB2YXIgdG9rZW5zO1xyXG5cdCAgICB0b2tlbnMgPSBbXTtcclxuXHQgICAgdHJ5IHtcclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5pemVyLmdldE5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGlmICghdG9rZW4pIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IGRlbGVnYXRlKHRva2VuKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICAgIGNhdGNoIChlKSB7XHJcblx0ICAgICAgICB0b2tlbml6ZXIuZXJyb3JIYW5kbGVyLnRvbGVyYXRlKGUpO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmICh0b2tlbml6ZXIuZXJyb3JIYW5kbGVyLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICB0b2tlbnMuZXJyb3JzID0gdG9rZW5pemVyLmVycm9ycygpO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiB0b2tlbnM7XHJcblx0fVxyXG5cdGV4cG9ydHMudG9rZW5pemUgPSB0b2tlbml6ZTtcclxuXHR2YXIgc3ludGF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cdGV4cG9ydHMuU3ludGF4ID0gc3ludGF4XzEuU3ludGF4O1xyXG5cdC8vIFN5bmMgd2l0aCAqLmpzb24gbWFuaWZlc3RzLlxyXG5cdGV4cG9ydHMudmVyc2lvbiA9ICc0LjAuMCc7XHJcblxuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBzeW50YXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblx0dmFyIENvbW1lbnRIYW5kbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ29tbWVudEhhbmRsZXIoKSB7XHJcblx0ICAgICAgICB0aGlzLmF0dGFjaCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5jb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5sZWFkaW5nID0gW107XHJcblx0ICAgICAgICB0aGlzLnRyYWlsaW5nID0gW107XHJcblx0ICAgIH1cclxuXHQgICAgQ29tbWVudEhhbmRsZXIucHJvdG90eXBlLmluc2VydElubmVyQ29tbWVudHMgPSBmdW5jdGlvbiAobm9kZSwgbWV0YWRhdGEpIHtcclxuXHQgICAgICAgIC8vICBpbm5uZXJDb21tZW50cyBmb3IgcHJvcGVydGllcyBlbXB0eSBibG9ja1xyXG5cdCAgICAgICAgLy8gIGBmdW5jdGlvbiBhKCkgey8qKiBjb21tZW50cyAqKlxcL31gXHJcblx0ICAgICAgICBpZiAobm9kZS50eXBlID09PSBzeW50YXhfMS5TeW50YXguQmxvY2tTdGF0ZW1lbnQgJiYgbm9kZS5ib2R5Lmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgIHZhciBpbm5lckNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVhZGluZy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmxlYWRpbmdbaV07XHJcblx0ICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YS5lbmQub2Zmc2V0ID49IGVudHJ5LnN0YXJ0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbm5lckNvbW1lbnRzLnVuc2hpZnQoZW50cnkuY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmxlYWRpbmcuc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFpbGluZy5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGlubmVyQ29tbWVudHMubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgIG5vZGUuaW5uZXJDb21tZW50cyA9IGlubmVyQ29tbWVudHM7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUuZmluZFRyYWlsaW5nQ29tbWVudHMgPSBmdW5jdGlvbiAobWV0YWRhdGEpIHtcclxuXHQgICAgICAgIHZhciB0cmFpbGluZ0NvbW1lbnRzID0gW107XHJcblx0ICAgICAgICBpZiAodGhpcy50cmFpbGluZy5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJhaWxpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGVudHJ5XzEgPSB0aGlzLnRyYWlsaW5nW2ldO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoZW50cnlfMS5zdGFydCA+PSBtZXRhZGF0YS5lbmQub2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLnVuc2hpZnQoZW50cnlfMS5jb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLnRyYWlsaW5nLmxlbmd0aCA9IDA7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRyYWlsaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XHJcblx0ICAgICAgICBpZiAoZW50cnkgJiYgZW50cnkubm9kZS50cmFpbGluZ0NvbW1lbnRzKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGZpcnN0Q29tbWVudCA9IGVudHJ5Lm5vZGUudHJhaWxpbmdDb21tZW50c1swXTtcclxuXHQgICAgICAgICAgICBpZiAoZmlyc3RDb21tZW50ICYmIGZpcnN0Q29tbWVudC5yYW5nZVswXSA+PSBtZXRhZGF0YS5lbmQub2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMgPSBlbnRyeS5ub2RlLnRyYWlsaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSBlbnRyeS5ub2RlLnRyYWlsaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRyYWlsaW5nQ29tbWVudHM7XHJcblx0ICAgIH07XHJcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS5maW5kTGVhZGluZ0NvbW1lbnRzID0gZnVuY3Rpb24gKG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICB2YXIgbGVhZGluZ0NvbW1lbnRzID0gW107XHJcblx0ICAgICAgICB2YXIgdGFyZ2V0O1xyXG5cdCAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcclxuXHQgICAgICAgICAgICBpZiAoZW50cnkgJiYgZW50cnkuc3RhcnQgPj0gbWV0YWRhdGEuc3RhcnQub2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRhcmdldCA9IGVudHJ5Lm5vZGU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNvdW50ID0gdGFyZ2V0LmxlYWRpbmdDb21tZW50cyA/IHRhcmdldC5sZWFkaW5nQ29tbWVudHMubGVuZ3RoIDogMDtcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gY291bnQgLSAxOyBpID49IDA7IC0taSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHRhcmdldC5sZWFkaW5nQ29tbWVudHNbaV07XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjb21tZW50LnJhbmdlWzFdIDw9IG1ldGFkYXRhLnN0YXJ0Lm9mZnNldCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzLnVuc2hpZnQoY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0YXJnZXQubGVhZGluZ0NvbW1lbnRzLnNwbGljZShpLCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAodGFyZ2V0LmxlYWRpbmdDb21tZW50cyAmJiB0YXJnZXQubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0LmxlYWRpbmdDb21tZW50cztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGxlYWRpbmdDb21tZW50cztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmxlYWRpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuXHQgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmxlYWRpbmdbaV07XHJcblx0ICAgICAgICAgICAgaWYgKGVudHJ5LnN0YXJ0IDw9IG1ldGFkYXRhLnN0YXJ0Lm9mZnNldCkge1xyXG5cdCAgICAgICAgICAgICAgICBsZWFkaW5nQ29tbWVudHMudW5zaGlmdChlbnRyeS5jb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5sZWFkaW5nLnNwbGljZShpLCAxKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gbGVhZGluZ0NvbW1lbnRzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUudmlzaXROb2RlID0gZnVuY3Rpb24gKG5vZGUsIG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICBpZiAobm9kZS50eXBlID09PSBzeW50YXhfMS5TeW50YXguUHJvZ3JhbSAmJiBub2RlLmJvZHkubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuaW5zZXJ0SW5uZXJDb21tZW50cyhub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB2YXIgdHJhaWxpbmdDb21tZW50cyA9IHRoaXMuZmluZFRyYWlsaW5nQ29tbWVudHMobWV0YWRhdGEpO1xyXG5cdCAgICAgICAgdmFyIGxlYWRpbmdDb21tZW50cyA9IHRoaXMuZmluZExlYWRpbmdDb21tZW50cyhtZXRhZGF0YSk7XHJcblx0ICAgICAgICBpZiAobGVhZGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IGxlYWRpbmdDb21tZW50cztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0cmFpbGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICBub2RlLnRyYWlsaW5nQ29tbWVudHMgPSB0cmFpbGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcclxuXHQgICAgICAgICAgICBub2RlOiBub2RlLFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBtZXRhZGF0YS5zdGFydC5vZmZzZXRcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICB9O1xyXG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKG5vZGUsIG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICB2YXIgdHlwZSA9IChub2RlLnR5cGVbMF0gPT09ICdMJykgPyAnTGluZScgOiAnQmxvY2snO1xyXG5cdCAgICAgICAgdmFyIGNvbW1lbnQgPSB7XHJcblx0ICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuXHQgICAgICAgICAgICB2YWx1ZTogbm9kZS52YWx1ZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIGlmIChub2RlLnJhbmdlKSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudC5yYW5nZSA9IG5vZGUucmFuZ2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAobm9kZS5sb2MpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50LmxvYyA9IG5vZGUubG9jO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuYXR0YWNoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG5cdCAgICAgICAgICAgICAgICBjb21tZW50OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5vZGUudmFsdWUsXHJcblx0ICAgICAgICAgICAgICAgICAgICByYW5nZTogW21ldGFkYXRhLnN0YXJ0Lm9mZnNldCwgbWV0YWRhdGEuZW5kLm9mZnNldF1cclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IG1ldGFkYXRhLnN0YXJ0Lm9mZnNldFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgaWYgKG5vZGUubG9jKSB7XHJcblx0ICAgICAgICAgICAgICAgIGVudHJ5LmNvbW1lbnQubG9jID0gbm9kZS5sb2M7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIG5vZGUudHlwZSA9IHR5cGU7XHJcblx0ICAgICAgICAgICAgdGhpcy5sZWFkaW5nLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgICAgIHRoaXMudHJhaWxpbmcucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uIChub2RlLCBtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0xpbmVDb21tZW50Jykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmlzaXRDb21tZW50KG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0Jsb2NrQ29tbWVudCcpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnZpc2l0Q29tbWVudChub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLmF0dGFjaCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmlzaXROb2RlKG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIENvbW1lbnRIYW5kbGVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Db21tZW50SGFuZGxlciA9IENvbW1lbnRIYW5kbGVyO1xyXG5cblxuLyoqKi8gfSxcbi8qIDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHRleHBvcnRzLlN5bnRheCA9IHtcclxuXHQgICAgQXNzaWdubWVudEV4cHJlc3Npb246ICdBc3NpZ25tZW50RXhwcmVzc2lvbicsXHJcblx0ICAgIEFzc2lnbm1lbnRQYXR0ZXJuOiAnQXNzaWdubWVudFBhdHRlcm4nLFxyXG5cdCAgICBBcnJheUV4cHJlc3Npb246ICdBcnJheUV4cHJlc3Npb24nLFxyXG5cdCAgICBBcnJheVBhdHRlcm46ICdBcnJheVBhdHRlcm4nLFxyXG5cdCAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJyxcclxuXHQgICAgQXdhaXRFeHByZXNzaW9uOiAnQXdhaXRFeHByZXNzaW9uJyxcclxuXHQgICAgQmxvY2tTdGF0ZW1lbnQ6ICdCbG9ja1N0YXRlbWVudCcsXHJcblx0ICAgIEJpbmFyeUV4cHJlc3Npb246ICdCaW5hcnlFeHByZXNzaW9uJyxcclxuXHQgICAgQnJlYWtTdGF0ZW1lbnQ6ICdCcmVha1N0YXRlbWVudCcsXHJcblx0ICAgIENhbGxFeHByZXNzaW9uOiAnQ2FsbEV4cHJlc3Npb24nLFxyXG5cdCAgICBDYXRjaENsYXVzZTogJ0NhdGNoQ2xhdXNlJyxcclxuXHQgICAgQ2xhc3NCb2R5OiAnQ2xhc3NCb2R5JyxcclxuXHQgICAgQ2xhc3NEZWNsYXJhdGlvbjogJ0NsYXNzRGVjbGFyYXRpb24nLFxyXG5cdCAgICBDbGFzc0V4cHJlc3Npb246ICdDbGFzc0V4cHJlc3Npb24nLFxyXG5cdCAgICBDb25kaXRpb25hbEV4cHJlc3Npb246ICdDb25kaXRpb25hbEV4cHJlc3Npb24nLFxyXG5cdCAgICBDb250aW51ZVN0YXRlbWVudDogJ0NvbnRpbnVlU3RhdGVtZW50JyxcclxuXHQgICAgRG9XaGlsZVN0YXRlbWVudDogJ0RvV2hpbGVTdGF0ZW1lbnQnLFxyXG5cdCAgICBEZWJ1Z2dlclN0YXRlbWVudDogJ0RlYnVnZ2VyU3RhdGVtZW50JyxcclxuXHQgICAgRW1wdHlTdGF0ZW1lbnQ6ICdFbXB0eVN0YXRlbWVudCcsXHJcblx0ICAgIEV4cG9ydEFsbERlY2xhcmF0aW9uOiAnRXhwb3J0QWxsRGVjbGFyYXRpb24nLFxyXG5cdCAgICBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb246ICdFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24nLFxyXG5cdCAgICBFeHBvcnROYW1lZERlY2xhcmF0aW9uOiAnRXhwb3J0TmFtZWREZWNsYXJhdGlvbicsXHJcblx0ICAgIEV4cG9ydFNwZWNpZmllcjogJ0V4cG9ydFNwZWNpZmllcicsXHJcblx0ICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcclxuXHQgICAgRm9yU3RhdGVtZW50OiAnRm9yU3RhdGVtZW50JyxcclxuXHQgICAgRm9yT2ZTdGF0ZW1lbnQ6ICdGb3JPZlN0YXRlbWVudCcsXHJcblx0ICAgIEZvckluU3RhdGVtZW50OiAnRm9ySW5TdGF0ZW1lbnQnLFxyXG5cdCAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiAnRnVuY3Rpb25EZWNsYXJhdGlvbicsXHJcblx0ICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogJ0Z1bmN0aW9uRXhwcmVzc2lvbicsXHJcblx0ICAgIElkZW50aWZpZXI6ICdJZGVudGlmaWVyJyxcclxuXHQgICAgSWZTdGF0ZW1lbnQ6ICdJZlN0YXRlbWVudCcsXHJcblx0ICAgIEltcG9ydERlY2xhcmF0aW9uOiAnSW1wb3J0RGVjbGFyYXRpb24nLFxyXG5cdCAgICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyOiAnSW1wb3J0RGVmYXVsdFNwZWNpZmllcicsXHJcblx0ICAgIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjogJ0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllcicsXHJcblx0ICAgIEltcG9ydFNwZWNpZmllcjogJ0ltcG9ydFNwZWNpZmllcicsXHJcblx0ICAgIExpdGVyYWw6ICdMaXRlcmFsJyxcclxuXHQgICAgTGFiZWxlZFN0YXRlbWVudDogJ0xhYmVsZWRTdGF0ZW1lbnQnLFxyXG5cdCAgICBMb2dpY2FsRXhwcmVzc2lvbjogJ0xvZ2ljYWxFeHByZXNzaW9uJyxcclxuXHQgICAgTWVtYmVyRXhwcmVzc2lvbjogJ01lbWJlckV4cHJlc3Npb24nLFxyXG5cdCAgICBNZXRhUHJvcGVydHk6ICdNZXRhUHJvcGVydHknLFxyXG5cdCAgICBNZXRob2REZWZpbml0aW9uOiAnTWV0aG9kRGVmaW5pdGlvbicsXHJcblx0ICAgIE5ld0V4cHJlc3Npb246ICdOZXdFeHByZXNzaW9uJyxcclxuXHQgICAgT2JqZWN0RXhwcmVzc2lvbjogJ09iamVjdEV4cHJlc3Npb24nLFxyXG5cdCAgICBPYmplY3RQYXR0ZXJuOiAnT2JqZWN0UGF0dGVybicsXHJcblx0ICAgIFByb2dyYW06ICdQcm9ncmFtJyxcclxuXHQgICAgUHJvcGVydHk6ICdQcm9wZXJ0eScsXHJcblx0ICAgIFJlc3RFbGVtZW50OiAnUmVzdEVsZW1lbnQnLFxyXG5cdCAgICBSZXR1cm5TdGF0ZW1lbnQ6ICdSZXR1cm5TdGF0ZW1lbnQnLFxyXG5cdCAgICBTZXF1ZW5jZUV4cHJlc3Npb246ICdTZXF1ZW5jZUV4cHJlc3Npb24nLFxyXG5cdCAgICBTcHJlYWRFbGVtZW50OiAnU3ByZWFkRWxlbWVudCcsXHJcblx0ICAgIFN1cGVyOiAnU3VwZXInLFxyXG5cdCAgICBTd2l0Y2hDYXNlOiAnU3dpdGNoQ2FzZScsXHJcblx0ICAgIFN3aXRjaFN0YXRlbWVudDogJ1N3aXRjaFN0YXRlbWVudCcsXHJcblx0ICAgIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjogJ1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbicsXHJcblx0ICAgIFRlbXBsYXRlRWxlbWVudDogJ1RlbXBsYXRlRWxlbWVudCcsXHJcblx0ICAgIFRlbXBsYXRlTGl0ZXJhbDogJ1RlbXBsYXRlTGl0ZXJhbCcsXHJcblx0ICAgIFRoaXNFeHByZXNzaW9uOiAnVGhpc0V4cHJlc3Npb24nLFxyXG5cdCAgICBUaHJvd1N0YXRlbWVudDogJ1Rocm93U3RhdGVtZW50JyxcclxuXHQgICAgVHJ5U3RhdGVtZW50OiAnVHJ5U3RhdGVtZW50JyxcclxuXHQgICAgVW5hcnlFeHByZXNzaW9uOiAnVW5hcnlFeHByZXNzaW9uJyxcclxuXHQgICAgVXBkYXRlRXhwcmVzc2lvbjogJ1VwZGF0ZUV4cHJlc3Npb24nLFxyXG5cdCAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiAnVmFyaWFibGVEZWNsYXJhdGlvbicsXHJcblx0ICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogJ1ZhcmlhYmxlRGVjbGFyYXRvcicsXHJcblx0ICAgIFdoaWxlU3RhdGVtZW50OiAnV2hpbGVTdGF0ZW1lbnQnLFxyXG5cdCAgICBXaXRoU3RhdGVtZW50OiAnV2l0aFN0YXRlbWVudCcsXHJcblx0ICAgIFlpZWxkRXhwcmVzc2lvbjogJ1lpZWxkRXhwcmVzc2lvbidcclxuXHR9O1xyXG5cblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHR2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcblx0ICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcblx0ICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcblx0ICAgIH07XHJcblx0fSkoKTtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIGNoYXJhY3Rlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHR2YXIgSlNYTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblx0dmFyIGpzeF9zeW50YXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblx0dmFyIE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG5cdHZhciBwYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcblx0dmFyIHRva2VuXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxuXHR2YXIgeGh0bWxfZW50aXRpZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG5cdHRva2VuXzEuVG9rZW5OYW1lWzEwMCAvKiBJZGVudGlmaWVyICovXSA9ICdKU1hJZGVudGlmaWVyJztcclxuXHR0b2tlbl8xLlRva2VuTmFtZVsxMDEgLyogVGV4dCAqL10gPSAnSlNYVGV4dCc7XHJcblx0Ly8gRnVsbHkgcXVhbGlmaWVkIGVsZW1lbnQgbmFtZSwgZS5nLiA8c3ZnOnBhdGg+IHJldHVybnMgXCJzdmc6cGF0aFwiXHJcblx0ZnVuY3Rpb24gZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUoZWxlbWVudE5hbWUpIHtcclxuXHQgICAgdmFyIHF1YWxpZmllZE5hbWU7XHJcblx0ICAgIHN3aXRjaCAoZWxlbWVudE5hbWUudHlwZSkge1xyXG5cdCAgICAgICAgY2FzZSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWElkZW50aWZpZXI6XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0gZWxlbWVudE5hbWU7XHJcblx0ICAgICAgICAgICAgcXVhbGlmaWVkTmFtZSA9IGlkLm5hbWU7XHJcblx0ICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICBjYXNlIGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYTmFtZXNwYWNlZE5hbWU6XHJcblx0ICAgICAgICAgICAgdmFyIG5zID0gZWxlbWVudE5hbWU7XHJcblx0ICAgICAgICAgICAgcXVhbGlmaWVkTmFtZSA9IGdldFF1YWxpZmllZEVsZW1lbnROYW1lKG5zLm5hbWVzcGFjZSkgKyAnOicgK1xyXG5cdCAgICAgICAgICAgICAgICBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShucy5uYW1lKTtcclxuXHQgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIGNhc2UganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hNZW1iZXJFeHByZXNzaW9uOlxyXG5cdCAgICAgICAgICAgIHZhciBleHByID0gZWxlbWVudE5hbWU7XHJcblx0ICAgICAgICAgICAgcXVhbGlmaWVkTmFtZSA9IGdldFF1YWxpZmllZEVsZW1lbnROYW1lKGV4cHIub2JqZWN0KSArICcuJyArXHJcblx0ICAgICAgICAgICAgICAgIGdldFF1YWxpZmllZEVsZW1lbnROYW1lKGV4cHIucHJvcGVydHkpO1xyXG5cdCAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIHF1YWxpZmllZE5hbWU7XHJcblx0fVxyXG5cdHZhciBKU1hQYXJzZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG5cdCAgICBfX2V4dGVuZHMoSlNYUGFyc2VyLCBfc3VwZXIpO1xyXG5cdCAgICBmdW5jdGlvbiBKU1hQYXJzZXIoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcclxuXHQgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkgfHwgdGhpcztcclxuXHQgICAgfVxyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5tYXRjaCgnPCcpID8gdGhpcy5wYXJzZUpTWFJvb3QoKSA6IF9zdXBlci5wcm90b3R5cGUucGFyc2VQcmltYXJ5RXhwcmVzc2lvbi5jYWxsKHRoaXMpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnN0YXJ0SlNYID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgLy8gVW53aW5kIHRoZSBzY2FubmVyIGJlZm9yZSB0aGUgbG9va2FoZWFkIHRva2VuLlxyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLmluZGV4ID0gdGhpcy5zdGFydE1hcmtlci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyID0gdGhpcy5zdGFydE1hcmtlci5saW5lO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLmxpbmVTdGFydCA9IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXggLSB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtbjtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5maW5pc2hKU1ggPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAvLyBQcmltZSB0aGUgbmV4dCBsb29rYWhlYWQuXHJcblx0ICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnJlZW50ZXJKU1ggPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0SlNYKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnfScpO1xyXG5cdCAgICAgICAgLy8gUG9wIHRoZSBjbG9zaW5nICd9JyBhZGRlZCBmcm9tIHRoZSBsb29rYWhlYWQuXHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9rZW5zKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucG9wKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuY3JlYXRlSlNYTm9kZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuY29sbGVjdENvbW1lbnRzKCk7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiB0aGlzLnNjYW5uZXIuaW5kZXgsXHJcblx0ICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmNyZWF0ZUpTWENoaWxkTm9kZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IHRoaXMuc2Nhbm5lci5pbmRleCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBjb2x1bW46IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnRcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuc2NhblhIVE1MRW50aXR5ID0gZnVuY3Rpb24gKHF1b3RlKSB7XHJcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gJyYnO1xyXG5cdCAgICAgICAgdmFyIHZhbGlkID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciB0ZXJtaW5hdGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgbnVtZXJpYyA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGhleCA9IGZhbHNlO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLnNjYW5uZXIuZW9mKCkgJiYgdmFsaWQgJiYgIXRlcm1pbmF0ZWQpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleF07XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGVybWluYXRlZCA9IChjaCA9PT0gJzsnKTtcclxuXHQgICAgICAgICAgICByZXN1bHQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgaWYgKCF0ZXJtaW5hdGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAocmVzdWx0Lmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGUuZy4gJyYjMTIzOydcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBudW1lcmljID0gKGNoID09PSAnIycpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW1lcmljKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGUuZy4gJyYjeDQxOydcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gKGNoID09PSAneCcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IGhleCB8fCBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyaWMgPSBudW1lcmljICYmICFoZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHZhbGlkICYmICEobnVtZXJpYyAmJiAhY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHZhbGlkICYmICEoaGV4ICYmICFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNIZXhEaWdpdChjaC5jaGFyQ29kZUF0KDApKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodmFsaWQgJiYgdGVybWluYXRlZCAmJiByZXN1bHQubGVuZ3RoID4gMikge1xyXG5cdCAgICAgICAgICAgIC8vIGUuZy4gJyYjeDQxOycgYmVjb21lcyBqdXN0ICcjeDQxJ1xyXG5cdCAgICAgICAgICAgIHZhciBzdHIgPSByZXN1bHQuc3Vic3RyKDEsIHJlc3VsdC5sZW5ndGggLSAyKTtcclxuXHQgICAgICAgICAgICBpZiAobnVtZXJpYyAmJiBzdHIubGVuZ3RoID4gMSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDEwKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGhleCAmJiBzdHIubGVuZ3RoID4gMikge1xyXG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KCcwJyArIHN0ci5zdWJzdHIoMSksIDE2KSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKCFudW1lcmljICYmICFoZXggJiYgeGh0bWxfZW50aXRpZXNfMS5YSFRNTEVudGl0aWVzW3N0cl0pIHtcclxuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0geGh0bWxfZW50aXRpZXNfMS5YSFRNTEVudGl0aWVzW3N0cl07XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gU2NhbiB0aGUgbmV4dCBKU1ggdG9rZW4uIFRoaXMgcmVwbGFjZXMgU2Nhbm5lciNsZXggd2hlbiBpbiBKU1ggbW9kZS5cclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5sZXhKU1ggPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY3AgPSB0aGlzLnNjYW5uZXIuc291cmNlLmNoYXJDb2RlQXQodGhpcy5zY2FubmVyLmluZGV4KTtcclxuXHQgICAgICAgIC8vIDwgPiAvIDogPSB7IH1cclxuXHQgICAgICAgIGlmIChjcCA9PT0gNjAgfHwgY3AgPT09IDYyIHx8IGNwID09PSA0NyB8fCBjcCA9PT0gNTggfHwgY3AgPT09IDYxIHx8IGNwID09PSAxMjMgfHwgY3AgPT09IDEyNSkge1xyXG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IDcgLyogUHVuY3R1YXRvciAqLyxcclxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLnNjYW5uZXIubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5zY2FubmVyLmluZGV4IC0gMSxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB0aGlzLnNjYW5uZXIuaW5kZXhcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gXCIgJ1xyXG5cdCAgICAgICAgaWYgKGNwID09PSAzNCB8fCBjcCA9PT0gMzkpIHtcclxuXHQgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdmFyIHF1b3RlID0gdGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgdmFyIHN0ciA9ICcnO1xyXG5cdCAgICAgICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IHF1b3RlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJyYnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdGhpcy5zY2FuWEhUTUxFbnRpdHkocXVvdGUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IDggLyogU3RyaW5nTGl0ZXJhbCAqLyxcclxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHN0cixcclxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5zY2FubmVyLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuc2Nhbm5lci5pbmRleFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyAuLi4gb3IgLlxyXG5cdCAgICAgICAgaWYgKGNwID09PSA0Nikge1xyXG5cdCAgICAgICAgICAgIHZhciBuMSA9IHRoaXMuc2Nhbm5lci5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLnNjYW5uZXIuaW5kZXggKyAxKTtcclxuXHQgICAgICAgICAgICB2YXIgbjIgPSB0aGlzLnNjYW5uZXIuc291cmNlLmNoYXJDb2RlQXQodGhpcy5zY2FubmVyLmluZGV4ICsgMik7XHJcblx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gKG4xID09PSA0NiAmJiBuMiA9PT0gNDYpID8gJy4uLicgOiAnLic7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5pbmRleCArPSB2YWx1ZS5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogNyAvKiBQdW5jdHVhdG9yICovLFxyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB0aGlzLnNjYW5uZXIuaW5kZXhcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gYFxyXG5cdCAgICAgICAgaWYgKGNwID09PSA5Nikge1xyXG5cdCAgICAgICAgICAgIC8vIE9ubHkgcGxhY2Vob2xkZXIsIHNpbmNlIGl0IHdpbGwgYmUgcmVzY2FubmVkIGFzIGEgcmVhbCBhc3NpZ25tZW50IGV4cHJlc3Npb24uXHJcblx0ICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogMTAgLyogVGVtcGxhdGUgKi8sXHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiAnJyxcclxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5zY2FubmVyLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc2Nhbm5lci5pbmRleCxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB0aGlzLnNjYW5uZXIuaW5kZXhcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gSWRlbnRpZmVyIGNhbiBub3QgY29udGFpbiBiYWNrc2xhc2ggKGNoYXIgY29kZSA5MikuXHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KGNwKSAmJiAoY3AgIT09IDkyKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNjYW5uZXIuc291cmNlLmNoYXJDb2RlQXQodGhpcy5zY2FubmVyLmluZGV4KTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJQYXJ0KGNoKSAmJiAoY2ggIT09IDkyKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDQ1KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBIeXBoZW4gKGNoYXIgY29kZSA0NSkgY2FuIGJlIHBhcnQgb2YgYW4gaWRlbnRpZmllci5cclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5zY2FubmVyLnNvdXJjZS5zbGljZShzdGFydCwgdGhpcy5zY2FubmVyLmluZGV4KTtcclxuXHQgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiAxMDAgLyogSWRlbnRpZmllciAqLyxcclxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IGlkLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLnNjYW5uZXIubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLnNjYW5uZXIubGV4KCk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUubmV4dEpTWFRva2VuID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5jb2xsZWN0Q29tbWVudHMoKTtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubGV4SlNYKCk7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9rZW5zKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0aGlzLmNvbnZlcnRUb2tlbih0b2tlbikpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRva2VuO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLm5leHRKU1hUZXh0ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIHRleHQgPSAnJztcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJ3snIHx8IGNoID09PSAnPCcpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHRleHQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgdGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXhdID09PSAnXFxuJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLmxpbmVTdGFydCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB7XHJcblx0ICAgICAgICAgICAgdHlwZTogMTAxIC8qIFRleHQgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHRleHQsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLnNjYW5uZXIubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuc2Nhbm5lci5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIGlmICgodGV4dC5sZW5ndGggPiAwKSAmJiB0aGlzLmNvbmZpZy50b2tlbnMpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHRoaXMuY29udmVydFRva2VuKHRva2VuKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdG9rZW47XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGVla0pTWFRva2VuID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zY2FubmVyLnNhdmVTdGF0ZSgpO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLnNjYW5Db21tZW50cygpO1xyXG5cdCAgICAgICAgdmFyIG5leHQgPSB0aGlzLmxleEpTWCgpO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLnJlc3RvcmVTdGF0ZShzdGF0ZSk7XHJcblx0ICAgICAgICByZXR1cm4gbmV4dDtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gRXhwZWN0IHRoZSBuZXh0IEpTWCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXHJcblx0ICAgIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmV4cGVjdEpTWCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0SlNYVG9rZW4oKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSA3IC8qIFB1bmN0dWF0b3IgKi8gfHwgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IEpTWCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5tYXRjaEpTWCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgICAgICAgdmFyIG5leHQgPSB0aGlzLnBlZWtKU1hUb2tlbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIG5leHQudHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIG5leHQudmFsdWUgPT09IHZhbHVlO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRKU1hUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IDEwMCAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hJZGVudGlmaWVyKHRva2VuLnZhbHVlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hFbGVtZW50TmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZWxlbWVudE5hbWUgPSB0aGlzLnBhcnNlSlNYSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hKU1goJzonKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBlbGVtZW50TmFtZTtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnOicpO1xyXG5cdCAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0aGlzLnBhcnNlSlNYSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIGVsZW1lbnROYW1lID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hOYW1lc3BhY2VkTmFtZShuYW1lc3BhY2UsIG5hbWVfMSkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEpTWCgnLicpKSB7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKHRoaXMubWF0Y2hKU1goJy4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0gZWxlbWVudE5hbWU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCcuJyk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2VKU1hJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnROYW1lID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hNZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHkpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZWxlbWVudE5hbWU7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lO1xyXG5cdCAgICAgICAgdmFyIGlkZW50aWZpZXIgPSB0aGlzLnBhcnNlSlNYSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hKU1goJzonKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBpZGVudGlmaWVyO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc6Jyk7XHJcblx0ICAgICAgICAgICAgdmFyIG5hbWVfMiA9IHRoaXMucGFyc2VKU1hJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYTmFtZXNwYWNlZE5hbWUobmFtZXNwYWNlLCBuYW1lXzIpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSBpZGVudGlmaWVyO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWU7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hTdHJpbmdMaXRlcmFsQXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dEpTWFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gOCAvKiBTdHJpbmdMaXRlcmFsICovKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5MaXRlcmFsKHRva2VuLnZhbHVlLCByYXcpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEV4cHJlc3Npb25BdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJ3snKTtcclxuXHQgICAgICAgIHRoaXMuZmluaXNoSlNYKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKCdKU1ggYXR0cmlidXRlcyBtdXN0IG9ubHkgYmUgYXNzaWduZWQgYSBub24tZW1wdHkgZXhwcmVzc2lvbicpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHRoaXMucmVlbnRlckpTWCgpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYRXhwcmVzc2lvbkNvbnRhaW5lcihleHByZXNzaW9uKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hBdHRyaWJ1dGVWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLm1hdGNoSlNYKCd7JykgPyB0aGlzLnBhcnNlSlNYRXhwcmVzc2lvbkF0dHJpYnV0ZSgpIDpcclxuXHQgICAgICAgICAgICB0aGlzLm1hdGNoSlNYKCc8JykgPyB0aGlzLnBhcnNlSlNYRWxlbWVudCgpIDogdGhpcy5wYXJzZUpTWFN0cmluZ0xpdGVyYWxBdHRyaWJ1dGUoKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWE5hbWVWYWx1ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VKU1hBdHRyaWJ1dGVOYW1lKCk7XHJcblx0ICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hKU1goJz0nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc9Jyk7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlSlNYQXR0cmlidXRlVmFsdWUoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYU3ByZWFkQXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCd7Jyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnLi4uJyk7XHJcblx0ICAgICAgICB0aGlzLmZpbmlzaEpTWCgpO1xyXG5cdCAgICAgICAgdmFyIGFyZ3VtZW50ID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB0aGlzLnJlZW50ZXJKU1goKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWFNwcmVhZEF0dHJpYnV0ZShhcmd1bWVudCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gW107XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2hKU1goJy8nKSAmJiAhdGhpcy5tYXRjaEpTWCgnPicpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMubWF0Y2hKU1goJ3snKSA/IHRoaXMucGFyc2VKU1hTcHJlYWRBdHRyaWJ1dGUoKSA6XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMucGFyc2VKU1hOYW1lVmFsdWVBdHRyaWJ1dGUoKTtcclxuXHQgICAgICAgICAgICBhdHRyaWJ1dGVzLnB1c2goYXR0cmlidXRlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYT3BlbmluZ0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJzwnKTtcclxuXHQgICAgICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZUpTWEVsZW1lbnROYW1lKCk7XHJcblx0ICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMucGFyc2VKU1hBdHRyaWJ1dGVzKCk7XHJcblx0ICAgICAgICB2YXIgc2VsZkNsb3NpbmcgPSB0aGlzLm1hdGNoSlNYKCcvJyk7XHJcblx0ICAgICAgICBpZiAoc2VsZkNsb3NpbmcpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnLycpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJz4nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWE9wZW5pbmdFbGVtZW50KG5hbWUsIHNlbGZDbG9zaW5nLCBhdHRyaWJ1dGVzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hCb3VuZGFyeUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJzwnKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoSlNYKCcvJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnLycpO1xyXG5cdCAgICAgICAgICAgIHZhciBuYW1lXzMgPSB0aGlzLnBhcnNlSlNYRWxlbWVudE5hbWUoKTtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPicpO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWENsb3NpbmdFbGVtZW50KG5hbWVfMykpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlSlNYRWxlbWVudE5hbWUoKTtcclxuXHQgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5wYXJzZUpTWEF0dHJpYnV0ZXMoKTtcclxuXHQgICAgICAgIHZhciBzZWxmQ2xvc2luZyA9IHRoaXMubWF0Y2hKU1goJy8nKTtcclxuXHQgICAgICAgIGlmIChzZWxmQ2xvc2luZykge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCcvJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPicpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYT3BlbmluZ0VsZW1lbnQobmFtZSwgc2VsZkNsb3NpbmcsIGF0dHJpYnV0ZXMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEVtcHR5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hDaGlsZE5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuY29sbGVjdENvbW1lbnRzKCk7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hFbXB0eUV4cHJlc3Npb24oKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hFeHByZXNzaW9uQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCd7Jyk7XHJcblx0ICAgICAgICB2YXIgZXhwcmVzc2lvbjtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoSlNYKCd9JykpIHtcclxuXHQgICAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5wYXJzZUpTWEVtcHR5RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCd9Jyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmZpbmlzaEpTWCgpO1xyXG5cdCAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICB0aGlzLnJlZW50ZXJKU1goKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWEV4cHJlc3Npb25Db250YWluZXIoZXhwcmVzc2lvbikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWENoaWxkTm9kZSgpO1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dEpTWFRleHQoKTtcclxuXHQgICAgICAgICAgICBpZiAodG9rZW4uc3RhcnQgPCB0b2tlbi5lbmQpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWFRleHQodG9rZW4udmFsdWUsIHJhdykpO1xyXG5cdCAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4XSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLnBhcnNlSlNYRXhwcmVzc2lvbkNvbnRhaW5lcigpO1xyXG5cdCAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNvbnRhaW5lcik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VDb21wbGV4SlNYRWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xyXG5cdCAgICAgICAgdmFyIHN0YWNrID0gW107XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGVsLmNoaWxkcmVuID0gZWwuY2hpbGRyZW4uY29uY2F0KHRoaXMucGFyc2VKU1hDaGlsZHJlbigpKTtcclxuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYQ2hpbGROb2RlKCk7XHJcblx0ICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlSlNYQm91bmRhcnlFbGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hPcGVuaW5nRWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgb3BlbmluZyA9IGVsZW1lbnQ7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChvcGVuaW5nLnNlbGZDbG9zaW5nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWEVsZW1lbnQob3BlbmluZywgW10sIG51bGwpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVsLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChlbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbCA9IHsgbm9kZTogbm9kZSwgb3BlbmluZzogb3BlbmluZywgY2xvc2luZzogbnVsbCwgY2hpbGRyZW46IFtdIH07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hDbG9zaW5nRWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICBlbC5jbG9zaW5nID0gZWxlbWVudDtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG9wZW5fMSA9IGdldFF1YWxpZmllZEVsZW1lbnROYW1lKGVsLm9wZW5pbmcubmFtZSk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjbG9zZV8xID0gZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUoZWwuY2xvc2luZy5uYW1lKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKG9wZW5fMSAhPT0gY2xvc2VfMSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKCdFeHBlY3RlZCBjb3JyZXNwb25kaW5nIEpTWCBjbG9zaW5nIHRhZyBmb3IgJTAnLCBvcGVuXzEpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmZpbmFsaXplKGVsLm5vZGUsIG5ldyBKU1hOb2RlLkpTWEVsZW1lbnQoZWwub3BlbmluZywgZWwuY2hpbGRyZW4sIGVsLmNsb3NpbmcpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVsID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZWw7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHZhciBvcGVuaW5nID0gdGhpcy5wYXJzZUpTWE9wZW5pbmdFbGVtZW50KCk7XHJcblx0ICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcclxuXHQgICAgICAgIHZhciBjbG9zaW5nID0gbnVsbDtcclxuXHQgICAgICAgIGlmICghb3BlbmluZy5zZWxmQ2xvc2luZykge1xyXG5cdCAgICAgICAgICAgIHZhciBlbCA9IHRoaXMucGFyc2VDb21wbGV4SlNYRWxlbWVudCh7IG5vZGU6IG5vZGUsIG9wZW5pbmc6IG9wZW5pbmcsIGNsb3Npbmc6IGNsb3NpbmcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcclxuXHQgICAgICAgICAgICBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xyXG5cdCAgICAgICAgICAgIGNsb3NpbmcgPSBlbC5jbG9zaW5nO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYRWxlbWVudChvcGVuaW5nLCBjaGlsZHJlbiwgY2xvc2luZykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYUm9vdCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIC8vIFBvcCB0aGUgb3BlbmluZyAnPCcgYWRkZWQgZnJvbSB0aGUgbG9va2FoZWFkLlxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRva2Vucykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnBvcCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5zdGFydEpTWCgpO1xyXG5cdCAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlSlNYRWxlbWVudCgpO1xyXG5cdCAgICAgICAgdGhpcy5maW5pc2hKU1goKTtcclxuXHQgICAgICAgIHJldHVybiBlbGVtZW50O1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmlzU3RhcnRPZkV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5pc1N0YXJ0T2ZFeHByZXNzaW9uLmNhbGwodGhpcykgfHwgdGhpcy5tYXRjaCgnPCcpO1xyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gSlNYUGFyc2VyO1xyXG5cdH0ocGFyc2VyXzEuUGFyc2VyKSk7XHJcblx0ZXhwb3J0cy5KU1hQYXJzZXIgPSBKU1hQYXJzZXI7XHJcblxuXG4vKioqLyB9LFxuLyogNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdC8vIFNlZSBhbHNvIHRvb2xzL2dlbmVyYXRlLXVuaWNvZGUtcmVnZXguanMuXHJcblx0dmFyIFJlZ2V4ID0ge1xyXG5cdCAgICAvLyBVbmljb2RlIHY4LjAuMCBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDpcclxuXHQgICAgTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6IC9bXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjRcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBBRjlcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5Qi1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QURcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERDQwLVxcdURENzRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNEFcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMFxcdURFMTAtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNFxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MDRbXFx1REMwMy1cXHVEQzM3XFx1REM4My1cXHVEQ0FGXFx1RENEMC1cXHVEQ0U4XFx1REQwMy1cXHVERDI2XFx1REQ1MC1cXHVERDcyXFx1REQ3NlxcdUREODMtXFx1RERCMlxcdUREQzEtXFx1RERDNFxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTJCXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVERVxcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNEXFx1REY1MFxcdURGNUQtXFx1REY2MV18XFx1RDgwNVtcXHVEQzgwLVxcdURDQUZcXHVEQ0M0XFx1RENDNVxcdURDQzdcXHVERDgwLVxcdUREQUVcXHVEREQ4LVxcdUREREJcXHVERTAwLVxcdURFMkZcXHVERTQ0XFx1REU4MC1cXHVERUFBXFx1REYwMC1cXHVERjE5XXxcXHVEODA2W1xcdURDQTAtXFx1RENERlxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RVxcdURDODAtXFx1REQ0M118W1xcdUQ4MENcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFRDAtXFx1REVFRFxcdURGMDAtXFx1REYyRlxcdURGNDAtXFx1REY0M1xcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwXFx1REY5My1cXHVERjlGXXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OV18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNF18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdLyxcclxuXHQgICAgLy8gVW5pY29kZSB2OC4wLjAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDpcclxuXHQgICAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDogL1tcXHhBQVxceEI1XFx4QjdcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzAwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4My1cXHUwNDg3XFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MTAtXFx1MDYxQVxcdTA2MjAtXFx1MDY2OVxcdTA2NkUtXFx1MDZEM1xcdTA2RDUtXFx1MDZEQ1xcdTA2REYtXFx1MDZFOFxcdTA2RUEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwLVxcdTA3NEFcXHUwNzRELVxcdTA3QjFcXHUwN0MwLVxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODJEXFx1MDg0MC1cXHUwODVCXFx1MDhBMC1cXHUwOEI0XFx1MDhFMy1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZGXFx1MDk3MS1cXHUwOTgzXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCQy1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0VcXHUwOUQ3XFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTNcXHUwOUU2LVxcdTA5RjFcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJDLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFFNi1cXHUwQUVGXFx1MEFGOVxcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNDLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjcxXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEMFxcdTBCRDdcXHUwQkU2LVxcdTBCRUZcXHUwQzAwLVxcdTBDMDNcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNELVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNTgtXFx1MEM1QVxcdTBDNjAtXFx1MEM2M1xcdTBDNjYtXFx1MEM2RlxcdTBDODEtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkMtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1N1xcdTBENUYtXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERFNi1cXHUwREVGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUQtXFx1MTM1RlxcdTEzNjktXFx1MTM3MVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0QzXFx1MTdEN1xcdTE3RENcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOURBXFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFBQjAtXFx1MUFCRFxcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUJGM1xcdTFDMDAtXFx1MUMzN1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNGNlxcdTFDRjhcXHUxQ0Y5XFx1MUQwMC1cXHUxREY1XFx1MURGQy1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwMENcXHUyMDBEXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEN0YtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJERTAtXFx1MkRGRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyRlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOTktXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2N0YtXFx1QTZGMVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRFxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgyN1xcdUE4NDAtXFx1QTg3M1xcdUE4ODAtXFx1QThDNFxcdUE4RDAtXFx1QThEOVxcdUE4RTAtXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwMC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUZFXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QS1cXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY2XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURERkRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERUUwXFx1REYwMC1cXHVERjFGXFx1REYzMC1cXHVERjRBXFx1REY1MC1cXHVERjdBXFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQTAtXFx1RENBOVxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDAtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNlxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MDRbXFx1REMwMC1cXHVEQzQ2XFx1REM2Ni1cXHVEQzZGXFx1REM3Ri1cXHVEQ0JBXFx1RENEMC1cXHVEQ0U4XFx1RENGMC1cXHVEQ0Y5XFx1REQwMC1cXHVERDM0XFx1REQzNi1cXHVERDNGXFx1REQ1MC1cXHVERDczXFx1REQ3NlxcdUREODAtXFx1RERDNFxcdUREQ0EtXFx1RERDQ1xcdURERDAtXFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMzdcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERUVBXFx1REVGMC1cXHVERUY5XFx1REYwMC1cXHVERjAzXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0MtXFx1REY0NFxcdURGNDdcXHVERjQ4XFx1REY0Qi1cXHVERjREXFx1REY1MFxcdURGNTdcXHVERjVELVxcdURGNjNcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MDVbXFx1REM4MC1cXHVEQ0M1XFx1RENDN1xcdURDRDAtXFx1RENEOVxcdUREODAtXFx1RERCNVxcdUREQjgtXFx1RERDMFxcdURERDgtXFx1RERERFxcdURFMDAtXFx1REU0MFxcdURFNDRcXHVERTUwLVxcdURFNTlcXHVERTgwLVxcdURFQjdcXHVERUMwLVxcdURFQzlcXHVERjAwLVxcdURGMTlcXHVERjFELVxcdURGMkJcXHVERjMwLVxcdURGMzldfFxcdUQ4MDZbXFx1RENBMC1cXHVEQ0U5XFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REU2MC1cXHVERTY5XFx1REVEMC1cXHVERUVEXFx1REVGMC1cXHVERUY0XFx1REYwMC1cXHVERjM2XFx1REY0MC1cXHVERjQzXFx1REY1MC1cXHVERjU5XFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTAtXFx1REY3RVxcdURGOEYtXFx1REY5Rl18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTlcXHVEQzlEXFx1REM5RV18XFx1RDgzNFtcXHVERDY1LVxcdURENjlcXHVERDZELVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQlxcdURGQ0UtXFx1REZGRl18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRcXHVEQ0QwLVxcdURDRDZdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXXxcXHVEQjQwW1xcdUREMDAtXFx1RERFRl0vXHJcblx0fTtcclxuXHRleHBvcnRzLkNoYXJhY3RlciA9IHtcclxuXHQgICAgLyogdHNsaW50OmRpc2FibGU6bm8tYml0d2lzZSAqL1xyXG5cdCAgICBmcm9tQ29kZVBvaW50OiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPCAweDEwMDAwKSA/IFN0cmluZy5mcm9tQ2hhckNvZGUoY3ApIDpcclxuXHQgICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCArICgoY3AgLSAweDEwMDAwKSA+PiAxMCkpICtcclxuXHQgICAgICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgweERDMDAgKyAoKGNwIC0gMHgxMDAwMCkgJiAxMDIzKSk7XHJcblx0ICAgIH0sXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXdoaXRlLXNwYWNlXHJcblx0ICAgIGlzV2hpdGVTcGFjZTogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID09PSAweDIwKSB8fCAoY3AgPT09IDB4MDkpIHx8IChjcCA9PT0gMHgwQikgfHwgKGNwID09PSAweDBDKSB8fCAoY3AgPT09IDB4QTApIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4MTY4MCAmJiBbMHgxNjgwLCAweDIwMDAsIDB4MjAwMSwgMHgyMDAyLCAweDIwMDMsIDB4MjAwNCwgMHgyMDA1LCAweDIwMDYsIDB4MjAwNywgMHgyMDA4LCAweDIwMDksIDB4MjAwQSwgMHgyMDJGLCAweDIwNUYsIDB4MzAwMCwgMHhGRUZGXS5pbmRleE9mKGNwKSA+PSAwKTtcclxuXHQgICAgfSxcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGluZS10ZXJtaW5hdG9yc1xyXG5cdCAgICBpc0xpbmVUZXJtaW5hdG9yOiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPT09IDB4MEEpIHx8IChjcCA9PT0gMHgwRCkgfHwgKGNwID09PSAweDIwMjgpIHx8IChjcCA9PT0gMHgyMDI5KTtcclxuXHQgICAgfSxcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbmFtZXMtYW5kLWtleXdvcmRzXHJcblx0ICAgIGlzSWRlbnRpZmllclN0YXJ0OiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPT09IDB4MjQpIHx8IChjcCA9PT0gMHg1RikgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHg0MSAmJiBjcCA8PSAweDVBKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDYxICYmIGNwIDw9IDB4N0EpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID09PSAweDVDKSB8fFxyXG5cdCAgICAgICAgICAgICgoY3AgPj0gMHg4MCkgJiYgUmVnZXguTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQudGVzdChleHBvcnRzLkNoYXJhY3Rlci5mcm9tQ29kZVBvaW50KGNwKSkpO1xyXG5cdCAgICB9LFxyXG5cdCAgICBpc0lkZW50aWZpZXJQYXJ0OiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPT09IDB4MjQpIHx8IChjcCA9PT0gMHg1RikgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHg0MSAmJiBjcCA8PSAweDVBKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDYxICYmIGNwIDw9IDB4N0EpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4MzAgJiYgY3AgPD0gMHgzOSkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPT09IDB4NUMpIHx8XHJcblx0ICAgICAgICAgICAgKChjcCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJQYXJ0LnRlc3QoZXhwb3J0cy5DaGFyYWN0ZXIuZnJvbUNvZGVQb2ludChjcCkpKTtcclxuXHQgICAgfSxcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGl0ZXJhbHMtbnVtZXJpYy1saXRlcmFsc1xyXG5cdCAgICBpc0RlY2ltYWxEaWdpdDogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID49IDB4MzAgJiYgY3AgPD0gMHgzOSk7IC8vIDAuLjlcclxuXHQgICAgfSxcclxuXHQgICAgaXNIZXhEaWdpdDogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID49IDB4MzAgJiYgY3AgPD0gMHgzOSkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHg0MSAmJiBjcCA8PSAweDQ2KSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDYxICYmIGNwIDw9IDB4NjYpOyAvLyBhLi5mXHJcblx0ICAgIH0sXHJcblx0ICAgIGlzT2N0YWxEaWdpdDogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID49IDB4MzAgJiYgY3AgPD0gMHgzNyk7IC8vIDAuLjdcclxuXHQgICAgfVxyXG5cdH07XHJcblxuXG4vKioqLyB9LFxuLyogNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBqc3hfc3ludGF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdC8qIHRzbGludDpkaXNhYmxlOm1heC1jbGFzc2VzLXBlci1maWxlICovXHJcblx0dmFyIEpTWENsb3NpbmdFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYQ2xvc2luZ0VsZW1lbnQobmFtZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hDbG9zaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWENsb3NpbmdFbGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hDbG9zaW5nRWxlbWVudCA9IEpTWENsb3NpbmdFbGVtZW50O1xyXG5cdHZhciBKU1hFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYRWxlbWVudChvcGVuaW5nRWxlbWVudCwgY2hpbGRyZW4sIGNsb3NpbmdFbGVtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWEVsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLm9wZW5pbmdFbGVtZW50ID0gb3BlbmluZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcblx0ICAgICAgICB0aGlzLmNsb3NpbmdFbGVtZW50ID0gY2xvc2luZ0VsZW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWEVsZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWEVsZW1lbnQgPSBKU1hFbGVtZW50O1xyXG5cdHZhciBKU1hFbXB0eUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hFbXB0eUV4cHJlc3Npb24oKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWEVtcHR5RXhwcmVzc2lvbjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYRW1wdHlFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hFbXB0eUV4cHJlc3Npb24gPSBKU1hFbXB0eUV4cHJlc3Npb247XHJcblx0dmFyIEpTWEV4cHJlc3Npb25Db250YWluZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hFeHByZXNzaW9uQ29udGFpbmVyKGV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYRXhwcmVzc2lvbkNvbnRhaW5lcjtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWEV4cHJlc3Npb25Db250YWluZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWEV4cHJlc3Npb25Db250YWluZXIgPSBKU1hFeHByZXNzaW9uQ29udGFpbmVyO1xyXG5cdHZhciBKU1hJZGVudGlmaWVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYSWRlbnRpZmllcihuYW1lKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWElkZW50aWZpZXI7XHJcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hJZGVudGlmaWVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hJZGVudGlmaWVyID0gSlNYSWRlbnRpZmllcjtcclxuXHR2YXIgSlNYTWVtYmVyRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWE1lbWJlckV4cHJlc3Npb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hNZW1iZXJFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblx0ICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWE1lbWJlckV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWE1lbWJlckV4cHJlc3Npb24gPSBKU1hNZW1iZXJFeHByZXNzaW9uO1xyXG5cdHZhciBKU1hBdHRyaWJ1dGUgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYQXR0cmlidXRlO1xyXG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYQXR0cmlidXRlO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hBdHRyaWJ1dGUgPSBKU1hBdHRyaWJ1dGU7XHJcblx0dmFyIEpTWE5hbWVzcGFjZWROYW1lID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYTmFtZXNwYWNlZE5hbWUobmFtZXNwYWNlLCBuYW1lKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWE5hbWVzcGFjZWROYW1lO1xyXG5cdCAgICAgICAgdGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XHJcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hOYW1lc3BhY2VkTmFtZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYTmFtZXNwYWNlZE5hbWUgPSBKU1hOYW1lc3BhY2VkTmFtZTtcclxuXHR2YXIgSlNYT3BlbmluZ0VsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hPcGVuaW5nRWxlbWVudChuYW1lLCBzZWxmQ2xvc2luZywgYXR0cmlidXRlcykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hPcGVuaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblx0ICAgICAgICB0aGlzLnNlbGZDbG9zaW5nID0gc2VsZkNsb3Npbmc7XHJcblx0ICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hPcGVuaW5nRWxlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYT3BlbmluZ0VsZW1lbnQgPSBKU1hPcGVuaW5nRWxlbWVudDtcclxuXHR2YXIgSlNYU3ByZWFkQXR0cmlidXRlID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYU3ByZWFkQXR0cmlidXRlKGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWFNwcmVhZEF0dHJpYnV0ZTtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYU3ByZWFkQXR0cmlidXRlO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hTcHJlYWRBdHRyaWJ1dGUgPSBKU1hTcHJlYWRBdHRyaWJ1dGU7XHJcblx0dmFyIEpTWFRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hUZXh0KHZhbHVlLCByYXcpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYVGV4dDtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgICAgIHRoaXMucmF3ID0gcmF3O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hUZXh0O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hUZXh0ID0gSlNYVGV4dDtcclxuXG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0ZXhwb3J0cy5KU1hTeW50YXggPSB7XHJcblx0ICAgIEpTWEF0dHJpYnV0ZTogJ0pTWEF0dHJpYnV0ZScsXHJcblx0ICAgIEpTWENsb3NpbmdFbGVtZW50OiAnSlNYQ2xvc2luZ0VsZW1lbnQnLFxyXG5cdCAgICBKU1hFbGVtZW50OiAnSlNYRWxlbWVudCcsXHJcblx0ICAgIEpTWEVtcHR5RXhwcmVzc2lvbjogJ0pTWEVtcHR5RXhwcmVzc2lvbicsXHJcblx0ICAgIEpTWEV4cHJlc3Npb25Db250YWluZXI6ICdKU1hFeHByZXNzaW9uQ29udGFpbmVyJyxcclxuXHQgICAgSlNYSWRlbnRpZmllcjogJ0pTWElkZW50aWZpZXInLFxyXG5cdCAgICBKU1hNZW1iZXJFeHByZXNzaW9uOiAnSlNYTWVtYmVyRXhwcmVzc2lvbicsXHJcblx0ICAgIEpTWE5hbWVzcGFjZWROYW1lOiAnSlNYTmFtZXNwYWNlZE5hbWUnLFxyXG5cdCAgICBKU1hPcGVuaW5nRWxlbWVudDogJ0pTWE9wZW5pbmdFbGVtZW50JyxcclxuXHQgICAgSlNYU3ByZWFkQXR0cmlidXRlOiAnSlNYU3ByZWFkQXR0cmlidXRlJyxcclxuXHQgICAgSlNYVGV4dDogJ0pTWFRleHQnXHJcblx0fTtcclxuXG5cbi8qKiovIH0sXG4vKiA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIHN5bnRheF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHQvKiB0c2xpbnQ6ZGlzYWJsZTptYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xyXG5cdHZhciBBcnJheUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBcnJheUV4cHJlc3Npb24oZWxlbWVudHMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5BcnJheUV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFycmF5RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXJyYXlFeHByZXNzaW9uID0gQXJyYXlFeHByZXNzaW9uO1xyXG5cdHZhciBBcnJheVBhdHRlcm4gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBcnJheVBhdHRlcm4oZWxlbWVudHMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5BcnJheVBhdHRlcm47XHJcblx0ICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFycmF5UGF0dGVybjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXJyYXlQYXR0ZXJuID0gQXJyYXlQYXR0ZXJuO1xyXG5cdHZhciBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFycm93RnVuY3Rpb25FeHByZXNzaW9uKHBhcmFtcywgYm9keSwgZXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IG51bGw7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuYXN5bmMgPSBmYWxzZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0dmFyIEFzc2lnbm1lbnRFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXNzaWdubWVudEV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudEV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBc3NpZ25tZW50RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXNzaWdubWVudEV4cHJlc3Npb24gPSBBc3NpZ25tZW50RXhwcmVzc2lvbjtcclxuXHR2YXIgQXNzaWdubWVudFBhdHRlcm4gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBc3NpZ25tZW50UGF0dGVybihsZWZ0LCByaWdodCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuO1xyXG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuXHQgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXNzaWdubWVudFBhdHRlcm47XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFzc2lnbm1lbnRQYXR0ZXJuID0gQXNzaWdubWVudFBhdHRlcm47XHJcblx0dmFyIEFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBc3luY0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKHBhcmFtcywgYm9keSwgZXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IG51bGw7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuYXN5bmMgPSB0cnVlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBc3luY0Fycm93RnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Bc3luY0Fycm93RnVuY3Rpb25FeHByZXNzaW9uID0gQXN5bmNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR2YXIgQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uKGlkLCBwYXJhbXMsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5hc3luYyA9IHRydWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uID0gQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uO1xyXG5cdHZhciBBc3luY0Z1bmN0aW9uRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFzeW5jRnVuY3Rpb25FeHByZXNzaW9uKGlkLCBwYXJhbXMsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5GdW5jdGlvbkV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmFzeW5jID0gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXN5bmNGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFzeW5jRnVuY3Rpb25FeHByZXNzaW9uID0gQXN5bmNGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0dmFyIEF3YWl0RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEF3YWl0RXhwcmVzc2lvbihhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkF3YWl0RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXdhaXRFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Bd2FpdEV4cHJlc3Npb24gPSBBd2FpdEV4cHJlc3Npb247XHJcblx0dmFyIEJpbmFyeUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBCaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xyXG5cdCAgICAgICAgdmFyIGxvZ2ljYWwgPSAob3BlcmF0b3IgPT09ICd8fCcgfHwgb3BlcmF0b3IgPT09ICcmJicpO1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gbG9naWNhbCA/IHN5bnRheF8xLlN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbiA6IHN5bnRheF8xLlN5bnRheC5CaW5hcnlFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuXHQgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQmluYXJ5RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQmluYXJ5RXhwcmVzc2lvbiA9IEJpbmFyeUV4cHJlc3Npb247XHJcblx0dmFyIEJsb2NrU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQmxvY2tTdGF0ZW1lbnQoYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkJsb2NrU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQmxvY2tTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkJsb2NrU3RhdGVtZW50ID0gQmxvY2tTdGF0ZW1lbnQ7XHJcblx0dmFyIEJyZWFrU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQnJlYWtTdGF0ZW1lbnQobGFiZWwpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5CcmVha1N0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQnJlYWtTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkJyZWFrU3RhdGVtZW50ID0gQnJlYWtTdGF0ZW1lbnQ7XHJcblx0dmFyIENhbGxFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ2FsbEV4cHJlc3Npb24oY2FsbGVlLCBhcmdzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ2FsbEV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmNhbGxlZSA9IGNhbGxlZTtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnRzID0gYXJncztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ2FsbEV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNhbGxFeHByZXNzaW9uID0gQ2FsbEV4cHJlc3Npb247XHJcblx0dmFyIENhdGNoQ2xhdXNlID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ2F0Y2hDbGF1c2UocGFyYW0sIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5DYXRjaENsYXVzZTtcclxuXHQgICAgICAgIHRoaXMucGFyYW0gPSBwYXJhbTtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENhdGNoQ2xhdXNlO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5DYXRjaENsYXVzZSA9IENhdGNoQ2xhdXNlO1xyXG5cdHZhciBDbGFzc0JvZHkgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDbGFzc0JvZHkoYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNsYXNzQm9keTtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENsYXNzQm9keTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ2xhc3NCb2R5ID0gQ2xhc3NCb2R5O1xyXG5cdHZhciBDbGFzc0RlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ2xhc3NEZWNsYXJhdGlvbihpZCwgc3VwZXJDbGFzcywgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNsYXNzRGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLnN1cGVyQ2xhc3MgPSBzdXBlckNsYXNzO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ2xhc3NEZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ2xhc3NEZWNsYXJhdGlvbiA9IENsYXNzRGVjbGFyYXRpb247XHJcblx0dmFyIENsYXNzRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENsYXNzRXhwcmVzc2lvbihpZCwgc3VwZXJDbGFzcywgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNsYXNzRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMuc3VwZXJDbGFzcyA9IHN1cGVyQ2xhc3M7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDbGFzc0V4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNsYXNzRXhwcmVzc2lvbiA9IENsYXNzRXhwcmVzc2lvbjtcclxuXHR2YXIgQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5jb21wdXRlZCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHQgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Db21wdXRlZE1lbWJlckV4cHJlc3Npb24gPSBDb21wdXRlZE1lbWJlckV4cHJlc3Npb247XHJcblx0dmFyIENvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENvbmRpdGlvbmFsRXhwcmVzc2lvbih0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Db25kaXRpb25hbEV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xyXG5cdCAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcclxuXHQgICAgICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDb25kaXRpb25hbEV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IENvbmRpdGlvbmFsRXhwcmVzc2lvbjtcclxuXHR2YXIgQ29udGludWVTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDb250aW51ZVN0YXRlbWVudChsYWJlbCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNvbnRpbnVlU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDb250aW51ZVN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ29udGludWVTdGF0ZW1lbnQgPSBDb250aW51ZVN0YXRlbWVudDtcclxuXHR2YXIgRGVidWdnZXJTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBEZWJ1Z2dlclN0YXRlbWVudCgpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5EZWJ1Z2dlclN0YXRlbWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRGVidWdnZXJTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkRlYnVnZ2VyU3RhdGVtZW50ID0gRGVidWdnZXJTdGF0ZW1lbnQ7XHJcblx0dmFyIERpcmVjdGl2ZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIERpcmVjdGl2ZShleHByZXNzaW9uLCBkaXJlY3RpdmUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuZGlyZWN0aXZlID0gZGlyZWN0aXZlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBEaXJlY3RpdmU7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkRpcmVjdGl2ZSA9IERpcmVjdGl2ZTtcclxuXHR2YXIgRG9XaGlsZVN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIERvV2hpbGVTdGF0ZW1lbnQoYm9keSwgdGVzdCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkRvV2hpbGVTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRG9XaGlsZVN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRG9XaGlsZVN0YXRlbWVudCA9IERvV2hpbGVTdGF0ZW1lbnQ7XHJcblx0dmFyIEVtcHR5U3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRW1wdHlTdGF0ZW1lbnQoKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRW1wdHlTdGF0ZW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEVtcHR5U3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FbXB0eVN0YXRlbWVudCA9IEVtcHR5U3RhdGVtZW50O1xyXG5cdHZhciBFeHBvcnRBbGxEZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEV4cG9ydEFsbERlY2xhcmF0aW9uKHNvdXJjZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cG9ydEFsbERlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEV4cG9ydEFsbERlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FeHBvcnRBbGxEZWNsYXJhdGlvbiA9IEV4cG9ydEFsbERlY2xhcmF0aW9uO1xyXG5cdHZhciBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb247XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uID0gRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uO1xyXG5cdHZhciBFeHBvcnROYW1lZERlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRXhwb3J0TmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwgc3BlY2lmaWVycywgc291cmNlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRXhwb3J0TmFtZWREZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuc3BlY2lmaWVycyA9IHNwZWNpZmllcnM7XHJcblx0ICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRXhwb3J0TmFtZWREZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRXhwb3J0TmFtZWREZWNsYXJhdGlvbiA9IEV4cG9ydE5hbWVkRGVjbGFyYXRpb247XHJcblx0dmFyIEV4cG9ydFNwZWNpZmllciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEV4cG9ydFNwZWNpZmllcihsb2NhbCwgZXhwb3J0ZWQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FeHBvcnRTcGVjaWZpZXI7XHJcblx0ICAgICAgICB0aGlzLmV4cG9ydGVkID0gZXhwb3J0ZWQ7XHJcblx0ICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEV4cG9ydFNwZWNpZmllcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRXhwb3J0U3BlY2lmaWVyID0gRXhwb3J0U3BlY2lmaWVyO1xyXG5cdHZhciBFeHByZXNzaW9uU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRXhwcmVzc2lvblN0YXRlbWVudChleHByZXNzaW9uKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRXhwcmVzc2lvblN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEV4cHJlc3Npb25TdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkV4cHJlc3Npb25TdGF0ZW1lbnQgPSBFeHByZXNzaW9uU3RhdGVtZW50O1xyXG5cdHZhciBGb3JJblN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEZvckluU3RhdGVtZW50KGxlZnQsIHJpZ2h0LCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRm9ySW5TdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZWFjaCA9IGZhbHNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBGb3JJblN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRm9ySW5TdGF0ZW1lbnQgPSBGb3JJblN0YXRlbWVudDtcclxuXHR2YXIgRm9yT2ZTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBGb3JPZlN0YXRlbWVudChsZWZ0LCByaWdodCwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZvck9mU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuXHQgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEZvck9mU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Gb3JPZlN0YXRlbWVudCA9IEZvck9mU3RhdGVtZW50O1xyXG5cdHZhciBGb3JTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBGb3JTdGF0ZW1lbnQoaW5pdCwgdGVzdCwgdXBkYXRlLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRm9yU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5pbml0ID0gaW5pdDtcclxuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XHJcblx0ICAgICAgICB0aGlzLnVwZGF0ZSA9IHVwZGF0ZTtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEZvclN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRm9yU3RhdGVtZW50ID0gRm9yU3RhdGVtZW50O1xyXG5cdHZhciBGdW5jdGlvbkRlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRnVuY3Rpb25EZWNsYXJhdGlvbihpZCwgcGFyYW1zLCBib2R5LCBnZW5lcmF0b3IpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuYXN5bmMgPSBmYWxzZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRnVuY3Rpb25EZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRnVuY3Rpb25EZWNsYXJhdGlvbiA9IEZ1bmN0aW9uRGVjbGFyYXRpb247XHJcblx0dmFyIEZ1bmN0aW9uRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEZ1bmN0aW9uRXhwcmVzc2lvbihpZCwgcGFyYW1zLCBib2R5LCBnZW5lcmF0b3IpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5GdW5jdGlvbkV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGdlbmVyYXRvcjtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5hc3luYyA9IGZhbHNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkZ1bmN0aW9uRXhwcmVzc2lvbiA9IEZ1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR2YXIgSWRlbnRpZmllciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIElkZW50aWZpZXIobmFtZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXI7XHJcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBJZGVudGlmaWVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5JZGVudGlmaWVyID0gSWRlbnRpZmllcjtcclxuXHR2YXIgSWZTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBJZlN0YXRlbWVudCh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JZlN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xyXG5cdCAgICAgICAgdGhpcy5hbHRlcm5hdGUgPSBhbHRlcm5hdGU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIElmU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5JZlN0YXRlbWVudCA9IElmU3RhdGVtZW50O1xyXG5cdHZhciBJbXBvcnREZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEltcG9ydERlY2xhcmF0aW9uKHNwZWNpZmllcnMsIHNvdXJjZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkltcG9ydERlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5zcGVjaWZpZXJzID0gc3BlY2lmaWVycztcclxuXHQgICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBJbXBvcnREZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSW1wb3J0RGVjbGFyYXRpb24gPSBJbXBvcnREZWNsYXJhdGlvbjtcclxuXHR2YXIgSW1wb3J0RGVmYXVsdFNwZWNpZmllciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEltcG9ydERlZmF1bHRTcGVjaWZpZXIobG9jYWwpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JbXBvcnREZWZhdWx0U3BlY2lmaWVyO1xyXG5cdCAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBJbXBvcnREZWZhdWx0U3BlY2lmaWVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5JbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gSW1wb3J0RGVmYXVsdFNwZWNpZmllcjtcclxuXHR2YXIgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKGxvY2FsKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xyXG5cdCAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcclxuXHR2YXIgSW1wb3J0U3BlY2lmaWVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSW1wb3J0U3BlY2lmaWVyKGxvY2FsLCBpbXBvcnRlZCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkltcG9ydFNwZWNpZmllcjtcclxuXHQgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcclxuXHQgICAgICAgIHRoaXMuaW1wb3J0ZWQgPSBpbXBvcnRlZDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSW1wb3J0U3BlY2lmaWVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5JbXBvcnRTcGVjaWZpZXIgPSBJbXBvcnRTcGVjaWZpZXI7XHJcblx0dmFyIExhYmVsZWRTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBMYWJlbGVkU3RhdGVtZW50KGxhYmVsLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTGFiZWxlZFN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIExhYmVsZWRTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkxhYmVsZWRTdGF0ZW1lbnQgPSBMYWJlbGVkU3RhdGVtZW50O1xyXG5cdHZhciBMaXRlcmFsID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gTGl0ZXJhbCh2YWx1ZSwgcmF3KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTGl0ZXJhbDtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgICAgIHRoaXMucmF3ID0gcmF3O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBMaXRlcmFsO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5MaXRlcmFsID0gTGl0ZXJhbDtcclxuXHR2YXIgTWV0YVByb3BlcnR5ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gTWV0YVByb3BlcnR5KG1ldGEsIHByb3BlcnR5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTWV0YVByb3BlcnR5O1xyXG5cdCAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcclxuXHQgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gTWV0YVByb3BlcnR5O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5NZXRhUHJvcGVydHkgPSBNZXRhUHJvcGVydHk7XHJcblx0dmFyIE1ldGhvZERlZmluaXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBNZXRob2REZWZpbml0aW9uKGtleSwgY29tcHV0ZWQsIHZhbHVlLCBraW5kLCBpc1N0YXRpYykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk1ldGhvZERlZmluaXRpb247XHJcblx0ICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuXHQgICAgICAgIHRoaXMuY29tcHV0ZWQgPSBjb21wdXRlZDtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XHJcblx0ICAgICAgICB0aGlzLnN0YXRpYyA9IGlzU3RhdGljO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBNZXRob2REZWZpbml0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5NZXRob2REZWZpbml0aW9uID0gTWV0aG9kRGVmaW5pdGlvbjtcclxuXHR2YXIgTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gTW9kdWxlKGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Qcm9ncmFtO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuc291cmNlVHlwZSA9ICdtb2R1bGUnO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBNb2R1bGU7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLk1vZHVsZSA9IE1vZHVsZTtcclxuXHR2YXIgTmV3RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIE5ld0V4cHJlc3Npb24oY2FsbGVlLCBhcmdzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTmV3RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuY2FsbGVlID0gY2FsbGVlO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudHMgPSBhcmdzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBOZXdFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5OZXdFeHByZXNzaW9uID0gTmV3RXhwcmVzc2lvbjtcclxuXHR2YXIgT2JqZWN0RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIE9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk9iamVjdEV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBPYmplY3RFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5PYmplY3RFeHByZXNzaW9uID0gT2JqZWN0RXhwcmVzc2lvbjtcclxuXHR2YXIgT2JqZWN0UGF0dGVybiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIE9iamVjdFBhdHRlcm4ocHJvcGVydGllcykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk9iamVjdFBhdHRlcm47XHJcblx0ICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBPYmplY3RQYXR0ZXJuO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5PYmplY3RQYXR0ZXJuID0gT2JqZWN0UGF0dGVybjtcclxuXHR2YXIgUHJvcGVydHkgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBQcm9wZXJ0eShraW5kLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgbWV0aG9kLCBzaG9ydGhhbmQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Qcm9wZXJ0eTtcclxuXHQgICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG5cdCAgICAgICAgdGhpcy5jb21wdXRlZCA9IGNvbXB1dGVkO1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgdGhpcy5raW5kID0ga2luZDtcclxuXHQgICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xyXG5cdCAgICAgICAgdGhpcy5zaG9ydGhhbmQgPSBzaG9ydGhhbmQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFByb3BlcnR5O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Qcm9wZXJ0eSA9IFByb3BlcnR5O1xyXG5cdHZhciBSZWdleExpdGVyYWwgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBSZWdleExpdGVyYWwodmFsdWUsIHJhdywgcGF0dGVybiwgZmxhZ3MpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5MaXRlcmFsO1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgdGhpcy5yYXcgPSByYXc7XHJcblx0ICAgICAgICB0aGlzLnJlZ2V4ID0geyBwYXR0ZXJuOiBwYXR0ZXJuLCBmbGFnczogZmxhZ3MgfTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gUmVnZXhMaXRlcmFsO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5SZWdleExpdGVyYWwgPSBSZWdleExpdGVyYWw7XHJcblx0dmFyIFJlc3RFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gUmVzdEVsZW1lbnQoYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5SZXN0RWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gUmVzdEVsZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlJlc3RFbGVtZW50ID0gUmVzdEVsZW1lbnQ7XHJcblx0dmFyIFJldHVyblN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFJldHVyblN0YXRlbWVudChhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlJldHVyblN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gUmV0dXJuU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5SZXR1cm5TdGF0ZW1lbnQgPSBSZXR1cm5TdGF0ZW1lbnQ7XHJcblx0dmFyIFNjcmlwdCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFNjcmlwdChib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguUHJvZ3JhbTtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLnNvdXJjZVR5cGUgPSAnc2NyaXB0JztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU2NyaXB0O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5TY3JpcHQgPSBTY3JpcHQ7XHJcblx0dmFyIFNlcXVlbmNlRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlNlcXVlbmNlRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU2VxdWVuY2VFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5TZXF1ZW5jZUV4cHJlc3Npb24gPSBTZXF1ZW5jZUV4cHJlc3Npb247XHJcblx0dmFyIFNwcmVhZEVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTcHJlYWRFbGVtZW50KGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguU3ByZWFkRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU3ByZWFkRWxlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU3ByZWFkRWxlbWVudCA9IFNwcmVhZEVsZW1lbnQ7XHJcblx0dmFyIFN0YXRpY01lbWJlckV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTdGF0aWNNZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5jb21wdXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblx0ICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFN0YXRpY01lbWJlckV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlN0YXRpY01lbWJlckV4cHJlc3Npb24gPSBTdGF0aWNNZW1iZXJFeHByZXNzaW9uO1xyXG5cdHZhciBTdXBlciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFN1cGVyKCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlN1cGVyO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTdXBlcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU3VwZXIgPSBTdXBlcjtcclxuXHR2YXIgU3dpdGNoQ2FzZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFN3aXRjaENhc2UodGVzdCwgY29uc2VxdWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlN3aXRjaENhc2U7XHJcblx0ICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xyXG5cdCAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU3dpdGNoQ2FzZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU3dpdGNoQ2FzZSA9IFN3aXRjaENhc2U7XHJcblx0dmFyIFN3aXRjaFN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFN3aXRjaFN0YXRlbWVudChkaXNjcmltaW5hbnQsIGNhc2VzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguU3dpdGNoU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5kaXNjcmltaW5hbnQgPSBkaXNjcmltaW5hbnQ7XHJcblx0ICAgICAgICB0aGlzLmNhc2VzID0gY2FzZXM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFN3aXRjaFN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU3dpdGNoU3RhdGVtZW50ID0gU3dpdGNoU3RhdGVtZW50O1xyXG5cdHZhciBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24odGFnLCBxdWFzaSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMudGFnID0gdGFnO1xyXG5cdCAgICAgICAgdGhpcy5xdWFzaSA9IHF1YXNpO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiA9IFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjtcclxuXHR2YXIgVGVtcGxhdGVFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVGVtcGxhdGVFbGVtZW50KHZhbHVlLCB0YWlsKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVGVtcGxhdGVFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgdGhpcy50YWlsID0gdGFpbDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVGVtcGxhdGVFbGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5UZW1wbGF0ZUVsZW1lbnQgPSBUZW1wbGF0ZUVsZW1lbnQ7XHJcblx0dmFyIFRlbXBsYXRlTGl0ZXJhbCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRlbXBsYXRlTGl0ZXJhbChxdWFzaXMsIGV4cHJlc3Npb25zKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVGVtcGxhdGVMaXRlcmFsO1xyXG5cdCAgICAgICAgdGhpcy5xdWFzaXMgPSBxdWFzaXM7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFRlbXBsYXRlTGl0ZXJhbDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsID0gVGVtcGxhdGVMaXRlcmFsO1xyXG5cdHZhciBUaGlzRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRoaXNFeHByZXNzaW9uKCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlRoaXNFeHByZXNzaW9uO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBUaGlzRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVGhpc0V4cHJlc3Npb24gPSBUaGlzRXhwcmVzc2lvbjtcclxuXHR2YXIgVGhyb3dTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUaHJvd1N0YXRlbWVudChhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlRocm93U3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBUaHJvd1N0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVGhyb3dTdGF0ZW1lbnQgPSBUaHJvd1N0YXRlbWVudDtcclxuXHR2YXIgVHJ5U3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVHJ5U3RhdGVtZW50KGJsb2NrLCBoYW5kbGVyLCBmaW5hbGl6ZXIpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5UcnlTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2s7XHJcblx0ICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cdCAgICAgICAgdGhpcy5maW5hbGl6ZXIgPSBmaW5hbGl6ZXI7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFRyeVN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVHJ5U3RhdGVtZW50ID0gVHJ5U3RhdGVtZW50O1xyXG5cdHZhciBVbmFyeUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBVbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVW5hcnlFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICAgICAgdGhpcy5wcmVmaXggPSB0cnVlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBVbmFyeUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlVuYXJ5RXhwcmVzc2lvbiA9IFVuYXJ5RXhwcmVzc2lvbjtcclxuXHR2YXIgVXBkYXRlRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFVwZGF0ZUV4cHJlc3Npb24ob3BlcmF0b3IsIGFyZ3VtZW50LCBwcmVmaXgpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5VcGRhdGVFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFVwZGF0ZUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlVwZGF0ZUV4cHJlc3Npb24gPSBVcGRhdGVFeHByZXNzaW9uO1xyXG5cdHZhciBWYXJpYWJsZURlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5kZWNsYXJhdGlvbnMgPSBkZWNsYXJhdGlvbnM7XHJcblx0ICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBWYXJpYWJsZURlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5WYXJpYWJsZURlY2xhcmF0aW9uID0gVmFyaWFibGVEZWNsYXJhdGlvbjtcclxuXHR2YXIgVmFyaWFibGVEZWNsYXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVmFyaWFibGVEZWNsYXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5pbml0ID0gaW5pdDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVmFyaWFibGVEZWNsYXJhdG9yO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5WYXJpYWJsZURlY2xhcmF0b3IgPSBWYXJpYWJsZURlY2xhcmF0b3I7XHJcblx0dmFyIFdoaWxlU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gV2hpbGVTdGF0ZW1lbnQodGVzdCwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LldoaWxlU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFdoaWxlU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5XaGlsZVN0YXRlbWVudCA9IFdoaWxlU3RhdGVtZW50O1xyXG5cdHZhciBXaXRoU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gV2l0aFN0YXRlbWVudChvYmplY3QsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5XaXRoU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBXaXRoU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5XaXRoU3RhdGVtZW50ID0gV2l0aFN0YXRlbWVudDtcclxuXHR2YXIgWWllbGRFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gWWllbGRFeHByZXNzaW9uKGFyZ3VtZW50LCBkZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LllpZWxkRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gWWllbGRFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5ZaWVsZEV4cHJlc3Npb24gPSBZaWVsZEV4cHJlc3Npb247XHJcblxuXG4vKioqLyB9LFxuLyogOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBhc3NlcnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcblx0dmFyIGVycm9yX2hhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5cdHZhciBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcblx0dmFyIE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG5cdHZhciBzY2FubmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxuXHR2YXIgc3ludGF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cdHZhciB0b2tlbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcblx0dmFyIEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIgPSAnQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcic7XHJcblx0dmFyIFBhcnNlciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFBhcnNlcihjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuXHQgICAgICAgIHRoaXMuY29uZmlnID0ge1xyXG5cdCAgICAgICAgICAgIHJhbmdlOiAodHlwZW9mIG9wdGlvbnMucmFuZ2UgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5yYW5nZSxcclxuXHQgICAgICAgICAgICBsb2M6ICh0eXBlb2Ygb3B0aW9ucy5sb2MgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5sb2MsXHJcblx0ICAgICAgICAgICAgc291cmNlOiBudWxsLFxyXG5cdCAgICAgICAgICAgIHRva2VuczogKHR5cGVvZiBvcHRpb25zLnRva2VucyA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnRva2VucyxcclxuXHQgICAgICAgICAgICBjb21tZW50OiAodHlwZW9mIG9wdGlvbnMuY29tbWVudCA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLmNvbW1lbnQsXHJcblx0ICAgICAgICAgICAgdG9sZXJhbnQ6ICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnRvbGVyYW50XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvYyAmJiBvcHRpb25zLnNvdXJjZSAmJiBvcHRpb25zLnNvdXJjZSAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29uZmlnLnNvdXJjZSA9IFN0cmluZyhvcHRpb25zLnNvdXJjZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlciA9IG5ldyBlcnJvcl9oYW5kbGVyXzEuRXJyb3JIYW5kbGVyKCk7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlci50b2xlcmFudCA9IHRoaXMuY29uZmlnLnRvbGVyYW50O1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyID0gbmV3IHNjYW5uZXJfMS5TY2FubmVyKGNvZGUsIHRoaXMuZXJyb3JIYW5kbGVyKTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci50cmFja0NvbW1lbnQgPSB0aGlzLmNvbmZpZy5jb21tZW50O1xyXG5cdCAgICAgICAgdGhpcy5vcGVyYXRvclByZWNlZGVuY2UgPSB7XHJcblx0ICAgICAgICAgICAgJyknOiAwLFxyXG5cdCAgICAgICAgICAgICc7JzogMCxcclxuXHQgICAgICAgICAgICAnLCc6IDAsXHJcblx0ICAgICAgICAgICAgJz0nOiAwLFxyXG5cdCAgICAgICAgICAgICddJzogMCxcclxuXHQgICAgICAgICAgICAnfHwnOiAxLFxyXG5cdCAgICAgICAgICAgICcmJic6IDIsXHJcblx0ICAgICAgICAgICAgJ3wnOiAzLFxyXG5cdCAgICAgICAgICAgICdeJzogNCxcclxuXHQgICAgICAgICAgICAnJic6IDUsXHJcblx0ICAgICAgICAgICAgJz09JzogNixcclxuXHQgICAgICAgICAgICAnIT0nOiA2LFxyXG5cdCAgICAgICAgICAgICc9PT0nOiA2LFxyXG5cdCAgICAgICAgICAgICchPT0nOiA2LFxyXG5cdCAgICAgICAgICAgICc8JzogNyxcclxuXHQgICAgICAgICAgICAnPic6IDcsXHJcblx0ICAgICAgICAgICAgJzw9JzogNyxcclxuXHQgICAgICAgICAgICAnPj0nOiA3LFxyXG5cdCAgICAgICAgICAgICc8PCc6IDgsXHJcblx0ICAgICAgICAgICAgJz4+JzogOCxcclxuXHQgICAgICAgICAgICAnPj4+JzogOCxcclxuXHQgICAgICAgICAgICAnKyc6IDksXHJcblx0ICAgICAgICAgICAgJy0nOiA5LFxyXG5cdCAgICAgICAgICAgICcqJzogMTEsXHJcblx0ICAgICAgICAgICAgJy8nOiAxMSxcclxuXHQgICAgICAgICAgICAnJSc6IDExXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgdGhpcy5sb29rYWhlYWQgPSB7XHJcblx0ICAgICAgICAgICAgdHlwZTogMiAvKiBFT0YgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6ICcnLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogMCxcclxuXHQgICAgICAgICAgICBzdGFydDogMCxcclxuXHQgICAgICAgICAgICBlbmQ6IDBcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICB0aGlzLmhhc0xpbmVUZXJtaW5hdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQgPSB7XHJcblx0ICAgICAgICAgICAgaXNNb2R1bGU6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGF3YWl0OiBmYWxzZSxcclxuXHQgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIGFsbG93U3RyaWN0RGlyZWN0aXZlOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIGFsbG93WWllbGQ6IHRydWUsXHJcblx0ICAgICAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yOiBudWxsLFxyXG5cdCAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldDogZmFsc2UsXHJcblx0ICAgICAgICAgICAgaXNCaW5kaW5nRWxlbWVudDogZmFsc2UsXHJcblx0ICAgICAgICAgICAgaW5GdW5jdGlvbkJvZHk6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGluSXRlcmF0aW9uOiBmYWxzZSxcclxuXHQgICAgICAgICAgICBpblN3aXRjaDogZmFsc2UsXHJcblx0ICAgICAgICAgICAgbGFiZWxTZXQ6IHt9LFxyXG5cdCAgICAgICAgICAgIHN0cmljdDogZmFsc2VcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlciA9IHtcclxuXHQgICAgICAgICAgICBpbmRleDogMCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBjb2x1bW46IDBcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIgPSB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IDAsXHJcblx0ICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiAwXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlciA9IHtcclxuXHQgICAgICAgICAgICBpbmRleDogdGhpcy5zY2FubmVyLmluZGV4LFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfVxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnRocm93RXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZUZvcm1hdCkge1xyXG5cdCAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xyXG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuXHQgICAgICAgICAgICB2YWx1ZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblx0ICAgICAgICB2YXIgbXNnID0gbWVzc2FnZUZvcm1hdC5yZXBsYWNlKC8lKFxcZCkvZywgZnVuY3Rpb24gKHdob2xlLCBpZHgpIHtcclxuXHQgICAgICAgICAgICBhc3NlcnRfMS5hc3NlcnQoaWR4IDwgYXJncy5sZW5ndGgsICdNZXNzYWdlIHJlZmVyZW5jZSBtdXN0IGJlIGluIHJhbmdlJyk7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGFyZ3NbaWR4XTtcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5sYXN0TWFya2VyLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxhc3RNYXJrZXIubGluZTtcclxuXHQgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmxhc3RNYXJrZXIuY29sdW1uICsgMTtcclxuXHQgICAgICAgIHRocm93IHRoaXMuZXJyb3JIYW5kbGVyLmNyZWF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2x1bW4sIG1zZyk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUudG9sZXJhdGVFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlRm9ybWF0KSB7XHJcblx0ICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG5cdCAgICAgICAgICAgIHZhbHVlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHQgICAgICAgIHZhciBtc2cgPSBtZXNzYWdlRm9ybWF0LnJlcGxhY2UoLyUoXFxkKS9nLCBmdW5jdGlvbiAod2hvbGUsIGlkeCkge1xyXG5cdCAgICAgICAgICAgIGFzc2VydF8xLmFzc2VydChpZHggPCBhcmdzLmxlbmd0aCwgJ01lc3NhZ2UgcmVmZXJlbmNlIG11c3QgYmUgaW4gcmFuZ2UnKTtcclxuXHQgICAgICAgICAgICByZXR1cm4gYXJnc1tpZHhdO1xyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxhc3RNYXJrZXIuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgbGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubGFzdE1hcmtlci5jb2x1bW4gKyAxO1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIudG9sZXJhdGVFcnJvcihpbmRleCwgbGluZSwgY29sdW1uLCBtc2cpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBUaHJvdyBhbiBleGNlcHRpb24gYmVjYXVzZSBvZiB0aGUgdG9rZW4uXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUudW5leHBlY3RlZFRva2VuRXJyb3IgPSBmdW5jdGlvbiAodG9rZW4sIG1lc3NhZ2UpIHtcclxuXHQgICAgICAgIHZhciBtc2cgPSBtZXNzYWdlIHx8IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlO1xyXG5cdCAgICAgICAgaWYgKHRva2VuKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCFtZXNzYWdlKSB7XHJcblx0ICAgICAgICAgICAgICAgIG1zZyA9ICh0b2tlbi50eXBlID09PSAyIC8qIEVPRiAqLykgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRFT1MgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRJZGVudGlmaWVyIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gNiAvKiBOdW1lcmljTGl0ZXJhbCAqLykgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWROdW1iZXIgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gOCAvKiBTdHJpbmdMaXRlcmFsICovKSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFN0cmluZyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gMTAgLyogVGVtcGxhdGUgKi8pID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVGVtcGxhdGUgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gNCAvKiBLZXl3b3JkICovKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzRnV0dXJlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFJlc2VydmVkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdG9rZW4udmFsdWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9ICdJTExFR0FMJztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKCclMCcsIHZhbHVlKTtcclxuXHQgICAgICAgIGlmICh0b2tlbiAmJiB0eXBlb2YgdG9rZW4ubGluZU51bWJlciA9PT0gJ251bWJlcicpIHtcclxuXHQgICAgICAgICAgICB2YXIgaW5kZXggPSB0b2tlbi5zdGFydDtcclxuXHQgICAgICAgICAgICB2YXIgbGluZSA9IHRva2VuLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgdmFyIGxhc3RNYXJrZXJMaW5lU3RhcnQgPSB0aGlzLmxhc3RNYXJrZXIuaW5kZXggLSB0aGlzLmxhc3RNYXJrZXIuY29sdW1uO1xyXG5cdCAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0b2tlbi5zdGFydCAtIGxhc3RNYXJrZXJMaW5lU3RhcnQgKyAxO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9ySGFuZGxlci5jcmVhdGVFcnJvcihpbmRleCwgbGluZSwgY29sdW1uLCBtc2cpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5sYXN0TWFya2VyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHZhciBsaW5lID0gdGhpcy5sYXN0TWFya2VyLmxpbmU7XHJcblx0ICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubGFzdE1hcmtlci5jb2x1bW4gKyAxO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9ySGFuZGxlci5jcmVhdGVFcnJvcihpbmRleCwgbGluZSwgY29sdW1uLCBtc2cpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnRocm93VW5leHBlY3RlZFRva2VuID0gZnVuY3Rpb24gKHRva2VuLCBtZXNzYWdlKSB7XHJcblx0ICAgICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWRUb2tlbkVycm9yKHRva2VuLCBtZXNzYWdlKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbiwgbWVzc2FnZSkge1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIudG9sZXJhdGUodGhpcy51bmV4cGVjdGVkVG9rZW5FcnJvcih0b2tlbiwgbWVzc2FnZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmNvbGxlY3RDb21tZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICghdGhpcy5jb25maWcuY29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhciBjb21tZW50cyA9IHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcclxuXHQgICAgICAgICAgICBpZiAoY29tbWVudHMubGVuZ3RoID4gMCAmJiB0aGlzLmRlbGVnYXRlKSB7XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWVudHMubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlID0gY29tbWVudHNbaV07XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcclxuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZS5tdWx0aUxpbmUgPyAnQmxvY2tDb21tZW50JyA6ICdMaW5lQ29tbWVudCcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc2Nhbm5lci5zb3VyY2Uuc2xpY2UoZS5zbGljZVswXSwgZS5zbGljZVsxXSlcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcucmFuZ2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJhbmdlID0gZS5yYW5nZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5sb2MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmxvYyA9IGUubG9jO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGUubG9jLnN0YXJ0LmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogZS5sb2Muc3RhcnQuY29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGUucmFuZ2VbMF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVuZDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBlLmxvYy5lbmQubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBlLmxvYy5lbmQuY29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGUucmFuZ2VbMV1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZShub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIEZyb20gaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gdG8gYW4gZXh0ZXJuYWwgc3RydWN0dXJlXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuZ2V0VG9rZW5SYXcgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLnNjYW5uZXIuc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmNvbnZlcnRUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgdmFyIHQgPSB7XHJcblx0ICAgICAgICAgICAgdHlwZTogdG9rZW5fMS5Ub2tlbk5hbWVbdG9rZW4udHlwZV0sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnJhbmdlKSB7XHJcblx0ICAgICAgICAgICAgdC5yYW5nZSA9IFt0b2tlbi5zdGFydCwgdG9rZW4uZW5kXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy5sb2MpIHtcclxuXHQgICAgICAgICAgICB0LmxvYyA9IHtcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMuc3RhcnRNYXJrZXIubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zdGFydE1hcmtlci5jb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA5IC8qIFJlZ3VsYXJFeHByZXNzaW9uICovKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSB0b2tlbi5wYXR0ZXJuO1xyXG5cdCAgICAgICAgICAgIHZhciBmbGFncyA9IHRva2VuLmZsYWdzO1xyXG5cdCAgICAgICAgICAgIHQucmVnZXggPSB7IHBhdHRlcm46IHBhdHRlcm4sIGZsYWdzOiBmbGFncyB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubmV4dFRva2VuID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICB0aGlzLmNvbGxlY3RDb21tZW50cygpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pbmRleCAhPT0gdGhpcy5zdGFydE1hcmtlci5pbmRleCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdGhpcy5zdGFydE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgdGhpcy5zdGFydE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5leHQgPSB0aGlzLnNjYW5uZXIubGV4KCk7XHJcblx0ICAgICAgICB0aGlzLmhhc0xpbmVUZXJtaW5hdG9yID0gKHRva2VuLmxpbmVOdW1iZXIgIT09IG5leHQubGluZU51bWJlcik7XHJcblx0ICAgICAgICBpZiAobmV4dCAmJiB0aGlzLmNvbnRleHQuc3RyaWN0ICYmIG5leHQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQobmV4dC52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgbmV4dC50eXBlID0gNCAvKiBLZXl3b3JkICovO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMubG9va2FoZWFkID0gbmV4dDtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy50b2tlbnMgJiYgbmV4dC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2godGhpcy5jb252ZXJ0VG9rZW4obmV4dCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRva2VuO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm5leHRSZWdleFRva2VuID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5jb2xsZWN0Q29tbWVudHMoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMuc2Nhbm5lci5zY2FuUmVnRXhwKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9rZW5zKSB7XHJcblx0ICAgICAgICAgICAgLy8gUG9wIHRoZSBwcmV2aW91cyB0b2tlbiwgJy8nIG9yICcvPSdcclxuXHQgICAgICAgICAgICAvLyBUaGlzIGlzIGFkZGVkIGZyb20gdGhlIGxvb2thaGVhZCB0b2tlbi5cclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wb3AoKTtcclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHRoaXMuY29udmVydFRva2VuKHRva2VuKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBQcmltZSB0aGUgbmV4dCBsb29rYWhlYWQuXHJcblx0ICAgICAgICB0aGlzLmxvb2thaGVhZCA9IHRva2VuO1xyXG5cdCAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHJldHVybiB0b2tlbjtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVOb2RlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBpbmRleDogdGhpcy5zdGFydE1hcmtlci5pbmRleCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0aGlzLnN0YXJ0TWFya2VyLmxpbmUsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtblxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5zdGFydE5vZGUgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IHRva2VuLnN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRva2VuLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiB0b2tlbi5zdGFydCAtIHRva2VuLmxpbmVTdGFydFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uIChtYXJrZXIsIG5vZGUpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy5yYW5nZSkge1xyXG5cdCAgICAgICAgICAgIG5vZGUucmFuZ2UgPSBbbWFya2VyLmluZGV4LCB0aGlzLmxhc3RNYXJrZXIuaW5kZXhdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvYykge1xyXG5cdCAgICAgICAgICAgIG5vZGUubG9jID0ge1xyXG5cdCAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogbWFya2VyLmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IG1hcmtlci5jb2x1bW4sXHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIGVuZDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5sYXN0TWFya2VyLmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMubGFzdE1hcmtlci5jb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnNvdXJjZSkge1xyXG5cdCAgICAgICAgICAgICAgICBub2RlLmxvYy5zb3VyY2UgPSB0aGlzLmNvbmZpZy5zb3VyY2U7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUpIHtcclxuXHQgICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiBtYXJrZXIubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogbWFya2VyLmNvbHVtbixcclxuXHQgICAgICAgICAgICAgICAgICAgIG9mZnNldDogbWFya2VyLmluZGV4XHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIGVuZDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5sYXN0TWFya2VyLmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMubGFzdE1hcmtlci5jb2x1bW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMubGFzdE1hcmtlci5pbmRleFxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICB0aGlzLmRlbGVnYXRlKG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBub2RlO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxyXG5cdCAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5leHBlY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gNyAvKiBQdW5jdHVhdG9yICovIHx8IHRva2VuLnZhbHVlICE9PSB2YWx1ZSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBRdWlldGx5IGV4cGVjdCBhIGNvbW1hIHdoZW4gaW4gdG9sZXJhbnQgbW9kZSwgb3RoZXJ3aXNlIGRlbGVnYXRlcyB0byBleHBlY3QoKS5cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5leHBlY3RDb21tYVNlcGFyYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgdG9rZW4udmFsdWUgPT09ICcsJykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgdG9rZW4udmFsdWUgPT09ICc7Jykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBrZXl3b3JkLlxyXG5cdCAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5leHBlY3RLZXl3b3JkID0gZnVuY3Rpb24gKGtleXdvcmQpIHtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gNCAvKiBLZXl3b3JkICovIHx8IHRva2VuLnZhbHVlICE9PSBrZXl3b3JkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5sb29rYWhlYWQudHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSB2YWx1ZTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleXdvcmRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5tYXRjaEtleXdvcmQgPSBmdW5jdGlvbiAoa2V5d29yZCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyAmJiB0aGlzLmxvb2thaGVhZC52YWx1ZSA9PT0ga2V5d29yZDtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGNvbnRleHR1YWwga2V5d29yZFxyXG5cdCAgICAvLyAod2hlcmUgYW4gaWRlbnRpZmllciBpcyBzb21ldGltZXMgYSBrZXl3b3JkIGRlcGVuZGluZyBvbiB0aGUgY29udGV4dClcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5tYXRjaENvbnRleHR1YWxLZXl3b3JkID0gZnVuY3Rpb24gKGtleXdvcmQpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgdGhpcy5sb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIGlzIGFuIGFzc2lnbm1lbnQgb3BlcmF0b3JcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5tYXRjaEFzc2lnbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSA3IC8qIFB1bmN0dWF0b3IgKi8pIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgb3AgPSB0aGlzLmxvb2thaGVhZC52YWx1ZTtcclxuXHQgICAgICAgIHJldHVybiBvcCA9PT0gJz0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICcqPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJyoqPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJy89JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnJT0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICcrPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJy09JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnPDw9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnPj49JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnPj4+PScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJyY9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnXj0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICd8PSc7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIENvdmVyIGdyYW1tYXIgc3VwcG9ydC5cclxuXHQgICAgLy9cclxuXHQgICAgLy8gV2hlbiBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24gcG9zaXRpb24gc3RhcnRzIHdpdGggYW4gbGVmdCBwYXJlbnRoZXNpcywgdGhlIGRldGVybWluYXRpb24gb2YgdGhlIHR5cGVcclxuXHQgICAgLy8gb2YgdGhlIHN5bnRheCBpcyB0byBiZSBkZWZlcnJlZCBhcmJpdHJhcmlseSBsb25nIHVudGlsIHRoZSBlbmQgb2YgdGhlIHBhcmVudGhlc2VzIHBhaXIgKHBsdXMgYSBsb29rYWhlYWQpXHJcblx0ICAgIC8vIG9yIHRoZSBmaXJzdCBjb21tYS4gVGhpcyBzaXR1YXRpb24gYWxzbyBkZWZlcnMgdGhlIGRldGVybWluYXRpb24gb2YgYWxsIHRoZSBleHByZXNzaW9ucyBuZXN0ZWQgaW4gdGhlIHBhaXIuXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIFRoZXJlIGFyZSB0aHJlZSBwcm9kdWN0aW9ucyB0aGF0IGNhbiBiZSBwYXJzZWQgaW4gYSBwYXJlbnRoZXNlcyBwYWlyIHRoYXQgbmVlZHMgdG8gYmUgZGV0ZXJtaW5lZFxyXG5cdCAgICAvLyBhZnRlciB0aGUgb3V0ZXJtb3N0IHBhaXIgaXMgY2xvc2VkLiBUaGV5IGFyZTpcclxuXHQgICAgLy9cclxuXHQgICAgLy8gICAxLiBBc3NpZ25tZW50RXhwcmVzc2lvblxyXG5cdCAgICAvLyAgIDIuIEJpbmRpbmdFbGVtZW50c1xyXG5cdCAgICAvLyAgIDMuIEFzc2lnbm1lbnRUYXJnZXRzXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIEluIG9yZGVyIHRvIGF2b2lkIGV4cG9uZW50aWFsIGJhY2t0cmFja2luZywgd2UgdXNlIHR3byBmbGFncyB0byBkZW5vdGUgaWYgdGhlIHByb2R1Y3Rpb24gY2FuIGJlXHJcblx0ICAgIC8vIGJpbmRpbmcgZWxlbWVudCBvciBhc3NpZ25tZW50IHRhcmdldC5cclxuXHQgICAgLy9cclxuXHQgICAgLy8gVGhlIHRocmVlIHByb2R1Y3Rpb25zIGhhdmUgdGhlIHJlbGF0aW9uc2hpcDpcclxuXHQgICAgLy9cclxuXHQgICAgLy8gICBCaW5kaW5nRWxlbWVudHMg4oqGIEFzc2lnbm1lbnRUYXJnZXRzIOKKhiBBc3NpZ25tZW50RXhwcmVzc2lvblxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyB3aXRoIGEgc2luZ2xlIGV4Y2VwdGlvbiB0aGF0IENvdmVySW5pdGlhbGl6ZWROYW1lIHdoZW4gdXNlZCBkaXJlY3RseSBpbiBhbiBFeHByZXNzaW9uLCBnZW5lcmF0ZXNcclxuXHQgICAgLy8gYW4gZWFybHkgZXJyb3IuIFRoZXJlZm9yZSwgd2UgbmVlZCB0aGUgdGhpcmQgc3RhdGUsIGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciwgdG8gdHJhY2sgdGhlXHJcblx0ICAgIC8vIGZpcnN0IHVzYWdlIG9mIENvdmVySW5pdGlhbGl6ZWROYW1lIGFuZCByZXBvcnQgaXQgd2hlbiB3ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHBhcmVudGhlc2VzIHBhaXIuXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIGlzb2xhdGVDb3ZlckdyYW1tYXIgZnVuY3Rpb24gcnVucyB0aGUgZ2l2ZW4gcGFyc2VyIGZ1bmN0aW9uIHdpdGggYSBuZXcgY292ZXIgZ3JhbW1hciBjb250ZXh0LCBhbmQgaXQgZG9lcyBub3RcclxuXHQgICAgLy8gZWZmZWN0IHRoZSBjdXJyZW50IGZsYWdzLiBUaGlzIG1lYW5zIHRoZSBwcm9kdWN0aW9uIHRoZSBwYXJzZXIgcGFyc2VzIGlzIG9ubHkgdXNlZCBhcyBhbiBleHByZXNzaW9uLiBUaGVyZWZvcmVcclxuXHQgICAgLy8gdGhlIENvdmVySW5pdGlhbGl6ZWROYW1lIGNoZWNrIGlzIGNvbmR1Y3RlZC5cclxuXHQgICAgLy9cclxuXHQgICAgLy8gaW5oZXJpdENvdmVyR3JhbW1hciBmdW5jdGlvbiBydW5zIHRoZSBnaXZlbiBwYXJzZSBmdW5jdGlvbiB3aXRoIGEgbmV3IGNvdmVyIGdyYW1tYXIgY29udGV4dCwgYW5kIGl0IHByb3BhZ2F0ZXNcclxuXHQgICAgLy8gdGhlIGZsYWdzIG91dHNpZGUgb2YgdGhlIHBhcnNlci4gVGhpcyBtZWFucyB0aGUgcHJvZHVjdGlvbiB0aGUgcGFyc2VyIHBhcnNlcyBpcyB1c2VkIGFzIGEgcGFydCBvZiBhIHBvdGVudGlhbFxyXG5cdCAgICAvLyBwYXR0ZXJuLiBUaGUgQ292ZXJJbml0aWFsaXplZE5hbWUgY2hlY2sgaXMgZGVmZXJyZWQuXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuaXNvbGF0ZUNvdmVyR3JhbW1hciA9IGZ1bmN0aW9uIChwYXJzZUZ1bmN0aW9uKSB7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJc0JpbmRpbmdFbGVtZW50ID0gdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJc0Fzc2lnbm1lbnRUYXJnZXQgPSB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcjtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VGdW5jdGlvbi5jYWxsKHRoaXMpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBwcmV2aW91c0lzQmluZGluZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gcHJldmlvdXNJc0Fzc2lnbm1lbnRUYXJnZXQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gcHJldmlvdXNGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I7XHJcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmluaGVyaXRDb3ZlckdyYW1tYXIgPSBmdW5jdGlvbiAocGFyc2VGdW5jdGlvbikge1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSXNCaW5kaW5nRWxlbWVudCA9IHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSXNBc3NpZ25tZW50VGFyZ2V0ID0gdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0ZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlRnVuY3Rpb24uY2FsbCh0aGlzKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgJiYgcHJldmlvdXNJc0JpbmRpbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgJiYgcHJldmlvdXNJc0Fzc2lnbm1lbnRUYXJnZXQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gcHJldmlvdXNGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgfHwgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcjtcclxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuY29uc3VtZVNlbWljb2xvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCc7JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8gJiYgIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5sYXN0TWFya2VyLmluZGV4ID0gdGhpcy5zdGFydE1hcmtlci5pbmRleDtcclxuXHQgICAgICAgICAgICB0aGlzLmxhc3RNYXJrZXIubGluZSA9IHRoaXMuc3RhcnRNYXJrZXIubGluZTtcclxuXHQgICAgICAgICAgICB0aGlzLmxhc3RNYXJrZXIuY29sdW1uID0gdGhpcy5zdGFydE1hcmtlci5jb2x1bW47XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByaW1hcnktZXhwcmVzc2lvblxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICB2YXIgdG9rZW4sIHJhdztcclxuXHQgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgMyAvKiBJZGVudGlmaWVyICovOlxyXG5cdCAgICAgICAgICAgICAgICBpZiAoKHRoaXMuY29udGV4dC5pc01vZHVsZSB8fCB0aGlzLmNvbnRleHQuYXdhaXQpICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSAnYXdhaXQnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5tYXRjaEFzeW5jRnVuY3Rpb24oKSA/IHRoaXMucGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKSA6IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0aGlzLm5leHRUb2tlbigpLnZhbHVlKSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNiAvKiBOdW1lcmljTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDggLyogU3RyaW5nTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgdGhpcy5sb29rYWhlYWQub2N0YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQsIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkxpdGVyYWwodG9rZW4udmFsdWUsIHJhdykpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDEgLyogQm9vbGVhbkxpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTGl0ZXJhbCh0b2tlbi52YWx1ZSA9PT0gJ3RydWUnLCByYXcpKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA1IC8qIE51bGxMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkxpdGVyYWwobnVsbCwgcmF3KSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgMTAgLyogVGVtcGxhdGUgKi86XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlVGVtcGxhdGVMaXRlcmFsKCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNyAvKiBQdW5jdHVhdG9yICovOlxyXG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICcoJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUdyb3VwRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdbJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBcnJheUluaXRpYWxpemVyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3snOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZU9iamVjdEluaXRpYWxpemVyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnLz0nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5pbmRleCA9IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLm5leHRSZWdleFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuUmVnZXhMaXRlcmFsKHRva2VuLnJlZ2V4LCByYXcsIHRva2VuLnBhdHRlcm4sIHRva2VuLmZsYWdzKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNCAvKiBLZXl3b3JkICovOlxyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5zdHJpY3QgJiYgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ3lpZWxkJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLm1hdGNoS2V5d29yZCgnbGV0JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIodGhpcy5uZXh0VG9rZW4oKS52YWx1ZSkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZnVuY3Rpb24nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlRnVuY3Rpb25FeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoS2V5d29yZCgndGhpcycpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UaGlzRXhwcmVzc2lvbigpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdjbGFzcycpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VDbGFzc0V4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LWluaXRpYWxpemVyXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTcHJlYWRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcuLi4nKTtcclxuXHQgICAgICAgIHZhciBhcmcgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlNwcmVhZEVsZW1lbnQoYXJnKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBcnJheUluaXRpYWxpemVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ1snKTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnXScpKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG51bGwpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcuLi4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VTcHJlYWRFbGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnXScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnXScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ10nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFycmF5RXhwcmVzc2lvbihlbGVtZW50cykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QtaW5pdGlhbGl6ZXJcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByb3BlcnR5TWV0aG9kID0gZnVuY3Rpb24gKHBhcmFtcykge1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZSA9IHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IHBhcmFtcy5zaW1wbGU7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBwYXJhbXMuZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihwYXJhbXMuZmlyc3RSZXN0cmljdGVkLCBwYXJhbXMubWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBwYXJhbXMuc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHBhcmFtcy5zdHJpY3RlZCwgcGFyYW1zLm1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgIHJldHVybiBib2R5O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJvcGVydHlNZXRob2RGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoKTtcclxuXHQgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2QocGFyYW1zKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRnVuY3Rpb25FeHByZXNzaW9uKG51bGwsIHBhcmFtcy5wYXJhbXMsIG1ldGhvZCwgaXNHZW5lcmF0b3IpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByb3BlcnR5TWV0aG9kQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBd2FpdCA9IHRoaXMuY29udGV4dC5hd2FpdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKCk7XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kKHBhcmFtcyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IHByZXZpb3VzQXdhaXQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Bc3luY0Z1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBwYXJhbXMucGFyYW1zLCBtZXRob2QpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9iamVjdFByb3BlcnR5S2V5ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB2YXIga2V5O1xyXG5cdCAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSA4IC8qIFN0cmluZ0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA2IC8qIE51bWVyaWNMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiB0b2tlbi5vY3RhbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHZhciByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5MaXRlcmFsKHRva2VuLnZhbHVlLCByYXcpKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAzIC8qIElkZW50aWZpZXIgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSAxIC8qIEJvb2xlYW5MaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNSAvKiBOdWxsTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDQgLyogS2V5d29yZCAqLzpcclxuXHQgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKHRva2VuLnZhbHVlKSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNyAvKiBQdW5jdHVhdG9yICovOlxyXG5cdCAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdbJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnXScpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAga2V5ID0gdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ga2V5O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmlzUHJvcGVydHlLZXkgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG5cdCAgICAgICAgcmV0dXJuIChrZXkudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIgJiYga2V5Lm5hbWUgPT09IHZhbHVlKSB8fFxyXG5cdCAgICAgICAgICAgIChrZXkudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkxpdGVyYWwgJiYga2V5LnZhbHVlID09PSB2YWx1ZSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VPYmplY3RQcm9wZXJ0eSA9IGZ1bmN0aW9uIChoYXNQcm90bykge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIGtpbmQ7XHJcblx0ICAgICAgICB2YXIga2V5ID0gbnVsbDtcclxuXHQgICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgY29tcHV0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBtZXRob2QgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBzaG9ydGhhbmQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBpc0FzeW5jID0gZmFsc2U7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0gdG9rZW4udmFsdWU7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBpc0FzeW5jID0gIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IgJiYgKGlkID09PSAnYXN5bmMnKSAmJlxyXG5cdCAgICAgICAgICAgICAgICAhdGhpcy5tYXRjaCgnOicpICYmICF0aGlzLm1hdGNoKCcoJykgJiYgIXRoaXMubWF0Y2goJyonKTtcclxuXHQgICAgICAgICAgICBrZXkgPSBpc0FzeW5jID8gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCkgOiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIoaWQpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJyonKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBsb29rYWhlYWRQcm9wZXJ0eUtleSA9IHRoaXMucXVhbGlmaWVkUHJvcGVydHlOYW1lKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgIWlzQXN5bmMgJiYgdG9rZW4udmFsdWUgPT09ICdnZXQnICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XHJcblx0ICAgICAgICAgICAga2luZCA9ICdnZXQnO1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlR2V0dGVyTWV0aG9kKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgIWlzQXN5bmMgJiYgdG9rZW4udmFsdWUgPT09ICdzZXQnICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XHJcblx0ICAgICAgICAgICAga2luZCA9ICdzZXQnO1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZVNldHRlck1ldGhvZCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIHRva2VuLnZhbHVlID09PSAnKicgJiYgbG9va2FoZWFkUHJvcGVydHlLZXkpIHtcclxuXHQgICAgICAgICAgICBraW5kID0gJ2luaXQnO1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZUdlbmVyYXRvck1ldGhvZCgpO1xyXG5cdCAgICAgICAgICAgIG1ldGhvZCA9IHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBpZiAoIWtleSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAga2luZCA9ICdpbml0JztcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnOicpICYmICFpc0FzeW5jKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghY29tcHV0ZWQgJiYgdGhpcy5pc1Byb3BlcnR5S2V5KGtleSwgJ19fcHJvdG9fXycpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaGFzUHJvdG8udmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5EdXBsaWNhdGVQcm90b1Byb3BlcnR5KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGhhc1Byb3RvLnZhbHVlID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcoJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBpc0FzeW5jID8gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kQXN5bmNGdW5jdGlvbigpIDogdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgbWV0aG9kID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBpZCA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0b2tlbi52YWx1ZSkpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2hvcnRoYW5kID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbml0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXNzaWdubWVudFBhdHRlcm4oaWQsIGluaXQpKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHNob3J0aGFuZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGlkO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlByb3BlcnR5KGtpbmQsIGtleSwgY29tcHV0ZWQsIHZhbHVlLCBtZXRob2QsIHNob3J0aGFuZCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlT2JqZWN0SW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gW107XHJcblx0ICAgICAgICB2YXIgaGFzUHJvdG8gPSB7IHZhbHVlOiBmYWxzZSB9O1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2godGhpcy5wYXJzZU9iamVjdFByb3BlcnR5KGhhc1Byb3RvKSk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDb21tYVNlcGFyYXRvcigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5PYmplY3RFeHByZXNzaW9uKHByb3BlcnRpZXMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbHNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRlbXBsYXRlSGVhZCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydCh0aGlzLmxvb2thaGVhZC5oZWFkLCAnVGVtcGxhdGUgbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSB0ZW1wbGF0ZSBoZWFkJyk7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHZhciByYXcgPSB0b2tlbi52YWx1ZTtcclxuXHQgICAgICAgIHZhciBjb29rZWQgPSB0b2tlbi5jb29rZWQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UZW1wbGF0ZUVsZW1lbnQoeyByYXc6IHJhdywgY29va2VkOiBjb29rZWQgfSwgdG9rZW4udGFpbCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGVtcGxhdGVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDEwIC8qIFRlbXBsYXRlICovKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB2YXIgcmF3ID0gdG9rZW4udmFsdWU7XHJcblx0ICAgICAgICB2YXIgY29va2VkID0gdG9rZW4uY29va2VkO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGVtcGxhdGVFbGVtZW50KHsgcmF3OiByYXcsIGNvb2tlZDogY29va2VkIH0sIHRva2VuLnRhaWwpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRlbXBsYXRlTGl0ZXJhbCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcclxuXHQgICAgICAgIHZhciBxdWFzaXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBxdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZUhlYWQoKTtcclxuXHQgICAgICAgIHF1YXNpcy5wdXNoKHF1YXNpKTtcclxuXHQgICAgICAgIHdoaWxlICghcXVhc2kudGFpbCkge1xyXG5cdCAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSk7XHJcblx0ICAgICAgICAgICAgcXVhc2kgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgcXVhc2lzLnB1c2gocXVhc2kpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGVtcGxhdGVMaXRlcmFsKHF1YXNpcywgZXhwcmVzc2lvbnMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ3JvdXBpbmctb3BlcmF0b3JcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4gPSBmdW5jdGlvbiAoZXhwcikge1xyXG5cdCAgICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyOlxyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4Lk1lbWJlckV4cHJlc3Npb246XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguUmVzdEVsZW1lbnQ6XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudFBhdHRlcm46XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LlNwcmVhZEVsZW1lbnQ6XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIudHlwZSA9IHN5bnRheF8xLlN5bnRheC5SZXN0RWxlbWVudDtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5hcmd1bWVudCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LkFycmF5RXhwcmVzc2lvbjpcclxuXHQgICAgICAgICAgICAgICAgZXhwci50eXBlID0gc3ludGF4XzEuU3ludGF4LkFycmF5UGF0dGVybjtcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZXhwci5lbGVtZW50c1tpXSAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIuZWxlbWVudHNbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4Lk9iamVjdEV4cHJlc3Npb246XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIudHlwZSA9IHN5bnRheF8xLlN5bnRheC5PYmplY3RQYXR0ZXJuO1xyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHIucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5wcm9wZXJ0aWVzW2ldLnZhbHVlKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjpcclxuXHQgICAgICAgICAgICAgICAgZXhwci50eXBlID0gc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuO1xyXG5cdCAgICAgICAgICAgICAgICBkZWxldGUgZXhwci5vcGVyYXRvcjtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5sZWZ0KTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgLy8gQWxsb3cgb3RoZXIgbm9kZSB0eXBlIGZvciB0b2xlcmFudCBwYXJzaW5nLlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUdyb3VwRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnPT4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnPT4nKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgcGFyYW1zOiBbXSxcclxuXHQgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcuLi4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZVJlc3RFbGVtZW50KHBhcmFtcyk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnPT4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0+Jyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtleHByXSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGFycm93ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHJlc3Npb25zW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdyA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBleHByZXNzaW9ucyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcuLi4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VSZXN0RWxlbWVudChwYXJhbXMpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCc9PicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnPT4nKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByZXNzaW9uc1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3cgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogZXhwcmVzc2lvbnMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyb3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnJvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5TZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoIWFycm93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0+JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllciAmJiBleHByLm5hbWUgPT09ICd5aWVsZCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3cgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogW2V4cHJdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJyb3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LlNlcXVlbmNlRXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByLmV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5leHByZXNzaW9uc1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVycyA9IChleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb24gPyBleHByLmV4cHJlc3Npb25zIDogW2V4cHJdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtZXRlcnMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxlZnQtaGFuZC1zaWRlLWV4cHJlc3Npb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBcmd1bWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLm1hdGNoKCcuLi4nKSA/IHRoaXMucGFyc2VTcHJlYWRFbGVtZW50KCkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgIGFyZ3MucHVzaChleHByKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDb21tYVNlcGFyYXRvcigpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICByZXR1cm4gYXJncztcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5pc0lkZW50aWZpZXJOYW1lID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICByZXR1cm4gdG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovIHx8XHJcblx0ICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gNCAvKiBLZXl3b3JkICovIHx8XHJcblx0ICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gMSAvKiBCb29sZWFuTGl0ZXJhbCAqLyB8fFxyXG5cdCAgICAgICAgICAgIHRva2VuLnR5cGUgPT09IDUgLyogTnVsbExpdGVyYWwgKi87XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJZGVudGlmaWVyTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLmlzSWRlbnRpZmllck5hbWUodG9rZW4pKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKHRva2VuLnZhbHVlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VOZXdFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KGlkLm5hbWUgPT09ICduZXcnLCAnTmV3IGV4cHJlc3Npb24gbXVzdCBzdGFydCB3aXRoIGBuZXdgJyk7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcuJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5ICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSAndGFyZ2V0Jykge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IG5ldyBOb2RlLk1ldGFQcm9wZXJ0eShpZCwgcHJvcGVydHkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNhbGxlZSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLm1hdGNoKCcoJykgPyB0aGlzLnBhcnNlQXJndW1lbnRzKCkgOiBbXTtcclxuXHQgICAgICAgICAgICBleHByID0gbmV3IE5vZGUuTmV3RXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgZXhwcik7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBc3luY0FyZ3VtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGFyZyA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XHJcblx0ICAgICAgICByZXR1cm4gYXJnO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXN5bmNBcmd1bWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLm1hdGNoKCcuLi4nKSA/IHRoaXMucGFyc2VTcHJlYWRFbGVtZW50KCkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3luY0FyZ3VtZW50KTtcclxuXHQgICAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHIpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENvbW1hU2VwYXJhdG9yKCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgIHJldHVybiBhcmdzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgbWF5YmVBc3luYyA9IHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXN5bmMnKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93SW4gPSB0aGlzLmNvbnRleHQuYWxsb3dJbjtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdzdXBlcicpICYmIHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSkge1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKGV4cHIsIG5ldyBOb2RlLlN1cGVyKCkpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKCcpICYmICF0aGlzLm1hdGNoKCcuJykgJiYgIXRoaXMubWF0Y2goJ1snKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMubWF0Y2hLZXl3b3JkKCduZXcnKSA/IHRoaXMucGFyc2VOZXdFeHByZXNzaW9uIDogdGhpcy5wYXJzZVByaW1hcnlFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJy4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJy4nKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5TdGF0aWNNZW1iZXJFeHByZXNzaW9uKGV4cHIsIHByb3BlcnR5KSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJygnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgYXN5bmNBcnJvdyA9IG1heWJlQXN5bmMgJiYgKHN0YXJ0VG9rZW4ubGluZU51bWJlciA9PT0gdGhpcy5sb29rYWhlYWQubGluZU51bWJlcik7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhc3luY0Fycm93ID8gdGhpcy5wYXJzZUFzeW5jQXJndW1lbnRzKCkgOiB0aGlzLnBhcnNlQXJndW1lbnRzKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5DYWxsRXhwcmVzc2lvbihleHByLCBhcmdzKSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChhc3luY0Fycm93ICYmIHRoaXMubWF0Y2goJz0+JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGFyZ3NbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogYXJncyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCdbJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCdbJyk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCddJyk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5Db21wdXRlZE1lbWJlckV4cHJlc3Npb24oZXhwciwgcHJvcGVydHkpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMTAgLyogVGVtcGxhdGUgKi8gJiYgdGhpcy5sb29rYWhlYWQuaGVhZCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcXVhc2kgPSB0aGlzLnBhcnNlVGVtcGxhdGVMaXRlcmFsKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oZXhwciwgcXVhc2kpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTdXBlciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3N1cGVyJyk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ1snKSAmJiAhdGhpcy5tYXRjaCgnLicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5TdXBlcigpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQodGhpcy5jb250ZXh0LmFsbG93SW4sICdjYWxsZWUgb2YgbmV3IGV4cHJlc3Npb24gYWx3YXlzIGFsbG93IGluIGtleXdvcmQuJyk7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIHZhciBleHByID0gKHRoaXMubWF0Y2hLZXl3b3JkKCdzdXBlcicpICYmIHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSkgPyB0aGlzLnBhcnNlU3VwZXIoKSA6XHJcblx0ICAgICAgICAgICAgdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMubWF0Y2hLZXl3b3JkKCduZXcnKSA/IHRoaXMucGFyc2VOZXdFeHByZXNzaW9uIDogdGhpcy5wYXJzZVByaW1hcnlFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ1snKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJ1snKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJ10nKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uKGV4cHIsIHByb3BlcnR5KSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJy4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJy4nKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlN0YXRpY01lbWJlckV4cHJlc3Npb24oZXhwciwgcHJvcGVydHkpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMTAgLyogVGVtcGxhdGUgKi8gJiYgdGhpcy5sb29rYWhlYWQuaGVhZCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcXVhc2kgPSB0aGlzLnBhcnNlVGVtcGxhdGVMaXRlcmFsKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihleHByLCBxdWFzaSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXVwZGF0ZS1leHByZXNzaW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVXBkYXRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcrKycpIHx8IHRoaXMubWF0Y2goJy0tJykpIHtcclxuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pO1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlVW5hcnlFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyICYmIHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKGV4cHIubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0TEhTUHJlZml4KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB2YXIgcHJlZml4ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5VcGRhdGVFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByLCBwcmVmaXgpKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5oYXNMaW5lVGVybWluYXRvciAmJiB0aGlzLmxvb2thaGVhZC50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJysrJykgfHwgdGhpcy5tYXRjaCgnLS0nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllciAmJiB0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChleHByLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0TEhTUG9zdGZpeCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm5leHRUb2tlbigpLnZhbHVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLlVwZGF0ZUV4cHJlc3Npb24ob3BlcmF0b3IsIGV4cHIsIHByZWZpeCkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXVuYXJ5LW9wZXJhdG9yc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXdhaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB2YXIgYXJndW1lbnQgPSB0aGlzLnBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Bd2FpdEV4cHJlc3Npb24oYXJndW1lbnQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVuYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJysnKSB8fCB0aGlzLm1hdGNoKCctJykgfHwgdGhpcy5tYXRjaCgnficpIHx8IHRoaXMubWF0Y2goJyEnKSB8fFxyXG5cdCAgICAgICAgICAgIHRoaXMubWF0Y2hLZXl3b3JkKCdkZWxldGUnKSB8fCB0aGlzLm1hdGNoS2V5d29yZCgndm9pZCcpIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCd0eXBlb2YnKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUodGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlVW5hcnlFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5VbmFyeUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBleHByLm9wZXJhdG9yID09PSAnZGVsZXRlJyAmJiBleHByLmFyZ3VtZW50LnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdERlbGV0ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZXh0LmF3YWl0ICYmIHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXdhaXQnKSkge1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlQXdhaXRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZVVwZGF0ZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRXhwb25lbnRpYXRpb25FeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VVbmFyeUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgaWYgKGV4cHIudHlwZSAhPT0gc3ludGF4XzEuU3ludGF4LlVuYXJ5RXhwcmVzc2lvbiAmJiB0aGlzLm1hdGNoKCcqKicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB2YXIgbGVmdCA9IGV4cHI7XHJcblx0ICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHBvbmVudGlhdGlvbkV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5CaW5hcnlFeHByZXNzaW9uKCcqKicsIGxlZnQsIHJpZ2h0KSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZXhwLW9wZXJhdG9yXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW11bHRpcGxpY2F0aXZlLW9wZXJhdG9yc1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hZGRpdGl2ZS1vcGVyYXRvcnNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYml0d2lzZS1zaGlmdC1vcGVyYXRvcnNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVsYXRpb25hbC1vcGVyYXRvcnNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZXF1YWxpdHktb3BlcmF0b3JzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWJpbmFyeS1iaXR3aXNlLW9wZXJhdG9yc1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1iaW5hcnktbG9naWNhbC1vcGVyYXRvcnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5iaW5hcnlQcmVjZWRlbmNlID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICB2YXIgb3AgPSB0b2tlbi52YWx1ZTtcclxuXHQgICAgICAgIHZhciBwcmVjZWRlbmNlO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLykge1xyXG5cdCAgICAgICAgICAgIHByZWNlZGVuY2UgPSB0aGlzLm9wZXJhdG9yUHJlY2VkZW5jZVtvcF0gfHwgMDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLykge1xyXG5cdCAgICAgICAgICAgIHByZWNlZGVuY2UgPSAob3AgPT09ICdpbnN0YW5jZW9mJyB8fCAodGhpcy5jb250ZXh0LmFsbG93SW4gJiYgb3AgPT09ICdpbicpKSA/IDcgOiAwO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgcHJlY2VkZW5jZSA9IDA7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gcHJlY2VkZW5jZTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJpbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUV4cG9uZW50aWF0aW9uRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBwcmVjID0gdGhpcy5iaW5hcnlQcmVjZWRlbmNlKHRva2VuKTtcclxuXHQgICAgICAgIGlmIChwcmVjID4gMCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdmFyIG1hcmtlcnMgPSBbc3RhcnRUb2tlbiwgdGhpcy5sb29rYWhlYWRdO1xyXG5cdCAgICAgICAgICAgIHZhciBsZWZ0ID0gZXhwcjtcclxuXHQgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUV4cG9uZW50aWF0aW9uRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YWNrID0gW2xlZnQsIHRva2VuLnZhbHVlLCByaWdodF07XHJcblx0ICAgICAgICAgICAgdmFyIHByZWNlZGVuY2VzID0gW3ByZWNdO1xyXG5cdCAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHByZWMgPSB0aGlzLmJpbmFyeVByZWNlZGVuY2UodGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAocHJlYyA8PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAvLyBSZWR1Y2U6IG1ha2UgYSBiaW5hcnkgZXhwcmVzc2lvbiBmcm9tIHRoZSB0aHJlZSB0b3Btb3N0IGVudHJpZXMuXHJcblx0ICAgICAgICAgICAgICAgIHdoaWxlICgoc3RhY2subGVuZ3RoID4gMikgJiYgKHByZWMgPD0gcHJlY2VkZW5jZXNbcHJlY2VkZW5jZXMubGVuZ3RoIC0gMV0pKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gc3RhY2sucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlcy5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzdGFjay5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIG1hcmtlcnMucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKG1hcmtlcnNbbWFya2Vycy5sZW5ndGggLSAxXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpKSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgLy8gU2hpZnQuXHJcblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5uZXh0VG9rZW4oKS52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgICAgIHByZWNlZGVuY2VzLnB1c2gocHJlYyk7XHJcblx0ICAgICAgICAgICAgICAgIG1hcmtlcnMucHVzaCh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHBvbmVudGlhdGlvbkV4cHJlc3Npb24pKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgLy8gRmluYWwgcmVkdWNlIHRvIGNsZWFuLXVwIHRoZSBzdGFjay5cclxuXHQgICAgICAgICAgICB2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHN0YWNrW2ldO1xyXG5cdCAgICAgICAgICAgIG1hcmtlcnMucG9wKCk7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKGkgPiAxKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUobWFya2Vycy5wb3AoKSk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHN0YWNrW2kgLSAxXTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgc3RhY2tbaSAtIDJdLCBleHByKSk7XHJcblx0ICAgICAgICAgICAgICAgIGkgLT0gMjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY29uZGl0aW9uYWwtb3BlcmF0b3JcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQmluYXJ5RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnPycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIHZhciBjb25zZXF1ZW50ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJzonKTtcclxuXHQgICAgICAgICAgICB2YXIgYWx0ZXJuYXRlID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLkNvbmRpdGlvbmFsRXhwcmVzc2lvbihleHByLCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hc3NpZ25tZW50LW9wZXJhdG9yc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmNoZWNrUGF0dGVyblBhcmFtID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmFtKSB7XHJcblx0ICAgICAgICBzd2l0Y2ggKHBhcmFtLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyOlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGFyYW0ob3B0aW9ucywgcGFyYW0sIHBhcmFtLm5hbWUpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5SZXN0RWxlbWVudDpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbS5hcmd1bWVudCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuOlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLmxlZnQpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5BcnJheVBhdHRlcm46XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW0uZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbS5lbGVtZW50c1tpXSAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0uZWxlbWVudHNbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4Lk9iamVjdFBhdHRlcm46XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW0ucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbS5wcm9wZXJ0aWVzW2ldLnZhbHVlKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIG9wdGlvbnMuc2ltcGxlID0gb3B0aW9ucy5zaW1wbGUgJiYgKHBhcmFtIGluc3RhbmNlb2YgTm9kZS5JZGVudGlmaWVyKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5yZWludGVycHJldEFzQ292ZXJGb3JtYWxzTGlzdCA9IGZ1bmN0aW9uIChleHByKSB7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gW2V4cHJdO1xyXG5cdCAgICAgICAgdmFyIG9wdGlvbnM7XHJcblx0ICAgICAgICB2YXIgYXN5bmNBcnJvdyA9IGZhbHNlO1xyXG5cdCAgICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyOlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXI6XHJcblx0ICAgICAgICAgICAgICAgIHBhcmFtcyA9IGV4cHIucGFyYW1zO1xyXG5cdCAgICAgICAgICAgICAgICBhc3luY0Fycm93ID0gZXhwci5hc3luYztcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBvcHRpb25zID0ge1xyXG5cdCAgICAgICAgICAgIHNpbXBsZTogdHJ1ZSxcclxuXHQgICAgICAgICAgICBwYXJhbVNldDoge31cclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1tpXTtcclxuXHQgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChwYXJhbS5yaWdodC50eXBlID09PSBzeW50YXhfMS5TeW50YXguWWllbGRFeHByZXNzaW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW0ucmlnaHQuYXJndW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHBhcmFtLnJpZ2h0LnR5cGUgPSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHBhcmFtLnJpZ2h0Lm5hbWUgPSAneWllbGQnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtLnJpZ2h0LmFyZ3VtZW50O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtLnJpZ2h0LmRlbGVnYXRlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGFzeW5jQXJyb3cgJiYgcGFyYW0udHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIgJiYgcGFyYW0ubmFtZSA9PT0gJ2F3YWl0Jykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbSk7XHJcblx0ICAgICAgICAgICAgcGFyYW1zW2ldID0gcGFyYW07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCB8fCAhdGhpcy5jb250ZXh0LmFsbG93WWllbGQpIHtcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSBwYXJhbXNbaV07XHJcblx0ICAgICAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBzeW50YXhfMS5TeW50YXguWWllbGRFeHByZXNzaW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChvcHRpb25zLm1lc3NhZ2UgPT09IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5jb250ZXh0LnN0cmljdCA/IG9wdGlvbnMuc3RyaWN0ZWQgOiBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZDtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBvcHRpb25zLm1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBzaW1wbGU6IG9wdGlvbnMuc2ltcGxlLFxyXG5cdCAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxyXG5cdCAgICAgICAgICAgIHN0cmljdGVkOiBvcHRpb25zLnN0cmljdGVkLFxyXG5cdCAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZDogb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQsXHJcblx0ICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucy5tZXNzYWdlXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmFsbG93WWllbGQgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ3lpZWxkJykpIHtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZVlpZWxkRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSBzdGFydFRva2VuO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiAodG9rZW4ubGluZU51bWJlciA9PT0gdGhpcy5sb29rYWhlYWQubGluZU51bWJlcikgJiYgdG9rZW4udmFsdWUgPT09ICdhc3luYycpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyB8fCB0aGlzLm1hdGNoS2V5d29yZCgneWllbGQnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IHRoaXMucGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oYXJnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFthcmddLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChleHByLnR5cGUgPT09IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIgfHwgdGhpcy5tYXRjaCgnPT4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJvdy1mdW5jdGlvbi1kZWZpbml0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBpc0FzeW5jID0gZXhwci5hc3luYztcclxuXHQgICAgICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnJlaW50ZXJwcmV0QXNDb3ZlckZvcm1hbHNMaXN0KGV4cHIpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAobGlzdCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0ID0gdGhpcy5jb250ZXh0LnN0cmljdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlID0gdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gbGlzdC5zaW1wbGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBd2FpdCA9IHRoaXMuY29udGV4dC5hd2FpdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IGlzQXN5bmM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0+Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYm9keSA9IHZvaWQgMDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCd7JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBib2R5LnR5cGUgIT09IHN5bnRheF8xLlN5bnRheC5CbG9ja1N0YXRlbWVudDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGxpc3QuZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihsaXN0LmZpcnN0UmVzdHJpY3RlZCwgbGlzdC5tZXNzYWdlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGxpc3Quc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGxpc3Quc3RyaWN0ZWQsIGxpc3QubWVzc2FnZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0gaXNBc3luYyA/IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXN5bmNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihsaXN0LnBhcmFtcywgYm9keSwgZXhwcmVzc2lvbikpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFycm93RnVuY3Rpb25FeHByZXNzaW9uKGxpc3QucGFyYW1zLCBib2R5LCBleHByZXNzaW9uKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBwcmV2aW91c0F3YWl0O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEFzc2lnbigpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBleHByO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdExIU0Fzc2lnbm1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZC5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdG9rZW4udmFsdWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5Bc3NpZ25tZW50RXhwcmVzc2lvbihvcGVyYXRvciwgZXhwciwgcmlnaHQpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNvbW1hLW9wZXJhdG9yXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XHJcblx0ICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChleHByKTtcclxuXHQgICAgICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuU2VxdWVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb25zKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYmxvY2tcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0YXRlbWVudExpc3RJdGVtID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSB0cnVlO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLykge1xyXG5cdCAgICAgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnZXhwb3J0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzTW9kdWxlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCwgbWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsRXhwb3J0RGVjbGFyYXRpb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUV4cG9ydERlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnaW1wb3J0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzTW9kdWxlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCwgbWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsSW1wb3J0RGVjbGFyYXRpb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUltcG9ydERlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnY29uc3QnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUxleGljYWxEZWNsYXJhdGlvbih7IGluRm9yOiBmYWxzZSB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VDbGFzc0RlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnbGV0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMuaXNMZXhpY2FsRGVjbGFyYXRpb24oKSA/IHRoaXMucGFyc2VMZXhpY2FsRGVjbGFyYXRpb24oeyBpbkZvcjogZmFsc2UgfSkgOiB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBzdGF0ZW1lbnQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VCbG9jayA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgdmFyIGJsb2NrID0gW107XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGJsb2NrLnB1c2godGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkJsb2NrU3RhdGVtZW50KGJsb2NrKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxldC1hbmQtY29uc3QtZGVjbGFyYXRpb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VMZXhpY2FsQmluZGluZyA9IGZ1bmN0aW9uIChraW5kLCBvcHRpb25zKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZVBhdHRlcm4ocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGlkLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKGlkLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFZhck5hbWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgIGlmIChraW5kID09PSAnY29uc3QnKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoS2V5d29yZCgnaW4nKSAmJiAhdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdvZicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5EZWNsYXJhdGlvbk1pc3NpbmdJbml0aWFsaXplciwgJ2NvbnN0Jyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICgoIW9wdGlvbnMuaW5Gb3IgJiYgaWQudHlwZSAhPT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpIHx8IHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc9Jyk7XHJcblx0ICAgICAgICAgICAgaW5pdCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VCaW5kaW5nTGlzdCA9IGZ1bmN0aW9uIChraW5kLCBvcHRpb25zKSB7XHJcblx0ICAgICAgICB2YXIgbGlzdCA9IFt0aGlzLnBhcnNlTGV4aWNhbEJpbmRpbmcoa2luZCwgb3B0aW9ucyldO1xyXG5cdCAgICAgICAgd2hpbGUgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgbGlzdC5wdXNoKHRoaXMucGFyc2VMZXhpY2FsQmluZGluZyhraW5kLCBvcHRpb25zKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gbGlzdDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5pc0xleGljYWxEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc2Nhbm5lci5zYXZlU3RhdGUoKTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcclxuXHQgICAgICAgIHZhciBuZXh0ID0gdGhpcy5zY2FubmVyLmxleCgpO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLnJlc3RvcmVTdGF0ZShzdGF0ZSk7XHJcblx0ICAgICAgICByZXR1cm4gKG5leHQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB8fFxyXG5cdCAgICAgICAgICAgIChuZXh0LnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiBuZXh0LnZhbHVlID09PSAnWycpIHx8XHJcblx0ICAgICAgICAgICAgKG5leHQudHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIG5leHQudmFsdWUgPT09ICd7JykgfHxcclxuXHQgICAgICAgICAgICAobmV4dC50eXBlID09PSA0IC8qIEtleXdvcmQgKi8gJiYgbmV4dC52YWx1ZSA9PT0gJ2xldCcpIHx8XHJcblx0ICAgICAgICAgICAgKG5leHQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovICYmIG5leHQudmFsdWUgPT09ICd5aWVsZCcpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTGV4aWNhbERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIga2luZCA9IHRoaXMubmV4dFRva2VuKCkudmFsdWU7XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQoa2luZCA9PT0gJ2xldCcgfHwga2luZCA9PT0gJ2NvbnN0JywgJ0xleGljYWwgZGVjbGFyYXRpb24gbXVzdCBiZSBlaXRoZXIgbGV0IG9yIGNvbnN0Jyk7XHJcblx0ICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KGtpbmQsIG9wdGlvbnMpO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1kZXN0cnVjdHVyaW5nLWJpbmRpbmctcGF0dGVybnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJpbmRpbmdSZXN0RWxlbWVudCA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnLi4uJyk7XHJcblx0ICAgICAgICB2YXIgYXJnID0gdGhpcy5wYXJzZVBhdHRlcm4ocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlJlc3RFbGVtZW50KGFyZykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXJyYXlQYXR0ZXJuID0gZnVuY3Rpb24gKHBhcmFtcywga2luZCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCdbJyk7XHJcblx0ICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnXScpKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG51bGwpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJy4uLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHRoaXMucGFyc2VCaW5kaW5nUmVzdEVsZW1lbnQocGFyYW1zLCBraW5kKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2godGhpcy5wYXJzZVBhdHRlcm5XaXRoRGVmYXVsdChwYXJhbXMsIGtpbmQpKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ10nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCddJyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5BcnJheVBhdHRlcm4oZWxlbWVudHMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByb3BlcnR5UGF0dGVybiA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgY29tcHV0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBzaG9ydGhhbmQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBtZXRob2QgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBrZXk7XHJcblx0ICAgICAgICB2YXIgdmFsdWU7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGtleVRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIHZhciBpbml0ID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKGtleVRva2VuLnZhbHVlKSk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChrZXlUb2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIHNob3J0aGFuZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShrZXlUb2tlbiksIG5ldyBOb2RlLkFzc2lnbm1lbnRQYXR0ZXJuKGluaXQsIGV4cHIpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMubWF0Y2goJzonKSkge1xyXG5cdCAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChrZXlUb2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIHNob3J0aGFuZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gaW5pdDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc6Jyk7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZVBhdHRlcm5XaXRoRGVmYXVsdChwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc6Jyk7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlUGF0dGVybldpdGhEZWZhdWx0KHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Qcm9wZXJ0eSgnaW5pdCcsIGtleSwgY29tcHV0ZWQsIHZhbHVlLCBtZXRob2QsIHNob3J0aGFuZCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlT2JqZWN0UGF0dGVybiA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcHJvcGVydGllcyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHRoaXMucGFyc2VQcm9wZXJ0eVBhdHRlcm4ocGFyYW1zLCBraW5kKSk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuT2JqZWN0UGF0dGVybihwcm9wZXJ0aWVzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQYXR0ZXJuID0gZnVuY3Rpb24gKHBhcmFtcywga2luZCkge1xyXG5cdCAgICAgICAgdmFyIHBhdHRlcm47XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnWycpKSB7XHJcblx0ICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMucGFyc2VBcnJheVBhdHRlcm4ocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJ3snKSkge1xyXG5cdCAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLnBhcnNlT2JqZWN0UGF0dGVybihwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdsZXQnKSAmJiAoa2luZCA9PT0gJ2NvbnN0JyB8fCBraW5kID09PSAnbGV0JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCwgbWVzc2FnZXNfMS5NZXNzYWdlcy5MZXRJbkxleGljYWxCaW5kaW5nKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgcGFyYW1zLnB1c2godGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKGtpbmQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHBhdHRlcm47XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQgPSBmdW5jdGlvbiAocGFyYW1zLCBraW5kKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIHBhdHRlcm4gPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQXNzaWdubWVudFBhdHRlcm4ocGF0dGVybiwgcmlnaHQpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBwYXR0ZXJuO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy12YXJpYWJsZS1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZhcmlhYmxlSWRlbnRpZmllciA9IGZ1bmN0aW9uIChraW5kKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8gJiYgdG9rZW4udmFsdWUgPT09ICd5aWVsZCcpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlICE9PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiB0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8gJiYgdGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgfHwgdG9rZW4udmFsdWUgIT09ICdsZXQnIHx8IGtpbmQgIT09ICd2YXInKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKCh0aGlzLmNvbnRleHQuaXNNb2R1bGUgfHwgdGhpcy5jb250ZXh0LmF3YWl0KSAmJiB0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgdG9rZW4udmFsdWUgPT09ICdhd2FpdCcpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIodG9rZW4udmFsdWUpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VQYXR0ZXJuKHBhcmFtcywgJ3ZhcicpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgaWQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQoaWQubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0VmFyTmFtZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgaW5pdCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoaWQudHlwZSAhPT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIgJiYgIW9wdGlvbnMuaW5Gb3IpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnPScpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0ICAgICAgICB2YXIgb3B0ID0geyBpbkZvcjogb3B0aW9ucy5pbkZvciB9O1xyXG5cdCAgICAgICAgdmFyIGxpc3QgPSBbXTtcclxuXHQgICAgICAgIGxpc3QucHVzaCh0aGlzLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbihvcHQpKTtcclxuXHQgICAgICAgIHdoaWxlICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGxpc3QucHVzaCh0aGlzLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbihvcHQpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBsaXN0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVmFyaWFibGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd2YXInKTtcclxuXHQgICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSB0aGlzLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoeyBpbkZvcjogZmFsc2UgfSk7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCAndmFyJykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lbXB0eS1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUVtcHR5U3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCc7Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FbXB0eVN0YXRlbWVudCgpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZXhwcmVzc2lvbi1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaWYtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJZkNsYXVzZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMubWF0Y2hLZXl3b3JkKCdmdW5jdGlvbicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUlmU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBjb25zZXF1ZW50O1xyXG5cdCAgICAgICAgdmFyIGFsdGVybmF0ZSA9IG51bGw7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2lmJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIHRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykgJiYgdGhpcy5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIGNvbnNlcXVlbnQgPSB0aGlzLmZpbmFsaXplKHRoaXMuY3JlYXRlTm9kZSgpLCBuZXcgTm9kZS5FbXB0eVN0YXRlbWVudCgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgY29uc2VxdWVudCA9IHRoaXMucGFyc2VJZkNsYXVzZSgpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZWxzZScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGFsdGVybmF0ZSA9IHRoaXMucGFyc2VJZkNsYXVzZSgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklmU3RhdGVtZW50KHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1kby13aGlsZS1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZURvV2hpbGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdkbycpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSW5JdGVyYXRpb24gPSB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSBwcmV2aW91c0luSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd3aGlsZScpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciB0ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpICYmIHRoaXMuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJzsnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkRvV2hpbGVTdGF0ZW1lbnQoYm9keSwgdGVzdCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy13aGlsZS1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVdoaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd3aGlsZScpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciB0ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpICYmIHRoaXMuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5maW5hbGl6ZSh0aGlzLmNyZWF0ZU5vZGUoKSwgbmV3IE5vZGUuRW1wdHlTdGF0ZW1lbnQoKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgIHZhciBwcmV2aW91c0luSXRlcmF0aW9uID0gdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHRydWU7XHJcblx0ICAgICAgICAgICAgYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSBwcmV2aW91c0luSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuV2hpbGVTdGF0ZW1lbnQodGVzdCwgYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mb3Itc3RhdGVtZW50XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWZvci1pbi1hbmQtZm9yLW9mLXN0YXRlbWVudHNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZvclN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgIHZhciB0ZXN0ID0gbnVsbDtcclxuXHQgICAgICAgIHZhciB1cGRhdGUgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGZvckluID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBsZWZ0LCByaWdodDtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2ZvcicpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCc7JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCd2YXInKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93SW4gPSB0aGlzLmNvbnRleHQuYWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCh7IGluRm9yOiB0cnVlIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ2luJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkZWNsID0gZGVjbGFyYXRpb25zWzBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRlY2wuaW5pdCAmJiAoZGVjbC5pZC50eXBlID09PSBzeW50YXhfMS5TeW50YXguQXJyYXlQYXR0ZXJuIHx8IGRlY2wuaWQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4Lk9iamVjdFBhdHRlcm4gfHwgdGhpcy5jb250ZXh0LnN0cmljdCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5Gb3JJbk9mTG9vcEluaXRpYWxpemVyLCAnZm9yLWluJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywgJ3ZhcicpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgZGVjbGFyYXRpb25zWzBdLmluaXQgPT09IG51bGwgJiYgdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdvZicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywgJ3ZhcicpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZvckluID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywgJ3ZhcicpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc7Jyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2NvbnN0JykgfHwgdGhpcy5tYXRjaEtleXdvcmQoJ2xldCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGtpbmQgPSB0aGlzLm5leHRUb2tlbigpLnZhbHVlO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5zdHJpY3QgJiYgdGhpcy5sb29rYWhlYWQudmFsdWUgPT09ICdpbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLklkZW50aWZpZXIoa2luZCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdChraW5kLCB7IGluRm9yOiB0cnVlIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiBkZWNsYXJhdGlvbnNbMF0uaW5pdCA9PT0gbnVsbCAmJiB0aGlzLm1hdGNoS2V5d29yZCgnaW4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIGRlY2xhcmF0aW9uc1swXS5pbml0ID09PSBudWxsICYmIHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnb2YnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvckluID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgaW5pdFN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dJbiA9IHRoaXMuY29udGV4dC5hbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2luJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCB8fCBpbml0LnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRMSFNJbkZvckluKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihpbml0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdvZicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgfHwgaW5pdC50eXBlID09PSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkTEhTSW5Gb3JMb29wKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihpbml0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9ySW4gPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdFNlcSA9IFtpbml0XTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRTZXEucHVzaCh0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKGluaXRTdGFydFRva2VuKSwgbmV3IE5vZGUuU2VxdWVuY2VFeHByZXNzaW9uKGluaXRTZXEpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc7Jyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCc7JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc7Jyk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdXBkYXRlID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgYm9keTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpICYmIHRoaXMuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5maW5hbGl6ZSh0aGlzLmNyZWF0ZU5vZGUoKSwgbmV3IE5vZGUuRW1wdHlTdGF0ZW1lbnQoKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgIHZhciBwcmV2aW91c0luSXRlcmF0aW9uID0gdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHRydWU7XHJcblx0ICAgICAgICAgICAgYm9keSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlU3RhdGVtZW50KTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSBwcmV2aW91c0luSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpID9cclxuXHQgICAgICAgICAgICB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZvclN0YXRlbWVudChpbml0LCB0ZXN0LCB1cGRhdGUsIGJvZHkpKSA6XHJcblx0ICAgICAgICAgICAgZm9ySW4gPyB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZvckluU3RhdGVtZW50KGxlZnQsIHJpZ2h0LCBib2R5KSkgOlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZvck9mU3RhdGVtZW50KGxlZnQsIHJpZ2h0LCBib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNvbnRpbnVlLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ29udGludWVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdjb250aW51ZScpO1xyXG5cdCAgICAgICAgdmFyIGxhYmVsID0gbnVsbDtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcclxuXHQgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgbGFiZWwgPSBpZDtcclxuXHQgICAgICAgICAgICB2YXIga2V5ID0gJyQnICsgaWQubmFtZTtcclxuXHQgICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNvbnRleHQubGFiZWxTZXQsIGtleSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5rbm93bkxhYmVsLCBpZC5uYW1lKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIGlmIChsYWJlbCA9PT0gbnVsbCAmJiAhdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNvbnRpbnVlU3RhdGVtZW50KGxhYmVsKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWJyZWFrLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQnJlYWtTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdicmVhaycpO1xyXG5cdCAgICAgICAgdmFyIGxhYmVsID0gbnVsbDtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcclxuXHQgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgdmFyIGtleSA9ICckJyArIGlkLm5hbWU7XHJcblx0ICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb250ZXh0LmxhYmVsU2V0LCBrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlVua25vd25MYWJlbCwgaWQubmFtZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGxhYmVsID0gaWQ7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIGlmIChsYWJlbCA9PT0gbnVsbCAmJiAhdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uICYmICF0aGlzLmNvbnRleHQuaW5Td2l0Y2gpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsQnJlYWspO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQnJlYWtTdGF0ZW1lbnQobGFiZWwpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmV0dXJuLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUmV0dXJuU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsUmV0dXJuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3JldHVybicpO1xyXG5cdCAgICAgICAgdmFyIGhhc0FyZ3VtZW50ID0gIXRoaXMubWF0Y2goJzsnKSAmJiAhdGhpcy5tYXRjaCgnfScpICYmXHJcblx0ICAgICAgICAgICAgIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IgJiYgdGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi87XHJcblx0ICAgICAgICB2YXIgYXJndW1lbnQgPSBoYXNBcmd1bWVudCA/IHRoaXMucGFyc2VFeHByZXNzaW9uKCkgOiBudWxsO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5SZXR1cm5TdGF0ZW1lbnQoYXJndW1lbnQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtd2l0aC1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVdpdGhTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdE1vZGVXaXRoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgYm9keTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnd2l0aCcpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciBvYmplY3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykgJiYgdGhpcy5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIGJvZHkgPSB0aGlzLmZpbmFsaXplKHRoaXMuY3JlYXRlTm9kZSgpLCBuZXcgTm9kZS5FbXB0eVN0YXRlbWVudCgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLldpdGhTdGF0ZW1lbnQob2JqZWN0LCBib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN3aXRjaC1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN3aXRjaENhc2UgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRlc3Q7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdGVzdCA9IG51bGw7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2Nhc2UnKTtcclxuXHQgICAgICAgICAgICB0ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCc6Jyk7XHJcblx0ICAgICAgICB2YXIgY29uc2VxdWVudCA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnfScpIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykgfHwgdGhpcy5tYXRjaEtleXdvcmQoJ2Nhc2UnKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgY29uc2VxdWVudC5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlN3aXRjaENhc2UodGVzdCwgY29uc2VxdWVudCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3dpdGNoU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnc3dpdGNoJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIGRpc2NyaW1pbmFudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSW5Td2l0Y2ggPSB0aGlzLmNvbnRleHQuaW5Td2l0Y2g7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5Td2l0Y2ggPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIGNhc2VzID0gW107XHJcblx0ICAgICAgICB2YXIgZGVmYXVsdEZvdW5kID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB2YXIgY2xhdXNlID0gdGhpcy5wYXJzZVN3aXRjaENhc2UoKTtcclxuXHQgICAgICAgICAgICBpZiAoY2xhdXNlLnRlc3QgPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRGb3VuZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0Rm91bmQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBjYXNlcy5wdXNoKGNsYXVzZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluU3dpdGNoID0gcHJldmlvdXNJblN3aXRjaDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlN3aXRjaFN0YXRlbWVudChkaXNjcmltaW5hbnQsIGNhc2VzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxhYmVsbGVkLXN0YXRlbWVudHNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxhYmVsbGVkU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHZhciBzdGF0ZW1lbnQ7XHJcblx0ICAgICAgICBpZiAoKGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpICYmIHRoaXMubWF0Y2goJzonKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0gZXhwcjtcclxuXHQgICAgICAgICAgICB2YXIga2V5ID0gJyQnICsgaWQubmFtZTtcclxuXHQgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29udGV4dC5sYWJlbFNldCwga2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5SZWRlY2xhcmF0aW9uLCAnTGFiZWwnLCBpZC5uYW1lKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmxhYmVsU2V0W2tleV0gPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIHZhciBib2R5ID0gdm9pZCAwO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnY2xhc3MnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMucGFyc2VDbGFzc0RlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdmdW5jdGlvbicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVjbGFyYXRpb24uZ2VuZXJhdG9yKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLkdlbmVyYXRvckluTGVnYWN5Q29udGV4dCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYm9keSA9IGRlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29udGV4dC5sYWJlbFNldFtrZXldO1xyXG5cdCAgICAgICAgICAgIHN0YXRlbWVudCA9IG5ldyBOb2RlLkxhYmVsZWRTdGF0ZW1lbnQoaWQsIGJvZHkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICAgICAgc3RhdGVtZW50ID0gbmV3IE5vZGUuRXhwcmVzc2lvblN0YXRlbWVudChleHByKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIHN0YXRlbWVudCk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRocm93LXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGhyb3dTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd0aHJvdycpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5OZXdsaW5lQWZ0ZXJUaHJvdyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UaHJvd1N0YXRlbWVudChhcmd1bWVudCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10cnktc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDYXRjaENsYXVzZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2NhdGNoJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtID0gdGhpcy5wYXJzZVBhdHRlcm4ocGFyYW1zKTtcclxuXHQgICAgICAgIHZhciBwYXJhbU1hcCA9IHt9O1xyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICB2YXIga2V5ID0gJyQnICsgcGFyYW1zW2ldLnZhbHVlO1xyXG5cdCAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1NYXAsIGtleSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuRHVwbGljYXRlQmluZGluZywgcGFyYW1zW2ldLnZhbHVlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgcGFyYW1NYXBba2V5XSA9IHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBwYXJhbS50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChwYXJhbS5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RDYXRjaFZhcmlhYmxlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlQmxvY2soKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNhdGNoQ2xhdXNlKHBhcmFtLCBib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGaW5hbGx5Q2xhdXNlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdmaW5hbGx5Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJsb2NrKCk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VUcnlTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd0cnknKTtcclxuXHQgICAgICAgIHZhciBibG9jayA9IHRoaXMucGFyc2VCbG9jaygpO1xyXG5cdCAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLm1hdGNoS2V5d29yZCgnY2F0Y2gnKSA/IHRoaXMucGFyc2VDYXRjaENsYXVzZSgpIDogbnVsbDtcclxuXHQgICAgICAgIHZhciBmaW5hbGl6ZXIgPSB0aGlzLm1hdGNoS2V5d29yZCgnZmluYWxseScpID8gdGhpcy5wYXJzZUZpbmFsbHlDbGF1c2UoKSA6IG51bGw7XHJcblx0ICAgICAgICBpZiAoIWhhbmRsZXIgJiYgIWZpbmFsaXplcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLk5vQ2F0Y2hPckZpbmFsbHkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVHJ5U3RhdGVtZW50KGJsb2NrLCBoYW5kbGVyLCBmaW5hbGl6ZXIpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGVidWdnZXItc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VEZWJ1Z2dlclN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2RlYnVnZ2VyJyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkRlYnVnZ2VyU3RhdGVtZW50KCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXN0YXRlbWVudHMtYW5kLWRlY2xhcmF0aW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXRlbWVudDtcclxuXHQgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgMSAvKiBCb29sZWFuTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDUgLyogTnVsbExpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA2IC8qIE51bWVyaWNMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgOCAvKiBTdHJpbmdMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgMTAgLyogVGVtcGxhdGUgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA5IC8qIFJlZ3VsYXJFeHByZXNzaW9uICovOlxyXG5cdCAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDcgLyogUHVuY3R1YXRvciAqLzpcclxuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5sb29rYWhlYWQudmFsdWU7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlQmxvY2soKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gJygnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSAnOycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VFbXB0eVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDMgLyogSWRlbnRpZmllciAqLzpcclxuXHQgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5tYXRjaEFzeW5jRnVuY3Rpb24oKSA/IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCkgOiB0aGlzLnBhcnNlTGFiZWxsZWRTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA0IC8qIEtleXdvcmQgKi86XHJcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JyZWFrJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlQnJlYWtTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbnRpbnVlJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlQ29udGludWVTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RlYnVnZ2VyJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RvJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRG9XaGlsZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9yJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRm9yU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2lmJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlSWZTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JldHVybic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVJldHVyblN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3dpdGNoJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlU3dpdGNoU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd0aHJvdyc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVRocm93U3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd0cnknOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VUcnlTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Zhcic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVZhcmlhYmxlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd3aGlsZSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVdoaWxlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd3aXRoJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlV2l0aFN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHN0YXRlbWVudDtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZnVuY3Rpb24tZGVmaW5pdGlvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZURpcmVjdGl2ZVByb2xvZ3VlcygpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzTGFiZWxTZXQgPSB0aGlzLmNvbnRleHQubGFiZWxTZXQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJbkl0ZXJhdGlvbiA9IHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0luU3dpdGNoID0gdGhpcy5jb250ZXh0LmluU3dpdGNoO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSW5GdW5jdGlvbkJvZHkgPSB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQubGFiZWxTZXQgPSB7fTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluU3dpdGNoID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkgPSB0cnVlO1xyXG5cdCAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgYm9keS5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQubGFiZWxTZXQgPSBwcmV2aW91c0xhYmVsU2V0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gcHJldmlvdXNJbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pblN3aXRjaCA9IHByZXZpb3VzSW5Td2l0Y2g7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkgPSBwcmV2aW91c0luRnVuY3Rpb25Cb2R5O1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQmxvY2tTdGF0ZW1lbnQoYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnZhbGlkYXRlUGFyYW0gPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyYW0sIG5hbWUpIHtcclxuXHQgICAgICAgIHZhciBrZXkgPSAnJCcgKyBuYW1lO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQobmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3RlZCA9IHBhcmFtO1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFBhcmFtTmFtZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLnBhcmFtU2V0LCBrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RyaWN0ZWQgPSBwYXJhbTtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoIW9wdGlvbnMuZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKG5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkID0gcGFyYW07XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UGFyYW1OYW1lO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKG5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkID0gcGFyYW07XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy5wYXJhbVNldCwga2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLnN0cmljdGVkID0gcGFyYW07XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRpb25zLnBhcmFtU2V0LCBrZXksIHsgdmFsdWU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBvcHRpb25zLnBhcmFtU2V0W2tleV0gPSB0cnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUmVzdEVsZW1lbnQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJy4uLicpO1xyXG5cdCAgICAgICAgdmFyIGFyZyA9IHRoaXMucGFyc2VQYXR0ZXJuKHBhcmFtcyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuRGVmYXVsdFJlc3RQYXJhbWV0ZXIpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5QYXJhbWV0ZXJBZnRlclJlc3RQYXJhbWV0ZXIpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuUmVzdEVsZW1lbnQoYXJnKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGb3JtYWxQYXJhbWV0ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtID0gdGhpcy5tYXRjaCgnLi4uJykgPyB0aGlzLnBhcnNlUmVzdEVsZW1lbnQocGFyYW1zKSA6IHRoaXMucGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQocGFyYW1zKTtcclxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVBhcmFtKG9wdGlvbnMsIHBhcmFtc1tpXSwgcGFyYW1zW2ldLnZhbHVlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIG9wdGlvbnMuc2ltcGxlID0gb3B0aW9ucy5zaW1wbGUgJiYgKHBhcmFtIGluc3RhbmNlb2YgTm9kZS5JZGVudGlmaWVyKTtcclxuXHQgICAgICAgIG9wdGlvbnMucGFyYW1zLnB1c2gocGFyYW0pO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRm9ybWFsUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChmaXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgIHZhciBvcHRpb25zO1xyXG5cdCAgICAgICAgb3B0aW9ucyA9IHtcclxuXHQgICAgICAgICAgICBzaW1wbGU6IHRydWUsXHJcblx0ICAgICAgICAgICAgcGFyYW1zOiBbXSxcclxuXHQgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQ6IGZpcnN0UmVzdHJpY3RlZFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgIG9wdGlvbnMucGFyYW1TZXQgPSB7fTtcclxuXHQgICAgICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcihvcHRpb25zKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBzaW1wbGU6IG9wdGlvbnMuc2ltcGxlLFxyXG5cdCAgICAgICAgICAgIHBhcmFtczogb3B0aW9ucy5wYXJhbXMsXHJcblx0ICAgICAgICAgICAgc3RyaWN0ZWQ6IG9wdGlvbnMuc3RyaWN0ZWQsXHJcblx0ICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCxcclxuXHQgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2VcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubWF0Y2hBc3luY0Z1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG1hdGNoID0gdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhc3luYycpO1xyXG5cdCAgICAgICAgaWYgKG1hdGNoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zY2FubmVyLnNhdmVTdGF0ZSgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcclxuXHQgICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuc2Nhbm5lci5sZXgoKTtcclxuXHQgICAgICAgICAgICB0aGlzLnNjYW5uZXIucmVzdG9yZVN0YXRlKHN0YXRlKTtcclxuXHQgICAgICAgICAgICBtYXRjaCA9IChzdGF0ZS5saW5lTnVtYmVyID09PSBuZXh0LmxpbmVOdW1iZXIpICYmIChuZXh0LnR5cGUgPT09IDQgLyogS2V5d29yZCAqLykgJiYgKG5leHQudmFsdWUgPT09ICdmdW5jdGlvbicpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChpZGVudGlmaWVySXNPcHRpb25hbCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpc0FzeW5jID0gdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhc3luYycpO1xyXG5cdCAgICAgICAgaWYgKGlzQXN5bmMpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdmdW5jdGlvbicpO1xyXG5cdCAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gaXNBc3luYyA/IGZhbHNlIDogdGhpcy5tYXRjaCgnKicpO1xyXG5cdCAgICAgICAgaWYgKGlzR2VuZXJhdG9yKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBtZXNzYWdlO1xyXG5cdCAgICAgICAgdmFyIGlkID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBmaXJzdFJlc3RyaWN0ZWQgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKCFpZGVudGlmaWVySXNPcHRpb25hbCB8fCAhdGhpcy5tYXRjaCgnKCcpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgaWQgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XHJcblx0ICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0F3YWl0ID0gdGhpcy5jb250ZXh0LmF3YWl0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gaXNBc3luYztcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gIWlzR2VuZXJhdG9yO1xyXG5cdCAgICAgICAgdmFyIGZvcm1hbFBhcmFtZXRlcnMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycyhmaXJzdFJlc3RyaWN0ZWQpO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zO1xyXG5cdCAgICAgICAgdmFyIHN0cmljdGVkID0gZm9ybWFsUGFyYW1ldGVycy5zdHJpY3RlZDtcclxuXHQgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IGZvcm1hbFBhcmFtZXRlcnMuZmlyc3RSZXN0cmljdGVkO1xyXG5cdCAgICAgICAgaWYgKGZvcm1hbFBhcmFtZXRlcnMubWVzc2FnZSkge1xyXG5cdCAgICAgICAgICAgIG1lc3NhZ2UgPSBmb3JtYWxQYXJhbWV0ZXJzLm1lc3NhZ2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QgPSB0aGlzLmNvbnRleHQuc3RyaWN0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmUgPSB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBmb3JtYWxQYXJhbWV0ZXJzLnNpbXBsZTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihzdHJpY3RlZCwgbWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gcHJldmlvdXNBbGxvd0F3YWl0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICByZXR1cm4gaXNBc3luYyA/IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uKGlkLCBwYXJhbXMsIGJvZHkpKSA6XHJcblx0ICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5GdW5jdGlvbkRlY2xhcmF0aW9uKGlkLCBwYXJhbXMsIGJvZHksIGlzR2VuZXJhdG9yKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGdW5jdGlvbkV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGlzQXN5bmMgPSB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzeW5jJyk7XHJcblx0ICAgICAgICBpZiAoaXNBc3luYykge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2Z1bmN0aW9uJyk7XHJcblx0ICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSBpc0FzeW5jID8gZmFsc2UgOiB0aGlzLm1hdGNoKCcqJyk7XHJcblx0ICAgICAgICBpZiAoaXNHZW5lcmF0b3IpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG1lc3NhZ2U7XHJcblx0ICAgICAgICB2YXIgaWQgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGZpcnN0UmVzdHJpY3RlZDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93QXdhaXQgPSB0aGlzLmNvbnRleHQuYXdhaXQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBpc0FzeW5jO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSAhaXNHZW5lcmF0b3I7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJygnKSkge1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIGlkID0gKCF0aGlzLmNvbnRleHQuc3RyaWN0ICYmICFpc0dlbmVyYXRvciAmJiB0aGlzLm1hdGNoS2V5d29yZCgneWllbGQnKSkgPyB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKSA6IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBmb3JtYWxQYXJhbWV0ZXJzID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoZmlyc3RSZXN0cmljdGVkKTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtcztcclxuXHQgICAgICAgIHZhciBzdHJpY3RlZCA9IGZvcm1hbFBhcmFtZXRlcnMuc3RyaWN0ZWQ7XHJcblx0ICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSBmb3JtYWxQYXJhbWV0ZXJzLmZpcnN0UmVzdHJpY3RlZDtcclxuXHQgICAgICAgIGlmIChmb3JtYWxQYXJhbWV0ZXJzLm1lc3NhZ2UpIHtcclxuXHQgICAgICAgICAgICBtZXNzYWdlID0gZm9ybWFsUGFyYW1ldGVycy5tZXNzYWdlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0ID0gdGhpcy5jb250ZXh0LnN0cmljdDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlID0gdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gZm9ybWFsUGFyYW1ldGVycy5zaW1wbGU7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBmaXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oc3RyaWN0ZWQsIG1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IHByZXZpb3VzQWxsb3dBd2FpdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgcmV0dXJuIGlzQXN5bmMgPyB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFzeW5jRnVuY3Rpb25FeHByZXNzaW9uKGlkLCBwYXJhbXMsIGJvZHkpKSA6XHJcblx0ICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5GdW5jdGlvbkV4cHJlc3Npb24oaWQsIHBhcmFtcywgYm9keSwgaXNHZW5lcmF0b3IpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGlyZWN0aXZlLXByb2xvZ3Vlcy1hbmQtdGhlLXVzZS1zdHJpY3QtZGlyZWN0aXZlXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VEaXJlY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB2YXIgZGlyZWN0aXZlID0gKGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkxpdGVyYWwpID8gdGhpcy5nZXRUb2tlblJhdyh0b2tlbikuc2xpY2UoMSwgLTEpIDogbnVsbDtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgZGlyZWN0aXZlID8gbmV3IE5vZGUuRGlyZWN0aXZlKGV4cHIsIGRpcmVjdGl2ZSkgOiBuZXcgTm9kZS5FeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZURpcmVjdGl2ZVByb2xvZ3VlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBmaXJzdFJlc3RyaWN0ZWQgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IDggLyogU3RyaW5nTGl0ZXJhbCAqLykge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXRlbWVudCA9IHRoaXMucGFyc2VEaXJlY3RpdmUoKTtcclxuXHQgICAgICAgICAgICBib2R5LnB1c2goc3RhdGVtZW50KTtcclxuXHQgICAgICAgICAgICB2YXIgZGlyZWN0aXZlID0gc3RhdGVtZW50LmRpcmVjdGl2ZTtcclxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGRpcmVjdGl2ZSAhPT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChkaXJlY3RpdmUgPT09ICd1c2Ugc3RyaWN0Jykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsTGFuZ3VhZ2VNb2RlRGlyZWN0aXZlKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCFmaXJzdFJlc3RyaWN0ZWQgJiYgdG9rZW4ub2N0YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGJvZHk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW1ldGhvZC1kZWZpbml0aW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnF1YWxpZmllZFByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAzIC8qIElkZW50aWZpZXIgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA4IC8qIFN0cmluZ0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSAxIC8qIEJvb2xlYW5MaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNSAvKiBOdWxsTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDYgLyogTnVtZXJpY0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA0IC8qIEtleXdvcmQgKi86XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNyAvKiBQdW5jdHVhdG9yICovOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4udmFsdWUgPT09ICdbJztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUdldHRlck1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgZm9ybWFsUGFyYW1ldGVycyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKCk7XHJcblx0ICAgICAgICBpZiAoZm9ybWFsUGFyYW1ldGVycy5wYXJhbXMubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkJhZEdldHRlckFyaXR5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2QoZm9ybWFsUGFyYW1ldGVycyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtcywgbWV0aG9kLCBpc0dlbmVyYXRvcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU2V0dGVyTWV0aG9kID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBmb3JtYWxQYXJhbWV0ZXJzID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoKTtcclxuXHQgICAgICAgIGlmIChmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtcy5sZW5ndGggIT09IDEpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5CYWRTZXR0ZXJBcml0eSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmIChmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtc1swXSBpbnN0YW5jZW9mIE5vZGUuUmVzdEVsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5CYWRTZXR0ZXJSZXN0UGFyYW1ldGVyKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2QoZm9ybWFsUGFyYW1ldGVycyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtcywgbWV0aG9kLCBpc0dlbmVyYXRvcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlR2VuZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kKHBhcmFtcyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBwYXJhbXMucGFyYW1zLCBtZXRob2QsIGlzR2VuZXJhdG9yKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdlbmVyYXRvci1mdW5jdGlvbi1kZWZpbml0aW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmlzU3RhcnRPZkV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5sb29rYWhlYWQudmFsdWU7XHJcblx0ICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIDcgLyogUHVuY3R1YXRvciAqLzpcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQgPSAodmFsdWUgPT09ICdbJykgfHwgKHZhbHVlID09PSAnKCcpIHx8ICh2YWx1ZSA9PT0gJ3snKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAnKycpIHx8ICh2YWx1ZSA9PT0gJy0nKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAnIScpIHx8ICh2YWx1ZSA9PT0gJ34nKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAnKysnKSB8fCAodmFsdWUgPT09ICctLScpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICcvJykgfHwgKHZhbHVlID09PSAnLz0nKTsgLy8gcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWxcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA0IC8qIEtleXdvcmQgKi86XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0ID0gKHZhbHVlID09PSAnY2xhc3MnKSB8fCAodmFsdWUgPT09ICdkZWxldGUnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAnZnVuY3Rpb24nKSB8fCAodmFsdWUgPT09ICdsZXQnKSB8fCAodmFsdWUgPT09ICduZXcnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAnc3VwZXInKSB8fCAodmFsdWUgPT09ICd0aGlzJykgfHwgKHZhbHVlID09PSAndHlwZW9mJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJ3ZvaWQnKSB8fCAodmFsdWUgPT09ICd5aWVsZCcpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBzdGFydDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVlpZWxkRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3lpZWxkJyk7XHJcblx0ICAgICAgICB2YXIgYXJndW1lbnQgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGRlbGVnYXRlID0gZmFsc2U7XHJcblx0ICAgICAgICBpZiAoIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcclxuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICBkZWxlZ2F0ZSA9IHRoaXMubWF0Y2goJyonKTtcclxuXHQgICAgICAgICAgICBpZiAoZGVsZWdhdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgYXJndW1lbnQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc1N0YXJ0T2ZFeHByZXNzaW9uKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgYXJndW1lbnQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5ZaWVsZEV4cHJlc3Npb24oYXJndW1lbnQsIGRlbGVnYXRlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNsYXNzLWRlZmluaXRpb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0VsZW1lbnQgPSBmdW5jdGlvbiAoaGFzQ29uc3RydWN0b3IpIHtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBraW5kID0gJyc7XHJcblx0ICAgICAgICB2YXIga2V5ID0gbnVsbDtcclxuXHQgICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgY29tcHV0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBtZXRob2QgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBpc1N0YXRpYyA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGlzQXN5bmMgPSBmYWxzZTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcqJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0ga2V5O1xyXG5cdCAgICAgICAgICAgIGlmIChpZC5uYW1lID09PSAnc3RhdGljJyAmJiAodGhpcy5xdWFsaWZpZWRQcm9wZXJ0eU5hbWUodGhpcy5sb29rYWhlYWQpIHx8IHRoaXMubWF0Y2goJyonKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICAgICAgaXNTdGF0aWMgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyonKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICgodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSAmJiAhdGhpcy5oYXNMaW5lVGVybWluYXRvciAmJiAodG9rZW4udmFsdWUgPT09ICdhc3luYycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwdW5jdHVhdG9yID0gdGhpcy5sb29rYWhlYWQudmFsdWU7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChwdW5jdHVhdG9yICE9PSAnOicgJiYgcHVuY3R1YXRvciAhPT0gJygnICYmIHB1bmN0dWF0b3IgIT09ICcqJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaXNBc3luYyA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnZ2V0JyB8fCB0b2tlbi52YWx1ZSA9PT0gJ3NldCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnY29uc3RydWN0b3InKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuQ29uc3RydWN0b3JJc0FzeW5jKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbG9va2FoZWFkUHJvcGVydHlLZXkgPSB0aGlzLnF1YWxpZmllZFByb3BlcnR5TmFtZSh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnZ2V0JyAmJiBsb29rYWhlYWRQcm9wZXJ0eUtleSkge1xyXG5cdCAgICAgICAgICAgICAgICBraW5kID0gJ2dldCc7XHJcblx0ICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlR2V0dGVyTWV0aG9kKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnc2V0JyAmJiBsb29rYWhlYWRQcm9wZXJ0eUtleSkge1xyXG5cdCAgICAgICAgICAgICAgICBraW5kID0gJ3NldCc7XHJcblx0ICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlU2V0dGVyTWV0aG9kKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIHRva2VuLnZhbHVlID09PSAnKicgJiYgbG9va2FoZWFkUHJvcGVydHlLZXkpIHtcclxuXHQgICAgICAgICAgICBraW5kID0gJ2luaXQnO1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZUdlbmVyYXRvck1ldGhvZCgpO1xyXG5cdCAgICAgICAgICAgIG1ldGhvZCA9IHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIWtpbmQgJiYga2V5ICYmIHRoaXMubWF0Y2goJygnKSkge1xyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnaW5pdCc7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSBpc0FzeW5jID8gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kQXN5bmNGdW5jdGlvbigpIDogdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24oKTtcclxuXHQgICAgICAgICAgICBtZXRob2QgPSB0cnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCFraW5kKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoa2luZCA9PT0gJ2luaXQnKSB7XHJcblx0ICAgICAgICAgICAga2luZCA9ICdtZXRob2QnO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCFjb21wdXRlZCkge1xyXG5cdCAgICAgICAgICAgIGlmIChpc1N0YXRpYyAmJiB0aGlzLmlzUHJvcGVydHlLZXkoa2V5LCAncHJvdG90eXBlJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdGF0aWNQcm90b3R5cGUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoIWlzU3RhdGljICYmIHRoaXMuaXNQcm9wZXJ0eUtleShrZXksICdjb25zdHJ1Y3RvcicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChraW5kICE9PSAnbWV0aG9kJyB8fCAhbWV0aG9kIHx8ICh2YWx1ZSAmJiB2YWx1ZS5nZW5lcmF0b3IpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLkNvbnN0cnVjdG9yU3BlY2lhbE1ldGhvZCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGhhc0NvbnN0cnVjdG9yLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLkR1cGxpY2F0ZUNvbnN0cnVjdG9yKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGhhc0NvbnN0cnVjdG9yLnZhbHVlID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBraW5kID0gJ2NvbnN0cnVjdG9yJztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5NZXRob2REZWZpbml0aW9uKGtleSwgY29tcHV0ZWQsIHZhbHVlLCBraW5kLCBpc1N0YXRpYykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NFbGVtZW50TGlzdCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBib2R5ID0gW107XHJcblx0ICAgICAgICB2YXIgaGFzQ29uc3RydWN0b3IgPSB7IHZhbHVlOiBmYWxzZSB9O1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJzsnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYm9keS5wdXNoKHRoaXMucGFyc2VDbGFzc0VsZW1lbnQoaGFzQ29uc3RydWN0b3IpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgcmV0dXJuIGJvZHk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0JvZHkgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGVsZW1lbnRMaXN0ID0gdGhpcy5wYXJzZUNsYXNzRWxlbWVudExpc3QoKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNsYXNzQm9keShlbGVtZW50TGlzdCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChpZGVudGlmaWVySXNPcHRpb25hbCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnY2xhc3MnKTtcclxuXHQgICAgICAgIHZhciBpZCA9IChpZGVudGlmaWVySXNPcHRpb25hbCAmJiAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMyAvKiBJZGVudGlmaWVyICovKSkgPyBudWxsIDogdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgdmFyIHN1cGVyQ2xhc3MgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdleHRlbmRzJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHN1cGVyQ2xhc3MgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGNsYXNzQm9keSA9IHRoaXMucGFyc2VDbGFzc0JvZHkoKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNsYXNzRGVjbGFyYXRpb24oaWQsIHN1cGVyQ2xhc3MsIGNsYXNzQm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnY2xhc3MnKTtcclxuXHQgICAgICAgIHZhciBpZCA9ICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pID8gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpIDogbnVsbDtcclxuXHQgICAgICAgIHZhciBzdXBlckNsYXNzID0gbnVsbDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZXh0ZW5kcycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBzdXBlckNsYXNzID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBjbGFzc0JvZHkgPSB0aGlzLnBhcnNlQ2xhc3NCb2R5KCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5DbGFzc0V4cHJlc3Npb24oaWQsIHN1cGVyQ2xhc3MsIGNsYXNzQm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zY3JpcHRzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW1vZHVsZXNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU1vZHVsZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzTW9kdWxlID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VEaXJlY3RpdmVQcm9sb2d1ZXMoKTtcclxuXHQgICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgIGJvZHkucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Nb2R1bGUoYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU2NyaXB0ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZURpcmVjdGl2ZVByb2xvZ3VlcygpO1xyXG5cdCAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgYm9keS5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlNjcmlwdChib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWltcG9ydHNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU1vZHVsZVNwZWNpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gOCAvKiBTdHJpbmdMaXRlcmFsICovKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZE1vZHVsZVNwZWNpZmllcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdmFyIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTGl0ZXJhbCh0b2tlbi52YWx1ZSwgcmF3KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGltcG9ydCB7PGZvbyBhcyBiYXI+fSAuLi47XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJbXBvcnRTcGVjaWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGltcG9ydGVkO1xyXG5cdCAgICAgICAgdmFyIGxvY2FsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIGltcG9ydGVkID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIGxvY2FsID0gaW1wb3J0ZWQ7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXMnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBsb2NhbCA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBpbXBvcnRlZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgICAgIGxvY2FsID0gaW1wb3J0ZWQ7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXMnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBsb2NhbCA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSW1wb3J0U3BlY2lmaWVyKGxvY2FsLCBpbXBvcnRlZCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyB7Zm9vLCBiYXIgYXMgYmFzfVxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTmFtZWRJbXBvcnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHZhciBzcGVjaWZpZXJzID0gW107XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyKCkpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHJldHVybiBzcGVjaWZpZXJzO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBpbXBvcnQgPGZvbz4gLi4uO1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSW1wb3J0RGVmYXVsdFNwZWNpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgbG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkltcG9ydERlZmF1bHRTcGVjaWZpZXIobG9jYWwpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaW1wb3J0IDwqIGFzIGZvbz4gLi4uO1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcqJyk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXMnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLk5vQXNBZnRlckltcG9ydE5hbWVzcGFjZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdmFyIGxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIobG9jYWwpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUltcG9ydERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxJbXBvcnREZWNsYXJhdGlvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdpbXBvcnQnKTtcclxuXHQgICAgICAgIHZhciBzcmM7XHJcblx0ICAgICAgICB2YXIgc3BlY2lmaWVycyA9IFtdO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDggLyogU3RyaW5nTGl0ZXJhbCAqLykge1xyXG5cdCAgICAgICAgICAgIC8vIGltcG9ydCAnZm9vJztcclxuXHQgICAgICAgICAgICBzcmMgPSB0aGlzLnBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgneycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGltcG9ydCB7YmFyfVxyXG5cdCAgICAgICAgICAgICAgICBzcGVjaWZpZXJzID0gc3BlY2lmaWVycy5jb25jYXQodGhpcy5wYXJzZU5hbWVkSW1wb3J0cygpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnKicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGltcG9ydCAqIGFzIGZvb1xyXG5cdCAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2godGhpcy5wYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllcigpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0lkZW50aWZpZXJOYW1lKHRoaXMubG9va2FoZWFkKSAmJiAhdGhpcy5tYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBpbXBvcnQgZm9vXHJcblx0ICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh0aGlzLnBhcnNlSW1wb3J0RGVmYXVsdFNwZWNpZmllcigpKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcqJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbXBvcnQgZm9vLCAqIGFzIGZvb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh0aGlzLnBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgneycpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1wb3J0IGZvbywge2Jhcn1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZXJzID0gc3BlY2lmaWVycy5jb25jYXQodGhpcy5wYXJzZU5hbWVkSW1wb3J0cygpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnZnJvbScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5sb29rYWhlYWQudmFsdWUgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiA6IG1lc3NhZ2VzXzEuTWVzc2FnZXMuTWlzc2luZ0Zyb21DbGF1c2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCB0aGlzLmxvb2thaGVhZC52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgc3JjID0gdGhpcy5wYXJzZU1vZHVsZVNwZWNpZmllcigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JbXBvcnREZWNsYXJhdGlvbihzcGVjaWZpZXJzLCBzcmMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZXhwb3J0c1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRXhwb3J0U3BlY2lmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBsb2NhbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgdmFyIGV4cG9ydGVkID0gbG9jYWw7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBleHBvcnRlZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0U3BlY2lmaWVyKGxvY2FsLCBleHBvcnRlZCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRXhwb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbEV4cG9ydERlY2xhcmF0aW9uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2V4cG9ydCcpO1xyXG5cdCAgICAgICAgdmFyIGV4cG9ydERlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykpIHtcclxuXHQgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCAuLi5cclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZnVuY3Rpb24nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb28gKCkge31cclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge31cclxuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24odHJ1ZSk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2NsYXNzJykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgY2xhc3MgZm9vIHt9XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VDbGFzc0RlY2xhcmF0aW9uKHRydWUpO1xyXG5cdCAgICAgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXN5bmMnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBmICgpIHt9XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uICgpIHt9XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGFzeW5jIHggPT4geFxyXG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLm1hdGNoQXN5bmNGdW5jdGlvbigpID8gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24odHJ1ZSkgOiB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihkZWNsYXJhdGlvbikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnZnJvbScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sIHRoaXMubG9va2FoZWFkLnZhbHVlKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCB7fTtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgW107XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0ICgxICsgMik7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMubWF0Y2goJ3snKSA/IHRoaXMucGFyc2VPYmplY3RJbml0aWFsaXplcigpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goJ1snKSA/IHRoaXMucGFyc2VBcnJheUluaXRpYWxpemVyKCkgOiB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcqJykpIHtcclxuXHQgICAgICAgICAgICAvLyBleHBvcnQgKiBmcm9tICdmb28nO1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMubG9va2FoZWFkLnZhbHVlID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4gOiBtZXNzYWdlc18xLk1lc3NhZ2VzLk1pc3NpbmdGcm9tQ2xhdXNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgdGhpcy5sb29rYWhlYWQudmFsdWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHZhciBzcmMgPSB0aGlzLnBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydEFsbERlY2xhcmF0aW9uKHNyYykpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovKSB7XHJcblx0ICAgICAgICAgICAgLy8gZXhwb3J0IHZhciBmID0gMTtcclxuXHQgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB2b2lkIDA7XHJcblx0ICAgICAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC52YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdsZXQnOlxyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdjb25zdCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VMZXhpY2FsRGVjbGFyYXRpb24oeyBpbkZvcjogZmFsc2UgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAndmFyJzpcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnY2xhc3MnOlxyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydE5hbWVkRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIFtdLCBudWxsKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoQXN5bmNGdW5jdGlvbigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0TmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwgW10sIG51bGwpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhciBzcGVjaWZpZXJzID0gW107XHJcblx0ICAgICAgICAgICAgdmFyIHNvdXJjZSA9IG51bGw7XHJcblx0ICAgICAgICAgICAgdmFyIGlzRXhwb3J0RnJvbUlkZW50aWZpZXIgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlzRXhwb3J0RnJvbUlkZW50aWZpZXIgPSBpc0V4cG9ydEZyb21JZGVudGlmaWVyIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCdkZWZhdWx0Jyk7XHJcblx0ICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVyKCkpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQge2RlZmF1bHR9IGZyb20gJ2Zvbyc7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCB7Zm9vfSBmcm9tICdmb28nO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBzb3VyY2UgPSB0aGlzLnBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChpc0V4cG9ydEZyb21JZGVudGlmaWVyKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCB7ZGVmYXVsdH07IC8vIG1pc3NpbmcgZnJvbUNsYXVzZVxyXG5cdCAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMubG9va2FoZWFkLnZhbHVlID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4gOiBtZXNzYWdlc18xLk1lc3NhZ2VzLk1pc3NpbmdGcm9tQ2xhdXNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgdGhpcy5sb29rYWhlYWQudmFsdWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IHtmb299O1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydE5hbWVkRGVjbGFyYXRpb24obnVsbCwgc3BlY2lmaWVycywgc291cmNlKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwb3J0RGVjbGFyYXRpb247XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBQYXJzZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcclxuXG5cbi8qKiovIH0sXG4vKiA5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHQvLyBFbnN1cmUgdGhlIGNvbmRpdGlvbiBpcyB0cnVlLCBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3IuXHJcblx0Ly8gVGhpcyBpcyBvbmx5IHRvIGhhdmUgYSBiZXR0ZXIgY29udHJhY3Qgc2VtYW50aWMsIGkuZS4gYW5vdGhlciBzYWZldHkgbmV0XHJcblx0Ly8gdG8gY2F0Y2ggYSBsb2dpYyBlcnJvci4gVGhlIGNvbmRpdGlvbiBzaGFsbCBiZSBmdWxmaWxsZWQgaW4gbm9ybWFsIGNhc2UuXHJcblx0Ly8gRG8gTk9UIHVzZSB0aGlzIHRvIGVuZm9yY2UgYSBjZXJ0YWluIGNvbmRpdGlvbiBvbiBhbnkgdXNlciBpbnB1dC5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0ZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xyXG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuXHQgICAgaWYgKCFjb25kaXRpb24pIHtcclxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignQVNTRVJUOiAnICsgbWVzc2FnZSk7XHJcblx0ICAgIH1cclxuXHR9XHJcblx0ZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XHJcblxuXG4vKioqLyB9LFxuLyogMTAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdC8qIHRzbGludDpkaXNhYmxlOm1heC1jbGFzc2VzLXBlci1maWxlICovXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBFcnJvckhhbmRsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFcnJvckhhbmRsZXIoKSB7XHJcblx0ICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy50b2xlcmFudCA9IGZhbHNlO1xyXG5cdCAgICB9XHJcblx0ICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUucmVjb3JkRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goZXJyb3IpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLnRvbGVyYXRlID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMucmVjb3JkRXJyb3IoZXJyb3IpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUuY29uc3RydWN0RXJyb3IgPSBmdW5jdGlvbiAobXNnLCBjb2x1bW4pIHtcclxuXHQgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihtc2cpO1xyXG5cdCAgICAgICAgdHJ5IHtcclxuXHQgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGNhdGNoIChiYXNlKSB7XHJcblx0ICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuXHQgICAgICAgICAgICBpZiAoT2JqZWN0LmNyZWF0ZSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcclxuXHQgICAgICAgICAgICAgICAgZXJyb3IgPSBPYmplY3QuY3JlYXRlKGJhc2UpO1xyXG5cdCAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3IsICdjb2x1bW4nLCB7IHZhbHVlOiBjb2x1bW4gfSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgICAgICAgIHJldHVybiBlcnJvcjtcclxuXHQgICAgfTtcclxuXHQgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVFcnJvciA9IGZ1bmN0aW9uIChpbmRleCwgbGluZSwgY29sLCBkZXNjcmlwdGlvbikge1xyXG5cdCAgICAgICAgdmFyIG1zZyA9ICdMaW5lICcgKyBsaW5lICsgJzogJyArIGRlc2NyaXB0aW9uO1xyXG5cdCAgICAgICAgdmFyIGVycm9yID0gdGhpcy5jb25zdHJ1Y3RFcnJvcihtc2csIGNvbCk7XHJcblx0ICAgICAgICBlcnJvci5pbmRleCA9IGluZGV4O1xyXG5cdCAgICAgICAgZXJyb3IubGluZU51bWJlciA9IGxpbmU7XHJcblx0ICAgICAgICBlcnJvci5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xyXG5cdCAgICAgICAgcmV0dXJuIGVycm9yO1xyXG5cdCAgICB9O1xyXG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLnRocm93RXJyb3IgPSBmdW5jdGlvbiAoaW5kZXgsIGxpbmUsIGNvbCwgZGVzY3JpcHRpb24pIHtcclxuXHQgICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IoaW5kZXgsIGxpbmUsIGNvbCwgZGVzY3JpcHRpb24pO1xyXG5cdCAgICB9O1xyXG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLnRvbGVyYXRlRXJyb3IgPSBmdW5jdGlvbiAoaW5kZXgsIGxpbmUsIGNvbCwgZGVzY3JpcHRpb24pIHtcclxuXHQgICAgICAgIHZhciBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoaW5kZXgsIGxpbmUsIGNvbCwgZGVzY3JpcHRpb24pO1xyXG5cdCAgICAgICAgaWYgKHRoaXMudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnJlY29yZEVycm9yKGVycm9yKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gRXJyb3JIYW5kbGVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FcnJvckhhbmRsZXIgPSBFcnJvckhhbmRsZXI7XHJcblxuXG4vKioqLyB9LFxuLyogMTEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHQvLyBFcnJvciBtZXNzYWdlcyBzaG91bGQgYmUgaWRlbnRpY2FsIHRvIFY4LlxyXG5cdGV4cG9ydHMuTWVzc2FnZXMgPSB7XHJcblx0ICAgIEJhZEdldHRlckFyaXR5OiAnR2V0dGVyIG11c3Qgbm90IGhhdmUgYW55IGZvcm1hbCBwYXJhbWV0ZXJzJyxcclxuXHQgICAgQmFkU2V0dGVyQXJpdHk6ICdTZXR0ZXIgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGZvcm1hbCBwYXJhbWV0ZXInLFxyXG5cdCAgICBCYWRTZXR0ZXJSZXN0UGFyYW1ldGVyOiAnU2V0dGVyIGZ1bmN0aW9uIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgcmVzdCBwYXJhbWV0ZXInLFxyXG5cdCAgICBDb25zdHJ1Y3RvcklzQXN5bmM6ICdDbGFzcyBjb25zdHJ1Y3RvciBtYXkgbm90IGJlIGFuIGFzeW5jIG1ldGhvZCcsXHJcblx0ICAgIENvbnN0cnVjdG9yU3BlY2lhbE1ldGhvZDogJ0NsYXNzIGNvbnN0cnVjdG9yIG1heSBub3QgYmUgYW4gYWNjZXNzb3InLFxyXG5cdCAgICBEZWNsYXJhdGlvbk1pc3NpbmdJbml0aWFsaXplcjogJ01pc3NpbmcgaW5pdGlhbGl6ZXIgaW4gJTAgZGVjbGFyYXRpb24nLFxyXG5cdCAgICBEZWZhdWx0UmVzdFBhcmFtZXRlcjogJ1VuZXhwZWN0ZWQgdG9rZW4gPScsXHJcblx0ICAgIER1cGxpY2F0ZUJpbmRpbmc6ICdEdXBsaWNhdGUgYmluZGluZyAlMCcsXHJcblx0ICAgIER1cGxpY2F0ZUNvbnN0cnVjdG9yOiAnQSBjbGFzcyBtYXkgb25seSBoYXZlIG9uZSBjb25zdHJ1Y3RvcicsXHJcblx0ICAgIER1cGxpY2F0ZVByb3RvUHJvcGVydHk6ICdEdXBsaWNhdGUgX19wcm90b19fIGZpZWxkcyBhcmUgbm90IGFsbG93ZWQgaW4gb2JqZWN0IGxpdGVyYWxzJyxcclxuXHQgICAgRm9ySW5PZkxvb3BJbml0aWFsaXplcjogJyUwIGxvb3AgdmFyaWFibGUgZGVjbGFyYXRpb24gbWF5IG5vdCBoYXZlIGFuIGluaXRpYWxpemVyJyxcclxuXHQgICAgR2VuZXJhdG9ySW5MZWdhY3lDb250ZXh0OiAnR2VuZXJhdG9yIGRlY2xhcmF0aW9ucyBhcmUgbm90IGFsbG93ZWQgaW4gbGVnYWN5IGNvbnRleHRzJyxcclxuXHQgICAgSWxsZWdhbEJyZWFrOiAnSWxsZWdhbCBicmVhayBzdGF0ZW1lbnQnLFxyXG5cdCAgICBJbGxlZ2FsQ29udGludWU6ICdJbGxlZ2FsIGNvbnRpbnVlIHN0YXRlbWVudCcsXHJcblx0ICAgIElsbGVnYWxFeHBvcnREZWNsYXJhdGlvbjogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxyXG5cdCAgICBJbGxlZ2FsSW1wb3J0RGVjbGFyYXRpb246ICdVbmV4cGVjdGVkIHRva2VuJyxcclxuXHQgICAgSWxsZWdhbExhbmd1YWdlTW9kZURpcmVjdGl2ZTogJ0lsbGVnYWwgXFwndXNlIHN0cmljdFxcJyBkaXJlY3RpdmUgaW4gZnVuY3Rpb24gd2l0aCBub24tc2ltcGxlIHBhcmFtZXRlciBsaXN0JyxcclxuXHQgICAgSWxsZWdhbFJldHVybjogJ0lsbGVnYWwgcmV0dXJuIHN0YXRlbWVudCcsXHJcblx0ICAgIEludmFsaWRFc2NhcGVkUmVzZXJ2ZWRXb3JkOiAnS2V5d29yZCBtdXN0IG5vdCBjb250YWluIGVzY2FwZWQgY2hhcmFjdGVycycsXHJcblx0ICAgIEludmFsaWRIZXhFc2NhcGVTZXF1ZW5jZTogJ0ludmFsaWQgaGV4YWRlY2ltYWwgZXNjYXBlIHNlcXVlbmNlJyxcclxuXHQgICAgSW52YWxpZExIU0luQXNzaWdubWVudDogJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gYXNzaWdubWVudCcsXHJcblx0ICAgIEludmFsaWRMSFNJbkZvckluOiAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3ItaW4nLFxyXG5cdCAgICBJbnZhbGlkTEhTSW5Gb3JMb29wOiAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3ItbG9vcCcsXHJcblx0ICAgIEludmFsaWRNb2R1bGVTcGVjaWZpZXI6ICdVbmV4cGVjdGVkIHRva2VuJyxcclxuXHQgICAgSW52YWxpZFJlZ0V4cDogJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uJyxcclxuXHQgICAgTGV0SW5MZXhpY2FsQmluZGluZzogJ2xldCBpcyBkaXNhbGxvd2VkIGFzIGEgbGV4aWNhbGx5IGJvdW5kIG5hbWUnLFxyXG5cdCAgICBNaXNzaW5nRnJvbUNsYXVzZTogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxyXG5cdCAgICBNdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2g6ICdNb3JlIHRoYW4gb25lIGRlZmF1bHQgY2xhdXNlIGluIHN3aXRjaCBzdGF0ZW1lbnQnLFxyXG5cdCAgICBOZXdsaW5lQWZ0ZXJUaHJvdzogJ0lsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvdycsXHJcblx0ICAgIE5vQXNBZnRlckltcG9ydE5hbWVzcGFjZTogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxyXG5cdCAgICBOb0NhdGNoT3JGaW5hbGx5OiAnTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGFmdGVyIHRyeScsXHJcblx0ICAgIFBhcmFtZXRlckFmdGVyUmVzdFBhcmFtZXRlcjogJ1Jlc3QgcGFyYW1ldGVyIG11c3QgYmUgbGFzdCBmb3JtYWwgcGFyYW1ldGVyJyxcclxuXHQgICAgUmVkZWNsYXJhdGlvbjogJyUwIFxcJyUxXFwnIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWQnLFxyXG5cdCAgICBTdGF0aWNQcm90b3R5cGU6ICdDbGFzc2VzIG1heSBub3QgaGF2ZSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgcHJvdG90eXBlJyxcclxuXHQgICAgU3RyaWN0Q2F0Y2hWYXJpYWJsZTogJ0NhdGNoIHZhcmlhYmxlIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3REZWxldGU6ICdEZWxldGUgb2YgYW4gdW5xdWFsaWZpZWQgaWRlbnRpZmllciBpbiBzdHJpY3QgbW9kZS4nLFxyXG5cdCAgICBTdHJpY3RGdW5jdGlvbjogJ0luIHN0cmljdCBtb2RlIGNvZGUsIGZ1bmN0aW9ucyBjYW4gb25seSBiZSBkZWNsYXJlZCBhdCB0b3AgbGV2ZWwgb3IgaW5zaWRlIGEgYmxvY2snLFxyXG5cdCAgICBTdHJpY3RGdW5jdGlvbk5hbWU6ICdGdW5jdGlvbiBuYW1lIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3RMSFNBc3NpZ25tZW50OiAnQXNzaWdubWVudCB0byBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdExIU1Bvc3RmaXg6ICdQb3N0Zml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3RMSFNQcmVmaXg6ICdQcmVmaXggaW5jcmVtZW50L2RlY3JlbWVudCBtYXkgbm90IGhhdmUgZXZhbCBvciBhcmd1bWVudHMgb3BlcmFuZCBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdE1vZGVXaXRoOiAnU3RyaWN0IG1vZGUgY29kZSBtYXkgbm90IGluY2x1ZGUgYSB3aXRoIHN0YXRlbWVudCcsXHJcblx0ICAgIFN0cmljdE9jdGFsTGl0ZXJhbDogJ09jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZS4nLFxyXG5cdCAgICBTdHJpY3RQYXJhbUR1cGU6ICdTdHJpY3QgbW9kZSBmdW5jdGlvbiBtYXkgbm90IGhhdmUgZHVwbGljYXRlIHBhcmFtZXRlciBuYW1lcycsXHJcblx0ICAgIFN0cmljdFBhcmFtTmFtZTogJ1BhcmFtZXRlciBuYW1lIGV2YWwgb3IgYXJndW1lbnRzIGlzIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0UmVzZXJ2ZWRXb3JkOiAnVXNlIG9mIGZ1dHVyZSByZXNlcnZlZCB3b3JkIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0VmFyTmFtZTogJ1ZhcmlhYmxlIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFRlbXBsYXRlT2N0YWxMaXRlcmFsOiAnT2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHRlbXBsYXRlIHN0cmluZ3MuJyxcclxuXHQgICAgVW5leHBlY3RlZEVPUzogJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0JyxcclxuXHQgICAgVW5leHBlY3RlZElkZW50aWZpZXI6ICdVbmV4cGVjdGVkIGlkZW50aWZpZXInLFxyXG5cdCAgICBVbmV4cGVjdGVkTnVtYmVyOiAnVW5leHBlY3RlZCBudW1iZXInLFxyXG5cdCAgICBVbmV4cGVjdGVkUmVzZXJ2ZWQ6ICdVbmV4cGVjdGVkIHJlc2VydmVkIHdvcmQnLFxyXG5cdCAgICBVbmV4cGVjdGVkU3RyaW5nOiAnVW5leHBlY3RlZCBzdHJpbmcnLFxyXG5cdCAgICBVbmV4cGVjdGVkVGVtcGxhdGU6ICdVbmV4cGVjdGVkIHF1YXNpICUwJyxcclxuXHQgICAgVW5leHBlY3RlZFRva2VuOiAnVW5leHBlY3RlZCB0b2tlbiAlMCcsXHJcblx0ICAgIFVuZXhwZWN0ZWRUb2tlbklsbGVnYWw6ICdVbmV4cGVjdGVkIHRva2VuIElMTEVHQUwnLFxyXG5cdCAgICBVbmtub3duTGFiZWw6ICdVbmRlZmluZWQgbGFiZWwgXFwnJTBcXCcnLFxyXG5cdCAgICBVbnRlcm1pbmF0ZWRSZWdFeHA6ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogbWlzc2luZyAvJ1xyXG5cdH07XHJcblxuXG4vKioqLyB9LFxuLyogMTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgYXNzZXJ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG5cdHZhciBjaGFyYWN0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblx0dmFyIG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxuXHRmdW5jdGlvbiBoZXhWYWx1ZShjaCkge1xyXG5cdCAgICByZXR1cm4gJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIG9jdGFsVmFsdWUoY2gpIHtcclxuXHQgICAgcmV0dXJuICcwMTIzNDU2NycuaW5kZXhPZihjaCk7XHJcblx0fVxyXG5cdHZhciBTY2FubmVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU2Nhbm5lcihjb2RlLCBoYW5kbGVyKSB7XHJcblx0ICAgICAgICB0aGlzLnNvdXJjZSA9IGNvZGU7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlciA9IGhhbmRsZXI7XHJcblx0ICAgICAgICB0aGlzLnRyYWNrQ29tbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5sZW5ndGggPSBjb2RlLmxlbmd0aDtcclxuXHQgICAgICAgIHRoaXMuaW5kZXggPSAwO1xyXG5cdCAgICAgICAgdGhpcy5saW5lTnVtYmVyID0gKGNvZGUubGVuZ3RoID4gMCkgPyAxIDogMDtcclxuXHQgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gMDtcclxuXHQgICAgICAgIHRoaXMuY3VybHlTdGFjayA9IFtdO1xyXG5cdCAgICB9XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNhdmVTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnRcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnJlc3RvcmVTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xyXG5cdCAgICAgICAgdGhpcy5pbmRleCA9IHN0YXRlLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5saW5lTnVtYmVyID0gc3RhdGUubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5lb2YgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5pbmRleCA+PSB0aGlzLmxlbmd0aDtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUudGhyb3dVbmV4cGVjdGVkVG9rZW4gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG5cdCAgICAgICAgaWYgKG1lc3NhZ2UgPT09IHZvaWQgMCkgeyBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW5JbGxlZ2FsOyB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5lcnJvckhhbmRsZXIudGhyb3dFcnJvcih0aGlzLmluZGV4LCB0aGlzLmxpbmVOdW1iZXIsIHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydCArIDEsIG1lc3NhZ2UpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcblx0ICAgICAgICBpZiAobWVzc2FnZSA9PT0gdm9pZCAwKSB7IG1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbklsbGVnYWw7IH1cclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLnRvbGVyYXRlRXJyb3IodGhpcy5pbmRleCwgdGhpcy5saW5lTnVtYmVyLCB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnQgKyAxLCBtZXNzYWdlKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY29tbWVudHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2tpcFNpbmdsZUxpbmVDb21tZW50ID0gZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdCAgICAgICAgdmFyIGNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICB2YXIgc3RhcnQsIGxvYztcclxuXHQgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICAgICAgc3RhcnQgPSB0aGlzLmluZGV4IC0gb2Zmc2V0O1xyXG5cdCAgICAgICAgICAgIGxvYyA9IHtcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0IC0gb2Zmc2V0XHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIGVuZDoge31cclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0IC0gMVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aUxpbmU6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlOiBbc3RhcnQgKyBvZmZzZXQsIHRoaXMuaW5kZXggLSAxXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCB0aGlzLmluZGV4IC0gMV0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiBsb2NcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDEzICYmIHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkgPT09IDEwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1lbnRzO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIGxvYy5lbmQgPSB7XHJcblx0ICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnRcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcclxuXHQgICAgICAgICAgICAgICAgbXVsdGlMaW5lOiBmYWxzZSxcclxuXHQgICAgICAgICAgICAgICAgc2xpY2U6IFtzdGFydCArIG9mZnNldCwgdGhpcy5pbmRleF0sXHJcblx0ICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIHRoaXMuaW5kZXhdLFxyXG5cdCAgICAgICAgICAgICAgICBsb2M6IGxvY1xyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgY29tbWVudHMucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gY29tbWVudHM7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNraXBNdWx0aUxpbmVDb21tZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICB2YXIgc3RhcnQsIGxvYztcclxuXHQgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICAgICAgc3RhcnQgPSB0aGlzLmluZGV4IC0gMjtcclxuXHQgICAgICAgICAgICBsb2MgPSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydCAtIDJcclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB7fVxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaCkpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAweDBEICYmIHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpID09PSAweDBBKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gMHgyQSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBCbG9jayBjb21tZW50IGVuZHMgd2l0aCAnKi8nLlxyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSkgPT09IDB4MkYpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMjtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlMaW5lOiB0cnVlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGljZTogW3N0YXJ0ICsgMiwgdGhpcy5pbmRleCAtIDJdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCB0aGlzLmluZGV4XSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiBsb2NcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1lbnRzO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBSYW4gb2ZmIHRoZSBlbmQgb2YgdGhlIGZpbGUgLSB0aGUgd2hvbGUgdGhpbmcgaXMgYSBjb21tZW50XHJcblx0ICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICBsb2MuZW5kID0ge1xyXG5cdCAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICB2YXIgZW50cnkgPSB7XHJcblx0ICAgICAgICAgICAgICAgIG11bHRpTGluZTogdHJ1ZSxcclxuXHQgICAgICAgICAgICAgICAgc2xpY2U6IFtzdGFydCArIDIsIHRoaXMuaW5kZXhdLFxyXG5cdCAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCB0aGlzLmluZGV4XSxcclxuXHQgICAgICAgICAgICAgICAgbG9jOiBsb2NcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIGNvbW1lbnRzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuQ29tbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY29tbWVudHM7XHJcblx0ICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gKHRoaXMuaW5kZXggPT09IDApO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzV2hpdGVTcGFjZShjaCkpIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaCkpIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MEQgJiYgdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSA9PT0gMHgwQSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4MkYpIHtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAxKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAweDJGKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDI7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMuc2tpcFNpbmdsZUxpbmVDb21tZW50KDIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5jb25jYXQoY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4MkEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gdGhpcy5za2lwTXVsdGlMaW5lQ29tbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5jb25jYXQoY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChzdGFydCAmJiBjaCA9PT0gMHgyRCkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBVKzAwM0UgaXMgJz4nXHJcblx0ICAgICAgICAgICAgICAgIGlmICgodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSkgPT09IDB4MkQpICYmICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAyKSA9PT0gMHgzRSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vICctLT4nIGlzIGEgc2luZ2xlLWxpbmUgY29tbWVudFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLnNraXBTaW5nbGVMaW5lQ29tbWVudCgzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID0gY29tbWVudHMuY29uY2F0KGNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4M0MpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlLnNsaWNlKHRoaXMuaW5kZXggKyAxLCB0aGlzLmluZGV4ICsgNCkgPT09ICchLS0nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDQ7IC8vIGA8IS0tYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLnNraXBTaW5nbGVMaW5lQ29tbWVudCg0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID0gY29tbWVudHMuY29uY2F0KGNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBjb21tZW50cztcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZnV0dXJlLXJlc2VydmVkLXdvcmRzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmlzRnV0dXJlUmVzZXJ2ZWRXb3JkID0gZnVuY3Rpb24gKGlkKSB7XHJcblx0ICAgICAgICBzd2l0Y2ggKGlkKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAnZW51bSc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnZXhwb3J0JzpcclxuXHQgICAgICAgICAgICBjYXNlICdpbXBvcnQnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3N1cGVyJzpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQgPSBmdW5jdGlvbiAoaWQpIHtcclxuXHQgICAgICAgIHN3aXRjaCAoaWQpIHtcclxuXHQgICAgICAgICAgICBjYXNlICdpbXBsZW1lbnRzJzpcclxuXHQgICAgICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3BhY2thZ2UnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3ByaXZhdGUnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3Byb3RlY3RlZCc6XHJcblx0ICAgICAgICAgICAgY2FzZSAncHVibGljJzpcclxuXHQgICAgICAgICAgICBjYXNlICdzdGF0aWMnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3lpZWxkJzpcclxuXHQgICAgICAgICAgICBjYXNlICdsZXQnOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmlzUmVzdHJpY3RlZFdvcmQgPSBmdW5jdGlvbiAoaWQpIHtcclxuXHQgICAgICAgIHJldHVybiBpZCA9PT0gJ2V2YWwnIHx8IGlkID09PSAnYXJndW1lbnRzJztcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMta2V5d29yZHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuaXNLZXl3b3JkID0gZnVuY3Rpb24gKGlkKSB7XHJcblx0ICAgICAgICBzd2l0Y2ggKGlkLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgMjpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2lmJykgfHwgKGlkID09PSAnaW4nKSB8fCAoaWQgPT09ICdkbycpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgMzpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3ZhcicpIHx8IChpZCA9PT0gJ2ZvcicpIHx8IChpZCA9PT0gJ25ldycpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAoaWQgPT09ICd0cnknKSB8fCAoaWQgPT09ICdsZXQnKTtcclxuXHQgICAgICAgICAgICBjYXNlIDQ6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd0aGlzJykgfHwgKGlkID09PSAnZWxzZScpIHx8IChpZCA9PT0gJ2Nhc2UnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKGlkID09PSAndm9pZCcpIHx8IChpZCA9PT0gJ3dpdGgnKSB8fCAoaWQgPT09ICdlbnVtJyk7XHJcblx0ICAgICAgICAgICAgY2FzZSA1OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAnd2hpbGUnKSB8fCAoaWQgPT09ICdicmVhaycpIHx8IChpZCA9PT0gJ2NhdGNoJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgIChpZCA9PT0gJ3Rocm93JykgfHwgKGlkID09PSAnY29uc3QnKSB8fCAoaWQgPT09ICd5aWVsZCcpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAoaWQgPT09ICdjbGFzcycpIHx8IChpZCA9PT0gJ3N1cGVyJyk7XHJcblx0ICAgICAgICAgICAgY2FzZSA2OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAncmV0dXJuJykgfHwgKGlkID09PSAndHlwZW9mJykgfHwgKGlkID09PSAnZGVsZXRlJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgIChpZCA9PT0gJ3N3aXRjaCcpIHx8IChpZCA9PT0gJ2V4cG9ydCcpIHx8IChpZCA9PT0gJ2ltcG9ydCcpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNzpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2RlZmF1bHQnKSB8fCAoaWQgPT09ICdmaW5hbGx5JykgfHwgKGlkID09PSAnZXh0ZW5kcycpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgODpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2Z1bmN0aW9uJykgfHwgKGlkID09PSAnY29udGludWUnKSB8fCAoaWQgPT09ICdkZWJ1Z2dlcicpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgMTA6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpbnN0YW5jZW9mJyk7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5jb2RlUG9pbnRBdCA9IGZ1bmN0aW9uIChpKSB7XHJcblx0ICAgICAgICB2YXIgY3AgPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KGkpO1xyXG5cdCAgICAgICAgaWYgKGNwID49IDB4RDgwMCAmJiBjcCA8PSAweERCRkYpIHtcclxuXHQgICAgICAgICAgICB2YXIgc2Vjb25kID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdChpICsgMSk7XHJcblx0ICAgICAgICAgICAgaWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSBjcDtcclxuXHQgICAgICAgICAgICAgICAgY3AgPSAoZmlyc3QgLSAweEQ4MDApICogMHg0MDAgKyBzZWNvbmQgLSAweERDMDAgKyAweDEwMDAwO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBjcDtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbkhleEVzY2FwZSA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuXHQgICAgICAgIHZhciBsZW4gPSAocHJlZml4ID09PSAndScpID8gNCA6IDI7XHJcblx0ICAgICAgICB2YXIgY29kZSA9IDA7XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmVvZigpICYmIGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0hleERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogMTYgKyBoZXhWYWx1ZSh0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgdmFyIGNvZGUgPSAwO1xyXG5cdCAgICAgICAgLy8gQXQgbGVhc3QsIG9uZSBoZXggZGlnaXQgaXMgcmVxdWlyZWQuXHJcblx0ICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0hleERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBjb2RlID0gY29kZSAqIDE2ICsgaGV4VmFsdWUoY2gpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNvZGUgPiAweDEwRkZGRiB8fCBjaCAhPT0gJ30nKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5mcm9tQ29kZVBvaW50KGNvZGUpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5nZXRJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleCsrO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09IDB4NUMpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gQmxhY2tzbGFzaCAoVSswMDVDKSBtYXJrcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHN0YXJ0O1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wbGV4SWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA+PSAweEQ4MDAgJiYgY2ggPCAweERGRkYpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBoYW5kbGUgc3Vycm9nYXRlIHBhaXJzLlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gc3RhcnQ7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbXBsZXhJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyUGFydChjaCkpIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnNsaWNlKHN0YXJ0LCB0aGlzLmluZGV4KTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuZ2V0Q29tcGxleElkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY3AgPSB0aGlzLmNvZGVQb2ludEF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgdmFyIGlkID0gY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmZyb21Db2RlUG9pbnQoY3ApO1xyXG5cdCAgICAgICAgdGhpcy5pbmRleCArPSBpZC5sZW5ndGg7XHJcblx0ICAgICAgICAvLyAnXFx1JyAoVSswMDVDLCBVKzAwNzUpIGRlbm90ZXMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXHJcblx0ICAgICAgICB2YXIgY2g7XHJcblx0ICAgICAgICBpZiAoY3AgPT09IDB4NUMpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSAhPT0gMHg3NSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNjYW5IZXhFc2NhcGUoJ3UnKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSBudWxsIHx8IGNoID09PSAnXFxcXCcgfHwgIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlkID0gY2g7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBjcCA9IHRoaXMuY29kZVBvaW50QXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyUGFydChjcCkpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGNoID0gY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmZyb21Db2RlUG9pbnQoY3ApO1xyXG5cdCAgICAgICAgICAgIGlkICs9IGNoO1xyXG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gY2gubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgIC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cclxuXHQgICAgICAgICAgICBpZiAoY3AgPT09IDB4NUMpIHtcclxuXHQgICAgICAgICAgICAgICAgaWQgPSBpZC5zdWJzdHIoMCwgaWQubGVuZ3RoIC0gMSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpICE9PSAweDc1KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc2NhbkhleEVzY2FwZSgndScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSBudWxsIHx8IGNoID09PSAnXFxcXCcgfHwgIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlkICs9IGNoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBpZDtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUub2N0YWxUb0RlY2ltYWwgPSBmdW5jdGlvbiAoY2gpIHtcclxuXHQgICAgICAgIC8vIFxcMCBpcyBub3Qgb2N0YWwgZXNjYXBlIHNlcXVlbmNlXHJcblx0ICAgICAgICB2YXIgb2N0YWwgPSAoY2ggIT09ICcwJyk7XHJcblx0ICAgICAgICB2YXIgY29kZSA9IG9jdGFsVmFsdWUoY2gpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLmVvZigpICYmIGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICBvY3RhbCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgb2N0YWxWYWx1ZSh0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdKTtcclxuXHQgICAgICAgICAgICAvLyAzIGRpZ2l0cyBhcmUgb25seSBhbGxvd2VkIHdoZW4gc3RyaW5nIHN0YXJ0c1xyXG5cdCAgICAgICAgICAgIC8vIHdpdGggMCwgMSwgMiwgM1xyXG5cdCAgICAgICAgICAgIGlmICgnMDEyMycuaW5kZXhPZihjaCkgPj0gMCAmJiAhdGhpcy5lb2YoKSAmJiBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArIG9jdGFsVmFsdWUodGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBjb2RlOiBjb2RlLFxyXG5cdCAgICAgICAgICAgIG9jdGFsOiBvY3RhbFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbmFtZXMtYW5kLWtleXdvcmRzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5JZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHR5cGU7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgLy8gQmFja3NsYXNoIChVKzAwNUMpIHN0YXJ0cyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cclxuXHQgICAgICAgIHZhciBpZCA9ICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gMHg1QykgPyB0aGlzLmdldENvbXBsZXhJZGVudGlmaWVyKCkgOiB0aGlzLmdldElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgIC8vIFRoZXJlIGlzIG5vIGtleXdvcmQgb3IgbGl0ZXJhbCB3aXRoIG9ubHkgb25lIGNoYXJhY3Rlci5cclxuXHQgICAgICAgIC8vIFRodXMsIGl0IG11c3QgYmUgYW4gaWRlbnRpZmllci5cclxuXHQgICAgICAgIGlmIChpZC5sZW5ndGggPT09IDEpIHtcclxuXHQgICAgICAgICAgICB0eXBlID0gMyAvKiBJZGVudGlmaWVyICovO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5pc0tleXdvcmQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgdHlwZSA9IDQgLyogS2V5d29yZCAqLztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKGlkID09PSAnbnVsbCcpIHtcclxuXHQgICAgICAgICAgICB0eXBlID0gNSAvKiBOdWxsTGl0ZXJhbCAqLztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKGlkID09PSAndHJ1ZScgfHwgaWQgPT09ICdmYWxzZScpIHtcclxuXHQgICAgICAgICAgICB0eXBlID0gMSAvKiBCb29sZWFuTGl0ZXJhbCAqLztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHR5cGUgPSAzIC8qIElkZW50aWZpZXIgKi87XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodHlwZSAhPT0gMyAvKiBJZGVudGlmaWVyICovICYmIChzdGFydCArIGlkLmxlbmd0aCAhPT0gdGhpcy5pbmRleCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgcmVzdG9yZSA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdGhpcy5pbmRleCA9IHN0YXJ0O1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkRXNjYXBlZFJlc2VydmVkV29yZCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5pbmRleCA9IHJlc3RvcmU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcblx0ICAgICAgICAgICAgdmFsdWU6IGlkLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXB1bmN0dWF0b3JzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5QdW5jdHVhdG9yID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgIC8vIENoZWNrIGZvciBtb3N0IGNvbW1vbiBzaW5nbGUtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxyXG5cdCAgICAgICAgdmFyIHN0ciA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgc3dpdGNoIChzdHIpIHtcclxuXHQgICAgICAgICAgICBjYXNlICcoJzpcclxuXHQgICAgICAgICAgICBjYXNlICd7JzpcclxuXHQgICAgICAgICAgICAgICAgaWYgKHN0ciA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cmx5U3RhY2sucHVzaCgneycpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAnLic6XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAnLicgJiYgdGhpcy5zb3VyY2VbdGhpcy5pbmRleCArIDFdID09PSAnLicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNwcmVhZCBvcGVyYXRvcjogLi4uXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLi4uJztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlICd9JzpcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmN1cmx5U3RhY2sucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgJyknOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJzsnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJywnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ1snOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ10nOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJzonOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJz8nOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ34nOlxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIC8vIDQtY2hhcmFjdGVyIHB1bmN0dWF0b3IuXHJcblx0ICAgICAgICAgICAgICAgIHN0ciA9IHRoaXMuc291cmNlLnN1YnN0cih0aGlzLmluZGV4LCA0KTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHN0ciA9PT0gJz4+Pj0nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyAzLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cclxuXHQgICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHIoMCwgMyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RyID09PSAnPT09JyB8fCBzdHIgPT09ICchPT0nIHx8IHN0ciA9PT0gJz4+PicgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICc8PD0nIHx8IHN0ciA9PT0gJz4+PScgfHwgc3RyID09PSAnKio9Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDItY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHIoMCwgMik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ciA9PT0gJyYmJyB8fCBzdHIgPT09ICd8fCcgfHwgc3RyID09PSAnPT0nIHx8IHN0ciA9PT0gJyE9JyB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICcrPScgfHwgc3RyID09PSAnLT0nIHx8IHN0ciA9PT0gJyo9JyB8fCBzdHIgPT09ICcvPScgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnKysnIHx8IHN0ciA9PT0gJy0tJyB8fCBzdHIgPT09ICc8PCcgfHwgc3RyID09PSAnPj4nIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJyY9JyB8fCBzdHIgPT09ICd8PScgfHwgc3RyID09PSAnXj0nIHx8IHN0ciA9PT0gJyU9JyB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICc8PScgfHwgc3RyID09PSAnPj0nIHx8IHN0ciA9PT0gJz0+JyB8fCBzdHIgPT09ICcqKicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJzw+PSErLSolJnxeLycuaW5kZXhPZihzdHIpID49IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IHN0YXJ0KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA3IC8qIFB1bmN0dWF0b3IgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHN0cixcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1saXRlcmFscy1udW1lcmljLWxpdGVyYWxzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5IZXhMaXRlcmFsID0gZnVuY3Rpb24gKHN0YXJ0KSB7XHJcblx0ICAgICAgICB2YXIgbnVtID0gJyc7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0hleERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChudW0ubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogNiAvKiBOdW1lcmljTGl0ZXJhbCAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQoJzB4JyArIG51bSwgMTYpLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5CaW5hcnlMaXRlcmFsID0gZnVuY3Rpb24gKHN0YXJ0KSB7XHJcblx0ICAgICAgICB2YXIgbnVtID0gJyc7XHJcblx0ICAgICAgICB2YXIgY2g7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCAhPT0gJzAnICYmIGNoICE9PSAnMScpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKG51bS5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICAvLyBvbmx5IDBiIG9yIDBCXHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydChjaCkgfHwgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KGNoKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA2IC8qIE51bWVyaWNMaXRlcmFsICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW0sIDIpLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5PY3RhbExpdGVyYWwgPSBmdW5jdGlvbiAocHJlZml4LCBzdGFydCkge1xyXG5cdCAgICAgICAgdmFyIG51bSA9ICcnO1xyXG5cdCAgICAgICAgdmFyIG9jdGFsID0gZmFsc2U7XHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdChwcmVmaXguY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICBvY3RhbCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgbnVtID0gJzAnICsgdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIW9jdGFsICYmIG51bS5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICAvLyBvbmx5IDBvIG9yIDBPXHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSB8fCBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDYgLyogTnVtZXJpY0xpdGVyYWwgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHBhcnNlSW50KG51bSwgOCksXHJcblx0ICAgICAgICAgICAgb2N0YWw6IG9jdGFsLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmlzSW1wbGljaXRPY3RhbExpdGVyYWwgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAvLyBJbXBsaWNpdCBvY3RhbCwgdW5sZXNzIHRoZXJlIGlzIGEgbm9uLW9jdGFsIGRpZ2l0LlxyXG5cdCAgICAgICAgLy8gKEFubmV4IEIuMS4xIG9uIE51bWVyaWMgTGl0ZXJhbHMpXHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5pbmRleCArIDE7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2VbaV07XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAnOCcgfHwgY2ggPT09ICc5Jykge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbk51bWVyaWNMaXRlcmFsID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3N0YXJ0XTtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkgfHwgKGNoID09PSAnLicpLCAnTnVtZXJpYyBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIGRlY2ltYWwgZGlnaXQgb3IgYSBkZWNpbWFsIHBvaW50Jyk7XHJcblx0ICAgICAgICB2YXIgbnVtID0gJyc7XHJcblx0ICAgICAgICBpZiAoY2ggIT09ICcuJykge1xyXG5cdCAgICAgICAgICAgIG51bSA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgICAgICAvLyBIZXggbnVtYmVyIHN0YXJ0cyB3aXRoICcweCcuXHJcblx0ICAgICAgICAgICAgLy8gT2N0YWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJy5cclxuXHQgICAgICAgICAgICAvLyBPY3RhbCBudW1iZXIgaW4gRVM2IHN0YXJ0cyB3aXRoICcwbycuXHJcblx0ICAgICAgICAgICAgLy8gQmluYXJ5IG51bWJlciBpbiBFUzYgc3RhcnRzIHdpdGggJzBiJy5cclxuXHQgICAgICAgICAgICBpZiAobnVtID09PSAnMCcpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAneCcgfHwgY2ggPT09ICdYJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkhleExpdGVyYWwoc3RhcnQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ2InIHx8IGNoID09PSAnQicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5CaW5hcnlMaXRlcmFsKHN0YXJ0KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdvJyB8fCBjaCA9PT0gJ08nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuT2N0YWxMaXRlcmFsKGNoLCBzdGFydCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoICYmIGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW1wbGljaXRPY3RhbExpdGVyYWwoKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5PY3RhbExpdGVyYWwoY2gsIHN0YXJ0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB3aGlsZSAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNoID09PSAnLicpIHtcclxuXHQgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICB3aGlsZSAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xyXG5cdCAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAnKycgfHwgY2ggPT09ICctJykge1xyXG5cdCAgICAgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDYgLyogTnVtZXJpY0xpdGVyYWwgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQobnVtKSxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1saXRlcmFscy1zdHJpbmctbGl0ZXJhbHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblN0cmluZ0xpdGVyYWwgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIHF1b3RlID0gdGhpcy5zb3VyY2Vbc3RhcnRdO1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KChxdW90ZSA9PT0gJ1xcJycgfHwgcXVvdGUgPT09ICdcIicpLCAnU3RyaW5nIGxpdGVyYWwgbXVzdCBzdGFydHMgd2l0aCBhIHF1b3RlJyk7XHJcblx0ICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgb2N0YWwgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBzdHIgPSAnJztcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBxdW90ZSA9ICcnO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgICAgIGlmICghY2ggfHwgIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdGhpcy5zY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuZXNjYXBlZF8xID0gdGhpcy5zY2FuSGV4RXNjYXBlKGNoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmVzY2FwZWRfMSA9PT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSB1bmVzY2FwZWRfMTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd4JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuZXNjYXBlZCA9IHRoaXMuc2NhbkhleEVzY2FwZShjaCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmVzY2FwZWQgPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkSGV4RXNjYXBlU2VxdWVuY2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSB1bmVzY2FwZWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcbic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xccic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcdCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcYic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcZic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xceDBCJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnOCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnOSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggJiYgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9jdFRvRGVjID0gdGhpcy5vY3RhbFRvRGVjaW1hbChjaCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvY3RhbCA9IG9jdFRvRGVjLm9jdGFsIHx8IG9jdGFsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUob2N0VG9EZWMuY29kZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgdGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICdcXG4nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChxdW90ZSAhPT0gJycpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmluZGV4ID0gc3RhcnQ7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA4IC8qIFN0cmluZ0xpdGVyYWwgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHN0cixcclxuXHQgICAgICAgICAgICBvY3RhbDogb2N0YWwsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNvb2tlZCA9ICcnO1xyXG5cdCAgICAgICAgdmFyIHRlcm1pbmF0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgaGVhZCA9ICh0aGlzLnNvdXJjZVtzdGFydF0gPT09ICdgJyk7XHJcblx0ICAgICAgICB2YXIgdGFpbCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHJhd09mZnNldCA9IDI7XHJcblx0ICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJ2AnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJhd09mZnNldCA9IDE7XHJcblx0ICAgICAgICAgICAgICAgIHRhaWwgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnJCcpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VybHlTdGFjay5wdXNoKCckeycpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGVybWluYXRlZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxuJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxyJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFx0JztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gdGhpcy5zY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3RvcmUgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuZXNjYXBlZF8yID0gdGhpcy5zY2FuSGV4RXNjYXBlKGNoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmVzY2FwZWRfMiAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSB1bmVzY2FwZWRfMjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSByZXN0b3JlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd4JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuZXNjYXBlZCA9IHRoaXMuc2NhbkhleEVzY2FwZShjaCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmVzY2FwZWQgPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkSGV4RXNjYXBlU2VxdWVuY2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSB1bmVzY2FwZWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcYic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcZic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcdic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJzAnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbDogXFwwMSBcXDAyIGFuZCBzbyBvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5UZW1wbGF0ZU9jdGFsTGl0ZXJhbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcMCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbDogXFwxIFxcMlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLlRlbXBsYXRlT2N0YWxMaXRlcmFsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ1xcbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgdGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICdcXG4nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcbic7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCF0ZXJtaW5hdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCFoZWFkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5jdXJseVN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiAxMCAvKiBUZW1wbGF0ZSAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogdGhpcy5zb3VyY2Uuc2xpY2Uoc3RhcnQgKyAxLCB0aGlzLmluZGV4IC0gcmF3T2Zmc2V0KSxcclxuXHQgICAgICAgICAgICBjb29rZWQ6IGNvb2tlZCxcclxuXHQgICAgICAgICAgICBoZWFkOiBoZWFkLFxyXG5cdCAgICAgICAgICAgIHRhaWw6IHRhaWwsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGl0ZXJhbHMtcmVndWxhci1leHByZXNzaW9uLWxpdGVyYWxzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnRlc3RSZWdFeHAgPSBmdW5jdGlvbiAocGF0dGVybiwgZmxhZ3MpIHtcclxuXHQgICAgICAgIC8vIFRoZSBCTVAgY2hhcmFjdGVyIHRvIHVzZSBhcyBhIHJlcGxhY2VtZW50IGZvciBhc3RyYWwgc3ltYm9scyB3aGVuXHJcblx0ICAgICAgICAvLyB0cmFuc2xhdGluZyBhbiBFUzYgXCJ1XCItZmxhZ2dlZCBwYXR0ZXJuIHRvIGFuIEVTNS1jb21wYXRpYmxlXHJcblx0ICAgICAgICAvLyBhcHByb3hpbWF0aW9uLlxyXG5cdCAgICAgICAgLy8gTm90ZTogcmVwbGFjaW5nIHdpdGggJ1xcdUZGRkYnIGVuYWJsZXMgZmFsc2UgcG9zaXRpdmVzIGluIHVubGlrZWx5XHJcblx0ICAgICAgICAvLyBzY2VuYXJpb3MuIEZvciBleGFtcGxlLCBgW1xcdXsxMDQ0Zn0tXFx1ezEwNDQwfV1gIGlzIGFuIGludmFsaWRcclxuXHQgICAgICAgIC8vIHBhdHRlcm4gdGhhdCB3b3VsZCBub3QgYmUgZGV0ZWN0ZWQgYnkgdGhpcyBzdWJzdGl0dXRpb24uXHJcblx0ICAgICAgICB2YXIgYXN0cmFsU3Vic3RpdHV0ZSA9ICdcXHVGRkZGJztcclxuXHQgICAgICAgIHZhciB0bXAgPSBwYXR0ZXJuO1xyXG5cdCAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cdCAgICAgICAgaWYgKGZsYWdzLmluZGV4T2YoJ3UnKSA+PSAwKSB7XHJcblx0ICAgICAgICAgICAgdG1wID0gdG1wXHJcblx0ICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcdVxceyhbMC05YS1mQS1GXSspXFx9fFxcXFx1KFthLWZBLUYwLTldezR9KS9nLCBmdW5jdGlvbiAoJDAsICQxLCAkMikge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gcGFyc2VJbnQoJDEgfHwgJDIsIDE2KTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4MTBGRkZGKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzZWxmLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweEZGRkYpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFzdHJhbFN1YnN0aXR1dGU7XHJcblx0ICAgICAgICAgICAgfSlcclxuXHQgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZywgYXN0cmFsU3Vic3RpdHV0ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBGaXJzdCwgZGV0ZWN0IGludmFsaWQgcmVndWxhciBleHByZXNzaW9ucy5cclxuXHQgICAgICAgIHRyeSB7XHJcblx0ICAgICAgICAgICAgUmVnRXhwKHRtcCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBjYXRjaCAoZSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkUmVnRXhwKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFJldHVybiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QgZm9yIHRoaXMgcGF0dGVybi1mbGFnIHBhaXIsIG9yXHJcblx0ICAgICAgICAvLyBgbnVsbGAgaW4gY2FzZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IHN1cHBvcnQgdGhlIGZsYWdzIGl0XHJcblx0ICAgICAgICAvLyB1c2VzLlxyXG5cdCAgICAgICAgdHJ5IHtcclxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBjYXRjaCAoZXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblJlZ0V4cEJvZHkgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydChjaCA9PT0gJy8nLCAnUmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgc2xhc2gnKTtcclxuXHQgICAgICAgIHZhciBzdHIgPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgdmFyIGNsYXNzTWFya2VyID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgdGVybWluYXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxpdGVyYWxzLXJlZ3VsYXItZXhwcmVzc2lvbi1saXRlcmFsc1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNsYXNzTWFya2VyKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjbGFzc01hcmtlciA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcvJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGVybWluYXRlZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjbGFzc01hcmtlciA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIEV4Y2x1ZGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2guXHJcblx0ICAgICAgICByZXR1cm4gc3RyLnN1YnN0cigxLCBzdHIubGVuZ3RoIC0gMik7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5SZWdFeHBGbGFncyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdHIgPSAnJztcclxuXHQgICAgICAgIHZhciBmbGFncyA9ICcnO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyUGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnICYmICF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdG9yZSA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2hhciA9IHRoaXMuc2NhbkhleEVzY2FwZSgndScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXIgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmbGFncyArPSBjaGFyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoc3RyICs9ICdcXFxcdSc7IHJlc3RvcmUgPCB0aGlzLmluZGV4OyArK3Jlc3RvcmUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHRoaXMuc291cmNlW3Jlc3RvcmVdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSByZXN0b3JlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICs9ICd1JztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFx1JztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGZsYWdzICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGZsYWdzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuUmVnRXhwID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgIHZhciBwYXR0ZXJuID0gdGhpcy5zY2FuUmVnRXhwQm9keSgpO1xyXG5cdCAgICAgICAgdmFyIGZsYWdzID0gdGhpcy5zY2FuUmVnRXhwRmxhZ3MoKTtcclxuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudGVzdFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDkgLyogUmVndWxhckV4cHJlc3Npb24gKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6ICcnLFxyXG5cdCAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4sXHJcblx0ICAgICAgICAgICAgZmxhZ3M6IGZsYWdzLFxyXG5cdCAgICAgICAgICAgIHJlZ2V4OiB2YWx1ZSxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5sZXggPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IDIgLyogRU9GICovLFxyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogJycsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuaW5kZXgsXHJcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgY3AgPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydChjcCkpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gVmVyeSBjb21tb246ICggYW5kICkgYW5kIDtcclxuXHQgICAgICAgIGlmIChjcCA9PT0gMHgyOCB8fCBjcCA9PT0gMHgyOSB8fCBjcCA9PT0gMHgzQikge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5QdW5jdHVhdG9yKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBTdHJpbmcgbGl0ZXJhbCBzdGFydHMgd2l0aCBzaW5nbGUgcXVvdGUgKFUrMDAyNykgb3IgZG91YmxlIHF1b3RlIChVKzAwMjIpLlxyXG5cdCAgICAgICAgaWYgKGNwID09PSAweDI3IHx8IGNwID09PSAweDIyKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblN0cmluZ0xpdGVyYWwoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIERvdCAoLikgVSswMDJFIGNhbiBhbHNvIHN0YXJ0IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLCBoZW5jZSB0aGUgbmVlZFxyXG5cdCAgICAgICAgLy8gdG8gY2hlY2sgdGhlIG5leHQgY2hhcmFjdGVyLlxyXG5cdCAgICAgICAgaWYgKGNwID09PSAweDJFKSB7XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAxKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk51bWVyaWNMaXRlcmFsKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5QdW5jdHVhdG9yKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KGNwKSkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5OdW1lcmljTGl0ZXJhbCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gVGVtcGxhdGUgbGl0ZXJhbHMgc3RhcnQgd2l0aCBgIChVKzAwNjApIGZvciB0ZW1wbGF0ZSBoZWFkXHJcblx0ICAgICAgICAvLyBvciB9IChVKzAwN0QpIGZvciB0ZW1wbGF0ZSBtaWRkbGUgb3IgdGVtcGxhdGUgdGFpbC5cclxuXHQgICAgICAgIGlmIChjcCA9PT0gMHg2MCB8fCAoY3AgPT09IDB4N0QgJiYgdGhpcy5jdXJseVN0YWNrW3RoaXMuY3VybHlTdGFjay5sZW5ndGggLSAxXSA9PT0gJyR7JykpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuVGVtcGxhdGUoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFBvc3NpYmxlIGlkZW50aWZpZXIgc3RhcnQgaW4gYSBzdXJyb2dhdGUgcGFpci5cclxuXHQgICAgICAgIGlmIChjcCA+PSAweEQ4MDAgJiYgY3AgPCAweERGRkYpIHtcclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KHRoaXMuY29kZVBvaW50QXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5JZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2NhblB1bmN0dWF0b3IoKTtcclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIFNjYW5uZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlNjYW5uZXIgPSBTY2FubmVyO1xyXG5cblxuLyoqKi8gfSxcbi8qIDEzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWUgPSB7fTtcclxuXHRleHBvcnRzLlRva2VuTmFtZVsxIC8qIEJvb2xlYW5MaXRlcmFsICovXSA9ICdCb29sZWFuJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVsyIC8qIEVPRiAqL10gPSAnPGVuZD4nO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzMgLyogSWRlbnRpZmllciAqL10gPSAnSWRlbnRpZmllcic7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbNCAvKiBLZXl3b3JkICovXSA9ICdLZXl3b3JkJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVs1IC8qIE51bGxMaXRlcmFsICovXSA9ICdOdWxsJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVs2IC8qIE51bWVyaWNMaXRlcmFsICovXSA9ICdOdW1lcmljJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVs3IC8qIFB1bmN0dWF0b3IgKi9dID0gJ1B1bmN0dWF0b3InO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzggLyogU3RyaW5nTGl0ZXJhbCAqL10gPSAnU3RyaW5nJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVs5IC8qIFJlZ3VsYXJFeHByZXNzaW9uICovXSA9ICdSZWd1bGFyRXhwcmVzc2lvbic7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbMTAgLyogVGVtcGxhdGUgKi9dID0gJ1RlbXBsYXRlJztcclxuXG5cbi8qKiovIH0sXG4vKiAxNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0Ly8gR2VuZXJhdGVkIGJ5IGdlbmVyYXRlLXhodG1sLWVudGl0aWVzLmpzLiBETyBOT1QgTU9ESUZZIVxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHRleHBvcnRzLlhIVE1MRW50aXRpZXMgPSB7XHJcblx0ICAgIHF1b3Q6ICdcXHUwMDIyJyxcclxuXHQgICAgYW1wOiAnXFx1MDAyNicsXHJcblx0ICAgIGFwb3M6ICdcXHUwMDI3JyxcclxuXHQgICAgZ3Q6ICdcXHUwMDNFJyxcclxuXHQgICAgbmJzcDogJ1xcdTAwQTAnLFxyXG5cdCAgICBpZXhjbDogJ1xcdTAwQTEnLFxyXG5cdCAgICBjZW50OiAnXFx1MDBBMicsXHJcblx0ICAgIHBvdW5kOiAnXFx1MDBBMycsXHJcblx0ICAgIGN1cnJlbjogJ1xcdTAwQTQnLFxyXG5cdCAgICB5ZW46ICdcXHUwMEE1JyxcclxuXHQgICAgYnJ2YmFyOiAnXFx1MDBBNicsXHJcblx0ICAgIHNlY3Q6ICdcXHUwMEE3JyxcclxuXHQgICAgdW1sOiAnXFx1MDBBOCcsXHJcblx0ICAgIGNvcHk6ICdcXHUwMEE5JyxcclxuXHQgICAgb3JkZjogJ1xcdTAwQUEnLFxyXG5cdCAgICBsYXF1bzogJ1xcdTAwQUInLFxyXG5cdCAgICBub3Q6ICdcXHUwMEFDJyxcclxuXHQgICAgc2h5OiAnXFx1MDBBRCcsXHJcblx0ICAgIHJlZzogJ1xcdTAwQUUnLFxyXG5cdCAgICBtYWNyOiAnXFx1MDBBRicsXHJcblx0ICAgIGRlZzogJ1xcdTAwQjAnLFxyXG5cdCAgICBwbHVzbW46ICdcXHUwMEIxJyxcclxuXHQgICAgc3VwMjogJ1xcdTAwQjInLFxyXG5cdCAgICBzdXAzOiAnXFx1MDBCMycsXHJcblx0ICAgIGFjdXRlOiAnXFx1MDBCNCcsXHJcblx0ICAgIG1pY3JvOiAnXFx1MDBCNScsXHJcblx0ICAgIHBhcmE6ICdcXHUwMEI2JyxcclxuXHQgICAgbWlkZG90OiAnXFx1MDBCNycsXHJcblx0ICAgIGNlZGlsOiAnXFx1MDBCOCcsXHJcblx0ICAgIHN1cDE6ICdcXHUwMEI5JyxcclxuXHQgICAgb3JkbTogJ1xcdTAwQkEnLFxyXG5cdCAgICByYXF1bzogJ1xcdTAwQkInLFxyXG5cdCAgICBmcmFjMTQ6ICdcXHUwMEJDJyxcclxuXHQgICAgZnJhYzEyOiAnXFx1MDBCRCcsXHJcblx0ICAgIGZyYWMzNDogJ1xcdTAwQkUnLFxyXG5cdCAgICBpcXVlc3Q6ICdcXHUwMEJGJyxcclxuXHQgICAgQWdyYXZlOiAnXFx1MDBDMCcsXHJcblx0ICAgIEFhY3V0ZTogJ1xcdTAwQzEnLFxyXG5cdCAgICBBY2lyYzogJ1xcdTAwQzInLFxyXG5cdCAgICBBdGlsZGU6ICdcXHUwMEMzJyxcclxuXHQgICAgQXVtbDogJ1xcdTAwQzQnLFxyXG5cdCAgICBBcmluZzogJ1xcdTAwQzUnLFxyXG5cdCAgICBBRWxpZzogJ1xcdTAwQzYnLFxyXG5cdCAgICBDY2VkaWw6ICdcXHUwMEM3JyxcclxuXHQgICAgRWdyYXZlOiAnXFx1MDBDOCcsXHJcblx0ICAgIEVhY3V0ZTogJ1xcdTAwQzknLFxyXG5cdCAgICBFY2lyYzogJ1xcdTAwQ0EnLFxyXG5cdCAgICBFdW1sOiAnXFx1MDBDQicsXHJcblx0ICAgIElncmF2ZTogJ1xcdTAwQ0MnLFxyXG5cdCAgICBJYWN1dGU6ICdcXHUwMENEJyxcclxuXHQgICAgSWNpcmM6ICdcXHUwMENFJyxcclxuXHQgICAgSXVtbDogJ1xcdTAwQ0YnLFxyXG5cdCAgICBFVEg6ICdcXHUwMEQwJyxcclxuXHQgICAgTnRpbGRlOiAnXFx1MDBEMScsXHJcblx0ICAgIE9ncmF2ZTogJ1xcdTAwRDInLFxyXG5cdCAgICBPYWN1dGU6ICdcXHUwMEQzJyxcclxuXHQgICAgT2NpcmM6ICdcXHUwMEQ0JyxcclxuXHQgICAgT3RpbGRlOiAnXFx1MDBENScsXHJcblx0ICAgIE91bWw6ICdcXHUwMEQ2JyxcclxuXHQgICAgdGltZXM6ICdcXHUwMEQ3JyxcclxuXHQgICAgT3NsYXNoOiAnXFx1MDBEOCcsXHJcblx0ICAgIFVncmF2ZTogJ1xcdTAwRDknLFxyXG5cdCAgICBVYWN1dGU6ICdcXHUwMERBJyxcclxuXHQgICAgVWNpcmM6ICdcXHUwMERCJyxcclxuXHQgICAgVXVtbDogJ1xcdTAwREMnLFxyXG5cdCAgICBZYWN1dGU6ICdcXHUwMEREJyxcclxuXHQgICAgVEhPUk46ICdcXHUwMERFJyxcclxuXHQgICAgc3psaWc6ICdcXHUwMERGJyxcclxuXHQgICAgYWdyYXZlOiAnXFx1MDBFMCcsXHJcblx0ICAgIGFhY3V0ZTogJ1xcdTAwRTEnLFxyXG5cdCAgICBhY2lyYzogJ1xcdTAwRTInLFxyXG5cdCAgICBhdGlsZGU6ICdcXHUwMEUzJyxcclxuXHQgICAgYXVtbDogJ1xcdTAwRTQnLFxyXG5cdCAgICBhcmluZzogJ1xcdTAwRTUnLFxyXG5cdCAgICBhZWxpZzogJ1xcdTAwRTYnLFxyXG5cdCAgICBjY2VkaWw6ICdcXHUwMEU3JyxcclxuXHQgICAgZWdyYXZlOiAnXFx1MDBFOCcsXHJcblx0ICAgIGVhY3V0ZTogJ1xcdTAwRTknLFxyXG5cdCAgICBlY2lyYzogJ1xcdTAwRUEnLFxyXG5cdCAgICBldW1sOiAnXFx1MDBFQicsXHJcblx0ICAgIGlncmF2ZTogJ1xcdTAwRUMnLFxyXG5cdCAgICBpYWN1dGU6ICdcXHUwMEVEJyxcclxuXHQgICAgaWNpcmM6ICdcXHUwMEVFJyxcclxuXHQgICAgaXVtbDogJ1xcdTAwRUYnLFxyXG5cdCAgICBldGg6ICdcXHUwMEYwJyxcclxuXHQgICAgbnRpbGRlOiAnXFx1MDBGMScsXHJcblx0ICAgIG9ncmF2ZTogJ1xcdTAwRjInLFxyXG5cdCAgICBvYWN1dGU6ICdcXHUwMEYzJyxcclxuXHQgICAgb2NpcmM6ICdcXHUwMEY0JyxcclxuXHQgICAgb3RpbGRlOiAnXFx1MDBGNScsXHJcblx0ICAgIG91bWw6ICdcXHUwMEY2JyxcclxuXHQgICAgZGl2aWRlOiAnXFx1MDBGNycsXHJcblx0ICAgIG9zbGFzaDogJ1xcdTAwRjgnLFxyXG5cdCAgICB1Z3JhdmU6ICdcXHUwMEY5JyxcclxuXHQgICAgdWFjdXRlOiAnXFx1MDBGQScsXHJcblx0ICAgIHVjaXJjOiAnXFx1MDBGQicsXHJcblx0ICAgIHV1bWw6ICdcXHUwMEZDJyxcclxuXHQgICAgeWFjdXRlOiAnXFx1MDBGRCcsXHJcblx0ICAgIHRob3JuOiAnXFx1MDBGRScsXHJcblx0ICAgIHl1bWw6ICdcXHUwMEZGJyxcclxuXHQgICAgT0VsaWc6ICdcXHUwMTUyJyxcclxuXHQgICAgb2VsaWc6ICdcXHUwMTUzJyxcclxuXHQgICAgU2Nhcm9uOiAnXFx1MDE2MCcsXHJcblx0ICAgIHNjYXJvbjogJ1xcdTAxNjEnLFxyXG5cdCAgICBZdW1sOiAnXFx1MDE3OCcsXHJcblx0ICAgIGZub2Y6ICdcXHUwMTkyJyxcclxuXHQgICAgY2lyYzogJ1xcdTAyQzYnLFxyXG5cdCAgICB0aWxkZTogJ1xcdTAyREMnLFxyXG5cdCAgICBBbHBoYTogJ1xcdTAzOTEnLFxyXG5cdCAgICBCZXRhOiAnXFx1MDM5MicsXHJcblx0ICAgIEdhbW1hOiAnXFx1MDM5MycsXHJcblx0ICAgIERlbHRhOiAnXFx1MDM5NCcsXHJcblx0ICAgIEVwc2lsb246ICdcXHUwMzk1JyxcclxuXHQgICAgWmV0YTogJ1xcdTAzOTYnLFxyXG5cdCAgICBFdGE6ICdcXHUwMzk3JyxcclxuXHQgICAgVGhldGE6ICdcXHUwMzk4JyxcclxuXHQgICAgSW90YTogJ1xcdTAzOTknLFxyXG5cdCAgICBLYXBwYTogJ1xcdTAzOUEnLFxyXG5cdCAgICBMYW1iZGE6ICdcXHUwMzlCJyxcclxuXHQgICAgTXU6ICdcXHUwMzlDJyxcclxuXHQgICAgTnU6ICdcXHUwMzlEJyxcclxuXHQgICAgWGk6ICdcXHUwMzlFJyxcclxuXHQgICAgT21pY3JvbjogJ1xcdTAzOUYnLFxyXG5cdCAgICBQaTogJ1xcdTAzQTAnLFxyXG5cdCAgICBSaG86ICdcXHUwM0ExJyxcclxuXHQgICAgU2lnbWE6ICdcXHUwM0EzJyxcclxuXHQgICAgVGF1OiAnXFx1MDNBNCcsXHJcblx0ICAgIFVwc2lsb246ICdcXHUwM0E1JyxcclxuXHQgICAgUGhpOiAnXFx1MDNBNicsXHJcblx0ICAgIENoaTogJ1xcdTAzQTcnLFxyXG5cdCAgICBQc2k6ICdcXHUwM0E4JyxcclxuXHQgICAgT21lZ2E6ICdcXHUwM0E5JyxcclxuXHQgICAgYWxwaGE6ICdcXHUwM0IxJyxcclxuXHQgICAgYmV0YTogJ1xcdTAzQjInLFxyXG5cdCAgICBnYW1tYTogJ1xcdTAzQjMnLFxyXG5cdCAgICBkZWx0YTogJ1xcdTAzQjQnLFxyXG5cdCAgICBlcHNpbG9uOiAnXFx1MDNCNScsXHJcblx0ICAgIHpldGE6ICdcXHUwM0I2JyxcclxuXHQgICAgZXRhOiAnXFx1MDNCNycsXHJcblx0ICAgIHRoZXRhOiAnXFx1MDNCOCcsXHJcblx0ICAgIGlvdGE6ICdcXHUwM0I5JyxcclxuXHQgICAga2FwcGE6ICdcXHUwM0JBJyxcclxuXHQgICAgbGFtYmRhOiAnXFx1MDNCQicsXHJcblx0ICAgIG11OiAnXFx1MDNCQycsXHJcblx0ICAgIG51OiAnXFx1MDNCRCcsXHJcblx0ICAgIHhpOiAnXFx1MDNCRScsXHJcblx0ICAgIG9taWNyb246ICdcXHUwM0JGJyxcclxuXHQgICAgcGk6ICdcXHUwM0MwJyxcclxuXHQgICAgcmhvOiAnXFx1MDNDMScsXHJcblx0ICAgIHNpZ21hZjogJ1xcdTAzQzInLFxyXG5cdCAgICBzaWdtYTogJ1xcdTAzQzMnLFxyXG5cdCAgICB0YXU6ICdcXHUwM0M0JyxcclxuXHQgICAgdXBzaWxvbjogJ1xcdTAzQzUnLFxyXG5cdCAgICBwaGk6ICdcXHUwM0M2JyxcclxuXHQgICAgY2hpOiAnXFx1MDNDNycsXHJcblx0ICAgIHBzaTogJ1xcdTAzQzgnLFxyXG5cdCAgICBvbWVnYTogJ1xcdTAzQzknLFxyXG5cdCAgICB0aGV0YXN5bTogJ1xcdTAzRDEnLFxyXG5cdCAgICB1cHNpaDogJ1xcdTAzRDInLFxyXG5cdCAgICBwaXY6ICdcXHUwM0Q2JyxcclxuXHQgICAgZW5zcDogJ1xcdTIwMDInLFxyXG5cdCAgICBlbXNwOiAnXFx1MjAwMycsXHJcblx0ICAgIHRoaW5zcDogJ1xcdTIwMDknLFxyXG5cdCAgICB6d25qOiAnXFx1MjAwQycsXHJcblx0ICAgIHp3ajogJ1xcdTIwMEQnLFxyXG5cdCAgICBscm06ICdcXHUyMDBFJyxcclxuXHQgICAgcmxtOiAnXFx1MjAwRicsXHJcblx0ICAgIG5kYXNoOiAnXFx1MjAxMycsXHJcblx0ICAgIG1kYXNoOiAnXFx1MjAxNCcsXHJcblx0ICAgIGxzcXVvOiAnXFx1MjAxOCcsXHJcblx0ICAgIHJzcXVvOiAnXFx1MjAxOScsXHJcblx0ICAgIHNicXVvOiAnXFx1MjAxQScsXHJcblx0ICAgIGxkcXVvOiAnXFx1MjAxQycsXHJcblx0ICAgIHJkcXVvOiAnXFx1MjAxRCcsXHJcblx0ICAgIGJkcXVvOiAnXFx1MjAxRScsXHJcblx0ICAgIGRhZ2dlcjogJ1xcdTIwMjAnLFxyXG5cdCAgICBEYWdnZXI6ICdcXHUyMDIxJyxcclxuXHQgICAgYnVsbDogJ1xcdTIwMjInLFxyXG5cdCAgICBoZWxsaXA6ICdcXHUyMDI2JyxcclxuXHQgICAgcGVybWlsOiAnXFx1MjAzMCcsXHJcblx0ICAgIHByaW1lOiAnXFx1MjAzMicsXHJcblx0ICAgIFByaW1lOiAnXFx1MjAzMycsXHJcblx0ICAgIGxzYXF1bzogJ1xcdTIwMzknLFxyXG5cdCAgICByc2FxdW86ICdcXHUyMDNBJyxcclxuXHQgICAgb2xpbmU6ICdcXHUyMDNFJyxcclxuXHQgICAgZnJhc2w6ICdcXHUyMDQ0JyxcclxuXHQgICAgZXVybzogJ1xcdTIwQUMnLFxyXG5cdCAgICBpbWFnZTogJ1xcdTIxMTEnLFxyXG5cdCAgICB3ZWllcnA6ICdcXHUyMTE4JyxcclxuXHQgICAgcmVhbDogJ1xcdTIxMUMnLFxyXG5cdCAgICB0cmFkZTogJ1xcdTIxMjInLFxyXG5cdCAgICBhbGVmc3ltOiAnXFx1MjEzNScsXHJcblx0ICAgIGxhcnI6ICdcXHUyMTkwJyxcclxuXHQgICAgdWFycjogJ1xcdTIxOTEnLFxyXG5cdCAgICByYXJyOiAnXFx1MjE5MicsXHJcblx0ICAgIGRhcnI6ICdcXHUyMTkzJyxcclxuXHQgICAgaGFycjogJ1xcdTIxOTQnLFxyXG5cdCAgICBjcmFycjogJ1xcdTIxQjUnLFxyXG5cdCAgICBsQXJyOiAnXFx1MjFEMCcsXHJcblx0ICAgIHVBcnI6ICdcXHUyMUQxJyxcclxuXHQgICAgckFycjogJ1xcdTIxRDInLFxyXG5cdCAgICBkQXJyOiAnXFx1MjFEMycsXHJcblx0ICAgIGhBcnI6ICdcXHUyMUQ0JyxcclxuXHQgICAgZm9yYWxsOiAnXFx1MjIwMCcsXHJcblx0ICAgIHBhcnQ6ICdcXHUyMjAyJyxcclxuXHQgICAgZXhpc3Q6ICdcXHUyMjAzJyxcclxuXHQgICAgZW1wdHk6ICdcXHUyMjA1JyxcclxuXHQgICAgbmFibGE6ICdcXHUyMjA3JyxcclxuXHQgICAgaXNpbjogJ1xcdTIyMDgnLFxyXG5cdCAgICBub3RpbjogJ1xcdTIyMDknLFxyXG5cdCAgICBuaTogJ1xcdTIyMEInLFxyXG5cdCAgICBwcm9kOiAnXFx1MjIwRicsXHJcblx0ICAgIHN1bTogJ1xcdTIyMTEnLFxyXG5cdCAgICBtaW51czogJ1xcdTIyMTInLFxyXG5cdCAgICBsb3dhc3Q6ICdcXHUyMjE3JyxcclxuXHQgICAgcmFkaWM6ICdcXHUyMjFBJyxcclxuXHQgICAgcHJvcDogJ1xcdTIyMUQnLFxyXG5cdCAgICBpbmZpbjogJ1xcdTIyMUUnLFxyXG5cdCAgICBhbmc6ICdcXHUyMjIwJyxcclxuXHQgICAgYW5kOiAnXFx1MjIyNycsXHJcblx0ICAgIG9yOiAnXFx1MjIyOCcsXHJcblx0ICAgIGNhcDogJ1xcdTIyMjknLFxyXG5cdCAgICBjdXA6ICdcXHUyMjJBJyxcclxuXHQgICAgaW50OiAnXFx1MjIyQicsXHJcblx0ICAgIHRoZXJlNDogJ1xcdTIyMzQnLFxyXG5cdCAgICBzaW06ICdcXHUyMjNDJyxcclxuXHQgICAgY29uZzogJ1xcdTIyNDUnLFxyXG5cdCAgICBhc3ltcDogJ1xcdTIyNDgnLFxyXG5cdCAgICBuZTogJ1xcdTIyNjAnLFxyXG5cdCAgICBlcXVpdjogJ1xcdTIyNjEnLFxyXG5cdCAgICBsZTogJ1xcdTIyNjQnLFxyXG5cdCAgICBnZTogJ1xcdTIyNjUnLFxyXG5cdCAgICBzdWI6ICdcXHUyMjgyJyxcclxuXHQgICAgc3VwOiAnXFx1MjI4MycsXHJcblx0ICAgIG5zdWI6ICdcXHUyMjg0JyxcclxuXHQgICAgc3ViZTogJ1xcdTIyODYnLFxyXG5cdCAgICBzdXBlOiAnXFx1MjI4NycsXHJcblx0ICAgIG9wbHVzOiAnXFx1MjI5NScsXHJcblx0ICAgIG90aW1lczogJ1xcdTIyOTcnLFxyXG5cdCAgICBwZXJwOiAnXFx1MjJBNScsXHJcblx0ICAgIHNkb3Q6ICdcXHUyMkM1JyxcclxuXHQgICAgbGNlaWw6ICdcXHUyMzA4JyxcclxuXHQgICAgcmNlaWw6ICdcXHUyMzA5JyxcclxuXHQgICAgbGZsb29yOiAnXFx1MjMwQScsXHJcblx0ICAgIHJmbG9vcjogJ1xcdTIzMEInLFxyXG5cdCAgICBsb3o6ICdcXHUyNUNBJyxcclxuXHQgICAgc3BhZGVzOiAnXFx1MjY2MCcsXHJcblx0ICAgIGNsdWJzOiAnXFx1MjY2MycsXHJcblx0ICAgIGhlYXJ0czogJ1xcdTI2NjUnLFxyXG5cdCAgICBkaWFtczogJ1xcdTI2NjYnLFxyXG5cdCAgICBsYW5nOiAnXFx1MjdFOCcsXHJcblx0ICAgIHJhbmc6ICdcXHUyN0U5J1xyXG5cdH07XHJcblxuXG4vKioqLyB9LFxuLyogMTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgZXJyb3JfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcblx0dmFyIHNjYW5uZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG5cdHZhciB0b2tlbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcblx0dmFyIFJlYWRlciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFJlYWRlcigpIHtcclxuXHQgICAgICAgIHRoaXMudmFsdWVzID0gW107XHJcblx0ICAgICAgICB0aGlzLmN1cmx5ID0gdGhpcy5wYXJlbiA9IC0xO1xyXG5cdCAgICB9XHJcblx0ICAgIC8vIEEgZnVuY3Rpb24gZm9sbG93aW5nIG9uZSBvZiB0aG9zZSB0b2tlbnMgaXMgYW4gZXhwcmVzc2lvbi5cclxuXHQgICAgUmVhZGVyLnByb3RvdHlwZS5iZWZvcmVGdW5jdGlvbkV4cHJlc3Npb24gPSBmdW5jdGlvbiAodCkge1xyXG5cdCAgICAgICAgcmV0dXJuIFsnKCcsICd7JywgJ1snLCAnaW4nLCAndHlwZW9mJywgJ2luc3RhbmNlb2YnLCAnbmV3JyxcclxuXHQgICAgICAgICAgICAncmV0dXJuJywgJ2Nhc2UnLCAnZGVsZXRlJywgJ3Rocm93JywgJ3ZvaWQnLFxyXG5cdCAgICAgICAgICAgIC8vIGFzc2lnbm1lbnQgb3BlcmF0b3JzXHJcblx0ICAgICAgICAgICAgJz0nLCAnKz0nLCAnLT0nLCAnKj0nLCAnKio9JywgJy89JywgJyU9JywgJzw8PScsICc+Pj0nLCAnPj4+PScsXHJcblx0ICAgICAgICAgICAgJyY9JywgJ3w9JywgJ149JywgJywnLFxyXG5cdCAgICAgICAgICAgIC8vIGJpbmFyeS91bmFyeSBvcGVyYXRvcnNcclxuXHQgICAgICAgICAgICAnKycsICctJywgJyonLCAnKionLCAnLycsICclJywgJysrJywgJy0tJywgJzw8JywgJz4+JywgJz4+PicsICcmJyxcclxuXHQgICAgICAgICAgICAnfCcsICdeJywgJyEnLCAnficsICcmJicsICd8fCcsICc/JywgJzonLCAnPT09JywgJz09JywgJz49JyxcclxuXHQgICAgICAgICAgICAnPD0nLCAnPCcsICc+JywgJyE9JywgJyE9PSddLmluZGV4T2YodCkgPj0gMDtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gRGV0ZXJtaW5lIGlmIGZvcndhcmQgc2xhc2ggKC8pIGlzIGFuIG9wZXJhdG9yIG9yIHBhcnQgb2YgYSByZWd1bGFyIGV4cHJlc3Npb25cclxuXHQgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc3dlZXQuanMvd2lraS9kZXNpZ25cclxuXHQgICAgUmVhZGVyLnByb3RvdHlwZS5pc1JlZ2V4U3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLnZhbHVlc1t0aGlzLnZhbHVlcy5sZW5ndGggLSAxXTtcclxuXHQgICAgICAgIHZhciByZWdleCA9IChwcmV2aW91cyAhPT0gbnVsbCk7XHJcblx0ICAgICAgICBzd2l0Y2ggKHByZXZpb3VzKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAndGhpcyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnXSc6XHJcblx0ICAgICAgICAgICAgICAgIHJlZ2V4ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgJyknOlxyXG5cdCAgICAgICAgICAgICAgICB2YXIga2V5d29yZCA9IHRoaXMudmFsdWVzW3RoaXMucGFyZW4gLSAxXTtcclxuXHQgICAgICAgICAgICAgICAgcmVnZXggPSAoa2V5d29yZCA9PT0gJ2lmJyB8fCBrZXl3b3JkID09PSAnd2hpbGUnIHx8IGtleXdvcmQgPT09ICdmb3InIHx8IGtleXdvcmQgPT09ICd3aXRoJyk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgJ30nOlxyXG5cdCAgICAgICAgICAgICAgICAvLyBEaXZpZGluZyBhIGZ1bmN0aW9uIGJ5IGFueXRoaW5nIG1ha2VzIGxpdHRsZSBzZW5zZSxcclxuXHQgICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgdG8gY2hlY2sgZm9yIHRoYXQuXHJcblx0ICAgICAgICAgICAgICAgIHJlZ2V4ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlc1t0aGlzLmN1cmx5IC0gM10gPT09ICdmdW5jdGlvbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEFub255bW91cyBmdW5jdGlvbiwgZS5nLiBmdW5jdGlvbigpe30gLzQyXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2sgPSB0aGlzLnZhbHVlc1t0aGlzLmN1cmx5IC0gNF07XHJcblx0ICAgICAgICAgICAgICAgICAgICByZWdleCA9IGNoZWNrID8gIXRoaXMuYmVmb3JlRnVuY3Rpb25FeHByZXNzaW9uKGNoZWNrKSA6IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudmFsdWVzW3RoaXMuY3VybHkgLSA0XSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gTmFtZWQgZnVuY3Rpb24sIGUuZy4gZnVuY3Rpb24gZigpe30gLzQyL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoZWNrID0gdGhpcy52YWx1ZXNbdGhpcy5jdXJseSAtIDVdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmVnZXggPSBjaGVjayA/ICF0aGlzLmJlZm9yZUZ1bmN0aW9uRXhwcmVzc2lvbihjaGVjaykgOiB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHJlZ2V4O1xyXG5cdCAgICB9O1xyXG5cdCAgICBSZWFkZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gfHwgdG9rZW4udHlwZSA9PT0gNCAvKiBLZXl3b3JkICovKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jdXJseSA9IHRoaXMudmFsdWVzLmxlbmd0aDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICcoJykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnBhcmVuID0gdGhpcy52YWx1ZXMubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHRva2VuLnZhbHVlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmFsdWVzLnB1c2gobnVsbCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBSZWFkZXI7XHJcblx0fSgpKTtcclxuXHR2YXIgVG9rZW5pemVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVG9rZW5pemVyKGNvZGUsIGNvbmZpZykge1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBuZXcgZXJyb3JfaGFuZGxlcl8xLkVycm9ySGFuZGxlcigpO1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIudG9sZXJhbnQgPSBjb25maWcgPyAodHlwZW9mIGNvbmZpZy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIGNvbmZpZy50b2xlcmFudCkgOiBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lciA9IG5ldyBzY2FubmVyXzEuU2Nhbm5lcihjb2RlLCB0aGlzLmVycm9ySGFuZGxlcik7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIudHJhY2tDb21tZW50ID0gY29uZmlnID8gKHR5cGVvZiBjb25maWcuY29tbWVudCA9PT0gJ2Jvb2xlYW4nICYmIGNvbmZpZy5jb21tZW50KSA6IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy50cmFja1JhbmdlID0gY29uZmlnID8gKHR5cGVvZiBjb25maWcucmFuZ2UgPT09ICdib29sZWFuJyAmJiBjb25maWcucmFuZ2UpIDogZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLnRyYWNrTG9jID0gY29uZmlnID8gKHR5cGVvZiBjb25maWcubG9jID09PSAnYm9vbGVhbicgJiYgY29uZmlnLmxvYykgOiBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuYnVmZmVyID0gW107XHJcblx0ICAgICAgICB0aGlzLnJlYWRlciA9IG5ldyBSZWFkZXIoKTtcclxuXHQgICAgfVxyXG5cdCAgICBUb2tlbml6ZXIucHJvdG90eXBlLmVycm9ycyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmVycm9ySGFuZGxlci5lcnJvcnM7XHJcblx0ICAgIH07XHJcblx0ICAgIFRva2VuaXplci5wcm90b3R5cGUuZ2V0TmV4dFRva2VuID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgIHZhciBjb21tZW50cyA9IHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1lbnRzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGNvbW1lbnRzW2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5zY2FubmVyLnNvdXJjZS5zbGljZShlLnNsaWNlWzBdLCBlLnNsaWNlWzFdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGUubXVsdGlMaW5lID8gJ0Jsb2NrQ29tbWVudCcgOiAnTGluZUNvbW1lbnQnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrUmFuZ2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50LnJhbmdlID0gZS5yYW5nZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrTG9jKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudC5sb2MgPSBlLmxvYztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2goY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLnNjYW5uZXIuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGxvYyA9IHZvaWQgMDtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tMb2MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxvYyA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHt9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHZhciBzdGFydFJlZ2V4ID0gKHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4XSA9PT0gJy8nKSAmJiB0aGlzLnJlYWRlci5pc1JlZ2V4U3RhcnQoKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHRva2VuID0gc3RhcnRSZWdleCA/IHRoaXMuc2Nhbm5lci5zY2FuUmVnRXhwKCkgOiB0aGlzLnNjYW5uZXIubGV4KCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVhZGVyLnB1c2godG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b2tlbl8xLlRva2VuTmFtZVt0b2tlbi50eXBlXSxcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNjYW5uZXIuc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpXHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrUmFuZ2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVudHJ5LnJhbmdlID0gW3Rva2VuLnN0YXJ0LCB0b2tlbi5lbmRdO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrTG9jKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsb2MuZW5kID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVudHJ5LmxvYyA9IGxvYztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gOSAvKiBSZWd1bGFyRXhwcmVzc2lvbiAqLykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSB0b2tlbi5wYXR0ZXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZsYWdzID0gdG9rZW4uZmxhZ3M7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbnRyeS5yZWdleCA9IHsgcGF0dGVybjogcGF0dGVybiwgZmxhZ3M6IGZsYWdzIH07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNoaWZ0KCk7XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBUb2tlbml6ZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRva2VuaXplciA9IFRva2VuaXplcjtcclxuXG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjsiLCIndXNlIHN0cmljdCdcbnZhciByZWFkb25seVByb3hpZXMgPSBuZXcgV2Vha01hcFxudmFyIGN1cnJlbnRTYW5kYm94ID0gdW5kZWZpbmVkXG52YXIgR0xPQkFMID0gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKClcbnZhciB1bnNjb3BhYmxlc1N5bWJvbCA9IFN5bWJvbC51bnNjb3BhYmxlc1xudmFyIEZ1bmN0aW9uQ29uc3RydWN0b3IgPSAwLi5jb25zdHJ1Y3Rvci5jb25zdHJ1Y3RvclxuXG5mdW5jdGlvbiBjb21waWxlRXhwcmVzc2lvbihzcmMpIHtcblx0aWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYSBzdHJpbmcuJylcblx0fVxuXHRcblx0bmV3IEZ1bmN0aW9uQ29uc3RydWN0b3IoJ1widXNlIHN0cmljdFwiOyByZXR1cm4gJyArIHNyYykgLy8gVGVzdHMgZm9yIHN5bnRheCBlcnJvcnMgd2l0aG91dCBydW5uaW5nIHRoZSBjb2RlXG5cdHZhciBjb2RlID0gbmV3IEZ1bmN0aW9uQ29uc3RydWN0b3IoJ3NhbmRib3gnLCAnd2l0aCAoc2FuZGJveCkge3JldHVybiAoZnVuY3Rpb24gKCkge1widXNlIHN0cmljdFwiOyByZXR1cm4gJyArIHNyYyArICd9KS5jYWxsKHRoaXMpfScpXG5cdFxuXHRyZXR1cm4gZnVuY3Rpb24gKHNhbmRib3gpIHtcblx0XHRpZiAoIWlzT2JqZWN0KHNhbmRib3gpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3Qgb3IgZnVuY3Rpb24uJylcblx0XHR9XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgcnVuIHNhbmRib3hlZCBjb2RlIGluc2lkZSBhbiBhbHJlYWR5LXJ1bm5pbmcgc2FuZGJveC4nKVxuXHRcdH1cblx0XHR2YXIgc2FuZGJveFByb3h5ID0gZ2V0UHJveHkoc2FuZGJveClcblx0XHR2YXIgcmVzdWx0LCBlcnJvclxuXHRcdFxuXHRcdGN1cnJlbnRTYW5kYm94ID0gc2FuZGJveFxuXHRcdHRyeSB7XG5cdFx0XHRyZXN1bHQgPSBjb2RlLmNhbGwoc2FuZGJveFByb3h5LCBzYW5kYm94UHJveHkpXG5cdFx0XHRjdXJyZW50U2FuZGJveCA9IHVuZGVmaW5lZFxuXHRcdH0gY2F0Y2ggKGV4KSB7XG5cdFx0XHRjdXJyZW50U2FuZGJveCA9IHVuZGVmaW5lZFxuXHRcdFx0aWYgKGV4IGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdFx0ZXJyb3IgPSBuZXcgZXguY29uc3RydWN0b3IoJycgKyBleC5tZXNzYWdlKVxuXHRcdFx0XHRlcnJvci5zdGFjayA9ICcnICsgZXguc3RhY2tcblx0XHRcdFx0dGhyb3cgZXJyb3Jcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcihTdHJpbmcoZXgpKVxuXHRcdH1cblx0XHRpZiAoaXNPYmplY3QocmVzdWx0KSkge1xuXHRcdFx0dGhyb3cgVHlwZUVycm9yKCdTYW5kYm94ZXMgYXJlIG9ubHkgYWxsb3dlZCB0byByZXR1cm4gcHJpbWl0aXZlIHZhbHVlcy4nKVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0XG5cdH1cbn1cbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZUV4cHJlc3Npb25cblxudmFyIHRyYXBzID0ge1xuXHRnZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdGlmIChrZXkgPT09IHVuc2NvcGFibGVzU3ltYm9sICYmIHRhcmdldCA9PT0gY3VycmVudFNhbmRib3gpIHtcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZFxuXHRcdFx0fVxuXHRcdFx0aWYgKCFub3RQcml2YXRlKGtleSkpIHtcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZFxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGdldFByb3h5T3JQcmltaXRpdmUoUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSlcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcilcblx0fSxcblx0c2V0OiBmdW5jdGlvbiAodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbm5vdCBzZXQgcHJvcGVydGllcyBvbiBhIHNhbmRib3hlZCBvYmplY3QuJylcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpXG5cdH0sXG5cdGhhczogZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHRpZiAodGFyZ2V0ID09PSBjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFub3RQcml2YXRlKGtleSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZ2V0UHJveHlPclByaW1pdGl2ZShSZWZsZWN0Lmhhcyh0YXJnZXQsIGtleSkpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIGtleSlcblx0fSxcblx0Z2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdHJldHVybiBnZXRQcm94eU9yUHJpbWl0aXZlKFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSlcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KVxuXHR9LFxuXHRzZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gKHRhcmdldCwgcHJvdG8pIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBjYW5ub3Qgc2V0IHRoZSBwcm90b3R5cGUgb2YgYSBzYW5kYm94ZWQgb2JqZWN0LicpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0LnNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pXG5cdH0sXG5cdGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0cmV0dXJuIGdldFByb3h5T3JQcmltaXRpdmUoUmVmbGVjdC5pc0V4dGVuc2libGUodGFyZ2V0KSlcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3QuaXNFeHRlbnNpYmxlKHRhcmdldClcblx0fSxcblx0cHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBjYW5ub3QgY2hhbmdlIHRoZSBleHRlbnNpYmlsaXR5IG9mIGEgc2FuZGJveGVkIG9iamVjdC4nKVxuXHRcdH1cblx0XHRyZXR1cm4gUmVmbGVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpXG5cdH0sXG5cdGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHRpZiAoa2V5ID09PSBTeW1ib2wudW5zY29wYWJsZXMgJiYgdGFyZ2V0ID09PSBjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0XHRpZiAoIW5vdFByaXZhdGUoa2V5KSkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZ2V0UHJveHlPclByaW1pdGl2ZShSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSlcblx0fSxcblx0ZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbm5vdCBkZWZpbmUgcHJvcGVydGllcyBvbiBhIHNhbmRib3hlZCBvYmplY3QuJylcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpXG5cdH0sXG5cdGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBjYW5ub3QgZGVsZXRlIHByb3BlcnRpZXMgb24gYSBzYW5kYm94ZWQgb2JqZWN0LicpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KVxuXHR9LFxuXHRvd25LZXlzOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHRyZXR1cm4gZ2V0UHJveHlPclByaW1pdGl2ZShSZWZsZWN0Lm93bktleXModGFyZ2V0KS5maWx0ZXIobm90UHJpdmF0ZSkpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxuXHR9LFxuXHRhcHBseTogZnVuY3Rpb24gKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0aWYgKHRhcmdldCA9PT0gRnVuY3Rpb25Db25zdHJ1Y3RvciB8fCB0YXJnZXQgPT09IEZ1bmN0aW9uQ29uc3RydWN0b3JQcm94eSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgY2Fubm90IHVzZSB0aGUgRnVuY3Rpb24gY29uc3RydWN0b3IgaW4gYSBzYW5kYm94ZWQgY29udGV4dC4nKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGdldFByb3h5T3JQcmltaXRpdmUoUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpKVxuXHRcdH1cblx0XHRyZXR1cm4gUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpXG5cdH0sXG5cdGNvbnN0cnVjdDogZnVuY3Rpb24gKHRhcmdldCwgYXJndW1lbnRzTGlzdCwgbmV3VGFyZ2V0KSB7XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHRpZiAodGFyZ2V0ID09PSBGdW5jdGlvbkNvbnN0cnVjdG9yIHx8IHRhcmdldCA9PT0gRnVuY3Rpb25Db25zdHJ1Y3RvclByb3h5KSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBjYW5ub3QgdXNlIHRoZSBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpbiBhIHNhbmRib3hlZCBjb250ZXh0LicpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZ2V0UHJveHlPclByaW1pdGl2ZShSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QsIG5ld1RhcmdldCkpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QsIG5ld1RhcmdldClcblx0fVxufVxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8ICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKVxufVxuXG5mdW5jdGlvbiBnZXRQcm94eU9yUHJpbWl0aXZlKHZhbHVlKSB7XG5cdGlmIChpc09iamVjdCh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gc2FmZU9iamVjdHMuaW5kZXhPZih2YWx1ZSkgPj0gMCA/IHZhbHVlIDogZ2V0UHJveHkodmFsdWUpXG5cdH1cblx0cmV0dXJuIHZhbHVlXG59XG5cbmZ1bmN0aW9uIGdldFByb3h5KG9iamVjdCwgaGlkZU9yaWdpbmFsKSB7XG5cdGlmIChvYmplY3QgPT09IEdMT0JBTCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBnbG9iYWwgb2JqZWN0IGlzIGZvcmJpZGRlbiBmcm9tIGVudGVyaW5nIGEgc2FuZGJveGVkIGNvbnRleHQuJylcblx0fVxuXHRpZiAob2JqZWN0ID09PSBldmFsRnVuY3Rpb24pIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgZXZhbCBmdW5jdGlvbiBpcyBmb3JiaWRkZW4gZnJvbSBlbnRlcmluZyBhIHNhbmRib3hlZCBjb250ZXh0LicpXG5cdH1cblx0dmFyIHByb3h5ID0gcmVhZG9ubHlQcm94aWVzLmdldChvYmplY3QpXG5cdGlmICh0eXBlb2YgcHJveHkgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cHJveHkgPSBuZXcgUHJveHkob2JqZWN0LCB0cmFwcylcblx0XHRyZWFkb25seVByb3hpZXMuc2V0KGhpZGVPcmlnaW5hbCA/IHByb3h5IDogb2JqZWN0LCBwcm94eSlcblx0fVxuXHRyZXR1cm4gcHJveHlcbn1cblxuZnVuY3Rpb24gbm90UHJpdmF0ZShrZXkpIHtcblx0cmV0dXJuIHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8IGtleVswXSAhPT0gJ18nXG59XG5cbi8vIEZyZWV6ZSBhbmQgcHJveHkgYW55dGhpbmcgdGhhdCBpcyBhY2Nlc3NpYmxlIHRocm91Z2ggSmF2YVNjcmlwdCBzeW50YXggYWxvbmVcbi8vIFRoaXMgc2hvdWxkIGluY2x1ZGUgYW55IHZhbHVlIHRoYXQgeW91IGNhbiBnZXQgZnJvbSBKYXZhU2NyaXB0IHN5bnRheCBpdHNlbGYuXG4vLyBGb3IgZXhhbXBsZTpcbi8vICAgICBcIm15IHN0cmluZ1wiLmZvb2JhclxuLy8gICAgIHRyeSB7dGhyb3cgMX0gY2F0Y2ggKGVycikge2Vyci5mb29iYXJ9XG4vLyBTeW1ib2xzIGFyZSBpbmNsdWRlZCBoZXJlIGJlY2F1c2UgdGhleSBhcmUgbm90IHByb3RlY3RlZCBieSBvdXIgcHJveHlpbmdcbi8vIGJlY2F1c2UgdGhleSBhcmUgcHJpbWl0aXZlcy5cbnZhciBzYWZlT2JqZWN0cyA9IHJlcXVpcmUoJy4vbGliL21ha2Utc2FmZScpKFtcblx0Qm9vbGVhbi5wcm90b3R5cGUsXG5cdE51bWJlci5wcm90b3R5cGUsXG5cdFN0cmluZy5wcm90b3R5cGUsXG5cdFN5bWJvbC5wcm90b3R5cGUsXG5cdEZ1bmN0aW9uLnByb3RvdHlwZSxcblx0T2JqZWN0LnByb3RvdHlwZSxcblx0QXJyYXkucHJvdG90eXBlLFxuXHRSZWdFeHAucHJvdG90eXBlLFxuXHRFcnJvci5wcm90b3R5cGUsXG5cdEV2YWxFcnJvci5wcm90b3R5cGUsXG5cdFJhbmdlRXJyb3IucHJvdG90eXBlLFxuXHRSZWZlcmVuY2VFcnJvci5wcm90b3R5cGUsXG5cdFN5bnRheEVycm9yLnByb3RvdHlwZSxcblx0VHlwZUVycm9yLnByb3RvdHlwZSxcblx0VVJJRXJyb3IucHJvdG90eXBlLFxuXHRQcm9taXNlLnByb3RvdHlwZSxcblx0T2JqZWN0LmdldFByb3RvdHlwZU9mKGZ1bmN0aW9uKigpe30pLFxuXHRPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnVuY3Rpb24qKCl7fSgpKVxuXSwgaXNPYmplY3QsIGdldFByb3h5LCBHTE9CQUwpXG5cbnZhciBldmFsRnVuY3Rpb24gPSBHTE9CQUwuZXZhbFxudmFyIEZ1bmN0aW9uQ29uc3RydWN0b3JQcm94eSA9IDAuLmNvbnN0cnVjdG9yLmNvbnN0cnVjdG9yXG5cbm1vZHVsZS5leHBvcnRzLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cdHJldHVybiBhID09PSBiIHx8IChyZWFkb25seVByb3hpZXMuZ2V0KGEpIHx8IGEpID09PSAocmVhZG9ubHlQcm94aWVzLmdldChiKSB8fCBiKVxufVxuXG5cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1bnNhZmVPYmplY3RzLCBpc09iamVjdCwgZ2V0UHJveHksIEdMT0JBTCkge1xuXHR2YXIgcHJveGllcyA9IFtdXG5cdHZhciBzYWZlT2JqZWN0cyA9IFtdXG5cdHZhciByZXR1cm5zU2FmZVZhbHVlcyA9IFtcblx0XHRGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXVxuXHRdXG5cdHZhciBnbG9iYWxLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoR0xPQkFMKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09ICdyb290JyAmJiBrZXkgIT09ICdHTE9CQUwnICYmIGtleSAhPT0gJ2dsb2JhbCcgJiYga2V5ICE9PSAnd2luZG93JyAmJiBrZXkgIT09ICdzZWxmJ30pXG5cdHZhciBnbG9iYWxWYWx1ZXMgPSBnbG9iYWxLZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIHRoaXNba2V5XX0sIEdMT0JBTClcblx0XG5cdHdoaWxlICh1bnNhZmVPYmplY3RzLmxlbmd0aCkge1xuXHRcdG1ha2VTYWZlKHVuc2FmZU9iamVjdHMuc2hpZnQoKSlcblx0fVxuXHRcblx0ZnVuY3Rpb24gbWFrZVNhZmUob2JqZWN0KSB7XG5cdFx0aWYgKGlzU2FmZShvYmplY3QpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0XG5cdFx0dmFyIHJlYWNoYWJsZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdClcblx0XHRcdC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpKVxuXHRcdFxuXHRcdGlmIChvYmplY3QgPT09IEZ1bmN0aW9uLnByb3RvdHlwZSkge1xuXHRcdFx0cmVhY2hhYmxlID0gcmVhY2hhYmxlLmZpbHRlcihpZ25vcmVkS2V5cylcblx0XHR9XG5cdFx0XG5cdFx0cmVhY2hhYmxlLmZvckVhY2gocmVwbGFjZVdpdGhQcm94eSwgb2JqZWN0KVxuXHRcdE9iamVjdC5mcmVlemUob2JqZWN0KVxuXHRcdHNhZmVPYmplY3RzLnB1c2gob2JqZWN0KVxuXHRcdFxuXHRcdHVuc2FmZU9iamVjdHMucHVzaChPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KSlcblx0fVxuXHRcblx0ZnVuY3Rpb24gaWdub3JlZEtleXMoa2V5KSB7XG5cdFx0cmV0dXJuIGtleSAhPT0gJ2NhbGxlcicgJiYga2V5ICE9PSAnYXJndW1lbnRzJ1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBpc1NhZmUodmFsdWUpIHtcblx0XHRyZXR1cm4gIWlzT2JqZWN0KHZhbHVlKSB8fCBwcm94aWVzLmluZGV4T2YodmFsdWUpID49IDAgfHwgc2FmZU9iamVjdHMuaW5kZXhPZih2YWx1ZSkgPj0gMFxuXHR9XG5cdFxuXHRmdW5jdGlvbiByZXBsYWNlV2l0aFByb3h5KGtleSkge1xuXHRcdHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBrZXkpXG5cdFx0aWYgKCEoJ3ZhbHVlJyBpbiBkKSkge1xuXHRcdFx0aWYgKGtleSA9PT0gJ19fcHJvdG9fXycgJiYgaXNTYWZlKHRoaXNba2V5XSkpIHtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRpZiAoIWQuY29uZmlndXJhYmxlKSB7XG5cdFx0XHRcdGQuZ2V0ICYmIHVuc2FmZU9iamVjdHMucHVzaChkLmdldClcblx0XHRcdFx0ZC5zZXQgJiYgdW5zYWZlT2JqZWN0cy5wdXNoKGQuc2V0KVxuXHRcdFx0XHQvLyBUaGlzIGdldHRlci9zZXR0ZXIgY291bGQgcG90ZW50aWFsbHkgcmV0dXJuIGEgbm9uLXByb3hpZWQgb2JqZWN0XG5cdFx0XHRcdGNvbnNvbGUud2FybignUG90ZW50aWFsbHkgdnVsbmVyYWJsZSBnZXR0ZXIvc2V0dGVyIGF0ICVzIGluICVzJywga2V5LCB0aGlzKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdHZhciBnZXR0ZXIgPSBkLmdldCAmJiBnZXRQcm94eShkLmdldCwgdHJ1ZSlcblx0XHRcdHZhciBzZXR0ZXIgPSBkLnNldCAmJiBnZXRQcm94eShkLnNldCwgdHJ1ZSlcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcblx0XHRcdFx0Z2V0OiBnZXR0ZXIsXG5cdFx0XHRcdHNldDogc2V0dGVyLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiBkLmVudW1lcmFibGUsXG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2Vcblx0XHRcdH0pXG5cdFx0XHRnZXR0ZXIgJiYgcHJveGllcy5wdXNoKGdldHRlcilcblx0XHRcdHNldHRlciAmJiBwcm94aWVzLnB1c2goc2V0dGVyKVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdFxuXHRcdHZhciB2YWx1ZSA9IHRoaXNba2V5XVxuXHRcdGlmIChpc1NhZmUodmFsdWUpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0XG5cdFx0aWYgKGQud3JpdGFibGUpIHtcblx0XHRcdHZhciBwcm94eSA9IGdldFByb3h5KHZhbHVlLCB0cnVlKVxuXHRcdFx0cHJveGllcy5wdXNoKHRoaXNba2V5XSA9IHByb3h5KVxuXHRcdFx0cmVwbGFjZUluR2xvYmFsKHZhbHVlLCBwcm94eSlcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHRpZiAoZC5jb25maWd1cmFibGUpIHtcblx0XHRcdHZhciBwcm94eSA9IGdldFByb3h5KHZhbHVlLCB0cnVlKVxuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuXHRcdFx0XHR2YWx1ZTogcHJveHksXG5cdFx0XHRcdHdyaXRhYmxlOiBmYWxzZSxcblx0XHRcdFx0ZW51bWVyYWJsZTogZC5lbnVtZXJhYmxlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlXG5cdFx0XHR9KVxuXHRcdFx0cmVwbGFjZUluR2xvYmFsKHZhbHVlLCBwcm94eSlcblx0XHRcdHByb3hpZXMucHVzaChwcm94eSlcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHR1bnNhZmVPYmplY3RzLnB1c2godmFsdWUpXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiByZXR1cm5zU2FmZVZhbHVlcy5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcblx0XHRcdC8vIFRoaXMgZnVuY3Rpb24gY291bGQgcG90ZW50aWFsbHkgcmV0dXJuIGEgbm9uLXByb3hpZWQgb2JqZWN0XG5cdFx0XHRjb25zb2xlLndhcm4oJ1BvdGVudGlhbGx5IHZ1bG5lcmFibGUgZnVuY3Rpb24gYXQgJXMgaW4gJXMnLCBrZXksIHRoaXMpXG5cdFx0fVxuXHR9XG5cdFxuXHRmdW5jdGlvbiByZXBsYWNlSW5HbG9iYWwodmFsdWUsIHByb3h5KSB7XG5cdFx0dmFyIGluZGV4ID0gZ2xvYmFsVmFsdWVzLmluZGV4T2YodmFsdWUpXG5cdFx0aWYgKGluZGV4ID49IDApIHtcblx0XHRcdHZhciBrZXkgPSBnbG9iYWxLZXlzW2luZGV4XVxuXHRcdFx0dmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEdMT0JBTCwga2V5KVxuXHRcdFx0aWYgKGQud3JpdGFibGUpIHtcblx0XHRcdFx0R0xPQkFMW2tleV0gPSBwcm94eVxuXHRcdFx0fSBlbHNlIGlmIChkLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoR0xPQkFMLCBrZXksIHtcblx0XHRcdFx0XHR2YWx1ZTogcHJveHksXG5cdFx0XHRcdFx0d3JpdGFibGU6IGZhbHNlLFxuXHRcdFx0XHRcdGVudW1lcmFibGU6IGQuZW51bWVyYWJsZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlXG5cdFx0XHRcdH0pXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1dhcyBub3QgYWJsZSB0byByZXBsYWNlICVzIGluIGdsb2JhbCBvYmplY3QnLCBrZXkpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRyZXR1cm4gc2FmZU9iamVjdHNcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4Jyk7XG52YXIgcmUgPSBuZXcgUmVnRXhwKGFuc2lSZWdleCgpLnNvdXJjZSk7IC8vIHJlbW92ZSB0aGUgYGdgIGZsYWdcbm1vZHVsZS5leHBvcnRzID0gcmUudGVzdC5iaW5kKHJlKTtcbiIsIi8qKlxuICogwqkgQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE3IEFsbCBSaWdodHMgUmVzZXJ2ZWRcbiAqICAgUHJvamVjdCBuYW1lOiBKU09OYXRhXG4gKiAgIFRoaXMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UsIHNlZSBMSUNFTlNFXG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIEpTT05hdGFcbiAqIEBkZXNjcmlwdGlvbiBKU09OIHF1ZXJ5IGFuZCB0cmFuc2Zvcm1hdGlvbiBsYW5ndWFnZVxuICovXG5cbi8qKlxuICoganNvbmF0YVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICogQHJldHVybnMge3tldmFsdWF0ZTogZXZhbHVhdGUsIGFzc2lnbjogYXNzaWdufX0gRXZhbHVhdGVkIGV4cHJlc3Npb25cbiAqL1xudmFyIGpzb25hdGEgPSAoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG9wZXJhdG9ycyA9IHtcbiAgICAgICAgJy4nOiA3NSxcbiAgICAgICAgJ1snOiA4MCxcbiAgICAgICAgJ10nOiAwLFxuICAgICAgICAneyc6IDcwLFxuICAgICAgICAnfSc6IDAsXG4gICAgICAgICcoJzogODAsXG4gICAgICAgICcpJzogMCxcbiAgICAgICAgJywnOiAwLFxuICAgICAgICAnQCc6IDc1LFxuICAgICAgICAnIyc6IDcwLFxuICAgICAgICAnOyc6IDgwLFxuICAgICAgICAnOic6IDgwLFxuICAgICAgICAnPyc6IDIwLFxuICAgICAgICAnKyc6IDUwLFxuICAgICAgICAnLSc6IDUwLFxuICAgICAgICAnKic6IDYwLFxuICAgICAgICAnLyc6IDYwLFxuICAgICAgICAnJSc6IDYwLFxuICAgICAgICAnfCc6IDIwLFxuICAgICAgICAnPSc6IDQwLFxuICAgICAgICAnPCc6IDQwLFxuICAgICAgICAnPic6IDQwLFxuICAgICAgICAnXic6IDQwLFxuICAgICAgICAnKionOiA2MCxcbiAgICAgICAgJy4uJzogMjAsXG4gICAgICAgICc6PSc6IDEwLFxuICAgICAgICAnIT0nOiA0MCxcbiAgICAgICAgJzw9JzogNDAsXG4gICAgICAgICc+PSc6IDQwLFxuICAgICAgICAnfj4nOiA0MCxcbiAgICAgICAgJ2FuZCc6IDMwLFxuICAgICAgICAnb3InOiAyNSxcbiAgICAgICAgJ2luJzogNDAsXG4gICAgICAgICcmJzogNTAsXG4gICAgICAgICchJzogMCwgICAvLyBub3QgYW4gb3BlcmF0b3IsIGJ1dCBuZWVkZWQgYXMgYSBzdG9wIGNoYXJhY3RlciBmb3IgbmFtZSB0b2tlbnNcbiAgICAgICAgJ34nOiAwICAgLy8gbm90IGFuIG9wZXJhdG9yLCBidXQgbmVlZGVkIGFzIGEgc3RvcCBjaGFyYWN0ZXIgZm9yIG5hbWUgdG9rZW5zXG4gICAgfTtcblxuICAgIHZhciBlc2NhcGVzID0geyAgLy8gSlNPTiBzdHJpbmcgZXNjYXBlIHNlcXVlbmNlcyAtIHNlZSBqc29uLm9yZ1xuICAgICAgICAnXCInOiAnXCInLFxuICAgICAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAgICAgJy8nOiAnLycsXG4gICAgICAgICdiJzogJ1xcYicsXG4gICAgICAgICdmJzogJ1xcZicsXG4gICAgICAgICduJzogJ1xcbicsXG4gICAgICAgICdyJzogJ1xccicsXG4gICAgICAgICd0JzogJ1xcdCdcbiAgICB9O1xuXG4gICAgLy8gVG9rZW5pemVyIChsZXhlcikgLSBpbnZva2VkIGJ5IHRoZSBwYXJzZXIgdG8gcmV0dXJuIG9uZSB0b2tlbiBhdCBhIHRpbWVcbiAgICB2YXIgdG9rZW5pemVyID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gMDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICAgIHZhciBjcmVhdGUgPSBmdW5jdGlvbiAodHlwZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSB7dHlwZTogdHlwZSwgdmFsdWU6IHZhbHVlLCBwb3NpdGlvbjogcG9zaXRpb259O1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc2NhblJlZ2V4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyB0aGUgcHJlZml4ICcvJyB3aWxsIGhhdmUgYmVlbiBwcmV2aW91c2x5IHNjYW5uZWQuIEZpbmQgdGhlIGVuZCBvZiB0aGUgcmVnZXguXG4gICAgICAgICAgICAvLyBzZWFyY2ggZm9yIGNsb3NpbmcgJy8nIGlnbm9yaW5nIGFueSB0aGF0IGFyZSBlc2NhcGVkLCBvciB3aXRoaW4gYnJhY2tldHNcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIGRlcHRoID0gMDtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuO1xuICAgICAgICAgICAgdmFyIGZsYWdzO1xuICAgICAgICAgICAgd2hpbGUocG9zaXRpb24gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudENoYXIgPSBwYXRoLmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYoY3VycmVudENoYXIgPT09ICcvJyAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiAtIDEpICE9PSAnXFxcXCcgJiYgZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5kIG9mIHJlZ2V4IGZvdW5kXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBwYXRoLnN1YnN0cmluZyhzdGFydCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZihwYXR0ZXJuID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAzMDFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYXIgPSBwYXRoLmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZsYWdzXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGN1cnJlbnRDaGFyID09PSAnaScgfHwgY3VycmVudENoYXIgPT09ICdtJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFyID0gcGF0aC5jaGFyQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzID0gcGF0aC5zdWJzdHJpbmcoc3RhcnQsIHBvc2l0aW9uKSArICdnJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZigoY3VycmVudENoYXIgPT09ICcoJyB8fCBjdXJyZW50Q2hhciA9PT0gJ1snIHx8IGN1cnJlbnRDaGFyID09PSAneycpICYmIHBhdGguY2hhckF0KHBvc2l0aW9uIC0gMSkgIT09ICdcXFxcJyApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoKGN1cnJlbnRDaGFyID09PSAnKScgfHwgY3VycmVudENoYXIgPT09ICddJyB8fCBjdXJyZW50Q2hhciA9PT0gJ30nKSAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiAtIDEpICE9PSAnXFxcXCcgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMzAyXCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID49IGxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgY3VycmVudENoYXIgPSBwYXRoLmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICAvLyBza2lwIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCAmJiAnIFxcdFxcblxcclxcdicuaW5kZXhPZihjdXJyZW50Q2hhcikgPiAtMSkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgY3VycmVudENoYXIgPSBwYXRoLmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IGZvciByZWdleFxuICAgICAgICAgICAgaWYgKHByZWZpeCAhPT0gdHJ1ZSAmJiBjdXJyZW50Q2hhciA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdyZWdleCcsIHNjYW5SZWdleCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhbmRsZSBkb3VibGUtY2hhciBvcGVyYXRvcnNcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJy4nICYmIHBhdGguY2hhckF0KHBvc2l0aW9uICsgMSkgPT09ICcuJykge1xuICAgICAgICAgICAgICAgIC8vIGRvdWJsZS1kb3QgLi4gcmFuZ2Ugb3BlcmF0b3JcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ29wZXJhdG9yJywgJy4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICc6JyAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiArIDEpID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICAvLyA6PSBhc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdvcGVyYXRvcicsICc6PScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnIScgJiYgcGF0aC5jaGFyQXQocG9zaXRpb24gKyAxKSA9PT0gJz0nKSB7XG4gICAgICAgICAgICAgICAgLy8gIT1cbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ29wZXJhdG9yJywgJyE9Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICc+JyAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiArIDEpID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICAvLyA+PVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgnb3BlcmF0b3InLCAnPj0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJzwnICYmIHBhdGguY2hhckF0KHBvc2l0aW9uICsgMSkgPT09ICc9Jykge1xuICAgICAgICAgICAgICAgIC8vIDw9XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdvcGVyYXRvcicsICc8PScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnKicgJiYgcGF0aC5jaGFyQXQocG9zaXRpb24gKyAxKSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgLy8gKiogIGRlc2NlbmRhbnQgd2lsZGNhcmRcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ29wZXJhdG9yJywgJyoqJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICd+JyAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiArIDEpID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICAvLyB+PiAgY2hhaW4gZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ29wZXJhdG9yJywgJ34+Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IGZvciBzaW5nbGUgY2hhciBvcGVyYXRvcnNcbiAgICAgICAgICAgIGlmIChvcGVyYXRvcnMuaGFzT3duUHJvcGVydHkoY3VycmVudENoYXIpKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdvcGVyYXRvcicsIGN1cnJlbnRDaGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgZm9yIHN0cmluZyBsaXRlcmFsc1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnXCInIHx8IGN1cnJlbnRDaGFyID09PSBcIidcIikge1xuICAgICAgICAgICAgICAgIHZhciBxdW90ZVR5cGUgPSBjdXJyZW50Q2hhcjtcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUgcXVvdGVkIHN0cmluZyBsaXRlcmFsIC0gZmluZCBlbmQgb2Ygc3RyaW5nXG4gICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICB2YXIgcXN0ciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFyID0gcGF0aC5jaGFyQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICdcXFxcJykgeyAvLyBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhciA9IHBhdGguY2hhckF0KHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlc2NhcGVzLmhhc093blByb3BlcnR5KGN1cnJlbnRDaGFyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFzdHIgKz0gZXNjYXBlc1tjdXJyZW50Q2hhcl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDaGFyID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcXHUgc2hvdWxkIGJlIGZvbGxvd2VkIGJ5IDQgaGV4IGRpZ2l0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvY3RldHMgPSBwYXRoLnN1YnN0cihwb3NpdGlvbiArIDEsIDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXlswLTlhLWZBLUZdKyQvLnRlc3Qob2N0ZXRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kZXBvaW50ID0gcGFyc2VJbnQob2N0ZXRzLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAxMDRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbGxlZ2FsIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDEwM1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogY3VycmVudENoYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENoYXIgPT09IHF1b3RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ3N0cmluZycsIHFzdHIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXN0ciArPSBjdXJyZW50Q2hhcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAxMDFcIixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IGZvciBudW1iZXJzXG4gICAgICAgICAgICB2YXIgbnVtcmVnZXggPSAvXi0/KDB8KFsxLTldWzAtOV0qKSkoXFwuWzAtOV0rKT8oW0VlXVstK10/WzAtOV0rKT8vO1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gbnVtcmVnZXguZXhlYyhwYXRoLnN1YnN0cmluZyhwb3NpdGlvbikpO1xuICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG51bSA9IHBhcnNlRmxvYXQobWF0Y2hbMF0pO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4obnVtKSAmJiBpc0Zpbml0ZShudW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgnbnVtYmVyJywgbnVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMTAyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBtYXRjaFswXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgZm9yIHF1b3RlZCBuYW1lcyAoYmFja3RpY2tzKVxuICAgICAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgICAgICBpZihjdXJyZW50Q2hhciA9PT0gJ2AnKSB7XG4gICAgICAgICAgICAgICAgLy8gc2NhbiBmb3IgY2xvc2luZyBxdW90ZVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IHBhdGguaW5kZXhPZignYCcsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZihlbmQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBwYXRoLnN1YnN0cmluZyhwb3NpdGlvbiwgZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBlbmQgKyAxO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCduYW1lJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gbGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDEwNVwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgZm9yIG5hbWVzXG4gICAgICAgICAgICB2YXIgaSA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIGNoO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGNoID0gcGF0aC5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGxlbmd0aCB8fCAnIFxcdFxcblxcclxcdicuaW5kZXhPZihjaCkgPiAtMSB8fCBvcGVyYXRvcnMuaGFzT3duUHJvcGVydHkoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoLmNoYXJBdChwb3NpdGlvbikgPT09ICckJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyaWFibGUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gcGF0aC5zdWJzdHJpbmcocG9zaXRpb24gKyAxLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ3ZhcmlhYmxlJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gcGF0aC5zdWJzdHJpbmcocG9zaXRpb24sIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnb3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2luJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhbmQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdvcGVyYXRvcicsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RydWUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCd2YWx1ZScsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhbHNlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgndmFsdWUnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ3ZhbHVlJywgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSBsZW5ndGggJiYgbmFtZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaXRlc3BhY2UgYXQgZW5kIG9mIGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCduYW1lJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBmdW5jdGlvbiBzaWduYXR1cmUgZGVmaW5pdGlvbiBhbmQgcmV0dXJucyBhIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlIC0gdGhlIHNpZ25hdHVyZSBiZXR3ZWVuIHRoZSA8YW5nbGUgYnJhY2tldHM+XG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIFJlZ2V4IHRoYXQgcmVwcmVzZW50cyB0aGlzIHNpZ25hdHVyZSBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB3aGVuIGludm9rZWQsXG4gICAgICAgIC8vIHJldHVybnMgdGhlIHZhbGlkYXRlZCAocG9zc2libHkgZml4ZWQtdXApIGFyZ3VtZW50cywgb3IgdGhyb3dzIGEgdmFsaWRhdGlvbiBlcnJvclxuICAgICAgICAvLyBzdGVwIHRocm91Z2ggdGhlIHNpZ25hdHVyZSwgb25lIHN5bWJvbCBhdCBhIHRpbWVcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gMTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICB2YXIgcGFyYW0gPSB7fTtcbiAgICAgICAgdmFyIHByZXZQYXJhbSA9IHBhcmFtO1xuICAgICAgICB3aGlsZSAocG9zaXRpb24gPCBzaWduYXR1cmUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc3ltYm9sID0gc2lnbmF0dXJlLmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICBpZihzeW1ib2wgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gZmlndXJlIG91dCB3aGF0IHRvIGRvIHdpdGggdGhlIHJldHVybiB0eXBlXG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIGl0IGZvciBub3dcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgcHJldlBhcmFtID0gcGFyYW07XG4gICAgICAgICAgICAgICAgcGFyYW0gPSB7fTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBmaW5kQ2xvc2luZ0JyYWNrZXQgPSBmdW5jdGlvbihzdHIsIHN0YXJ0LCBvcGVuU3ltYm9sLCBjbG9zZVN5bWJvbCkge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjbG9zaW5nIHN5bWJvbCAoZS5nLiBicmFja2V0KSBpbiBhIHN0cmluZ1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgYmFsYW5jZXMgdGhlIG9wZW5pbmcgc3ltYm9sIGF0IHBvc2l0aW9uIHN0YXJ0XG4gICAgICAgICAgICAgICAgdmFyIGRlcHRoID0gMTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBzdGFydDtcbiAgICAgICAgICAgICAgICB3aGlsZShwb3NpdGlvbiA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gc3RyLmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbCA9PT0gY2xvc2VTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gb3V0IG9mIHdoaWxlIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHN5bWJvbCA9PT0gb3BlblN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHN5bWJvbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOiAvLyBzdHJpbmdcbiAgICAgICAgICAgICAgICBjYXNlICduJzogLy8gbnVtYmVyXG4gICAgICAgICAgICAgICAgY2FzZSAnYic6IC8vIGJvb2xlYW5cbiAgICAgICAgICAgICAgICBjYXNlICdsJzogLy8gbm90IHNvIHN1cmUgYWJvdXQgZXhwZWN0aW5nIG51bGw/XG4gICAgICAgICAgICAgICAgY2FzZSAnbyc6IC8vIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBwYXJhbS5yZWdleCA9ICdbJyArIHN5bWJvbCArICdtXSc7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnR5cGUgPSBzeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYSc6IC8vIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIC8vICBub3JtYWxseSB0cmVhdCBhbnkgdmFsdWUgYXMgc2luZ2xldG9uIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnJlZ2V4ID0gJ1thc25ibGZvbV0nO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbS50eXBlID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbS5hcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZic6IC8vIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnJlZ2V4ID0gJ2YnO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbS50eXBlID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2onOiAvLyBhbnkgSlNPTiB0eXBlXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnJlZ2V4ID0gJ1thc25ibG9tXSc7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnR5cGUgPSBzeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAneCc6IC8vIGFueSB0eXBlXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnJlZ2V4ID0gJ1thc25ibGZvbV0nO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbS50eXBlID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJy0nOiAvLyB1c2UgY29udGV4dCBpZiBwYXJhbSBub3Qgc3VwcGxpZWRcbiAgICAgICAgICAgICAgICAgICAgcHJldlBhcmFtLmNvbnRleHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwcmV2UGFyYW0uY29udGV4dFJlZ2V4ID0gbmV3IFJlZ0V4cChwcmV2UGFyYW0ucmVnZXgpOyAvLyBwcmUtY29tcGlsZWQgdG8gdGVzdCB0aGUgY29udGV4dCB0eXBlIGF0IHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAgICAgcHJldlBhcmFtLnJlZ2V4ICs9ICc/JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnPyc6IC8vIG9wdGlvbmFsIHBhcmFtXG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6IC8vIG9uZSBvciBtb3JlXG4gICAgICAgICAgICAgICAgICAgIHByZXZQYXJhbS5yZWdleCArPSBzeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJygnOiAvLyBjaG9pY2Ugb2YgdHlwZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VhcmNoIGZvcndhcmQgZm9yIG1hdGNoaW5nICcpJ1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kUGFyZW4gPSBmaW5kQ2xvc2luZ0JyYWNrZXQoc2lnbmF0dXJlLCBwb3NpdGlvbiwgJygnLCAnKScpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hvaWNlID0gc2lnbmF0dXJlLnN1YnN0cmluZyhwb3NpdGlvbiArIDEsIGVuZFBhcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoY2hvaWNlLmluZGV4T2YoJzwnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIHBhcmFtZXRlcml6ZWQgdHlwZXMsIHNpbXBsZSByZWdleFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0ucmVnZXggPSAnWycgKyBjaG9pY2UgKyAnbV0nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBoYXJkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwNDAyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNob2ljZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnR5cGUgPSAnKCcgKyBjaG9pY2UgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gZW5kUGFyZW47XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnPCc6IC8vIHR5cGUgcGFyYW1ldGVyIC0gY2FuIG9ubHkgYmUgYXBwbGllZCB0byAnYScgYW5kICdmJ1xuICAgICAgICAgICAgICAgICAgICBpZihwcmV2UGFyYW0udHlwZSA9PT0gJ2EnIHx8IHByZXZQYXJhbS50eXBlID09PSAnZicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBmb3J3YXJkIGZvciBtYXRjaGluZyAnPidcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRQb3MgPSBmaW5kQ2xvc2luZ0JyYWNrZXQoc2lnbmF0dXJlLCBwb3NpdGlvbiwgJzwnLCAnPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldlBhcmFtLnN1YnR5cGUgPSBzaWduYXR1cmUuc3Vic3RyaW5nKHBvc2l0aW9uICsgMSwgZW5kUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gZW5kUG9zO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzA0MDFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcHJldlBhcmFtLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZ2V4U3RyID0gJ14nICtcbiAgICAgICAgICBwYXJhbXMubWFwKGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnKCcgKyBwYXJhbS5yZWdleCArICcpJztcbiAgICAgICAgICB9KS5qb2luKCcnKSArXG4gICAgICAgICAgJyQnO1xuICAgICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4U3RyKTtcbiAgICAgICAgdmFyIGdldFN5bWJvbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgc3ltYm9sO1xuICAgICAgICAgICAgaWYoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSAnZic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gJ3MnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSAnbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSAnYic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9ICdsJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSAnYSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9ICdvJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW55IHZhbHVlIGNhbiBiZSB1bmRlZmluZWQsIGJ1dCBzaG91bGQgYmUgYWxsb3dlZCB0byBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gJ20nOyAvLyBtIGZvciBtaXNzaW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdGhyb3dWYWxpZGF0aW9uRXJyb3IgPSBmdW5jdGlvbihiYWRBcmdzLCBiYWRTaWcpIHtcbiAgICAgICAgICAgIC8vIHRvIGZpZ3VyZSBvdXQgd2hlcmUgdGhpcyB3ZW50IHdyb25nIHdlIG5lZWQgYXBwbHkgZWFjaCBjb21wb25lbnQgb2YgdGhlXG4gICAgICAgICAgICAvLyByZWdleCB0byBlYWNoIGFyZ3VtZW50IHVudGlsIHdlIGdldCB0byB0aGUgb25lIHRoYXQgZmFpbHMgdG8gbWF0Y2hcbiAgICAgICAgICAgIHZhciBwYXJ0aWFsUGF0dGVybiA9ICdeJztcbiAgICAgICAgICAgIHZhciBnb29kVG8gPSAwO1xuICAgICAgICAgICAgZm9yKHZhciBpbmRleCA9IDA7IGluZGV4IDwgcGFyYW1zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHBhcnRpYWxQYXR0ZXJuICs9IHBhcmFtc1tpbmRleF0ucmVnZXg7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gYmFkU2lnLm1hdGNoKHBhcnRpYWxQYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBpZihtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmYWlsZWQgaGVyZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQwNDEwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBiYWRBcmdzW2dvb2RUb10sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogZ29vZFRvICsgMVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnb29kVG8gPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBpdCBnb3QgdGhpcyBmYXIsIGl0J3MgcHJvYmFibHkgYmVjYXVzZSBvZiBleHRyYW5lb3VzIGFyZ3VtZW50cyAod2VcbiAgICAgICAgICAgIC8vIGhhdmVuJ3QgYWRkZWQgdGhlIHRyYWlsaW5nICckJyBpbiB0aGUgcmVnZXggeWV0LlxuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiVDA0MTBcIixcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYmFkQXJnc1tnb29kVG9dLFxuICAgICAgICAgICAgICAgIGluZGV4OiBnb29kVG8gKyAxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWZpbml0aW9uOiBzaWduYXR1cmUsXG4gICAgICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24oYXJncywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBzdXBwbGllZFNpZyA9ICcnO1xuICAgICAgICAgICAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwcGxpZWRTaWcgKz0gZ2V0U3ltYm9sKGFyZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGlzVmFsaWQgPSByZWdleC5leGVjKHN1cHBsaWVkU2lnKTtcbiAgICAgICAgICAgICAgICBpZihpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZGF0ZWRBcmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3NbYXJnSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gaXNWYWxpZFtpbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobWF0Y2ggPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Vic3RpdHV0ZSBjb250ZXh0IHZhbHVlIGZvciBtaXNzaW5nIGFyZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdCBjaGVjayB0aGF0IHRoZSBjb250ZXh0IHZhbHVlIGlzIHRoZSByaWdodCB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0VHlwZSA9IGdldFN5bWJvbChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGVzdCBjb250ZXh0VHlwZSBhZ2FpbnN0IHRoZSByZWdleCBmb3IgdGhpcyBhcmcgKHdpdGhvdXQgdGhlIHRyYWlsaW5nID8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHBhcmFtLmNvbnRleHRSZWdleC50ZXN0KGNvbnRleHRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVkQXJncy5wdXNoKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGV4dCB2YWx1ZSBub3QgY29tcGF0aWJsZSB3aXRoIHRoaXMgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQwNDExXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGFyZ0luZGV4ICsgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlZEFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF5IGhhdmUgbWF0Y2hlZCBtdWx0aXBsZSBhcmdzIChpZiB0aGUgcmVnZXggZW5kcyB3aXRoIGEgJysnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BsaXQgaW50byBzaW5nbGUgdG9rZW5zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2guc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24oc2luZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSAnYScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaW5nbGUgPT09ICdtJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pc3NpbmcgKHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3NbYXJnSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcnJheU9LID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyB0aGVyZSB0eXBlIGluZm9ybWF0aW9uIG9uIHRoZSBjb250ZW50cyBvZiB0aGUgYXJyYXk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbS5zdWJ0eXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2luZ2xlICE9PSAnYScgJiYgbWF0Y2ggIT09IHBhcmFtLnN1YnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5T0sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzaW5nbGUgPT09ICdhJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1UeXBlID0gZ2V0U3ltYm9sKGFyZ1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1UeXBlICE9PSBwYXJhbS5zdWJ0eXBlLmNoYXJBdCgwKSkgeyAvLyBUT0RPIHJlY3Vyc2UgZnVydGhlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheU9LID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGV2ZXJ5IGl0ZW0gaW4gdGhlIGFycmF5IGlzIHRoaXMgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZmVyZW50SXRlbXMgPSBhcmcuZmlsdGVyKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZ2V0U3ltYm9sKHZhbCkgIT09IGl0ZW1UeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5T0sgPSAoZGlmZmVyZW50SXRlbXMubGVuZ3RoID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnJheU9LKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDA0MTJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGFyZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBhcmdJbmRleCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBwYXJhbS5zdWJ0eXBlIC8vIFRPRE8gdHJhbnNsYXRlIHN5bWJvbCB0byB0eXBlIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZ1bmN0aW9uIGV4cGVjdHMgYW4gYXJyYXkuIElmIGl0J3Mgbm90IG9uZSwgbWFrZSBpdCBzb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaW5nbGUgIT09ICdhJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBbYXJnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZWRBcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ0luZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZWRBcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ0luZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZWRBcmdzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvd1ZhbGlkYXRpb25FcnJvcihhcmdzLCBzdXBwbGllZFNpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBwYXJzZXIgaW1wbGVtZW50cyB0aGUgJ1RvcCBkb3duIG9wZXJhdG9yIHByZWNlZGVuY2UnIGFsZ29yaXRobSBkZXZlbG9wZWQgYnkgVmF1Z2hhbiBSIFByYXR0OyBodHRwOi8vZGwuYWNtLm9yZy9jaXRhdGlvbi5jZm0/aWQ9NTEyOTMxLlxuICAgIC8vIGFuZCBidWlsZHMgb24gdGhlIEphdmFzY3JpcHQgZnJhbWV3b3JrIGRlc2NyaWJlZCBieSBEb3VnbGFzIENyb2NrZm9yZCBhdCBodHRwOi8vamF2YXNjcmlwdC5jcm9ja2ZvcmQuY29tL3Rkb3AvdGRvcC5odG1sXG4gICAgLy8gYW5kIGluICdCZWF1dGlmdWwgQ29kZScsIGVkaXRlZCBieSBBbmR5IE9yYW0gYW5kIEdyZWcgV2lsc29uLCBDb3B5cmlnaHQgMjAwNyBPJ1JlaWxseSBNZWRpYSwgSW5jLiA3OTgtMC01OTYtNTEwMDQtNlxuXG4gICAgdmFyIHBhcnNlciA9IGZ1bmN0aW9uIChzb3VyY2UsIHJlY292ZXIpIHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHZhciBsZXhlcjtcblxuICAgICAgICB2YXIgc3ltYm9sX3RhYmxlID0ge307XG4gICAgICAgIHZhciBlcnJvcnMgPSBbXTtcblxuICAgICAgICB2YXIgcmVtYWluaW5nVG9rZW5zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gW107XG4gICAgICAgICAgICBpZihub2RlLmlkICE9PSAnKGVuZCknKSB7XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nLnB1c2goe3R5cGU6IG5vZGUudHlwZSwgdmFsdWU6IG5vZGUudmFsdWUsIHBvc2l0aW9uOiBub2RlLnBvc2l0aW9ufSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbnh0ID0gbGV4ZXIoKTtcbiAgICAgICAgICAgIHdoaWxlKG54dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZy5wdXNoKG54dCk7XG4gICAgICAgICAgICAgICAgbnh0ID0gbGV4ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZW1haW5pbmc7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGJhc2Vfc3ltYm9sID0ge1xuICAgICAgICAgICAgbnVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gZXJyb3IgLSBzeW1ib2wgaGFzIGJlZW4gaW52b2tlZCBhcyBhIHVuYXJ5IG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogJ1MwMjExJyxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IHRoaXMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmKHJlY292ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyLnJlbWFpbmluZyA9IHJlbWFpbmluZ1Rva2VucygpO1xuICAgICAgICAgICAgICAgICAgICBlcnIudHlwZSA9ICdlcnJvcic7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc3ltYm9sID0gZnVuY3Rpb24gKGlkLCBicCkge1xuICAgICAgICAgICAgdmFyIHMgPSBzeW1ib2xfdGFibGVbaWRdO1xuICAgICAgICAgICAgYnAgPSBicCB8fCAwO1xuICAgICAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnAgPj0gcy5sYnApIHtcbiAgICAgICAgICAgICAgICAgICAgcy5sYnAgPSBicDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgPSBPYmplY3QuY3JlYXRlKGJhc2Vfc3ltYm9sKTtcbiAgICAgICAgICAgICAgICBzLmlkID0gcy52YWx1ZSA9IGlkO1xuICAgICAgICAgICAgICAgIHMubGJwID0gYnA7XG4gICAgICAgICAgICAgICAgc3ltYm9sX3RhYmxlW2lkXSA9IHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaGFuZGxlRXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmKHJlY292ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyB0b2tlbml6ZSB0aGUgcmVzdCBvZiB0aGUgYnVmZmVyIGFuZCBhZGQgaXQgdG8gYW4gZXJyb3IgdG9rZW5cbiAgICAgICAgICAgICAgICBlcnIucmVtYWluaW5nID0gcmVtYWluaW5nVG9rZW5zKCk7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gc3ltYm9sX3RhYmxlW1wiKGVycm9yKVwiXTtcbiAgICAgICAgICAgICAgICBub2RlID0gT2JqZWN0LmNyZWF0ZShzeW1ib2wpO1xuICAgICAgICAgICAgICAgIG5vZGUuZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgbm9kZS50eXBlID0gXCIoZXJyb3IpXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVyci5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhZHZhbmNlID0gZnVuY3Rpb24gKGlkLCBpbmZpeCkge1xuICAgICAgICAgICAgaWYgKGlkICYmIG5vZGUuaWQgIT09IGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGU7XG4gICAgICAgICAgICAgICAgaWYobm9kZS5pZCA9PT0gJyhlbmQpJykge1xuICAgICAgICAgICAgICAgICAgICAvLyB1bmV4cGVjdGVkIGVuZCBvZiBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IFwiUzAyMDNcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2RlID0gXCJTMDIwMlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZXJyID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogbm9kZS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IG5vZGUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV4dF90b2tlbiA9IGxleGVyKGluZml4KTtcbiAgICAgICAgICAgIGlmIChuZXh0X3Rva2VuID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHN5bWJvbF90YWJsZVtcIihlbmQpXCJdO1xuICAgICAgICAgICAgICAgIG5vZGUucG9zaXRpb24gPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gbmV4dF90b2tlbi52YWx1ZTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gbmV4dF90b2tlbi50eXBlO1xuICAgICAgICAgICAgdmFyIHN5bWJvbDtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3ZhcmlhYmxlJzpcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gc3ltYm9sX3RhYmxlW1wiKG5hbWUpXCJdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdvcGVyYXRvcic6XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbF90YWJsZVt2YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMjA0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG5leHRfdG9rZW4ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJsaXRlcmFsXCI7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbF90YWJsZVtcIihsaXRlcmFsKVwiXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmVnZXgnOlxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJyZWdleFwiO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2xfdGFibGVbXCIocmVnZXgpXCJdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAyMDVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG5leHRfdG9rZW4ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSBPYmplY3QuY3JlYXRlKHN5bWJvbCk7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBub2RlLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgbm9kZS5wb3NpdGlvbiA9IG5leHRfdG9rZW4ucG9zaXRpb247XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQcmF0dCdzIGFsZ29yaXRobVxuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChyYnApIHtcbiAgICAgICAgICAgIHZhciBsZWZ0O1xuICAgICAgICAgICAgdmFyIHQgPSBub2RlO1xuICAgICAgICAgICAgYWR2YW5jZShudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIGxlZnQgPSB0Lm51ZCgpO1xuICAgICAgICAgICAgd2hpbGUgKHJicCA8IG5vZGUubGJwKSB7XG4gICAgICAgICAgICAgICAgdCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSB0LmxlZChsZWZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB0ZXJtaW5hbCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHN5bWJvbChpZCwgMCk7XG4gICAgICAgICAgICBzLm51ZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBtYXRjaCBpbmZpeCBvcGVyYXRvcnNcbiAgICAgICAgLy8gPGV4cHJlc3Npb24+IDxvcGVyYXRvcj4gPGV4cHJlc3Npb24+XG4gICAgICAgIC8vIGxlZnQgYXNzb2NpYXRpdmVcbiAgICAgICAgdmFyIGluZml4ID0gZnVuY3Rpb24gKGlkLCBicCwgbGVkKSB7XG4gICAgICAgICAgICB2YXIgYmluZGluZ1Bvd2VyID0gYnAgfHwgb3BlcmF0b3JzW2lkXTtcbiAgICAgICAgICAgIHZhciBzID0gc3ltYm9sKGlkLCBiaW5kaW5nUG93ZXIpO1xuICAgICAgICAgICAgcy5sZWQgPSBsZWQgfHwgZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxocyA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yaHMgPSBleHByZXNzaW9uKGJpbmRpbmdQb3dlcik7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJiaW5hcnlcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBtYXRjaCBpbmZpeCBvcGVyYXRvcnNcbiAgICAgICAgLy8gPGV4cHJlc3Npb24+IDxvcGVyYXRvcj4gPGV4cHJlc3Npb24+XG4gICAgICAgIC8vIHJpZ2h0IGFzc29jaWF0aXZlXG4gICAgICAgIHZhciBpbmZpeHIgPSBmdW5jdGlvbiAoaWQsIGJwLCBsZWQpIHtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nUG93ZXIgPSBicCB8fCBvcGVyYXRvcnNbaWRdO1xuICAgICAgICAgICAgdmFyIHMgPSBzeW1ib2woaWQsIGJpbmRpbmdQb3dlcik7XG4gICAgICAgICAgICBzLmxlZCA9IGxlZCB8fCBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGhzID0gbGVmdDtcbiAgICAgICAgICAgICAgICB0aGlzLnJocyA9IGV4cHJlc3Npb24oYmluZGluZ1Bvd2VyIC0gMSk7IC8vIHN1YnRyYWN0IDEgZnJvbSBiaW5kaW5nUG93ZXIgZm9yIHJpZ2h0IGFzc29jaWF0aXZlIG9wZXJhdG9yc1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiYmluYXJ5XCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbWF0Y2ggcHJlZml4IG9wZXJhdG9yc1xuICAgICAgICAvLyA8b3BlcmF0b3I+IDxleHByZXNzaW9uPlxuICAgICAgICB2YXIgcHJlZml4ID0gZnVuY3Rpb24gKGlkLCBudWQpIHtcbiAgICAgICAgICAgIHZhciBzID0gc3ltYm9sKGlkKTtcbiAgICAgICAgICAgIHMubnVkID0gbnVkIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uKDcwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcInVuYXJ5XCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGVybWluYWwoXCIoZW5kKVwiKTtcbiAgICAgICAgdGVybWluYWwoXCIobmFtZSlcIik7XG4gICAgICAgIHRlcm1pbmFsKFwiKGxpdGVyYWwpXCIpO1xuICAgICAgICB0ZXJtaW5hbChcIihyZWdleClcIik7XG4gICAgICAgIHN5bWJvbChcIjpcIik7XG4gICAgICAgIHN5bWJvbChcIjtcIik7XG4gICAgICAgIHN5bWJvbChcIixcIik7XG4gICAgICAgIHN5bWJvbChcIilcIik7XG4gICAgICAgIHN5bWJvbChcIl1cIik7XG4gICAgICAgIHN5bWJvbChcIn1cIik7XG4gICAgICAgIHN5bWJvbChcIi4uXCIpOyAvLyByYW5nZSBvcGVyYXRvclxuICAgICAgICBpbmZpeChcIi5cIik7IC8vIGZpZWxkIHJlZmVyZW5jZVxuICAgICAgICBpbmZpeChcIitcIik7IC8vIG51bWVyaWMgYWRkaXRpb25cbiAgICAgICAgaW5maXgoXCItXCIpOyAvLyBudW1lcmljIHN1YnRyYWN0aW9uXG4gICAgICAgIGluZml4KFwiKlwiKTsgLy8gbnVtZXJpYyBtdWx0aXBsaWNhdGlvblxuICAgICAgICBpbmZpeChcIi9cIik7IC8vIG51bWVyaWMgZGl2aXNpb25cbiAgICAgICAgaW5maXgoXCIlXCIpOyAvLyBudW1lcmljIG1vZHVsdXNcbiAgICAgICAgaW5maXgoXCI9XCIpOyAvLyBlcXVhbGl0eVxuICAgICAgICBpbmZpeChcIjxcIik7IC8vIGxlc3MgdGhhblxuICAgICAgICBpbmZpeChcIj5cIik7IC8vIGdyZWF0ZXIgdGhhblxuICAgICAgICBpbmZpeChcIiE9XCIpOyAvLyBub3QgZXF1YWwgdG9cbiAgICAgICAgaW5maXgoXCI8PVwiKTsgLy8gbGVzcyB0aGFuIG9yIGVxdWFsXG4gICAgICAgIGluZml4KFwiPj1cIik7IC8vIGdyZWF0ZXIgdGhhbiBvciBlcXVhbFxuICAgICAgICBpbmZpeChcIiZcIik7IC8vIHN0cmluZyBjb25jYXRlbmF0aW9uXG4gICAgICAgIGluZml4KFwiYW5kXCIpOyAvLyBCb29sZWFuIEFORFxuICAgICAgICBpbmZpeChcIm9yXCIpOyAvLyBCb29sZWFuIE9SXG4gICAgICAgIGluZml4KFwiaW5cIik7IC8vIGlzIG1lbWJlciBvZiBhcnJheVxuICAgICAgICB0ZXJtaW5hbChcImFuZFwiKTsgLy8gdGhlICdrZXl3b3JkcycgY2FuIGFsc28gYmUgdXNlZCBhcyB0ZXJtaW5hbHMgKGZpZWxkIG5hbWVzKVxuICAgICAgICB0ZXJtaW5hbChcIm9yXCIpOyAvL1xuICAgICAgICB0ZXJtaW5hbChcImluXCIpOyAvL1xuICAgICAgICBpbmZpeHIoXCI6PVwiKTsgLy8gYmluZCB2YXJpYWJsZVxuICAgICAgICBwcmVmaXgoXCItXCIpOyAvLyB1bmFyeSBudW1lcmljIG5lZ2F0aW9uXG4gICAgICAgIGluZml4KFwifj5cIik7IC8vIGZ1bmN0aW9uIGFwcGxpY2F0aW9uXG5cbiAgICAgICAgaW5maXhyKFwiKGVycm9yKVwiLCAxMCwgZnVuY3Rpb24obGVmdCkge1xuICAgICAgICAgICAgdGhpcy5saHMgPSBsZWZ0O1xuXG4gICAgICAgICAgICB0aGlzLmVycm9yID0gbm9kZS5lcnJvcjtcbiAgICAgICAgICAgIHRoaXMucmVtYWluaW5nID0gcmVtYWluaW5nVG9rZW5zKCk7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAnZXJyb3InO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGZpZWxkIHdpbGRjYXJkIChzaW5nbGUgbGV2ZWwpXG4gICAgICAgIHByZWZpeCgnKicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFwid2lsZGNhcmRcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBkZXNjZW5kYW50IHdpbGRjYXJkIChtdWx0aS1sZXZlbClcbiAgICAgICAgcHJlZml4KCcqKicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiZGVzY2VuZGFudFwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGZ1bmN0aW9uIGludm9jYXRpb25cbiAgICAgICAgaW5maXgoXCIoXCIsIG9wZXJhdG9yc1snKCddLCBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICAgICAgLy8gbGVmdCBpcyBpcyB3aGF0IHdlIGFyZSB0cnlpbmcgdG8gaW52b2tlXG4gICAgICAgICAgICB0aGlzLnByb2NlZHVyZSA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAnZnVuY3Rpb24nO1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChub2RlLmlkICE9PSAnKScpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdvcGVyYXRvcicgJiYgbm9kZS5pZCA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJ0aWFsIGZ1bmN0aW9uIGFwcGxpY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAncGFydGlhbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ3VtZW50cy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgnPycpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmd1bWVudHMucHVzaChleHByZXNzaW9uKDApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCAhPT0gJywnKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgnLCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoXCIpXCIsIHRydWUpO1xuICAgICAgICAgICAgLy8gaWYgdGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIGlzICdmdW5jdGlvbicgb3IgzrssIHRoZW4gdGhpcyBpcyBmdW5jdGlvbiBkZWZpbml0aW9uIChsYW1iZGEgZnVuY3Rpb24pXG4gICAgICAgICAgICBpZiAobGVmdC50eXBlID09PSAnbmFtZScgJiYgKGxlZnQudmFsdWUgPT09ICdmdW5jdGlvbicgfHwgbGVmdC52YWx1ZSA9PT0gJ1xcdTAzQkInKSkge1xuICAgICAgICAgICAgICAgIC8vIGFsbCBvZiB0aGUgYXJncyBtdXN0IGJlIFZBUklBQkxFIHRva2Vuc1xuICAgICAgICAgICAgICAgIHRoaXMuYXJndW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGFyZywgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy50eXBlICE9PSAndmFyaWFibGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMjA4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGFyZy5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogYXJnLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbmRleCArIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ2xhbWJkYSc7XG4gICAgICAgICAgICAgICAgLy8gaXMgdGhlIG5leHQgdG9rZW4gYSAnPCcgLSBpZiBzbywgcGFyc2UgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgIGlmKG5vZGUuaWQgPT09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2lnUG9zID0gbm9kZS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcHRoID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZyA9ICc8JztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoZGVwdGggPiAwICYmIG5vZGUuaWQgIT09ICd7JyAmJiBub2RlLmlkICE9PSAnKGVuZCknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9rID0gYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodG9rLmlkID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHRvay5pZCA9PT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZyArPSB0b2sudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgnPicpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWduYXR1cmUgPSBwYXJzZVNpZ25hdHVyZShzaWcpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBwb3NpdGlvbiBpbnRvIHRoaXMgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5wb3NpdGlvbiA9IHNpZ1BvcyArIGVyci5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoIGVyciApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHBhcnNlIHRoZSBmdW5jdGlvbiBib2R5XG4gICAgICAgICAgICAgICAgYWR2YW5jZSgneycpO1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keSA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgICAgYWR2YW5jZSgnfScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHBhcmVudGhlc2lzIC0gYmxvY2sgZXhwcmVzc2lvblxuICAgICAgICBwcmVmaXgoXCIoXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUuaWQgIT09IFwiKVwiKSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKDApKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCAhPT0gXCI7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkdmFuY2UoXCI7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShcIilcIiwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAnYmxvY2snO1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFycmF5IGNvbnN0cnVjdG9yXG4gICAgICAgIHByZWZpeChcIltcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICAgIGlmIChub2RlLmlkICE9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBleHByZXNzaW9uKDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCA9PT0gXCIuLlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByYW5nZSBvcGVyYXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0ge3R5cGU6IFwiYmluYXJ5XCIsIHZhbHVlOiBcIi4uXCIsIHBvc2l0aW9uOiBub2RlLnBvc2l0aW9uLCBsaHM6IGl0ZW19O1xuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShcIi4uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UucmhzID0gZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSByYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmlkICE9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShcIixcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShcIl1cIiwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gYTtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFwidW5hcnlcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBmaWx0ZXIgLSBwcmVkaWNhdGUgb3IgYXJyYXkgaW5kZXhcbiAgICAgICAgaW5maXgoXCJbXCIsIG9wZXJhdG9yc1snWyddLCBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICAgICAgaWYobm9kZS5pZCA9PT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBwcmVkaWNhdGUgbWVhbnMgbWFpbnRhaW4gc2luZ2xldG9uIGFycmF5cyBpbiB0aGUgb3V0cHV0XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXAgPSBsZWZ0O1xuICAgICAgICAgICAgICAgIHdoaWxlKHN0ZXAgJiYgc3RlcC50eXBlID09PSAnYmluYXJ5JyAmJiBzdGVwLnZhbHVlID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcCA9IHN0ZXAubGhzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGVwLmtlZXBBcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWR2YW5jZShcIl1cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGhzID0gbGVmdDtcbiAgICAgICAgICAgICAgICB0aGlzLnJocyA9IGV4cHJlc3Npb24ob3BlcmF0b3JzWyddJ10pO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdiaW5hcnknO1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoXCJdXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBvcmRlci1ieVxuICAgICAgICBpbmZpeChcIl5cIiwgb3BlcmF0b3JzWydeJ10sIGZ1bmN0aW9uIChsZWZ0KSB7XG4gICAgICAgICAgICBhZHZhbmNlKFwiKFwiKTtcbiAgICAgICAgICAgIHZhciB0ZXJtcyA9IFtdO1xuICAgICAgICAgICAgZm9yKDs7KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlcm0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NlbmRpbmc6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCA9PT0gXCI8XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXNjZW5kaW5nIHNvcnRcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShcIjxcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmlkID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZXNjZW5kaW5nIHNvcnRcbiAgICAgICAgICAgICAgICAgICAgdGVybS5kZXNjZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShcIj5cIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy91bnNwZWNpZmllZCAtIGRlZmF1bHQgdG8gYXNjZW5kaW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRlcm0uZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgICAgdGVybXMucHVzaCh0ZXJtKTtcbiAgICAgICAgICAgICAgICBpZihub2RlLmlkICE9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWR2YW5jZShcIixcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZHZhbmNlKFwiKVwiKTtcbiAgICAgICAgICAgIHRoaXMubGhzID0gbGVmdDtcbiAgICAgICAgICAgIHRoaXMucmhzID0gdGVybXM7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAnYmluYXJ5JztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgb2JqZWN0UGFyc2VyID0gZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICBpZiAobm9kZS5pZCAhPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShcIjpcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKFtuLCB2XSk7IC8vIGhvbGRzIGFuIGFycmF5IG9mIG5hbWUvdmFsdWUgZXhwcmVzc2lvbiBwYWlyc1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCAhPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoXCIsXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoXCJ9XCIsIHRydWUpO1xuICAgICAgICAgICAgaWYodHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gTlVEIC0gdW5hcnkgcHJlZml4IGZvcm1cbiAgICAgICAgICAgICAgICB0aGlzLmxocyA9IGE7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJ1bmFyeVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMRUQgLSBiaW5hcnkgaW5maXggZm9ybVxuICAgICAgICAgICAgICAgIHRoaXMubGhzID0gbGVmdDtcbiAgICAgICAgICAgICAgICB0aGlzLnJocyA9IGE7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ2JpbmFyeSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0b3JcbiAgICAgICAgcHJlZml4KFwie1wiLCBvYmplY3RQYXJzZXIpO1xuXG4gICAgICAgIC8vIG9iamVjdCBncm91cGluZ1xuICAgICAgICBpbmZpeChcIntcIiwgb3BlcmF0b3JzWyd7J10sIG9iamVjdFBhcnNlcik7XG5cbiAgICAgICAgLy8gaWYvdGhlbi9lbHNlIHRlcm5hcnkgb3BlcmF0b3IgPzpcbiAgICAgICAgaW5maXgoXCI/XCIsIG9wZXJhdG9yc1snPyddLCBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ2NvbmRpdGlvbic7XG4gICAgICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnRoZW4gPSBleHByZXNzaW9uKDApO1xuICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgIC8vIGVsc2UgY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgYWR2YW5jZShcIjpcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5lbHNlID0gZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBvYmplY3QgdHJhbnNmb3JtZXJcbiAgICAgICAgcHJlZml4KFwifFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAndHJhbnNmb3JtJztcbiAgICAgICAgICAgIHRoaXMucGF0dGVybiA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICBhZHZhbmNlKCd8Jyk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICBpZihub2RlLmlkID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlKCcsJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGUgPSBleHByZXNzaW9uKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZSgnfCcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRhaWwgY2FsbCBvcHRpbWl6YXRpb25cbiAgICAgICAgLy8gdGhpcyBpcyBpbnZva2VkIGJ5IHRoZSBwb3N0IHBhcnNlciB0byBhbmFseXNlIGxhbWJkYSBmdW5jdGlvbnMgdG8gc2VlXG4gICAgICAgIC8vIGlmIHRoZXkgbWFrZSBhIHRhaWwgY2FsbC4gIElmIHNvLCBpdCBpcyByZXBsYWNlZCBieSBhIHRodW5rIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgaW52b2tlZCBieSB0aGUgdHJhbXBvbGluZSBsb29wIGR1cmluZyBmdW5jdGlvbiBhcHBsaWNhdGlvbi5cbiAgICAgICAgLy8gVGhpcyBlbmFibGVzIHRhaWwtcmVjdXJzaXZlIGZ1bmN0aW9ucyB0byBiZSB3cml0dGVuIHdpdGhvdXQgZ3Jvd2luZyB0aGUgc3RhY2tcbiAgICAgICAgdmFyIHRhaWxfY2FsbF9vcHRpbWl6ZSA9IGZ1bmN0aW9uKGV4cHIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZihleHByLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGh1bmsgPSB7dHlwZTogJ2xhbWJkYScsIHRodW5rOiB0cnVlLCBhcmd1bWVudHM6IFtdLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgdGh1bmsuYm9keSA9IGV4cHI7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGh1bms7XG4gICAgICAgICAgICB9IGVsc2UgaWYoZXhwci50eXBlID09PSAnY29uZGl0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIGFuYWx5c2UgYm90aCBicmFuY2hlc1xuICAgICAgICAgICAgICAgIGV4cHIudGhlbiA9IHRhaWxfY2FsbF9vcHRpbWl6ZShleHByLnRoZW4pO1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBleHByLmVsc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cHIuZWxzZSA9IHRhaWxfY2FsbF9vcHRpbWl6ZShleHByLmVsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBleHByO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGV4cHIudHlwZSA9PT0gJ2Jsb2NrJykge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgdGhlIGxhc3QgZXhwcmVzc2lvbiBpbiB0aGUgYmxvY2tcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gZXhwci5leHByZXNzaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBleHByLmV4cHJlc3Npb25zW2xlbmd0aCAtIDFdID0gdGFpbF9jYWxsX29wdGltaXplKGV4cHIuZXhwcmVzc2lvbnNbbGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBleHByO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBleHByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBwb3N0LXBhcnNlIHN0YWdlXG4gICAgICAgIC8vIHRoZSBwdXJwb3NlIG9mIHRoaXMgaXMgZmxhdHRlbiB0aGUgcGFydHMgb2YgdGhlIEFTVCByZXByZXNlbnRpbmcgbG9jYXRpb24gcGF0aHMsXG4gICAgICAgIC8vIGNvbnZlcnRpbmcgdGhlbSB0byBhcnJheXMgb2Ygc3RlcHMgd2hpY2ggaW4gdHVybiBtYXkgY29udGFpbiBhcnJheXMgb2YgcHJlZGljYXRlcy5cbiAgICAgICAgLy8gZm9sbG93aW5nIHRoaXMsIG5vZGVzIGNvbnRhaW5pbmcgJy4nIGFuZCAnWycgc2hvdWxkIGJlIGVsaW1pbmF0ZWQgZnJvbSB0aGUgQVNULlxuICAgICAgICB2YXIgYXN0X29wdGltaXplID0gZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXhwci52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxzdGVwID0gYXN0X29wdGltaXplKGV4cHIubGhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogJ3BhdGgnLCBzdGVwczogW119O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsc3RlcC50eXBlID09PSAncGF0aCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocmVzdWx0LnN0ZXBzLCBsc3RlcC5zdGVwcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0ZXBzID0gW2xzdGVwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3QgPSBhc3Rfb3B0aW1pemUoZXhwci5yaHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3QudHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdC5wcm9jZWR1cmUudHlwZSA9PT0gJ3BhdGgnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0LnByb2NlZHVyZS5zdGVwcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3QucHJvY2VkdXJlLnN0ZXBzWzBdLnR5cGUgPT09ICduYW1lJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0ZXBzW3Jlc3VsdC5zdGVwcy5sZW5ndGgtMV0udHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGZ1bmN0aW9uIGluIGNoYWluIG9mIGZ1bmN0aW9ucyAtIHdpbGwgb3ZlcnJpZGUgYSB0aGVuYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RlcHNbcmVzdWx0LnN0ZXBzLmxlbmd0aC0xXS5uZXh0RnVuY3Rpb24gPSByZXN0LnByb2NlZHVyZS5zdGVwc1swXS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzdC50eXBlICE9PSAncGF0aCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdCA9IHt0eXBlOiAncGF0aCcsIHN0ZXBzOiBbcmVzdF19O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShyZXN1bHQuc3RlcHMsIHJlc3Quc3RlcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFueSBzdGVwcyB3aXRoaW4gYSBwYXRoIHRoYXQgYXJlIGxpdGVyYWxzLCBzaG91bGQgYmUgY2hhbmdlZCB0byAnbmFtZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RlcHMuZmlsdGVyKGZ1bmN0aW9uKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0ZXAudHlwZSA9PT0gJ2xpdGVyYWwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24obGl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpdC50eXBlID0gJ25hbWUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFueSBzdGVwIHRoYXQgc2lnbmFscyBrZWVwaW5nIGEgc2luZ2xldG9uIGFycmF5LCBzaG91bGQgYmUgZmxhZ2dlZCBvbiB0aGUgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdC5zdGVwcy5maWx0ZXIoZnVuY3Rpb24oc3RlcCkgeyByZXR1cm4gc3RlcC5rZWVwQXJyYXkgPT09IHRydWU7fSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQua2VlcFNpbmdsZXRvbkFycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgZmlyc3Qgc3RlcCBpcyBhIHBhdGggY29uc3RydWN0b3IsIGZsYWcgaXQgZm9yIHNwZWNpYWwgaGFuZGxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQuc3RlcHNbMF0udHlwZSA9PT0gJ3VuYXJ5JyAmJiByZXN1bHQuc3RlcHNbMF0udmFsdWUgPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RlcHNbMF0uY29uc2FycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmVkaWNhdGVkIHN0ZXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMSFMgaXMgYSBzdGVwIG9yIGEgcHJlZGljYXRlZCBzdGVwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUkhTIGlzIHRoZSBwcmVkaWNhdGUgZXhwclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFzdF9vcHRpbWl6ZShleHByLmxocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ZXAgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0LnR5cGUgPT09ICdwYXRoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwID0gcmVzdWx0LnN0ZXBzW3Jlc3VsdC5zdGVwcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGVwLmdyb3VwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMjA5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RlcC5wcmVkaWNhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXAucHJlZGljYXRlID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXAucHJlZGljYXRlLnB1c2goYXN0X29wdGltaXplKGV4cHIucmhzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBncm91cC1ieVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExIUyBpcyBhIHN0ZXAgb3IgYSBwcmVkaWNhdGVkIHN0ZXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSSFMgaXMgdGhlIG9iamVjdCBjb25zdHJ1Y3RvciBleHByXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYXN0X29wdGltaXplKGV4cHIubGhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdC5ncm91cCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDIxMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0b3IgLSBwcm9jZXNzIGVhY2ggcGFpclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ncm91cCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGhzOiBleHByLnJocy5tYXAoZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbYXN0X29wdGltaXplKHBhaXJbMF0pLCBhc3Rfb3B0aW1pemUocGFpclsxXSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3JkZXItYnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMSFMgaXMgdGhlIGFycmF5IHRvIGJlIG9yZGVyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSSFMgZGVmaW5lcyB0aGUgdGVybXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogJ3NvcnQnLCB2YWx1ZTogZXhwci52YWx1ZSwgcG9zaXRpb246IGV4cHIucG9zaXRpb259O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5saHMgPSBhc3Rfb3B0aW1pemUoZXhwci5saHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yaHMgPSBleHByLnJocy5tYXAoZnVuY3Rpb24gKHRlcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjZW5kaW5nOiB0ZXJtcy5kZXNjZW5kaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogYXN0X29wdGltaXplKHRlcm1zLmV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc6PSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6ICdiaW5kJywgdmFsdWU6IGV4cHIudmFsdWUsIHBvc2l0aW9uOiBleHByLnBvc2l0aW9ufTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubGhzID0gYXN0X29wdGltaXplKGV4cHIubGhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmhzID0gYXN0X29wdGltaXplKGV4cHIucmhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ34+JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogJ2FwcGx5JywgdmFsdWU6IGV4cHIudmFsdWUsIHBvc2l0aW9uOiBleHByLnBvc2l0aW9ufTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubGhzID0gYXN0X29wdGltaXplKGV4cHIubGhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmhzID0gYXN0X29wdGltaXplKGV4cHIucmhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6IGV4cHIudHlwZSwgdmFsdWU6IGV4cHIudmFsdWUsIHBvc2l0aW9uOiBleHByLnBvc2l0aW9ufTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubGhzID0gYXN0X29wdGltaXplKGV4cHIubGhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmhzID0gYXN0X29wdGltaXplKGV4cHIucmhzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd1bmFyeSc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt0eXBlOiBleHByLnR5cGUsIHZhbHVlOiBleHByLnZhbHVlLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByLnZhbHVlID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IGNvbnN0cnVjdG9yIC0gcHJvY2VzcyBlYWNoIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5leHByZXNzaW9ucyA9IGV4cHIuZXhwcmVzc2lvbnMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzdF9vcHRpbWl6ZShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIudmFsdWUgPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdG9yIC0gcHJvY2VzcyBlYWNoIHBhaXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5saHMgPSBleHByLmxocy5tYXAoZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2FzdF9vcHRpbWl6ZShwYWlyWzBdKSwgYXN0X29wdGltaXplKHBhaXJbMV0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIG90aGVyIHVuYXJ5IGV4cHJlc3Npb25zIC0ganVzdCBwcm9jZXNzIHRoZSBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXhwcmVzc2lvbiA9IGFzdF9vcHRpbWl6ZShleHByLmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdW5hcnkgbWludXMgb24gYSBudW1iZXIsIHRoZW4gcHJlLXByb2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByLnZhbHVlID09PSAnLScgJiYgcmVzdWx0LmV4cHJlc3Npb24udHlwZSA9PT0gJ2xpdGVyYWwnICYmIGlzTnVtZXJpYyhyZXN1bHQuZXhwcmVzc2lvbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSAtcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICBjYXNlICdwYXJ0aWFsJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6IGV4cHIudHlwZSwgbmFtZTogZXhwci5uYW1lLCB2YWx1ZTogZXhwci52YWx1ZSwgcG9zaXRpb246IGV4cHIucG9zaXRpb259O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXJndW1lbnRzID0gZXhwci5hcmd1bWVudHMubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhc3Rfb3B0aW1pemUoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wcm9jZWR1cmUgPSBhc3Rfb3B0aW1pemUoZXhwci5wcm9jZWR1cmUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdsYW1iZGEnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogZXhwci50eXBlLCBhcmd1bWVudHM6IGV4cHIuYXJndW1lbnRzLCBzaWduYXR1cmU6IGV4cHIuc2lnbmF0dXJlLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gYXN0X29wdGltaXplKGV4cHIuYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ib2R5ID0gdGFpbF9jYWxsX29wdGltaXplKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb25kaXRpb24nOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogZXhwci50eXBlLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb25kaXRpb24gPSBhc3Rfb3B0aW1pemUoZXhwci5jb25kaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQudGhlbiA9IGFzdF9vcHRpbWl6ZShleHByLnRoZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cHIuZWxzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lbHNlID0gYXN0X29wdGltaXplKGV4cHIuZWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndHJhbnNmb3JtJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6IGV4cHIudHlwZSwgcG9zaXRpb246IGV4cHIucG9zaXRpb259O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucGF0dGVybiA9IGFzdF9vcHRpbWl6ZShleHByLnBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQudXBkYXRlID0gYXN0X29wdGltaXplKGV4cHIudXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGV4cHIuZGVsZXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRlbGV0ZSA9IGFzdF9vcHRpbWl6ZShleHByLmRlbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYmxvY2snOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogZXhwci50eXBlLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IG9mIGV4cHJlc3Npb25zIC0gcHJvY2VzcyBlYWNoIG9uZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXhwcmVzc2lvbnMgPSBleHByLmV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzdF9vcHRpbWl6ZShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gc2NhbiB0aGUgYXJyYXkgb2YgZXhwcmVzc2lvbnMgdG8gc2VlIGlmIGFueSBvZiB0aGVtIGFzc2lnbiB2YXJpYWJsZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgc28sIG5lZWQgdG8gbWFyayB0aGUgYmxvY2sgYXMgb25lIHRoYXQgbmVlZHMgdG8gY3JlYXRlIGEgbmV3IGZyYW1lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogJ3BhdGgnLCBzdGVwczogW2V4cHJdfTtcbiAgICAgICAgICAgICAgICAgICAgaWYoZXhwci5rZWVwQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5rZWVwU2luZ2xldG9uQXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xpdGVyYWwnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3dpbGRjYXJkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkZXNjZW5kYW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICd2YXJpYWJsZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAncmVnZXgnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBleHByO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdvcGVyYXRvcic6XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB0b2tlbnMgJ2FuZCcgYW5kICdvcicgbWlnaHQgaGF2ZSBiZWVuIHVzZWQgYXMgYSBuYW1lIHJhdGhlciB0aGFuIGFuIG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByLnZhbHVlID09PSAnYW5kJyB8fCBleHByLnZhbHVlID09PSAnb3InIHx8IGV4cHIudmFsdWUgPT09ICdpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIudHlwZSA9ICduYW1lJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFzdF9vcHRpbWl6ZShleHByKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovIGlmIChleHByLnZhbHVlID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcnRpYWwgYXBwbGljYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV4cHI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDIwMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBleHByLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZXhwcjtcbiAgICAgICAgICAgICAgICAgICAgaWYoZXhwci5saHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFzdF9vcHRpbWl6ZShleHByLmxocyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBcIlMwMjA2XCI7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByLmlkID09PSAnKGVuZCknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gXCJTMDIwN1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogZXhwci52YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZihyZWNvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBlcnJvcjogZXJyfTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbm93IGludm9rZSB0aGUgdG9rZW5pemVyIGFuZCB0aGUgcGFyc2VyIGFuZCByZXR1cm4gdGhlIHN5bnRheCB0cmVlXG4gICAgICAgIGxleGVyID0gdG9rZW5pemVyKHNvdXJjZSk7XG4gICAgICAgIGFkdmFuY2UoKTtcbiAgICAgICAgLy8gcGFyc2UgdGhlIHRva2Vuc1xuICAgICAgICB2YXIgZXhwciA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgIGlmIChub2RlLmlkICE9PSAnKGVuZCknKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAyMDFcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogbm9kZS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICB0b2tlbjogbm9kZS52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZXhwciA9IGFzdF9vcHRpbWl6ZShleHByKTtcblxuICAgICAgICBpZihlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZXhwci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9O1xuXG4gICAgLy8gU3RhcnQgb2YgRXZhbHVhdG9yIGNvZGVcblxuICAgIHZhciBzdGF0aWNGcmFtZSA9IGNyZWF0ZUZyYW1lKG51bGwpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdmFsdWUgaXMgYSBmaW5pdGUgbnVtYmVyXG4gICAgICogQHBhcmFtIHtmbG9hdH0gbiAtIG51bWJlciB0byBldmFsdWF0ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG4gaXMgYSBmaW5pdGUgbnVtYmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgICAgICAgdmFyIGlzTnVtID0gZmFsc2U7XG4gICAgICAgIGlmKHR5cGVvZiBuID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFyIG51bSA9IHBhcnNlRmxvYXQobik7XG4gICAgICAgICAgICBpc051bSA9ICFpc05hTihudW0pO1xuICAgICAgICAgICAgaWYgKGlzTnVtICYmICFpc0Zpbml0ZShudW0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkQxMDAxXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFja1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTnVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXJnIGlzIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgKiBAcGFyYW0geyp9IGFyZyAtIHRoZSBpdGVtIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBhcmcgaXMgYW4gYXJyYXkgb2Ygc3RyaW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlPZlN0cmluZ3MoYXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAoYXJnLmZpbHRlcihmdW5jdGlvbihpdGVtKXtyZXR1cm4gdHlwZW9mIGl0ZW0gIT09ICdzdHJpbmcnO30pLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFyZyBpcyBhbiBhcnJheSBvZiBudW1iZXJzXG4gICAgICogQHBhcmFtIHsqfSBhcmcgLSB0aGUgaXRlbSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYXJnIGlzIGFuIGFycmF5IG9mIG51bWJlcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5T2ZOdW1iZXJzKGFyZykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gKGFyZy5maWx0ZXIoZnVuY3Rpb24oaXRlbSl7cmV0dXJuICFpc051bWVyaWMoaXRlbSk7fSkubGVuZ3RoID09PSAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFBvbHlmaWxsXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBOdW1iZXIuaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmXG4gICAgICAgICAgaXNGaW5pdGUodmFsdWUpICYmXG4gICAgICAgICAgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBleHByZXNzaW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGUoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgdmFyIGVudHJ5Q2FsbGJhY2sgPSBlbnZpcm9ubWVudC5sb29rdXAoJ19fZXZhbHVhdGVfZW50cnknKTtcbiAgICAgICAgaWYoZW50cnlDYWxsYmFjaykge1xuICAgICAgICAgICAgZW50cnlDYWxsYmFjayhleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3BhdGgnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVQYXRoKGV4cHIuc3RlcHMsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbm9ybWFsaXplU2VxdWVuY2UocmVzdWx0LCBleHByLmtlZXBTaW5nbGV0b25BcnJheSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVCaW5hcnkoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VuYXJ5JzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlVW5hcnkoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlTmFtZShleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGl0ZXJhbCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVMaXRlcmFsKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3aWxkY2FyZCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVXaWxkY2FyZChleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGVzY2VuZGFudCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVEZXNjZW5kYW50cyhleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29uZGl0aW9uJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlQ29uZGl0aW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdibG9jayc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZUJsb2NrKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiaW5kJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlQmluZEV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JlZ2V4JzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZVJlZ2V4KGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZUZ1bmN0aW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd2YXJpYWJsZSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVWYXJpYWJsZShleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGFtYmRhJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZUxhbWJkYShleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncGFydGlhbCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZVBhcnRpYWxBcHBsaWNhdGlvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYXBwbHknOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVBcHBseUV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NvcnQnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVTb3J0RXhwcmVzc2lvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndHJhbnNmb3JtJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZVRyYW5zZm9ybUV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGVudmlyb25tZW50Lmxvb2t1cCgnX19qc29uYXRhX2FzeW5jJykgJiZcbiAgICAgICAgICAodHlwZW9mIHJlc3VsdCA9PT0gJ3VuZGVmaW5lZCcgfHwgcmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQudGhlbiAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGVudmlyb25tZW50Lmxvb2t1cCgnX19qc29uYXRhX2FzeW5jJykgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nICYmIGV4cHIubmV4dEZ1bmN0aW9uICYmIHR5cGVvZiByZXN1bHRbZXhwci5uZXh0RnVuY3Rpb25dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBhbHRob3VnaCB0aGlzIGlzIGEgJ3RoZW5hYmxlJywgaXQgaXMgY2hhaW5pbmcgYSBkaWZmZXJlbnQgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIHNvIGRvbid0IHlpZWxkIHNpbmNlIHlpZWxkaW5nIHdpbGwgdHJpZ2dlciB0aGUgLnRoZW4oKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgcmVzdWx0O1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAoZXhwci5oYXNPd25Qcm9wZXJ0eSgncHJlZGljYXRlJykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogYXBwbHlQcmVkaWNhdGVzKGV4cHIucHJlZGljYXRlLCByZXN1bHQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVNlcXVlbmNlKHJlc3VsdCk7XG5cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwci5oYXNPd25Qcm9wZXJ0eSgnZ3JvdXAnKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZUdyb3VwRXhwcmVzc2lvbihleHByLmdyb3VwLCByZXN1bHQsIGVudmlyb25tZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleGl0Q2FsbGJhY2sgPSBlbnZpcm9ubWVudC5sb29rdXAoJ19fZXZhbHVhdGVfZXhpdCcpO1xuICAgICAgICBpZihleGl0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIGV4aXRDYWxsYmFjayhleHByLCBpbnB1dCwgZW52aXJvbm1lbnQsIHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHBhdGggZXhwcmVzc2lvbiBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlUGF0aChleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIGlucHV0U2VxdWVuY2U7XG4gICAgICAgIC8vIGV4cHIgaXMgYW4gYXJyYXkgb2Ygc3RlcHNcbiAgICAgICAgLy8gaWYgdGhlIGZpcnN0IHN0ZXAgaXMgYSB2YXJpYWJsZSByZWZlcmVuY2UgKCQuLi4pLCBpbmNsdWRpbmcgcm9vdCByZWZlcmVuY2UgKCQkKSxcbiAgICAgICAgLy8gICB0aGVuIHRoZSBwYXRoIGlzIGFic29sdXRlIHJhdGhlciB0aGFuIHJlbGF0aXZlXG4gICAgICAgIGlmIChleHByWzBdLnR5cGUgPT09ICd2YXJpYWJsZScpIHtcbiAgICAgICAgICAgIGlucHV0U2VxdWVuY2UgPSBbaW5wdXRdOyAvLyBkdW1teSBzaW5nbGV0b24gc2VxdWVuY2UgZm9yIGZpcnN0IChhYnNvbHV0ZSkgc3RlcFxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBpbnB1dFNlcXVlbmNlID0gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBpbnB1dCBpcyBub3QgYW4gYXJyYXksIG1ha2UgaXQgc29cbiAgICAgICAgICAgIGlucHV0U2VxdWVuY2UgPSBbaW5wdXRdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdFNlcXVlbmNlO1xuXG4gICAgICAgIC8vIGV2YWx1YXRlIGVhY2ggc3RlcCBpbiB0dXJuXG4gICAgICAgIGZvcih2YXIgaWkgPSAwOyBpaSA8IGV4cHIubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IGV4cHJbaWldO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgZmlyc3Qgc3RlcCBpcyBhbiBleHBsaWNpdCBhcnJheSBjb25zdHJ1Y3RvciwgdGhlbiBqdXN0IGV2YWx1YXRlIHRoYXQgKGkuZS4gZG9uJ3QgaXRlcmF0ZSBvdmVyIGEgY29udGV4dCBhcnJheSlcbiAgICAgICAgICAgIGlmKGlpID09PSAwICYmIHN0ZXAuY29uc2FycmF5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0U2VxdWVuY2UgPSB5aWVsZCAqIGV2YWx1YXRlKHN0ZXAsIGlucHV0U2VxdWVuY2UsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0U2VxdWVuY2UgPSB5aWVsZCAqIGV2YWx1YXRlU3RlcChzdGVwLCBpbnB1dFNlcXVlbmNlLCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHR5cGVvZiByZXN1bHRTZXF1ZW5jZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcmVzdWx0U2VxdWVuY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dFNlcXVlbmNlID0gcmVzdWx0U2VxdWVuY2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0U2VxdWVuY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIGEgSlNPTmF0YSBzZXF1ZW5jZSAtIHNpbmdsZXRvbiBhcnJheXMgYmVjb21lIGF0b21pYyB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzZXF1ZW5jZSAtIGlucHV0IHNlcXVlbmNlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBrZWVwU2luZ2xldG9uIC0ga2VlcCBzaW5nbGV0b24gc2VxdWVuY2VzIGFzIGFycmF5c1xuICAgICAqIEByZXR1cm5zIHsqfSBub3JtYWxpemVkIHNlcXVlbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplU2VxdWVuY2Uoc2VxdWVuY2UsIGtlZXBTaW5nbGV0b24pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYodHlwZW9mIHNlcXVlbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYoIUFycmF5LmlzQXJyYXkoc2VxdWVuY2UpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzZXF1ZW5jZTtcbiAgICAgICAgfSBlbHNlIGlmIChzZXF1ZW5jZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmKGtlZXBTaW5nbGV0b24pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzZXF1ZW5jZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VxdWVuY2VbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2VxdWVuY2UubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc2VxdWVuY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBhIHN0ZXAgd2l0aGluIGEgcGF0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVTdGVwKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cblxuICAgICAgICBmb3IodmFyIGlpID0gMDsgaWkgPCBpbnB1dC5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgIHZhciByZXMgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIsIGlucHV0W2lpXSwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgaWYgKCEoQXJyYXkuaXNBcnJheShyZXMpICYmIChleHByLnZhbHVlICE9PSAnWycgKSkgJiYgIWV4cHIuY29uc2FycmF5KSB7XG4gICAgICAgICAgICAgICAgcmVzID0gW3Jlc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpcyByZXMgYW4gYXJyYXkgLSBpZiBzbywgZmxhdHRlbiBpdCBpbnRvIHRoZSBwYXJlbnQgYXJyYXlcbiAgICAgICAgICAgIHJlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbm5lclJlcykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5uZXJSZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGlubmVyUmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHByZWRpY2F0ZXMgdG8gaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmVkaWNhdGVzIC0gUHJlZGljYXRlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gYXBwbHkgcHJlZGljYXRlcyBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0IGFmdGVyIGFwcGx5aW5nIHByZWRpY2F0ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogYXBwbHlQcmVkaWNhdGVzKHByZWRpY2F0ZXMsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgaW5wdXRTZXF1ZW5jZSA9IGlucHV0O1xuICAgICAgICAvLyBsaHMgcG90ZW50aWFsbHkgaG9sZHMgYW4gYXJyYXlcbiAgICAgICAgLy8gd2Ugd2FudCB0byBpdGVyYXRlIG92ZXIgdGhlIGFycmF5LCBhbmQgb25seSBrZWVwIHRoZSBpdGVtcyB0aGF0IGFyZVxuICAgICAgICAvLyB0cnV0aHkgd2hlbiBhcHBsaWVkIHRvIHRoZSBwcmVkaWNhdGUuXG4gICAgICAgIC8vIGlmIHRoZSBwcmVkaWNhdGUgZXZhbHVhdGVzIHRvIGFuIGludGVnZXIsIHRoZW4gc2VsZWN0IHRoYXQgaW5kZXhcblxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IodmFyIGlpID0gMDsgaWkgPCBwcmVkaWNhdGVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgdmFyIHByZWRpY2F0ZSA9IHByZWRpY2F0ZXNbaWldO1xuICAgICAgICAgICAgLy8gaWYgaXQncyBub3QgYW4gYXJyYXksIHR1cm4gaXQgaW50byBvbmVcbiAgICAgICAgICAgIC8vIHNpbmNlIGluIFhQYXRoID49IDIuMCBhbiBpdGVtIGlzIGVxdWl2YWxlbnQgdG8gYSBzaW5nbGV0b24gc2VxdWVuY2Ugb2YgdGhhdCBpdGVtXG4gICAgICAgICAgICAvLyBpZiBpbnB1dCBpcyBub3QgYW4gYXJyYXksIG1ha2UgaXQgc29cbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dFNlcXVlbmNlKSkge1xuICAgICAgICAgICAgICAgIGlucHV0U2VxdWVuY2UgPSBbaW5wdXRTZXF1ZW5jZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlLnR5cGUgPT09ICdsaXRlcmFsJyAmJiBpc051bWVyaWMocHJlZGljYXRlLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHByZWRpY2F0ZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJvdW5kIGl0IGRvd25cbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb3VudCBpbiBmcm9tIGVuZCBvZiBhcnJheVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGlucHV0U2VxdWVuY2UubGVuZ3RoICsgaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBpbnB1dFNlcXVlbmNlW2luZGV4XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IHlpZWxkICogZXZhbHVhdGVGaWx0ZXIocHJlZGljYXRlLCBpbnB1dFNlcXVlbmNlLCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dFNlcXVlbmNlID0gcmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBmaWx0ZXIgcHJlZGljYXRlIHRvIGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJlZGljYXRlIC0gZmlsdGVyIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGFwcGx5IHByZWRpY2F0ZXMgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IFJlc3VsdCBhZnRlciBhcHBseWluZyBwcmVkaWNhdGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlRmlsdGVyKHByZWRpY2F0ZSwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGZvcih2YXIgaW5kZXggPSAwOyBpbmRleCA8IGlucHV0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpbnB1dFtpbmRleF07XG4gICAgICAgICAgICB2YXIgcmVzID0geWllbGQgKiBldmFsdWF0ZShwcmVkaWNhdGUsIGl0ZW0sIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgIGlmIChpc051bWVyaWMocmVzKSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IFtyZXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoaXNBcnJheU9mTnVtYmVycyhyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzLmZvckVhY2goZnVuY3Rpb24oaXJlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoaXJlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJvdW5kIGl0IGRvd25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlyZXMgPSBNYXRoLmZsb29yKGlyZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpcmVzIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY291bnQgaW4gZnJvbSBlbmQgb2YgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlyZXMgPSBpbnB1dC5sZW5ndGggKyBpcmVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpcmVzID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZ1bmN0aW9uQm9vbGVhbihyZXMpKSB7IC8vIHRydXRoeVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBiaW5hcnkgZXhwcmVzc2lvbiBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gKiBldmFsdWF0ZUJpbmFyeShleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIGxocyA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5saHMsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgIHZhciByaHMgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIucmhzLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICB2YXIgb3AgPSBleHByLnZhbHVlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlTnVtZXJpY0V4cHJlc3Npb24obGhzLCByaHMsIG9wKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlQ29tcGFyaXNvbkV4cHJlc3Npb24obGhzLCByaHMsIG9wKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlU3RyaW5nQ29uY2F0KGxocywgcmhzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYW5kJzpcbiAgICAgICAgICAgICAgICBjYXNlICdvcic6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlQm9vbGVhbkV4cHJlc3Npb24obGhzLCByaHMsIG9wKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnLi4nOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZVJhbmdlRXhwcmVzc2lvbihsaHMsIHJocyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2luJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVJbmNsdWRlc0V4cHJlc3Npb24obGhzLCByaHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIGVyci5wb3NpdGlvbiA9IGV4cHIucG9zaXRpb247XG4gICAgICAgICAgICBlcnIudG9rZW4gPSBvcDtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHVuYXJ5IGV4cHJlc3Npb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBldmFsdWF0ZVVuYXJ5KGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIHN3aXRjaCAoZXhwci52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZShleHByLmV4cHJlc3Npb24sIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtZXJpYyhyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IC1yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJEMTAwMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBleHByLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgICAgIC8vIGFycmF5IGNvbnN0cnVjdG9yIC0gZXZhbHVhdGUgZWFjaCBpdGVtXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpaSA9IDA7IGlpIDwgZXhwci5leHByZXNzaW9ucy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBleHByLmV4cHJlc3Npb25zW2lpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0geWllbGQgKiBldmFsdWF0ZShpdGVtLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS52YWx1ZSA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jdGlvbkFwcGVuZChyZXN1bHQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3RvciAtIGFwcGx5IGdyb3VwaW5nXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZUdyb3VwRXhwcmVzc2lvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBuYW1lIG9iamVjdCBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVOYW1lKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICAvLyBsb29rdXAgdGhlICduYW1lJyBpdGVtIGluIHRoZSBpbnB1dFxuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yKHZhciBpaSA9IDA7IGlpIDwgaW5wdXQubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9ICBldmFsdWF0ZU5hbWUoZXhwciwgaW5wdXRbaWldLCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlucHV0ICE9PSBudWxsICYmIHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0W2V4cHIudmFsdWVdO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVNlcXVlbmNlKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgbGl0ZXJhbCBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlTGl0ZXJhbChleHByKSB7XG4gICAgICAgIHJldHVybiBleHByLnZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHdpbGRjYXJkIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVXaWxkY2FyZChleHByLCBpbnB1dCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAoaW5wdXQgIT09IG51bGwgJiYgdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoaW5wdXQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2tleV07XG4gICAgICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBmbGF0dGVuKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IGZ1bmN0aW9uQXBwZW5kKHJlc3VsdHMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gbm9ybWFsaXplU2VxdWVuY2UocmVzdWx0cyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZsYXR0ZW5lZCBhcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZyAtIHRoZSBhcnJheSB0byBiZSBmbGF0dGVuXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmxhdHRlbmVkIC0gY2FycmllcyB0aGUgZmxhdHRlbmVkIGFycmF5IC0gaWYgbm90IGRlZmluZWQsIHdpbGwgaW5pdGlhbGl6ZSB0byBbXVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gLSB0aGUgZmxhdHRlbmVkIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcmcsIGZsYXR0ZW5lZCkge1xuICAgICAgICBpZih0eXBlb2YgZmxhdHRlbmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZmxhdHRlbmVkID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICBhcmcuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGZsYXR0ZW4oaXRlbSwgZmxhdHRlbmVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxhdHRlbmVkLnB1c2goYXJnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmxhdHRlbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGRlc2NlbmRhbnRzIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVEZXNjZW5kYW50cyhleHByLCBpbnB1dCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgcmVzdWx0U2VxdWVuY2UgPSBbXTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIHRyYXZlcnNlIGFsbCBkZXNjZW5kYW50cyBvZiB0aGlzIG9iamVjdC9hcnJheVxuICAgICAgICAgICAgcmVjdXJzZURlc2NlbmRhbnRzKGlucHV0LCByZXN1bHRTZXF1ZW5jZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0U2VxdWVuY2UubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0U2VxdWVuY2VbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFNlcXVlbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzZSB0aHJvdWdoIGRlc2NlbmRhbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHRzIC0gUmVzdWx0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlY3Vyc2VEZXNjZW5kYW50cyhpbnB1dCwgcmVzdWx0cykge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIC8vKiBpbiBYUGF0aFxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgaW5wdXQuZm9yRWFjaChmdW5jdGlvbiAobWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgcmVjdXJzZURlc2NlbmRhbnRzKG1lbWJlciwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCAhPT0gbnVsbCAmJiB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhpbnB1dCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmVjdXJzZURlc2NlbmRhbnRzKGlucHV0W2tleV0sIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBudW1lcmljIGV4cHJlc3Npb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxocyAtIExIUyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByaHMgLSBSSFMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3AgLSBvcGNvZGVcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVOdW1lcmljRXhwcmVzc2lvbihsaHMsIHJocywgb3ApIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHJocyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIGlmIGVpdGhlciBzaWRlIGlzIHVuZGVmaW5lZCwgdGhlIHJlc3VsdCBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVtZXJpYyhsaHMpKSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgY29kZTogXCJUMjAwMVwiLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBsaHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc051bWVyaWMocmhzKSkge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMDJcIixcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmhzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGhzICsgcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGhzIC0gcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGhzICogcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGhzIC8gcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGhzICUgcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgY29tcGFyaXNvbiBleHByZXNzaW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsaHMgLSBMSFMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmhzIC0gUkhTIHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wIC0gb3Bjb2RlXG4gICAgICogQHJldHVybnMgeyp9IFJlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlQ29tcGFyaXNvbkV4cHJlc3Npb24obGhzLCByaHMsIG9wKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gdHlwZSBjaGVja3NcbiAgICAgICAgdmFyIGx0eXBlID0gdHlwZW9mIGxocztcbiAgICAgICAgdmFyIHJ0eXBlID0gdHlwZW9mIHJocztcblxuICAgICAgICBpZiAobHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHJ0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gaWYgZWl0aGVyIHNpZGUgaXMgdW5kZWZpbmVkLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGlmIGFhIG9yIGJiIGFyZSBub3Qgc3RyaW5nIG9yIG51bWVyaWMgdmFsdWVzLCB0aGVuIHRocm93IGFuIGVycm9yXG4gICAgICAgICAgICBpZiAoIShsdHlwZSA9PT0gJ3N0cmluZycgfHwgbHR5cGUgPT09ICdudW1iZXInKSB8fCAhKHJ0eXBlID09PSAnc3RyaW5nJyB8fCBydHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQyMDEwXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogIShsdHlwZSA9PT0gJ3N0cmluZycgfHwgbHR5cGUgPT09ICdudW1iZXInKSA/IGxocyA6IHJoc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vaWYgYWEgYW5kIGJiIGFyZSBub3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgICAgICAgaWYgKGx0eXBlICE9PSBydHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJUMjAwOVwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxocyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUyOiByaHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyA9PT0gcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChsaHMgIT09IHJocyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyA8IHJocztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyA8PSByaHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyA+IHJocztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyA+PSByaHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmNsdXNpb24gb3BlcmF0b3IgLSBpblxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxocyAtIExIUyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByaHMgLSBSSFMgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIGxocyBpcyBhIG1lbWJlciBvZiByaHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmFsdWF0ZUluY2x1ZGVzRXhwcmVzc2lvbihsaHMsIHJocykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiByaHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBpZiBlaXRoZXIgc2lkZSBpcyB1bmRlZmluZWQsIHRoZSByZXN1bHQgaXMgZmFsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFBcnJheS5pc0FycmF5KHJocykpIHtcbiAgICAgICAgICAgIHJocyA9IFtyaHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHJocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYocmhzW2ldID09PSBsaHMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBib29sZWFuIGV4cHJlc3Npb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxocyAtIExIUyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByaHMgLSBSSFMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3AgLSBvcGNvZGVcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVCb29sZWFuRXhwcmVzc2lvbihsaHMsIHJocywgb3ApIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgICAgICBjYXNlICdhbmQnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uQm9vbGVhbihsaHMpICYmIGZ1bmN0aW9uQm9vbGVhbihyaHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnb3InOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uQm9vbGVhbihsaHMpIHx8IGZ1bmN0aW9uQm9vbGVhbihyaHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgc3RyaW5nIGNvbmNhdGVuYXRpb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxocyAtIExIUyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByaHMgLSBSSFMgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCp9IENvbmNhdGVuYXRlZCBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmFsdWF0ZVN0cmluZ0NvbmNhdChsaHMsIHJocykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIHZhciBsc3RyID0gJyc7XG4gICAgICAgIHZhciByc3RyID0gJyc7XG4gICAgICAgIGlmICh0eXBlb2YgbGhzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbHN0ciA9IGZ1bmN0aW9uU3RyaW5nKGxocyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByaHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByc3RyID0gZnVuY3Rpb25TdHJpbmcocmhzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IGxzdHIuY29uY2F0KHJzdHIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGdyb3VwIGV4cHJlc3Npb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHt7fX0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVHcm91cEV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgdmFyIGdyb3VwcyA9IHt9O1xuICAgICAgICAvLyBncm91cCB0aGUgaW5wdXQgc2VxdWVuY2UgYnkgJ2tleScgZXhwcmVzc2lvblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBpbnB1dCA9IFtpbnB1dF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBpdGVtSW5kZXggPSAwOyBpdGVtSW5kZXggPCBpbnB1dC5sZW5ndGg7IGl0ZW1JbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGlucHV0W2l0ZW1JbmRleF07XG4gICAgICAgICAgICBmb3IodmFyIHBhaXJJbmRleCA9IDA7IHBhaXJJbmRleCA8IGV4cHIubGhzLmxlbmd0aDsgcGFpckluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFpciA9IGV4cHIubGhzW3BhaXJJbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHlpZWxkICogZXZhbHVhdGUocGFpclswXSwgaXRlbSwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIC8vIGtleSBoYXMgdG8gYmUgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDEwMDNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToga2V5XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHtkYXRhOiBpdGVtLCBleHByOiBwYWlyWzFdfTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYSB2YWx1ZSBhbHJlYWR5IGV4aXN0cyBpbiB0aGlzIHNsb3RcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwZW5kIGl0IGFzIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwc1trZXldLmRhdGEgPSBmdW5jdGlvbkFwcGVuZChncm91cHNba2V5XS5kYXRhLCBpdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncm91cHNba2V5XSA9IGVudHJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGl0ZXJhdGUgb3ZlciB0aGUgZ3JvdXBzIHRvIGV2YWx1YXRlIHRoZSAndmFsdWUnIGV4cHJlc3Npb25cbiAgICAgICAgZm9yIChrZXkgaW4gZ3JvdXBzKSB7XG4gICAgICAgICAgICBlbnRyeSA9IGdyb3Vwc1trZXldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0geWllbGQgKiBldmFsdWF0ZShlbnRyeS5leHByLCBlbnRyeS5kYXRhLCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICBpZih0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgcmFuZ2UgZXhwcmVzc2lvbiBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGhzIC0gTEhTIHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJocyAtIFJIUyB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmVzdWx0YW50IGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVSYW5nZUV4cHJlc3Npb24obGhzLCByaHMpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHJocyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIGlmIGVpdGhlciBzaWRlIGlzIHVuZGVmaW5lZCwgdGhlIHJlc3VsdCBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGhzID4gcmhzKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgbGhzIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcmhzLCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxocykpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlQyMDAzXCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxoc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIocmhzKSkge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMDRcIixcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmhzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KHJocyAtIGxocyArIDEpO1xuICAgICAgICBmb3IgKHZhciBpdGVtID0gbGhzLCBpbmRleCA9IDA7IGl0ZW0gPD0gcmhzOyBpdGVtKyssIGluZGV4KyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgYmluZCBleHByZXNzaW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVCaW5kRXhwcmVzc2lvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgLy8gVGhlIFJIUyBpcyB0aGUgZXhwcmVzc2lvbiB0byBldmFsdWF0ZVxuICAgICAgICAvLyBUaGUgTEhTIGlzIHRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSB0byBiaW5kIHRvIC0gc2hvdWxkIGJlIGEgVkFSSUFCTEUgdG9rZW5cbiAgICAgICAgdmFyIHZhbHVlID0geWllbGQgKiBldmFsdWF0ZShleHByLnJocywgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgaWYgKGV4cHIubGhzLnR5cGUgIT09ICd2YXJpYWJsZScpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQyMDA1XCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgdG9rZW46IGV4cHIudmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV4cHIubGhzLnR5cGUgPT09ICdwYXRoJyA/IGV4cHIubGhzLnN0ZXBzWzBdLnZhbHVlIDogZXhwci5saHMudmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZW52aXJvbm1lbnQuYmluZChleHByLmxocy52YWx1ZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgY29uZGl0aW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVDb25kaXRpb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBjb25kaXRpb24gPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIuY29uZGl0aW9uLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICBpZiAoZnVuY3Rpb25Cb29sZWFuKGNvbmRpdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGUoZXhwci50aGVuLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHByLmVsc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIuZWxzZSwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGJsb2NrIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVCbG9jayhleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgLy8gY3JlYXRlIGEgbmV3IGZyYW1lIHRvIGxpbWl0IHRoZSBzY29wZSBvZiB2YXJpYWJsZSBhc3NpZ25tZW50c1xuICAgICAgICAvLyBUT0RPLCBvbmx5IGRvIHRoaXMgaWYgdGhlIHBvc3QtcGFyc2Ugc3RhZ2UgaGFzIGZsYWdnZWQgdGhpcyBhcyByZXF1aXJlZFxuICAgICAgICB2YXIgZnJhbWUgPSBjcmVhdGVGcmFtZShlbnZpcm9ubWVudCk7XG4gICAgICAgIC8vIGludm9rZSBlYWNoIGV4cHJlc3Npb24gaW4gdHVyblxuICAgICAgICAvLyBvbmx5IHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IG9uZVxuICAgICAgICBmb3IodmFyIGlpID0gMDsgaWkgPCBleHByLmV4cHJlc3Npb25zLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZShleHByLmV4cHJlc3Npb25zW2lpXSwgaW5wdXQsIGZyYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSBhIHJlZ2V4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBleHByZXNzaW9uIGNvbnRhaW5pbmcgcmVnZXhcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEhpZ2hlciBvcmRlciBmdW5jdGlvbiByZXByZXNlbnRpbmcgcHJlcGFyZWQgcmVnZXhcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmFsdWF0ZVJlZ2V4KGV4cHIpIHtcbiAgICAgICAgZXhwci52YWx1ZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgY2xvc3VyZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdmFyIHJlID0gZXhwci52YWx1ZTtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSByZS5leGVjKHN0cik7XG4gICAgICAgICAgICBpZihtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2g6IG1hdGNoWzBdLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogbWF0Y2guaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwczogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmKG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IG1hdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZ3JvdXBzLnB1c2gobWF0Y2hbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHJlLmxhc3RJbmRleCA+PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBjbG9zdXJlKHN0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihuZXh0ICYmIG5leHQubWF0Y2ggPT09ICcnICYmIHJlLmxhc3RJbmRleCA9PT0gZXhwci52YWx1ZS5sYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaGVzIHplcm8gbGVuZ3RoIHN0cmluZzsgdGhpcyB3aWxsIG5ldmVyIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkQxMDA0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGV4cHIudmFsdWUuc291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNsb3N1cmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgdmFyaWFibGUgYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlVmFyaWFibGUoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIC8vIGxvb2t1cCB0aGUgdmFyaWFibGUgdmFsdWUgaW4gdGhlIGVudmlyb25tZW50XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIC8vIGlmIHRoZSB2YXJpYWJsZSBuYW1lIGlzIGVtcHR5IHN0cmluZywgdGhlbiBpdCByZWZlcnMgdG8gY29udGV4dCB2YWx1ZVxuICAgICAgICBpZiAoZXhwci52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gZW52aXJvbm1lbnQubG9va3VwKGV4cHIudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc29ydCAvIG9yZGVyLWJ5IG9wZXJhdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBBU1QgZm9yIG9wZXJhdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gT3JkZXJlZCBzZXF1ZW5jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBldmFsdWF0ZVNvcnRFeHByZXNzaW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIGV2YWx1YXRlIHRoZSBsaHMsIHRoZW4gc29ydCB0aGUgcmVzdWx0cyBpbiBvcmRlciBhY2NvcmRpbmcgdG8gcmhzIGV4cHJlc3Npb25cbiAgICAgICAgdmFyIGxocyA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5saHMsIGlucHV0LCBlbnZpcm9ubWVudCk7XG5cbiAgICAgICAgLy8gc29ydCB0aGUgbGhzIGFycmF5XG4gICAgICAgIC8vIHVzZSBjb21wYXJhdG9yIGZ1bmN0aW9uXG4gICAgICAgIHZhciBjb21wYXJhdG9yID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgLy8gZXhwci5yaHMgaXMgYW4gYXJyYXkgb2Ygb3JkZXItYnkgaW4gcHJpb3JpdHkgb3JkZXJcbiAgICAgICAgICAgIHZhciBjb21wID0gMDtcbiAgICAgICAgICAgIGZvcih2YXIgaW5kZXggPSAwOyBjb21wID09PSAwICYmIGluZGV4IDwgZXhwci5yaHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlcm0gPSBleHByLnJoc1tpbmRleF07XG4gICAgICAgICAgICAgICAgLy9ldmFsdWF0ZSB0aGUgcmhzIGV4cHJlc3Npb24gaW4gdGhlIGNvbnRleHQgb2YgYVxuICAgICAgICAgICAgICAgIHZhciBhYSA9IGRyaXZlR2VuZXJhdG9yKHRlcm0uZXhwcmVzc2lvbiwgYSwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIC8vZXZhbHVhdGUgdGhlIHJocyBleHByZXNzaW9uIGluIHRoZSBjb250ZXh0IG9mIGJcbiAgICAgICAgICAgICAgICB2YXIgYmIgPSBkcml2ZUdlbmVyYXRvcih0ZXJtLmV4cHJlc3Npb24sIGIsIGVudmlyb25tZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIHR5cGUgY2hlY2tzXG4gICAgICAgICAgICAgICAgdmFyIGF0eXBlID0gdHlwZW9mIGFhO1xuICAgICAgICAgICAgICAgIHZhciBidHlwZSA9IHR5cGVvZiBiYjtcbiAgICAgICAgICAgICAgICAvLyB1bmRlZmluZWQgc2hvdWxkIGJlIGxhc3QgaW4gc29ydCBvcmRlclxuICAgICAgICAgICAgICAgIGlmKGF0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBzd2FwIHRoZW0sIHVubGVzcyBidHlwZSBpcyBhbHNvIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICBjb21wID0gKGJ0eXBlID09PSAndW5kZWZpbmVkJykgPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGJ0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIGFhIG9yIGJiIGFyZSBub3Qgc3RyaW5nIG9yIG51bWVyaWMgdmFsdWVzLCB0aGVuIHRocm93IGFuIGVycm9yXG4gICAgICAgICAgICAgICAgaWYoIShhdHlwZSA9PT0gJ3N0cmluZycgfHwgYXR5cGUgPT09ICdudW1iZXInKSB8fCAhKGJ0eXBlID09PSAnc3RyaW5nJyB8fCBidHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMDhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogIShhdHlwZSA9PT0gJ3N0cmluZycgfHwgYXR5cGUgPT09ICdudW1iZXInKSA/IGFhIDogYmJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2lmIGFhIGFuZCBiYiBhcmUgbm90IG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgICAgICAgICAgICBpZihhdHlwZSAhPT0gYnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJUMjAwN1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlMjogYmJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoYWEgPT09IGJiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJvdGggdGhlIHNhbWUgLSBtb3ZlIG9uIHRvIG5leHQgdGVybVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFhIDwgYmIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcCA9IC0xO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXAgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZih0ZXJtLmRlc2NlbmRpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcCA9IC1jb21wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9ubHkgc3dhcCBhICYgYiBpZiBjb21wIGVxdWFscyAxXG4gICAgICAgICAgICByZXR1cm4gY29tcCA9PT0gMTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXN1bHQgPSBmdW5jdGlvblNvcnQobGhzLCBjb21wYXJhdG9yKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIHRyYW5zZm9ybWVyIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBBU1QgZm9yIG9wZXJhdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gdHJhbmZvcm1lciBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlVHJhbnNmb3JtRXhwcmVzc2lvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgZnVuY3Rpb24gdG8gaW1wbGVtZW50IHRoZSB0cmFuc2Zvcm0gZGVmaW5pdGlvblxuICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSBmdW5jdGlvbioob2JqKSB7IC8vIHNpZ25hdHVyZSA8KG9hKTpvPlxuICAgICAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSBjb3B5IG9mIG9iaiB3aXRoIGNoYW5nZXMgc3BlY2lmaWVkIGJ5IHRoZSBwYXR0ZXJuL29wZXJhdGlvblxuICAgICAgICAgICAgdmFyIGNsb25lRnVuY3Rpb24gPSBlbnZpcm9ubWVudC5sb29rdXAoJ2Nsb25lJyk7XG4gICAgICAgICAgICBpZighaXNGdW5jdGlvbihjbG9uZUZ1bmN0aW9uKSkge1xuICAgICAgICAgICAgICAgIC8vIHRocm93IHR5cGUgZXJyb3JcbiAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMTNcIixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB5aWVsZCAqIGFwcGx5KGNsb25lRnVuY3Rpb24sIFtvYmpdLCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5wYXR0ZXJuLCByZXN1bHQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBtYXRjaGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGlmKCFBcnJheS5pc0FycmF5KG1hdGNoZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBbbWF0Y2hlc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcih2YXIgaWkgPSAwOyBpaSA8IG1hdGNoZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IG1hdGNoZXNbaWldO1xuICAgICAgICAgICAgICAgICAgICAvLyBldmFsdWF0ZSB0aGUgdXBkYXRlIHZhbHVlIGZvciBlYWNoIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGUgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIudXBkYXRlLCBtYXRjaCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgbXVzdCBiZSBhbiBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVR5cGUgPSB0eXBlb2YgdXBkYXRlO1xuICAgICAgICAgICAgICAgICAgICBpZih1cGRhdGVUeXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodXBkYXRlVHlwZSAhPT0gJ29iamVjdCcgfHwgdXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgdHlwZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJUMjAxMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIudXBkYXRlLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lcmdlIHRoZSB1cGRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgcHJvcCBpbiB1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtwcm9wXSA9IHVwZGF0ZVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSwgaWYgc3BlY2lmaWVkLCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ3MgKG9yIHNpbmdsZSBzdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBleHByLmRlbGV0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGlvbnMgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIuZGVsZXRlLCBtYXRjaCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGRlbGV0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gZGVsZXRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkZWxldGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0aW9ucyA9IFtkZWxldGlvbnNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXlPZlN0cmluZ3MoZGVsZXRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyB0eXBlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMTJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIuZGVsZXRlLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqaiA9IDA7IGpqIDwgZGVsZXRpb25zLmxlbmd0aDsgamorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWF0Y2hbZGVsZXRpb25zW2pqXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBkZWZpbmVGdW5jdGlvbih0cmFuc2Zvcm1lciwgJzwob2EpOm8+Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgYW4gZXhwcmVzc2lvbiBieSBkcml2aW5nIHRoZSBnZW5lcmF0b3IgdG8gY29tcGxldGlvblxuICAgICAqIFVzZWQgd2hlbiBpdCdzIG5vdCBwb3NzaWJsZSB0byB5aWVsZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gQVNUXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gcmVzdWx0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJpdmVHZW5lcmF0b3IoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciBnZW4gPSBldmFsdWF0ZShleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAvLyByZXR1cm5zIGEgZ2VuZXJhdG9yIC0gc28gaXRlcmF0ZSBvdmVyIGl0XG4gICAgICAgIHZhciBjb21wID0gZ2VuLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFjb21wLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbXAgPSBnZW4ubmV4dChjb21wLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcC52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgY2hhaW4gPSBkcml2ZUdlbmVyYXRvcihwYXJzZXIoJ2Z1bmN0aW9uKCRmLCAkZykgeyBmdW5jdGlvbigkeCl7ICRnKCRmKCR4KSkgfSB9JyksIG51bGwsIHN0YXRpY0ZyYW1lKTtcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBmdW5jdGlvbiBvbiB0aGUgUkhTIHVzaW5nIHRoZSBzZXF1ZW5jZSBvbiB0aGUgTEhTIGFzIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVBcHBseUV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cblxuICAgICAgICBpZihleHByLnJocy50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgZnVuY3Rpb24gX2ludm9jYXRpb25fOyBpbnZva2UgaXQgd2l0aCBsaHMgZXhwcmVzc2lvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAgICAgICAgIGV4cHIucmhzLmFyZ3VtZW50cy51bnNoaWZ0KGV4cHIubGhzKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVGdW5jdGlvbihleHByLnJocywgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgIGV4cHIucmhzLmFyZ3VtZW50cy5zaGlmdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxocyA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5saHMsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICB2YXIgZnVuYyA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5yaHMsIGlucHV0LCBlbnZpcm9ubWVudCk7XG5cbiAgICAgICAgICAgIGlmKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQyMDA2XCIsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihpc0Z1bmN0aW9uKGxocykpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGZ1bmN0aW9uIGNoYWluaW5nIChmdW5jMSB+PiBmdW5jMilcbiAgICAgICAgICAgICAgICAvLyDOuygkZiwgJGcpIHsgzrsoJHgpeyAkZygkZigkeCkpIH0gfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogYXBwbHkoY2hhaW4sIFtsaHMsIGZ1bmNdLCBlbnZpcm9ubWVudCwgbnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogYXBwbHkoZnVuYywgW2xoc10sIGVudmlyb25tZW50LCBudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmcgLSBleHByZXNzaW9uIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIGl0IGlzIGEgZnVuY3Rpb24gKGxhbWJkYSBvciBidWlsdC1pbilcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gKChhcmcgJiYgKGFyZy5fanNvbmF0YV9mdW5jdGlvbiA9PT0gdHJ1ZSB8fCBhcmcuX2pzb25hdGFfbGFtYmRhID09PSB0cnVlKSkgfHwgdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdHMgd2hldGhlciBhcmcgaXMgYSBsYW1iZGEgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IGFyZyAtIHRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSBpZiBpdCBpcyBhIGxhbWJkYSBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGFtYmRhKGFyZykge1xuICAgICAgICByZXR1cm4gYXJnICYmIGFyZy5fanNvbmF0YV9sYW1iZGEgPT09IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZyAtIGV4cHJlc3Npb24gdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUgaWYgaXQgaXMgYSBnZW5lcmF0b3IgaS5lLiB0aGUgcmVzdWx0IGZyb20gY2FsbGluZyBhXG4gICAgICogZ2VuZXJhdG9yIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNHZW5lcmF0b3IoYXJnKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgYXJnICE9PSBudWxsICYmXG4gICAgICAgICAgICBTeW1ib2wuaXRlcmF0b3IgaW4gYXJnICYmXG4gICAgICAgICAgICB0eXBlb2YgYXJnW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICduZXh0JyBpbiBhcmcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBhcmcubmV4dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGZ1bmN0aW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2FwcGx5dG9dIC0gTEhTIG9mIH4+IG9wZXJhdG9yXG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlRnVuY3Rpb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBwcm9jZWR1cmVcbiAgICAgICAgLy8gY2FuJ3QgYXNzdW1lIHRoYXQgZXhwci5wcm9jZWR1cmUgaXMgYSBsYW1iZGEgdHlwZSBkaXJlY3RseVxuICAgICAgICAvLyBjb3VsZCBiZSBhbiBleHByZXNzaW9uIHRoYXQgZXZhbHVhdGVzIHRvIGEgZnVuY3Rpb24gKGUuZy4gdmFyaWFibGUgcmVmZXJlbmNlLCBwYXJlbnMgZXhwciBldGMuXG4gICAgICAgIC8vIGV2YWx1YXRlIGl0IGdlbmVyaWNhbGx5IGZpcnN0LCB0aGVuIGNoZWNrIHRoYXQgaXQgaXMgYSBmdW5jdGlvbi4gIFRocm93IGVycm9yIGlmIG5vdC5cbiAgICAgICAgdmFyIHByb2MgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIucHJvY2VkdXJlLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvYyA9PT0gJ3VuZGVmaW5lZCcgJiYgZXhwci5wcm9jZWR1cmUudHlwZSA9PT0gJ3BhdGgnICYmIGVudmlyb25tZW50Lmxvb2t1cChleHByLnByb2NlZHVyZS5zdGVwc1swXS52YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIGhlbHAgdGhlIHVzZXIgb3V0IGhlcmUgaWYgdGhleSBzaW1wbHkgZm9yZ290IHRoZSBsZWFkaW5nICRcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlQxMDA1XCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgdG9rZW46IGV4cHIucHJvY2VkdXJlLnN0ZXBzWzBdLnZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV2YWx1YXRlZEFyZ3MgPSBbXTtcbiAgICAgICAgLy8gZWFnZXIgZXZhbHVhdGlvbiAtIGV2YWx1YXRlIHRoZSBhcmd1bWVudHNcbiAgICAgICAgZm9yICh2YXIgamogPSAwOyBqaiA8IGV4cHIuYXJndW1lbnRzLmxlbmd0aDsgamorKykge1xuICAgICAgICAgICAgLy8gb25seSBldmFsdWF0ZSAnZWFnZXInIGFyZ3VtZW50cyBhdCB0aGlzIHN0YWdlOyB3cmFwIHRoZSAnbGF6eScgb25lcyBpbiBhIGNsb3N1cmVcbiAgICAgICAgICAgIGV2YWx1YXRlZEFyZ3MucHVzaCh5aWVsZCogZXZhbHVhdGUoZXhwci5hcmd1bWVudHNbampdLCBpbnB1dCwgZW52aXJvbm1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBseSB0aGUgcHJvY2VkdXJlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBpZihpbnB1dCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgLy8gICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnB1dCwgJ19fZW52X18nLCB7XG4gICAgICAgICAgICAvLyAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgLy8gICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAvLyAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgcmV0dXJuIGVudmlyb25tZW50O1xuICAgICAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGFwcGx5KHByb2MsIGV2YWx1YXRlZEFyZ3MsIGlucHV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBhZGQgdGhlIHBvc2l0aW9uIGZpZWxkIHRvIHRoZSBlcnJvclxuICAgICAgICAgICAgZXJyLnBvc2l0aW9uID0gZXhwci5wb3NpdGlvbjtcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgZnVuY3Rpb24gaWRlbnRpZmllclxuICAgICAgICAgICAgZXJyLnRva2VuID0gZXhwci5wcm9jZWR1cmUudHlwZSA9PT0gJ3BhdGgnID8gZXhwci5wcm9jZWR1cmUuc3RlcHNbMF0udmFsdWUgOiBleHByLnByb2NlZHVyZS52YWx1ZTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHByb2NlZHVyZSBvciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9jIC0gUHJvY2VkdXJlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIC0gU2VsZlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXN1bHQgb2YgcHJvY2VkdXJlXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGFwcGx5KHByb2MsIGFyZ3MsIHNlbGYpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0geWllbGQgKiBhcHBseUlubmVyKHByb2MsIGFyZ3MsIHNlbGYpO1xuICAgICAgICB3aGlsZShpc0xhbWJkYShyZXN1bHQpICYmIHJlc3VsdC50aHVuayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gdHJhbXBvbGluZSBsb29wIC0gdGhpcyBnZXRzIGludm9rZWQgYXMgYSByZXN1bHQgb2YgdGFpbC1jYWxsIG9wdGltaXphdGlvblxuICAgICAgICAgICAgLy8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGEgdGFpbC1jYWxsIHRodW5rXG4gICAgICAgICAgICAvLyB1bnBhY2sgaXQsIGV2YWx1YXRlIGl0cyBhcmd1bWVudHMsIGFuZCBhcHBseSB0aGUgdGFpbCBjYWxsXG4gICAgICAgICAgICB2YXIgbmV4dCA9IHlpZWxkICogZXZhbHVhdGUocmVzdWx0LmJvZHkucHJvY2VkdXJlLCByZXN1bHQuaW5wdXQsIHJlc3VsdC5lbnZpcm9ubWVudCk7XG4gICAgICAgICAgICB2YXIgZXZhbHVhdGVkQXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yKHZhciBpaSA9IDA7IGlpIDwgcmVzdWx0LmJvZHkuYXJndW1lbnRzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICAgIGV2YWx1YXRlZEFyZ3MucHVzaCh5aWVsZCAqIGV2YWx1YXRlKHJlc3VsdC5ib2R5LmFyZ3VtZW50c1tpaV0sIHJlc3VsdC5pbnB1dCwgcmVzdWx0LmVudmlyb25tZW50KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogYXBwbHlJbm5lcihuZXh0LCBldmFsdWF0ZWRBcmdzLCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHByb2NlZHVyZSBvciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9jIC0gUHJvY2VkdXJlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIC0gU2VsZlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXN1bHQgb2YgcHJvY2VkdXJlXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGFwcGx5SW5uZXIocHJvYywgYXJncywgc2VsZikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgdmFsaWRhdGVkQXJncyA9IGFyZ3M7XG4gICAgICAgIGlmKHByb2MpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlZEFyZ3MgPSB2YWxpZGF0ZUFyZ3VtZW50cyhwcm9jLnNpZ25hdHVyZSwgYXJncywgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGFtYmRhKHByb2MpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGFwcGx5UHJvY2VkdXJlKHByb2MsIHZhbGlkYXRlZEFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2MgJiYgcHJvYy5fanNvbmF0YV9mdW5jdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcHJvYy5pbXBsZW1lbnRhdGlvbi5hcHBseShzZWxmLCB2YWxpZGF0ZWRBcmdzKTtcbiAgICAgICAgICAgIC8vIGBwcm9jLmltcGxlbWVudGF0aW9uYCBtaWdodCBiZSBhIGdlbmVyYXRvciBmdW5jdGlvblxuICAgICAgICAgICAgLy8gYW5kIGByZXN1bHRgIG1pZ2h0IGJlIGEgZ2VuZXJhdG9yIC0gaWYgc28sIHlpZWxkXG4gICAgICAgICAgICBpZihpc0dlbmVyYXRvcihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gcHJvYy5hcHBseShzZWxmLCB2YWxpZGF0ZWRBcmdzKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZihpc0dlbmVyYXRvcihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlQxMDA2XCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBsYW1iZGEgYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHt7bGFtYmRhOiBib29sZWFuLCBpbnB1dDogKiwgZW52aXJvbm1lbnQ6ICosIGFyZ3VtZW50czogKiwgYm9keTogKn19IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVMYW1iZGEoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIC8vIG1ha2UgYSBmdW5jdGlvbiAoY2xvc3VyZSlcbiAgICAgICAgdmFyIHByb2NlZHVyZSA9IHtcbiAgICAgICAgICAgIF9qc29uYXRhX2xhbWJkYTogdHJ1ZSxcbiAgICAgICAgICAgIGlucHV0OiBpbnB1dCxcbiAgICAgICAgICAgIGVudmlyb25tZW50OiBlbnZpcm9ubWVudCxcbiAgICAgICAgICAgIGFyZ3VtZW50czogZXhwci5hcmd1bWVudHMsXG4gICAgICAgICAgICBzaWduYXR1cmU6IGV4cHIuc2lnbmF0dXJlLFxuICAgICAgICAgICAgYm9keTogZXhwci5ib2R5XG4gICAgICAgIH07XG4gICAgICAgIGlmKGV4cHIudGh1bmsgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHByb2NlZHVyZS50aHVuayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2NlZHVyZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBwYXJ0aWFsIGFwcGxpY2F0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBldmFsdWF0ZVBhcnRpYWxBcHBsaWNhdGlvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgLy8gcGFydGlhbGx5IGFwcGx5IGEgZnVuY3Rpb25cbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgLy8gZXZhbHVhdGUgdGhlIGFyZ3VtZW50c1xuICAgICAgICB2YXIgZXZhbHVhdGVkQXJncyA9IFtdO1xuICAgICAgICBmb3IodmFyIGlpID0gMDsgaWkgPCBleHByLmFyZ3VtZW50cy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBleHByLmFyZ3VtZW50c1tpaV07XG4gICAgICAgICAgICBpZiAoYXJnLnR5cGUgPT09ICdvcGVyYXRvcicgJiYgYXJnLnZhbHVlID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICBldmFsdWF0ZWRBcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZhbHVhdGVkQXJncy5wdXNoKHlpZWxkICogZXZhbHVhdGUoYXJnLCBpbnB1dCwgZW52aXJvbm1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rdXAgdGhlIHByb2NlZHVyZVxuICAgICAgICB2YXIgcHJvYyA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5wcm9jZWR1cmUsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvYyA9PT0gJ3VuZGVmaW5lZCcgJiYgZXhwci5wcm9jZWR1cmUudHlwZSA9PT0gJ3BhdGgnICYmIGVudmlyb25tZW50Lmxvb2t1cChleHByLnByb2NlZHVyZS5zdGVwc1swXS52YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIGhlbHAgdGhlIHVzZXIgb3V0IGhlcmUgaWYgdGhleSBzaW1wbHkgZm9yZ290IHRoZSBsZWFkaW5nICRcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlQxMDA3XCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgdG9rZW46IGV4cHIucHJvY2VkdXJlLnN0ZXBzWzBdLnZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xhbWJkYShwcm9jKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFydGlhbEFwcGx5UHJvY2VkdXJlKHByb2MsIGV2YWx1YXRlZEFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2MgJiYgcHJvYy5fanNvbmF0YV9mdW5jdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFydGlhbEFwcGx5TmF0aXZlRnVuY3Rpb24ocHJvYy5pbXBsZW1lbnRhdGlvbiwgZXZhbHVhdGVkQXJncyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcnRpYWxBcHBseU5hdGl2ZUZ1bmN0aW9uKHByb2MsIGV2YWx1YXRlZEFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiVDEwMDhcIixcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICB0b2tlbjogZXhwci5wcm9jZWR1cmUudHlwZSA9PT0gJ3BhdGgnID8gZXhwci5wcm9jZWR1cmUuc3RlcHNbMF0udmFsdWUgOiBleHByLnByb2NlZHVyZS52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHRoZSBhcmd1bWVudHMgYWdhaW5zdCB0aGUgc2lnbmF0dXJlIHZhbGlkYXRvciAoaWYgaXQgZXhpc3RzKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNpZ25hdHVyZSAtIHZhbGlkYXRvciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgKiBAcGFyYW0geyp9IGNvbnRleHQgLSBjb250ZXh0IHZhbHVlXG4gICAgICogQHJldHVybnMge0FycmF5fSAtIHZhbGlkYXRlZCBhcmd1bWVudHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUFyZ3VtZW50cyhzaWduYXR1cmUsIGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgaWYodHlwZW9mIHNpZ25hdHVyZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gdmFsaWRhdGVcbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxpZGF0ZWRBcmdzID0gc2lnbmF0dXJlLnZhbGlkYXRlKGFyZ3MsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVkQXJncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBwcm9jZWR1cmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvYyAtIFByb2NlZHVyZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBBcmd1bWVudHNcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0IG9mIHByb2NlZHVyZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBhcHBseVByb2NlZHVyZShwcm9jLCBhcmdzKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBlbnYgPSBjcmVhdGVGcmFtZShwcm9jLmVudmlyb25tZW50KTtcbiAgICAgICAgcHJvYy5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0sIGluZGV4KSB7XG4gICAgICAgICAgICBlbnYuYmluZChwYXJhbS52YWx1ZSwgYXJnc1tpbmRleF0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jLmJvZHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBsYW1iZGEgdGhhdCB3cmFwcyBhIG5hdGl2ZSBmdW5jdGlvbiAtIGdlbmVyYXRlZCBieSBwYXJ0aWFsbHkgZXZhbHVhdGluZyBhIG5hdGl2ZVxuICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBhcHBseU5hdGl2ZUZ1bmN0aW9uKHByb2MuYm9keSwgZW52KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGUocHJvYy5ib2R5LCBwcm9jLmlucHV0LCBlbnYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFydGlhbGx5IGFwcGx5IHByb2NlZHVyZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9jIC0gUHJvY2VkdXJlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHt7bGFtYmRhOiBib29sZWFuLCBpbnB1dDogKiwgZW52aXJvbm1lbnQ6IHtiaW5kLCBsb29rdXB9LCBhcmd1bWVudHM6IEFycmF5LCBib2R5OiAqfX0gUmVzdWx0IG9mIHBhcnRpYWxseSBhcHBsaWVkIHByb2NlZHVyZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWxBcHBseVByb2NlZHVyZShwcm9jLCBhcmdzKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIGNsb3N1cmUsIGJpbmQgdGhlIHN1cHBsaWVkIHBhcmFtZXRlcnMgYW5kIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIHJlbWFpbmluZyAoPykgcGFyYW1ldGVyc1xuICAgICAgICB2YXIgZW52ID0gY3JlYXRlRnJhbWUocHJvYy5lbnZpcm9ubWVudCk7XG4gICAgICAgIHZhciB1bmJvdW5kQXJncyA9IFtdO1xuICAgICAgICBwcm9jLmFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChhcmcgJiYgYXJnLnR5cGUgPT09ICdvcGVyYXRvcicgJiYgYXJnLnZhbHVlID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICB1bmJvdW5kQXJncy5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW52LmJpbmQocGFyYW0udmFsdWUsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcHJvY2VkdXJlID0ge1xuICAgICAgICAgICAgX2pzb25hdGFfbGFtYmRhOiB0cnVlLFxuICAgICAgICAgICAgaW5wdXQ6IHByb2MuaW5wdXQsXG4gICAgICAgICAgICBlbnZpcm9ubWVudDogZW52LFxuICAgICAgICAgICAgYXJndW1lbnRzOiB1bmJvdW5kQXJncyxcbiAgICAgICAgICAgIGJvZHk6IHByb2MuYm9keVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcHJvY2VkdXJlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnRpYWxseSBhcHBseSBuYXRpdmUgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuYXRpdmUgLSBOYXRpdmUgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIC0gQXJndW1lbnRzXG4gICAgICogQHJldHVybnMge3tsYW1iZGE6IGJvb2xlYW4sIGlucHV0OiAqLCBlbnZpcm9ubWVudDoge2JpbmQsIGxvb2t1cH0sIGFyZ3VtZW50czogQXJyYXksIGJvZHk6ICp9fSBSZXN1bHQgb2YgcGFydGlhbGx5IGFwcGx5aW5nIG5hdGl2ZSBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWxBcHBseU5hdGl2ZUZ1bmN0aW9uKG5hdGl2ZSwgYXJncykge1xuICAgICAgICAvLyBjcmVhdGUgYSBsYW1iZGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBhbmQgaW52b2tlcyB0aGUgbmF0aXZlIGZ1bmN0aW9uXG4gICAgICAgIC8vIGdldCB0aGUgbGlzdCBvZiBkZWNsYXJlZCBhcmd1bWVudHMgZnJvbSB0aGUgbmF0aXZlIGZ1bmN0aW9uXG4gICAgICAgIC8vIHRoaXMgaGFzIHRvIGJlIHBpY2tlZCBvdXQgZnJvbSB0aGUgdG9TdHJpbmcoKSB2YWx1ZVxuICAgICAgICB2YXIgc2lnQXJncyA9IGdldE5hdGl2ZUZ1bmN0aW9uQXJndW1lbnRzKG5hdGl2ZSk7XG4gICAgICAgIHNpZ0FyZ3MgPSBzaWdBcmdzLm1hcChmdW5jdGlvbiAoc2lnQXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gJyQnICsgc2lnQXJnLnRyaW0oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBib2R5ID0gJ2Z1bmN0aW9uKCcgKyBzaWdBcmdzLmpvaW4oJywgJykgKyAnKXsgXyB9JztcblxuICAgICAgICB2YXIgYm9keUFTVCA9IHBhcnNlcihib2R5KTtcbiAgICAgICAgYm9keUFTVC5ib2R5ID0gbmF0aXZlO1xuXG4gICAgICAgIHZhciBwYXJ0aWFsID0gcGFydGlhbEFwcGx5UHJvY2VkdXJlKGJvZHlBU1QsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gcGFydGlhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBuYXRpdmUgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvYyAtIFByb2NlZHVyZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnYgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXN1bHQgb2YgYXBwbHlpbmcgbmF0aXZlIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGFwcGx5TmF0aXZlRnVuY3Rpb24ocHJvYywgZW52KSB7XG4gICAgICAgIHZhciBzaWdBcmdzID0gZ2V0TmF0aXZlRnVuY3Rpb25Bcmd1bWVudHMocHJvYyk7XG4gICAgICAgIC8vIGdlbmVyYXRlIHRoZSBhcnJheSBvZiBhcmd1bWVudHMgZm9yIGludm9raW5nIHRoZSBmdW5jdGlvbiAtIGxvb2sgdGhlbSB1cCBpbiB0aGUgZW52aXJvbm1lbnRcbiAgICAgICAgdmFyIGFyZ3MgPSBzaWdBcmdzLm1hcChmdW5jdGlvbiAoc2lnQXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gZW52Lmxvb2t1cChzaWdBcmcudHJpbSgpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHByb2MuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIGlmKGlzR2VuZXJhdG9yKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IG5hdGl2ZSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gRnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7KnxBcnJheX0gTmF0aXZlIGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE5hdGl2ZUZ1bmN0aW9uQXJndW1lbnRzKGZ1bmMpIHtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IGZ1bmMudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIHNpZ1BhcmVucyA9IC9cXCgoW14pXSopXFwpLy5leGVjKHNpZ25hdHVyZSlbMV07IC8vIHRoZSBjb250ZW50cyBvZiB0aGUgcGFyZW5zXG4gICAgICAgIHZhciBzaWdBcmdzID0gc2lnUGFyZW5zLnNwbGl0KCcsJyk7XG4gICAgICAgIHJldHVybiBzaWdBcmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBkZWZpbml0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uIGluIEphdmFzY3JpcHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlIC0gSlNPTmF0YSBmdW5jdGlvbiBzaWduYXR1cmUgZGVmaW5pdGlvblxuICAgICAqIEByZXR1cm5zIHt7aW1wbGVtZW50YXRpb246ICosIHNpZ25hdHVyZTogKn19IGZ1bmN0aW9uIGRlZmluaXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZpbmVGdW5jdGlvbihmdW5jLCBzaWduYXR1cmUpIHtcbiAgICAgICAgdmFyIGRlZmluaXRpb24gPSB7XG4gICAgICAgICAgICBfanNvbmF0YV9mdW5jdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIGltcGxlbWVudGF0aW9uOiBmdW5jXG4gICAgICAgIH07XG4gICAgICAgIGlmKHR5cGVvZiBzaWduYXR1cmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uLnNpZ25hdHVyZSA9IHBhcnNlU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3VtIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgLSBBcmd1bWVudHNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUb3RhbCB2YWx1ZSBvZiBhcmd1bWVudHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblN1bShhcmdzKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZ3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uKG51bSl7dG90YWwgKz0gbnVtO30pO1xuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ291bnQgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkNvdW50KGFyZ3MpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJncyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyZ3MubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1heCBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIC0gQXJndW1lbnRzXG4gICAgICogQHJldHVybnMge251bWJlcn0gTWF4IGVsZW1lbnQgaW4gdGhlIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25NYXgoYXJncykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmdzID09PSAndW5kZWZpbmVkJyB8fCBhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNaW4gZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE1pbiBlbGVtZW50IGluIHRoZSBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uTWluKGFyZ3MpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJncyA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkoTWF0aCwgYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXZlcmFnZSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIC0gQXJndW1lbnRzXG4gICAgICogQHJldHVybnMge251bWJlcn0gQXZlcmFnZSBlbGVtZW50IGluIHRoZSBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uQXZlcmFnZShhcmdzKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZ3MgPT09ICd1bmRlZmluZWQnIHx8IGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uKG51bSl7dG90YWwgKz0gbnVtO30pO1xuICAgICAgICByZXR1cm4gdG90YWwvYXJncy5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RpbmdpZnkgYXJndW1lbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFN0cmluZyBmcm9tIGFyZ3VtZW50c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU3RyaW5nKGFyZykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cjtcblxuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIGFscmVhZHkgYSBzdHJpbmdcbiAgICAgICAgICAgIHN0ciA9IGFyZztcbiAgICAgICAgfSBlbHNlIGlmKGlzRnVuY3Rpb24oYXJnKSkge1xuICAgICAgICAgICAgLy8gZnVuY3Rpb25zIChidWlsdC1pbiBhbmQgbGFtYmRhIGNvbnZlcnQgdG8gZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICBzdHIgPSAnJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUoYXJnKSkge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiRDMwMDFcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXJnLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHN0ciA9IEpTT04uc3RyaW5naWZ5KGFyZywgZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgIT09IG51bGwgJiYgdmFsLnRvUHJlY2lzaW9uICYmIGlzTnVtZXJpYyh2YWwpKSA/IE51bWJlcih2YWwudG9QcmVjaXNpb24oMTMpKSA6XG4gICAgICAgICAgICAgICAgICAgICh2YWwgJiYgaXNGdW5jdGlvbih2YWwpKSA/ICcnIDogdmFsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHN1YnN0cmluZyBiYXNlZCBvbiBjaGFyYWN0ZXIgbnVtYmVyIGFuZCBsZW5ndGhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gU3RyaW5nIHRvIGV2YWx1YXRlXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBzdGFydCAtIENoYXJhY3RlciBudW1iZXIgdG8gc3RhcnQgc3Vic3RyaW5nXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBbbGVuZ3RoXSAtIE51bWJlciBvZiBjaGFyYWN0ZXJzIGluIHN1YnN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8Kn0gU3Vic3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25TdWJzdHJpbmcoc3RyLCBzdGFydCwgbGVuZ3RoKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgc3Vic3RyaW5nIHVwIHVudGlsIGEgY2hhcmFjdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFN0cmluZyB0byBldmFsdWF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjaGFycyAtIENoYXJhY3RlciB0byBkZWZpbmUgc3Vic3RyaW5nIGJvdW5kYXJ5XG4gICAgICogQHJldHVybnMgeyp9IFN1YnN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU3Vic3RyaW5nQmVmb3JlKHN0ciwgY2hhcnMpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3MgPSBzdHIuaW5kZXhPZihjaGFycyk7XG4gICAgICAgIGlmIChwb3MgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgcG9zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgc3Vic3RyaW5nIGFmdGVyIGEgY2hhcmFjdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFN0cmluZyB0byBldmFsdWF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjaGFycyAtIENoYXJhY3RlciB0byBkZWZpbmUgc3Vic3RyaW5nIGJvdW5kYXJ5XG4gICAgICogQHJldHVybnMgeyp9IFN1YnN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU3Vic3RyaW5nQWZ0ZXIoc3RyLCBjaGFycykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvcyA9IHN0ci5pbmRleE9mKGNoYXJzKTtcbiAgICAgICAgaWYgKHBvcyA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihwb3MgKyBjaGFycy5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvd2VyY2FzZSBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBTdHJpbmcgdG8gZXZhbHVhdGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBMb3dlcmNhc2Ugc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Mb3dlcmNhc2Uoc3RyKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBwZXJjYXNlIGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFN0cmluZyB0byBldmFsdWF0ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFVwcGVyY2FzZSBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblVwcGVyY2FzZShzdHIpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBsZW5ndGggb2YgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkxlbmd0aChzdHIpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHIubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBhbmQgdHJpbSB3aGl0ZXNwYWNlIHdpdGhpbiBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBzdHJpbmcgdG8gYmUgdHJpbW1lZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdHJpbW1lZCBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblRyaW0oc3RyKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3JtYWxpemUgd2hpdGVzcGFjZVxuICAgICAgICB2YXIgcmVzdWx0ID0gc3RyLnJlcGxhY2UoL1sgXFx0XFxuXFxyXSsvZ20sICcgJyk7XG4gICAgICAgIGlmKHJlc3VsdC5jaGFyQXQoMCkgPT09ICcgJykge1xuICAgICAgICAgICAgLy8gc3RyaXAgbGVhZGluZyBzcGFjZVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBpZihyZXN1bHQuY2hhckF0KHJlc3VsdC5sZW5ndGggLSAxKSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAvLyBzdHJpcCB0cmFpbGluZyBzcGFjZVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygwLCByZXN1bHQubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWQgYSBzdHJpbmcgdG8gYSBtaW5pbXVtIHdpZHRoIGJ5IGFkZGluZyBjaGFyYWN0ZXJzIHRvIHRoZSBzdGFydCBvciBlbmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gc3RyaW5nIHRvIGJlIHBhZGRlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSBtaW5pbXVtIHdpZHRoOyArdmUgcGFkcyB0byB0aGUgcmlnaHQsIC12ZSBwYWRzIHRvIHRoZSBsZWZ0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFyXSAtIHRoZSBwYWQgY2hhcmFjdGVyKHMpOyBkZWZhdWx0cyB0byAnICdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHBhZGRlZCBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblBhZChzdHIsIHdpZHRoLCBjaGFyKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0eXBlb2YgY2hhciA9PT0gJ3VuZGVmaW5lZCcgfHwgY2hhci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNoYXIgPSAnICc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgcGFkTGVuZ3RoID0gTWF0aC5hYnMod2lkdGgpIC0gc3RyLmxlbmd0aDtcbiAgICAgICAgaWYocGFkTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSAobmV3IEFycmF5KHBhZExlbmd0aCArIDEpKS5qb2luKGNoYXIpO1xuICAgICAgICAgICAgaWYoY2hhci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgcGFkZGluZyA9IHBhZGRpbmcuc3Vic3RyaW5nKDAsIHBhZExlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih3aWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzdHIgKyBwYWRkaW5nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwYWRkaW5nICsgc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3RyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIHN0ciBjb250YWlucyB0aGUgdG9rZW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nIHRvIHRlc3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gLSBzdWJzdHJpbmcgb3IgcmVnZXggdG8gZmluZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSAtIHRydWUgaWYgc3RyIGNvbnRhaW5zIHRva2VuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Db250YWlucyhzdHIsIHRva2VuKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIGlmKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChzdHIuaW5kZXhPZih0b2tlbikgIT09IC0xKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gdG9rZW4oc3RyKTtcbiAgICAgICAgICAgIHJlc3VsdCA9ICh0eXBlb2YgbWF0Y2hlcyAhPT0gJ3VuZGVmaW5lZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXRjaCBhIHN0cmluZyB3aXRoIGEgcmVnZXggcmV0dXJuaW5nIGFuIGFycmF5IG9mIG9iamVjdCBjb250YWluaW5nIGRldGFpbHMgb2YgZWFjaCBtYXRjaFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVnZXggLSB0aGUgcmVnZXggYXBwbGllZCB0byB0aGUgc3RyaW5nXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBbbGltaXRdIC0gbWF4IG51bWJlciBvZiBtYXRjaGVzIHRvIHJldHVyblxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IG9mIG1hdGNoIG9iamVjdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbk1hdGNoKHN0ciwgcmVnZXgsIGxpbWl0KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsaW1pdCwgaWYgc3BlY2lmaWVkLCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlclxuICAgICAgICBpZihsaW1pdCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGltaXQsXG4gICAgICAgICAgICAgICAgY29kZTogJ0QzMDQwJyxcbiAgICAgICAgICAgICAgICBpbmRleDogM1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZih0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnIHx8IGxpbWl0ID4gMCkge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gcmVnZXgoc3RyKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWF0Y2hlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHlwZW9mIG1hdGNoZXMgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnIHx8IGNvdW50IDwgbGltaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoOiBtYXRjaGVzLm1hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IG1hdGNoZXMuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cHM6IG1hdGNoZXMuZ3JvdXBzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXRjaCBhIHN0cmluZyB3aXRoIGEgcmVnZXggcmV0dXJuaW5nIGFuIGFycmF5IG9mIG9iamVjdCBjb250YWluaW5nIGRldGFpbHMgb2YgZWFjaCBtYXRjaFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0dGVybiAtIHRoZSBzdWJzdHJpbmcvcmVnZXggYXBwbGllZCB0byB0aGUgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcGxhY2VtZW50IC0gdGV4dCB0byByZXBsYWNlIHRoZSBtYXRjaGVkIHN1YnN0cmluZ3NcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IFtsaW1pdF0gLSBtYXggbnVtYmVyIG9mIG1hdGNoZXMgdG8gcmV0dXJuXG4gICAgICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2YgbWF0Y2ggb2JqZWN0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBmdW5jdGlvblJlcGxhY2Uoc3RyLCBwYXR0ZXJuLCByZXBsYWNlbWVudCwgbGltaXQpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhdHRlcm4gY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgICBpZihwYXR0ZXJuID09PSAnJykge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiRDMwMTBcIixcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGF0dGVybixcbiAgICAgICAgICAgICAgICBpbmRleDogMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxpbWl0LCBpZiBzcGVjaWZpZWQsIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyXG4gICAgICAgIGlmKGxpbWl0IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiRDMwMTFcIixcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGltaXQsXG4gICAgICAgICAgICAgICAgaW5kZXg6IDRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVwbGFjZXI7XG4gICAgICAgIGlmKHR5cGVvZiByZXBsYWNlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlcGxhY2VyID0gZnVuY3Rpb24gKHJlZ2V4TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic3RpdHV0ZSA9ICcnO1xuICAgICAgICAgICAgICAgIC8vIHNjYW4gZm9yd2FyZCwgY29weWluZyB0aGUgcmVwbGFjZW1lbnQgdGV4dCBpbnRvIHRoZSBzdWJzdGl0dXRlIHN0cmluZ1xuICAgICAgICAgICAgICAgIC8vIGFuZCByZXBsYWNlIGFueSBvY2N1cnJlbmNlIG9mICRuIHdpdGggdGhlIHZhbHVlcyBtYXRjaGVkIGJ5IHRoZSByZWdleFxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcmVwbGFjZW1lbnQuaW5kZXhPZignJCcsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggIT09IC0xICYmIHBvc2l0aW9uIDwgcmVwbGFjZW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGUgKz0gcmVwbGFjZW1lbnQuc3Vic3RyaW5nKHBvc2l0aW9uLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9sbGFyVmFsID0gcmVwbGFjZW1lbnQuY2hhckF0KHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbGxhclZhbCA9PT0gJyQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsaXRlcmFsICRcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGUgKz0gJyQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkb2xsYXJWYWwgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0ZSArPSByZWdleE1hdGNoLm1hdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhEaWdpdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyZWdleE1hdGNoLmdyb3Vwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBzdWItbWF0Y2hlczsgYW55ICQgZm9sbG93ZWQgYnkgYSBkaWdpdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IGFuIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heERpZ2l0cyA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heCBudW1iZXIgb2YgZGlnaXRzIHRvIHBhcnNlIGZvbGxvd2luZyB0aGUgJFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heERpZ2l0cyA9IE1hdGguZmxvb3IoTWF0aC5sb2cocmVnZXhNYXRjaC5ncm91cHMubGVuZ3RoKSAqIE1hdGguTE9HMTBFKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHBhcnNlSW50KHJlcGxhY2VtZW50LnN1YnN0cmluZyhwb3NpdGlvbiwgcG9zaXRpb24gKyBtYXhEaWdpdHMpLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtYXhEaWdpdHMgPiAxICYmIGluZGV4ID4gcmVnZXhNYXRjaC5ncm91cHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBwYXJzZUludChyZXBsYWNlbWVudC5zdWJzdHJpbmcocG9zaXRpb24sIHBvc2l0aW9uICsgbWF4RGlnaXRzIC0gMSksIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4oaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVnZXhNYXRjaC5ncm91cHMubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1Ym1hdGNoID0gcmVnZXhNYXRjaC5ncm91cHNbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWJtYXRjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGUgKz0gc3VibWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gaW5kZXgudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBhIGNhcHR1cmUgZ3JvdXAsIHRyZWF0IHRoZSAkIGFzIGxpdGVyYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRlICs9ICckJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlcGxhY2VtZW50LmluZGV4T2YoJyQnLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1YnN0aXR1dGUgKz0gcmVwbGFjZW1lbnQuc3Vic3RyaW5nKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXBsYWNlciA9IHJlcGxhY2VtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSAwO1xuXG4gICAgICAgIGlmKHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcgfHwgbGltaXQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgaWYodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gc3RyLmluZGV4T2YocGF0dGVybiwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHdoaWxlKGluZGV4ICE9PSAtMSAmJiAodHlwZW9mIGxpbWl0ID09PSAndW5kZWZpbmVkJyB8fCBjb3VudCA8IGxpbWl0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyLnN1YnN0cmluZyhwb3NpdGlvbiwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gaW5kZXggKyBwYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzdHIuaW5kZXhPZihwYXR0ZXJuLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuc3Vic3RyaW5nKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBwYXR0ZXJuKHN0cik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtYXRjaGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHlwZW9mIG1hdGNoZXMgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnIHx8IGNvdW50IDwgbGltaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyLnN1YnN0cmluZyhwb3NpdGlvbiwgbWF0Y2hlcy5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZWRXaXRoID0geWllbGQgKiBhcHBseShyZXBsYWNlciwgW21hdGNoZXNdLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHJlcGxhY2VkV2l0aCBpcyBhIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIHJlcGxhY2VkV2l0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcmVwbGFjZWRXaXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgYSBzdHJpbmcgLSB0aHJvdyBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJEMzAxMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlcGxhY2VkV2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IG1hdGNoZXMuc3RhcnQgKyBtYXRjaGVzLm1hdGNoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5zdWJzdHJpbmcocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHN0cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzdHI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJhc2U2NCBlbmNvZGUgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nXG4gICAgICogQHJldHVybnMge1N0cmluZ30gQmFzZSA2NCBlbmNvZGluZyBvZiB0aGUgYmluYXJ5IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkJhc2U2NGVuY29kZShzdHIpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgYnRvYSBpbiBhIGJyb3dzZXIsIG9yIEJ1ZmZlciBpbiBOb2RlLmpzXG5cbiAgICAgICAgdmFyIGJ0b2EgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB3aW5kb3cuYnRvYSA6XG4gICAgICAgICAgICBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbHkgZG9pbmcgYG5ldyBCdWZmZXJgIGF0IHRoaXMgcG9pbnQgY2F1c2VzIEJyb3dzZXJpZnkgdG8gcHVsbFxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBlbnRpcmUgQnVmZmVyIGJyb3dzZXIgbGlicmFyeSwgd2hpY2ggaXMgbGFyZ2UgYW5kIHVubmVjZXNzYXJ5LlxuICAgICAgICAgICAgICAgIC8vIFVzaW5nIGBnbG9iYWwuQnVmZmVyYCBkZWZlYXRzIHRoaXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBnbG9iYWwuQnVmZmVyKHN0ciwgJ2JpbmFyeScpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIHJldHVybiBidG9hKHN0cik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmFzZTY0IGRlY29kZSBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBCYXNlIDY0IGVuY29kaW5nIG9mIHRoZSBiaW5hcnkgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uQmFzZTY0ZGVjb2RlKHN0cikge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBidG9hIGluIGEgYnJvd3Nlciwgb3IgQnVmZmVyIGluIE5vZGUuanNcbiAgICAgICAgdmFyIGF0b2IgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB3aW5kb3cuYXRvYiA6XG4gICAgICAgICAgICBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbHkgZG9pbmcgYG5ldyBCdWZmZXJgIGF0IHRoaXMgcG9pbnQgY2F1c2VzIEJyb3dzZXJpZnkgdG8gcHVsbFxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBlbnRpcmUgQnVmZmVyIGJyb3dzZXIgbGlicmFyeSwgd2hpY2ggaXMgbGFyZ2UgYW5kIHVubmVjZXNzYXJ5LlxuICAgICAgICAgICAgICAgIC8vIFVzaW5nIGBnbG9iYWwuQnVmZmVyYCBkZWZlYXRzIHRoaXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBnbG9iYWwuQnVmZmVyKHN0ciwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIHJldHVybiBhdG9iKHN0cik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BsaXQgYSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBzdWJzdHJpbmdzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXBhcmF0b3IgLSB0aGUgdG9rZW4gb3IgcmVnZXggdGhhdCBzcGxpdHMgdGhlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gW2xpbWl0XSAtIG1heCBudW1iZXIgb2Ygc3Vic3RyaW5nc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IG9mIHN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU3BsaXQoc3RyLCBzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsaW1pdCwgaWYgc3BlY2lmaWVkLCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlclxuICAgICAgICBpZihsaW1pdCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMDIwXCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxpbWl0LFxuICAgICAgICAgICAgICAgIGluZGV4OiAzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGlmKHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcgfHwgbGltaXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlcGFyYXRvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzdHIuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBzZXBhcmF0b3Ioc3RyKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1hdGNoZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0eXBlb2YgbWF0Y2hlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcgfHwgY291bnQgPCBsaW1pdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0ci5zdWJzdHJpbmcoc3RhcnQsIG1hdGNoZXMuc3RhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbWF0Y2hlcy5lbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcgfHwgY291bnQgPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RyLnN1YnN0cmluZyhzdGFydCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW3N0cl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBKb2luIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzdHJzIC0gYXJyYXkgb2Ygc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzZXBhcmF0b3JdIC0gdGhlIHRva2VuIHRoYXQgc3BsaXRzIHRoZSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgY29uY2F0ZW5hdGVkIHN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uSm9pbihzdHJzLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBzZXBhcmF0b3IgaXMgbm90IHNwZWNpZmllZCwgZGVmYXVsdCB0byBlbXB0eSBzdHJpbmdcbiAgICAgICAgaWYodHlwZW9mIHNlcGFyYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3Rycy5qb2luKHNlcGFyYXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0cyBhIG51bWJlciBpbnRvIGEgZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gdXNpbmcgWFBhdGggMy4xIEYmTyBmbjpmb3JtYXQtbnVtYmVyIHNwZWNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBudW1iZXIgdG8gZm9ybWF0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBpY3R1cmUgLSBwaWN0dXJlIHN0cmluZyBkZWZpbml0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG92ZXJyaWRlIGxvY2FsZSBkZWZhdWx0c1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBmb3JtYXR0ZWQgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Gb3JtYXROdW1iZXIodmFsdWUsIHBpY3R1cmUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgXCJkZWNpbWFsLXNlcGFyYXRvclwiOiBcIi5cIixcbiAgICAgICAgICAgIFwiZ3JvdXBpbmctc2VwYXJhdG9yXCI6IFwiLFwiLFxuICAgICAgICAgICAgXCJleHBvbmVudC1zZXBhcmF0b3JcIjogXCJlXCIsXG4gICAgICAgICAgICBcImluZmluaXR5XCI6IFwiSW5maW5pdHlcIixcbiAgICAgICAgICAgIFwibWludXMtc2lnblwiOiBcIi1cIixcbiAgICAgICAgICAgIFwiTmFOXCI6IFwiTmFOXCIsXG4gICAgICAgICAgICBcInBlcmNlbnRcIjogXCIlXCIsXG4gICAgICAgICAgICBcInBlci1taWxsZVwiOiBcIlxcdTIwMzBcIixcbiAgICAgICAgICAgIFwiemVyby1kaWdpdFwiOiBcIjBcIixcbiAgICAgICAgICAgIFwiZGlnaXRcIjogXCIjXCIsXG4gICAgICAgICAgICBcInBhdHRlcm4tc2VwYXJhdG9yXCI6IFwiO1wiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaWYgYG9wdGlvbnNgIGlzIHNwZWNpZmllZCwgdGhlbiBpdHMgZW50cmllcyBvdmVycmlkZSBkZWZhdWx0c1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IGRlZmF1bHRzO1xuICAgICAgICBpZih0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlY2ltYWxEaWdpdEZhbWlseSA9IFtdO1xuICAgICAgICB2YXIgemVyb0NoYXJDb2RlID0gcHJvcGVydGllc1snemVyby1kaWdpdCddLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGZvcih2YXIgaWkgPSB6ZXJvQ2hhckNvZGU7IGlpIDwgemVyb0NoYXJDb2RlICsgMTA7IGlpKyspIHtcbiAgICAgICAgICAgIGRlY2ltYWxEaWdpdEZhbWlseS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaWkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY3RpdmVDaGFycyA9IGRlY2ltYWxEaWdpdEZhbWlseS5jb25jYXQoW3Byb3BlcnRpZXNbJ2RlY2ltYWwtc2VwYXJhdG9yJ10sIHByb3BlcnRpZXNbJ2V4cG9uZW50LXNlcGFyYXRvciddLCBwcm9wZXJ0aWVzWydncm91cGluZy1zZXBhcmF0b3InXSwgcHJvcGVydGllcy5kaWdpdCwgcHJvcGVydGllc1sncGF0dGVybi1zZXBhcmF0b3InXV0pO1xuXG4gICAgICAgIHZhciBzdWJQaWN0dXJlcyA9IHBpY3R1cmUuc3BsaXQocHJvcGVydGllc1sncGF0dGVybi1zZXBhcmF0b3InXSk7XG5cbiAgICAgICAgaWYoc3ViUGljdHVyZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6ICdEMzA4MCcsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3BsaXRQYXJ0cyA9IGZ1bmN0aW9uKHN1YnBpY3R1cmUpIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaWkgPSAwOyBpaSA8IHN1YnBpY3R1cmUubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gc3VicGljdHVyZS5jaGFyQXQoaWkpO1xuICAgICAgICAgICAgICAgICAgICBpZihhY3RpdmVDaGFycy5pbmRleE9mKGNoKSAhPT0gLTEgJiYgY2ggIT09IHByb3BlcnRpZXNbJ2V4cG9uZW50LXNlcGFyYXRvciddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VicGljdHVyZS5zdWJzdHJpbmcoMCwgaWkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaWkgPSBzdWJwaWN0dXJlLmxlbmd0aCAtIDE7IGlpID49IDA7IGlpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSBzdWJwaWN0dXJlLmNoYXJBdChpaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGFjdGl2ZUNoYXJzLmluZGV4T2YoY2gpICE9PSAtMSAmJiBjaCAhPT0gcHJvcGVydGllc1snZXhwb25lbnQtc2VwYXJhdG9yJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJwaWN0dXJlLnN1YnN0cmluZyhpaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHZhciBhY3RpdmVQYXJ0ID0gc3VicGljdHVyZS5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aCwgc3VicGljdHVyZS5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBtYW50aXNzYVBhcnQsIGV4cG9uZW50UGFydCwgaW50ZWdlclBhcnQsIGZyYWN0aW9uYWxQYXJ0O1xuICAgICAgICAgICAgdmFyIGV4cG9uZW50UG9zaXRpb24gPSBzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllc1snZXhwb25lbnQtc2VwYXJhdG9yJ10sIHByZWZpeC5sZW5ndGgpO1xuICAgICAgICAgICAgaWYoZXhwb25lbnRQb3NpdGlvbiA9PT0gLTEgfHwgZXhwb25lbnRQb3NpdGlvbiA+IHN1YnBpY3R1cmUubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG1hbnRpc3NhUGFydCA9IGFjdGl2ZVBhcnQ7XG4gICAgICAgICAgICAgICAgZXhwb25lbnRQYXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYW50aXNzYVBhcnQgPSBhY3RpdmVQYXJ0LnN1YnN0cmluZygwLCBleHBvbmVudFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBleHBvbmVudFBhcnQgPSBhY3RpdmVQYXJ0LnN1YnN0cmluZyhleHBvbmVudFBvc2l0aW9uICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGVjaW1hbFBvc2l0aW9uID0gbWFudGlzc2FQYXJ0LmluZGV4T2YocHJvcGVydGllc1snZGVjaW1hbC1zZXBhcmF0b3InXSk7XG4gICAgICAgICAgICBpZihkZWNpbWFsUG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaW50ZWdlclBhcnQgPSBtYW50aXNzYVBhcnQ7XG4gICAgICAgICAgICAgICAgZnJhY3Rpb25hbFBhcnQgPSBzdWZmaXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGludGVnZXJQYXJ0ID0gbWFudGlzc2FQYXJ0LnN1YnN0cmluZygwLCBkZWNpbWFsUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGZyYWN0aW9uYWxQYXJ0ID0gbWFudGlzc2FQYXJ0LnN1YnN0cmluZyhkZWNpbWFsUG9zaXRpb24gKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBzdWZmaXgsXG4gICAgICAgICAgICAgICAgYWN0aXZlUGFydDogYWN0aXZlUGFydCxcbiAgICAgICAgICAgICAgICBtYW50aXNzYVBhcnQ6IG1hbnRpc3NhUGFydCxcbiAgICAgICAgICAgICAgICBleHBvbmVudFBhcnQ6IGV4cG9uZW50UGFydCxcbiAgICAgICAgICAgICAgICBpbnRlZ2VyUGFydDogaW50ZWdlclBhcnQsXG4gICAgICAgICAgICAgICAgZnJhY3Rpb25hbFBhcnQ6IGZyYWN0aW9uYWxQYXJ0LFxuICAgICAgICAgICAgICAgIHN1YnBpY3R1cmU6IHN1YnBpY3R1cmVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdmFsaWRhdGUgdGhlIHBpY3R1cmUgc3RyaW5nLCBGJk8gNC43LjNcbiAgICAgICAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24ocGFydHMpIHtcbiAgICAgICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgICAgIHZhciBpaTtcbiAgICAgICAgICAgIHZhciBzdWJwaWN0dXJlID0gcGFydHMuc3VicGljdHVyZTtcbiAgICAgICAgICAgIHZhciBkZWNpbWFsUG9zID0gc3VicGljdHVyZS5pbmRleE9mKHByb3BlcnRpZXNbJ2RlY2ltYWwtc2VwYXJhdG9yJ10pO1xuICAgICAgICAgICAgaWYoZGVjaW1hbFBvcyAhPT0gc3VicGljdHVyZS5sYXN0SW5kZXhPZihwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddKSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gJ0QzMDgxJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHN1YnBpY3R1cmUuaW5kZXhPZihwcm9wZXJ0aWVzLnBlcmNlbnQpICE9PSBzdWJwaWN0dXJlLmxhc3RJbmRleE9mKHByb3BlcnRpZXMucGVyY2VudCkpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA4Mic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllc1sncGVyLW1pbGxlJ10pICE9PSBzdWJwaWN0dXJlLmxhc3RJbmRleE9mKHByb3BlcnRpZXNbJ3Blci1taWxsZSddKSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gJ0QzMDgzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHN1YnBpY3R1cmUuaW5kZXhPZihwcm9wZXJ0aWVzLnBlcmNlbnQpICE9PSAtMSAmJiBzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllc1sncGVyLW1pbGxlJ10pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gJ0QzMDg0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yKGlpID0gMDsgaWkgPCBwYXJ0cy5tYW50aXNzYVBhcnQubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoID0gcGFydHMubWFudGlzc2FQYXJ0LmNoYXJBdChpaSk7XG4gICAgICAgICAgICAgICAgaWYoZGVjaW1hbERpZ2l0RmFtaWx5LmluZGV4T2YoY2gpICE9PSAtMSB8fCBjaCA9PT0gcHJvcGVydGllcy5kaWdpdCkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCF2YWxpZCkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gJ0QzMDg1JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGFyVHlwZXMgPSBwYXJ0cy5hY3RpdmVQYXJ0LnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24oY2hhcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY3RpdmVDaGFycy5pbmRleE9mKGNoYXIpID09PSAtMSA/ICdwJyA6ICdhJztcbiAgICAgICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgICAgICAgaWYoY2hhclR5cGVzLmluZGV4T2YoJ3AnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA4Nic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkZWNpbWFsUG9zICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmKHN1YnBpY3R1cmUuY2hhckF0KGRlY2ltYWxQb3MgLSAxKSA9PT0gcHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10gfHwgc3VicGljdHVyZS5jaGFyQXQoZGVjaW1hbFBvcyArIDEpID09PSBwcm9wZXJ0aWVzWydncm91cGluZy1zZXBhcmF0b3InXSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA4Nyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmKHBhcnRzLmludGVnZXJQYXJ0LmNoYXJBdChwYXJ0cy5pbnRlZ2VyUGFydC5sZW5ndGggLSAxKSA9PT0gcHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10pIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA4OCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10gKyBwcm9wZXJ0aWVzWydncm91cGluZy1zZXBhcmF0b3InXSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAnRDMwODknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9wdGlvbmFsRGlnaXRQb3MgPSBwYXJ0cy5pbnRlZ2VyUGFydC5pbmRleE9mKHByb3BlcnRpZXMuZGlnaXQpO1xuICAgICAgICAgICAgaWYob3B0aW9uYWxEaWdpdFBvcyAhPT0gLTEgJiYgcGFydHMuaW50ZWdlclBhcnQuc3Vic3RyaW5nKDAsIG9wdGlvbmFsRGlnaXRQb3MpLnNwbGl0KCcnKS5maWx0ZXIoZnVuY3Rpb24oY2hhcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNpbWFsRGlnaXRGYW1pbHkuaW5kZXhPZihjaGFyKSA+IC0xO1xuICAgICAgICAgICAgfSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gJ0QzMDkwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbmFsRGlnaXRQb3MgPSBwYXJ0cy5mcmFjdGlvbmFsUGFydC5sYXN0SW5kZXhPZihwcm9wZXJ0aWVzLmRpZ2l0KTtcbiAgICAgICAgICAgIGlmKG9wdGlvbmFsRGlnaXRQb3MgIT09IC0xICYmIHBhcnRzLmZyYWN0aW9uYWxQYXJ0LnN1YnN0cmluZyhvcHRpb25hbERpZ2l0UG9zKS5zcGxpdCgnJykuZmlsdGVyKGZ1bmN0aW9uKGNoYXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjaW1hbERpZ2l0RmFtaWx5LmluZGV4T2YoY2hhcikgPiAtMTtcbiAgICAgICAgICAgIH0pLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA5MSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXhwb25lbnRFeGlzdHMgPSAodHlwZW9mIHBhcnRzLmV4cG9uZW50UGFydCA9PT0gJ3N0cmluZycpO1xuICAgICAgICAgICAgaWYoZXhwb25lbnRFeGlzdHMgJiYgcGFydHMuZXhwb25lbnRQYXJ0Lmxlbmd0aCA+IDAgJiYgKHN1YnBpY3R1cmUuaW5kZXhPZihwcm9wZXJ0aWVzLnBlcmNlbnQpICE9PSAtMSB8fCBzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllc1sncGVyLW1pbGxlJ10pICE9PSAtMSkpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA5Mic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihleHBvbmVudEV4aXN0cyAmJiAocGFydHMuZXhwb25lbnRQYXJ0Lmxlbmd0aCA9PT0gMCB8fCBwYXJ0cy5leHBvbmVudFBhcnQuc3BsaXQoJycpLmZpbHRlcihmdW5jdGlvbihjaGFyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY2ltYWxEaWdpdEZhbWlseS5pbmRleE9mKGNoYXIpID09PSAtMTtcbiAgICAgICAgICAgIH0pLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAnRDMwOTMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFja1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYW5hbHlzZSB0aGUgcGljdHVyZSBzdHJpbmcsIEYmTyA0LjcuNFxuICAgICAgICB2YXIgYW5hbHlzZSA9IGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgICAgICAgICB2YXIgZ2V0R3JvdXBpbmdQb3NpdGlvbnMgPSBmdW5jdGlvbihwYXJ0LCB0b0xlZnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwaW5nUG9zaXRpb24gPSBwYXJ0LmluZGV4T2YocHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10pO1xuICAgICAgICAgICAgICAgIHdoaWxlKGdyb3VwaW5nUG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFyc1RvVGhlUmlnaHQgPSAodG9MZWZ0ID8gcGFydC5zdWJzdHJpbmcoMCwgZ3JvdXBpbmdQb3NpdGlvbikgOiBwYXJ0LnN1YnN0cmluZyhncm91cGluZ1Bvc2l0aW9uKSkuc3BsaXQoJycpLmZpbHRlcihmdW5jdGlvbihjaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjaW1hbERpZ2l0RmFtaWx5LmluZGV4T2YoY2hhcikgIT09IC0xIHx8IGNoYXIgPT09IHByb3BlcnRpZXMuZGlnaXQ7XG4gICAgICAgICAgICAgICAgICAgIH0pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goY2hhcnNUb1RoZVJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBpbmdQb3NpdGlvbiA9IHBhcnRzLmludGVnZXJQYXJ0LmluZGV4T2YocHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10sIGdyb3VwaW5nUG9zaXRpb24gKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgaW50ZWdlclBhcnRHcm91cGluZ1Bvc2l0aW9ucyA9IGdldEdyb3VwaW5nUG9zaXRpb25zKHBhcnRzLmludGVnZXJQYXJ0KTtcbiAgICAgICAgICAgIHZhciByZWd1bGFyID0gZnVuY3Rpb24oaW5kZXhlcykge1xuICAgICAgICAgICAgICAgIC8vIGFyZSB0aGUgZ3JvdXBpbmcgcG9zaXRpb25zIHJlZ3VsYXI/IGkuZS4gc2FtZSBpbnRlcnZhbCBiZXR3ZWVuIGVhY2ggb2YgdGhlbVxuICAgICAgICAgICAgICAgIGlmKGluZGV4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZ2NkID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYiA9PT0gMCA/IGEgOiBnY2QoYiwgYSAlIGIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgZ3JlYXRlc3QgY29tbW9uIGRpdmlzb3Igb2YgYWxsIHRoZSBwb3NpdGlvbnNcbiAgICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gaW5kZXhlcy5yZWR1Y2UoZ2NkKTtcbiAgICAgICAgICAgICAgICAvLyBpcyBldmVyeSBwb3NpdGlvbiBzZXBhcmF0ZWQgYnkgdGhpcyBkaXZpc29yPyBJZiBzbywgaXQncyByZWd1bGFyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpbmRleCA9IDE7IGluZGV4IDw9IGluZGV4ZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGluZGV4ZXMuaW5kZXhPZihpbmRleCAqIGZhY3RvcikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFjdG9yO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHJlZ3VsYXJHcm91cGluZyA9IHJlZ3VsYXIoaW50ZWdlclBhcnRHcm91cGluZ1Bvc2l0aW9ucyk7XG4gICAgICAgICAgICB2YXIgZnJhY3Rpb25hbFBhcnRHcm91cGluZ1Bvc2l0aW9ucyA9IGdldEdyb3VwaW5nUG9zaXRpb25zKHBhcnRzLmZyYWN0aW9uYWxQYXJ0LCB0cnVlKTtcblxuICAgICAgICAgICAgdmFyIG1pbmltdW1JbnRlZ2VyUGFydFNpemUgPSBwYXJ0cy5pbnRlZ2VyUGFydC5zcGxpdCgnJykuZmlsdGVyKGZ1bmN0aW9uKGNoYXIpIHsgcmV0dXJuIGRlY2ltYWxEaWdpdEZhbWlseS5pbmRleE9mKGNoYXIpICE9PSAtMTsgfSkubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHNjYWxpbmdGYWN0b3IgPSBtaW5pbXVtSW50ZWdlclBhcnRTaXplO1xuXG4gICAgICAgICAgICB2YXIgZnJhY3Rpb25hbFBhcnRBcnJheSA9IHBhcnRzLmZyYWN0aW9uYWxQYXJ0LnNwbGl0KCcnKTtcbiAgICAgICAgICAgIHZhciBtaW5pbXVtRmFjdGlvbmFsUGFydFNpemUgPSBmcmFjdGlvbmFsUGFydEFycmF5LmZpbHRlcihmdW5jdGlvbihjaGFyKSB7IHJldHVybiBkZWNpbWFsRGlnaXRGYW1pbHkuaW5kZXhPZihjaGFyKSAhPT0gLTE7IH0pLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBtYXhpbXVtRmFjdGlvbmFsUGFydFNpemUgPSBmcmFjdGlvbmFsUGFydEFycmF5LmZpbHRlcihmdW5jdGlvbihjaGFyKSB7IHJldHVybiBkZWNpbWFsRGlnaXRGYW1pbHkuaW5kZXhPZihjaGFyKSAhPT0gLTEgfHwgY2hhciA9PT0gcHJvcGVydGllcy5kaWdpdDsgfSkubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGV4cG9uZW50UHJlc2VudCA9IHR5cGVvZiBwYXJ0cy5leHBvbmVudFBhcnQgPT09ICdzdHJpbmcnO1xuICAgICAgICAgICAgaWYobWluaW11bUludGVnZXJQYXJ0U2l6ZSA9PT0gMCAmJiBtYXhpbXVtRmFjdGlvbmFsUGFydFNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZihleHBvbmVudFByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bUZhY3Rpb25hbFBhcnRTaXplID0gMTtcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bUZhY3Rpb25hbFBhcnRTaXplID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtSW50ZWdlclBhcnRTaXplID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihleHBvbmVudFByZXNlbnQgJiYgbWluaW11bUludGVnZXJQYXJ0U2l6ZSA9PT0gMCAmJiBwYXJ0cy5pbnRlZ2VyUGFydC5pbmRleE9mKHByb3BlcnRpZXMuZGlnaXQpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIG1pbmltdW1JbnRlZ2VyUGFydFNpemUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYobWluaW11bUludGVnZXJQYXJ0U2l6ZSA9PT0gMCAmJiBtaW5pbXVtRmFjdGlvbmFsUGFydFNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtaW5pbXVtRmFjdGlvbmFsUGFydFNpemUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1pbmltdW1FeHBvbmVudFNpemUgPSAwO1xuICAgICAgICAgICAgaWYoZXhwb25lbnRQcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgbWluaW11bUV4cG9uZW50U2l6ZSA9IHBhcnRzLmV4cG9uZW50UGFydC5zcGxpdCgnJykuZmlsdGVyKGZ1bmN0aW9uKGNoYXIpIHsgcmV0dXJuIGRlY2ltYWxEaWdpdEZhbWlseS5pbmRleE9mKGNoYXIpICE9PSAtMTsgfSkubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGludGVnZXJQYXJ0R3JvdXBpbmdQb3NpdGlvbnM6IGludGVnZXJQYXJ0R3JvdXBpbmdQb3NpdGlvbnMsXG4gICAgICAgICAgICAgICAgcmVndWxhckdyb3VwaW5nOiByZWd1bGFyR3JvdXBpbmcsXG4gICAgICAgICAgICAgICAgbWluaW11bUludGVnZXJQYXJ0U2l6ZTogbWluaW11bUludGVnZXJQYXJ0U2l6ZSxcbiAgICAgICAgICAgICAgICBzY2FsaW5nRmFjdG9yOiBzY2FsaW5nRmFjdG9yLFxuICAgICAgICAgICAgICAgIHByZWZpeDogcGFydHMucHJlZml4LFxuICAgICAgICAgICAgICAgIGZyYWN0aW9uYWxQYXJ0R3JvdXBpbmdQb3NpdGlvbnM6IGZyYWN0aW9uYWxQYXJ0R3JvdXBpbmdQb3NpdGlvbnMsXG4gICAgICAgICAgICAgICAgbWluaW11bUZhY3Rpb25hbFBhcnRTaXplOiBtaW5pbXVtRmFjdGlvbmFsUGFydFNpemUsXG4gICAgICAgICAgICAgICAgbWF4aW11bUZhY3Rpb25hbFBhcnRTaXplOiBtYXhpbXVtRmFjdGlvbmFsUGFydFNpemUsXG4gICAgICAgICAgICAgICAgbWluaW11bUV4cG9uZW50U2l6ZTogbWluaW11bUV4cG9uZW50U2l6ZSxcbiAgICAgICAgICAgICAgICBzdWZmaXg6IHBhcnRzLnN1ZmZpeCxcbiAgICAgICAgICAgICAgICBwaWN0dXJlOiBwYXJ0cy5zdWJwaWN0dXJlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwYXJ0cyA9IHN1YlBpY3R1cmVzLm1hcChzcGxpdFBhcnRzKTtcbiAgICAgICAgcGFydHMuZm9yRWFjaCh2YWxpZGF0ZSk7XG5cbiAgICAgICAgdmFyIHZhcmlhYmxlcyA9IHBhcnRzLm1hcChhbmFseXNlKTtcblxuICAgICAgICBpZih2YXJpYWJsZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB2YXJpYWJsZXMucHVzaChKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhcmlhYmxlc1swXSkpKTtcbiAgICAgICAgICAgIHZhcmlhYmxlc1sxXS5wcmVmaXggPSBwcm9wZXJ0aWVzWydtaW51cy1zaWduJ10gKyB2YXJpYWJsZXNbMV0ucHJlZml4O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETyBjYWNoZSB0aGUgcmVzdWx0IG9mIHRoZSBhbmFseXNpc1xuXG4gICAgICAgIC8vIGZvcm1hdCB0aGUgbnVtYmVyXG4gICAgICAgIC8vIGJ1bGxldCAxOiBUT0RPOiBOYU4gLSBub3Qgc3VyZSB3ZSdkIGV2ZXIgZ2V0IHRoaXMgaW4gSlNPTlxuICAgICAgICB2YXIgcGljO1xuICAgICAgICAvLyBidWxsZXQgMjpcbiAgICAgICAgaWYodmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgcGljID0gdmFyaWFibGVzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGljID0gdmFyaWFibGVzWzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhZGp1c3RlZE51bWJlcjtcbiAgICAgICAgLy8gYnVsbGV0IDM6XG4gICAgICAgIGlmKHBpYy5waWN0dXJlLmluZGV4T2YocHJvcGVydGllcy5wZXJjZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFkanVzdGVkTnVtYmVyID0gdmFsdWUgKiAxMDA7XG4gICAgICAgIH0gZWxzZSBpZihwaWMucGljdHVyZS5pbmRleE9mKHByb3BlcnRpZXNbJ3Blci1taWxsZSddKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFkanVzdGVkTnVtYmVyID0gdmFsdWUgKiAxMDAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRqdXN0ZWROdW1iZXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBidWxsZXQgNDpcbiAgICAgICAgLy8gVE9ETzogaW5maW5pdHkgLSBub3Qgc3VyZSB3ZSdkIGV2ZXIgZ2V0IHRoaXMgaW4gSlNPTlxuICAgICAgICAvLyBidWxsZXQgNTpcbiAgICAgICAgdmFyIG1hbnRpc3NhLCBleHBvbmVudDtcbiAgICAgICAgaWYocGljLm1pbmltdW1FeHBvbmVudFNpemUgPT09IDApIHtcbiAgICAgICAgICAgIG1hbnRpc3NhID0gYWRqdXN0ZWROdW1iZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBtYW50aXNzYSAqIDEwXmV4cG9uZW50ID0gYWRqdXN0ZWROdW1iZXJcbiAgICAgICAgICAgIHZhciBtYXhNYW50aXNzYSA9IE1hdGgucG93KDEwLCBwaWMuc2NhbGluZ0ZhY3Rvcik7XG4gICAgICAgICAgICB2YXIgbWluTWFudGlzc2EgPSBNYXRoLnBvdygxMCwgcGljLnNjYWxpbmdGYWN0b3IgLSAxKTtcbiAgICAgICAgICAgIG1hbnRpc3NhID0gYWRqdXN0ZWROdW1iZXI7XG4gICAgICAgICAgICBleHBvbmVudCA9IDA7XG4gICAgICAgICAgICB3aGlsZShtYW50aXNzYSA8IG1pbk1hbnRpc3NhKSB7XG4gICAgICAgICAgICAgICAgbWFudGlzc2EgKj0gMTA7XG4gICAgICAgICAgICAgICAgZXhwb25lbnQgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlKG1hbnRpc3NhID4gbWF4TWFudGlzc2EpIHtcbiAgICAgICAgICAgICAgICBtYW50aXNzYSAvPSAxMDtcbiAgICAgICAgICAgICAgICBleHBvbmVudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGJ1bGxldCA2OlxuICAgICAgICB2YXIgcm91bmRlZE51bWJlciA9IGZ1bmN0aW9uUm91bmQobWFudGlzc2EsIHBpYy5tYXhpbXVtRmFjdGlvbmFsUGFydFNpemUpO1xuICAgICAgICAvLyBidWxsZXQgNzpcbiAgICAgICAgdmFyIG1ha2VTdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSwgZHApIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBNYXRoLmFicyh2YWx1ZSkudG9GaXhlZChkcCk7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllc1snemVyby1kaWdpdCddICE9PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJycpLm1hcChmdW5jdGlvbiAoZGlnaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoZGlnaXQgPj0gJzAnICYmIGRpZ2l0IDw9JzknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjaW1hbERpZ2l0RmFtaWx5W2RpZ2l0LmNoYXJDb2RlQXQoMCkgLSA0OF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlnaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IG1ha2VTdHJpbmcocm91bmRlZE51bWJlciwgcGljLm1heGltdW1GYWN0aW9uYWxQYXJ0U2l6ZSk7XG4gICAgICAgIHZhciBkZWNpbWFsUG9zID0gc3RyaW5nVmFsdWUuaW5kZXhPZignLicpO1xuICAgICAgICBpZihkZWNpbWFsUG9zID09PSAtMSkge1xuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZSArIHByb3BlcnRpZXNbJ2RlY2ltYWwtc2VwYXJhdG9yJ107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpbmdWYWx1ZSA9IHN0cmluZ1ZhbHVlLnJlcGxhY2UoJy4nLCBwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZShzdHJpbmdWYWx1ZS5jaGFyQXQoMCkgPT09IHByb3BlcnRpZXNbJ3plcm8tZGlnaXQnXSkge1xuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUoc3RyaW5nVmFsdWUuY2hhckF0KHN0cmluZ1ZhbHVlLmxlbmd0aCAtIDEpID09PSBwcm9wZXJ0aWVzWyd6ZXJvLWRpZ2l0J10pIHtcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gc3RyaW5nVmFsdWUuc3Vic3RyaW5nKDAsIHN0cmluZ1ZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ1bGxldHMgOCAmIDk6XG4gICAgICAgIGRlY2ltYWxQb3MgPSBzdHJpbmdWYWx1ZS5pbmRleE9mKHByb3BlcnRpZXNbJ2RlY2ltYWwtc2VwYXJhdG9yJ10pO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IHBpYy5taW5pbXVtSW50ZWdlclBhcnRTaXplIC0gZGVjaW1hbFBvcztcbiAgICAgICAgdmFyIHBhZFJpZ2h0ID0gcGljLm1pbmltdW1GYWN0aW9uYWxQYXJ0U2l6ZSAtIChzdHJpbmdWYWx1ZS5sZW5ndGggLSBkZWNpbWFsUG9zIC0gMSk7XG4gICAgICAgIHN0cmluZ1ZhbHVlID0gKHBhZExlZnQgPiAwID8gbmV3IEFycmF5KHBhZExlZnQgKyAxKS5qb2luKCcwJykgOiAnJykgKyBzdHJpbmdWYWx1ZTtcbiAgICAgICAgc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZSArIChwYWRSaWdodCA+IDAgPyBuZXcgQXJyYXkocGFkUmlnaHQgKyAxKS5qb2luKCcwJykgOiAnJyk7XG4gICAgICAgIGRlY2ltYWxQb3MgPSBzdHJpbmdWYWx1ZS5pbmRleE9mKHByb3BlcnRpZXNbJ2RlY2ltYWwtc2VwYXJhdG9yJ10pO1xuICAgICAgICAvLyBidWxsZXQgMTA6XG4gICAgICAgIGlmKHBpYy5yZWd1bGFyR3JvdXBpbmcgPiAwKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBDb3VudCA9IE1hdGguZmxvb3IoKGRlY2ltYWxQb3MgLSAxKSAvIHBpYy5yZWd1bGFyR3JvdXBpbmcpO1xuICAgICAgICAgICAgZm9yKHZhciBncm91cCA9IDE7IGdyb3VwIDw9IGdyb3VwQ291bnQ7IGdyb3VwKyspIHtcbiAgICAgICAgICAgICAgICBzdHJpbmdWYWx1ZSA9IFtzdHJpbmdWYWx1ZS5zbGljZSgwLCBkZWNpbWFsUG9zIC0gZ3JvdXAgKiBwaWMucmVndWxhckdyb3VwaW5nKSwgcHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10sIHN0cmluZ1ZhbHVlLnNsaWNlKGRlY2ltYWxQb3MgLSBncm91cCAqIHBpYy5yZWd1bGFyR3JvdXBpbmcpXS5qb2luKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBpYy5pbnRlZ2VyUGFydEdyb3VwaW5nUG9zaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gW3N0cmluZ1ZhbHVlLnNsaWNlKDAsIGRlY2ltYWxQb3MgLSBwb3MpLCBwcm9wZXJ0aWVzWydncm91cGluZy1zZXBhcmF0b3InXSwgc3RyaW5nVmFsdWUuc2xpY2UoZGVjaW1hbFBvcyAtIHBvcyldLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIGRlY2ltYWxQb3MrKztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ1bGxldCAxMTpcbiAgICAgICAgZGVjaW1hbFBvcyA9IHN0cmluZ1ZhbHVlLmluZGV4T2YocHJvcGVydGllc1snZGVjaW1hbC1zZXBhcmF0b3InXSk7XG4gICAgICAgIHBpYy5mcmFjdGlvbmFsUGFydEdyb3VwaW5nUG9zaXRpb25zLmZvckVhY2goZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgICAgICBzdHJpbmdWYWx1ZSA9IFtzdHJpbmdWYWx1ZS5zbGljZSgwLCBwb3MgKyBkZWNpbWFsUG9zICsgMSksIHByb3BlcnRpZXNbJ2dyb3VwaW5nLXNlcGFyYXRvciddLCBzdHJpbmdWYWx1ZS5zbGljZShwb3MgKyBkZWNpbWFsUG9zICsgMSldLmpvaW4oJycpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gYnVsbGV0IDEyOlxuICAgICAgICBkZWNpbWFsUG9zID0gc3RyaW5nVmFsdWUuaW5kZXhPZihwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddKTtcbiAgICAgICAgaWYocGljLnBpY3R1cmUuaW5kZXhPZihwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddKSA9PT0gLTEgfHwgZGVjaW1hbFBvcyA9PT0gc3RyaW5nVmFsdWUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZS5zdWJzdHJpbmcoMCwgc3RyaW5nVmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnVsbGV0IDEzOlxuICAgICAgICBpZih0eXBlb2YgZXhwb25lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YXIgc3RyaW5nRXhwb25lbnQgPSBtYWtlU3RyaW5nKGV4cG9uZW50LCAwKTtcbiAgICAgICAgICAgIHBhZExlZnQgPSBwaWMubWluaW11bUV4cG9uZW50U2l6ZSAtIHN0cmluZ0V4cG9uZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmKHBhZExlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nRXhwb25lbnQgPSBuZXcgQXJyYXkocGFkTGVmdCArIDEpLmpvaW4oJzAnKSArIHN0cmluZ0V4cG9uZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZSArIHByb3BlcnRpZXNbJ2V4cG9uZW50LXNlcGFyYXRvciddICsgKGV4cG9uZW50IDwgMCA/IHByb3BlcnRpZXNbJ21pbnVzLXNpZ24nXSA6ICcnKSArIHN0cmluZ0V4cG9uZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ1bGxldCAxNDpcbiAgICAgICAgc3RyaW5nVmFsdWUgPSBwaWMucHJlZml4ICsgc3RyaW5nVmFsdWUgKyBwaWMuc3VmZml4O1xuICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBudW1iZXIgdG8gYSBzdHJpbmcgdXNpbmcgYSBzcGVjaWZpZWQgbnVtYmVyIGJhc2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSB0aGUgbnVtYmVyIHRvIGNvbnZlcnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl4XSAtIHRoZSBudW1iZXIgYmFzZTsgbXVzdCBiZSBiZXR3ZWVuIDIgYW5kIDM2LiBEZWZhdWx0cyB0byAxMFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGNvbnZlcnRlZCBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkZvcm1hdEJhc2UodmFsdWUsIHJhZGl4KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gZnVuY3Rpb25Sb3VuZCh2YWx1ZSk7XG5cbiAgICAgICAgaWYodHlwZW9mIHJhZGl4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmFkaXggPSAxMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhZGl4ID0gZnVuY3Rpb25Sb3VuZChyYWRpeCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihyYWRpeCA8IDIgfHwgcmFkaXggPiAzNikge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6ICdEMzEwMCcsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJhZGl4XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gdmFsdWUudG9TdHJpbmcocmFkaXgpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdCBhcmd1bWVudCB0byBudW1iZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnIC0gQXJndW1lbnRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBudW1lcmljIHZhbHVlIG9mIGFyZ3VtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25OdW1iZXIoYXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gYWxyZWFkeSBhIG51bWJlclxuICAgICAgICAgICAgcmVzdWx0ID0gYXJnO1xuICAgICAgICB9IGVsc2UgaWYodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgJiYgL14tPygwfChbMS05XVswLTldKikpKFxcLlswLTldKyk/KFtFZV1bLStdP1swLTldKyk/JC8udGVzdChhcmcpICYmICFpc05hTihwYXJzZUZsb2F0KGFyZykpICYmIGlzRmluaXRlKGFyZykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlRmxvYXQoYXJnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMDMwXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGFyZyxcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICBpbmRleDogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFic29sdXRlIHZhbHVlIG9mIGEgbnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZyAtIEFyZ3VtZW50XG4gICAgICogQHJldHVybnMge051bWJlcn0gYWJzb2x1dGUgdmFsdWUgb2YgYXJndW1lbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkFicyhhcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gTWF0aC5hYnMoYXJnKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3VuZHMgYSBudW1iZXIgZG93biB0byBpbnRlZ2VyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZyAtIEFyZ3VtZW50XG4gICAgICogQHJldHVybnMge051bWJlcn0gcm91bmRlZCBpbnRlZ2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25GbG9vcihhcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gTWF0aC5mbG9vcihhcmcpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJvdW5kcyBhIG51bWJlciB1cCB0byBpbnRlZ2VyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZyAtIEFyZ3VtZW50XG4gICAgICogQHJldHVybnMge051bWJlcn0gcm91bmRlZCBpbnRlZ2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25DZWlsKGFyZykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBNYXRoLmNlaWwoYXJnKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3VuZCB0byBoYWxmIGV2ZW5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJnIC0gQXJndW1lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJlY2lzaW9uIC0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gICAgICogQHJldHVybnMge051bWJlcn0gcm91bmRlZCBpbnRlZ2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Sb3VuZChhcmcsIHByZWNpc2lvbikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihwcmVjaXNpb24pIHtcbiAgICAgICAgICAgIC8vIHNoaWZ0IHRoZSBkZWNpbWFsIHBsYWNlIC0gdGhpcyBuZWVkcyB0byBiZSBkb25lIGluIGEgc3RyaW5nIHNpbmNlIG11bHRpcGx5aW5nXG4gICAgICAgICAgICAvLyBieSBhIHBvd2VyIG9mIHRlbiBjYW4gaW50cm9kdWNlIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBlcnJvcnMgd2hpY2ggbWVzcyB1cFxuICAgICAgICAgICAgLy8gdGhpcyByb3VuZGluZyBhbGdvcml0aG0gLSBTZWUgJ0RlY2ltYWwgcm91bmRpbmcnIGluXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3JvdW5kXG4gICAgICAgICAgICAvLyBTaGlmdFxuICAgICAgICAgICAgdmFyIHZhbHVlID0gYXJnLnRvU3RyaW5nKCkuc3BsaXQoJ2UnKTtcbiAgICAgICAgICAgIGFyZyA9ICsodmFsdWVbMF0gKyAnZScgKyAodmFsdWVbMV0gPyAoK3ZhbHVlWzFdICsgcHJlY2lzaW9uKSA6IHByZWNpc2lvbikpO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyByb3VuZCB1cCB0byBuZWFyZXN0IGludFxuICAgICAgICByZXN1bHQgPSBNYXRoLnJvdW5kKGFyZyk7XG4gICAgICAgIHZhciBkaWZmID0gcmVzdWx0IC0gYXJnO1xuICAgICAgICBpZihNYXRoLmFicyhkaWZmKSA9PT0gMC41ICYmIE1hdGguYWJzKHJlc3VsdCAlIDIpID09PSAxKSB7XG4gICAgICAgICAgICAvLyByb3VuZGVkIHRoZSB3cm9uZyB3YXkgLSBhZGp1c3QgdG8gbmVhcmVzdCBldmVuIG51bWJlclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0IC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZihwcmVjaXNpb24pIHtcbiAgICAgICAgICAgIC8vIFNoaWZ0IGJhY2tcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0LnRvU3RyaW5nKCkuc3BsaXQoJ2UnKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICByZXN1bHQgPSArKHZhbHVlWzBdICsgJ2UnICsgKHZhbHVlWzFdID8gKCt2YWx1ZVsxXSAtIHByZWNpc2lvbikgOiAtcHJlY2lzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoT2JqZWN0LmlzKHJlc3VsdCwgLTApKSB7IC8vIEVTTGludCBydWxlICduby1jb21wYXJlLW5lZy16ZXJvJyBzdWdnZXN0cyB0aGlzIHdheVxuICAgICAgICAgICAgLy8gSlNPTiBkb2Vzbid0IGRvIC0wXG4gICAgICAgICAgICByZXN1bHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3F1YXJlIHJvb3Qgb2YgbnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZyAtIEFyZ3VtZW50XG4gICAgICogQHJldHVybnMge051bWJlcn0gc3F1YXJlIHJvb3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblNxcnQoYXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGFyZyA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMDYwXCIsXG4gICAgICAgICAgICAgICAgaW5kZXg6IDEsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGFyZ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IE1hdGguc3FydChhcmcpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmFpc2VzIG51bWJlciB0byB0aGUgcG93ZXIgb2YgdGhlIHNlY29uZCBudW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJnIC0gdGhlIGJhc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZXhwIC0gdGhlIGV4cG9uZW50XG4gICAgICogQHJldHVybnMge051bWJlcn0gcm91bmRlZCBpbnRlZ2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Qb3dlcihhcmcsIGV4cCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBNYXRoLnBvdyhhcmcsIGV4cCk7XG5cbiAgICAgICAgaWYoIWlzRmluaXRlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMDYxXCIsXG4gICAgICAgICAgICAgICAgaW5kZXg6IDEsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGFyZyxcbiAgICAgICAgICAgICAgICBleHA6IGV4cFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSBudW1iZXIgMCA8PSBuIDwgMVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHJhbmRvbSBudW1iZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblJhbmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgYW4gaW5wdXQgYW5kIHJldHVybiBhIGJvb2xlYW5cbiAgICAgKiBAcGFyYW0geyp9IGFyZyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBCb29sZWFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Cb29sZWFuKGFyZykge1xuICAgICAgICAvLyBjYXN0IGFyZyB0byBpdHMgZWZmZWN0aXZlIGJvb2xlYW4gdmFsdWVcbiAgICAgICAgLy8gYm9vbGVhbjogdW5jaGFuZ2VkXG4gICAgICAgIC8vIHN0cmluZzogemVyby1sZW5ndGggLT4gZmFsc2U7IG90aGVyd2lzZSAtPiB0cnVlXG4gICAgICAgIC8vIG51bWJlcjogMCAtPiBmYWxzZTsgb3RoZXJ3aXNlIC0+IHRydWVcbiAgICAgICAgLy8gbnVsbCAtPiBmYWxzZVxuICAgICAgICAvLyBhcnJheTogZW1wdHkgLT4gZmFsc2U7IGxlbmd0aCA+IDEgLT4gdHJ1ZVxuICAgICAgICAvLyBvYmplY3Q6IGVtcHR5IC0+IGZhbHNlOyBub24tZW1wdHkgLT4gdHJ1ZVxuICAgICAgICAvLyBmdW5jdGlvbiAtPiBmYWxzZVxuXG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuY3Rpb25Cb29sZWFuKGFyZ1swXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRydWVzID0gYXJnLmZpbHRlcihmdW5jdGlvbih2YWwpIHtyZXR1cm4gZnVuY3Rpb25Cb29sZWFuKHZhbCk7fSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZXMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGFyZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc051bWVyaWMoYXJnKSkge1xuICAgICAgICAgICAgaWYgKGFyZyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYXJnICE9PSBudWxsICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYXJnKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGl0J3Mgbm90IGEgbGFtYmRhIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKCEoaXNMYW1iZGEoYXJnKSB8fCBhcmcuX2pzb25hdGFfZnVuY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyAmJiBhcmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBCb29sZWFuIE5PVCBvZiB0aGUgYXJnXG4gICAgICogQHBhcmFtIHsqfSBhcmcgLSBhcmd1bWVudFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIE5PVCBhcmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbk5vdChhcmcpIHtcbiAgICAgICAgcmV0dXJuICFmdW5jdGlvbkJvb2xlYW4oYXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBtYXAgZnJvbSBhbiBhcnJheSBvZiBhcmd1bWVudHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyXSAtIGFycmF5IHRvIG1hcCBvdmVyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIGZ1bmN0aW9uIHRvIGFwcGx5XG4gICAgICogQHJldHVybnMge0FycmF5fSBNYXAgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZnVuY3Rpb25NYXAoYXJyLCBmdW5jKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIC8vIGRvIHRoZSBtYXAgLSBpdGVyYXRlIG92ZXIgdGhlIGFycmF5cywgYW5kIGludm9rZSBmdW5jXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZnVuY19hcmdzID0gW2FycltpXV07IC8vIHRoZSBmaXJzdCBhcmcgKHZhbHVlKSBpcyByZXF1aXJlZFxuICAgICAgICAgICAgLy8gdGhlIG90aGVyIHR3byBhcmUgb3B0aW9uYWwgLSBvbmx5IHN1cHBseSBpdCBpZiB0aGUgZnVuY3Rpb24gY2FuIHRha2UgaXRcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmMubGVuZ3RoIDpcbiAgICAgICAgICAgICAgICBmdW5jLl9qc29uYXRhX2Z1bmN0aW9uID09PSB0cnVlID8gZnVuYy5pbXBsZW1lbnRhdGlvbi5sZW5ndGggOiBmdW5jLmFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBpZihsZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgIGZ1bmNfYXJncy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYobGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICAgICBmdW5jX2FyZ3MucHVzaChhcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW52b2tlIGZ1bmNcbiAgICAgICAgICAgIHZhciByZXMgPSB5aWVsZCAqIGFwcGx5KGZ1bmMsIGZ1bmNfYXJncywgbnVsbCk7XG4gICAgICAgICAgICBpZih0eXBlb2YgcmVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFRoaXMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGRvZXMgbm90IGhhdmUgYSB5aWVsZCgpLCBwcmVzdW1hYmx5IHRvIG1ha2UgaXRcbiAgICAvLyBjb25zaXN0ZW50IHdpdGggb3RoZXIgc2ltaWxhciBmdW5jdGlvbnMuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbWFwIGZyb20gYW4gYXJyYXkgb2YgYXJndW1lbnRzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2Fycl0gLSBhcnJheSB0byBmaWx0ZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gcHJlZGljYXRlIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge0FycmF5fSBNYXAgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZnVuY3Rpb25GaWx0ZXIoYXJyLCBmdW5jKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS15aWVsZFxuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcnIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIHZhciBwcmVkaWNhdGUgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBhcnJheSkge1xuICAgICAgICAgICAgdmFyIGl0ID0gYXBwbHkoZnVuYywgW3ZhbHVlLCBpbmRleCwgYXJyYXldLCBudWxsKTtcbiAgICAgICAgICAgIC8vIHJldHVybnMgYSBnZW5lcmF0b3IgLSBzbyBpdGVyYXRlIG92ZXIgaXRcbiAgICAgICAgICAgIHZhciByZXMgPSBpdC5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoIXJlcy5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gaXQubmV4dChyZXMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBhcnJbaV07XG4gICAgICAgICAgICBpZihmdW5jdGlvbkJvb2xlYW4ocHJlZGljYXRlKGVudHJ5LCBpLCBhcnIpKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udm9sdmVzICh6aXBzKSBlYWNoIHZhbHVlIGZyb20gYSBzZXQgb2YgYXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdIC0gYXJyYXlzIHRvIHppcFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gWmlwcGVkIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25aaXAoKSB7XG4gICAgICAgIC8vIHRoaXMgY2FuIHRha2UgYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAvLyBsZW5ndGggb2YgdGhlIHNob3J0ZXN0IGFycmF5XG4gICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbi5hcHBseShNYXRoLCBhcmdzLm1hcChmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmcubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdHVwbGUgPSBhcmdzLm1hcCgoYXJnKSA9PiB7cmV0dXJuIGFyZ1tpXTt9KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHR1cGxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvbGQgbGVmdCBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNlcXVlbmNlIC0gU2VxdWVuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5pdCAtIEluaXRpYWwgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0XG4gICAgICovXG4gICAgZnVuY3Rpb24qIGZ1bmN0aW9uRm9sZExlZnQoc2VxdWVuY2UsIGZ1bmMsIGluaXQpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc2VxdWVuY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBpZiAoIShmdW5jLmxlbmd0aCA9PT0gMiB8fCAoZnVuYy5fanNvbmF0YV9mdW5jdGlvbiA9PT0gdHJ1ZSAmJiBmdW5jLmltcGxlbWVudGF0aW9uLmxlbmd0aCA9PT0gMikgfHwgZnVuYy5hcmd1bWVudHMubGVuZ3RoID09PSAyKSkge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgIGNvZGU6IFwiRDMwNTBcIixcbiAgICAgICAgICAgICAgICBpbmRleDogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbml0ID09PSAndW5kZWZpbmVkJyAmJiBzZXF1ZW5jZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzZXF1ZW5jZVswXTtcbiAgICAgICAgICAgIGluZGV4ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGluaXQ7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBzZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogYXBwbHkoZnVuYywgW3Jlc3VsdCwgc2VxdWVuY2VbaW5kZXhdXSwgbnVsbCk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4ga2V5cyBmb3IgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZyAtIE9iamVjdFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2Yga2V5c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uS2V5cyhhcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgLy8gbWVyZ2UgdGhlIGtleXMgb2YgYWxsIG9mIHRoZSBpdGVtcyBpbiB0aGUgYXJyYXlcbiAgICAgICAgICAgIHZhciBtZXJnZSA9IHt9O1xuICAgICAgICAgICAgYXJnLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gZnVuY3Rpb25LZXlzKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2Vba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuY3Rpb25LZXlzKG1lcmdlKTtcbiAgICAgICAgfSBlbHNlIGlmKGFyZyAhPT0gbnVsbCAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAhKGlzTGFtYmRhKGFyZykpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBPYmplY3Qua2V5cyhhcmcpO1xuICAgICAgICAgICAgaWYocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB2YWx1ZSBmcm9tIGFuIG9iamVjdCBmb3IgYSBnaXZlbiBrZXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gT2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIEtleSBpbiBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7Kn0gVmFsdWUgb2Yga2V5IGluIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uTG9va3VwKG9iamVjdCwga2V5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBldmFsdWF0ZU5hbWUoe3ZhbHVlOiBrZXl9LCBvYmplY3QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGVuZCBzZWNvbmQgYXJndW1lbnQgdG8gZmlyc3RcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gYXJnMSAtIEZpcnN0IGFyZ3VtZW50XG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGFyZzIgLSBTZWNvbmQgYXJndW1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gQXBwZW5kZWQgYXJndW1lbnRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25BcHBlbmQoYXJnMSwgYXJnMikge1xuICAgICAgICAvLyBkaXNyZWdhcmQgdW5kZWZpbmVkIGFyZ3NcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZzI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZzE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgZWl0aGVyIGFyZ3VtZW50IGlzIG5vdCBhbiBhcnJheSwgbWFrZSBpdCBzb1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgICAgIGFyZzEgPSBbYXJnMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZzIpKSB7XG4gICAgICAgICAgICBhcmcyID0gW2FyZzJdO1xuICAgICAgICB9XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGFyZzEsIGFyZzIpO1xuICAgICAgICByZXR1cm4gYXJnMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBhcmd1bWVudCBpcyB1bmRlZmluZWRcbiAgICAgKiBAcGFyYW0geyp9IGFyZyAtIGFyZ3VtZW50XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IEZhbHNlIGlmIGFyZ3VtZW50IHVuZGVmaW5lZCwgb3RoZXJ3aXNlIHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkV4aXN0cyhhcmcpe1xuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGFuIG9iamVjdCBpbnRvIGFuIGFycmF5IG9mIG9iamVjdCB3aXRoIG9uZSBwcm9wZXJ0eSBlYWNoXG4gICAgICogQHBhcmFtIHsqfSBhcmcgLSB0aGUgb2JqZWN0IHRvIHNwbGl0XG4gICAgICogQHJldHVybnMgeyp9IC0gdGhlIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25TcHJlYWQoYXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZihBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgIC8vIHNwcmVhZCBhbGwgb2YgdGhlIGl0ZW1zIGluIHRoZSBhcnJheVxuICAgICAgICAgICAgYXJnLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uQXBwZW5kKHJlc3VsdCwgZnVuY3Rpb25TcHJlYWQoaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZihhcmcgIT09IG51bGwgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgIWlzTGFtYmRhKGFyZykpIHtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIGFyZykge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IGFyZ1trZXldO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhcmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIGEgc2luZ2xlIG9iamVjdC4gIER1cGxpY2F0ZSBwcm9wZXJ0aWVzIGFyZVxuICAgICAqIG92ZXJyaWRkZW4gYnkgZW50cmllcyBsYXRlciBpbiB0aGUgYXJyYXlcbiAgICAgKiBAcGFyYW0geyp9IGFyZyAtIHRoZSBvYmplY3RzIHRvIG1lcmdlXG4gICAgICogQHJldHVybnMgeyp9IC0gdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uTWVyZ2UoYXJnKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgICAgYXJnLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBmb3IodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyB0aGUgb3JkZXIgb2YgaXRlbXMgaW4gYW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgLSB0aGUgYXJyYXkgdG8gcmV2ZXJzZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gLSB0aGUgcmV2ZXJzZWQgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblJldmVyc2UoYXJyKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihhcnIubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtsZW5ndGggLSBpIC0gMV0gPSBhcnJbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBvYmogLSB0aGUgaW5wdXQgb2JqZWN0IHRvIGl0ZXJhdGUgb3ZlclxuICAgICAqIEBwYXJhbSB7Kn0gZnVuYyAtIHRoZSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGtleS92YWx1ZSBwYWlyXG4gICAgICogQHJldHVybnMge0FycmF5fSAtIHRoZSByZXN1bHRhbnQgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZnVuY3Rpb25FYWNoKG9iaiwgZnVuYykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgZm9yKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICB2YXIgZnVuY19hcmdzID0gW29ialtrZXldLCBrZXldO1xuICAgICAgICAgICAgLy8gaW52b2tlIGZ1bmNcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHlpZWxkICogYXBwbHkoZnVuYywgZnVuY19hcmdzLCBudWxsKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgdGhlIG1lcmdlIHNvcnQgKHN0YWJsZSkgd2l0aCBvcHRpb25hbCBjb21wYXJhdG9yIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgLSB0aGUgYXJyYXkgdG8gc29ydFxuICAgICAqIEBwYXJhbSB7Kn0gY29tcGFyYXRvciAtIGNvbXBhcmF0b3IgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IC0gc29ydGVkIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Tb3J0KGFyciwgY29tcGFyYXRvcikge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcnIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYXJyLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbXA7XG4gICAgICAgIGlmKHR5cGVvZiBjb21wYXJhdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gaW5qZWN0IGEgZGVmYXVsdCBjb21wYXJhdG9yIC0gb25seSB3b3JrcyBmb3IgbnVtZXJpYyBvciBzdHJpbmcgYXJyYXlzXG4gICAgICAgICAgICBpZiAoIWlzQXJyYXlPZk51bWJlcnMoYXJyKSAmJiAhaXNBcnJheU9mU3RyaW5ncyhhcnIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJEMzA3MFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogMVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbXAgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhID4gYjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZih0eXBlb2YgY29tcGFyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZm9yIGludGVybmFsIHVzYWdlIG9mIGZ1bmN0aW9uU29ydCAoaS5lLiBvcmRlci1ieSBzeW50YXgpXG4gICAgICAgICAgICBjb21wID0gY29tcGFyYXRvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXAgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBpdCA9IGFwcGx5KGNvbXBhcmF0b3IsIFthLCBiXSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJucyBhIGdlbmVyYXRvciAtIHNvIGl0ZXJhdGUgb3ZlciBpdFxuICAgICAgICAgICAgICAgIHZhciBjb21wID0gaXQubmV4dCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlICghY29tcC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXAgPSBpdC5uZXh0KGNvbXAudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcC52YWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWVyZ2UgPSBmdW5jdGlvbihsLCByKSB7XG4gICAgICAgICAgICB2YXIgbWVyZ2VfaXRlciA9IGZ1bmN0aW9uKHJlc3VsdCwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVmdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyaWdodC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocmVzdWx0LCBsZWZ0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbXAobGVmdFswXSwgcmlnaHRbMF0pKSB7IC8vIGludm9rZSB0aGUgY29tcGFyYXRvciBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCByZXR1cm5zIHRydWUgLSBzd2FwIGxlZnQgYW5kIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJpZ2h0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VfaXRlcihyZXN1bHQsIGxlZnQsIHJpZ2h0LnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Uga2VlcCB0aGUgc2FtZSBvcmRlclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsZWZ0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VfaXRlcihyZXN1bHQsIGxlZnQuc2xpY2UoMSksIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG1lcmdlZCA9IFtdO1xuICAgICAgICAgICAgbWVyZ2VfaXRlcihtZXJnZWQsIGwsIHIpO1xuICAgICAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc29ydCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgICAgICBpZihhcnJheS5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IoYXJyYXkubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBhcnJheS5zbGljZSgwLCBtaWRkbGUpO1xuICAgICAgICAgICAgICAgIHZhciByaWdodCA9IGFycmF5LnNsaWNlKG1pZGRsZSk7XG4gICAgICAgICAgICAgICAgbGVmdCA9IHNvcnQobGVmdCk7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBzb3J0KHJpZ2h0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2UobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBzb3J0KGFycik7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSYW5kb21seSBzaHVmZmxlcyB0aGUgY29udGVudHMgb2YgYW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgLSB0aGUgaW5wdXQgYXJyYXlcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBzaHVmZmxlZCBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU2h1ZmZsZShhcnIpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGFyci5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNodWZmbGUgdXNpbmcgdGhlICdpbnNpZGUtb3V0JyB2YXJpYW50IG9mIHRoZSBGaXNoZXItWWF0ZXMgYWxnb3JpdGhtXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7IC8vIHJhbmRvbSBpbnRlZ2VyIHN1Y2ggdGhhdCAwIOKJpCBqIOKJpCBpXG4gICAgICAgICAgICBpZihpICE9PSBqKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gcmVzdWx0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2pdID0gYXJyW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gYW4gb2JqZWN0LCBhbmQgcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZ1xuICAgICAqIG9ubHkgdGhlIGtleS92YWx1ZSBwYWlycyB0aGF0IHBhc3NlZCB0aGUgcHJlZGljYXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXJnIC0gdGhlIG9iamVjdCB0byBiZSBzaWZ0ZWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZnVuYyAtIHRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gKGxhbWJkYSBvciBuYXRpdmUpXG4gICAgICogQHJldHVybnMge29iamVjdH0gLSBzaWZ0ZWQgb2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25TaWZ0KGFyZywgZnVuYykge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgICAgdmFyIHByZWRpY2F0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBpdCA9IGFwcGx5KGZ1bmMsIFt2YWx1ZSwga2V5LCBvYmplY3RdLCBudWxsKTtcbiAgICAgICAgICAgIC8vIHJldHVybnMgYSBnZW5lcmF0b3IgLSBzbyBpdGVyYXRlIG92ZXIgaXRcbiAgICAgICAgICAgIHZhciByZXMgPSBpdC5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoIXJlcy5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gaXQubmV4dChyZXMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IodmFyIGl0ZW0gaW4gYXJnKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBhcmdbaXRlbV07XG4gICAgICAgICAgICBpZihmdW5jdGlvbkJvb2xlYW4ocHJlZGljYXRlKGVudHJ5LCBpdGVtLCBhcmcpKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpdGVtXSA9IGVudHJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW1wdHkgb2JqZWN0cyBzaG91bGQgYmUgY2hhbmdlZCB0byB1bmRlZmluZWRcbiAgICAgICAgaWYoT2JqZWN0LmtleXMocmVzdWx0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gUmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIGFuIElTTyA4NjAxIGZvcm1hdHRlZCB0aW1lc3RhbXBcbiAgICB2YXIgaXNvODYwMXJlZ2V4ID0gbmV3IFJlZ0V4cCgnXlxcXFxkezR9LVswMV1cXFxcZC1bMC0zXVxcXFxkVFswLTJdXFxcXGQ6WzAtNV1cXFxcZDpbMC01XVxcXFxkXFxcXC5cXFxcZCsoWystXVswLTJdXFxcXGQ6WzAtNV1cXFxcZHxaKSQnKTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIElTTyA4NjAxIHRpbWVzdGFtcCB0byBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGVwb2NoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGltZXN0YW1wIC0gdGhlIElTTyA4NjAxIHRpbWVzdGFtcCB0byBiZSBjb252ZXJ0ZWRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSAtIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2hcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblRvTWlsbGlzKHRpbWVzdGFtcCkge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiB0aW1lc3RhbXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWlzbzg2MDFyZWdleC50ZXN0KHRpbWVzdGFtcCkpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMTEwXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRpbWVzdGFtcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBEYXRlLnBhcnNlKHRpbWVzdGFtcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaCB0byBhbiBJU08gODYwMSB0aW1lc3RhbXBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWlsbGlzIC0gbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaCB0byBiZSBjb252ZXJ0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSAtIGFuIElTTyA4NjAxIGZvcm1hdHRlZCB0aW1lc3RhbXBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkZyb21NaWxsaXMobWlsbGlzKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIG1pbGxpcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERhdGUobWlsbGlzKS50b0lTT1N0cmluZygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb25lcyBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnIC0gb2JqZWN0IHRvIGNsb25lIChkZWVwIGNvcHkpXG4gICAgICogQHJldHVybnMgeyp9IC0gdGhlIGNsb25lZCBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkNsb25lKGFyZykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZnVuY3Rpb25TdHJpbmcoYXJnKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGZyYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVuY2xvc2luZ0Vudmlyb25tZW50IC0gRW5jbG9zaW5nIGVudmlyb25tZW50XG4gICAgICogQHJldHVybnMge3tiaW5kOiBiaW5kLCBsb29rdXA6IGxvb2t1cH19IENyZWF0ZWQgZnJhbWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGcmFtZShlbmNsb3NpbmdFbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgYmluZGluZ3MgPSB7fTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJpbmQ6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGJpbmRpbmdzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9va3VwOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZihiaW5kaW5ncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJpbmRpbmdzW25hbWVdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5jbG9zaW5nRW52aXJvbm1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlbmNsb3NpbmdFbnZpcm9ubWVudC5sb29rdXAobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBGdW5jdGlvbiByZWdpc3RyYXRpb25cbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdzdW0nLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblN1bSwgJzxhPG4+Om4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2NvdW50JywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Db3VudCwgJzxhOm4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ21heCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uTWF4LCAnPGE8bj46bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnbWluJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25NaW4sICc8YTxuPjpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdhdmVyYWdlJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25BdmVyYWdlLCAnPGE8bj46bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc3RyaW5nJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TdHJpbmcsICc8eC06cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc3Vic3RyaW5nJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TdWJzdHJpbmcsICc8cy1ubj86cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc3Vic3RyaW5nQmVmb3JlJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TdWJzdHJpbmdCZWZvcmUsICc8cy1zOnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3N1YnN0cmluZ0FmdGVyJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TdWJzdHJpbmdBZnRlciwgJzxzLXM6cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnbG93ZXJjYXNlJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Mb3dlcmNhc2UsICc8cy06cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgndXBwZXJjYXNlJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25VcHBlcmNhc2UsICc8cy06cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnbGVuZ3RoJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25MZW5ndGgsICc8cy06bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgndHJpbScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uVHJpbSwgJzxzLTpzPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdwYWQnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblBhZCwgJzxzLW5zPzpzPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdtYXRjaCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uTWF0Y2gsICc8cy1mPHM6bz5uPzphPG8+PicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdjb250YWlucycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQ29udGFpbnMsICc8cy0oc2YpOmI+JykpOyAvLyBUT0RPIDxzLShzZjxzOm8+KTpiPlxuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3JlcGxhY2UnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblJlcGxhY2UsICc8cy0oc2YpKHNmKW4/OnM+JykpOyAvLyBUT0RPIDxzLShzZjxzOm8+KShzZjxvOnM+KW4/OnM+XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc3BsaXQnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblNwbGl0LCAnPHMtKHNmKW4/OmE8cz4+JykpOyAvLyBUT0RPIDxzLShzZjxzOm8+KW4/OmE8cz4+XG4gICAgc3RhdGljRnJhbWUuYmluZCgnam9pbicsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uSm9pbiwgJzxhPHM+cz86cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnZm9ybWF0TnVtYmVyJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Gb3JtYXROdW1iZXIsICc8bi1zbz86cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnZm9ybWF0QmFzZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uRm9ybWF0QmFzZSwgJzxuLW4/OnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ251bWJlcicsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uTnVtYmVyLCAnPChucyktOm4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2Zsb29yJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25GbG9vciwgJzxuLTpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdjZWlsJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25DZWlsLCAnPG4tOm4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3JvdW5kJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Sb3VuZCwgJzxuLW4/Om4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2FicycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQWJzLCAnPG4tOm4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3NxcnQnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblNxcnQsICc8bi06bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgncG93ZXInLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblBvd2VyLCAnPG4tbjpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdyYW5kb20nLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblJhbmRvbSwgJzw6bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnYm9vbGVhbicsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQm9vbGVhbiwgJzx4LTpiPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdub3QnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbk5vdCwgJzx4LTpiPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdtYXAnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbk1hcCwgJzxhZj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnemlwJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25aaXAsICc8YSs+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2ZpbHRlcicsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uRmlsdGVyLCAnPGFmPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdyZWR1Y2UnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkZvbGRMZWZ0LCAnPGFmaj86aj4nKSk7IC8vIFRPRE8gPGY8amo6aj5hPGo+aj86aj5cbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdzaWZ0JywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TaWZ0LCAnPG8tZj86bz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgna2V5cycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uS2V5cywgJzx4LTphPHM+PicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdsb29rdXAnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkxvb2t1cCwgJzx4LXM6eD4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnYXBwZW5kJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25BcHBlbmQsICc8eHg6YT4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnZXhpc3RzJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25FeGlzdHMsICc8eDpiPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdzcHJlYWQnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblNwcmVhZCwgJzx4LTphPG8+PicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdtZXJnZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uTWVyZ2UsICc8YTxvPjpvPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdyZXZlcnNlJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25SZXZlcnNlLCAnPGE6YT4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnZWFjaCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uRWFjaCwgJzxvLWY6YT4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc29ydCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uU29ydCwgJzxhZj86YT4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc2h1ZmZsZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uU2h1ZmZsZSwgJzxhOmE+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2Jhc2U2NGVuY29kZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQmFzZTY0ZW5jb2RlLCAnPHMtOnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2Jhc2U2NGRlY29kZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQmFzZTY0ZGVjb2RlLCAnPHMtOnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3RvTWlsbGlzJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Ub01pbGxpcywgJzxzLTpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdmcm9tTWlsbGlzJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Gcm9tTWlsbGlzLCAnPG4tOnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2Nsb25lJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25DbG9uZSwgJzwob2EpLTpvPicpKTtcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGVzXG4gICAgICpcbiAgICAgKi9cbiAgICB2YXIgZXJyb3JDb2RlcyA9IHtcbiAgICAgICAgXCJTMDEwMVwiOiBcIlN0cmluZyBsaXRlcmFsIG11c3QgYmUgdGVybWluYXRlZCBieSBhIG1hdGNoaW5nIHF1b3RlXCIsXG4gICAgICAgIFwiUzAxMDJcIjogXCJOdW1iZXIgb3V0IG9mIHJhbmdlOiB7e3Rva2VufX1cIixcbiAgICAgICAgXCJTMDEwM1wiOiBcIlVuc3VwcG9ydGVkIGVzY2FwZSBzZXF1ZW5jZTogXFxcXHt7dG9rZW59fVwiLFxuICAgICAgICBcIlMwMTA0XCI6IFwiVGhlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdSBtdXN0IGJlIGZvbGxvd2VkIGJ5IDQgaGV4IGRpZ2l0c1wiLFxuICAgICAgICBcIlMwMTA1XCI6IFwiUXVvdGVkIHByb3BlcnR5IG5hbWUgbXVzdCBiZSB0ZXJtaW5hdGVkIHdpdGggYSBiYWNrcXVvdGUgKGApXCIsXG4gICAgICAgIFwiUzAyMDFcIjogXCJTeW50YXggZXJyb3I6IHt7dG9rZW59fVwiLFxuICAgICAgICBcIlMwMjAyXCI6IFwiRXhwZWN0ZWQge3t2YWx1ZX19LCBnb3Qge3t0b2tlbn19XCIsXG4gICAgICAgIFwiUzAyMDNcIjogXCJFeHBlY3RlZCB7e3ZhbHVlfX0gYmVmb3JlIGVuZCBvZiBleHByZXNzaW9uXCIsXG4gICAgICAgIFwiUzAyMDRcIjogXCJVbmtub3duIG9wZXJhdG9yOiB7e3Rva2VufX1cIixcbiAgICAgICAgXCJTMDIwNVwiOiBcIlVuZXhwZWN0ZWQgdG9rZW46IHt7dG9rZW59fVwiLFxuICAgICAgICBcIlMwMjA2XCI6IFwiVW5rbm93biBleHByZXNzaW9uIHR5cGU6IHt7dG9rZW59fVwiLFxuICAgICAgICBcIlMwMjA3XCI6IFwiVW5leHBlY3RlZCBlbmQgb2YgZXhwcmVzc2lvblwiLFxuICAgICAgICBcIlMwMjA4XCI6IFwiUGFyYW1ldGVyIHt7dmFsdWV9fSBvZiBmdW5jdGlvbiBkZWZpbml0aW9uIG11c3QgYmUgYSB2YXJpYWJsZSBuYW1lIChzdGFydCB3aXRoICQpXCIsXG4gICAgICAgIFwiUzAyMDlcIjogXCJBIHByZWRpY2F0ZSBjYW5ub3QgZm9sbG93IGEgZ3JvdXBpbmcgZXhwcmVzc2lvbiBpbiBhIHN0ZXBcIixcbiAgICAgICAgXCJTMDIxMFwiOiBcIkVhY2ggc3RlcCBjYW4gb25seSBoYXZlIG9uZSBncm91cGluZyBleHByZXNzaW9uXCIsXG4gICAgICAgIFwiUzAyMTFcIjogXCJUaGUgc3ltYm9sIHt7dG9rZW59fSBjYW5ub3QgYmUgdXNlZCBhcyBhIHVuYXJ5IG9wZXJhdG9yXCIsXG4gICAgICAgIFwiUzAzMDFcIjogXCJFbXB0eSByZWd1bGFyIGV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZFwiLFxuICAgICAgICBcIlMwMzAyXCI6IFwiTm8gdGVybWluYXRpbmcgLyBpbiByZWd1bGFyIGV4cHJlc3Npb25cIixcbiAgICAgICAgXCJTMDQwMlwiOiBcIkNob2ljZSBncm91cHMgY29udGFpbmluZyBwYXJhbWV0ZXJpemVkIHR5cGVzIGFyZSBub3Qgc3VwcG9ydGVkXCIsXG4gICAgICAgIFwiUzA0MDFcIjogXCJUeXBlIHBhcmFtZXRlcnMgY2FuIG9ubHkgYmUgYXBwbGllZCB0byBmdW5jdGlvbnMgYW5kIGFycmF5c1wiLFxuICAgICAgICBcIlMwNTAwXCI6IFwiQXR0ZW1wdGVkIHRvIGV2YWx1YXRlIGFuIGV4cHJlc3Npb24gY29udGFpbmluZyBzeW50YXggZXJyb3IocylcIixcbiAgICAgICAgXCJUMDQxMFwiOiBcIkFyZ3VtZW50IHt7aW5kZXh9fSBvZiBmdW5jdGlvbiB7e3Rva2VufX0gZG9lcyBub3QgbWF0Y2ggZnVuY3Rpb24gc2lnbmF0dXJlXCIsXG4gICAgICAgIFwiVDA0MTFcIjogXCJDb250ZXh0IHZhbHVlIGlzIG5vdCBhIGNvbXBhdGlibGUgdHlwZSB3aXRoIGFyZ3VtZW50IHt7aW5kZXh9fSBvZiBmdW5jdGlvbiB7e3Rva2VufX1cIixcbiAgICAgICAgXCJUMDQxMlwiOiBcIkFyZ3VtZW50IHt7aW5kZXh9fSBvZiBmdW5jdGlvbiB7e3Rva2VufX0gbXVzdCBiZSBhbiBhcnJheSBvZiB7e3R5cGV9fVwiLFxuICAgICAgICBcIkQxMDAxXCI6IFwiTnVtYmVyIG91dCBvZiByYW5nZToge3t2YWx1ZX19XCIsXG4gICAgICAgIFwiRDEwMDJcIjogXCJDYW5ub3QgbmVnYXRlIGEgbm9uLW51bWVyaWMgdmFsdWU6IHt7dmFsdWV9fVwiLFxuICAgICAgICBcIlQxMDAzXCI6IFwiS2V5IGluIG9iamVjdCBzdHJ1Y3R1cmUgbXVzdCBldmFsdWF0ZSB0byBhIHN0cmluZzsgZ290OiB7e3ZhbHVlfX1cIixcbiAgICAgICAgXCJEMTAwNFwiOiBcIlJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaGVzIHplcm8gbGVuZ3RoIHN0cmluZ1wiLFxuICAgICAgICBcIlQxMDA1XCI6IFwiQXR0ZW1wdGVkIHRvIGludm9rZSBhIG5vbi1mdW5jdGlvbi4gRGlkIHlvdSBtZWFuICR7e3t0b2tlbn19fT9cIixcbiAgICAgICAgXCJUMTAwNlwiOiBcIkF0dGVtcHRlZCB0byBpbnZva2UgYSBub24tZnVuY3Rpb25cIixcbiAgICAgICAgXCJUMTAwN1wiOiBcIkF0dGVtcHRlZCB0byBwYXJ0aWFsbHkgYXBwbHkgYSBub24tZnVuY3Rpb24uIERpZCB5b3UgbWVhbiAke3t7dG9rZW59fX0/XCIsXG4gICAgICAgIFwiVDEwMDhcIjogXCJBdHRlbXB0ZWQgdG8gcGFydGlhbGx5IGFwcGx5IGEgbm9uLWZ1bmN0aW9uXCIsXG4gICAgICAgIFwiVDIwMDFcIjogXCJUaGUgbGVmdCBzaWRlIG9mIHRoZSB7e3Rva2VufX0gb3BlcmF0b3IgbXVzdCBldmFsdWF0ZSB0byBhIG51bWJlclwiLFxuICAgICAgICBcIlQyMDAyXCI6IFwiVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHt7dG9rZW59fSBvcGVyYXRvciBtdXN0IGV2YWx1YXRlIHRvIGEgbnVtYmVyXCIsXG4gICAgICAgIFwiVDIwMDNcIjogXCJUaGUgbGVmdCBzaWRlIG9mIHRoZSByYW5nZSBvcGVyYXRvciAoLi4pIG11c3QgZXZhbHVhdGUgdG8gYW4gaW50ZWdlclwiLFxuICAgICAgICBcIlQyMDA0XCI6IFwiVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHJhbmdlIG9wZXJhdG9yICguLikgbXVzdCBldmFsdWF0ZSB0byBhbiBpbnRlZ2VyXCIsXG4gICAgICAgIFwiRDIwMDVcIjogXCJUaGUgbGVmdCBzaWRlIG9mIDo9IG11c3QgYmUgYSB2YXJpYWJsZSBuYW1lIChzdGFydCB3aXRoICQpXCIsXG4gICAgICAgIFwiVDIwMDZcIjogXCJUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZnVuY3Rpb24gYXBwbGljYXRpb24gb3BlcmF0b3Igfj4gbXVzdCBiZSBhIGZ1bmN0aW9uXCIsXG4gICAgICAgIFwiVDIwMDdcIjogXCJUeXBlIG1pc21hdGNoIHdoZW4gY29tcGFyaW5nIHZhbHVlcyB7e3ZhbHVlfX0gYW5kIHt7dmFsdWUyfX0gaW4gb3JkZXItYnkgY2xhdXNlXCIsXG4gICAgICAgIFwiVDIwMDhcIjogXCJUaGUgZXhwcmVzc2lvbnMgd2l0aGluIGFuIG9yZGVyLWJ5IGNsYXVzZSBtdXN0IGV2YWx1YXRlIHRvIG51bWVyaWMgb3Igc3RyaW5nIHZhbHVlc1wiLFxuICAgICAgICBcIlQyMDA5XCI6IFwiVGhlIHZhbHVlcyB7e3ZhbHVlfX0gYW5kIHt7dmFsdWUyfX0gZWl0aGVyIHNpZGUgb2Ygb3BlcmF0b3Ige3t0b2tlbn19IG11c3QgYmUgb2YgdGhlIHNhbWUgZGF0YSB0eXBlXCIsXG4gICAgICAgIFwiVDIwMTBcIjogXCJUaGUgZXhwcmVzc2lvbnMgZWl0aGVyIHNpZGUgb2Ygb3BlcmF0b3Ige3t0b2tlbn19IG11c3QgZXZhbHVhdGUgdG8gbnVtZXJpYyBvciBzdHJpbmcgdmFsdWVzXCIsXG4gICAgICAgIFwiVDIwMTFcIjogXCJUaGUgaW5zZXJ0L3VwZGF0ZSBjbGF1c2Ugb2YgdGhlIHRyYW5zZm9ybSBleHByZXNzaW9uIG11c3QgZXZhbHVhdGUgdG8gYW4gb2JqZWN0OiB7e3ZhbHVlfX1cIixcbiAgICAgICAgXCJUMjAxMlwiOiBcIlRoZSBkZWxldGUgY2xhdXNlIG9mIHRoZSB0cmFuc2Zvcm0gZXhwcmVzc2lvbiBtdXN0IGV2YWx1YXRlIHRvIGEgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3M6IHt7dmFsdWV9fVwiLFxuICAgICAgICBcIlQyMDEzXCI6IFwiVGhlIHRyYW5zZm9ybSBleHByZXNzaW9uIGNsb25lcyB0aGUgaW5wdXQgb2JqZWN0IHVzaW5nIHRoZSAkY2xvbmUoKSBmdW5jdGlvbi4gIFRoaXMgaGFzIGJlZW4gb3ZlcnJpZGRlbiBpbiB0aGUgY3VycmVudCBzY29wZSBieSBhIG5vbi1mdW5jdGlvbi5cIixcbiAgICAgICAgXCJEMzAwMVwiOiBcIkF0dGVtcHRpbmcgdG8gaW52b2tlIHN0cmluZyBmdW5jdGlvbiBvbiBJbmZpbml0eSBvciBOYU5cIixcbiAgICAgICAgXCJEMzAxMFwiOiBcIlNlY29uZCBhcmd1bWVudCBvZiByZXBsYWNlIGZ1bmN0aW9uIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmdcIixcbiAgICAgICAgXCJEMzAxMVwiOiBcIkZvdXJ0aCBhcmd1bWVudCBvZiByZXBsYWNlIGZ1bmN0aW9uIG11c3QgZXZhbHVhdGUgdG8gYSBwb3NpdGl2ZSBudW1iZXJcIixcbiAgICAgICAgXCJEMzAxMlwiOiBcIkF0dGVtcHRlZCB0byByZXBsYWNlIGEgbWF0Y2hlZCBzdHJpbmcgd2l0aCBhIG5vbi1zdHJpbmcgdmFsdWVcIixcbiAgICAgICAgXCJEMzAyMFwiOiBcIlRoaXJkIGFyZ3VtZW50IG9mIHNwbGl0IGZ1bmN0aW9uIG11c3QgZXZhbHVhdGUgdG8gYSBwb3NpdGl2ZSBudW1iZXJcIixcbiAgICAgICAgXCJEMzAzMFwiOiBcIlVuYWJsZSB0byBjYXN0IHZhbHVlIHRvIGEgbnVtYmVyOiB7e3ZhbHVlfX1cIixcbiAgICAgICAgXCJEMzA0MFwiOiBcIlRoaXJkIGFyZ3VtZW50IG9mIG1hdGNoIGZ1bmN0aW9uIG11c3QgZXZhbHVhdGUgdG8gYSBwb3NpdGl2ZSBudW1iZXJcIixcbiAgICAgICAgXCJEMzA1MFwiOiBcIkZpcnN0IGFyZ3VtZW50IG9mIHJlZHVjZSBmdW5jdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24gd2l0aCB0d28gYXJndW1lbnRzXCIsXG4gICAgICAgIFwiRDMwNjBcIjogXCJUaGUgc3FydCBmdW5jdGlvbiBjYW5ub3QgYmUgYXBwbGllZCB0byBhIG5lZ2F0aXZlIG51bWJlcjoge3t2YWx1ZX19XCIsXG4gICAgICAgIFwiRDMwNjFcIjogXCJUaGUgcG93ZXIgZnVuY3Rpb24gaGFzIHJlc3VsdGVkIGluIGEgdmFsdWUgdGhhdCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXMgYSBKU09OIG51bWJlcjogYmFzZT17e3ZhbHVlfX0sIGV4cG9uZW50PXt7ZXhwfX1cIixcbiAgICAgICAgXCJEMzA3MFwiOiBcIlRoZSBzaW5nbGUgYXJndW1lbnQgZm9ybSBvZiB0aGUgc29ydCBmdW5jdGlvbiBjYW4gb25seSBiZSBhcHBsaWVkIHRvIGFuIGFycmF5IG9mIHN0cmluZ3Mgb3IgYW4gYXJyYXkgb2YgbnVtYmVycy4gIFVzZSB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIHNwZWNpZnkgYSBjb21wYXJpc29uIGZ1bmN0aW9uXCIsXG4gICAgICAgIFwiRDMwODBcIjogXCJUaGUgcGljdHVyZSBzdHJpbmcgbXVzdCBvbmx5IGNvbnRhaW4gYSBtYXhpbXVtIG9mIHR3byBzdWItcGljdHVyZXNcIixcbiAgICAgICAgXCJEMzA4MVwiOiBcIlRoZSBzdWItcGljdHVyZSBtdXN0IG5vdCBjb250YWluIG1vcmUgdGhhbiBvbmUgaW5zdGFuY2Ugb2YgdGhlICdkZWNpbWFsLXNlcGFyYXRvcicgY2hhcmFjdGVyXCIsXG4gICAgICAgIFwiRDMwODJcIjogXCJUaGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBtb3JlIHRoYW4gb25lIGluc3RhbmNlIG9mIHRoZSAncGVyY2VudCcgY2hhcmFjdGVyXCIsXG4gICAgICAgIFwiRDMwODNcIjogXCJUaGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBtb3JlIHRoYW4gb25lIGluc3RhbmNlIG9mIHRoZSAncGVyLW1pbGxlJyBjaGFyYWN0ZXJcIixcbiAgICAgICAgXCJEMzA4NFwiOiBcIlRoZSBzdWItcGljdHVyZSBtdXN0IG5vdCBjb250YWluIGJvdGggYSAncGVyY2VudCcgYW5kIGEgJ3Blci1taWxsZScgY2hhcmFjdGVyXCIsXG4gICAgICAgIFwiRDMwODVcIjogXCJUaGUgbWFudGlzc2EgcGFydCBvZiBhIHN1Yi1waWN0dXJlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIHRoYXQgaXMgZWl0aGVyIGFuICdvcHRpb25hbCBkaWdpdCBjaGFyYWN0ZXInIG9yIGEgbWVtYmVyIG9mIHRoZSAnZGVjaW1hbCBkaWdpdCBmYW1pbHknXCIsXG4gICAgICAgIFwiRDMwODZcIjogXCJUaGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBhIHBhc3NpdmUgY2hhcmFjdGVyIHRoYXQgaXMgcHJlY2VkZWQgYnkgYW4gYWN0aXZlIGNoYXJhY3RlciBhbmQgdGhhdCBpcyBmb2xsb3dlZCBieSBhbm90aGVyIGFjdGl2ZSBjaGFyYWN0ZXJcIixcbiAgICAgICAgXCJEMzA4N1wiOiBcIlRoZSBzdWItcGljdHVyZSBtdXN0IG5vdCBjb250YWluIGEgJ2dyb3VwaW5nLXNlcGFyYXRvcicgY2hhcmFjdGVyIHRoYXQgYXBwZWFycyBhZGphY2VudCB0byBhICdkZWNpbWFsLXNlcGFyYXRvcicgY2hhcmFjdGVyXCIsXG4gICAgICAgIFwiRDMwODhcIjogXCJUaGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBhICdncm91cGluZy1zZXBhcmF0b3InIGF0IHRoZSBlbmQgb2YgdGhlIGludGVnZXIgcGFydFwiLFxuICAgICAgICBcIkQzMDg5XCI6IFwiVGhlIHN1Yi1waWN0dXJlIG11c3Qgbm90IGNvbnRhaW4gdHdvIGFkamFjZW50IGluc3RhbmNlcyBvZiB0aGUgJ2dyb3VwaW5nLXNlcGFyYXRvcicgY2hhcmFjdGVyXCIsXG4gICAgICAgIFwiRDMwOTBcIjogXCJUaGUgaW50ZWdlciBwYXJ0IG9mIHRoZSBzdWItcGljdHVyZSBtdXN0IG5vdCBjb250YWluIGEgbWVtYmVyIG9mIHRoZSAnZGVjaW1hbCBkaWdpdCBmYW1pbHknIHRoYXQgaXMgZm9sbG93ZWQgYnkgYW4gaW5zdGFuY2Ugb2YgdGhlICdvcHRpb25hbCBkaWdpdCBjaGFyYWN0ZXInXCIsXG4gICAgICAgIFwiRDMwOTFcIjogXCJUaGUgZnJhY3Rpb25hbCBwYXJ0IG9mIHRoZSBzdWItcGljdHVyZSBtdXN0IG5vdCBjb250YWluIGFuIGluc3RhbmNlIG9mIHRoZSAnb3B0aW9uYWwgZGlnaXQgY2hhcmFjdGVyJyB0aGF0IGlzIGZvbGxvd2VkIGJ5IGEgbWVtYmVyIG9mIHRoZSAnZGVjaW1hbCBkaWdpdCBmYW1pbHknXCIsXG4gICAgICAgIFwiRDMwOTJcIjogXCJBIHN1Yi1waWN0dXJlIHRoYXQgY29udGFpbnMgYSAncGVyY2VudCcgb3IgJ3Blci1taWxsZScgY2hhcmFjdGVyIG11c3Qgbm90IGNvbnRhaW4gYSBjaGFyYWN0ZXIgdHJlYXRlZCBhcyBhbiAnZXhwb25lbnQtc2VwYXJhdG9yJ1wiLFxuICAgICAgICBcIkQzMDkzXCI6IFwiVGhlIGV4cG9uZW50IHBhcnQgb2YgdGhlIHN1Yi1waWN0dXJlIG11c3QgY29tcHJpc2Ugb25seSBvZiBvbmUgb3IgbW9yZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIG1lbWJlcnMgb2YgdGhlICdkZWNpbWFsIGRpZ2l0IGZhbWlseSdcIixcbiAgICAgICAgXCJEMzEwMFwiOiBcIlRoZSByYWRpeCBvZiB0aGUgZm9ybWF0QmFzZSBmdW5jdGlvbiBtdXN0IGJlIGJldHdlZW4gMiBhbmQgMzYuICBJdCB3YXMgZ2l2ZW4ge3t2YWx1ZX19XCIsXG4gICAgICAgIFwiRDMxMTBcIjogXCJUaGUgYXJndW1lbnQgb2YgdGhlIHRvTWlsbGlzIGZ1bmN0aW9uIG11c3QgYmUgYW4gSVNPIDg2MDEgZm9ybWF0dGVkIHRpbWVzdGFtcC4gR2l2ZW4ge3t2YWx1ZX19XCJcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogbG9va3VwIGEgbWVzc2FnZSB0ZW1wbGF0ZSBmcm9tIHRoZSBjYXRhbG9nIGFuZCBzdWJzdGl0dXRlIHRoZSBpbnNlcnRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVyciAtIGVycm9yIGNvZGUgdG8gbG9va3VwXG4gICAgICogQHJldHVybnMge3N0cmluZ30gbWVzc2FnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvb2t1cE1lc3NhZ2UoZXJyKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJ1Vua25vd24gZXJyb3InO1xuICAgICAgICBpZih0eXBlb2YgZXJyLm1lc3NhZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRlbXBsYXRlID0gZXJyb3JDb2Rlc1tlcnIuY29kZV07XG4gICAgICAgIGlmKHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBhbnkgaGFuZGxlYmFycywgcmVwbGFjZSB0aGVtIHdpdGggdGhlIGZpZWxkIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIC8vIHRyaXBsZSBicmFjZXMgLSByZXBsYWNlIHdpdGggdmFsdWVcbiAgICAgICAgICAgIC8vIGRvdWJsZSBicmFjZXMgLSByZXBsYWNlIHdpdGgganNvbiBzdHJpbmdpZmllZCB2YWx1ZVxuICAgICAgICAgICAgbWVzc2FnZSA9IHRlbXBsYXRlLnJlcGxhY2UoL1xce1xce1xceyhbXn1dKyl9fX0vZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyclthcmd1bWVudHNbMV1dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKC9cXHtcXHsoW159XSspfX0vZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGVyclthcmd1bWVudHNbMV1dKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEpTT05hdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucyAtIHJlY292ZXI6IGF0dGVtcHQgdG8gcmVjb3ZlciBvbiBwYXJzZSBlcnJvclxuICAgICAqIEByZXR1cm5zIHt7ZXZhbHVhdGU6IGV2YWx1YXRlLCBhc3NpZ246IGFzc2lnbn19IEV2YWx1YXRlZCBleHByZXNzaW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24ganNvbmF0YShleHByLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBhc3Q7XG4gICAgICAgIHZhciBlcnJvcnM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhc3QgPSBwYXJzZXIoZXhwciwgb3B0aW9ucyAmJiBvcHRpb25zLnJlY292ZXIpO1xuICAgICAgICAgICAgZXJyb3JzID0gYXN0LmVycm9ycztcbiAgICAgICAgICAgIGRlbGV0ZSBhc3QuZXJyb3JzO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGVycm9yIG1lc3NhZ2UgaW50byBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID0gbG9va3VwTWVzc2FnZShlcnIpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbnZpcm9ubWVudCA9IGNyZWF0ZUZyYW1lKHN0YXRpY0ZyYW1lKTtcblxuICAgICAgICB2YXIgdGltZXN0YW1wID0gbmV3IERhdGUoKTsgLy8gd2lsbCBiZSBvdmVycmlkZGVuIG9uIGVhY2ggY2FsbCB0byBldmFsdXRlKClcbiAgICAgICAgZW52aXJvbm1lbnQuYmluZCgnbm93JywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGltZXN0YW1wLnRvSlNPTigpO1xuICAgICAgICB9LCAnPDpzPicpKTtcbiAgICAgICAgZW52aXJvbm1lbnQuYmluZCgnbWlsbGlzJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGltZXN0YW1wLmdldFRpbWUoKTtcbiAgICAgICAgfSwgJzw6bj4nKSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiAoaW5wdXQsIGJpbmRpbmdzLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIHRocm93IGlmIHRoZSBleHByZXNzaW9uIGNvbXBpbGVkIHdpdGggc3ludGF4IGVycm9yc1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBlcnJvcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiAnUzA1MDAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBsb29rdXBNZXNzYWdlKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJpbmRpbmdzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhlY19lbnY7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB2YXJpYWJsZSBiaW5kaW5ncyBoYXZlIGJlZW4gcGFzc2VkIGluIC0gY3JlYXRlIGEgZnJhbWUgdG8gaG9sZCB0aGVzZVxuICAgICAgICAgICAgICAgICAgICBleGVjX2VudiA9IGNyZWF0ZUZyYW1lKGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdiBpbiBiaW5kaW5ncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY19lbnYuYmluZCh2LCBiaW5kaW5nc1t2XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleGVjX2VudiA9IGVudmlyb25tZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBwdXQgdGhlIGlucHV0IGRvY3VtZW50IGludG8gdGhlIGVudmlyb25tZW50IGFzIHRoZSByb290IG9iamVjdFxuICAgICAgICAgICAgICAgIGV4ZWNfZW52LmJpbmQoJyQnLCBpbnB1dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBjYXB0dXJlIHRoZSB0aW1lc3RhbXAgYW5kIHB1dCBpdCBpbiB0aGUgZXhlY3V0aW9uIGVudmlyb25tZW50XG4gICAgICAgICAgICAgICAgLy8gdGhlICRub3coKSBhbmQgJG1pbGxpcygpIGZ1bmN0aW9ucyB3aWxsIHJldHVybiB0aGlzIHZhbHVlIC0gd2hlbmV2ZXIgaXQgaXMgY2FsbGVkXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gbmV3IERhdGUoKTtcblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQsIGl0O1xuICAgICAgICAgICAgICAgIC8vIGlmIGEgY2FsbGJhY2sgZnVuY3Rpb24gaXMgc3VwcGxpZWQsIHRoZW4gZHJpdmUgdGhlIGdlbmVyYXRvciBpbiBhIHByb21pc2UgY2hhaW5cbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhlY19lbnYuYmluZCgnX19qc29uYXRhX2FzeW5jJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGVuSGFuZGxlciA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gaXQubmV4dChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUudGhlbih0aGVuSGFuZGxlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gbG9va3VwTWVzc2FnZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGl0ID0gZXZhbHVhdGUoYXN0LCBpbnB1dCwgZXhlY19lbnYpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBpdC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZS50aGVuKHRoZW5IYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBjYWxsYmFjayBmdW5jdGlvbiAtIGRyaXZlIHRoZSBnZW5lcmF0b3IgdG8gY29tcGxldGlvbiBzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdCA9IGV2YWx1YXRlKGFzdCwgaW5wdXQsIGV4ZWNfZW52KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBpdC5uZXh0KHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2VydCBlcnJvciBtZXNzYWdlIGludG8gc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGxvb2t1cE1lc3NhZ2UoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3NpZ246IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGVudmlyb25tZW50LmJpbmQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZ2lzdGVyRnVuY3Rpb246IGZ1bmN0aW9uKG5hbWUsIGltcGxlbWVudGF0aW9uLCBzaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnVuYyA9IGRlZmluZUZ1bmN0aW9uKGltcGxlbWVudGF0aW9uLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgIGVudmlyb25tZW50LmJpbmQobmFtZSwgZnVuYyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBqc29uYXRhLnBhcnNlciA9IHBhcnNlcjsgLy8gVE9ETyByZW1vdmUgdGhpcyBpbiBhIGZ1dHVyZSByZWxlYXNlIC0gdXNlIGFzdCgpIGluc3RlYWRcblxuICAgIHJldHVybiBqc29uYXRhO1xuXG59KSgpO1xuXG4vLyBub2RlLmpzIG9ubHkgLSBleHBvcnQgdGhlIGpzb25hdGEgYW5kIHBhcnNlciBmdW5jdGlvbnNcbi8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlXG5pZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ganNvbmF0YTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGxvZ2xldmVsID0gcmVxdWlyZSgnbG9nbGV2ZWwnKTtcbnZhciBjaGFsayA9IHJlcXVpcmUoJ2NoYWxrJyk7XG5cbnZhciBsb2dnZXJzID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TG9nZ2VyO1xuXG5mdW5jdGlvbiBnZXRMb2dnZXIoKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIF9yZWYkbGV2ZWwgPSBfcmVmLmxldmVsLFxuICAgICAgbGV2ZWwgPSBfcmVmJGxldmVsID09PSB1bmRlZmluZWQgPyBnZXREZWZhdWx0TGV2ZWwoKSA6IF9yZWYkbGV2ZWwsXG4gICAgICBfcmVmJHByZWZpeCA9IF9yZWYucHJlZml4LFxuICAgICAgcHJlZml4ID0gX3JlZiRwcmVmaXggPT09IHVuZGVmaW5lZCA/ICcnIDogX3JlZiRwcmVmaXg7XG5cbiAgaWYgKGxvZ2dlcnNbcHJlZml4XSkge1xuICAgIHJldHVybiBsb2dnZXJzW3ByZWZpeF07XG4gIH1cbiAgdmFyIGNvbG9yZWRQcmVmaXggPSBwcmVmaXggPyBgJHtjaGFsay5kaW0ocHJlZml4KX0gYCA6ICcnO1xuICB2YXIgbGV2ZWxQcmVmaXggPSB7XG4gICAgVFJBQ0U6IGNoYWxrLmRpbSgnW1RSQUNFXScpLFxuICAgIERFQlVHOiBjaGFsay5jeWFuKCdbREVCVUddJyksXG4gICAgSU5GTzogY2hhbGsuYmx1ZSgnW0lORk9dJyksXG4gICAgV0FSTjogY2hhbGsueWVsbG93KCdbV0FSTl0nKSxcbiAgICBFUlJPUjogY2hhbGsucmVkKCdbRVJST1JdJylcbiAgfTtcblxuICB2YXIgbG9nZ2VyID0gbG9nbGV2ZWwuZ2V0TG9nZ2VyKGAke3ByZWZpeH0tbG9nZ2VyYCk7XG5cbiAgLy8gdGhpcyBpcyB0aGUgcGx1Z2luIFwiYXBpXCJcbiAgdmFyIG9yaWdpbmFsRmFjdG9yeSA9IGxvZ2dlci5tZXRob2RGYWN0b3J5O1xuICBsb2dnZXIubWV0aG9kRmFjdG9yeSA9IG1ldGhvZEZhY3Rvcnk7XG5cbiAgdmFyIG9yaWdpbmFsU2V0TGV2ZWwgPSBsb2dnZXIuc2V0TGV2ZWw7XG4gIGxvZ2dlci5zZXRMZXZlbCA9IHNldExldmVsO1xuICBsb2dnZXIuc2V0TGV2ZWwobGV2ZWwpO1xuICBsb2dnZXJzW3ByZWZpeF0gPSBsb2dnZXI7XG4gIHJldHVybiBsb2dnZXI7XG5cbiAgZnVuY3Rpb24gbWV0aG9kRmFjdG9yeSgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZmFjdG9yeUFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGZhY3RvcnlBcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBsb2dMZXZlbCA9IGZhY3RvcnlBcmdzWzBdO1xuXG4gICAgdmFyIHJhd01ldGhvZCA9IG9yaWdpbmFsRmFjdG9yeS5hcHBseSh1bmRlZmluZWQsIGZhY3RvcnlBcmdzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmF3TWV0aG9kLmFwcGx5KHVuZGVmaW5lZCwgW2Ake2NvbG9yZWRQcmVmaXh9JHtsZXZlbFByZWZpeFtsb2dMZXZlbC50b1VwcGVyQ2FzZSgpXX06YF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0TGV2ZWwobGV2ZWxUb1NldFRvKSB7XG4gICAgdmFyIHBlcnNpc3QgPSBmYWxzZTsgLy8gdXNlcyBicm93c2VyIGxvY2FsU3RvcmFnZVxuICAgIHJldHVybiBvcmlnaW5hbFNldExldmVsLmNhbGwobG9nZ2VyLCBsZXZlbFRvU2V0VG8sIHBlcnNpc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRMZXZlbCgpIHtcbiAgdmFyIGxvZ0xldmVsID0gcHJvY2Vzcy5lbnYuTE9HX0xFVkVMO1xuXG4gIGlmIChsb2dMZXZlbCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWxvZ0xldmVsKSB7XG4gICAgcmV0dXJuICd3YXJuJztcbiAgfVxuICByZXR1cm4gbG9nTGV2ZWw7XG59IiwiLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgICAgIFwidHJhY2VcIixcbiAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICBcImluZm9cIixcbiAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgIF07XG5cbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsIG1ldGhvZE5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlc2UgcHJpdmF0ZSBmdW5jdGlvbnMgYWx3YXlzIG5lZWQgYHRoaXNgIHRvIGJlIHNldCBwcm9wZXJseVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xuICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IChpIDwgbGV2ZWwpID9cbiAgICAgICAgICAgICAgICBub29wIDpcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1Z1xuICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XG4gICAgfVxuXG4gICAgLy8gSW4gb2xkIElFIHZlcnNpb25zLCB0aGUgY29uc29sZSBpc24ndCBwcmVzZW50IHVudGlsIHlvdSBmaXJzdCBvcGVuIGl0LlxuICAgIC8vIFdlIGJ1aWxkIHJlYWxNZXRob2QoKSByZXBsYWNlbWVudHMgaGVyZSB0aGF0IHJlZ2VuZXJhdGUgbG9nZ2luZyBtZXRob2RzXG4gICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcywgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB3ZSB1c2UgY2xvc2VseSBib3VuZCByZWFsIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUsIGFuZFxuICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAgZnVuY3Rpb24gZGVmYXVsdE1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHxcbiAgICAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2dnZXIobmFtZSwgZGVmYXVsdExldmVsLCBmYWN0b3J5KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY3VycmVudExldmVsO1xuICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBcImxvZ2xldmVsXCI7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhjb29raWUuc2xpY2UobG9jYXRpb24pKVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqXG4gICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgc2VsZi5uYW1lID0gbmFtZTtcblxuICAgICAgc2VsZi5sZXZlbHMgPSB7IFwiVFJBQ0VcIjogMCwgXCJERUJVR1wiOiAxLCBcIklORk9cIjogMiwgXCJXQVJOXCI6IDMsXG4gICAgICAgICAgXCJFUlJPUlwiOiA0LCBcIlNJTEVOVFwiOiA1fTtcblxuICAgICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZmFjdG9yeSB8fCBkZWZhdWx0TWV0aG9kRmFjdG9yeTtcblxuICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudExldmVsO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCwgcGVyc2lzdCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwic3RyaW5nXCIgJiYgc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgICBpZiAocGVyc2lzdCAhPT0gZmFsc2UpIHsgIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYsIGxldmVsLCBuYW1lKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlICYmIGxldmVsIDwgc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGxldmVsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgaWYgKCFnZXRQZXJzaXN0ZWRMZXZlbCgpKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbml0aWFsaXplIHdpdGggdGhlIHJpZ2h0IGxldmVsXG4gICAgICB2YXIgaW5pdGlhbExldmVsID0gZ2V0UGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgIGlmIChpbml0aWFsTGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgIGluaXRpYWxMZXZlbCA9IGRlZmF1bHRMZXZlbCA9PSBudWxsID8gXCJXQVJOXCIgOiBkZWZhdWx0TGV2ZWw7XG4gICAgICB9XG4gICAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICpcbiAgICAgKiBUb3AtbGV2ZWwgQVBJXG4gICAgICpcbiAgICAgKi9cblxuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG4gICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIgfHwgbmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdO1xuICAgICAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgICAgIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdID0gbmV3IExvZ2dlcihcbiAgICAgICAgICAgIG5hbWUsIGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSwgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIH07XG5cbiAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XG4gICAgZGVmYXVsdExvZ2dlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmXG4gICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBkZWZhdWx0TG9nZ2VyKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9nID0gX2xvZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xuICAgIH07XG5cbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlcnMgPSBmdW5jdGlvbiBnZXRMb2dnZXJzKCkge1xuICAgICAgICByZXR1cm4gX2xvZ2dlcnNCeU5hbWU7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xufSkpO1xuIiwidmFyIHBlcmZvcm1hbmNlID0gZ2xvYmFsLnBlcmZvcm1hbmNlIHx8IHt9O1xuXG52YXIgcHJlc2VudCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBuYW1lcyA9IFsnbm93JywgJ3dlYmtpdE5vdycsICdtc05vdycsICdtb3pOb3cnLCAnb05vdyddO1xuICB3aGlsZSAobmFtZXMubGVuZ3RoKSB7XG4gICAgdmFyIG5hbWUgPSBuYW1lcy5zaGlmdCgpO1xuICAgIGlmIChuYW1lIGluIHBlcmZvcm1hbmNlKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2VbbmFtZV0uYmluZChwZXJmb3JtYW5jZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRhdGVOb3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfTtcbiAgdmFyIG5hdmlnYXRpb25TdGFydCA9IChwZXJmb3JtYW5jZS50aW1pbmcgfHwge30pLm5hdmlnYXRpb25TdGFydCB8fCBkYXRlTm93KCk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRhdGVOb3coKSAtIG5hdmlnYXRpb25TdGFydDtcbiAgfTtcbn0oKSk7XG5cbnByZXNlbnQucGVyZm9ybWFuY2VOb3cgPSBwZXJmb3JtYW5jZS5ub3c7XG5wcmVzZW50Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHBlcmZvcm1hbmNlLm5vdyA9IHByZXNlbnQucGVyZm9ybWFuY2VOb3c7XG59O1xucHJlc2VudC5jb25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgcGVyZm9ybWFuY2Uubm93ID0gcHJlc2VudDtcbn07XG5wcmVzZW50LmNvbmZsaWN0KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcHJlc2VudDtcbiIsIi8vIEV4cG9ydCAuL2xpYi9yYW5kZ2VuXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL3JhbmRnZW5cIik7XG4iLCIvKmpzbGludCBpbmRlbnQ6IDIsIHBsdXNwbHVzOiB0cnVlLCBzbG9wcHk6IHRydWUgKi9cbi8vIEdlbmVyYXRlIHVuaWZvcm1seSBkaXN0cmlidXRlZCByYW5kb20gbnVtYmVyc1xuLy8gR2l2ZXMgYSByYW5kb20gbnVtYmVyIG9uIHRoZSBpbnRlcnZhbCBbbWluLCBtYXgpLlxuLy8gSWYgZGlzY3JldGUgaXMgdHJ1ZSwgdGhlIG51bWJlciB3aWxsIGJlIGFuIGludGVnZXIuXG5mdW5jdGlvbiBydW5pZihtaW4sIG1heCwgZGlzY3JldGUpIHtcbiAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWluID0gMDtcbiAgfVxuICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXggPSAxO1xuICB9XG4gIGlmIChkaXNjcmV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGlzY3JldGUgPSBmYWxzZTtcbiAgfVxuICBpZiAoZGlzY3JldGUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihydW5pZihtaW4sIG1heCwgZmFsc2UpKTtcbiAgfVxuICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xufVxuXG4vLyBHZW5lcmF0ZSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gbnVibWVyc1xuLy8gQWxnb3JpdGhtIGFkYXB0ZWQgZnJvbTpcbi8vIGh0dHA6Ly9jLWZhcS5jb20vbGliL2dhdXNzaWFuLmh0bWxcbmZ1bmN0aW9uIHJub3JtKG1lYW4sIHN0ZGV2KSB7XG4gIHZhciB1MSwgdTIsIHYxLCB2MiwgcztcbiAgaWYgKG1lYW4gPT09IHVuZGVmaW5lZCkge1xuICAgIG1lYW4gPSAwLjA7XG4gIH1cbiAgaWYgKHN0ZGV2ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGRldiA9IDEuMDtcbiAgfVxuICBpZiAocm5vcm0udjIgPT09IG51bGwpIHtcbiAgICBkbyB7XG4gICAgICB1MSA9IE1hdGgucmFuZG9tKCk7XG4gICAgICB1MiA9IE1hdGgucmFuZG9tKCk7XG5cbiAgICAgIHYxID0gMiAqIHUxIC0gMTtcbiAgICAgIHYyID0gMiAqIHUyIC0gMTtcbiAgICAgIHMgPSB2MSAqIHYxICsgdjIgKiB2MjtcbiAgICB9IHdoaWxlIChzID09PSAwIHx8IHMgPj0gMSk7XG5cbiAgICBybm9ybS52MiA9IHYyICogTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocykgLyBzKTtcbiAgICByZXR1cm4gc3RkZXYgKiB2MSAqIE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHMpIC8gcykgKyBtZWFuO1xuICB9XG5cbiAgdjIgPSBybm9ybS52MjtcbiAgcm5vcm0udjIgPSBudWxsO1xuICByZXR1cm4gc3RkZXYgKiB2MiArIG1lYW47XG59XG5cbnJub3JtLnYyID0gbnVsbDtcblxuLy8gR2VuZXJhdGUgQ2hpLXNxdWFyZSBkaXN0cmlidXRlZCByYW5kb20gbnVtYmVyc1xuZnVuY3Rpb24gcmNoaXNxKGRlZ3JlZXNPZkZyZWVkb20pIHtcbiAgaWYgKGRlZ3JlZXNPZkZyZWVkb20gPT09IHVuZGVmaW5lZCkge1xuICAgIGRlZ3JlZXNPZkZyZWVkb20gPSAxO1xuICB9XG4gIHZhciBpLCB6LCBzdW0gPSAwLjA7XG4gIGZvciAoaSA9IDA7IGkgPCBkZWdyZWVzT2ZGcmVlZG9tOyBpKyspIHtcbiAgICB6ID0gcm5vcm0oKTtcbiAgICBzdW0gKz0geiAqIHo7XG4gIH1cblxuICByZXR1cm4gc3VtO1xufVxuXG4vLyBHZW5lcmF0ZSBQb2lzc29uIGRpc3RyaWJ1dGVkIHJhbmRvbSBudW1iZXJzXG5mdW5jdGlvbiBycG9pc3NvbihsYW1iZGEpIHtcbiAgaWYgKGxhbWJkYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGFtYmRhID0gMTtcbiAgfVxuICB2YXIgbCA9IE1hdGguZXhwKC1sYW1iZGEpLFxuICAgIGsgPSAwLFxuICAgIHAgPSAxLjA7XG4gIGRvIHtcbiAgICBrKys7XG4gICAgcCAqPSBNYXRoLnJhbmRvbSgpO1xuICB9IHdoaWxlIChwID4gbCk7XG5cbiAgcmV0dXJuIGsgLSAxO1xufVxuXG4vLyBHZW5lcmF0ZSBDYXVjaHkgZGlzdHJpYnV0ZWQgcmFuZG9tIG51bWJlcnNcbmZ1bmN0aW9uIHJjYXVjaHkobG9jLCBzY2FsZSkge1xuICBpZiAobG9jID09PSB1bmRlZmluZWQpIHtcbiAgICBsb2MgPSAwLjA7XG4gIH1cbiAgaWYgKHNjYWxlID09PSB1bmRlZmluZWQpIHtcbiAgICBzY2FsZSA9IDEuMDtcbiAgfVxuICB2YXIgbjIsIG4xID0gcm5vcm0oKTtcbiAgZG8ge1xuICAgIG4yID0gcm5vcm0oKTtcbiAgfSB3aGlsZSAobjIgPT09IDAuMCk7XG5cbiAgcmV0dXJuIGxvYyArIHNjYWxlICogbjEgLyBuMjtcbn1cblxuLy8gQmVybm91bGxpIGRpc3RyaWJ1dGlvbjogZ2l2ZXMgMSB3aXRoIHByb2JhYmlsaXR5IHBcbmZ1bmN0aW9uIHJiZXJub3VsbGkocCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKSA8IHAgPyAxIDogMDtcbn1cblxuLy8gVmVjdG9yaXplIGEgcmFuZG9tIGdlbmVyYXRvclxuZnVuY3Rpb24gdmVjdG9yaXplKGdlbmVyYXRvcikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuLCByZXN1bHQsIGksIGFyZ3M7XG4gICAgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgIG4gPSBhcmdzLnNoaWZ0KCk7XG4gICAgcmVzdWx0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLy8gR2VuZXJhdGUgYSBoaXN0b2dyYW0gZnJvbSBhIGxpc3Qgb2YgbnVtYmVyc1xuZnVuY3Rpb24gaGlzdG9ncmFtKGRhdGEsIGJpbkNvdW50KSB7XG4gIGJpbkNvdW50ID0gYmluQ291bnQgfHwgMTA7XG5cbiAgdmFyIGJpbnMsIGksIHNjYWxlZCxcbiAgICBtYXggPSBNYXRoLm1heC5hcHBseSh0aGlzLCBkYXRhKSxcbiAgICBtaW4gPSBNYXRoLm1pbi5hcHBseSh0aGlzLCBkYXRhKTtcblxuICAvLyBlZGdlIGNhc2U6IG1heCA9PSBtaW5cbiAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgcmV0dXJuIFtkYXRhLmxlbmd0aF07XG4gIH1cblxuICBiaW5zID0gW107XG5cbiAgLy8gemVybyBlYWNoIGJpblxuICBmb3IgKGkgPSAwOyBpIDwgYmluQ291bnQ7IGkrKykge1xuICAgIGJpbnMucHVzaCgwKTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gc2NhbGUgaXQgdG8gYmUgYmV0d2VlbiAwIGFuZCAxXG4gICAgc2NhbGVkID0gKGRhdGFbaV0gLSBtaW4pIC8gKG1heCAtIG1pbik7XG5cbiAgICAvLyBzY2FsZSBpdCB1cCB0byB0aGUgaGlzdG9ncmFtIHNpemVcbiAgICBzY2FsZWQgKj0gYmluQ291bnQ7XG5cbiAgICAvLyBkcm9wIGl0IGluIGEgYmluXG4gICAgc2NhbGVkID0gTWF0aC5mbG9vcihzY2FsZWQpO1xuXG4gICAgLy8gZWRnZSBjYXNlOiB0aGUgbWF4XG4gICAgaWYgKHNjYWxlZCA9PT0gYmluQ291bnQpIHsgc2NhbGVkLS07IH1cblxuICAgIGJpbnNbc2NhbGVkXSsrO1xuICB9XG5cbiAgcmV0dXJuIGJpbnM7XG59XG5cbi8qKlxuICogR2V0IGEgcmFuZG9tIGVsZW1lbnQgZnJvbSBhIGxpc3RcbiAqL1xuZnVuY3Rpb24gcmxpc3QobGlzdCkge1xuICByZXR1cm4gbGlzdFtydW5pZigwLCBsaXN0Lmxlbmd0aCwgdHJ1ZSldO1xufVxuXG5leHBvcnRzLnJ1bmlmID0gcnVuaWY7XG5leHBvcnRzLnJub3JtID0gcm5vcm07XG5leHBvcnRzLnJjaGlzcSA9IHJjaGlzcTtcbmV4cG9ydHMucnBvaXNzb24gPSBycG9pc3NvbjtcbmV4cG9ydHMucmNhdWNoeSA9IHJjYXVjaHk7XG5leHBvcnRzLnJiZXJub3VsbGkgPSByYmVybm91bGxpO1xuZXhwb3J0cy5ybGlzdCA9IHJsaXN0O1xuXG5leHBvcnRzLnJ2dW5pZiA9IHZlY3Rvcml6ZShydW5pZik7XG5leHBvcnRzLnJ2bm9ybSA9IHZlY3Rvcml6ZShybm9ybSk7XG5leHBvcnRzLnJ2Y2hpc3EgPSB2ZWN0b3JpemUocmNoaXNxKTtcbmV4cG9ydHMucnZwb2lzc29uID0gdmVjdG9yaXplKHJwb2lzc29uKTtcbmV4cG9ydHMucnZjYXVjaHkgPSB2ZWN0b3JpemUocmNhdWNoeSk7XG5leHBvcnRzLnJ2YmVybm91bGxpID0gdmVjdG9yaXplKHJiZXJub3VsbGkpO1xuZXhwb3J0cy5ydmxpc3QgPSB2ZWN0b3JpemUocmxpc3QpO1xuXG5leHBvcnRzLmhpc3RvZ3JhbSA9IGhpc3RvZ3JhbTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4JykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ci5yZXBsYWNlKGFuc2lSZWdleCwgJycpIDogc3RyO1xufTtcbiIsIi8qIGpzaGludCBub2RlOiB0cnVlICovXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIG1ha2VBcnJheUZyb20ob2JqKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkob2JqKTtcbn1cbnZhclxuICBQRU5ESU5HID0gXCJwZW5kaW5nXCIsXG4gIFJFU09MVkVEID0gXCJyZXNvbHZlZFwiLFxuICBSRUpFQ1RFRCA9IFwicmVqZWN0ZWRcIjtcblxuZnVuY3Rpb24gU3luY2hyb25vdXNQcm9taXNlKGhhbmRsZXIpIHtcbiAgdGhpcy5zdGF0dXMgPSBQRU5ESU5HO1xuICB0aGlzLl9jb250aW51YXRpb25zID0gW107XG4gIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICBpZiAoaGFuZGxlcikge1xuICAgIGhhbmRsZXIuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICB0aGlzLl9jb250aW51ZVdpdGguYmluZCh0aGlzKSxcbiAgICAgIHRoaXMuX2ZhaWxXaXRoLmJpbmQodGhpcylcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxvb2tzTGlrZUFQcm9taXNlKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiAob2JqLnRoZW4pID09PSBcImZ1bmN0aW9uXCI7XG59XG5cblN5bmNocm9ub3VzUHJvbWlzZS5wcm90b3R5cGUgPSB7XG4gIHRoZW46IGZ1bmN0aW9uIChuZXh0Rm4sIGNhdGNoRm4pIHtcbiAgICB2YXIgbmV4dCA9IFN5bmNocm9ub3VzUHJvbWlzZS51bnJlc29sdmVkKCkuX3NldFBhcmVudCh0aGlzKTtcbiAgICBpZiAodGhpcy5faXNSZWplY3RlZCgpKSB7XG4gICAgICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICAgIHRoaXMuX2NvbnRpbnVhdGlvbnMucHVzaCh7XG4gICAgICAgICAgcHJvbWlzZTogbmV4dCxcbiAgICAgICAgICBuZXh0Rm46IG5leHRGbixcbiAgICAgICAgICBjYXRjaEZuOiBjYXRjaEZuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChjYXRjaEZuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGNhdGNoUmVzdWx0ID0gY2F0Y2hGbih0aGlzLl9lcnJvcik7XG4gICAgICAgICAgaWYgKGxvb2tzTGlrZUFQcm9taXNlKGNhdGNoUmVzdWx0KSkge1xuICAgICAgICAgICAgdGhpcy5fY2hhaW5Qcm9taXNlRGF0YShjYXRjaFJlc3VsdCwgbmV4dCk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKGNhdGNoUmVzdWx0KS5fc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVqZWN0KGUpLl9zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVqZWN0KHRoaXMuX2Vycm9yKS5fc2V0UGFyZW50KHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9jb250aW51YXRpb25zLnB1c2goe1xuICAgICAgcHJvbWlzZTogbmV4dCxcbiAgICAgIG5leHRGbjogbmV4dEZuLFxuICAgICAgY2F0Y2hGbjogY2F0Y2hGblxuICAgIH0pO1xuICAgIHRoaXMuX3J1blJlc29sdXRpb25zKCk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH0sXG4gIGNhdGNoOiBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHtcbiAgICAgIHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZSh0aGlzLl9kYXRhKS5fc2V0UGFyZW50KHRoaXMpO1xuICAgIH1cbiAgICB2YXIgbmV4dCA9IFN5bmNocm9ub3VzUHJvbWlzZS51bnJlc29sdmVkKCkuX3NldFBhcmVudCh0aGlzKTtcbiAgICB0aGlzLl9jb250aW51YXRpb25zLnB1c2goe1xuICAgICAgcHJvbWlzZTogbmV4dCxcbiAgICAgIGNhdGNoRm46IGhhbmRsZXJcbiAgICB9KTtcbiAgICB0aGlzLl9ydW5SZWplY3Rpb25zKCk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH0sXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZpcnN0UGF1c2VkID0gdGhpcy5fZmluZEZpcnN0UGF1c2VkKCk7XG4gICAgaWYgKGZpcnN0UGF1c2VkKSB7XG4gICAgICBmaXJzdFBhdXNlZC5fcGF1c2VkID0gZmFsc2U7XG4gICAgICBmaXJzdFBhdXNlZC5fcnVuUmVzb2x1dGlvbnMoKTtcbiAgICAgIGZpcnN0UGF1c2VkLl9ydW5SZWplY3Rpb25zKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfZmluZEFuY2VzdHJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRpbnVhdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cikge1xuICAgICAgaWYgKGN1ci5wcm9taXNlKSB7XG4gICAgICAgIHZhciBub2RlID0ge1xuICAgICAgICAgIHByb21pc2U6IGN1ci5wcm9taXNlLFxuICAgICAgICAgIGNoaWxkcmVuOiBjdXIucHJvbWlzZS5fZmluZEFuY2VzdHJ5KClcbiAgICAgICAgfTtcbiAgICAgICAgYWNjLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgfSxcbiAgX3NldFBhcmVudDogZnVuY3Rpb24gKHBhcmVudCkge1xuICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInBhcmVudCBhbHJlYWR5IHNldFwiKTtcbiAgICB9XG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfY29udGludWVXaXRoOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBmaXJzdFBlbmRpbmcgPSB0aGlzLl9maW5kRmlyc3RQZW5kaW5nKCk7XG4gICAgaWYgKGZpcnN0UGVuZGluZykge1xuICAgICAgZmlyc3RQZW5kaW5nLl9kYXRhID0gZGF0YTtcbiAgICAgIGZpcnN0UGVuZGluZy5fc2V0UmVzb2x2ZWQoKTtcbiAgICB9XG4gIH0sXG4gIF9maW5kRmlyc3RQZW5kaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRGaXJzdEFuY2VzdG9yKGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgICByZXR1cm4gdGVzdC5faXNQZW5kaW5nICYmIHRlc3QuX2lzUGVuZGluZygpO1xuICAgIH0pO1xuICB9LFxuICBfZmluZEZpcnN0UGF1c2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRGaXJzdEFuY2VzdG9yKGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgICByZXR1cm4gdGVzdC5fcGF1c2VkO1xuICAgIH0pO1xuICB9LFxuICBfZmluZEZpcnN0QW5jZXN0b3I6IGZ1bmN0aW9uIChtYXRjaGluZykge1xuICAgIHZhciB0ZXN0ID0gdGhpcztcbiAgICB2YXIgcmVzdWx0O1xuICAgIHdoaWxlICh0ZXN0KSB7XG4gICAgICBpZiAobWF0Y2hpbmcodGVzdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gdGVzdDtcbiAgICAgIH1cbiAgICAgIHRlc3QgPSB0ZXN0Ll9wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIF9mYWlsV2l0aDogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgdmFyIGZpcnN0UmVqZWN0ZWQgPSB0aGlzLl9maW5kRmlyc3RQZW5kaW5nKCk7XG4gICAgaWYgKGZpcnN0UmVqZWN0ZWQpIHtcbiAgICAgIGZpcnN0UmVqZWN0ZWQuX2Vycm9yID0gZXJyb3I7XG4gICAgICBmaXJzdFJlamVjdGVkLl9zZXRSZWplY3RlZCgpO1xuICAgIH1cbiAgfSxcbiAgX3Rha2VDb250aW51YXRpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRpbnVhdGlvbnMuc3BsaWNlKDAsIHRoaXMuX2NvbnRpbnVhdGlvbnMubGVuZ3RoKTtcbiAgfSxcbiAgX3J1blJlamVjdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcGF1c2VkIHx8ICF0aGlzLl9pc1JlamVjdGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyXG4gICAgICBlcnJvciA9IHRoaXMuX2Vycm9yLFxuICAgICAgY29udGludWF0aW9ucyA9IHRoaXMuX3Rha2VDb250aW51YXRpb25zKCksXG4gICAgICBzZWxmID0gdGhpcztcbiAgICBjb250aW51YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGNvbnQpIHtcbiAgICAgIGlmIChjb250LmNhdGNoRm4pIHtcbiAgICAgICAgdmFyIGNhdGNoUmVzdWx0ID0gY29udC5jYXRjaEZuKGVycm9yKTtcbiAgICAgICAgc2VsZi5faGFuZGxlVXNlckZ1bmN0aW9uUmVzdWx0KGNhdGNoUmVzdWx0LCBjb250LnByb21pc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udC5wcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIF9ydW5SZXNvbHV0aW9uczogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9wYXVzZWQgfHwgIXRoaXMuX2lzUmVzb2x2ZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY29udGludWF0aW9ucyA9IHRoaXMuX3Rha2VDb250aW51YXRpb25zKCk7XG4gICAgaWYgKGxvb2tzTGlrZUFQcm9taXNlKHRoaXMuX2RhdGEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFuZGxlV2hlblJlc29sdmVkRGF0YUlzUHJvbWlzZSh0aGlzLl9kYXRhKTtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBjb250aW51YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGNvbnQpIHtcbiAgICAgIGlmIChjb250Lm5leHRGbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBjb250Lm5leHRGbihkYXRhKTtcbiAgICAgICAgICBzZWxmLl9oYW5kbGVVc2VyRnVuY3Rpb25SZXN1bHQocmVzdWx0LCBjb250LnByb21pc2UpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgc2VsZi5faGFuZGxlUmVzb2x1dGlvbkVycm9yKGUsIGNvbnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvbnQucHJvbWlzZSkge1xuICAgICAgICBjb250LnByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgX2hhbmRsZVJlc29sdXRpb25FcnJvcjogZnVuY3Rpb24gKGUsIGNvbnRpbnVhdGlvbikge1xuICAgIHRoaXMuX3NldFJlamVjdGVkKCk7XG4gICAgaWYgKGNvbnRpbnVhdGlvbi5jYXRjaEZuKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb250aW51YXRpb24uY2F0Y2hGbihlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgZSA9IGUyO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGludWF0aW9uLnByb21pc2UpIHtcbiAgICAgIGNvbnRpbnVhdGlvbi5wcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH0sXG4gIF9oYW5kbGVXaGVuUmVzb2x2ZWREYXRhSXNQcm9taXNlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gZGF0YS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIHNlbGYuX2RhdGEgPSByZXN1bHQ7XG4gICAgICBzZWxmLl9ydW5SZXNvbHV0aW9ucygpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgc2VsZi5fZXJyb3IgPSBlcnJvcjtcbiAgICAgIHNlbGYuX3NldFJlamVjdGVkKCk7XG4gICAgICBzZWxmLl9ydW5SZWplY3Rpb25zKCk7XG4gICAgfSk7XG4gIH0sXG4gIF9oYW5kbGVVc2VyRnVuY3Rpb25SZXN1bHQ6IGZ1bmN0aW9uIChkYXRhLCBuZXh0U3luY2hyb25vdXNQcm9taXNlKSB7XG4gICAgaWYgKGxvb2tzTGlrZUFQcm9taXNlKGRhdGEpKSB7XG4gICAgICB0aGlzLl9jaGFpblByb21pc2VEYXRhKGRhdGEsIG5leHRTeW5jaHJvbm91c1Byb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0U3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoZGF0YSk7XG4gICAgfVxuICB9LFxuICBfY2hhaW5Qcm9taXNlRGF0YTogZnVuY3Rpb24gKHByb21pc2VEYXRhLCBuZXh0U3luY2hyb25vdXNQcm9taXNlKSB7XG4gICAgcHJvbWlzZURhdGEudGhlbihmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgbmV4dFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKG5ld0RhdGEpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChuZXdFcnJvcikge1xuICAgICAgbmV4dFN5bmNocm9ub3VzUHJvbWlzZS5yZWplY3QobmV3RXJyb3IpO1xuICAgIH0pO1xuICB9LFxuICBfc2V0UmVzb2x2ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnN0YXR1cyA9IFJFU09MVkVEO1xuICAgIGlmICghdGhpcy5fcGF1c2VkKSB7XG4gICAgICB0aGlzLl9ydW5SZXNvbHV0aW9ucygpO1xuICAgIH1cbiAgfSxcbiAgX3NldFJlamVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBSRUpFQ1RFRDtcbiAgICBpZiAoIXRoaXMuX3BhdXNlZCkge1xuICAgICAgdGhpcy5fcnVuUmVqZWN0aW9ucygpO1xuICAgIH1cbiAgfSxcbiAgX2lzUGVuZGluZzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gUEVORElORztcbiAgfSxcbiAgX2lzUmVzb2x2ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IFJFU09MVkVEO1xuICB9LFxuICBfaXNSZWplY3RlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gUkVKRUNURUQ7XG4gIH1cbn07XG5cblN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICByZXR1cm4gbmV3IFN5bmNocm9ub3VzUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKGxvb2tzTGlrZUFQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uIChuZXdSZXN1bHQpIHtcbiAgICAgICAgcmVzb2x2ZShuZXdSZXN1bHQpO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5TeW5jaHJvbm91c1Byb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICByZXR1cm4gbmV3IFN5bmNocm9ub3VzUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVqZWN0KHJlc3VsdCk7XG4gIH0pO1xufTtcblxuU3luY2hyb25vdXNQcm9taXNlLnVucmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgU3luY2hyb25vdXNQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcbn07XG5cblN5bmNocm9ub3VzUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcmdzID0gbWFrZUFycmF5RnJvbShhcmd1bWVudHMpO1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgIGFyZ3MgPSBhcmdzWzBdO1xuICB9XG4gIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICByZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoW10pO1xuICB9XG4gIHJldHVybiBuZXcgU3luY2hyb25vdXNQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXJcbiAgICAgIGFsbERhdGEgPSBbXSxcbiAgICAgIG51bVJlc29sdmVkID0gMCxcbiAgICAgIGRvUmVzb2x2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG51bVJlc29sdmVkID09PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIHJlc29sdmUoYWxsRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZWplY3RlZCA9IGZhbHNlLFxuICAgICAgZG9SZWplY3QgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWplY3RlZCA9IHRydWU7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfTtcbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGFyZywgaWR4KSB7XG4gICAgICBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZShhcmcpLnRoZW4oZnVuY3Rpb24gKHRoaXNSZXN1bHQpIHtcbiAgICAgICAgYWxsRGF0YVtpZHhdID0gdGhpc1Jlc3VsdDtcbiAgICAgICAgbnVtUmVzb2x2ZWQgKz0gMTtcbiAgICAgICAgZG9SZXNvbHZlKCk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGRvUmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG5pZiAoUHJvbWlzZSA9PT0gU3luY2hyb25vdXNQcm9taXNlKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSB1c2UgU3luY2hyb25vdXNQcm9taXNlLmluc3RhbGxHbG9iYWxseSgpIHRvIGluc3RhbGwgZ2xvYmFsbHlcIik7XG59XG52YXIgUmVhbFByb21pc2UgPSBQcm9taXNlO1xuU3luY2hyb25vdXNQcm9taXNlLmluc3RhbGxHbG9iYWxseSA9IGZ1bmN0aW9uKF9fYXdhaXRlcikge1xuICBpZiAoUHJvbWlzZSA9PT0gU3luY2hyb25vdXNQcm9taXNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcjtcbiAgfSBcbiAgdmFyIHJlc3VsdCA9IHBhdGNoQXdhaXRlcklmUmVxdWlyZWQoX19hd2FpdGVyKTtcbiAgUHJvbWlzZSA9IFN5bmNocm9ub3VzUHJvbWlzZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblN5bmNocm9ub3VzUHJvbWlzZS51bmluc3RhbGxHbG9iYWxseSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoUHJvbWlzZSA9PT0gU3luY2hyb25vdXNQcm9taXNlKSB7XG4gICAgUHJvbWlzZSA9IFJlYWxQcm9taXNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwYXRjaEF3YWl0ZXJJZlJlcXVpcmVkKF9fYXdhaXRlcikge1xuICBpZiAodHlwZW9mKF9fYXdhaXRlcikgPT09IFwidW5kZWZpbmVkXCIgfHwgX19hd2FpdGVyLl9fcGF0Y2hlZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXI7XG4gIH1cbiAgdmFyIG9yaWdpbmFsQXdhaXRlciA9IF9fYXdhaXRlcjtcbiAgX19hd2FpdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIFByb21pc2UgPSBSZWFsUHJvbWlzZTtcbiAgICBvcmlnaW5hbEF3YWl0ZXIuYXBwbHkodGhpcywgbWFrZUFycmF5RnJvbShhcmd1bWVudHMpKTtcbiAgfTtcbiAgX19hd2FpdGVyLl9fcGF0Y2hlZCA9IHRydWU7XG4gIHJldHVybiBfX2F3YWl0ZXI7XG59XG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgU3luY2hyb25vdXNQcm9taXNlOiBTeW5jaHJvbm91c1Byb21pc2Vcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBQbHVnaW4gdG8gYWRkICdwcm9wZXJ0eScgKGFzIGluIHBlcnNvbmFsIHByb3BlcnR5KSBwcm9wZXJ0eSB0byBQbGF5ZXJzIHdoZW4gdGhleSBhcmUgaW5pdGlhbGl6ZWQuIE1lYW50IHRvIGJlIHVzZWQgZm9yXHJcbi8vIHNpbXVsYXRpb25zIGludm9sdmluZyBwZXJzb25hbCBwb3Nlc3Npb25zLCBmb3IgaW5zdGFuY2UgZWNvbm9taWMgc2ltdWxhdGlvbnMuXHJcblxyXG4vLyBOYXNoSlMgZW5naW5lIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG4vLyBHYW1lIHN0YXRlXHJcbnZhciB7IHJlZ2lzdHJ5LCBnYW1lUG9wdWxhdGlvbiB9ID0gRW5naW5lLkJhY2tlbmQuU3RhdGU7XHJcblxyXG4vLyBMZXQncyBhZGQgc29tZSBQbGF5ZXJMaXN0IGZ1bmN0aW9uYWxpdHlcclxudmFyIHsgUGxheWVyTGlzdCB9ID0gRW5naW5lLkJhY2tlbmQuQ2xhc3NlcztcclxuXHJcblxyXG52YXIgQmFsYW5jZVNoZWV0ID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdC8vIFZhcmlhYmxlcyB0byBzdG9yZSBzZXR0aW5ncywgYW5kIGRlZmF1bHRzXHJcblx0dmFyIHNldHRpbmdzID0ge1xyXG5cdFx0YWRkQmFsYW5jZVNoZWV0T25DbGFpbTogdHJ1ZSxcclxuXHRcdGNsZWFuWmVyb3M6IHRydWUsXHJcblx0XHRuZWdhdGl2ZUFzc2V0czogZmFsc2VcclxuXHR9XHJcblx0Ly9UT0RPIG1ha2UgbmVnYXRpdmVBc3NldHMgKGFuZCBuZWdhdGl2ZUxpYWJpbGl0aWVzKSB3b3JrXHJcblxyXG5cclxuXHQvLyBBc3NldHMgQ2xhc3Nlc1xyXG5cclxuXHQvLyBDbGFpbSBwYXJlbnQgY2xhc3NcclxuXHR2YXIgQ2xhaW0gPSBmdW5jdGlvbihjbGFpbWFudCwgYW1vdW50KSB7XHJcblx0XHQvLyBBZGQgYmFsYW5jZSBzaGVldCBpZiBuZWNlc3NhcnkgYW5kIHBlcm1pdHRlZFxyXG5cdFx0aWYgKCFjbGFpbWFudC5iYWxhbmNlU2hlZXQpIHtcclxuXHRcdFx0aWYgKHNldHRpbmdzLmFkZEJhbGFuY2VTaGVldE9uQ2xhaW0pIGFkZEVudHJpZXMocmVnaXN0cnkucGxheWVyc1tjbGFpbWFudC5pZCgpXSlcclxuXHRcdFx0Ly8gRmFpbCBpZiBub3QgcGVybWl0dGVkIHRvIGFkZCBuZWNlc3NhcnkgYmFsYW5jZSBzaGVldC5cclxuXHRcdFx0ZWxzZSByZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hbW91bnQgPSBhbW91bnQ7XHJcblx0XHR0aGlzLmNsYWltYW50ID0gY2xhaW1hbnRcclxuXHRcdGNsYWltYW50LmVuZG93KHRoaXMpXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8vIEVuZCBvd25lcnNoaXAgY2xhaW1cclxuXHRDbGFpbS5wcm90b3R5cGUuZXJhc2UgPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuY2xhaW1hbnQucmV2b2tlKHRoaXMpXHJcblx0XHR0aGlzLmNsYWltYW50ID0gbnVsbDtcclxuXHRcdHRoaXMuYW1vdW50ID0gMFxyXG5cdH1cclxuXHJcblx0Ly8gTWVyZ2UgY2xhaW1zIGlmIHRoZXkncmUgdGhlIHNhbWUgZmFtaWx5IGJ1dCBkaWZmZXJlbnQgYW1vdW50c1xyXG5cdENsYWltLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKG90aGVyQ2xhaW0pIHtcclxuXHRcdGlmICh0aGlzLmNsYWltYW50ICE9PSBvdGhlckNsYWltLmNsYWltYW50KSByZXR1cm4gZmFsc2VcclxuXHRcdC8vIEFkZCBhbW91bnRzXHJcblx0XHR0aGlzLmFtb3VudCA9IHRoaXMuYW1vdW50ICsgb3RoZXJDbGFpbS5hbW91bnRcclxuXHJcblx0XHQvLyBSZW1vdmUgZnJvbSBiYWxhbmNlIHNoZWV0XHJcblx0XHRvdGhlckNsYWltLmVyYXNlKCk7XHJcblx0fVxyXG5cclxuXHQvLyBTcGxpdCB0aGlzIGludG8gdHdvIHNlcGFyYXRlIGNsYWltcywgd2l0aCBkaWZmZXJlbnQgYW1vdW50c1xyXG5cdENsYWltLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uKG5ld0Ftb3VudCkge1xyXG5cdFx0dmFyIGNsb25lID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSksIHRoaXMpO1xyXG5cdFx0Y2xvbmUuYW1vdW50ID0gbmV3QW1vdW50O1xyXG5cdFx0dGhpcy5hbW91bnQgPSB0aGlzLmFtb3VudCAtIG5ld0Ftb3VudDtcclxuXHRcdHRoaXMuY2xhaW1hbnQuZW5kb3coY2xvbmUsIGZhbHNlKVxyXG5cdFx0cmV0dXJuIGNsb25lO1xyXG5cdH1cclxuXHJcblx0Ly8gVHJhbnNmZXIgdG8gbmV3IG93bmVyXHJcblx0Q2xhaW0ucHJvdG90eXBlLnRyYW5zZmVyID0gZnVuY3Rpb24obmV3Q2xhaW1hbnQsIGFtb3VudCA9IFwiYWxsXCIpIHtcclxuXHRcdC8vIEFkZCBiYWxhbmNlIHNoZWV0IGlmIG5lY2Vzc2FyeSBhbmQgcGVybWl0dGVkXHJcblx0XHRpZiAoIW5ld0NsYWltYW50LmJhbGFuY2VTaGVldCkge1xyXG5cdFx0XHRpZiAoc2V0dGluZ3MuYWRkQmFsYW5jZVNoZWV0T25DbGFpbSkgYWRkRW50cmllcyhyZWdpc3RyeS5wbGF5ZXJzW25ld0NsYWltYW50LmlkKCldKVxyXG5cdFx0XHQvLyBGYWlsIGlmIG5vdCBwZXJtaXR0ZWQgdG8gYWRkIG5lY2Vzc2FyeSBiYWxhbmNlIHNoZWV0LlxyXG5cdFx0XHRlbHNlIHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBUcmFuc2ZlciBhbGwgb2YgaXRcclxuXHRcdGlmIChhbW91bnQgPT0gXCJhbGxcIiB8fCBhbW91bnQgPT0gdGhpcy5hbW91bnQpIHtcclxuXHRcdFx0dmFyIG9sZENsYWltYW50ID0gdGhpcy5jbGFpbWFudDtcclxuXHRcdFx0dGhpcy5jbGFpbWFudC5yZXZva2UodGhpcyk7XHJcblx0XHRcdHRoaXMuY2xhaW1hbnQgPSBuZXdDbGFpbWFudDtcclxuXHRcdFx0bmV3Q2xhaW1hbnQuZW5kb3codGhpcyk7XHJcblxyXG5cdFx0fVxyXG5cdFx0Ly8gb3Igb25seSBhIHBvcnRpb25cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR2YXIgbmV3Q2xhaW0gPSB0aGlzLnNwbGl0KGFtb3VudCk7XHJcblx0XHRcdG5ld0NsYWltLnRyYW5zZmVyKG5ld0NsYWltYW50LCBcImFsbFwiKVxyXG5cdFx0XHRjbGVhbkFzc2V0KHRoaXMpXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBDbGFpbXMgb24gcmVhbCB0aGluZ3MgKGxpa2UgY2FycywgaG91c2VzLCBnb2xkKVxyXG5cdHZhciBSZWFsQ2xhaW0gPSBmdW5jdGlvbihjbGFpbWFudCwgZ29vZCwgYW1vdW50KSB7XHJcblx0XHRpZiAoIUNsYWltLmNhbGwodGhpcywgY2xhaW1hbnQsIGFtb3VudCkpIHJldHVybiBmYWxzZTtcclxuXHRcdHRoaXMuZ29vZCA9IGdvb2Q7XHJcblx0fVxyXG5cdFJlYWxDbGFpbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYWltLnByb3RvdHlwZSlcclxuXHRSZWFsQ2xhaW0ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVhbENsYWltXHJcblxyXG5cdC8vIExvc2UgdmFsdWUgYnkgcGVyY2VudGFnZVxyXG5cdFJlYWxDbGFpbS5wcm90b3R5cGUuZGVwcmVjaWF0ZSA9IGZ1bmN0aW9uKHJhdGUgPSAuMSkge1xyXG5cdFx0dGhpcy5hbW91bnQgPSB0aGlzLmFtb3VudCAqICgxIC0gcmF0ZSlcclxuXHR9XHJcblxyXG5cdC8vIEFkZCBnb29kIGVuZm9yY2VtZW50IHRvIG1lcmdlXHJcblx0UmVhbENsYWltLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKG90aGVyQ2xhaW0pIHtcclxuXHRcdGlmICh0aGlzLmdvb2QgPT09IG90aGVyQ2xhaW0uZ29vZCkgcmV0dXJuIENsYWltLnByb3RvdHlwZS5tZXJnZS5jYWxsKHRoaXMsIG90aGVyQ2xhaW0pO1xyXG5cdH1cclxuXHJcblx0Ly8gUmVwbGFjZSBwbGF5ZXIgb2JqZWN0IHdpdGggaWQgd2hlbiBzdHJpbmdpZnlpbmdcclxuXHRSZWFsQ2xhaW0ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Y2xhaW1hbnQ6IHRoaXMuY2xhaW1hbnQuaWQoKSxcclxuXHRcdFx0Z29vZDogdGhpcy5nb29kLFxyXG5cdFx0XHRhbW91bnQ6IHRoaXMuYW1vdW50XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBDbGFpbXMgb24gb3RoZXIgZW50aXRpZXMgd2l0aCBiYWxhbmNlIHNoZWV0c1xyXG5cdHZhciBGaW5hbmNpYWxDbGFpbSA9IGZ1bmN0aW9uKGNsYWltYW50LCBjbGFpbWVkLCBhbW91bnQsIGluc3RydW1lbnQgPSBcIkRlYnRcIikge1xyXG5cdFx0Ly8gQWRkIGJhbGFuY2Ugc2hlZXQgaWYgbmVjZXNzYXJ5IGFuZCBwZXJtaXR0ZWRcclxuXHRcdGlmICghY2xhaW1lZC5iYWxhbmNlU2hlZXQpIHtcclxuXHRcdFx0aWYgKHNldHRpbmdzLmFkZEJhbGFuY2VTaGVldE9uQ2xhaW0pIGFkZEVudHJpZXMocmVnaXN0cnkucGxheWVyc1tjbGFpbWVkLmlkKCldKVxyXG5cdFx0XHQvLyBGYWlsIGlmIG5vdCBwZXJtaXR0ZWQgdG8gYWRkIG5lY2Vzc2FyeSBiYWxhbmNlIHNoZWV0LlxyXG5cdFx0XHRlbHNlIHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHRoaXMuY2xhaW1lZCA9IGNsYWltZWQ7XHJcblx0XHR0aGlzLmluc3RydW1lbnQgPSBpbnN0cnVtZW50O1xyXG5cclxuXHRcdGlmICghQ2xhaW0uY2FsbCh0aGlzLCBjbGFpbWFudCwgYW1vdW50KSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdGNsYWltZWQuaW5kZWJ0KHRoaXMpXHJcblx0fVxyXG5cdEZpbmFuY2lhbENsYWltLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhaW0ucHJvdG90eXBlKVxyXG5cdEZpbmFuY2lhbENsYWltLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZpbmFuY2lhbENsYWltXHJcblxyXG5cdC8vIEFkZCB0byBlcmFzZSBmdW5jdGlvbiwgdG8gZXJhc2UgZnJvbSBjbGFpbWVkJ3MgYmFsYW5jZSBzaGVldCB0b29cclxuXHRGaW5hbmNpYWxDbGFpbS5wcm90b3R5cGUuZXJhc2UgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBicyA9IHJlZ2lzdHJ5LnBsYXllcnNbdGhpcy5jbGFpbWVkLmlkKCldLmJhbGFuY2VTaGVldC5saWFiaWxpdGllc1xyXG5cdFx0YnMuc3BsaWNlKGJzLmluZGV4T2YodGhpcyksIDEpXHJcblx0XHR0aGlzLmNsYWltZWQgPSBudWxsO1xyXG5cclxuXHRcdHJldHVybiBDbGFpbS5wcm90b3R5cGUuZXJhc2UuY2FsbCh0aGlzKVxyXG5cdH1cclxuXHJcblx0Ly8gQWRkIGNsYWltZWQgZW5mb3JjZW1lbnQgdG8gbWVyZ2VcclxuXHRGaW5hbmNpYWxDbGFpbS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihvdGhlckNsYWltKSB7XHJcblx0XHRpZiAodGhpcy5jbGFpbWVkID09PSBvdGhlckNsYWltLmNsYWltZWQpIHJldHVybiBDbGFpbS5wcm90b3R5cGUubWVyZ2UuY2FsbCh0aGlzLCBvdGhlckNsYWltKTtcclxuXHR9XHJcblxyXG5cclxuXHQvLyBBZGQgdG8gc3BsaXQgZnVuY3Rpb24sIHRvIHNwbGl0IG9uIGNsYWltZWQncyBiYWxhbmNlIHNoZWV0IHRvb1xyXG5cdEZpbmFuY2lhbENsYWltLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uKG5ld0Ftb3VudCkge1xyXG5cdFx0dmFyIGNsb25lID0gQ2xhaW0ucHJvdG90eXBlLnNwbGl0LmNhbGwodGhpcywgbmV3QW1vdW50KTtcclxuXHRcdGNsb25lLmNsYWltZWQuaW5kZWJ0KGNsb25lLCBmYWxzZSk7XHJcblx0XHRyZXR1cm4gY2xvbmU7XHJcblx0fVxyXG5cclxuXHQvLyBSZXBsYWNlIHBsYXllciBvYmplY3Qgd2l0aCBpZCB3aGVuIHN0cmluZ2lmeWluZ1xyXG5cdEZpbmFuY2lhbENsYWltLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGNsYWltYW50OiB0aGlzLmNsYWltYW50LmlkKCksXHJcblx0XHRcdGNsYWltZWQ6IHRoaXMuY2xhaW1lZC5pZCgpLFxyXG5cdFx0XHRpbnN0cnVtZW50OiB0aGlzLmluc3RydW1lbnQsXHJcblx0XHRcdGFtb3VudDogdGhpcy5hbW91bnRcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHQvLyBDbGVhbiB0aGUgc2ltaWxhciBjbGFpbXMgb24gdGhlIGNsYWltYW50IHN1cHBsaWVkXHJcblx0dmFyIGNsZWFuQXNzZXQgPSBmdW5jdGlvbihjbGFpbSkge1xyXG5cdFx0dmFyIGJzID0gcmVnaXN0cnkucGxheWVyc1tjbGFpbS5jbGFpbWFudC5pZCgpXS5iYWxhbmNlU2hlZXQuYXNzZXRzO1xyXG5cclxuXHRcdHZhciBkaXJ0eSA9IGJzLmZpbHRlcihmdW5jdGlvbihlbnRyeSkge1xyXG5cdFx0XHRyZXR1cm4gKGVudHJ5ICE9PSBjbGFpbSAmJiBlbnRyeS5nb29kID09PSBjbGFpbS5nb29kICYmIGVudHJ5Lmluc3RydW1lbnQgPT09IGNsYWltLmluc3RydW1lbnQpO1xyXG5cdFx0fSlcclxuXHJcblx0XHRkaXJ0eS5mb3JFYWNoKGZ1bmN0aW9uKGRpcnQpIHtcclxuXHRcdFx0Y2xhaW0ubWVyZ2UoZGlydClcclxuXHRcdH0pXHJcblxyXG5cdFx0aWYgKHNldHRpbmdzLmNsZWFuWmVyb3MgJiYgY2xhaW0uYW1vdW50ID09IDApIGNsYWltLmVyYXNlKClcclxuXHR9XHJcblxyXG5cdHZhciBjbGVhbkxpYWJpbGl0eSA9IGZ1bmN0aW9uKGNsYWltKSB7XHJcblx0XHR2YXIgYnMgPSByZWdpc3RyeS5wbGF5ZXJzW2NsYWltLmNsYWltZWQuaWQoKV0uYmFsYW5jZVNoZWV0LmxpYWJpbGl0aWVzO1xyXG5cclxuXHRcdHZhciBkaXJ0eSA9IGJzLmZpbHRlcihmdW5jdGlvbihlbnRyeSkge1xyXG5cdFx0XHRyZXR1cm4gKGVudHJ5ICE9PSBjbGFpbSAmJiBlbnRyeS5jbGFpbWFudCA9PT0gY2xhaW0uY2xhaW1hbnQgJiYgZW50cnkuaW5zdHJ1bWVudCA9PT0gY2xhaW0uaW5zdHJ1bWVudCk7XHJcblx0XHR9KVxyXG5cclxuXHRcdGRpcnR5LmZvckVhY2goZnVuY3Rpb24oZGlydCkge1xyXG5cdFx0XHRjbGFpbS5tZXJnZShkaXJ0KVxyXG5cdFx0fSlcclxuXHJcblx0XHRpZiAoc2V0dGluZ3MuY2xlYW5aZXJvcyAmJiBjbGFpbS5hbW91bnQgPT0gMCkgY2xhaW0uZXJhc2VcclxuXHR9XHJcblxyXG5cclxuXHJcblx0Ly8gQWRkIGJhbGFuY2Ugc2hlZXQgb2JqZWN0IGFuZCBtZXRob2RzIHRvIHBsYXllci5cclxuXHR2YXIgYWRkRW50cmllcyA9IGZ1bmN0aW9uKHBsYXllcikge1xyXG5cclxuXHRcdC8vX3BsYXllciBwcm9wZXJ0aWVzL21ldGhvZHNcclxuXHRcdHBsYXllci5iYWxhbmNlU2hlZXQgPSB7IGFzc2V0czogW10sIGxpYWJpbGl0aWVzOiBbXSB9XHJcblxyXG5cdFx0LypcclxuXHRcdHZhciBsb29rdXAgPSBmdW5jdGlvbih0eXBlKSB7XHJcblx0XHRcdHRoaXMucmVkdWNlKGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSkge1xyXG5cdFx0XHRcdGlmICh0eXBlID09PSB2YWx1ZS5nb29kKSBhY2N1bXVsYXRvciArPSB2YWx1ZS5hbW91bnRcclxuXHRcdFx0XHRlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgT2JqZWN0ICYmIHR5cGUuaW5zdHJ1bWVudCA9PSB2YWx1ZS5pbnN0cnVtZW50ICYmICh0eXBlLmNsYWltZWQgPT09IHZhbHVlLmNsYWltZWQpKVxyXG5cdFx0XHRcdFx0YWNjdW11bGF0b3IgKz0gdmFsdWUuYW1vdW50XHJcblx0XHRcdFx0cmV0dXJuIGFjY3VtdWxhdG9yO1xyXG5cdFx0XHR9LCAwKVxyXG5cdFx0fVxyXG5cdFx0cGxheWVyLmJhbGFuY2VTaGVldC5hc3NldHMubG9va3VwID0gbG9va3VwO1xyXG5cdFx0cGxheWVyLmJhbGFuY2VTaGVldC5saWFiaWxpdGllcy5sb29rdXAgPSBsb29rdXA7XHJcblx0XHQqL1xyXG5cclxuXHRcdHBsYXllci5uZXRXb3J0aCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0dmFyIGFzc2V0cyA9IHRoaXMuYmFsYW5jZVNoZWV0LmFzc2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSkge1xyXG5cdFx0XHRcdHJldHVybiBhY2N1bXVsYXRvciArIGN1cnJlbnRWYWx1ZS5hbW91bnRcclxuXHRcdFx0fSwgMCk7XHJcblxyXG5cdFx0XHR2YXIgbGlhYmlsaXRpZXMgPSB0aGlzLmJhbGFuY2VTaGVldC5saWFiaWxpdGllcy5yZWR1Y2UoZnVuY3Rpb24oYWNjdW11bGF0b3IsXHJcblx0XHRcdFx0Y3VycmVudFZhbHVlKSB7XHJcblx0XHRcdFx0cmV0dXJuIGFjY3VtdWxhdG9yICsgY3VycmVudFZhbHVlLmFtb3VudFxyXG5cdFx0XHR9LCAwKTtcclxuXHJcblx0XHRcdHJldHVybiBhc3NldHMgLSBsaWFiaWxpdGllcztcclxuXHRcdH1cclxuXHJcblx0XHQvLyBVc2VyIGludGVyZmFjZVxyXG5cdFx0cGxheWVyLmludGVyZmFjZS5iYWxhbmNlU2hlZXQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVnaXN0cnkucGxheWVyc1twbGF5ZXIuaWRdLmJhbGFuY2VTaGVldCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHBsYXllci5pbnRlcmZhY2UubmV0V29ydGggPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyLmlkXS5uZXRXb3J0aCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRPRE8gdmFsaWRhdGUgb2JqZWN0LlxyXG5cdFx0cGxheWVyLmludGVyZmFjZS5lbmRvdyA9IGZ1bmN0aW9uKGFzc2V0LCBjbGVhbiA9IHRydWUpIHtcclxuXHRcdFx0aWYgKGFzc2V0IGluc3RhbmNlb2YgQ2xhaW0pIHtcclxuXHRcdFx0XHRyZWdpc3RyeS5wbGF5ZXJzW3BsYXllci5pZF0uYmFsYW5jZVNoZWV0LmFzc2V0cy5wdXNoKGFzc2V0KTtcclxuXHRcdFx0XHRpZiAoY2xlYW4pIGNsZWFuQXNzZXQoYXNzZXQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cGxheWVyLmludGVyZmFjZS5pbmRlYnQgPSBmdW5jdGlvbihsaWFiaWxpdHksIGNsZWFuID0gdHJ1ZSkge1xyXG5cdFx0XHRpZiAobGlhYmlsaXR5IGluc3RhbmNlb2YgRmluYW5jaWFsQ2xhaW0pIHtcclxuXHRcdFx0XHRyZWdpc3RyeS5wbGF5ZXJzW3BsYXllci5pZF0uYmFsYW5jZVNoZWV0LmxpYWJpbGl0aWVzLnB1c2goXHJcblx0XHRcdFx0XHRsaWFiaWxpdHkpO1xyXG5cdFx0XHRcdGlmIChjbGVhbikgY2xlYW5MaWFiaWxpdHkobGlhYmlsaXR5KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHBsYXllci5pbnRlcmZhY2UucmV2b2tlID0gZnVuY3Rpb24oYXNzZXQpIHtcclxuXHRcdFx0aWYgKGFzc2V0IGluc3RhbmNlb2YgQ2xhaW0pIHtcclxuXHRcdFx0XHR2YXIgYnMgPSByZWdpc3RyeS5wbGF5ZXJzW3BsYXllci5pZF0uYmFsYW5jZVNoZWV0LmFzc2V0c1xyXG5cdFx0XHRcdGJzLnNwbGljZShicy5pbmRleE9mKGFzc2V0KSwgMSlcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRPRE8gY29udmVydCB0aGlzIG92ZXJcclxuXHRcdHBsYXllci5pbnRlcmZhY2UubGVuZCA9IGZ1bmN0aW9uKGJvcnJvd2VyLCBhbW91bnQsIGluc3RydW1lbnQgPSBcIkRlYnRcIikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IEZpbmFuY2lhbENsYWltKHBsYXllci5pbnRlcmZhY2UsIGJvcnJvd2VyLCBhbW91bnQsIGluc3RydW1lbnQpXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8vIFRoZSBwbHVnaW4gb2JqZWN0LlxyXG5cdHZhciBQbHVnaW4gPSB7XHJcblx0XHRuYW1lOiBcImJhbGFuY2Utc2hlZXQtY29tcGxleFwiLFxyXG5cclxuXHRcdHNldHRpbmdzOiBmdW5jdGlvbihwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRcdFx0T2JqZWN0LmFzc2lnbihzZXR0aW5ncywgcGFyYW1ldGVycylcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gT3B0aW9uIHRvIGluaXRpYWxpemUgYnkgY3JlYXRpbmcgJ3Byb3BlcnR5JyBmb3IgYSBncm91cCBvZiBwbGF5ZXJzLlxyXG5cdFx0aW5pdChwbGF5ZXJzID0gW10pIHtcclxuXHRcdFx0Ly8gQWRkIHNvbWUgcGxheWVybGlzdCBmdW5jdGlvbmFsaXR5XHJcblx0XHRcdFBsYXllckxpc3QucHJvdG90eXBlLmJhbGFuY2VTaGVldHMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0XHRpZiAocGxheWVyLmJhbGFuY2VTaGVldCkgcmV0dXJuIHBsYXllci5pbnRlcmZhY2UuYmFsYW5jZVNoZWV0KCk7XHJcblx0XHRcdFx0XHRlbHNlIHJldHVybiBudWxsO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRQbGF5ZXJMaXN0LnByb3RvdHlwZS5hc3NldHMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0XHRpZiAocGxheWVyLmJhbGFuY2VTaGVldCkgcmV0dXJuIHBsYXllci5pbnRlcmZhY2UuYmFsYW5jZVNoZWV0KCkuYXNzZXRzO1xyXG5cdFx0XHRcdFx0ZWxzZSByZXR1cm4gbnVsbDtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0UGxheWVyTGlzdC5wcm90b3R5cGUubGlhYmlsaXRpZXMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0XHRpZiAocGxheWVyLmJhbGFuY2VTaGVldCkgcmV0dXJuIHBsYXllci5pbnRlcmZhY2UuYmFsYW5jZVNoZWV0KCkubGlhYmlsaXRpZXM7XHJcblx0XHRcdFx0XHRlbHNlIHJldHVybiBudWxsO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRQbGF5ZXJMaXN0LnByb3RvdHlwZS5uZXRXb3J0aCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0XHRcdGlmIChwbGF5ZXIuYmFsYW5jZVNoZWV0KSByZXR1cm4gcGxheWVyLm5ldFdvcnRoKCk7XHJcblx0XHRcdFx0XHRlbHNlIHJldHVybiBudWxsO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRQbGF5ZXJMaXN0LnByb3RvdHlwZS56ZXJvQmFsYW5jZVNoZWV0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0XHRcdGFkZEVudHJpZXMocGxheWVyKVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBBZGQgYnMgZm9yIHNwZWNpZmllZCBwbGF5ZXJzXHJcblx0XHRcdHBsYXllcnMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0XHRhZGRFbnRyaWVzKHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyLmlkKCldKTtcclxuXHRcdFx0fSlcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gSWYgd2UndmUgaW5pdC1lZCBhbHJlZHksIGp1c3QgYWRkIGJzJ3MgdG8gdGhlIGN1cnJlbnQgcGxheWVyIGxpc3QgaWYgdGhleSBkb24ndCBoYXZlIGFscmVhZHlcclxuXHRcdHJlcXVpcmUocGxheWVycyA9IFtdKSB7XHJcblx0XHRcdHBsYXllcnMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0XHRpZiAoIXBsYXllci5iYWxhbmNlU2hlZXQpIGFkZEVudHJpZXMocmVnaXN0cnkucGxheWVyc1twbGF5ZXIuaWQoKV0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0sXHJcblxyXG5cdFx0c3RvcCgpIHtcclxuXHRcdFx0Ly8gcmVtb3ZlIHByb3RvdHlwZSBhZGRFbnRyaWVzXHJcblx0XHRcdGRlbGV0ZSBQbGF5ZXJMaXN0LnByb3RvdHlwZS5iYWxhbmNlU2hlZXRzO1xyXG5cdFx0XHRkZWxldGUgUGxheWVyTGlzdC5wcm90b3R5cGUuYXNzZXRzO1xyXG5cdFx0XHRkZWxldGUgUGxheWVyTGlzdC5wcm90b3R5cGUubGlhYmlsaXRpZXM7XHJcblx0XHRcdGRlbGV0ZSBQbGF5ZXJMaXN0LnByb3RvdHlwZS5uZXRXb3J0aDtcclxuXHJcblx0XHRcdC8vIGRlbGV0ZSBiYWxhbmNlIHNoZWV0IHByb3BlcnRpZXMgZnJvbSBldmVyeSBwbGF5ZXIgYW5kIGludGVyZmFjZS5cclxuXHRcdFx0Z2FtZVBvcHVsYXRpb24oKS5mb3JFYWNoKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdGRlbGV0ZSBwbGF5ZXIuYmFsYW5jZVNoZWV0O1xyXG5cdFx0XHRcdGRlbGV0ZSBwbGF5ZXIubmV0V29ydGg7XHJcblx0XHRcdFx0ZGVsZXRlIHBsYXllci5pbnRlcmZhY2UuYmFsYW5jZVNoZWV0O1xyXG5cdFx0XHRcdGRlbGV0ZSBwbGF5ZXIuaW50ZXJmYWNlLm5ldFdvcnRoO1xyXG5cdFx0XHRcdGRlbGV0ZSBwbGF5ZXIuaW50ZXJmYWNlLmVuZG93QXNzZXRzO1xyXG5cdFx0XHRcdGRlbGV0ZSBwbGF5ZXIuaW50ZXJmYWNlLmxlbmQ7XHJcblx0XHRcdH0pXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIFB1YmxpYyBjbGFzc2VzIGZvciBhc3NldC9saWFiaWxpdHlcclxuXHRcdHB1YmxpY0lmQWN0aXZlOiB7XHJcblx0XHRcdFJlYWxDbGFpbSxcclxuXHRcdFx0RmluYW5jaWFsQ2xhaW1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gY3JlYXRlIHByb3BlcnR5IGFuZCBpbnRlcmZhY2UgZnVuY3Rpb24gd2hlbiBwbGF5ZXIgaXMgY3JlYXRlZFxyXG5cdFx0J3BsYXllci1jcmVhdGUnOiBhZGRFbnRyaWVzLFxyXG5cclxuXHRcdC8vIEJsYW5rIHByb3BlcnR5IHdoZW4gcGxheWVyIGlzIHJlLWluaXRpYWxpemVkXHJcblx0XHRcInBsYXllci1yZWluaXRpYWxpemVcIiAocGxheWVyKSB7XHJcblx0XHRcdHBsYXllci5iYWxhbmNlU2hlZXQgPSB7IGFzc2V0czogW10sIGxpYWJpbGl0aWVzOiBbXSB9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gUGx1Z2luO1xyXG59XHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFsYW5jZVNoZWV0O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIFBsdWdpbiB0byBhZGQgJ3Byb3BlcnR5JyAoYXMgaW4gcGVyc29uYWwgcHJvcGVydHkpIHByb3BlcnR5IHRvIFBsYXllcnMgd2hlbiB0aGV5IGFyZSBpbml0aWFsaXplZC4gTWVhbnQgdG8gYmUgdXNlZCBmb3JcclxuLy8gc2ltdWxhdGlvbnMgaW52b2x2aW5nIHBlcnNvbmFsIHBvc2Vzc2lvbnMsIGZvciBpbnN0YW5jZSBlY29ub21pYyBzaW11bGF0aW9ucy5cclxuXHJcbi8vIE5hc2hKUyBlbmdpbmUgY29tcG9uZW50c1xyXG52YXIgRW5naW5lID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIilcclxuXHJcbi8vIEdhbWUgc3RhdGVcclxudmFyIHsgcmVnaXN0cnksIGdhbWVQb3B1bGF0aW9uIH0gPSBFbmdpbmUuQmFja2VuZC5TdGF0ZTtcclxuXHJcbi8vIExldCdzIGFkZCBzb21lIFBsYXllckxpc3QgZnVuY3Rpb25hbGl0eVxyXG52YXIgeyBQbGF5ZXJMaXN0IH0gPSBFbmdpbmUuQmFja2VuZC5DbGFzc2VzO1xyXG5cclxuXHJcbnZhciBCYWxhbmNlU2hlZXQgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dmFyIGFkZEVudHJpZXMgPSBmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdC8vX3BsYXllciBwcm9wZXJ0aWVzL21ldGhvZHNcclxuXHRcdHBsYXllci5iYWxhbmNlU2hlZXQgPSB7IGFzc2V0czoge30sIGxpYWJpbGl0aWVzOiB7fSB9XHJcblxyXG5cdFx0cGxheWVyLm5ldFdvcnRoID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0XHR2YXIgYXNzZXRzID0gT2JqZWN0LmVudHJpZXModGhpcy5iYWxhbmNlU2hlZXQuYXNzZXRzKS5yZWR1Y2UoZnVuY3Rpb24oYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSkge1xyXG5cdFx0XHRcdHJldHVybiBhY2N1bXVsYXRvciArIGN1cnJlbnRWYWx1ZVsxXVxyXG5cdFx0XHR9LCAwKTtcclxuXHJcblx0XHRcdHZhciBsaWFiaWxpdGllcyA9IE9iamVjdC5lbnRyaWVzKHRoaXMuYmFsYW5jZVNoZWV0LmxpYWJpbGl0aWVzKS5yZWR1Y2UoZnVuY3Rpb24oYWNjdW11bGF0b3IsXHJcblx0XHRcdFx0Y3VycmVudFZhbHVlKSB7XHJcblx0XHRcdFx0cmV0dXJuIGFjY3VtdWxhdG9yICsgY3VycmVudFZhbHVlWzFdXHJcblx0XHRcdH0sIDApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGFzc2V0cyAtIGxpYWJpbGl0aWVzO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFVzZXIgaW50ZXJmYWNlXHJcblx0XHRwbGF5ZXIuaW50ZXJmYWNlLmJhbGFuY2VTaGVldCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZWdpc3RyeS5wbGF5ZXJzW3BsYXllci5pZF0uYmFsYW5jZVNoZWV0KSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cGxheWVyLmludGVyZmFjZS5uZXRXb3J0aCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gcmVnaXN0cnkucGxheWVyc1twbGF5ZXIuaWRdLm5ldFdvcnRoKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVE9ETyB2YWxpZGF0ZSBvYmplY3QuIFNob3VsZCBiZSBvZiBmb3JtIHthcHBsZXM6MiwgZG9nczoxfVxyXG5cdFx0cGxheWVyLmludGVyZmFjZS5lbmRvd0Fzc2V0cyA9IGZ1bmN0aW9uKGFzc2V0T2JqZWN0KSB7XHJcblxyXG5cdFx0XHRPYmplY3QuYXNzaWduKHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyLmlkXS5iYWxhbmNlU2hlZXQuYXNzZXRzLCBhc3NldE9iamVjdClcclxuXHRcdH1cclxuXHJcblx0XHRwbGF5ZXIuaW50ZXJmYWNlLmxlbmQgPSBmdW5jdGlvbihsb2FuT2JqZWN0KSB7XHJcblx0XHRcdC8vVE9ETyB2YWxpZGF0ZSBvYmplY3QuIFNob3VsZCBiZSBvZiBmb3JtIHtwbGF5ZXIxOnttb3J0Z2FnZToxMH19XHJcblx0XHRcdHZhciBsZW5kZXIgPSByZWdpc3RyeS5wbGF5ZXJzW3BsYXllci5pZF0uYmFsYW5jZVNoZWV0LmFzc2V0c1xyXG5cdFx0XHRPYmplY3QuZW50cmllcyhsb2FuT2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uKGxvYW5Ubykge1xyXG5cdFx0XHRcdHZhciBkZWJ0cztcclxuXHRcdFx0XHRsZW5kZXJbbG9hblRvWzBdXSA/XHJcblx0XHRcdFx0XHRkZWJ0cyA9IGxlbmRlcltsb2FuVG9bMF1dIDogZGVidHMgPSBsZW5kZXJbbG9hblRvWzBdXSA9IHt9O1xyXG5cclxuXHRcdFx0XHRPYmplY3QuZW50cmllcyhsb2FuVG9bMV0pLmZvckVhY2goZnVuY3Rpb24obmV3TG9hbikge1xyXG5cdFx0XHRcdFx0ZGVidHNbbmV3TG9hblswXV0gPyBkZWJ0c1tuZXdMb2FuWzBdXSArPSBuZXdMb2FuWzFdIDogZGVidHNbbmV3TG9hblswXV0gPSBuZXdMb2FuWzFdXHJcblx0XHRcdFx0XHRyZWdpc3RyeS5wbGF5ZXJzW2xvYW5Ub1swXV0uYmFsYW5jZVNoZWV0LmxpYWJpbGl0aWVzW25ld0xvYW5bMF1dID8gcmVnaXN0cnkucGxheWVyc1tsb2FuVG9bMF1dLmJhbGFuY2VTaGVldFxyXG5cdFx0XHRcdFx0XHQubGlhYmlsaXRpZXNbbmV3TG9hblswXV0gKz0gbmV3TG9hblsxXSA6IHJlZ2lzdHJ5LnBsYXllcnNbbG9hblRvWzBdXS5iYWxhbmNlU2hlZXQubGlhYmlsaXRpZXNbXHJcblx0XHRcdFx0XHRcdFx0bmV3TG9hblswXV0gPSBuZXdMb2FuWzFdO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHJcblx0Ly8gVGhlIHBsdWdpbiBvYmplY3QuXHJcblx0dmFyIFBsdWdpbiA9IHtcclxuXHRcdG5hbWU6IFwiYmFsYW5jZS1zaGVldFwiLFxyXG5cclxuXHRcdC8vIE9wdGlvbiB0byBpbml0aWFsaXplIGJ5IGNyZWF0aW5nICdwcm9wZXJ0eScgZm9yIGEgZ3JvdXAgb2YgcGxheWVycy5cclxuXHRcdGluaXQocGxheWVycyA9IFtdKSB7XHJcblx0XHRcdC8vIEFkZCBzb21lIHBsYXllcmxpc3QgZnVuY3Rpb25hbGl0eVxyXG5cdFx0XHRQbGF5ZXJMaXN0LnByb3RvdHlwZS5iYWxhbmNlU2hlZXRzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdFx0aWYgKHBsYXllci5iYWxhbmNlU2hlZXQpIHJldHVybiBwbGF5ZXIuaW50ZXJmYWNlLmJhbGFuY2VTaGVldCgpO1xyXG5cdFx0XHRcdFx0ZWxzZSByZXR1cm4gbnVsbDtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0UGxheWVyTGlzdC5wcm90b3R5cGUuYXNzZXRzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdFx0aWYgKHBsYXllci5iYWxhbmNlU2hlZXQpIHJldHVybiBwbGF5ZXIuaW50ZXJmYWNlLmJhbGFuY2VTaGVldCgpLmFzc2V0cztcclxuXHRcdFx0XHRcdGVsc2UgcmV0dXJuIG51bGw7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdFBsYXllckxpc3QucHJvdG90eXBlLmxpYWJpbGl0aWVzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdFx0aWYgKHBsYXllci5iYWxhbmNlU2hlZXQpIHJldHVybiBwbGF5ZXIuaW50ZXJmYWNlLmJhbGFuY2VTaGVldCgpLmxpYWJpbGl0aWVzO1xyXG5cdFx0XHRcdFx0ZWxzZSByZXR1cm4gbnVsbDtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0UGxheWVyTGlzdC5wcm90b3R5cGUubmV0V29ydGggPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0XHRpZiAocGxheWVyLmJhbGFuY2VTaGVldCkgcmV0dXJuIHBsYXllci5uZXRXb3J0aCgpO1xyXG5cdFx0XHRcdFx0ZWxzZSByZXR1cm4gbnVsbDtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0UGxheWVyTGlzdC5wcm90b3R5cGUuemVyb0JhbGFuY2VTaGVldHMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR0aGlzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0XHRhZGRFbnRyaWVzKHBsYXllcilcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQWRkIGJzIGZvciBzcGVjaWZpZWQgcGxheWVyc1xyXG5cdFx0XHRwbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0YWRkRW50cmllcyhyZWdpc3RyeS5wbGF5ZXJzW3BsYXllci5pZCgpXSk7XHJcblx0XHRcdH0pXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIElmIHdlJ3ZlIGluaXQtZWQgYWxyZWR5LCBqdXN0IGFkZCBicydzIHRvIHRoZSBjdXJyZW50IHBsYXllciBsaXN0IGlmIHRoZXkgZG9uJ3QgaGF2ZSBhbHJlYWR5XHJcblx0XHRyZXF1aXJlKHBsYXllcnMgPSBbXSkge1xyXG5cdFx0XHRwbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0aWYgKCFwbGF5ZXIuYmFsYW5jZVNoZWV0KSBhZGRFbnRyaWVzKHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyLmlkKCldKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdHN0b3AoKSB7XHJcblx0XHRcdC8vIHJlbW92ZSBwcm90b3R5cGUgYWRkRW50cmllc1xyXG5cdFx0XHRkZWxldGUgUGxheWVyTGlzdC5wcm90b3R5cGUuYmFsYW5jZVNoZWV0cztcclxuXHRcdFx0ZGVsZXRlIFBsYXllckxpc3QucHJvdG90eXBlLmFzc2V0cztcclxuXHRcdFx0ZGVsZXRlIFBsYXllckxpc3QucHJvdG90eXBlLmxpYWJpbGl0aWVzO1xyXG5cdFx0XHRkZWxldGUgUGxheWVyTGlzdC5wcm90b3R5cGUubmV0V29ydGg7XHJcblxyXG5cdFx0XHQvLyBkZWxldGUgYmFsYW5jZSBzaGVldCBwcm9wZXJ0aWVzIGZyb20gZXZlcnkgcGxheWVyIGFuZCBpbnRlcmZhY2UuXHJcblx0XHRcdGdhbWVQb3B1bGF0aW9uKCkuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLmJhbGFuY2VTaGVldDtcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLm5ldFdvcnRoO1xyXG5cdFx0XHRcdGRlbGV0ZSBwbGF5ZXIuaW50ZXJmYWNlLmJhbGFuY2VTaGVldDtcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLmludGVyZmFjZS5uZXRXb3J0aDtcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLmludGVyZmFjZS5lbmRvd0Fzc2V0cztcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLmludGVyZmFjZS5sZW5kO1xyXG5cdFx0XHR9KVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBjcmVhdGUgcHJvcGVydHkgYW5kIGludGVyZmFjZSBmdW5jdGlvbiB3aGVuIHBsYXllciBpcyBjcmVhdGVkXHJcblx0XHQncGxheWVyLWNyZWF0ZSc6IGFkZEVudHJpZXMsXHJcblxyXG5cdFx0Ly8gQmxhbmsgcHJvcGVydHkgd2hlbiBwbGF5ZXIgaXMgcmUtaW5pdGlhbGl6ZWRcclxuXHRcdFwicGxheWVyLXJlaW5pdGlhbGl6ZVwiIChwbGF5ZXIpIHtcclxuXHRcdFx0cGxheWVyLmJhbGFuY2VTaGVldCA9IHsgYXNzZXRzOiBbXSwgbGlhYmlsaXRpZXM6IFtdIH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBQbHVnaW47XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhbGFuY2VTaGVldDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBnYW1lIHBpZWNlc1xyXG52YXIgcHJpc29uZXJEaWxlbW1hID0gcmVxdWlyZShcIi4vaXRlcmF0ZWQtcHJpc29uZXItZGlsZW1tYVwiKS5jcmVhdGVHZW5lcmF0b3I7XHJcbnZhciByb3VuZFJvYmluID0gcmVxdWlyZShcIi4vcm91bmQtcm9iaW5cIik7XHJcblxyXG4vLyBOYXNoSlMgZW5naW5lIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG52YXIgeyBMb29wIH0gPSBFbmdpbmUuRnJvbnRlbmQuUGxheWFibGVzO1xyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lV3JhcHBlciB9ID0gRW5naW5lLkJhY2tlbmQuSGVscGVyRnVuY3Rpb25zKFwic3RvY2stZ2FtZXNcIilcclxudmFyIHsgZ2VuZXJhdGVQb3B1bGF0aW9uIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJ0b3VybmFtZW50XCIpO1xyXG5cclxuLy8gUG9wdWxhdGlvbiBpbnRlcmZhY2VzXHJcbnZhciB7IFBvcHVsYXRpb24gfSA9IEVuZ2luZS5Gcm9udGVuZC5Qb3B1bGF0aW9uO1xyXG5cclxuXHJcbnZhciBBeGVscm9kVG91cm5hbWVudCA9IGdhbWVXcmFwcGVyKGZ1bmN0aW9uKHBsYXllcnMsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHZhciB7IGdlbmVyYXRlUGxheWVycyA9IHRydWUsIHJlcGVhdHMgPSA1LCBnYW1lTGVuZ3RoID0gMjAwIH0gPSBwYXJhbWV0ZXJzO1xyXG5cclxuXHQvLyBFaXRoZXIgY3JlYXRlIGFuIGVudGlyZSBwb3B1bGF0aW9uXHJcblx0aWYgKGdlbmVyYXRlUGxheWVycykge1xyXG5cdFx0Ly8gR2V0IHR3byBzZXRzIG9mIHBsYXllcnMuIFRoZSBzZWNvbmQgaXMgc28gcGxheWVycyBjYW4gcGxheSB0aGVtc2VsdmVzXHJcblx0XHRwbGF5ZXJzID0gZ2VuZXJhdGVQb3B1bGF0aW9uKCk7XHJcblx0XHR2YXIgY29waWVzID0gZ2VuZXJhdGVQb3B1bGF0aW9uKCk7XHJcblx0XHRwYXJhbWV0ZXJzLmNvcGllcyA9IGNvcGllcztcclxuXHR9XHJcblxyXG5cdC8vIG9yIHVzZSB0aGUgc3VwcGxpZWQgcGxheWVyc1xyXG5cdGVsc2UgaWYgKHBsYXllcnMpIHtcclxuXHRcdC8vIGRvIG5vdGhpbmdcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gb3IgdXNlIHRoZSBwbGF5ZXJzIGFscmVhZHkgcHJlc2VudFxyXG5cdFx0cGxheWVycyA9IFBvcHVsYXRpb24oKS5vbmx5QWxpdmUoKS5vbmx5QXZhaWxhYmxlKCk7XHJcblx0fVxyXG5cclxuXHQvLyBhc3NpZ24gcGFyYW1ldGVycyBhbmQgZ2VuZXJhdGUgdGhlIGdhbWVcclxuXHRwYXJhbWV0ZXJzLmluaXRpYWxpemVQbGF5ZXJzID0gcGxheWVycztcclxuXHR2YXIgaXRlcmF0aW9uID0gcm91bmRSb2JpbihwbGF5ZXJzLCBwcmlzb25lckRpbGVtbWEoZ2FtZUxlbmd0aCksIHBhcmFtZXRlcnMpO1xyXG5cclxuXHRyZXR1cm4gTG9vcChpdGVyYXRpb24sIHJlcGVhdHMsIHsgaWQ6IFwiQXhlbHJvZC1Ub3VybmFtZW50XCIgfSk7XHJcbn0pO1xyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEF4ZWxyb2RUb3VybmFtZW50O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vYmFzZSBnYW1lXHJcbnZhciBUd29QbGF5ZXJOb3JtYWwgPSByZXF1aXJlKFwiLi9zaW1wbGUtbm9ybWFsXCIpO1xyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lV3JhcHBlciB9ID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIikuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKVxyXG5cclxuXHJcbi8vIEJhdHRsZSBvZiB0aGUgU2V4ZXNcclxudmFyIEJhdHRsZU9mVGhlU2V4ZXMgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRwYXJhbWV0ZXJzLmlkID0gcGFyYW1ldGVycy5pZCB8fCBcIkJhdHRsZS1vZi10aGUtU2V4ZXNcIjtcclxuXHJcblx0dmFyIGNob2ljZXMgPSBbXHJcblx0XHRbXCJPcGVyYVwiLCBcIkZvb3RiYWxsXCJdLFxyXG5cdFx0W1wiT3BlcmFcIiwgXCJGb290YmFsbFwiXVxyXG5cdF07XHJcblx0dmFyIHBheW9mZnMgPSBbXHJcblx0XHRbXHJcblx0XHRcdFsyLCAxXSxcclxuXHRcdFx0WzAsIDBdXHJcblx0XHRdLFxyXG5cdFx0W1xyXG5cdFx0XHRbMCwgMF0sXHJcblx0XHRcdFsxLCAyXVxyXG5cdFx0XVxyXG5cdF07XHJcblxyXG5cdHJldHVybiBUd29QbGF5ZXJOb3JtYWwocGxheWVycywgY2hvaWNlcywgcGF5b2ZmcywgcGFyYW1ldGVycyk7XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYXR0bGVPZlRoZVNleGVzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIE5hc2hKUyBlbmdpbmUgY29tcG9uZW50c1xyXG52YXIgRW5naW5lID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIilcclxuXHJcbi8vIFVzZXIgZGF0YVxyXG52YXIgeyBQb3B1bGF0aW9uIH0gPSBFbmdpbmUuRnJvbnRlbmRcclxuXHJcbi8vIFBsYXlhYmxlc1xyXG52YXIgeyBMYW1iZGEsIFNpbXVsdGFuZW91cywgU2VxdWVuY2UsIExvb3AgfSA9IEVuZ2luZS5Gcm9udGVuZC5QbGF5YWJsZXM7XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlzRnVuY3Rpb24gfSA9IEVuZ2luZS5CYWNrZW5kLkhlbHBlckZ1bmN0aW9ucyhcImdlbmVyYWxcIik7XHJcblxyXG5cclxuLy9DdWx0dXJhbCBldm9sdXRpb25cclxuLy9cclxuLy8gVE9ETzogYWRkIGluc3RydWN0aW9ucyBoZXJlXHJcbmZ1bmN0aW9uIEN1bHR1cmFsRXZvbHV0aW9uKGdhbWVHZW5lcmF0b3IsIG51bUxvb3BzID0gMSwge1xyXG5cdGlkID0gXCJDdWx0dXJhbEV2b2x1dGlvblwiLFxyXG5cdGdhbWVQcm9iYWJpbGl0eSA9IC4yNSxcclxuXHRwYWlyUHJvYmFiaWxpdHkgPSAuMjUsXHJcblx0Z2VuZXJhdGVQb3B1bGF0aW9uID0gbnVsbCxcclxuXHRsb29wID0gdHJ1ZVxyXG59ID0ge30pIHtcclxuXHJcblx0aWYgKGxvb3AgJiYgaXNOYU4obnVtTG9vcHMpKSB0aHJvdyBuZXcgRXJyb3IoXCJDdWx0dXJhbEV2b2x1dGlvbiBhcmd1bWVudCAnbnVtTG9vcHMgbXVzdCBiZSBhIG51bWJlclwiKTtcclxuXHRpZiAoIWlzRnVuY3Rpb24oZ2FtZUdlbmVyYXRvcikpIHRocm93IG5ldyBFcnJvcihcclxuXHRcdFwiQ3VsdHVyYWxFdm9sdXRpb24gYXJndW1lbnQgJ2dhbWVHZW5lcmF0b3InIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcclxuXHRpZiAoaXNOYU4oZ2FtZVByb2JhYmlsaXR5KSB8fCBnYW1lUHJvYmFiaWxpdHkgPCAwIHx8IGdhbWVQcm9iYWJpbGl0eSA+IDEpIHRocm93IG5ldyBFcnJvcihcclxuXHRcdFwiQ3VsdHVyYWxFdm9sdXRpb24gYXJndW1lbnQgJ2dhbWVQcm9iYWJpbGl0eScgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDFcIik7XHJcblx0aWYgKGlzTmFOKHBhaXJQcm9iYWJpbGl0eSkgfHwgcGFpclByb2JhYmlsaXR5IDwgMCB8fCBwYWlyUHJvYmFiaWxpdHkgPiAxKSB0aHJvdyBuZXcgRXJyb3IoXHJcblx0XHRcIkN1bHR1cmFsRXZvbHV0aW9uIGFyZ3VtZW50ICdwYWlyUHJvYmFiaWxpdHknIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxXCIpO1xyXG5cclxuXHQvLyBHZW5lcmF0ZSBwb3B1bGF0aW9uIGlmIHVzZXIgd2FudHMgdXMgdG8uXHJcblx0aWYgKGlzRnVuY3Rpb24oZ2VuZXJhdGVQb3B1bGF0aW9uKSkgZ2VuZXJhdGVQb3B1bGF0aW9uKCk7XHJcblxyXG5cdC8vUmVzZXQgdGhlIHNjb3JlcyBlYWNoIHJvdW5kLlxyXG5cdHZhciBSZXNldFNjb3JlcyA9IExhbWJkYShmdW5jdGlvbigpIHtcclxuXHRcdFBvcHVsYXRpb24oKS5vbmx5QWxpdmUoKS5yZXNldFNjb3JlcygpO1xyXG5cdH0pO1xyXG5cclxuXHQvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIG1hdGNoZXNcclxuXHR2YXIgbiA9IE1hdGguZmxvb3IoUG9wdWxhdGlvbigpLm9ubHlBbGl2ZSgpLmxlbmd0aCAqIGdhbWVQcm9iYWJpbGl0eSk7XHJcblxyXG5cdC8vIENyZWF0ZSBtYXRjaGVzLlxyXG5cdHZhciBtYXRjaGVzID0gWy4uLkFycmF5KG4pXVxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRtYXRjaGVzW2ldID0gZ2FtZUdlbmVyYXRvcigpO1xyXG5cdFx0aWYgKCFtYXRjaGVzW2ldLnBsYXkpIHRocm93IG5ldyBFcnJvcihcIkN1bHR1cmFsRXZvbHV0aW9uIGFyZ3VtZW50ICdnYW1lR2VuZXJhdG9yJyBtdXN0IHJldHVybiBhIFBsYXlhYmxlXCIpO1xyXG5cdH1cclxuXHJcblx0Ly9SdW4gYWxsIG1hdGNoZXMgc2ltdWx0YW5lb3VzbHlcclxuXHR2YXIgUm91bmQgPSBTaW11bHRhbmVvdXMobWF0Y2hlcyk7XHJcblxyXG5cdC8vQ2FsY3VsYXRlIG51bWJlciBvZiBwYWlyaW5nc1xyXG5cdHZhciBuID0gTWF0aC5mbG9vcihQb3B1bGF0aW9uKCkub25seUFsaXZlKCkubGVuZ3RoICogcGFpclByb2JhYmlsaXR5KVxyXG5cclxuXHQvL0NyZWF0ZSBwYWlyaW5nc1xyXG5cdHZhciBwYWlyaW5ncyA9IFsuLi5BcnJheShuKV07XHJcblx0Zm9yIChpID0gMDsgaSA8IG47IGkrKykge1xyXG5cclxuXHRcdHBhaXJpbmdzW2ldID0gTGFtYmRhKGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0Ly9GaW5kIHNvbWUgYXZhaWxhYmxlIHBsYXllcnNcclxuXHRcdFx0dmFyIHBvb2wgPSBQb3B1bGF0aW9uKCkub25seUFsaXZlKCkub25seUF2YWlsYWJsZSgpO1xyXG5cdFx0XHR2YXIgcDEgPSBwb29sW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvb2wubGVuZ3RoKV07XHJcblx0XHRcdHZhciBwMiA9IHBvb2xbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9vbC5sZW5ndGgpXTtcclxuXHJcblx0XHRcdC8vTWFyayB0aGVtIGJ1c3lcclxuXHRcdFx0cDEuYnVzeSgpO1xyXG5cdFx0XHRwMi5idXN5KCk7XHJcblxyXG5cdFx0XHQvLyBBc3NpZ24gc3RyYXRlZ3kgb2YgcGxheWVyIHdpdGggaGlnaGVyIHNjb3JlXHJcblx0XHRcdGlmIChwMS5zY29yZSgpID4gcDIuc2NvcmUoKSkgcDIuYXNzaWduKHAxLnN0cmF0ZWd5KCkpO1xyXG5cdFx0XHRlbHNlIGlmIChwMS5zY29yZSgpID09IHAyLnNjb3JlKCkpIG51bGw7XHJcblx0XHRcdGVsc2UgcDEuYXNzaWduKHAyLnN0cmF0ZWd5KCkpO1xyXG5cclxuXHRcdFx0Ly9SZXR1cm4gdmFsdWUgb2YgcGxheWVyIGlkcywgc28gdGhlIGxvZyBtYWtlcyBzb21lIHNlbnNlLlxyXG5cdFx0XHRyZXR1cm4gW3AxLmlkKCksIHAyLmlkKCldO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvLyBSdW4gcGFpcmluZ3Mgc2ltdWx0YW5lb3VzbHlcclxuXHR2YXIgUGFpcmluZyA9IFNpbXVsdGFuZW91cyhwYWlyaW5ncyk7XHJcblxyXG5cdC8vIEFmdGVyIHBhaXJpbmdzLCBtYXJrIGFsbCBwbGF5ZXJzIGFzIGF2YWlsYWJsZS5cclxuXHR2YXIgUmVsZWFzZVBsYXllcnMgPSBMYW1iZGEoZnVuY3Rpb24oKSB7XHJcblx0XHRQb3B1bGF0aW9uKCkub25seUFsaXZlKCkucmVsZWFzZSgpO1xyXG5cdH0pO1xyXG5cclxuXHQvLyBEZWZpbmUgdGhlIGdhbWUuXHJcblx0Um91bmQoUmVzZXRTY29yZXMpO1xyXG5cdFBhaXJpbmcoUm91bmQpO1xyXG5cdFJlbGVhc2VQbGF5ZXJzKFBhaXJpbmcpO1xyXG5cdHZhciBJdGVyYXRpb24gPSBTZXF1ZW5jZShSZXNldFNjb3JlcywgUmVsZWFzZVBsYXllcnMpO1xyXG5cclxuXHQvLyBVc2VyIGNhbiBzZXQgbG9vcCBwYXJhbWV0ZXIgdG8gZmFsc2UsIHRvIGF2b2lkIHdyYXBwaW5nIHRoaXMgaW4gYSBsb29wLlxyXG5cdGlmIChsb29wKVxyXG5cdFx0dmFyIENFID0gTG9vcChJdGVyYXRpb24sIG51bUxvb3BzLCB7IHBsYXlhYmxlUGFyYW1ldGVyczogeyBpbml0aWFsaXplUGxheWVyczogdHJ1ZSB9IH0pO1xyXG5cdGVsc2VcclxuXHRcdHZhciBDRSA9IEl0ZXJhdGlvbjtcclxuXHJcblx0cmV0dXJuIENFO1xyXG59XHJcblxyXG4vL1RPRE86IGZpeCBwYXJhbWV0ZXJzLiBVc2VyIHNob3VsZCBiZSBhYmxlIHRvIHN1cHBseSBwYXJhbWV0ZXJzIHdoaWNoIGVpdGhlclxyXG4vLyBlbmQgdXAgYXMgcGFyYW1ldGVycyBmb3IgdGhlIExvb3Agb3IgdGhlIFNlcXVlbmNlLlxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3VsdHVyYWxFdm9sdXRpb247XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gYmFzZSBnYW1lXHJcbnZhciBUd29QbGF5ZXJOb3JtYWwgPSByZXF1aXJlKFwiLi9zaW1wbGUtbm9ybWFsXCIpLlR3b1BsYXllck5vcm1hbDtcclxuXHJcbi8vIE5hc2hKUyBlbmdpbmUgY29tcG9uZW50c1xyXG52YXIgRW5naW5lID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIilcclxuXHJcbi8vIE5hc2ggZW5naW5lIGNvbXBvbmVudHNcclxudmFyIHsgU2VxdWVuY2UsIExhbWJkYSB9ID0gRW5naW5lLkZyb250ZW5kLlBsYXlhYmxlcztcclxuXHJcbi8vIEdhbWUgc3RhdGVcclxudmFyIHsgcmVnaXN0cnkgfSA9IEVuZ2luZS5CYWNrZW5kLlN0YXRlXHJcblxyXG4vLyBoZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKVxyXG5cclxuLy8gV2UnbGwgbmVlZCB0aGUgJ2JhbGFuY2Utc2hlZXQnIHBsdWdpblxyXG52YXIgUGx1Z2luTWFuYWdlciA9IEVuZ2luZS5CYWNrZW5kLlBsdWdpbk1hbmFnZXI7XHJcblxyXG5mdW5jdGlvbiBpbnZlcnRUZXJtcyh0ZXJtc09mVHJhZGUpIHtcclxuXHR2YXIgaW52ZXJzZSA9IHt9XHJcblx0T2JqZWN0LmVudHJpZXModGVybXNPZlRyYWRlKS5mb3JFYWNoKGZ1bmN0aW9uKHRlcm0pIHtcclxuXHRcdGlmICh0ZXJtWzBdID09IFwiYm9ycm93XCIpIHtcclxuXHRcdFx0aW52ZXJzZS5sZW5kID0gdGVybVsxXVxyXG5cdFx0fSBlbHNlIGlmICh0ZXJtWzBdID09IFwibGVuZFwiKSB7XHJcblx0XHRcdGludmVyc2UuYm9ycm93ID0gdGVybVsxXVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW52ZXJzZVt0ZXJtWzBdXSA9IHRlcm1bMV0gKiAtMVxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdHJldHVybiBpbnZlcnNlO1xyXG59XHJcblxyXG4vLyB0ZXJtc09mVHJhZGUgc2hvdWxkIGJlIGFuIG9iamVjdCByZWZsZWN0aW5nIHRoZSBvdXRjb21lcyBmb3IgcGxheWVyIDEuXHJcbi8vIEV4YW1wbGUge2FwcGxlOjIsIG9yYW5nZTotMn0uIFRvIGJvcnJvdyBvciBsZW5kLCBjcmVhdGUgYSBzdWItb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGxvYW4gdGVybXMuXHJcbi8vIGVnIHthcHBsZToyLCBib3Jyb3c6e0lPVTo1fX0sIG9yIHtjb3VjaDotMTAsIGxlbmQ6eydjcmVkaXQgY2FyZCc6NTB9fVxyXG52YXIgRXhjaGFuZ2UgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCB0ZXJtc09mVHJhZGUgPSB7fSwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIHsgdXRpbGl0eUZ1bmN0aW9ucywgdXRpbGl0eU1vZGUgPSBcImFic29sdXRlXCIsIGluaXRpYWxFbmRvd21lbnQgPSBbe30sIHt9XSB9ID0gcGFyYW1ldGVycyAvL3V0aWxpdHlGdW5jdGlvbnMgc2hvdWxkIGJlIGFuIGFycmF5IG9mIDIgZnVuY3Rpb25zLCB3aGljaCB0YWtlIGEgcmVzdWx0cyBvYmplY3QgYW5kIHJldHVybiBhIGNoYW5nZSBpbiB1dGlsaXR5XHJcblx0cGFyYW1ldGVycy5pZCA9IFwiRXhjaGFuZ2VcIiB8fCBwYXJhbWV0ZXJzLmlkO1xyXG5cclxuXHJcblxyXG5cclxuXHQvLyBUbyBwbGF5IHRoaXMgZ2FtZSwgcGxheWVycyB3aWxsIG5lZWQgYSBiYWxhbmNlIHNoZWV0LiBUaGlzIHBsdWdpbiB3aWxsIGFkZCBiYWxhbmNlIHNoZWV0cyB0byB0aGUgcGxheWVycyxcclxuXHQvLyBhcyB3ZWxsIGFzIGVuc3VyZSB0aGF0IG5ldyBwbGF5ZXJzIGFyZSBjcmVhdGVkIHdpdGggb25lLCBhbmQgdGhhdCB0aGV5IGFyZSByZS1pbml0aWFsaXplZCBwcm9wZXJseS5cclxuXHR2YXIgYmFsYW5jZVNoZWV0ID0gUGx1Z2luTWFuYWdlci5wYWNrYWdlKFwiYmFsYW5jZS1zaGVldC1jb21wbGV4XCIpLnJlcXVpcmUocGxheWVycyk7XHJcblx0YmFsYW5jZVNoZWV0LnNldHRpbmdzKHsgY2xlYW5aZXJvczogZmFsc2UgfSlcclxuXHJcblx0dmFyIHAxID0gcmVnaXN0cnkucGxheWVyc1twbGF5ZXJzWzBdLmlkKCldO1xyXG5cdHZhciBwMiA9IHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyc1sxXS5pZCgpXTtcclxuXHJcblx0Ly8gRG8gaW5pdGlhbCBlbmRvd21lbnRzIGlmIHRoZXJlIGFyZSBhbnkuIEZvcm1hdCBzYW1lIGFzIGZvciB0ZXJtcyBvZiB0cmFkZS5cclxuXHRpbml0aWFsRW5kb3dtZW50LmZvckVhY2goZnVuY3Rpb24oZW5kb3dtZW50LCBpbmRleCkge1xyXG5cdFx0dmFyIHBsYXllciA9IHBsYXllcnNbaW5kZXhdXHJcblx0XHR2YXIgaW52ZXJ0UGxheWVyID0gcGxheWVyc1tOdW1iZXIoIWluZGV4KV1cclxuXHRcdE9iamVjdC5lbnRyaWVzKGVuZG93bWVudCkuZm9yRWFjaChmdW5jdGlvbih0ZXJtKSB7XHJcblx0XHRcdGlmICh0ZXJtWzBdID09IFwiYm9ycm93XCIpIHtcclxuXHRcdFx0XHR2YXIgbG9hblRlcm1zID0gT2JqZWN0LmVudHJpZXModGVybVsxXSlbMF1cclxuXHRcdFx0XHRuZXcgYmFsYW5jZVNoZWV0LkZpbmFuY2lhbENsYWltKGludmVydFBsYXllciwgcGxheWVyLCBsb2FuVGVybXNbMV0sIGxvYW5UZXJtc1swXSlcclxuXHRcdFx0fSBlbHNlIGlmICh0ZXJtWzBdID09IFwibGVuZFwiKSB7XHJcblx0XHRcdFx0dmFyIGxvYW5UZXJtcyA9IE9iamVjdC5lbnRyaWVzKHRlcm1bMV0pWzBdXHJcblx0XHRcdFx0bmV3IGJhbGFuY2VTaGVldC5GaW5hbmNpYWxDbGFpbShwbGF5ZXIsIGludmVydFBsYXllciwgbG9hblRlcm1zWzFdLCBsb2FuVGVybXNbMF0pXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bmV3IGJhbGFuY2VTaGVldC5SZWFsQ2xhaW0ocGxheWVyLCB0ZXJtWzBdLCB0ZXJtWzFdKVxyXG5cdFx0XHR9XHJcblx0XHR9KVxyXG5cdH0pXHJcblxyXG5cdC8vIFRoZSBhY3R1YWwgcGxheWFibGVcclxuXHR2YXIgRGVjaXNpb24gPSBUd29QbGF5ZXJOb3JtYWwocGxheWVycywgW1xyXG5cdFx0W1wiQWNjZXB0XCIsIFwiUmVqZWN0XCJdLFxyXG5cdFx0W1wiQWNjZXB0XCIsIFwiUmVqZWN0XCJdXHJcblx0XSwgbnVsbCwge1xyXG5cdFx0aWQ6IFwiRGVjaXNpb25cIixcclxuXHRcdGluZm9ybWF0aW9uRmlsdGVyOiBmdW5jdGlvbihpbmZvKSB7IC8vVE9ETyBtaWdodCBuZWVkIHRvIHdyYXAgdXNlci1zdXBwbGllZCBpbmZvcm1hdGlvbkZpbHRlcj9cclxuXHRcdFx0aW5mby50ZXJtc09mVHJhZGUgPSB7XHJcblx0XHRcdFx0W3AxLmlkXTogdGVybXNPZlRyYWRlLFxyXG5cdFx0XHRcdFtwMi5pZF06IGludmVydFRlcm1zKHRlcm1zT2ZUcmFkZSlcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gaW5mbztcclxuXHRcdH1cclxuXHR9KVxyXG5cclxuXHQvLyBEaXN0cmlidXRlIHRoZSBnb29kc1xyXG5cdHZhciBEaXN0cmlidXRlID0gTGFtYmRhKGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciByZXN1bHRzID0gW107XHJcblxyXG5cdFx0T2JqZWN0LmVudHJpZXModGVybXNPZlRyYWRlKS5mb3JFYWNoKGZ1bmN0aW9uKHRlcm0pIHtcclxuXHRcdFx0aWYgKHRlcm1bMF0gPT0gXCJib3Jyb3dcIikge1xyXG5cdFx0XHRcdHZhciBsb2FuVGVybXMgPSBPYmplY3QuZW50cmllcyh0ZXJtWzFdKVswXVxyXG5cdFx0XHRcdHZhciBsb2FuID0gbmV3IGJhbGFuY2VTaGVldC5GaW5hbmNpYWxDbGFpbShwMi5pbnRlcmZhY2UsIHAxLmludGVyZmFjZSwgbG9hblRlcm1zWzFdLCBsb2FuVGVybXNbMF0pXHJcblxyXG5cdFx0XHRcdHJlc3VsdHMucHVzaCh7XHJcblx0XHRcdFx0XHRwbGF5ZXI6IHAxLmlkLFxyXG5cdFx0XHRcdFx0Ym9ycm93OiB7XHJcblx0XHRcdFx0XHRcdFtsb2FuVGVybXNbMF1dOiBsb2FuVGVybXNbMV1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0cmVzdWx0cy5wdXNoKHtcclxuXHRcdFx0XHRcdHBsYXllcjogcDIuaWQsXHJcblx0XHRcdFx0XHRsZW5kOiB7XHJcblx0XHRcdFx0XHRcdFtwMS5pZF06IHtcclxuXHRcdFx0XHRcdFx0XHRbbG9hblRlcm1zWzBdXTogbG9hblRlcm1zWzFdXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAodGVybVswXSA9PSBcImxlbmRcIikge1xyXG5cdFx0XHRcdHZhciBsb2FuVGVybXMgPSBPYmplY3QuZW50cmllcyh0ZXJtWzFdKVswXVxyXG5cdFx0XHRcdHZhciBsb2FuID0gbmV3IGJhbGFuY2VTaGVldC5GaW5hbmNpYWxDbGFpbShwMS5pbnRlcmZhY2UsIHAyLmludGVyZmFjZSwgbG9hblRlcm1zWzFdLCBsb2FuVGVybXNbMF0pXHJcblxyXG5cdFx0XHRcdHJlc3VsdHMucHVzaCh7XHJcblx0XHRcdFx0XHRwbGF5ZXI6IHAyLmlkLFxyXG5cdFx0XHRcdFx0Ym9ycm93OiB7XHJcblx0XHRcdFx0XHRcdFtsb2FuVGVybXNbMF1dOiBsb2FuVGVybXNbMV1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0cmVzdWx0cy5wdXNoKHtcclxuXHRcdFx0XHRcdHBsYXllcjogcDEuaWQsXHJcblx0XHRcdFx0XHRsZW5kOiB7XHJcblx0XHRcdFx0XHRcdFtwMi5pZF06IHtcclxuXHRcdFx0XHRcdFx0XHRbbG9hblRlcm1zWzBdXTogbG9hblRlcm1zWzFdXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGdvb2QgPSBuZXcgYmFsYW5jZVNoZWV0LlJlYWxDbGFpbShwMS5pbnRlcmZhY2UsIHRlcm1bMF0sIDApXHJcblx0XHRcdFx0Z29vZC50cmFuc2ZlcihwMi5pbnRlcmZhY2UsIHRlcm1bMV0gKiAtMSlcclxuXHJcblx0XHRcdFx0cmVzdWx0cy5wdXNoKHsgcGxheWVyOiBwMS5pZCwgW3Rlcm1bMF1dOiB0ZXJtWzFdIH0pO1xyXG5cdFx0XHRcdHJlc3VsdHMucHVzaCh7IHBsYXllcjogcDIuaWQsIFt0ZXJtWzBdXTogLTEgKiB0ZXJtWzFdIH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblxyXG5cdFx0aWYgKHV0aWxpdHlGdW5jdGlvbnMpIHtcclxuXHJcblx0XHRcdHAxLnNjb3JlID0gdXRpbGl0eU1vZGUudG9Mb3dlckNhc2UoKSA9PSBcInJlbGF0aXZlXCIgPyBwMS5zY29yZSArIHV0aWxpdHlGdW5jdGlvbnNbMF0ocmVzdWx0cykgOlxyXG5cdFx0XHRcdHV0aWxpdHlGdW5jdGlvbnNbMF0ocmVzdWx0cylcclxuXHRcdFx0cDIuc2NvcmUgPSB1dGlsaXR5TW9kZS50b0xvd2VyQ2FzZSgpID09IFwicmVsYXRpdmVcIiA/IHAyLnNjb3JlICsgdXRpbGl0eUZ1bmN0aW9uc1sxXShyZXN1bHRzKSA6XHJcblx0XHRcdFx0dXRpbGl0eUZ1bmN0aW9uc1sxXShyZXN1bHRzKVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHRzO1xyXG5cdH0sIHsgaWQ6IFwiRGlzdHJpYnV0aW9uXCIgfSk7XHJcblxyXG5cdC8vQnV0IG9ubHkgZG8gaXQgaWYgdGhlIHRyYWRlIGdvZXMgdGhyb3VnaC5cclxuXHREaXN0cmlidXRlKERlY2lzaW9uLkFjY2VwdC5BY2NlcHQoKSlcclxuXHJcblxyXG5cclxuXHRyZXR1cm4gU2VxdWVuY2UoRGVjaXNpb24sIERpc3RyaWJ1dGUsIHBhcmFtZXRlcnMpO1xyXG59LCB7XHJcblx0YXJndW1lbnRWYWxpZGF0b3IocGxheWVycywgdGVybXNPZlRyYWRlKSB7XHJcblx0XHQvLyBUT0RPOiB2YWxpZGF0ZSBwYXJhbWV0ZXJzXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXhjaGFuZ2U7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIFN0b2NrR2FtZXMgPSB7XHJcblx0Ly9HYW1lIHNrZWxldG9uc1xyXG5cdFwiVHdvLVBsYXllciBOb3JtYWxcIjogcmVxdWlyZShcIi4vc2ltcGxlLW5vcm1hbFwiKS5Ud29QbGF5ZXJOb3JtYWwsXHJcblx0XCJOb3JtYWxcIjogcmVxdWlyZShcIi4vc2ltcGxlLW5vcm1hbFwiKS5Ob3JtYWwsXHJcblx0XCJTaW1wbGUgWmVyby1TdW1cIjogcmVxdWlyZShcIi4vc2ltcGxlLXplcm8tc3VtXCIpLFxyXG5cclxuXHQvLyBDbGFzc2ljIGdhbWVzXHJcblx0XCJCYXR0bGUgT2YgVGhlIFNleGVzXCI6IHJlcXVpcmUoXCIuL2JhdHRsZS1vZi10aGUtc2V4ZXNcIiksXHJcblx0XCJNYXRjaGluZyBQZW5uaWVzXCI6IHJlcXVpcmUoXCIuL21hdGNoaW5nLXBlbm5pZXNcIiksXHJcblx0XCJQcmlzb25lcidzIERpbGVtbWFcIjogcmVxdWlyZShcIi4vcHJpc29uZXItZGlsZW1tYVwiKSxcclxuXHRcIlJvY2stUGFwZXItU2Npc3NvcnNcIjogcmVxdWlyZShcIi4vcm9jay1wYXBlci1zY2lzc29yc1wiKSxcclxuXHJcblx0Ly8gSXRlcmF0ZWQgZ2FtZXNcclxuXHRcIkl0ZXJhdGVkXCI6IHJlcXVpcmUoXCIuL2l0ZXJhdGVkXCIpLFxyXG5cdFwiSXRlcmF0ZWQgUHJpc29uZXIncyBEaWxlbW1hXCI6IHJlcXVpcmUoXCIuL2l0ZXJhdGVkLXByaXNvbmVyLWRpbGVtbWFcIiksXHJcblxyXG5cdC8vIEV2b2x1dGlvbmFyeSBnYW1lc1xyXG5cdFwiQ3VsdHVyYWwgRXZvbHV0aW9uXCI6IHJlcXVpcmUoXCIuL2N1bHR1cmFsLWV2b2x1dGlvblwiKSxcclxuXHJcblx0Ly9Ub3VybmFtZW50c1xyXG5cdFwiUm91bmQgUm9iaW5cIjogcmVxdWlyZShcIi4vcm91bmQtcm9iaW5cIiksXHJcblx0XCJBeGVscm9kIFRvdXJuYW1lbnRcIjogcmVxdWlyZShcIi4vYXhlbHJvZC10b3VybmFtZW50XCIpLFxyXG5cclxuXHQvLyBQcm9iYWJpbGl0eSBUaGVvcnlcclxuXHRcIk1vbnR5IEhhbGxcIjogcmVxdWlyZShcIi4vbW9udHktaGFsbFwiKSxcclxuXHJcblx0Ly9OZW9jbGFzc2ljYWwgZWNvbm9taWNzXHJcblx0XCJFeGNoYW5nZVwiOiByZXF1aXJlKFwiLi9leGNoYW5nZS1jb21wbGV4XCIpLFxyXG5cclxuXHQvLyBGdW5jdGlvbiB0byBkaXNwbGF5IGxvYWRlZCBxdWVyeSBzaG9ydGN1dHMuXHJcblx0cXVlcmllcygpIHtcclxuXHRcdHJldHVybiBPYmplY3Qua2V5cyhyZWdpc3RyeS5xdWVyaWVzKS5tYXAoZnVuY3Rpb24ocXVlcnkpIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRbcXVlcnldOiByZWdpc3RyeS5xdWVyaWVzW3F1ZXJ5XS5kZXNjcmlwdGlvblxyXG5cdFx0XHR9XHJcblx0XHR9KVxyXG5cdH1cclxufTtcclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdG9ja0dhbWVzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIEJhc2UgZ2FtZVxyXG52YXIgcHJpc29uZXJEaWxlbW1hID0gcmVxdWlyZShcIi4vcHJpc29uZXItZGlsZW1tYVwiKS5jcmVhdGVHZW5lcmF0b3IoKTtcclxuXHJcbi8vIE5hc2hKUyBlbmdpbmUgY29tcG9uZW50c1xyXG52YXIgRW5naW5lID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIilcclxuXHJcbi8vIGdhbWUgZW5naW5lXHJcbnZhciB7IExvb3AgfSA9IEVuZ2luZS5Gcm9udGVuZC5QbGF5YWJsZXM7XHJcblxyXG4vLyBoZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKVxyXG5cclxuLy8gR2FtZSB1dGlsaXR5XHJcbnZhciBJdGVyYXRlZCA9IHJlcXVpcmUoXCIuL2l0ZXJhdGVkXCIpXHJcblxyXG5cclxuXHJcbnZhciBJdGVyYXRlZFByaXNvbmVyRGlsZW1tYSA9IGdhbWVXcmFwcGVyKGZ1bmN0aW9uKHBsYXllcnMsIG51bWJlckl0ZXJhdGlvbnMgPSA1MCwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0cmV0dXJuIEl0ZXJhdGVkKHBsYXllcnMsIHByaXNvbmVyRGlsZW1tYSwgXCJQcmlzb25lci1EaWxlbW1hXCIsIG51bWJlckl0ZXJhdGlvbnMsIHBhcmFtZXRlcnMpXHJcbn0sIHtcclxuXHRxdWVyaWVzOiBbe1xyXG5cdFx0XHRzaG9ydGN1dDogXCJASVBELWNob2ljZXNcIixcclxuXHRcdFx0cXVlcnk6IFwiJG1hcCgkLlthY3Rpb25dLnJlc3VsdHMsIGZ1bmN0aW9uKCRsKXskbC5yZXN1bHR9KVwiLFxyXG5cdFx0XHRkZXNjcmlwdGlvbjogXCJSZXN1bHRzLCBvcmdhbml6ZWQgYnkgcm91bmQuXCJcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdHNob3J0Y3V0OiBcIkBJUEQtcGxheWVyc1wiLFxyXG5cdFx0XHRxdWVyeTogXCIkbWFwKCQuW2FjdGlvbl0ucmVzdWx0cywgZnVuY3Rpb24oJGwpeyRsLnBsYXllcn0pXCIsXHJcblx0XHRcdGRlc2NyaXB0aW9uOiBcIlBsYXllcnMsIG9yZ2FuaXplZCBieSByb3VuZC5cIlxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0c2hvcnRjdXQ6IFwiQElQRC1wYXlvdXRzXCIsXHJcblx0XHRcdHF1ZXJ5OiBcIiQuYWN0aW9uLnBheW91dHNcIixcclxuXHRcdFx0ZGVzY3JpcHRpb246IFwiUGF5b3V0cywgYXMgYXJyYXkgb2Ygb2JqZWN0cy5cIlxyXG5cdFx0fVxyXG5cdF0sXHJcblx0c3RyYXRlZ3lMb2FkZXIoKSB7XHJcblx0XHRyZXR1cm4gW3tcclxuXHRcdFx0XHRuYW1lOiBcIlRpdCBGb3IgVGF0XCIsXHJcblx0XHRcdFx0ZGVzY3JpcHRpb246IFwiRG8gd2hhdGV2ZXIgeW91ciBvcHBvbmVudCBkaWQgbGFzdCB0dXJuLiBDb29wZXJhdGUgaWYgdGhpcyBpcyB0aGUgZmlyc3QgdHVybi5cIixcclxuXHRcdFx0XHRzdHJhdGVneTogZnVuY3Rpb24gdGl0Rm9yVGF0KCkge1xyXG5cdFx0XHRcdFx0dGhpcy5jaG9vc2UgPSBmdW5jdGlvbihjaG9pY2VzLCBpbmZvcm1hdGlvbikge1xyXG5cdFx0XHRcdFx0XHRpZiAoaW5mb3JtYXRpb24ub3Bwb25lbnQuaGlzdG9yeS5sZW5ndGgpIHJldHVybiBpbmZvcm1hdGlvbi5vcHBvbmVudC5oaXN0b3J5W2luZm9ybWF0aW9uLm9wcG9uZW50XHJcblx0XHRcdFx0XHRcdFx0XHQuaGlzdG9yeS5sZW5ndGggLSAxXVxyXG5cdFx0XHRcdFx0XHRcdC5yZXN1bHRcclxuXHRcdFx0XHRcdFx0ZWxzZSByZXR1cm4gXCJDb29wZXJhdGVcIjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdHtcclxuXHRcdFx0XHRuYW1lOiBcIkdydWRnZXJcIixcclxuXHRcdFx0XHRkZXNjcmlwdGlvbjogXCJDb29wZXJhdGUgdW50aWwgeW91ciBvcHBvbmVudCBkb2Vzbid0LCB0aGVuIERlZmVjdC5cIixcclxuXHRcdFx0XHRzdHJhdGVneTogZnVuY3Rpb24gZ3J1ZGdlcigpIHtcclxuXHRcdFx0XHRcdHRoaXMuY29vcGVyYXRpbmcgPSB0cnVlXHJcblxyXG5cdFx0XHRcdFx0dGhpcy5jaG9vc2UgPSBmdW5jdGlvbihjaG9pY2VzLCBpbmZvcm1hdGlvbikge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gSWYgb3Bwb25lbnQganVzdCBkZWZlY3RlZCwgdGhlbiBzdG9wIGNvb3BlcmF0aW5nXHJcblx0XHRcdFx0XHRcdGlmIChpbmZvcm1hdGlvbi5vcHBvbmVudC5oaXN0b3J5Lmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChpbmZvcm1hdGlvbi5vcHBvbmVudC5oaXN0b3J5W2luZm9ybWF0aW9uLm9wcG9uZW50Lmhpc3RvcnkubGVuZ3RoIC0gMV0ucmVzdWx0ID09IFwiRGVmZWN0XCIpIHRoaXNcclxuXHRcdFx0XHRcdFx0XHRcdC5jb29wZXJhdGluZyA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5jb29wZXJhdGluZykgcmV0dXJuIFwiQ29vcGVyYXRlXCI7XHJcblx0XHRcdFx0XHRcdGVsc2UgcmV0dXJuIFwiRGVmZWN0XCI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0e1xyXG5cdFx0XHRcdG5hbWU6IFwiTmFpdmUgUHJvYmVyXCIsXHJcblx0XHRcdFx0ZGVzY3JpcHRpb246IFwiTGlrZSBUaXQgRm9yIFRhdCwgYnV0IG9jY2FzaW9uYWxseSBEZWZlY3RzIHdpdGggc21hbGwgcHJvYmFiaWxpdHlcIixcclxuXHRcdFx0XHRzdHJhdGVneTogZnVuY3Rpb24gcHJvYmVyKHByb2JhYmlsaXR5ID0gMC4xKSB7XHJcblx0XHRcdFx0XHR0aGlzLmNob29zZSA9IGZ1bmN0aW9uKGNob2ljZXMsIGluZm9ybWF0aW9uKSB7XHJcblx0XHRcdFx0XHRcdGlmIChNYXRoLnJhbmRvbSgpIDwgcHJvYmFiaWxpdHkpIHJldHVybiBcIkRlZmVjdFwiO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKGluZm9ybWF0aW9uLm9wcG9uZW50Lmhpc3RvcnkubGVuZ3RoKSByZXR1cm4gaW5mb3JtYXRpb24ub3Bwb25lbnQuaGlzdG9yeVtpbmZvcm1hdGlvbi5vcHBvbmVudFxyXG5cdFx0XHRcdFx0XHRcdFx0Lmhpc3RvcnkubGVuZ3RoIC0gMV1cclxuXHRcdFx0XHRcdFx0XHQucmVzdWx0XHJcblx0XHRcdFx0XHRcdGVsc2UgcmV0dXJuIFwiQ29vcGVyYXRlXCI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0e1xyXG5cdFx0XHRcdG5hbWU6IFwiVGl0IEZvciBUd28gVGF0c1wiLFxyXG5cdFx0XHRcdGRlc2NyaXB0aW9uOiBcIkNvb3BlcmF0ZXMgb24gdGhlIGZpcnN0IG1vdmUsIHRoZW4gRGVmZWN0cyBvbmx5IHdoZW4gdGhlIG9wcG9uZW50IERlZmVjdHMgdHdvIHRpbWVzXCIsXHJcblx0XHRcdFx0c3RyYXRlZ3k6IGZ1bmN0aW9uIFRGMlQoKSB7XHJcblx0XHRcdFx0XHR0aGlzLmNob29zZSA9IGZ1bmN0aW9uKGNob2ljZXMsIGluZm9ybWF0aW9uKSB7XHJcblx0XHRcdFx0XHRcdGlmIChpbmZvcm1hdGlvbi5vcHBvbmVudC5oaXN0b3J5Lmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoaW5mb3JtYXRpb24ub3Bwb25lbnQuaGlzdG9yeVtpbmZvcm1hdGlvbi5vcHBvbmVudC5oaXN0b3J5Lmxlbmd0aCAtIDFdLnJlc3VsdCA9PSBcIkRlZmVjdFwiICYmXHJcblx0XHRcdFx0XHRcdFx0XHRpbmZvcm1hdGlvbi5vcHBvbmVudC5oaXN0b3J5W2luZm9ybWF0aW9uLm9wcG9uZW50Lmhpc3RvcnkubGVuZ3RoIC0gMl0ucmVzdWx0ID09IFwiRGVmZWN0XCIpIHJldHVybiBcIkRlZmVjdFwiO1xyXG5cdFx0XHRcdFx0XHRcdGVsc2UgcmV0dXJuIFwiQ29vcGVyYXRlXCI7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSByZXR1cm4gXCJDb29wZXJhdGVcIjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRdXHJcblx0fVxyXG59KTtcclxuLy8gVE9ETyB2YWxpZGF0ZSBhcmd1bWVudHNcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSXRlcmF0ZWRQcmlzb25lckRpbGVtbWFcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBOYXNoSlMgZW5naW5lIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG4vLyBnYW1lIGVuZ2luZVxyXG52YXIgeyBMb29wIH0gPSBFbmdpbmUuRnJvbnRlbmQuUGxheWFibGVzO1xyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lV3JhcHBlciB9ID0gRW5naW5lLkJhY2tlbmQuSGVscGVyRnVuY3Rpb25zKFwic3RvY2stZ2FtZXNcIilcclxuXHJcblxyXG52YXIgSXRlcmF0ZWQgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCBnYW1lR2VuZXJhdG9yLCBnYW1lTmFtZSwgbnVtYmVySXRlcmF0aW9ucyA9IDUwLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHJcblx0dmFyIHsgcGFyYW1ldGVyczogZ2FtZVBhcmFtZXRlcnMgPSB7fSB9ID0gcGFyYW1ldGVyc1xyXG5cclxuXHRnYW1lUGFyYW1ldGVycy5pZCA9IGdhbWVQYXJhbWV0ZXJzLmlkIHx8IGdhbWVOYW1lXHJcblx0cGFyYW1ldGVycy5pZCA9IHBhcmFtZXRlcnMuaWQgfHwgXCJJdGVyYXRlZC1cIiArIGdhbWVOYW1lO1xyXG5cclxuXHRyZXR1cm4gTG9vcChnYW1lR2VuZXJhdG9yKHBsYXllcnMsIGdhbWVQYXJhbWV0ZXJzKSwgbnVtYmVySXRlcmF0aW9ucywgcGFyYW1ldGVycyk7XHJcbn0pXHJcblxyXG4vLyBUT0RPIHZhbGlkYXRlIGFyZ3VtZW50c1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJdGVyYXRlZDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBiYXNlIGdhbWVcclxudmFyIFNpbXBsZVplcm9TdW0gPSByZXF1aXJlKFwiLi9zaW1wbGUtemVyby1zdW1cIik7XHJcblxyXG4vLyBOYXNoSlMgZW5naW5lIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG4vLyBoZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKVxyXG5cclxuLy8gUGxheS10aW1lIGxvZ2ljXHJcbnZhciB7IEV4cHJlc3Npb24gfSA9IEVuZ2luZS5Gcm9udGVuZFxyXG5cclxuXHJcbnZhciBNYXRjaGluZ1Blbm5pZXMgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRwYXJhbWV0ZXJzLmlkID0gcGFyYW1ldGVycy5pZCB8fCBcIk1hdGNoaW5nLVBlbm5pZXNcIjtcclxuXHRwYXlvZmYgPSBwYXJhbWV0ZXJzLnBheW9mZiB8fCAxO1xyXG5cclxuXHR2YXIgd2luID0gcGF5b2ZmO1xyXG5cdHZhciBsb3NlID0gRXhwcmVzc2lvbihmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAtcGF5b2ZmO1xyXG5cdH0pO1xyXG5cclxuXHR2YXIgY2hvaWNlcyA9IFtcclxuXHRcdFtcIkhlYWRzXCIsIFwiVGFpbHNcIl0sXHJcblx0XHRbXCJIZWFkc1wiLCBcIlRhaWxzXCJdXHJcblx0XTtcclxuXHJcblx0dmFyIHBheW9mZnMgPSBbXHJcblx0XHRbd2luLCBsb3NlXSxcclxuXHRcdFtsb3NlLCB3aW5dXHJcblx0XTtcclxuXHJcblx0cmV0dXJuIFNpbXBsZVplcm9TdW0ocGxheWVycywgY2hvaWNlcywgcGF5b2ZmcywgcGFyYW1ldGVycyk7XHJcbn0pO1xyXG5cclxuLy8gTWF0Y2hpbmcgUGVubmllc1xyXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGNoaW5nUGVubmllcztcclxuIiwiXCJ1c2Ugc3RyaWN0XCJcclxuXHJcbi8vIE5hc2hKUyBlbmdpbmUgY29tcG9uZW50c1xyXG52YXIgRW5naW5lID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIik7XHJcblxyXG4vLyBQbGF5YWJsZXNcclxudmFyIHsgQ2hvaWNlLCBMYW1iZGEgfSA9IEVuZ2luZS5Gcm9udGVuZC5QbGF5YWJsZXM7XHJcblxyXG4vLyBsb2dpY1xyXG52YXIgeyBWYXJpYWJsZSwgQ29tcGxleFZhcmlhYmxlIH0gPSBFbmdpbmUuRnJvbnRlbmRcclxuXHJcbi8vIGhlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgZ2FtZVdyYXBwZXIgfSA9IEVuZ2luZS5CYWNrZW5kLkhlbHBlckZ1bmN0aW9ucyhcInN0b2NrLWdhbWVzXCIpO1xyXG5cclxuXHJcbnZhciBNb250eUhhbGwgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXIsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHBhcmFtZXRlcnMuaWQgPSBwYXJhbWV0ZXJzLmlkIHx8IFwiTW9udHktSGFsbFwiXHJcblx0dmFyIG51bURvb3JzID0gcGFyYW1ldGVycy5udW1Eb29ycyB8fCAzO1xyXG5cdHZhciBudW1Qcml6ZXMgPSBwYXJhbWV0ZXJzLm51bVByaXplcyB8fCAxO1xyXG5cdHZhciBudW1SZXZlYWxzID0gcGFyYW1ldGVycy5udW1SZXZlYWxzIHx8IDE7XHJcblx0dmFyIHByaXplID0gcGFyYW1ldGVycy5wcml6ZSB8fCA1O1xyXG5cclxuXHQvLyBBbGxvdyBhcnJheSBvciBzaW5nbGUgcGxheWVyXHJcblx0aWYgKEFycmF5LmlzQXJyYXkocGxheWVyKSkgcGxheWVyID0gcGxheWVyWzBdXHJcblxyXG5cdC8vR2VuZXJhdGUgbGlzdCBvZiBkb29yc1xyXG5cdHZhciBkb29ycyA9IFtdO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRG9vcnM7IGkrKykge1xyXG5cdFx0ZG9vcnMucHVzaChcIkRvb3IgXCIgKyBpLnRvU3RyaW5nKCkpXHJcblx0fVxyXG5cclxuXHR2YXIgQ2hvb3NlID0gQ2hvaWNlKHBsYXllciwgZG9vcnMsIHsgaWQ6IFwiQ2hvb3NlXCIgfSk7XHJcblxyXG5cclxuXHR2YXIgcHJpemVzXHJcblx0dmFyIHNjb3JlcyA9IEFycmF5LmFwcGx5KG51bGwsIEFycmF5KGRvb3JzLmxlbmd0aCkpLm1hcChmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBWYXJpYWJsZSgwKVxyXG5cdH0pXHJcblxyXG5cdC8vTmVlZCB0byBzZXQgdGhpcyBoZXJlIGluIG9yZGVyIGZvciBzY29yaW5nIHRvIHdvcmtcclxuXHR2YXIgZG9vcnMyID0gQ29tcGxleFZhcmlhYmxlKGRvb3JzLnNsaWNlKCkpO1xyXG5cclxuXHR2YXIgUmV2ZWFsID0gTGFtYmRhKGZ1bmN0aW9uKHsgaGlzdG9yeSB9KSB7XHJcblxyXG5cdFx0Ly8gUmUtaW5pdGlhbGl6ZSBwYXlvZmZzLlxyXG5cdFx0cHJpemVzID0gW11cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2NvcmVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHNjb3Jlc1tpXS5zZXQoMClcclxuXHRcdH1cclxuXHJcblx0XHQvLyBXaGF0IGRvb3IgZGlkIHRoZSBwbGF5ZXIgb3Blbj9cclxuXHRcdHZhciBwbGF5ZXJDaG9pY2UgPSBoaXN0b3J5LmxvZy5xdWVyeShcIiRbY2hvaWNlPSdcIiArIENob29zZS5pZCgpICsgXCInXVstMV1cIikucmVzdWx0IC8vIFRPRE8gZG9lcyB0aGlzIHdvcms/XHJcblxyXG5cdFx0Ly8gU2VsZWN0IHdoaWNoIGRvb3JzIGhhdmUgcHJpemVzXHJcblx0XHR2YXIgcmV2ZWFsRnJvbSA9IGRvb3JzLnNsaWNlKCk7IC8vIENvcHkgdGhlIGRvb3JzIGxpc3RcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUHJpemVzOyBpKyspIHtcclxuXHRcdFx0dmFyIHByaXplSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiByZXZlYWxGcm9tLmxlbmd0aCkgLy8gU2VsZWN0IGEgZG9vciBmcm9tIHRoZSBkb29ycyBjb3B5XHJcblx0XHRcdHByaXplcy5wdXNoKHJldmVhbEZyb21bcHJpemVJbmRleF0pIC8vIEFkZCB0aGUgcHJpemUgdG8gdGhlIGxpc3RzXHJcblx0XHRcdHNjb3Jlc1twcml6ZUluZGV4XS5zZXQocHJpemUpIC8vIFNldCBwYXlvZmZzIGFwcHJvcHJpYXRlbHlcclxuXHRcdFx0cmV2ZWFsRnJvbS5zcGxpY2UocHJpemVJbmRleCwgMSkgLy8gUmVtb3ZlIHRoZSBwcml6ZWQgZG9vciBmcm9tIHRoZSBkb29ycyBjb3B5LCBzbyB0aGF0IHdlIGRvbid0IHNlbGVjdCBpdCBtb3JlIHRoYW4gb25jZVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vUmVtb3ZlIHBsYXllciBjaG9pY2UgZnJvbSBkb29ycyBjb3B5XHJcblx0XHR2YXIgcGxheWVyQ2hvaWNlSW5kZXggPSByZXZlYWxGcm9tLmluZGV4T2YocGxheWVyQ2hvaWNlKVxyXG5cdFx0aWYgKHBsYXllckNob2ljZUluZGV4ID4gLTEpIHJldmVhbEZyb20uc3BsaWNlKHBsYXllckNob2ljZUluZGV4LCAxKVxyXG5cclxuXHRcdC8vIENob29zZSBkb29ycyB0byByZXZlYWxcclxuXHRcdHZhciByZXZlYWwgPSBbXTtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUmV2ZWFsczsgaSsrKSB7XHJcblx0XHRcdHJldmVhbC5wdXNoKHJldmVhbEZyb21bTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKSAqIHJldmVhbEZyb20ubGVuZ3RoXSlcclxuXHRcdH1cclxuXHJcblx0XHQvLyBDb3B5IGRvb3JzIGxpc3QgdG8gc2VuZCBvbndhcmQsIHRoZW4gcmVtb3ZlIHRoZSByZXZlYWxlZCBkb29ycyBmcm9tIGxpc3RcclxuXHRcdGRvb3JzMi5zZXQoZG9vcnMuc2xpY2UoKSk7IC8vIE5lZWQgdG8gc2V0IHRoaXMgaGVyZSBzbyByZXZlYWxpbmcgdG8gd29ya1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCByZXZlYWwubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IGluZGV4ID0gZG9vcnMyLmluZGV4T2YocmV2ZWFsW2ldKVxyXG5cdFx0XHRkb29yczIoKS5zcGxpY2UoaW5kZXgsIDEpXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJldmVhbC5sZW5ndGggPT0gMSA/IHJldmVhbFswXSA6IHJldmVhbDtcclxuXHR9LCB7IGlkOiBcIlJldmVhbFwiIH0pXHJcblxyXG5cdHZhciBTZWNvbmRDaG9pY2UgPSBDaG9pY2UocGxheWVyLCBkb29yczIsIHsgaWQ6IFwiU3RheS1vci1Td2l0Y2hcIiwgdXNlUGF5b2ZmczogdHJ1ZSB9KTtcclxuXHRTZWNvbmRDaG9pY2Uuc2V0QWxsUGF5b2ZmcyhzY29yZXMpXHJcblxyXG5cdFJldmVhbChDaG9vc2UpXHJcblx0U2Vjb25kQ2hvaWNlKFJldmVhbClcclxuXHJcblx0cmV0dXJuIFNlcXVlbmNlKENob29zZSwgU2Vjb25kQ2hvaWNlLCBwYXJhbWV0ZXJzKTtcclxufSwge1xyXG5cclxuXHRzdHJhdGVneUxvYWRlcigpIHtcclxuXHRcdHJldHVybiBbe1xyXG5cdFx0XHRcdG5hbWU6IFwiQWx3YXlzIFN3aXRjaFwiLFxyXG5cdFx0XHRcdGRlc2NyaXB0aW9uOiBcIlJhbmRvbWx5IHNlbGVjdCBhIGRvb3IuIFRoZW4sIGFsd2F5cyBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgb25lLlwiLFxyXG5cclxuXHRcdFx0XHRzdHJhdGVneTogZnVuY3Rpb24gYWx3YXlzU3dpdGNoKCkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuZG9vciA9IG51bGw7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5jaG9vc2UgPSBmdW5jdGlvbihvcHRpb25zLCBpbmZvcm1hdGlvbikge1xyXG5cdFx0XHRcdFx0XHR2YXIgY2hvaWNlXHJcblx0XHRcdFx0XHRcdGlmICh0aGlzLmRvb3IpIHtcclxuXHRcdFx0XHRcdFx0XHRvcHRpb25zLnNwbGljZShvcHRpb25zLmluZGV4T2YodGhpcy5kb29yKSwgMSlcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmRvb3IgPSBudWxsO1xyXG5cdFx0XHRcdFx0XHRcdGNob2ljZSA9IG9wdGlvbnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogb3B0aW9ucy5sZW5ndGgpXVxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdGNob2ljZSA9IG9wdGlvbnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogb3B0aW9ucy5sZW5ndGgpXVxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuZG9vciA9IGNob2ljZVxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gY2hvaWNlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0bmFtZTogXCJBbHdheXMgU3RheVwiLFxyXG5cdFx0XHRcdGRlc2NyaXB0aW9uOiBcIlJhbmRvbWx5IHNlbGVjdCBhIGRvb3IuIFRoZW4sIGFsd2F5cyBzdGF5IHdpdGggdGhhdCBkb29yLlwiLFxyXG5cclxuXHRcdFx0XHRzdHJhdGVneTogZnVuY3Rpb24gYWx3YXlzU3RheSgpIHtcclxuXHRcdFx0XHRcdHRoaXMuZG9vciA9IG51bGw7XHJcblxyXG5cdFx0XHRcdFx0Ly9UT0RPIGFkZCBzdHJhdGVneSBkZXNjcmlwdGlvbiBmZWF0dXJlXHJcblx0XHRcdFx0XHR0aGlzLmNob29zZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGluZm9ybWF0aW9uKSB7XHJcblx0XHRcdFx0XHRcdHZhciBjaG9pY2VcclxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuZG9vcikge1xyXG5cdFx0XHRcdFx0XHRcdGNob2ljZSA9IHRoaXMuZG9vclxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuZG9vciA9IG51bGw7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdGNob2ljZSA9IG9wdGlvbnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogb3B0aW9ucy5sZW5ndGgpXVxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuZG9vciA9IGNob2ljZVxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gY2hvaWNlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRdXHJcblx0fVxyXG59KVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNb250eUhhbGxcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBiYXNlIGdhbWVcclxudmFyIFR3b1BsYXllck5vcm1hbCA9IHJlcXVpcmUoXCIuL3NpbXBsZS1ub3JtYWxcIikuVHdvUGxheWVyTm9ybWFsO1xyXG5cclxuLy9OYXNoSlMgZW5naW5lIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG4vLyBoZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKTtcclxuXHJcbi8vIHBsYXktdGltZSBsb2dpY1xyXG52YXIgeyBWYXJpYWJsZSwgRXhwcmVzc2lvbiB9ID0gRW5naW5lLkZyb250ZW5kO1xyXG5cclxuXHJcbnZhciBwcmlzb25lckRpbGVtbWEgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRwYXJhbWV0ZXJzLmlkID0gcGFyYW1ldGVycy5pZCB8fCBcIlByaXNvbmVyLURpbGVtbWFcIjtcclxuXHR2YXIgcGF5b2ZmcyA9IHBhcmFtZXRlcnMucGF5b2ZmcyB8fCBbVmFyaWFibGUoMSksIFZhcmlhYmxlKDIpLCBWYXJpYWJsZSgzKSwgVmFyaWFibGUoNCldO1xyXG5cclxuXHJcblx0Ly8gc29ydCBudW1iZXJzIGJlY2F1c2UgdGhlIHdyb25nIG9yZGVyIHdvdWxkIHNjcmV3IHVwIHRoZSBnYW1lXHJcblx0cGF5b2Zmcy5zb3J0KClcclxuXHR2YXIgc3Vja2VyID0gcGF5b2Zmc1swXVxyXG5cdHZhciBwdW5pc2htZW50ID0gcGF5b2Zmc1sxXVxyXG5cdHZhciByZXdhcmQgPSBwYXlvZmZzWzJdXHJcblx0dmFyIHRlbXB0YXRpb24gPSBwYXlvZmZzWzNdXHJcblxyXG5cclxuXHR2YXIgY2hvaWNlcyA9IFtcclxuXHRcdFtcIkNvb3BlcmF0ZVwiLCBcIkRlZmVjdFwiXSxcclxuXHRcdFtcIkNvb3BlcmF0ZVwiLCBcIkRlZmVjdFwiXVxyXG5cdF07XHJcblx0dmFyIGdhbWVQYXlvZmZzID0gW1xyXG5cdFx0W1xyXG5cdFx0XHRbcmV3YXJkLCByZXdhcmRdLFxyXG5cdFx0XHRbc3Vja2VyLCB0ZW1wdGF0aW9uXVxyXG5cdFx0XSxcclxuXHRcdFtcclxuXHRcdFx0W3RlbXB0YXRpb24sIHN1Y2tlcl0sXHJcblx0XHRcdFtwdW5pc2htZW50LCBwdW5pc2htZW50XVxyXG5cdFx0XVxyXG5cdF07XHJcblxyXG5cdHJldHVybiBUd29QbGF5ZXJOb3JtYWwocGxheWVycywgY2hvaWNlcywgZ2FtZVBheW9mZnMsIHBhcmFtZXRlcnMpO1xyXG59KTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHByaXNvbmVyRGlsZW1tYTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBiYXNlIGdhbWVcclxudmFyIFNpbXBsZVplcm9TdW0gPSByZXF1aXJlKFwiLi9zaW1wbGUtemVyby1zdW1cIik7XHJcblxyXG52YXIgRW5naW5lID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIilcclxuXHJcbi8vIGhlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgZ2FtZVdyYXBwZXIgfSA9IEVuZ2luZS5CYWNrZW5kLkhlbHBlckZ1bmN0aW9ucyhcInN0b2NrLWdhbWVzXCIpXHJcblxyXG4vLyBQbGF5LXRpbWUgbG9naWNcclxudmFyIHsgRXhwcmVzc2lvbiB9ID0gRW5naW5lLkZyb250ZW5kXHJcblxyXG5cclxuLy8gUm9jay1QYXBlci1TY2lzc29yc1xyXG52YXIgUm9ja1BhcGVyU2Npc3NvcnMgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRwYXJhbWV0ZXJzLmlkID0gcGFyYW1ldGVycy5pZCB8fCBcIlJvY2stUGFwZXItU2Npc3NvcnNcIjtcclxuXHRwYXJhbWV0ZXJzLnBheW9mZiA9IHBhcmFtZXRlcnMucGF5b2ZmIHx8IDE7XHJcblxyXG5cdHZhciB3aW4gPSBwYXJhbWV0ZXJzLnBheW9mZjtcclxuXHR2YXIgbG9zZSA9IEV4cHJlc3Npb24oZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gLXBheW9mZjtcclxuXHR9KTtcclxuXHJcblx0dmFyIGNob2ljZXMgPSBbXHJcblx0XHRbXCJSb2NrXCIsIFwiUGFwZXJcIiwgXCJTY2lzc29yc1wiXSxcclxuXHRcdFtcIlJvY2tcIiwgXCJQYXBlclwiLCBcIlNjaXNzb3JzXCJdXHJcblx0XTtcclxuXHR2YXIgcGF5b2ZmcyA9IFtcclxuXHRcdFswLCBsb3NlLCB3aW5dLFxyXG5cdFx0W3dpbiwgMCwgbG9zZV0sXHJcblx0XHRbbG9zZSwgd2luLCAwXVxyXG5cdF07XHJcblxyXG5cdHJldHVybiBTaW1wbGVaZXJvU3VtKHBsYXllcnMsIGNob2ljZXMsIHBheW9mZnMsIHBhcmFtZXRlcnMpO1xyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm9ja1BhcGVyU2Npc3NvcnNcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vL05hc2hKUyBFbmdpbmVcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG4vLyBoZWxwZXIgZnVuY3Rpb25cclxudmFyIHsgc2h1ZmZsZSB9ID0gRW5naW5lLkJhY2tlbmQuSGVscGVyRnVuY3Rpb25zKFwiZ2VuZXJhbFwiKTtcclxudmFyIHsgZ2FtZVdyYXBwZXIgfSA9IEVuZ2luZS5CYWNrZW5kLkhlbHBlckZ1bmN0aW9ucyhcInN0b2NrLWdhbWVzXCIpXHJcblxyXG4vLyBuYXNoSlMgZW5naW5lIGNvbXBvbmVudFxyXG52YXIgeyBTZXF1ZW5jZSwgU2ltdWx0YW5lb3VzIH0gPSBFbmdpbmUuRnJvbnRlbmQuUGxheWFibGVzO1xyXG5cclxuLy9mb3IgaW5mb3JtYXRpb24gbWVjaGFuaWNzXHJcbnZhciB7IEluZm9ybWF0aW9uLCBIaXN0b3J5LCBQbGF5ZXJMaXN0IH0gPSBFbmdpbmUuQmFja2VuZC5DbGFzc2VzO1xyXG5cclxuXHJcbi8vIGdhbWVHZW5lcmF0b3Igc2hvdWxkIGJlIGEgZnVuY3Rpb24gd2hvc2UgZmlyc3QgYXJndW1lbnQgaXMgYW4gYXJyYXkgb2YgcGxheWVyc1xyXG52YXIgUm91bmRSb2JpbiA9IGdhbWVXcmFwcGVyKGZ1bmN0aW9uKHBsYXllcnMsIGdhbWVHZW5lcmF0b3IsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHBhcmFtZXRlcnMuaWQgPSBwYXJhbWV0ZXJzLmlkIHx8IFwiUm91bmQtUm9iaW5cIjtcclxuXHRwYXJhbWV0ZXJzLmluaXRpYWxpemVQbGF5ZXJzID0gcGFyYW1ldGVycy5pbml0aWFsaXplUGxheWVycyAmJiB0cnVlO1xyXG5cclxuXHQvLyBDcmVhdGUgYXJyYXkgb2YgZWFjaCBjb21iaW5hdGlvbiBvZiBwbGF5ZXJzXHJcblx0dmFyIG1hdGNoZXMgPSBbXTtcclxuXHJcblx0cGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uKHBsYXllcjEsIGluZGV4MSkge1xyXG5cdFx0Zm9yICh2YXIgaW5kZXgyID0gMDsgaW5kZXgyIDwgaW5kZXgxOyBpbmRleDIrKykge1xyXG5cdFx0XHRtYXRjaGVzLnB1c2goW3BsYXllcnNbaW5kZXgyXSwgcGxheWVyMV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG9wdGlvbmFsIHBhcmFtZXRlciAnY29waWVzLicgUGFzcyBhbiBleHRyYSBjb3B5IG9mIGVhY2ggcGxheWVyLCB0byBwbGF5IHRoZW1zZWx2ZXNcclxuXHRcdGlmIChwYXJhbWV0ZXJzLmNvcGllcykgbWF0Y2hlcy5wdXNoKFtwYXJhbWV0ZXJzLmNvcGllc1tpbmRleDFdLCBwbGF5ZXIxXSk7XHJcblx0fSk7XHJcblxyXG5cdC8vcmFuZG9taXplIHRoZSBvcmRlclxyXG5cdHNodWZmbGUobWF0Y2hlcyk7XHJcblxyXG5cdC8vIFRyYWNrIHNjb3Jlc1xyXG5cdHZhciBzY29yZXNSZWNvcmQgPSBbXTtcclxuXHJcblx0Ly9cclxuXHR2YXIgYWRkUm91bmQgPSBmdW5jdGlvbihwbGF5ZXJzLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRcdC8vIGluZm9ybWF0aW9uIG1lY2hhbmljcyBhbmQgb3RoZXIgcGFyYW1ldGVyc1xyXG5cdFx0dmFyIHBvcHVsYXRpb24gPSBuZXcgUGxheWVyTGlzdChwbGF5ZXJzKS5nZW5lcmF0b3JcclxuXHRcdHBhcmFtZXRlcnMuY29tcGFydG1lbnRhbGl6ZSA9IHsgcG9wdWxhdGlvbiB9XHJcblx0XHRwYXJhbWV0ZXJzLmluaXRpYWxpemVQbGF5ZXJzID0gcG9wdWxhdGlvbjtcclxuXHJcblx0XHQvLyBnZW5lcmF0ZSByb3VuZFxyXG5cdFx0dmFyIHJvdW5kID0gZ2FtZUdlbmVyYXRvcihwbGF5ZXJzLCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0XHQvLyB0cmFjayB0aGUgc2NvcmVzXHJcblx0XHR2YXIgcmVjb3JkU2NvcmVzID0gTGFtYmRhKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgc2NvcmUgPSB7fVxyXG5cdFx0XHRmb3IgKGxldCBbc3RyYXRlZ3ksIHNjb3Jlc10gb2YgT2JqZWN0LmVudHJpZXMocG9wdWxhdGlvbigpLnNjb3Jlc0J5U3RyYXRlZ3koKSkpIHtcclxuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShzY29yZXMpKSB7XHJcblx0XHRcdFx0XHRpZiAoc2NvcmVzLmxlbmd0aCA9PSAxKSBzY29yZXMgPSBzY29yZXNbMF1cclxuXHRcdFx0XHRcdHNjb3JlW3N0cmF0ZWd5XSA9IHNjb3JlcztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0c2NvcmVzUmVjb3JkLnB1c2goc2NvcmUpO1xyXG5cclxuXHRcdFx0Ly9yZXR1cm4gc2NvcmUgZm9yIGhpc3RvcnlcclxuXHRcdFx0cmV0dXJuIHNjb3JlO1xyXG5cdFx0fSwgeyBpZDogXCJSZWNvcmQtU2NvcmVzXCIgfSk7XHJcblxyXG5cdFx0Ly9DaGFpbiB0b2dldGhlclxyXG5cdFx0cmVjb3JkU2NvcmVzKHJvdW5kKTtcclxuXHJcblx0XHQvLyByZXR1cm4gYm90aFxyXG5cdFx0cmV0dXJuIFtyb3VuZCwgcmVjb3JkU2NvcmVzXHJcblx0XHRcdC8vICxTZXF1ZW5jZShyb3VuZCwgcmVjb3JkU2NvcmVzKSAvLyBVbmNvbW1lbnQgZm9yIFNpbXVsdGFuZW91cyBpbXBsZW1lbnRhdGlvblxyXG5cdFx0XTtcclxuXHR9O1xyXG5cclxuXHJcblxyXG5cdC8vIFNlcXVlbnRpYWwgaW1wbGVtZW50YXRpb25cclxuXHQvLyBsb2FkIHRoZSBmaXJzdCBtYXRjaCBtYW51YWxseVxyXG5cdHZhciBbZmlyc3RSb3VuZCwgZmlyc3RSZWNvcmRdID0gYWRkUm91bmQoXHJcblx0XHRtYXRjaGVzLnNoaWZ0KCksXHJcblx0XHRwYXJhbWV0ZXJzLnBhcmFtZXRlcnNcclxuXHQpO1xyXG5cclxuXHQvL3RoZW4gbG9hZCBzdWJzZXF1ZW50IG1hdGNoZXNcclxuXHR2YXIgcmVjb3JkID0gZmlyc3RSZWNvcmQ7XHJcblx0dmFyIGxhc3RSZWNvcmQsIGxhc3RSb3VuZDtcclxuXHJcblx0bWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uKG1hdGNoKSB7XHJcblx0XHRbbGFzdFJvdW5kLCBsYXN0UmVjb3JkXSA9IGFkZFJvdW5kKG1hdGNoLCBwYXJhbWV0ZXJzLnBhcmFtZXRlcnMpO1xyXG5cclxuXHRcdGxhc3RSb3VuZChyZWNvcmQpO1xyXG5cdFx0cmVjb3JkID0gbGFzdFJlY29yZDtcclxuXHR9KTtcclxuXHJcblxyXG5cdHJldHVybiBTZXF1ZW5jZShmaXJzdFJvdW5kLCBsYXN0UmVjb3JkLCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0LyogLy8gU2ltdWx0YW5lb3VzIGltcGxlbWVudGF0aW9uXHJcblx0dmFyIHJvdW5kcyA9IFtdO1xyXG5cdG1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbihtYXRjaCkge1xyXG5cdCAgcm91bmRzLnB1c2goYWRkUm91bmQobWF0Y2gsIHBhcmFtZXRlcnMuZ2FtZVBhcmFtZXRlcnMpWzJdKTtcclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIFNpbXVsdGFuZW91cyhyb3VuZHMsIHBhcmFtZXRlcnMpOyAqL1xyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm91bmRSb2JpbjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vL0dhbWUgZW5naW5lXHJcbnZhciBFbmdpbmUgPSByZXF1aXJlKFwiLi4vbGliL2VuZ2luZVwiKVxyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlzRnVuY3Rpb24gfSA9IEVuZ2luZS5CYWNrZW5kLkhlbHBlckZ1bmN0aW9ucyhcImdlbmVyYWxcIilcclxudmFyIHsgZ2FtZVdyYXBwZXIgfSA9IEVuZ2luZS5CYWNrZW5kLkhlbHBlckZ1bmN0aW9ucyhcInN0b2NrLWdhbWVzXCIpXHJcblxyXG4vLyBQbGF5YWJsZXNcclxudmFyIHsgVHVybiwgQ2hvaWNlLCBSYW5kb21QbGF5ZXJDaG9pY2UgfSA9IEVuZ2luZS5Gcm9udGVuZC5QbGF5YWJsZXM7XHJcblxyXG4vL1BsYXktdGltZSBMb2dpY1xyXG52YXIgeyBSYW5kb21WYXJpYWJsZSB9ID0gRW5naW5lLkZyb250ZW5kXHJcblxyXG5cclxudmFyIE5vcm1hbCA9IGdhbWVXcmFwcGVyKGZ1bmN0aW9uKHBsYXllcnMsIGNob2ljZUxpc3RzLCBwYXlvZmZzID0gbnVsbCwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblxyXG5cdFx0Ly9wcm9wb2dhdGUgdGhlIGluZm9ybWF0aW9uIGZpbHRlclxyXG5cdFx0cGFyYW1ldGVycy5wYXJhbWV0ZXJzID8gcGFyYW1ldGVycy5wYXJhbWV0ZXJzLmluZm9ybWF0aW9uRmlsdGVyID0gcGFyYW1ldGVycy5pbmZvcm1hdGlvbkZpbHRlciA6XHJcblx0XHRcdHBhcmFtZXRlcnMucGFyYW1ldGVycyA9IHsgaW5mb3JtYXRpb25GaWx0ZXI6IHBhcmFtZXRlcnMuaW5mb3JtYXRpb25GaWx0ZXIgfVxyXG5cclxuXHRcdC8vIGNvbnN0cnVjdCB0aGUgY2hvaWNlc1xyXG5cdFx0dmFyIGNob2ljZXMgPSBjaG9pY2VMaXN0cy5tYXAoZnVuY3Rpb24obGlzdCwgaW5kZXgpIHtcclxuXHRcdFx0cmV0dXJuIHBsYXllcnMgPT0gXCJyYW5kb21cIiA/IFJhbmRvbVBsYXllckNob2ljZShsaXN0LCBwYXJhbWV0ZXJzLnBhcmFtZXRlcnMpIDogQ2hvaWNlKHBsYXllcnNbaW5kZXhdLFxyXG5cdFx0XHRcdGxpc3QsIHBhcmFtZXRlcnMucGFyYW1ldGVycyk7XHJcblx0XHR9KTtcclxuXHJcblx0XHR2YXIgZ2FtZSA9IFR1cm4oY2hvaWNlcywgcGFyYW1ldGVycyk7XHJcblxyXG5cdFx0aWYgKHBheW9mZnMpIGdhbWUuc2V0QWxsUGF5b2ZmcyhwYXlvZmZzKTtcclxuXHJcblx0XHRyZXR1cm4gZ2FtZTtcclxuXHR9LCB7XHJcblx0XHRxdWVyaWVzOiBbe1xyXG5cdFx0XHRcdHNob3J0Y3V0OiBcIkBOLWNob2ljZXNcIixcclxuXHRcdFx0XHRxdWVyeTogXCIkLnJlc3VsdHN7cGxheWVyOnJlc3VsdH1cIixcclxuXHRcdFx0XHRkZXNjcmlwdGlvbjogXCJOb3JtYWw6IFBsYXllcnMgYW5kIHRoZWlyIGNob2ljZS5cIlxyXG5cdFx0XHR9LFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0c2hvcnRjdXQ6IFwiQE4tcGF5b3V0c1wiLFxyXG5cdFx0XHRcdHF1ZXJ5OiBcIiQucGF5b3V0c1wiLFxyXG5cdFx0XHRcdGRlc2NyaXB0aW9uOiBcIk5vcm1hbDogUGF5b3V0cyBvYmplY3QsIGJ5IHBsYXllci5cIlxyXG5cdFx0XHR9LFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0c2hvcnRjdXQ6IFwiQE4tcGxheWVyc1wiLFxyXG5cdFx0XHRcdHF1ZXJ5OiBcIiQucmVzdWx0cy5wbGF5ZXJcIixcclxuXHRcdFx0XHRkZXNjcmlwdGlvbjogXCJOb3JtYWw6IFdobyBwbGF5ZWQuXCJcclxuXHRcdFx0fVxyXG5cdFx0XSxcclxuXHRcdHN0cmF0ZWd5TG9hZGVyOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIFt7XHJcblx0XHRcdFx0XHRzdHJhdGVneTogZnVuY3Rpb24gY2hvb3NlRmlyc3QoKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuY2hvb3NlID0gZnVuY3Rpb24oY2hvaWNlcywgaW5mb3JtYXRpb24pIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY2hvaWNlc1swXVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0bmFtZTogXCJDaG9vc2UgRmlyc3RcIixcclxuXHRcdFx0XHRcdGRlc2NyaXB0aW9uOiBcIkFsd2F5cyBjaG9vc2UgZmlyc3QgYXZhaWxhYmxlIG9wdGlvbi5cIlxyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHN0cmF0ZWd5OiBmdW5jdGlvbiBjaG9vc2VTZWNvbmQoKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuY2hvb3NlID0gZnVuY3Rpb24oY2hvaWNlcywgaW5mb3JtYXRpb24pIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY2hvaWNlc1sxXVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0bmFtZTogXCJDaG9vc2UgU2Vjb25kXCIsXHJcblx0XHRcdFx0XHRkZXNjcmlwdGlvbjogXCJBbHdheXMgY2hvb3NlIHNlY29uZCBhdmFpbGFibGUgb3B0aW9uLlwiXHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0c3RyYXRlZ3k6IGZ1bmN0aW9uIHJhbmRvbWl6ZShjaG9pY2VzID0gWzAsIDFdKSB7XHJcblx0XHRcdFx0XHRcdC8vIENyZWF0aW5nIGEgbWFwIHdpbGwgbWFrZSBwaWNraW5nIGEgcmFuZG9tIHZhbHVlIGVhc2llclxyXG5cdFx0XHRcdFx0XHRjaG9pY2VzID0gY2hvaWNlcy5tYXAoZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gW2luZGV4LCBpdGVtXVxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0dmFyIGNob2ljZU1hcCA9IG5ldyBNYXAoY2hvaWNlcylcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMuY2hvb3NlID0gZnVuY3Rpb24oY2hvaWNlcywgaW5mb3JtYXRpb24pIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY2hvaWNlc1tjaG9pY2VNYXAuZ2V0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNob2ljZU1hcC5zaXplKSldO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0bmFtZTogXCJSYW5kb21pemVcIixcclxuXHRcdFx0XHRcdGRlc2NyaXB0aW9uOiBcIkNob29zZSByYW5kb21seSBmcm9tIGF2YWlsYWJsZSBvcHRpb25zLlwiXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRdO1xyXG5cdFx0fVxyXG5cdH0gLy8gXHRcdFx0XHRcdFx0XHRcdFx0XHRUT0RPOiB2YWxpZGF0ZSBhbGwgYXJndW1lbnRzXHJcbik7XHJcblxyXG5cclxudmFyIFR3b1BsYXllck5vcm1hbCA9IGdhbWVXcmFwcGVyKGZ1bmN0aW9uKHBsYXllcnMsIGNob2ljZXMsIHBheW9mZnMgPSBudWxsLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHJcblx0Ly8gSW5mb3JtYXRpb24gbWVjaGFuaWNzLi4gVGhlcmUgYXJlIG9ubHkgdHdvIHBsYXllcnMsIHNvIHdlIGNhbiBoYXZlIGEgJ21lJyBhbmQgJ29wcG9uZW50JyBlbnRyeS5cclxuXHQvLyBJZiB1c2VyIHN1cHBsaWVkIGFuIGluZm9ybWF0aW9uIGZpbHRlciwgd3JhcCB0aGF0IGZpbHRlciBpbiBvdXJzLlxyXG5cdHZhciB7IGluZm9ybWF0aW9uRmlsdGVyIH0gPSBwYXJhbWV0ZXJzO1xyXG5cdGlmICghaXNGdW5jdGlvbihpbmZvcm1hdGlvbkZpbHRlcikpIGluZm9ybWF0aW9uRmlsdGVyID0gbnVsbDtcclxuXHJcblx0Ly8gV3JhcCB0aGUgdXNlcidzIGZpbHRlclxyXG5cdHZhciB3cmFwcGVkRmlsdGVyID0gZnVuY3Rpb24oaW5mb3JtYXRpb24pIHtcclxuXHRcdC8vIEZpZ3VyZSBvdXQgd2hvIEkgYW0gYW5kIHdobyB0aGUgb3Bwb25lbnQgaXNcclxuXHRcdHZhciBtZSA9IGluZm9ybWF0aW9uLm1lLmlkXHJcblx0XHR2YXIgcGxheWVycyA9IFtpbmZvcm1hdGlvbi50dXJuLmNob2ljZXNbMF0uY2hvaWNlLnBsYXllciwgaW5mb3JtYXRpb24udHVybi5jaG9pY2VzWzFdLmNob2ljZS5wbGF5ZXJdXHJcblx0XHR2YXIgb3Bwb25lbnQgPSBwbGF5ZXJzLnNwbGljZShwbGF5ZXJzLmluZGV4T2YobWUpLCAxKSAmJiBwbGF5ZXJzWzBdO1xyXG5cclxuXHRcdC8vIGFkZCBlbnRyeSBmb3Igb3Bwb25lbnRcclxuXHRcdHZhciBvcHBvbmVudERldGFpbCA9IGluZm9ybWF0aW9uLnBvcHVsYXRpb24uZmlsdGVyKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRyZXR1cm4gKHBsYXllci5pZCA9PSBvcHBvbmVudClcclxuXHRcdH0pWzBdO1xyXG5cdFx0aW5mb3JtYXRpb24ub3Bwb25lbnQgPSBvcHBvbmVudERldGFpbDtcclxuXHJcblx0XHQvLyBydW4gdGhlIHVzZXIncyBpbmZvcm1hdGlvbiBmaWx0ZXJcclxuXHRcdGlmIChpbmZvcm1hdGlvbkZpbHRlcikgaW5mb3JtYXRpb24gPSBpbmZvcm1hdGlvbkZpbHRlcihpbmZvcm1hdGlvbik7XHJcblxyXG5cdFx0cmV0dXJuIGluZm9ybWF0aW9uO1xyXG5cdH1cclxuXHJcblx0Ly8gUGFzcyB0aGUgaW5mb3JtYXRpb24gZmlsdGVyXHJcblx0cGFyYW1ldGVycy5pbmZvcm1hdGlvbkZpbHRlciA9IHdyYXBwZWRGaWx0ZXJcclxuXHJcblx0cmV0dXJuIE5vcm1hbChwbGF5ZXJzLCBjaG9pY2VzLCBwYXlvZmZzLCBwYXJhbWV0ZXJzKVxyXG59KTsgLy9cdFx0XHRcdCBcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFRPRE86IG1heSB3YW50IHRvIHZhbGlkYXRlIGFyZ3VtZW50cyBoZXJlIHRvb1xyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgVHdvUGxheWVyTm9ybWFsLCBOb3JtYWwgfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBiYXNlIGdhbWVcclxudmFyIFR3b1BsYXllck5vcm1hbCA9IHJlcXVpcmUoXCIuL3NpbXBsZS1ub3JtYWxcIikuVHdvUGxheWVyTm9ybWFsO1xyXG5cclxuLy8gTmFzaEpTIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG4vLyBHYW1lIHN0YXRlIGNvbnRyb2xsZXJcclxudmFyIHsgcmVnaXN0cnkgfSA9IEVuZ2luZS5CYWNrZW5kLlN0YXRlXHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKTtcclxuXHJcbi8vIFBsYXktdGltZSBsb2dpY1xyXG52YXIgeyBWYXJpYWJsZSwgRXhwcmVzc2lvbiB9ID0gRW5naW5lLkZyb250ZW5kO1xyXG5cclxuLyogYmVhdXRpZnkgcHJlc2VydmU6c3RhcnQgKi9cclxudmFyIFNpbXBsZVplcm9TdW0gPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCBjaG9pY2VzLCBwYXlvZmZzID0gW1swLCAwXSxcdFswLCAwXV0sIHBhcmFtZXRlcnM9e30pIHtcclxuLyogYmVhdXRpZnkgcHJlc2VydmU6ZW5kICovXHJcblxyXG5cdHZhciBnYW1lID0gVHdvUGxheWVyTm9ybWFsKHBsYXllcnMsIGNob2ljZXMsIG51bGwsIHBhcmFtZXRlcnMpXHJcblxyXG5cdHZhciBlO1xyXG5cclxuXHRjaG9pY2VzWzBdLmZvckVhY2goZnVuY3Rpb24oY2hvaWNlMCwgaW5kZXgwKSB7XHJcblx0XHRjaG9pY2VzWzFdLmZvckVhY2goZnVuY3Rpb24oY2hvaWNlMSwgaW5kZXgxKSB7XHJcblxyXG5cdFx0XHQvLyBTZXQgZXhwcmVzc2lvblxyXG5cdFx0XHRlID0gRXhwcmVzc2lvbihmdW5jdGlvbigpIHtcclxuXHRcdFx0XHQvL1JldHVybiB0aGUgbmVnYXRpdmUgcGF5b2ZmLCBvciB6ZXJvXHJcblx0XHRcdFx0cmV0dXJuICgwIC0gcmVnaXN0cnkudHVybnNbZ2FtZS5pZCgpXS5wYXlvZmZzSW1wbGljaXRbY2hvaWNlMF1bY2hvaWNlMV1bMF0gfHwgMCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly9TZXQgcGF5b2Zmc1xyXG5cdFx0XHRnYW1lW2Nob2ljZTBdW2Nob2ljZTFdKFtwYXlvZmZzW2luZGV4MF1baW5kZXgxXSwgZV0pO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblxyXG5cdHJldHVybiBnYW1lO1xyXG59KTsgLy9cdFx0XHRcdFx0VE9ETzogdmFsaWRhdGUgYXJndW1lbnRzXHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2ltcGxlWmVyb1N1bTtcclxuIl19
