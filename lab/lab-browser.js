(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":3}],3:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],4:[function(require,module,exports){
//Main module code
var NashJS = require('./lib/engine').Frontend;

//Stock-games
NashJS.StockGames = require('./stock-games');


module.exports = NashJS;

},{"./lib/engine":6,"./stock-games":79}],5:[function(require,module,exports){
({
	Player,
	_Player,
	gamePopulation,
	Population,
	PlayerList,
	registerStrategy,
	Strategies,
	strategyLoader,
	_expose,
	registry,
	Variable,
	Expression,
	RandomVariable,
	ComplexVariable,
	History,
	Queries,
	excludedPlayers,
	startREPL,
	nhistory,
	Information,
	PerfectInformation,
	PluginManager
} = require("../index"));
({
	Choice,
	Turn,
	Sequence,
	Consecutive,
	Loop,
	StochasticLoop,
	HaltIf,
	StochasticHalt,
	Lambda,
	RandomPlayerChoice,
	PopulationDynamics,
	Simultaneous
} = require("../index").Playables);
StockGames = require("../index").StockGames;



p1 = Player();
p2 = Player();
p3 = Player();
ipd = StockGames["Iterated Prisoner's Dilemma"]([p1, p2], 20)
/*
StockGames["Prisoner's Dilemma"]([p1, p2])

p1.assign("chooseFirst")
p2.assign("randomize");

p3 = Player();
p3.assign("chooseSecond");
p4 = Player();
p4.assign("randomize")

c1 = Choice(p1, ["cooperate", "defect"]);
//c1['left'](5) ;
//c1['right'](2);
c2 = Choice(p2, ["Cooperate", "Defect"]);
//c2['up'](1);
//c2['down'](7);

t2 = Turn([c1, c2]);
t3 = Turn([c1, c2]);
t4 = Turn([c1, c2]);
t5 = Turn([c1, c2]);
s1 = Simultaneous([t2, t3, t4, t5])

c = Consecutive([
	Turn([c1, c2]),
	Turn([c2, c1]),
	Choice(p1, ["cooperate", "defect"]),
	Lambda(function() { console.log("hi") }),
	HaltIf(function() { return true })
])

c3 = RandomPlayerChoice(["cooperate", "defect"]);
c4 = RandomPlayerChoice(["Cooperate", "Defect"]);

t1 = Turn([c3, c4]);

v1 = new Variable(3);

t1.defect.Defect([2, 2]);
t1.defect.Cooperate([4, 1]);
t1.cooperate.Defect([1, 4]);
t1.cooperate.Cooperate([v1, v1]);

L1 = Lambda(function() {
	v1.set(v1 + 1);
});

pd1 = PopulationDynamics(1.5, 1);

h2 = HaltIf(function() {
	return Population().onlyAlive().length == 0;
});

L1(t1);
pd1(L1);
h2(pd1);

//s1 = Sequence(t1, h2);

//l1 = Loop(s1, 10, { logContinue: true });

//console.log(_expose(t1).next)
//console.log(_expose(t1).next.cooperate.Cooperate)

h2 = HaltIf(function() {
	return Population().onlyAlive().length == 0;
});

L2 = Lambda(function() {
	p1.kill();
});

t2(L2);

generatePopulation = function() {
	for (i = 0; i < 30; i++) {
		Player({ assign: "chooseFirst" });
	}
	for (i = 0; i < 30; i++) {
		Player({ assign: "chooseSecond" });
	}
};

function gameGenerator() {
	var t = Turn([
		RandomPlayerChoice(["cooperate", "defect"]),
		RandomPlayerChoice(["Cooperate", "Defect"])
	]);

	t.defect.Defect([2, 2]);
	t.defect.Cooperate([4, 1]);
	t.cooperate.Defect([1, 4]);
	t.cooperate.Cooperate([3, 3]);

	return t;
}
//
//
//

//CE = StockGames["Cultural Evolution"](gameGenerator, 1, {generatePopulation});

//n = StockGames["Two-Player Normal"](p1,p2,[["left","right"],["up","down"]]);
//pd1 = StockGames["Prisoner's Dilemma"]([p1, p2]);
//pd2 = StockGames["Prisoner's Dilemma"]([p3, p4]);

//s = Simultaneous([pd1, pd2])

v2 = Variable(1);

//n = StockGames["Simple Zero-Sum"](p1,p2,[["left","right"],["up","down"]], [[v2,2],[3,4]]);

//rpc = StockGames["Rock-Paper-Scissors"]([p1, p2]);
//t = StockGames["Axelrod Tournament"];
//t = StockGames["Iterated Prisoner's Dilemma"]([p1, p2]);
//The code below is to run the repl for testing purposes.
//var toRepl = {_expose, registry,Player,Choice,Turn,Sequence,Loop,StochasticLoop,HaltIf, StochasticHalt, Lambda, p1,c1,c2,t1};
//startREPL(toRepl);
*/

},{"../index":4}],6:[function(require,module,exports){
"use strict";

// Start plug-in manager
var PluginManager = require("./plugin-manager")
PluginManager.start(function() {})


//Logging
var log = require("./logger");
//log.useWinston();  				Winston doesn't work with browserify, so this is a shim. Uncomment to use Winston.
log.setLevel("debug");
log("info", "Starting NashJS");


//Game state controllers
var { registry, idCounters } = require('./state');


// Query language and shortcuts
var { Queries, Query, QueryResult, evaluateQuery } = require("./query");


// History
var { gameHistory, userGameHistory, History, UserHistory } = require('./history');


//Players
var { _Player, Player } = require('./player');
registry._addType_("players");
idCounters._addType_("player");


//Population
var { gamePopulation, Population, PlayerList, UserPlayerList } = require('./population');


//Information mechanics
var { Information, PerfectInformation } = require("./information");


//Playables
var { playableClasses, playableInterfaces } = require('./playables/')
for (var _class in playableClasses) {
	registry._addType_(playableClasses[_class].registryName);
	idCounters._addType_(playableClasses[_class].counterName);
}

//Symbolic Logic
var {
	variablePrototype,
	Variable,
	expressionPrototype,
	Expression,
	RandomVariable,
	ComplexVariable
} = require("./logic");


//Strategies
registry._addType_("strategies");
idCounters._addType_("strategy");

var { registerStrategy, registerStrategyObject, Strategies } = require('./strategy');
var { loadStrategy, loadStrategyFolder } = require('./strategy-loader');


// Helper function loader
var HelperFunctions = require('./helperFunctions');


//THIS FUNCTION IS ONLY FOR DEBUGGING. REMOVE IT FROM MODULE EXPORTS WHEN PUBLISHING
function Expose(interfacePlayable) {
	return registry.playables[interfacePlayable.id()];
}


function startREPL(toREPL) {
	var repl = require("repl");

	var replServer = repl.start({
		prompt: "Nash >> "
	});

	Object.assign(replServer.context, toREPL);
}



var Engine = {
	Frontend: {
		Player,
		_Player, //REMOVE THIS LINE WHEN PUBLISHING
		gamePopulation, //REMOVE THIS LINE WHEN PUBLISHING
		'PlayerList': UserPlayerList,
		Population,
		Information, //REMOVE THIS LINE WHEN PUBLISHING
		PerfectInformation, //REMOVE THIS LINE WHEN PUBLISHING
		'Playables': playableInterfaces,
		registerStrategy,
		registerStrategyObject,
		Strategies,
		loadStrategy,
		loadStrategyFolder,
		History: userGameHistory,
		Queries,
		Expose, //REMOVE THIS LINE WHEN PUBLISHING
		registry, //REMOVE THIS LINE WHEN PUBLISHING
		startREPL, //Should this line be removed when publishing?
		Variable,
		Expression,
		RandomVariable,
		ComplexVariable,
		PluginManager //REMOVE THIS LINE WHEN PUBLISHING
	},

	Backend: {
		logger: log,
		State: { registry, idCounters, gameHistory, gamePopulation, PerfectInformation },
		Classes: {
			Player: _Player,
			History,
			UserHistory,
			PlayerList,
			UserPlayerList,
			Information,
			PlayableClasses: { playableClasses },
			Query,
			QueryResult,
			variablePrototype,
			expressionPrototype
		},
		HelperFunctions,
		PluginManager,
		Expose
	}
}

module.exports = Engine;

},{"./helperFunctions":8,"./history":25,"./information":26,"./logger":27,"./logic":28,"./playables/":32,"./player":43,"./plugin-manager":45,"./population":49,"./query":50,"./state":51,"./strategy":53,"./strategy-loader":52,"repl":1}],7:[function(require,module,exports){
var general = {
	//Check if variable is an Object
	isObject(a) {
		return !!a && a.constructor === Object;
	},

	//What do you think?
	isFunction(a) {
		return typeof a === "function";
	},

	//Provide a function, a context ('this'), and an argument array.
	//Returns a function that can be called.
	applyBind(func, that, argArray) {
		return func.bind.apply(func, [that].concat(argArray));
	},

	//Wraps a function to ensure it only gets called one time.
	once(fn, context) {
		var result;

		return function() {
			if (fn) {
				result = fn.apply(context || this, arguments);
				fn = null;
			}

			return result;
		};
	},

	// Randomly re-order array
	shuffle(array) {
		var currentIndex = array.length,
			temporaryValue,
			randomIndex;

		// While there remain elements to shuffle...
		while (0 !== currentIndex) {
			// Pick a remaining element...
			randomIndex = Math.floor(Math.random() * currentIndex);
			currentIndex -= 1;

			// And swap it with the current element.
			temporaryValue = array[currentIndex];
			array[currentIndex] = array[randomIndex];
			array[randomIndex] = temporaryValue;
		}

		return array;
	}
};

module.exports = general;

},{}],8:[function(require,module,exports){
"use strict";

var log = require("../logger");

log("debug", "helperFunctions-index: Loading helper functions loader.");

/*
var general  = require('./general');
var player   = require('./player');
var playable = require('./playable');
var turn 	 = require('./turn');
var state 	 = require('./state'); 
*/

function loader(file) {
	return require("./" + file + ".js");
}

module.exports = loader;
//module.exports = {general, player, playable, turn, state};

// Hack to compile Glob files (in browserify). DonÂ´t call this function!
(function() {
	require('./general.js');require('./index.js');require('./logic.js');require('./playable.js');require('./player.js');require('./state.js');require('./stock-games.js');require('./tournament.js');require('./turn.js');
});

},{"../logger":27,"./general.js":7,"./index.js":8,"./logic.js":9,"./playable.js":10,"./player.js":11,"./state.js":12,"./stock-games.js":13,"./tournament.js":14,"./turn.js":15}],9:[function(require,module,exports){
"use strict";

var logic = {

	// Check to see if object is Variable/Expression or not. Returns true/false
	isLogic(logic) {

		if (logic instanceof Function && logic == logic * 1) return true
		else return false;
	}
};

module.exports = logic;

},{}],10:[function(require,module,exports){
"use strict";

var { SynchronousPromise } = require('synchronous-promise');

//Game state controllers
var { registry } = require('../state');

var playable = {
	// Generates the function that gets returned when a Playable is called, which can then be called to chain playables together.
	chainerGenerator(externalObj, internalObj) {
		externalObj = this;
		return function(source) {
			var previousPlayable, path;

			//TODO: verify that source is the right type

			return SynchronousPromise.all([function() {
				if (source instanceof Promise || source instanceof SynchronousPromise) {
					source.then(function(result) {
						previousPlayable = registry.playables[result.playable.id()];
						path = result.path
						return SynchronousPromise.resolve();
					});
				}
				return SynchronousPromise.resolve()
			}(), function() {
				if (!(source instanceof Promise || source instanceof SynchronousPromise)) {
					previousPlayable = registry.playables[source.id()];
					path = source.path;
				}
				return SynchronousPromise.resolve();
			}()]).then(function(result) {

				if (path == "all") previousPlayable.addNext(internalObj);
				else {

					outcomeTreeGetValue(previousPlayable.next, path).push(internalObj);
				}

				//previousPlayable.next[selected].push(_choice);

				return SynchronousPromise.resolve({
					'playable': externalObj,
					path: "all"
				});
			});
		};
	},


	//Use to set every value of an outcome tree
	outcomeTreeAddAll(tree, value) {

		//If it's an array, then we're already done.
		if (Array.isArray(tree)) {
			tree.push(value); //Use push here because this will be a unique array
		} else {
			var recurse = function(obj, val) {

				for (var keys in obj) {

					//If no keys left to traverse, then assign value. If not, recurse.
					if (Array.isArray(obj[keys])) {
						obj[keys] = obj[keys].slice().concat(val); //Use slice-concat here because this might not be a unique array (the creation process duplicates them)
					} else recurse(obj[keys], val);

				}
			};
			recurse(tree, value);
		}
	},


	//Traverse an outcome tree to obtain the value for a desired key-set
	//Argument one is a nested object, while argument 2 is an array of keys for the object, 1 layer at a time.
	outcomeTreeGetValue(tree, selector) {

		//Find the next item in the chain associated with the resultant outcome
		for (var i = 0, len = selector.length; i < len; i++) {
			tree = tree[selector[i]];
		}

		return tree;
	},


	//Traverse an outcome tree to set the value for a desired key-set
	//Argument one is a nested object, while argument 2 is an array of keys for the object, 1 layer at a time.
	outcomeTreeSetValue(tree, selector, value) {

		//Find the next item in the chain associated with the resultant outcome
		for (var i = 0, len = selector.length - 1; i < len; i++) {
			tree = tree[selector[i]];
		}

		return tree[selector[i]] = value;
	}
}



module.exports = playable;

},{"../state":51,"synchronous-promise":72}],11:[function(require,module,exports){
"use strict";

//  Game state
var { registry } = require("../state");

// helper function
var { isFunction } = require("./general");

// Player claass
var { _Player } = require("../player");

// Population
var { gamePopulation } = require("../population")

// Plugins
var PluginManager = require("../plugin-manager/")

var player = {

	//reset all players. Recreate from class, re-assign strategy, loop through objects that reference player to set new reference. result argument is only for pass-through.
	reinitializePlayers(population = "all", result = null) {
		return Promise.resolve().then(function() {
			var oldPlayer, strategy, strategyArgs, parameters;

			// if no population is supplied, fetch everybody
			if (population === "all") population = Object.keys(registry.players)
			else(population = population.ids())

			//Redefine each player
			for (var i = 0; i < population.length; i++) {
				var player = population[i];

				oldPlayer = registry.players[player];
				strategy = oldPlayer.strategy ? oldPlayer.strategy._id : null;
				strategyArgs = strategy ? oldPlayer.strategy._args : [];
				parameters = {}; //TODO: when adding player parameters, be sure they're included here

				registry.players[player] = new _Player(oldPlayer.id, parameters);
				registry.players[player].interface = oldPlayer.interface;
				strategy && registry.players[player].assign(strategy, ...strategyArgs);

				// Plugin, to alter players in re-initialization
				PluginManager.run("player-reinitialize", registry.players[player]);
			}

			//For each choice, recreate player references
			for (var choice in registry.choices) {
				if (registry.choices[choice].player)
					registry.choices[choice].player = registry.players[registry.choices[choice].player.id];
			}

			return Promise.resolve(result);
		});
	}
};

module.exports = player;

},{"../player":43,"../plugin-manager/":45,"../population":49,"../state":51,"./general":7}],12:[function(require,module,exports){
"use strict";

var log = require('../logger');

// State variables
var {idCounters, registry} = require('../state');

var state = {
	
	//Handle ID setting for all objects that get stored in the registry
	idHandler: function idHandler(id, type, recursing=false){
		//Assign id
		
		idCounters[type]++;
		var counter = idCounters[type];
		
		if (!id) {
			return type + counter.toString();
		}
		else {
			
			// Check that id isn't taken. If it is, construct a new one.
			
			//Construct list of all objects by extracting all registry entries
			var items = []
			Object.keys(registry).forEach(function(reg){items.push.apply(items, Object.keys(registry[reg]))})
			
			// if id is already taken, generate a new one by adding a number at the end.
			if (items.indexOf(id) > -1) {
				
				var match, oldNum, exp, newId;
				var oldId = id;
				
				do {
					// This finds a number at the end, and increments it, or starts with 1 if there wasn't one.
					match = /\d+$/.exec(id);
					oldNum = match ? match[0] : "";
					exp = new RegExp(oldNum + "$");
					id = id.replace(exp, Number(oldNum) + 1)
				
				}	
				while (items.indexOf(id) >-1)
				
				// Log warning
				log("warn", "ID " + oldId + " is taken. Using instead " + id);
			}
			
			return id
		}
	}
};

module.exports = state;
},{"../logger":27,"../state":51}],13:[function(require,module,exports){
"use strict";

// Strategy registration
var { registerStrategyObject } = require("../engine").Frontend;

// Helper functions
var { isFunction, once } = require("./general");

//External dependency
var esprima = require("esprima");


// For handling queries
var { registry } = require("../engine").Backend.State
var { idHandler } = require("./state")

var registerQueryObject = function(queryObject, gameName) {
	// If there are multiple queries, recurse
	if (Array.isArray(queryObject)) return queryObject.map(function(query) {
		return registerQueryObject(query)
	});

	var { shortcut, query, description = "No description given." } = queryObject;
	// Enforce naming convention, first character '@'
	if (shortcut[0] != "@") shortcut = "@".concat(shortcut)

	// Check for duplicates. Abort if so, but return the data for display purposes.
	if (registry.queries[shortcut] && registry.queries[shortcut].query == query &&
		registry.queries[shortcut].description == description)
		return { shortcut, description };

	// assign id and add to registry
	var id = idHandler(shortcut, "query")
	registry.queries[id] = { query, description }

	//return the data for display purposes
	return { id, description }
}



var stockGames = {
	// utility function to create two ways to call a game, either with all the arguments, or curried, where the returned function takes players and parameters
	// The combineParameters setting will
	gameWrapper(game, {
		argumentValidator = function() { return true; },
		combineParameters = true,
		gameDescription = "No description given.",
		strategyLoader = null,
		queries = null
	} = {}) {

		var generate;

		// If there's a strategy loader, make sure it only runs once
		var loadStrategies
		if (isFunction(strategyLoader)) loadStrategies = once(function() {
			return registerStrategyObject(strategyLoader());
		});
		else loadStrategies = function() {}

		// If there's a query loader, make sure it only runs once
		var loadQueries
		if (queries) loadQueries = once(function() {
			return registerQueryObject(queries);
		});
		else loadQueries = function() {}

		// run the game. Optionally, validate the arguments and load strageies first
		generate = function(...args) {
			var result = argumentValidator(...args)
			if (result === true) {
				loadStrategies();
				loadQueries();
				return game(...args);
			} else throw new Error(result);
		}

		// creates a wrapper around the game, which accepts the first argument (players) and last argument (parameters), and passes it forward.
		// If combineParameters is set to true, then the second argument of the returned function will get merged with the last argument
		// given when generator is called.
		generate.createGenerator = function(...args) {

			var gameCode = esprima.parseScript("(" + game.toString() + ")")

			var gameArgs = gameCode.body[0].expression.params
			var lastArg = gameArgs[gameArgs.length - 1]

			var originalParameters
			if ((lastArg.name && lastArg.name.toLowerCase() === "parameters") || lastArg.type === "ObjectPattern" ||
				(lastArg.type == "AssignmentPattern" && lastArg.left.type == "ObjectPattern")) {
				// Check that the game arguments and createGenerator arguments are the correct lengths. createGenerator should be
				// 1 less than game, because players is omitted.
				// TODO: use esprima to allow players to be anywhere in the game definition (or even omitted) rather than first
				if (args.length == gameArgs.length - 1) originalParameters = args.pop();
			}


			return function(players, parameters = {}) {

				// If combining parameters, merge and remove from arguments
				if (combineParameters && originalParameters) parameters = Object.assign({}, originalParameters,
					parameters)

				return generate(players, ...args, parameters)
			}
		}

		// Allow for game description feature
		generate.description = function() {
			return gameDescription;
		};

		// Display any queries
		generate.queries = function() {
			return queries;
		}

		return generate;
	}


}

module.exports = stockGames;

},{"../engine":6,"./general":7,"./state":12,"esprima":60}],14:[function(require,module,exports){
"use strict";

// Strategies
var { Strategies } = require("../strategy");

// Players
var { Player } = require("../player");

module.exports = {
	// Create a player for each available strategy
	generatePopulation() {
		var players = [];

		Strategies().forEach(function(strategy) {
			players.push(Player({ assign: strategy }));
		});

		return players;
	}
};

},{"../player":43,"../strategy":53}],15:[function(require,module,exports){
"use strict";

var {SynchronousPromise} = require('synchronous-promise');

var turn = {
	
	//Recurse through the options in input, and write val to output. 
	recurse : function recurse(input, output, val, valGenerator=function(){}, path=[]){
		return SynchronousPromise.resolve(path).then(function(path){
			
			//Since we slice the array each time, if there are no more entries left then we're done with this branch.
			if (input.length == 0) return SynchronousPromise.resolve(path)
			
			
			//Among all values from the array
			return SynchronousPromise.all(input[0].map(function(item){
				var value;
				var splitPath = path.slice(0).concat(item);
				
				//If there are more items to iterate over, include them in the output then recurse.
				//If not, put in the new value.
				if (input.length == 1) {
					
					//If val is a function, wrap it in a function that will get supplied an argument with where we are				
					if (typeof val == "function") {
						value = function(){	
							var args = [splitPath].concat(Array.prototype.slice.call(arguments));
							return val.apply(null, args);
						};
					}
					else value = val || valGenerator(splitPath);
					
					output[item] = value;
				}
				else output[item] = {};
				
				
				return recurse(input.slice(1),output[item], val, valGenerator, splitPath);
			}));		
		});
	}
};


module.exports = turn;
},{"synchronous-promise":72}],16:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],17:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"../logger":27,"./general.js":16,"./index.js":17,"./logic.js":18,"./playable.js":19,"./player.js":20,"./state.js":21,"./stock-games.js":22,"./tournament.js":23,"./turn.js":24,"dup":8}],18:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"dup":9}],19:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"../state":51,"dup":10,"synchronous-promise":72}],20:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"../player":43,"../plugin-manager/":45,"../population":49,"../state":51,"./general":16,"dup":11}],21:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"../logger":27,"../state":51,"dup":12}],22:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"../engine":6,"./general":16,"./state":21,"dup":13,"esprima":60}],23:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"../player":43,"../strategy":53,"dup":14}],24:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"synchronous-promise":72}],25:[function(require,module,exports){
"use strict";

var { evaluateQuery } = require("./query")

var { registry } = require("./state")

var { isObject, isFunction } = require("./helperfunctions")("general");

//Extension of array to handle history lists.
function History(...args) {
	if (Array.isArray(args[0])) args = args[0];

	Object.setPrototypeOf(args, History.prototype);

	args.log = args.slice();
	args.log.tree = args;
	Object.setPrototypeOf(args.log, History.prototype);

	args.scores = [];
	args.scores.tree = args;
	Object.setPrototypeOf(args.scores, History.prototype);

	return args;
}

History.prototype = Object.create(Array.prototype);
History.prototype.constructor = History;

//To add entry
History.prototype.add = function(entry) {
	//Add to history and to log
	this.push(entry);
	if (this.log) this.log.push(entry);

	//Cycle up the parent tree, add to each log
	var check = this;
	if (check.tree instanceof History && check.tree.parent instanceof History) {
		check.tree.parent.log.add(entry);
	}
	if (check.parent instanceof History) {
		check.parent.log.add(entry);
	}

	//If we're being called fr

	return this;
};

//To add entry without logging (for playables that would like the tree history
//to be structured differently than the log history.
History.prototype.addNoLog = function(entry) {
	this.push(entry);
	return this;
};


History.prototype.addScores = function(entry) {
	//Add to history
	this.scores.push(entry);

	//Cycle up the parent tree, add to each log
	var check = this;
	if (check.parent instanceof History) {
		check.parent.addScores(entry);
	}



	return this;
};


//A temporary History that can be merged back in later. The child and parent are linked until .orphan() is called.
History.prototype.child = function(parent = this) {
	var h = new History();
	h.parent = parent;
	return h;
};

//Same as .child except includes prior parent history when .print() is called.
History.prototype.childWithContent = function(parent = this) {
	var storedLog = parent.slice();
	var storedScores = parent.slice();

	var h = new History();


	h.log.print = function() {
		History.prototype.print.call(storedLog.concat(h.log))
	}
	h.scores.print = function() {
		History.prototype.print.call(storedScores.concat(h.scores))
	}

	h.parent = parent;
	return h;
};

//This severs the link between the temporary history and its parent. Use this when merging composite entries.
History.prototype.orphan = function() {
	delete this.parent;
	delete this.log;
	delete this.scores;
	return this;
};

//Clear history
History.prototype.clearHistory = function() {
	this.splice(0, this.length);
	if (this.log) this.log.splice(0, this.log.length);
	if (this.scores) this.scores.splice(0, this.scores.length);
	delete this.parent;
};

//End the game.
History.prototype.end = function() {
	this.stop = true;
	if (this.parent) this.parent.end();
};

//Get a particular sort of entry, eg. Turn.
History.prototype.getType = function(type) {
	return new History(
		this.filter(function(entry) {
			//If it's not an object, don't even bother.
			if (!isObject(entry)) return false;

			for (var key in entry) {
				if (key == type) return true;
			}

			return false;
		})
	);
};

History.prototype.mostRecent = function() {
	return this[this.length - 1]
}

//Help read the history in Chrome with less clutter.
History.prototype.print = function() {
	var history = JSON.parse(JSON.stringify(this));
	history.query = History.prototype.query
	return history;
};

History.prototype.query = function(queryString, ...args) {
	return evaluateQuery(queryString, this, ...args)
}

//Supply an entry, it will check for a property that is a History
History.prototype.recurse = function(type) {
	var list = this;

	return new History(
		list.map(function(entry) {
			for (var key in entry) {
				console.log(key, entry);
				if (entry[key] instanceof History) return entry[key].recurse(type);
				else if (key == type) return entry;
			}
			return null;
		})
	);
};

//Accept a History and return one suitable for the user
function UserHistory(history) {
	var userHistory = history.map(function(entry) {
		return JSON.parse(JSON.stringify(entry));
	});
	if (history.log) {
		userHistory.log = new UserHistory(history.log)
	};
	if (history.scores) {
		userHistory.scores = new UserHistory(history.scores)
	}

	Object.setPrototypeOf(userHistory, UserHistory.prototype);

	//Attach methods from History, wrapped in a function. If those methods return a history,
	//then the function will convert that to a userHistory.
	for (var method in History.prototype) {
		if (isFunction(history[method])) {
			if (method != "constructor")
				userHistory[method] = (function(method) {
					return function() {
						var result = history[method].apply(history, arguments);
						if (result instanceof History) return new UserHistory(result);
						else if (isObject(result))
							return JSON.parse(JSON.stringify(result));
						else return result;
					};
				})(method);
		}
	}

	return userHistory;
}

UserHistory.prototype = Object.create(History.prototype);
UserHistory.prototype.constructor = UserHistory;

var gameHistory = new History(); //TODO: add choice-only history

var userGameHistory = function() {
	return new UserHistory(gameHistory)
}

module.exports = { History, UserHistory, gameHistory, userGameHistory };

},{"./helperfunctions":17,"./query":50,"./state":51}],26:[function(require,module,exports){
"use strict";

//When a strategy's .choose() function is called, it is given an information set. That data is a limited map of the internal objects of the game engine, including information on the game history and the players. This is threaded through playables, much like History, so that a parent playable can specify an information set for the playables it calls, or else the default construction will be used. Additionally, the user can provide a filter function, to selectively delete (or add) information elements before they are passed to .choose().

//History functions
var { gameHistory, History } = require('./history');

//Population functions
var { gamePopulation, PlayerList } = require('./population');


function Information(history = gameHistory, population = gamePopulation, { parentHistory = [] } = {}) {
	this.history = history;
	this.population = population;

	// Record any history entries that need to be added to the records
	this.parentHistory = parentHistory.slice(0);

	this.additional = [];

	this.update();
};

//Check the source then cache a hard-copy.
Information.prototype.update = function(player, local) {
	this.infoPopulation = this.population().info();

	this.infoHistory = { log: this.parentHistory.concat(this.history.log).slice(0), scores: this.history.scores
			.slice(0) };

	this.additional = [];

	//Return value. Mimics .deliver()
	var information = {
		history: { log: this.infoHistory.log, scores: this.infoHistory.scores },
		population: this
			.infoPopulation
	}
	if (player) information.me = information.population.get(player.id);
	if (local) Object.assign(information, local);

	return information;
};

//Clone the cached copies and provide them. Will deliver the same thing every time until update is called.
Information.prototype.deliver = function(player, local) {
	var information = {
		history: { log: this.infoHistory.log, scores: this.infoHistory.scores },
		population: this
			.infoPopulation
	}


	if (player) information.me = information.population.get(player.id);
	if (local) Object.assign(information, local);
	if (this.additional) this.additional.forEach(function(entry) { Object.assign(information, entry) });

	return JSON.parse(JSON.stringify(information));
};

//This probably doesn't need to be a separate function, but adding it in case it expands later.
Information.prototype.addAdditional = function(entry = null) {
	if (entry) this.additional.push(entry);
};

//Make copy of this information function, which allows for updating and freezing.
Information.prototype.child = function() {
	var information = new Information(this.history, this.population, { parentHistory: this.parentHistory });

	return information;
};



//Game state, analogous to gameHistory
var PerfectInformation = new Information(gameHistory, gamePopulation);

//Overwrite .deliver(). PerfectInformation is always up-to-date! Thus no need to do a 2nd JSON.stringify.
PerfectInformation.deliver = function(player, local) {

	var information = this.update(player, local);

	if (player) information.me = information.population.get(player.id);
	if (local) Object.assign(information, local);

	return information;
};


module.exports = { Information, PerfectInformation };

},{"./history":25,"./population":49}],27:[function(require,module,exports){
"use strict";



var logger = function() {
	var args = [...arguments];
	var level = (args[0] == "silly" || !args[0]) ? "trace" : args[0];
	var level = level == "warning" ? "warn" : level;
	args.shift();

	logger.logger[level].apply(logger.logger, args);
};

//logger.logger = console;					//TODO clean this all up a lot.

var getLogger = require("loglevel-colored-level-prefix");
var options = { prefix: 'nashJS', level: 'trace' }
logger.logger = getLogger(options)

logger.setLevel = function(level) {
	logger.logger.level = level;
	logger.logger.setLevel(level)
};

/*
logger.useWinston = function(){

	var winston = require('winston');
	var util = require('util');

	winston.level = "warn";

	winston.clear()
	winston.add(winston.transports.Console, {
		level: 'trace',
		prettyPrint:  function ( object ){
			return util.inspect(object);
		},
		colorize: true,
		silent: false,
		timestamp: false
	});

	this.logger = winston;
};
*/

module.exports = logger;

},{"loglevel-colored-level-prefix":66}],28:[function(require,module,exports){
"use strict";

var log = require("./logger");

//Helper functions
var { isFunction } = require("./helperFunctions")("general");

// Extend function, the sneaky way.
var variablePrototype = Object.create(Function.prototype);

variablePrototype.constructor = function(value, { enforceNumber = true } = {}) {
	var variable = this;
	variable.value = enforceNumber ? value * 1 : value;
	variable.enforceNumber = enforceNumber

	this.id = function() {
		return _playable.id;
	}; //TODO: work on ids and registration
};

variablePrototype.call = function() {
	return this.value;
};

variablePrototype.toJSON = function() {
	return this.call();
};
variablePrototype.toString = function() {
	return this.call();
};
variablePrototype.valueOf = function() {
	return this.call();
};

variablePrototype.set = function(newValue) {
	this.value = this.enforceNumber ? newValue * 1 : newValue
	return this.value;
};

//Repurpose the very-similar code for Variable, but re-write certain keys
var expressionPrototype = Object.create(Function.prototype);

expressionPrototype.constructor = function(expression) {
	if (!isFunction(expression)) log("error", "Expression must be a function.");

	var value = expression();
	if (isNaN(value)) log("error", "Expression must return a number"); //TODO: should Expressions/Variables allow strings?

	this.value = expression;

	return value;
};

expressionPrototype.call = function() {
	return this.value() * 1;
};

expressionPrototype.toJSON = function() {
	return this.call();
};
expressionPrototype.toString = function() {
	return this.call();
};
expressionPrototype.valueOf = function() {
	return this.call();
};

expressionPrototype.set = function(newExpression) {
	if (!isFunction(newExpression))
		log("error", "Expression must be a function.");

	var value = newExpression();
	this.value = newExpression;

	return value;
};

//Produces the function that will produce the end result. This part is reusable if you need to do this again.
var classFactory = function(proto) {
	return function() {
		var f = function() {
			return f.call.apply(f, arguments);
		};

		Object.defineProperty(f, "constructor", {
			configurable: true,
			writable: true
		});
		Object.defineProperty(f, "call", {
			writable: true
		});
		Object.defineProperty(f, "toString", {
			writable: true
		});
		Object.defineProperty(f, "valueOf", {
			writable: true
		});

		Object.keys(proto).forEach(function(key) {
			f[key] = proto[key];
		});

		f.constructor.apply(f, arguments);

		return f;
	};
};

var Variable = classFactory(variablePrototype);
var Expression = classFactory(expressionPrototype);
// called as: var instance = Variable();

// A pre-built Expression generator, for generating random numbers
var RandomVariable = function({ lowerbound = 0, upperbound = 10, generator = "uniform" }) {

	if (isFunction(generator)) {
		var expression = Expression(generator);
		expression.generator = generator;
		return expression;

	} else if (generator.toLowerCase() == "uniform") {
		generator = function() {
			return Math.floor(Math.random() * (upperbound - lowerbound + 1) + lowerbound);
		};
		//	TODO: add more distributions here.
	}

	return Expression(generator);
};



// A way to have Variables which are more complicated things, like arrays or obects
var ComplexVariable = function(value) {
	var variable = Variable(value, { enforceNumber: false })

	var excludeList = ["set", "call", "toJSON", "toString", "valueOf"]

	var handler = {
		get(target, key) {
			var prop;
			if (excludeList.indexOf(key) > -1) prop = target[key].bind(target);
			else {
				prop = target.value[key]
				if (isFunction(prop)) prop = prop.bind(target.value)
			}

			return prop
		},
		set(target, key, prop) {
			target.value[key] = prop;
			return true;
		}
	}
	return new Proxy(variable, handler)
}




module.exports = {
	variablePrototype,
	Variable,
	expressionPrototype,
	Expression,
	RandomVariable,
	ComplexVariable
};

},{"./helperFunctions":8,"./logger":27}],29:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Choice");

// External dependency
var { SynchronousPromise } = require("synchronous-promise");

//Game state controllers
var { registry } = require("../state");
var { gameHistory } = require("../history");
var { PerfectInformation } = require("../information");

//Helper functions
var { idHandler } = require("../helperFunctions")("state");
var { isFunction } = require("../helperFunctions")("general");
var { chainerGenerator } = require("../helperFunctions")("playable");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Choice
function _Choice(id, player, options, parameters = {}) {
	_Playable.call(this, id);

	this.next = {};

	this.player = registry.players[player];
	this.options = options;
	this.defaultOption = parameters.defaultOption || options[0]; //TODO: make defaultOption functional
	this.informationFilter = parameters.informationFilter || null;
	this.usePayoffs = parameters.usePayoffs || false;

	registry.choices[id] = this;

	var choice = this;
	this.options.forEach(function(item) {
		choice.next[item] = [];
	});
}

_Choice.prototype = Object.create(_Playable.prototype);
_Choice.prototype.constructor = _Choice;

_Choice.registryName = "choices";
_Choice.counterName = "choice";

_Choice.prototype.play = function({
	usePayoffs = this.usePayoffs,
	history = gameHistory,
	information: rawInformation = PerfectInformation,
	releasePlayer = true,
	informationFilter = this.informationFilter,
	_compileInformation = null
} = {}) {
	var choice = this;

	if (!choice.player.alive)
		return Promise.reject({
			result: choice.id + ": Player " + choice.player.id + " is dead."
		});

	//While this choice is happening, don't allow other choices to use this player.
	choice.player.available = false;

	//Information mechanics. If we're dealing with PerfectInformation, this won't get delivered, so we'll include it in the call to .deliver(). If we're using an information supplied from some other playable, then they can do what they like with it.
	var choiceInfo = {
		choice: {
			id: choice.id,
			player: choice.player.id,
			options: choice.options
		}
	};
	rawInformation.addAdditional(choiceInfo);
	//Perform some data processing if other playables need it.
	if (_compileInformation) _compileInformation(rawInformation);

	return Promise.resolve()
		.then(function() {
			//Prep information
			var information = rawInformation.deliver(choice.player, choiceInfo);
			if (informationFilter) information = informationFilter(information);

			return choice.player.choose(choice.options.slice(0), information);
		})
		.then(function(result) {
			var player = choice.player;
			var id = choice.id;

			//Add to player's individual history;
			player.history.push({
				choice: id,
				options: choice.options,
				result
			});

			result = result || choice.defaultOption;

			var resultObject = {
				result,
				historyEntry: {
					choice: id,
					player: player.id,
					result
				}
			};

			//This will probably only happen if it's a single-player game, otherwise we'll use playoffs defined in a Turn
			if (usePayoffs) {
				var payout = choice.payoffs[result];

				player.score += payout;

				//track the payoff
				var scoreEntry = {
					choice: id,
					payouts: {
						[player.id]: Number(payout)
					}
				};

				history.addScores(scoreEntry);
				resultObject.historyEntry.payouts = {
					[player.id]: payout
				};
			}

			log(
				"silly",
				"_Choice.play: removing from occupiedPlayers: ",
				choice.player.id
			);
			if (releasePlayer) choice.releasePlayer();

			return Promise.resolve(resultObject); //TODO: add information mechanisms
		});
};

//Release player from excluded players list, so that other objects can use it.
_Choice.prototype.releasePlayer = function() {
	this.player.available = true;
};

_Choice.prototype.findNext = function({ result } = {}) {
	return this.next[result.result];
};

_Choice.prototype.generateChainingFunctions = function(choice) {
	var _choice = this;

	_choice.options.forEach(function(option) {
		_choice.payoffs[option] = 0; //Start payoffs at zero

		choice[option] = function(payoff) {
			//Create functions for user to assign payoffs
			if (!isNaN(payoff)) _choice.payoffs[option] = payoff;
			return SynchronousPromise.resolve({
				playable: choice,
				path: [option]
			});
		};
	});
};

_Choice.prototype.summaryThis = function(summary) {
	summary.player = this.player.id;
	summary.options = this.options.slice();

	return summary;
};

//TODO: un-fuck this.
_Choice.prototype.summaryNext = function(
	summary,
	entries = {},
	shortCircuit = false,
	maxEntries = 10
) {
	// Copy over the choice options
	summary.next = Object.assign({}, this.next);

	// Loop through them and summarize at each step.
	var count = 0;
	for (var key in summary.next) {
		summary.next[key] = summary.next[key].map(function(playable) {
			count++;
			return playable.summarize({}, entries);
		});
	}

	// If there weren't any next steps, delete the next key, to reduce clutter.
	if (count == 0) delete summary.next;

	return summary;
};

//Set all payoffs to zero.
_Choice.prototype.zeroPayoffs = function() {
	var choice = this;

	choice.payoffs = {};

	choice.options.forEach(function(option) {
		choice.payoffs[option] = 0;
	});
};

function Choice(player, options, parameters = {}) {
	var id = idHandler(parameters.id, "choice");

	//If informationFilter was supplied, it must be a function
	if (parameters.informationFilter && !isFunction(parameters.informationFilter))
		throw new Error("informationFilter must be a function");

	//Create backend choice object
	var _choice = new _Choice(id, player.id(), options, parameters);

	//Return this reference object to the user. Run the function to select a source
	var choice = Playable(_choice);

	//Interface to specify single-player payoffs in single-player/single-choice games
	_choice.zeroPayoffs();

	_choice.generateChainingFunctions(choice);

	/*
	options.forEach(function(option){
		_choice.payoffs[option] = 0;			//Start payoffs at zero

		choice[option] = function(payoff){					//Create functions for user to assign payoffs
			if (!isNaN(payoff))_choice.payoffs[option] = payoff;
			return Promise.resolve({
				playable:choice,
				path:[option]
			})
		};
	});
	*/

	//Function to set all payoffs at once
	choice.setAllPayoffs = function(payoffs) {
		if (!Array.isArray(payoffs)) throw new Error("Payoffs must be array")
		if (payoffs.length != registry.choices[id].options.length) throw new Error(
			"Payoffs must be same dimensions as choice options")

		payoffs.forEach(function(payoff, index) {
			registry.choices[id].payoffs[options[index]] = payoff;
		})
		//TODO: make this work. Include error handling if array given isn't expected dimensions.
	};

	//Way for user to interact with payoffs
	choice.payoffs = function() {
		return registry.choices[id].payoffs;
	};

	return choice;
}

module.exports = { _Choice, Choice };

},{"../helperFunctions":8,"../history":25,"../information":26,"../logger":27,"../state":51,"./playable":35,"synchronous-promise":72}],30:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Consecutive");

//Game state controllers
var { registry } = require("../state");
var { gameHistory } = require("../history");

//Helper functions
var { idHandler } = require("../helperFunctions")("state");

//Information
var { Information, PerfectInformation } = require("../information");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Consecutive
function _Consecutive(id, playablesArray, parameters = {}) {
	_Playable.call(this, id, parameters);

	playablesArray = playablesArray.map(function(playable) {
		return registry.playables[playable.id()]
	})
	this.playablesArray = playablesArray

	registry.consecutives[id] = this;
}
_Consecutive.prototype = Object.create(_Playable.prototype);
_Consecutive.prototype.constructor = _Consecutive;

_Consecutive.registryName = "consecutives";
_Consecutive.counterName = "consecutive";

_Consecutive.prototype.play = function({
	history = gameHistory,
	information = this.information ||
	PerfectInformation
} = {}) {

	var consecutive = this;

	//Log the history appropriately
	var startEntry = {
		consecutive: consecutive.id,
		action: "start"
	};
	history.log.add(startEntry);

	//History object to give to consecutived playables.
	var consecutiveHistory = history.child();

	//compartmentalize if set. "compartmentalize" means pass on information as if this playable is the entire game.
	if (consecutive.compartmentalize) {
		information = new Information(consecutive.compartmentalize.history || consecutiveHistory,
			consecutive.compartmentalize.population || information.population);
	}

	var action = function action(playablesArray) {
		//Stop if the game is over.
		if (history.stop) return { playable: consecutive };

		if (playablesArray.length > 0) {
			return playablesArray.shift().play({ shortCircuit: true, history: consecutiveHistory, information })
				.then(function(result) {
					return action(playablesArray) || result
				})
		} else return false
	}

	return action(consecutive.playablesArray.slice())
		.then(function(result) {
			result.historyEntry = {
				consecutive: consecutive.id,
				action: consecutiveHistory.orphan()
			};

			//TODO: add information mechanisms

			return Promise.resolve(result);
		});
};

//Overwrite history handler so that tree doesn't have "start" and "finish" entries.
_Consecutive.prototype.handleHistory = function({ history = gameHistory } = {},
	result
) {
	var consecutive = this;

	return Promise.resolve(result).then(function(result) {
		history.log.add({
			consecutive: consecutive.id,
			action: "finish",
			duration: result.historyEntry.duration
		});

		history.addNoLog(result.historyEntry);
		return Promise.resolve(result);
	});
};

//TODO: finish this!
_Consecutive.prototype.summaryThis = function(summary, entries, shortCircuit) {
	summary.action = {};

	this.playableStart.summarize(
		summary.action,
		entries,
		(shortCircuit = this.playableFinish)
	);
};

function Consecutive(playablesArray, parameters = {}) {
	var id = idHandler(parameters.id, "consecutive");

	//Create backend loop object
	var _consecutive = new _Consecutive(id, playablesArray, parameters);

	//Return this reference object to the user. Run the function to select a source
	var consecutive = Playable(_consecutive);

	consecutive.ids = function() {
		return playablesArray.map(function(playable) {
			return playable.id();
		})
	}

	return consecutive;
}

module.exports = { _Consecutive, Consecutive };

},{"../helperFunctions":8,"../history":25,"../information":26,"../logger":27,"../state":51,"./playable":35}],31:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: HaltIf")

//Game state controllers
var {registry} = require('../state');
var {gameHistory} = require('../history');

//Helper functions
var {isFunction}	= require('../helperFunctions')("general");
var {idHandler} 	= require('../helperFunctions')("state");

//Parent class
var {_Playable, Playable} = require('./playable');



//Backend function class for Game
function _Halt(id,testCondition, {logContinue = false}){
	_Playable.call(this,id);
	
	this.testCondition = testCondition;
	this.logContinue = logContinue;
	
	registry.halts[id] = this;
}

_Halt.prototype = Object.create(_Playable.prototype);
_Halt.prototype.constructor = _Halt;

_Halt.registryName = "halts";
_Halt.counterName = "haltIf";

_Halt.prototype.play = function({initializePlayers=false, shortCircuit=false, history=gameHistory}={}){
	
	var halt = this;
	
	var resultObject = {
		'playable':halt,
		'historyEntry':{
			'halt':halt.id
		}
	};
	
	
	var test = halt.testCondition();
	
	
	if (test) {
		log("info", "Halting at " + halt.id)
		
		resultObject.historyEntry.action = "halt";
		resultObject.result = "Halt";
	
		return Promise.reject(resultObject);
	}
	
	//Halt probably gets used for loops, and we might not want to see lots of continue messages, so "logContinue" will omit them.
	if (halt.logContinue) {
		resultObject.historyEntry.action = "continue";
	}
	else delete resultObject.historyEntry
	
	
	return Promise.resolve(resultObject)
};


_Halt.prototype.summaryThis = function(summary){
	summary.condition = this.testCondition.toString();
}



function HaltIf(testCondition=function(){}, {id=null, logContinue=false}={}){
	var id = idHandler(id,"haltIf")
	
	if (!isFunction(testCondition)) log("warn",id + ": testCondition should be a function, or else game will not halt.")

	//Create backend loop object
	var _halt = new _Halt(id, testCondition, {logContinue});
	
	
	//Return this reference object to the user. Run the function to select a source
	var halt = Playable(_halt);	
	return halt;	
}


module.exports = {_Halt, HaltIf};
},{"../helperFunctions":8,"../history":25,"../logger":27,"../state":51,"./playable":35}],32:[function(require,module,exports){
"use strict";

//Loads the playables that will be used by Nash. This is basically the controller list: if it's not in these lists,
// then it won't be available for us.

//External dependency
var present = require("present");

var log = require("../logger");

var { applyBind } = require("../helperFunctions")("general");

log("debug", "Loading Playable Classes: ");

//Playables
var { _Playable } = require("./playable");
var { _Choice, Choice } = require("./choice");
var { _Turn, Turn } = require("./turn");
var { _Sequence, Sequence } = require("./sequence");
var { _Consecutive, Consecutive } = require("./consecutive");
var { _Loop, Loop } = require("./loop");
var { _SLoop, StochasticLoop } = require("./stochasticLoop");
var { _Halt, HaltIf } = require("./halt-if");
var { _SHalt, StochasticHalt } = require("./stochastic-halt");
var { _Lambda, Lambda } = require("./lambda");
var { _RPChoice, RandomPlayerChoice } = require("./random-player-choice");
var { _PopulationDynamics, PopulationDynamics } = require("./population-dynamics");
var { _Simultaneous, Simultaneous } = require("./simultaneous");

//Runs when loading Playable classes.
function initializePlayableClass(playableClass) {
	//Replace the .play() method with a wrapper which calls it and a few other functions
	if (playableClass.prototype.hasOwnProperty("play")) {
		playableClass.prototype.play = (function(play) {
			return function({ history = gameHistory } = {}) {
				var playable = this;
				var args = [].slice.call(arguments);

				// Set our history
				args[0].history ? null : args[0].history = this.history || gameHistory

				// how to halt the game without errors. TODO this is probably fucked
				if (history.stop) return { playable };


				return _Playable.prototype._startTimer
					.apply(playable, args)
					.then(applyBind(playable.checkInit, playable, args))
					.then(applyBind(playable.prePlay, playable, args))
					.then(applyBind(play, playable, args))
					.then(applyBind(playable.postPlay, playable, args))
					.then(applyBind(_Playable.prototype._stopTimer, playable, args))
					.then(applyBind(playable.handleHistory, playable, args))
					.then(applyBind(_Playable.prototype.proceed, playable, args));
			};
		})(playableClass.prototype.play);
	}
}

exports.playableClasses = {
	_Playable,
	_Choice,
	_Turn,
	_Sequence,
	_Consecutive,
	_Loop,
	_SLoop,
	_Halt,
	_SHalt,
	_Lambda,
	_RPChoice,
	_PopulationDynamics,
	_Simultaneous
};
exports.playableInterfaces = {
	Choice,
	Turn,
	Sequence,
	Consecutive,
	Loop,
	StochasticLoop,
	HaltIf,
	StochasticHalt,
	Lambda,
	RandomPlayerChoice,
	PopulationDynamics,
	Simultaneous
};

for (var playableClass in exports.playableClasses) {
	if (playableClass != "_Playable")
		initializePlayableClass(exports.playableClasses[playableClass]);
}

},{"../helperFunctions":8,"../logger":27,"./choice":29,"./consecutive":30,"./halt-if":31,"./lambda":33,"./loop":34,"./playable":35,"./population-dynamics":36,"./random-player-choice":37,"./sequence":38,"./simultaneous":39,"./stochastic-halt":40,"./stochasticLoop":41,"./turn":42,"present":68}],33:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: Lambda")

//Game state controllers
var { registry, gameHistory } = require('../state');

// Information mechanics
var { PerfectInformation } = require("../information");

//Helper functions
var { isFunction } = require('../helperFunctions')("general");
var { idHandler } = require('../helperFunctions')("state");

//Parent class
var { _Playable, Playable } = require('./playable');



//Backend function class for Game
function _Lambda(id, action, parameters = {}) {
	_Playable.call(this, id);

	this.action = action;

	registry.lambdas[id] = this;
}
_Lambda.prototype = Object.create(_Playable.prototype);
_Lambda.prototype.constructor = _Lambda

_Lambda.registryName = "lambdas";
_Lambda.counterName = "lambda";


_Lambda.prototype.play = function({ initializePlayers = false, shortCircuit = false, history = gameHistory,
	information = PerfectInformation } = {}) {

	var lambda = this;

	var result = lambda.action({ history, information })

	var resultObject = {
		result,
		'playable': lambda,
		historyEntry: {
			lambda: lambda.id,
			result
		}
	};

	return Promise.resolve(resultObject)
};

// Simple helper to just run synchronously whatever the Lambda is. Useful for debugging.
_Lambda.prototype.run = function() {
	return this.action();
}

_Lambda.prototype.summaryThis = function(summary) {
	summary.action = this.action.toString();
}


function Lambda(action = function() {}, parameters = {}) {
	var id = idHandler(parameters.id, "lambda")

	if (!isFunction(action)) log("warn", id + ": action should be a function.")

	//Create backend lambda object
	var _lambda = new _Lambda(id, action, parameters);


	//Return this reference object to the user. Run the function to select a source
	var lambda = Playable(_lambda);


	lambda.run = function() {
		return _lambda.run();
	}

	return lambda;
}


module.exports = { _Lambda, Lambda };

},{"../helperFunctions":8,"../information":26,"../logger":27,"../state":51,"./playable":35}],34:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Loop");

//Game state controllers
var { registry } = require("../state");
var { gameHistory, History } = require("../history");

//Helper functions
var { idHandler } = require("../helperFunctions")("state");
var { chainerGenerator } = require("../helperFunctions")("playable");

// Information mechanics
var { Information, PerfectInformation } = require("../information");
var { gamePopulation } = require("../population");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Loop

function _Loop(id, playable, count, parameters) {
	_Playable.call(this, id, parameters);

	var { logContinue = true, playableParameters = {} } = parameters;

	this.playable = registry.playables[playable.id()];
	this.logContinue = logContinue;
	this.playableParameters = playableParameters;

	this.count = count;

	registry.loops[id] = this;
}
_Loop.prototype = Object.create(_Playable.prototype);
_Loop.prototype.constructor = _Loop;

_Loop.registryName = "loops";
_Loop.counterName = "loop";

_Loop.prototype.play = function({
	history = this.history || gameHistory,
	information = this.information || PerfectInformation,
	playableParameters = this.playableParameters
} = {}) {

	var loop = this;
	loop.counter = 0;

	// Split the history entry
	var loopHistory = history.child();

	// information mechanics.
	//compartmentalize If set
	if (loop.compartmentalize) {
		information = new Information(loop.compartmentalize.history || loopHistory,
			loop.compartmentalize.population || information.population);
	}
	// Pass along
	playableParameters.information = information


	var promise = Promise.resolve();

	var action = function(result) {
		//If the game has been ended early, don't continue.
		if (history.stop) return { playable: loop };

		loop.counter++;
		if (!result) result = {};

		//Deal with history
		history.log.add({
			loop: loop.id,
			loopTo: loop.playable.id,
			count: loop.counter
		});

		playableParameters.shortCircuit = true;
		playableParameters.history = loopHistory;

		return loop.playable.play(playableParameters).then(function(result) {
			//Re-format result, replace playable with Loop playable
			result.playable = loop;

			//TODO: add information mechanisms

			return Promise.resolve(result);
		});
	};

	//Repeat the playable loop.count times, by chaining promises.
	for (var i = 0; i < loop.count; i++) {
		promise = promise.then(action);
	}

	return promise.then(function(result) {
		result.historyEntry = {
			loop: loop.id,
			count: loop.counter,
			action: loopHistory.orphan()
		};
		return Promise.resolve(result);
	});
};

//Overwrite history handler to prevent "loop finished" entry from hitting the tree.
_Loop.prototype.handleHistory = function({
		history = this.history || gameHistory,
		information = this.information || PerfectInformation,
		logContinue = this.logContinue
	} = {},
	result
) {
	var loop = this;

	return Promise.resolve(result).then(function(result) {
		//Write final entry if logContinue is set to true
		if (logContinue) {
			history.log.add({
				loop: loop.id,
				loopTo: "Loop finished.",
				count: loop.counter
			});
		}

		history.addNoLog(result.historyEntry);

		return result;
	});
};

// Add detail/nesting to summary.
_Loop.prototype.summaryThis = function(summary, entries) {
	summary.count = this.count;

	summary.action = {};
	this.playable.summarize(summary.action, entries, true);
};

function Loop(playable, count = 1, parameters = {}) {
	var id = idHandler(parameters.id, "loop");

	//Create backend loop object
	var _loop = new _Loop(id, playable, count, parameters);

	//Return this reference object to the user. Run the function to select a source
	var loop = Playable(_loop);
	return loop;
}

module.exports = { _Loop, Loop };

},{"../helperFunctions":8,"../history":25,"../information":26,"../logger":27,"../population":49,"../state":51,"./playable":35}],35:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Playable");

var { SynchronousPromise } = require("synchronous-promise");
var present = require("present");

//Game state controllers
var { registry, idCounters } = require("../state");
var { gameHistory, History } = require("../history");

//Helper functions
var { isFunction } = require("../helperFunctions")("general");
var { outcomeTreeAddAll, outcomeTreeGetValue } = require("../helperFunctions")("playable");
var { reinitializePlayers } = require("../helperFunctions")("player");

//To return to user
var { Population, PlayerList } = require("../population");

//_playable class, superclass for objects which can execute game steps (choice, turn, game)
function _Playable(id, parameters = {}) {
	this.id = id;
	this.next = [];
	registry.playables[id] = this;
	idCounters.playable++;

	parameters.compartmentalize ? this.compartmentalize = parameters.compartmentalize : null;
	parameters.history ? (this.history = parameters.history) : null;
	parameters.information ? (this.information = parameters.information) : null;
	parameters.initializePlayers ? (this.initializePlayers = parameters.initializePlayers) : null;
}

_Playable.registryName = "playables";
_Playable.counterName = "playable";

//Add reference to next playable branch, to chain playables together.
_Playable.prototype.addNext = function(nextPlayable) {
	outcomeTreeAddAll(this.next, nextPlayable);
};

//Called before .play() to start timing.
_Playable.prototype._startTimer = function() {
	this._timer = present();
	return Promise.resolve();
};

//Called before prePlay, initialize players if true.
_Playable.prototype.checkInit = function({ initializePlayers = this.initializePlayers } = {}, result) {
	// if we get something
	if (initializePlayers) {
		// if it's just true, then reinitialize everybody
		if (initializePlayers === true) return reinitializePlayers("all", result)

		// if it's a playerList, use that
		else if (initializePlayers instanceof PlayerList) return reinitializePlayers(initializePlayers)

		// if we get a function, then run the function and check that it's returning a playerList
		else if (isFunction(initializePlayers)) {
			var list = initializePlayers()
			if (list instanceof PlayerList) return reinitializePlayers(list, result);
		}

		// otherwise, convert it to a playerList and let PlayerList deal with it.
		else return reinitializePlayers(new PlayerList(initializePlayers), result);
	}

	// if we didn't get anything or got false, we're done here.
	else return Promise.resolve(result);
};


//Called before .play() but after _startTimer
_Playable.prototype.prePlay = function({} = {}, result) {
	return Promise.resolve(result);
};

//Called after .play(), overwritable.
_Playable.prototype.postPlay = function({} = {}, result) {
	return Promise.resolve(result);
};

//Called after .postPlay() to stop timer and log.
_Playable.prototype._stopTimer = function({} = {}, result) {
	if (result.historyEntry)
		result.historyEntry.duration = present() - this._timer;
	delete this._timer;

	return Promise.resolve(result);
};

//Called after timer stops, to write log. Overwiteable if playable has specific logging behavior.
_Playable.prototype.handleHistory = function({ history = gameHistory } = {},
	result
) {
	return Promise.resolve(result).then(function(result) {
		if (result.historyEntry) history.add(result.historyEntry);
		return Promise.resolve(result);
	});
};

//Determine whether to play next, and if so, do.
_Playable.prototype.proceed = function({ shortCircuit } = {}, result) {
	var playable = this;

	return Promise.resolve(result).then(function(result) {
		//Replace reported playable with latest running playable (this is necessary for short-circuit logic)
		result.playable = playable;

		//Short-circuit logic allows higher-order playable to figure out what to do next.
		if (shortCircuit) return Promise.resolve(result);

		return playable.playNext(result);
	});
};

//Play next.
_Playable.prototype.playNext = function(result, parameters = {}) {
	var playable = this;

	return Promise.resolve(result).then(function(result) {
		//Find out where to go next
		var next = playable.findNext({ result });

		//If there's somewhere to go, then go.
		if (next[0] instanceof _Playable)
			return Promise.all(
				next.map(function(playable) {
					return playable.play(parameters);
				})
			);

		//Otherwise, we're done here
		return Promise.resolve(result);
	});
};

// Return the next playable in the sequence. Overwriteable for playables with more complicated branching.
_Playable.prototype.findNext = function() {
	return this.next;
};

_Playable.prototype._summarize = function() {};

// Summarize the game structure. Calls summaryThis and summaryNext, which are overwritable.
_Playable.prototype.summarize = function(
	summary = {},
	entries = {},
	shortCircuit = false,
	maxEntries = 10
) {
	// Start summary for this playable
	summary[this.constructor.counterName] = this.id;

	// Track how many times we've been here before, to avoid circular recursion
	entries[this.id] ? ++entries[this.id] : (entries[this.id] = 1);
	if (entries[this.id] > maxEntries) shortCircuit = true;

	// Add summary
	this.summaryThis(summary, entries);

	// Proceed to next steps
	if (!shortCircuit || shortCircuit !== this)
		this.summaryNext(summary, entries);

	return summary;
};

// Adds the summary information on this playable. Overwrite this in order to add specific information.
_Playable.prototype.summaryThis = function(summary = {}, entries = {}) {
	return summary;
};

// Adds summary information down the next-path. Overwite this for playables with more complex branching.
_Playable.prototype.summaryNext = function(summary = {}, entries = {}) {
	// If there's a next-entry
	if (this.next.length > 0) {
		// Loop over each next-item, and summarize it.
		summary.next = this.next.map(function(playable) {
			return playable.summarize({}, entries);
		});

		// If there's only one item, no need for an array.
		if (summary.next.length == 1) summary.next = summary.next[0];
	}
};


//Convoluted code here to produce the object that user interacts with (ie c1 in 'c1 = Choice()')
//This mimics creating a class that inherits from Function. First define the "prototype", which includes
//a "constructor", a "call" method that will get called, and any other properties and methods.
//Then 'classFactory' produces the class/constructing object (see below), which you can use to
//produce the actual objects.

var playablePrototype = Object.create(Function.prototype);

playablePrototype.constructor = function(_playable) {
	var playable = this;

	//Tag-back. Store the front-end object in the back-end object, for retrieval
	_playable.interface = playable;

	this.call = function(source) {
		var previousPlayable, path;

		//TODO: verify that source is the right type

		return SynchronousPromise.all([
			(function() {
				if (source instanceof Promise || source instanceof SynchronousPromise) {
					source.then(function(result) {
						previousPlayable = registry.playables[result.playable.id()];
						path = result.path;
						console.log(path);
						return SynchronousPromise.resolve();
					});
				}
				return SynchronousPromise.resolve();
			})(),
			(function() {
				if (!(source instanceof Promise || source instanceof SynchronousPromise)) {
					previousPlayable = registry.playables[source.id()];
					path = source.path;
				}

				return SynchronousPromise.resolve();
			})()
		]).then(function(result) {
			console.log(path);
			log(
				"debug",
				"Adding next playable to " +
				previousPlayable.id +
				", node " +
				_playable.id
			);

			if (path == "all") previousPlayable.addNext(_playable);
			else {
				outcomeTreeGetValue(previousPlayable.next, path).push(_playable);
			}

			log("silly", previousPlayable.next);
			//previousPlayable.next[selected].push(_choice);

			return SynchronousPromise.resolve({
				playable: playable,
				path: "all"
			});
		});
	};

	this.id = function() {
		return _playable.id;
	};

	this.play = function({
		initializePlayers = false,
		usePayoffs = true,
		shortCircuit = false,
		writeHistory = true,
		clearHistory = true,
		releasePlayers = true
	} = {}) {

		if (clearHistory) gameHistory.clearHistory();

		var history = writeHistory ?
			_playable.history || gameHistory :
			new History();

		return Promise.resolve()
			.then(function(result) {
				return _playable.play({ initializePlayers, usePayoffs, shortCircuit, history, releasePlayers });
			})
			.catch(function(reason) {
				console.log(reason);

				//If the game was stopped by a Halt playable or everybody's dead, we'll end up here, and things are fine. Just log it.
				if (reason.result == "Halt") {
					gameHistory.add(reason.historyEntry);
					return Promise.resolve(reason.result);
				} else if (reason.result == "Population Collapse")
					return Promise.resolve(reason.result);
				else {
					history.log.add({ error: reason });
					return Promise.reject(reason);
				}
			})
			.then(function(result) {
				//Replace result, so that user can't get access to _playables

				return Promise.resolve({
					Population: Population(),
					gameHistory
				});
			});
	};

	this.summarize = function() {
		return _playable.summarize({});
	};
};

playablePrototype.call = function() {
	//This will get overwritten when the "constructor" is called, but leaving it here so you can figure out how the hell this works.
};

playablePrototype.path = "all";

//Produces the function that will produce the end result. This part is reusable if you need to do this again.
var classFactory = function(proto) {
	return function() {
		var f = function() {
			return f.call.apply(f, arguments);
		};

		Object.defineProperty(f, "constructor", {
			configurable: true,
			writable: true
		});
		Object.defineProperty(f, "call", { writable: true });

		Object.keys(proto).forEach(function(key) {
			f[key] = proto[key];
		});

		f.constructor.apply(f, arguments);

		delete f.constructor; //Added this bit here, to prevent the user from trying to create new objects.

		return f;
	};
};

var Playable = classFactory(playablePrototype);
// called as: var instance = Playable(/* some internal object like _choice */);

module.exports = { _Playable, Playable };

},{"../helperFunctions":8,"../history":25,"../logger":27,"../population":49,"../state":51,"present":68,"synchronous-promise":72}],36:[function(require,module,exports){
"use strict";

var log = require('../logger');

//External dependency
var poisson = require('randgen').rpoisson;

//Game state controllers
var {registry, gameHistory} = require('../state');

//Helper functions
var {isFunction}	= require('../helperFunctions')("general");
var {idHandler} 	= require('../helperFunctions')("state");

//Parent class
var {_Playable, Playable} = require('./playable');

//Player controllers
var {_Player, Player} = require('../player');
var {PlayerList, UserPlayerList, gamePopulation, Population} = require('../population');

//Update this each time .play is called, but leave it available to the whole scope so that 
//growth and decay can access it
var population;

//Default growth function
var growthDefault = function growth(player, population, birthRate, selectiveMultiplier) {
	var score = player.score;
	var mean = population.scoresMean();
	var std = population.scoresStd();
	
	var Z = !(isNaN(std) || std==0) ? (score-mean)/std : 0
	
	console.log(score, mean, std,Z);
	
	var rate = birthRate + selectiveMultiplier*Z;

	var generated = poisson(rate);
	log("silly","growthDefault: generated random number " + generated.toString()+ " using rate "+ rate.toString());
	
	return generated;
}

//Default decay function
var decayDefault = function decay(player, population, deathRate, selectiveMultiplier) {
	var score = player.score;
	var mean = population.scoresMean();
	var std = population.scoresStd();
	
	console.log(score, mean, std);
	
	var Z =  !(isNaN(std)||std==0) ? (score-mean)/std : 0;
	
	console.log(Z)
	var rate = deathRate - selectiveMultiplier*Z;
	
	var generated = poisson(rate);
	log("silly","decayDefault: generated random number " + generated.toString()+ " using rate "+ rate.toString());
	return generated;
}



//Backend function class for PopulationDynamics
function _PopulationDynamics(id, birthRate,deathRate, {growthFunction=growthDefault, decayFunction=decayDefault, selectiveMultiplier= .5, playerParameters={}}={}){
	_Playable.call(this,id);
	
	var pd = this;
	
	this.birthRate = birthRate;
	this.deathRate = deathRate;
	this.selectiveMultiplier = selectiveMultiplier;
	
	//Wrap the growth and decay functions, so that the user doesn't have to worry about calling this.birthRate or this.deathRate
	this.growth = function(player){
		log("silly","_pd.growth: Checking grow condition");
		return growthFunction(player, population, pd.birthRate, pd.selectiveMultiplier)
	};
	this.decay = function(player){
		log("silly","_pd.decay: Checking decay condition");
		return decayFunction(player, population, pd.deathRate, pd.selectiveMultiplier);
	};
	
	this.playerParameters = playerParameters;
	
	registry.controllers[id] = this;
}
_PopulationDynamics.prototype = Object.create(_Playable.prototype);
_PopulationDynamics.prototype.constructor = _PopulationDynamics;

_PopulationDynamics.registryName = "controllers";
_PopulationDynamics.counterName = "populationDynamics";


_PopulationDynamics.prototype.play = function({initializePlayers=false, shortCircuit=false, history=gameHistory}={}){
	
	var pd = this;
	
	var births = 0;
	var deaths = 0;
	
	//Update population using whoever's alive currently
	population = gamePopulation().onlyAlive();
		
	
	//Kill cycle
	var killed = new PlayerList([]);
	population.forEach(function(player){
		// If the decay function is returns truthy, kill.
		
		if (pd.decay(player)) {
			log("silly","must kill...")
			player.kill();
			deaths++;
			killed.push(player);
			log("silly","dead");
		}
		
		
	});
	
	//Update update again to prevent the recently deceased from reproducing
	population = gamePopulation().onlyAlive();
	
	if (population.length == 0) {
		//Everybody's dead. Let's wrap it up.
		var reason = {result:"Population Collapse", playable:pd};
		history.end();
		return Promise.resolve(reason);
	}
	
	//Birth cycle
	var born = new UserPlayerList([]);
	population.forEach(function(player){
		//Birth whatever number is returned
		var numBirth = pd.growth(player)
		console.log(numBirth);
		for (var i=1; i<=numBirth; i++){
			log("silly", "Player " + player.id +" giving birth!");
			
			var playerParameters = Object.assign({},{
					assign:player.strategy ? player.strategy._id : "",
					parent:player.id}
				,pd.playerParameters);
			
			born.push(Player(playerParameters));
		}	
	});
	
	
	var result = {births, deaths};
	
	var resultObject = {
		result,
		'playable':pd,
		historyEntry:{
			populationDynamics:pd.id,
			result
		}
	};
	
	return Promise.resolve(resultObject);
};



function PopulationDynamics(birthRate=.05, deathRate = .05, parameters={}){
	var id = idHandler(parameters.id,"populationDynamics")
	
	if (parameters.growth && !isFunction(growth)) log("error",id + ": growth should be a function.");
	if (parameters.decay && !isFunction(decay))   log("error",id + ": decay should be a function.");
		
	//Create backend lambda object
	var _pd = new _PopulationDynamics(id, birthRate, deathRate, parameters);
	
	
	//Return this reference object to the user. Run the function to select a source
	var pd = Playable(_pd);	
	return pd;	
}


module.exports = {_PopulationDynamics, PopulationDynamics};
},{"../helperFunctions":8,"../logger":27,"../player":43,"../population":49,"../state":51,"./playable":35,"randgen":69}],37:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: RandomPlayerChoice")

//Game state controllers
var { registry, gameHistory, occupiedPlayers } = require('../state');

//Helper functions
var { idHandler } = require('../helperFunctions')("state");
var { chainerGenerator } = require('../helperFunctions')("playable");

//Parent class
var { _Playable, Playable } = require('./playable');
var { _Choice, Choice } = require('./choice');

//Population helpers
var { PlayerList } = require('../population');


//Backend function class for RPChoice
function _RPChoice(id, options, parameters = {}) {

	//If they specify players to draw from, use only that list. Otherwise, use whoever's around.
	this.includePlayers = parameters.includePlayers || "all";

	this.excludePlayers = parameters.excludePlayers ? new PlayerList(parameters.excludePlayers) : new PlayerList()

	this.generator = Math.random;

	var player = null;


	_Choice.call(this, id, player, options, parameters);
}

_RPChoice.prototype = Object.create(_Choice.prototype);
_RPChoice.prototype.constructor = _RPChoice;

_RPChoice.registryName = "choices";
_RPChoice.counterName = "randomPlayerChoice";



//Select the player to make the choice
_RPChoice.prototype.choosePlayer = function choosePlayer() {

	var rpChoice = this;

	return Promise.resolve().then(function() {

		//Find players to choose from
		var pool = new PlayerList(rpChoice.includePlayers).onlyAlive().onlyAvailable().exclude(rpChoice.excludePlayers)
		if (pool.length == 0) return Promise.reject("No available players.");

		log("silly", "rpChoice.choosePlayer: choosing froom pool: " + pool.ids());

		var randomNumber = Math.floor(rpChoice.generator() * pool.length);
		var candidate = pool[randomNumber];


		log("silly", "rpChoice.choosePlayer: selecting player ", candidate.id)

		rpChoice.player = candidate;
		candidate.available = false;

		return Promise.resolve(candidate.id);
	});
};

_RPChoice.prototype.prePlay = function() {
	return this.choosePlayer();
};


_RPChoice.prototype.summaryThis = function(summary) {
	summary.options = this.options;
};



function RandomPlayerChoice(options, parameters = {}) {
	var { id = null, excludePlayers = [], playerList = null } = parameters

	var id = idHandler(id, "randomPlayerChoice")

	//Create backend choice object
	var _rpChoice = new _RPChoice(id, options, parameters);

	//Return this reference object to the user. Run the function to select a source
	var rpChoice = Playable(_rpChoice)

	rpChoice.playerList = function(playerList) {
		if (Array.isArray(playerList)) _rpChoice.playerList = playerList;
		return _rpChoice.playerList
	};

	rpChoice.excludePlayers = function(excludePlayers) {
		if (Array.isArray(excludePlayers)) {
			_rpChoice.excludePlayers = [];

			excludePlayers.forEach(function(player) {
				_rpChoice.excludePlayers.push(player.id());
			});

		}
		return _rpChoice.excludePlayers
	};

	//Interface to specify single-player payoffs in single-player/single-choice games
	_rpChoice.zeroPayoffs();

	_rpChoice.generateChainingFunctions(rpChoice);

	//Function to set all payoffs at once
	rpChoice.setAllPayoffs = function(payoffs) {
		//TODO: make this work. Include error handling if array given isn't expected dimensions.
	};


	//Way for user to interact with payoffs
	rpChoice.payoffs = function() { return registry.choices[id].payoffs; };

	return rpChoice;
}



module.exports = { _RPChoice, RandomPlayerChoice };

},{"../helperFunctions":8,"../logger":27,"../population":49,"../state":51,"./choice":29,"./playable":35}],38:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Sequence");

//Game state controllers
var { registry } = require("../state");
var { gameHistory } = require("../history");

//Helper functions
var { idHandler } = require("../helperFunctions")("state");

//Information
var { Information, PerfectInformation } = require("../information");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Sequence
function _Sequence(id, playableStart, playableFinish, parameters = {}) {
	_Playable.call(this, id, parameters);

	this.playableStart = registry.playables[playableStart.id()];
	this.playableFinish = registry.playables[playableFinish.id()];

	registry.sequences[id] = this;
}
_Sequence.prototype = Object.create(_Playable.prototype);
_Sequence.prototype.constructor = _Sequence;

_Sequence.registryName = "sequences";
_Sequence.counterName = "sequence";

_Sequence.prototype.play = function({
	history = gameHistory,
	information = this.information ||
	PerfectInformation
} = {}) {

	var sequence = this;

	//Log the history appropriately
	var startEntry = {
		sequence: sequence.id,
		action: "start"
	};
	history.log.add(startEntry);

	//History object to give to sequenced playables.
	var sequenceHistory = history.child();

	//compartmentalize if set. "compartmentalize" means pass on information as if this playable is the entire game.
	if (sequence.compartmentalize) {
		information = new Information(sequence.compartmentalize.history || sequenceHistory,
			sequence.compartmentalize.population || information.population);
	}

	// Recursion down the chain of playables
	var action = function action(result) {
		//Stop if the game is over.
		if (history.stop) return { playable: sequence };

		//Otherwise, recurse to figure out what to do next.
		if (Array.isArray(result)) {
			log("silly", "sequence.play: Next-item is an array, splitting into pieces.");

			return Promise.all(
				result.map(function(item) {
					log("silly", "sequence.play: recursing on", item);
					return action(item);
				})
			);
		}

		if (result.playable !== sequence.playableFinish) {
			log("silly", result);

			if (result.playable.findNext({ result }).length > 0) {
				log("silly", "Playable has next-item, continuing down chain.");

				return result.playable.playNext(result, { shortCircuit: true, history: sequenceHistory, information })
					.then(action); //Repeat for next playable in chain
			}
			return Promise.resolve(result);
		}
		return Promise.resolve(result);
	};

	return sequence.playableStart
		.play({ shortCircuit: true, history: sequenceHistory, information })
		.then(action)
		.then(function(result) {
			result.historyEntry = {
				sequence: sequence.id,
				action: sequenceHistory.orphan()
			};

			//TODO: add information mechanisms

			return Promise.resolve(result);
		});
};

//Overwrite history handler so that tree doesn't have "start" and "finish" entries.
_Sequence.prototype.handleHistory = function({ history = gameHistory } = {},
	result
) {
	var sequence = this;

	return Promise.resolve(result).then(function(result) {
		history.log.add({
			sequence: sequence.id,
			action: "finish",
			duration: result.historyEntry.duration
		});

		history.addNoLog(result.historyEntry);
		return Promise.resolve(result);
	});
};

//TODO: finish this!
_Sequence.prototype.summaryThis = function(summary, entries, shortCircuit) {
	summary.action = {};

	this.playableStart.summarize(
		summary.action,
		entries,
		(shortCircuit = this.playableFinish)
	);
};

function Sequence(playableStart, playableFinish, parameters = {}) {
	var id = idHandler(parameters.id, "sequence");

	//Create backend loop object
	var _sequence = new _Sequence(id, playableStart, playableFinish, parameters);

	//Return this reference object to the user. Run the function to select a source
	var sequence = Playable(_sequence);
	return sequence;
}

module.exports = { _Sequence, Sequence };

},{"../helperFunctions":8,"../history":25,"../information":26,"../logger":27,"../state":51,"./playable":35}],39:[function(require,module,exports){
"use strict";

var log = require('../logger');

//Helper functions
var { isObject } = require('../helperFunctions')("general");
var { idHandler } = require('../helperFunctions')("state");

//Parent class
var { _Playable, Playable } = require('./playable');

// Information mechanics
var { Information, PerfectInformation } = require('../information');


//Backend class
function _Simultaneous(id, playableArray, { playableParameters = {} } = {}) {
	_Playable.call(this, id);

	this.playableArray = playableArray;
	this.playableParameters = playableParameters;

	registry.controllers[id] = this;
}

_Simultaneous.prototype = Object.create(_Playable.prototype);
_Simultaneous.prototype.constructor = _Simultaneous;

_Simultaneous.registryName = "controllers";
_Simultaneous.counterName = "simultaneous";


//Simultaneous Promise.all's the playables, which causes them to run meshed.
_Simultaneous.prototype.play = function({ history = gameHistory, information = PerfectInformation } = {}) {

	var simultaneous = this;

	// Deal with history. Log start, then split history for children playables to fill in.
	history.log.add({
		simultaneous: simultaneous.id,
		action: "Simultaneous start."
	});
	var simultaneousHistory = []



	//TODO: is information mechanics correct?

	return Promise.all(simultaneous.playableArray.map(function(playable) {

		var branchHistory = history.child();
		simultaneousHistory.push(branchHistory)

		// Information mechanics
		var infoPopulation, parentHistory, infoHistory = branchHistory;
		//compartmentalize if set. "compartmentalize" means pass on information as if this playable is the entire game.
		if (simultaneous.compartmentalize) {
			infoPopulation = simultaneous.compartmentalize.population || information.population;
			parentHistory = simultaneous.compartmentalize.history || information.history;
		} else {
			infoPopulation = information.population;
			parentHistory = information.history
		}
		var simultaneousInformation = new Information(infoHistory, infoPopulation, { parentHistory });



		return playable.play({ history: branchHistory, information: simultaneousInformation });
	})).then(function(resultArray) {

		var resultObject = {
			resultArray,
			playable: simultaneous,
			historyEntry: {
				simultaneous: simultaneous.id,
				action: simultaneousHistory.map(function(history) {
					return history.orphan();
				})
			}
		};
		return resultObject;
	});
};


_Simultaneous.prototype.handleHistory = function({ history = gameHistory } = {}, result) {

	history.log.add({
		simultaneous: this.id,
		action: "Simultaneous complete."
	});

	history.addNoLog(result.historyEntry);

	return Promise.resolve(result);
};

_Simultaneous.prototype.summaryThis = function(summary, entries) {
	summary.action = [];

	this.playableArray.forEach(function(playable, index) {
		summary.action[index] = {}
		playable.summarize(summary.action[index], entries);
	});
}


//Frontend class
function Simultaneous(playableArray, parameters = {}) {
	var id = idHandler(parameters.id, "simultaneous")

	playableArray = playableArray.map(function(playable) {
		return registry.playables[playable.id()];
	});


	//Create backend instance.
	var _simultaneous = new _Simultaneous(id, playableArray, parameters);

	//Return this reference object to the user. Run the function to select a source
	var simultaneous = Playable(_simultaneous);
	return simultaneous;
}


module.exports = { _Simultaneous, Simultaneous };

},{"../helperFunctions":8,"../information":26,"../logger":27,"./playable":35}],40:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: Stochastic-Halt")

//Game state controllers
var {registry, gameHistory} = require('../state');

//Helper functions
var {isFunction}	= require('../helperFunctions')("general");
var {idHandler} 	= require('../helperFunctions')("state");

//Parent class
var {_Playable, Playable} 	= require('./playable');
var {_Halt, Halt}			= require('./halt-if');


//Backend function class for SHalt
function _SHalt(id, probability, parameters){
	_Halt.call(this,id,null,parameters);
	
	var sHalt = this;
	
	this.probability = probability;
	this.generator = Math.random;				//TODO: allow user to specify random number generator
	
	this.testCondition = function(){
		if (sHalt.generator() < sHalt.probability) return true;
	};
	
	
	registry.sHalts[id] = this;
}
_SHalt.prototype = Object.create(_Halt.prototype);
_SHalt.prototype.constructor = _SHalt;

_SHalt.registryName = "sHalts";
_SHalt.counterName = "stochasticHalt";

/*
_SHalt.prototype.play = function({initializePlayers=false, shortCircuit=false}={}){
	
	var sHalt = this;
	var test = sHalt.testCondition();
	
	if (test) {
		log("info", "Halting at " + sHalt.id)
		
		return Promise.reject({
			result:"Halt",
			playable:sHalt
		});
	}
	
	var resultObject = {
		'result':"Continued",
		'playable':sHalt
	};
	
	return Promise.resolve(resultObject)
	.then(function(result){	
		
		//TODO: add information mechanisms
		
		return Promise.resolve(result)		
	}).then(function(result){
		
		return sHalt.proceed(result, shortCircuit);
	});
};
*/

_SHalt.prototype.summaryThis = function(summary, entries){
	summary.probability = this.probability;
}


function StochasticHalt(probability, {id=null, logContinue=false}={}){
	var id = idHandler(id,"stochasticHalt")
	
	if (isNaN(probability) || probability < 0 || probability > 1) throw new Error('Invalid probability');

	//Create backend sHalt objects
	var _sHalt = new _SHalt(id, probability, {logContinue});
	
	
	//Return this reference object to the user. Run the function to select a source
	var sHalt = Playable(_sHalt);	
	return sHalt;	
}


module.exports = {_SHalt, StochasticHalt};
},{"../helperFunctions":8,"../logger":27,"../state":51,"./halt-if":31,"./playable":35}],41:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: StochasticLoop")

//Game state controllers
var { registry, gameHistory } = require('../state');

//Helper functions
var { idHandler } = require('../helperFunctions')("state");
var { chainerGenerator } = require('../helperFunctions')("playable");

//Parent classes
var { _Playable, Playable } = require('./playable');
var { _Loop, Loop } = require('./loop');


//Backend function class for StochasticLoop
function _SLoop(id, playable, probability, parameters) {
	_Loop.call(this, id, playable, null, parameters);

	this.playable = registry.playables[playable.id()];

	//This inherits from Loop which uses a count. Delete that and replace with probability.
	delete this.count;
	this.probability = probability;

	this.generator = Math.random; //TODO: allow user to specify random number generator

	registry.sLoops[id] = this;
}
_SLoop.prototype = Object.create(_Loop.prototype);
_SLoop.prototype.constructor = _SLoop;

_SLoop.registryName = "sLoops";
_SLoop.counterName = "stochasticLoop";


_SLoop.prototype.play = function({
	initializePlayers = false,
	shortCircuit = false,
	history = gameHistory,
	information: PerfectInformation
} = {}) {

	var sLoop = this;
	sLoop.counter = 0;
	var loopHistory = history.child();

	if (sLoop.compartmentalize) {
		information = new Information(sLoop.compartmentalize.history || loopHistory,
			sLoop.compartmentalize.population || information.population);
	}


	var promise = Promise.resolve({});

	//Section that will be looped
	var action = function(result) {

		sLoop.counter++;
		if (!result) result = {};


		//Deal with history
		history.log.add({
			loop: sLoop.id,
			loopTo: sLoop.playable.id,
			count: sLoop.counter
		});

		return sLoop.playable.play({ shortCircuit: true, history: loopHistory, information })
			.then(function(result) {

				result.playable = sLoop;
				//TODO: add information mechanisms

				return Promise.resolve(result)
			});
	};


	//Generate random numbers, repeat while number is above halting probability
	while (sLoop.generator() > sLoop.probability) {
		promise = promise.then(action);
	}


	return promise.then(function(result) {

		result.historyEntry = {
			loop: sLoop.id,
			count: sLoop.counter,
			action: loopHistory.orphan()
		};

		return Promise.resolve(result);
	});
};

_SLoop.prototype.summaryThis = function(summary, entries) {
	summary.probability = this.probability;

	summary.action = {}
	this.playable.summarize(summary.action, entries, true)
}


//User interface
function StochasticLoop(playable, probability = .5, parameters = {}) {
	var id = idHandler(parameters.id, "stochasticLoop")

	if (isNaN(probability) || probability < 0 || probability > 1) throw new Error('Invalid probability');

	//Create backend sLoop object
	var _sLoop = new _SLoop(id, playable, probability, parameters);


	//Return this reference object to the user. Run the function to select a source
	var sLoop = Playable(_sLoop);
	return sLoop;
}



module.exports = { _SLoop, StochasticLoop };

},{"../helperFunctions":8,"../logger":27,"../state":51,"./loop":34,"./playable":35}],42:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Turn");

//External dependency
var { SynchronousPromise } = require("synchronous-promise");

//Helper functions
var { isObject, once } = require("../helperFunctions")("general");
var { chainerGenerator, outcomeTreeGetValue, outcomeTreeSetValue } = require("../helperFunctions")("playable");
var { recurse } = require("../helperFunctions")("turn");
var { idHandler } = require("../helperFunctions")("state");

//Game state controllers
var { registry } = require("../state");
var { gameHistory } = require("../history");
var { Information, PerfectInformation } = require("../information");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Turn
function _Turn(id, choices, parameters = {}) {
	_Playable.call(this, id);

	this.payoffsImplicit = {};
	this.payoffsExplicit = {};

	this.next = {};

	this.choices = choices.map(function(choice) {
		return registry.choices[choice.id()];
	});

	registry.turns[id] = this;

	var turn = this;

	this.choiceMap = this.choices.map(function(item) {
		return item.options;
	});

	recurse(turn.choiceMap, turn.payoffsImplicit, null, function() {
			return Array(turn.choiceMap.length).fill(0);
		})
		.then(function(result) {
			log("silly", "Added implicit payoffs map to turn.");
			return recurse(turn.choiceMap, turn.payoffsExplicit, {});
		})
		.then(function(result) {
			log("silly", "Added explicit payoffs map to turn.");
			return recurse(turn.choiceMap, turn.next, null, function() {
				return [];
			});
		})
		.then(function(result) {
			log("silly", "Added blank next map to turn.");
			return Promise.resolve(result);
		})
		.catch(function(reason) {
			log("error", reason);
		}); //TODO: error handling here
}
_Turn.prototype = Object.create(_Playable.prototype);
_Turn.prototype.constructor = _Turn;

_Turn.registryName = "turns";
_Turn.counterName = "turn";


_Turn.prototype.play = function({
	usePayoffs = true,
	history = gameHistory,
	information = PerfectInformation,
	releasePlayers = true
} = {}) {

	var turn = this;
	var choiceHistory = history.child();
	var choiceInformation = information.child();

	if (turn.compartmentalize) {
		choiceInformation = new Information(turn.compartmentalize.history || choiceHistory,
			turn.compartmentalize.population || information.population);
	}

	history.log.add({
		turn: turn.id,
		choices: turn.choices.map(function(choice) {
			return choice.id;
		})
	});

	var compileInformation = function(ri) {
		//If there's no turn entry, create one.
		if (!choiceInformation.additional[0].turn) {
			var turnInfo = {
				turn: {
					id: turn.id,
					choices: [],
					exclude(player) {
						return this.choices.filter(function(choice) {
							return choice.player == player;
						});
					}
				}
			};
			choiceInformation.additional.unshift(turnInfo);
		}
		choiceInformation.additional[0].turn.choices.push(
			choiceInformation.additional.pop()
		);

		information.additional.forEach( // TODO: what does this do???
			choiceInformation.addAdditional.bind(choiceInformation)
		);
	};

	return Promise.all(
			turn.choices.map(function(choice) {
				return choice.play({
					shortCircuit: true,
					history: choiceHistory,
					information: choiceInformation,
					_compileInformation: compileInformation,
					releasePlayers: false
				});
			})
		)
		.then(function(result) {
			//Re-format output from array of Choice results to single Turn result
			//And release players
			var resultPath = result.map(function(choice, index) {
				if (releasePlayers) turn.choices[index].releasePlayer();
				return choice.result;
			});

			//Pass along results and record history
			var resultObject = {
				result: resultPath,
				playable: turn,
				historyEntry: {
					turn: turn.id,
					results: choiceHistory.orphan(),
					payouts: {}
				}
			};

			return Promise.resolve(resultObject);
		})
		.then(function(result) {
			//Implement payoffs
			if (usePayoffs) {
				var implicitPayoffs = outcomeTreeGetValue(
					turn.payoffsImplicit,
					result.result
				);
				var explicitPayoffs = outcomeTreeGetValue(
					turn.payoffsExplicit,
					result.result
				);

				// For the log
				var payouts = {};

				implicitPayoffs.forEach(function(payoff, index) {
					// Do nothing if payoff is zero.
					if (payoff == 0) return;

					// fetch player and increment score
					var player = turn.choices[index].player;
					player.score += payoff;

					//And include it in the log entry
					payouts[player.id] = Number(payoff);
				});

				for (var player in explicitPayoffs) {
					registry.players[player].score += explicitPayoffs[player];

					//And include it in the log entry
					payouts[player] = Number(explicitPayoffs[player]);
				}

				//Log for the scores log
				var scoreEntry = {
					turn: turn.id,
					result: result.result,
					payouts: payouts
				};
				history.addScores(scoreEntry);


				// Log for the game history
				result.historyEntry.payouts = payouts;
			}

			return Promise.resolve(result); //TODO: add information mechanisms
		});
};

//Overwrite default history handler, because we don't want a second entry in the tree
_Turn.prototype.handleHistory = function({ history = gameHistory } = {},
	result
) {
	history.addNoLog(result.historyEntry);

	return Promise.resolve(result);
};

_Turn.prototype.findNext = function({ result } = {}) {
	return outcomeTreeGetValue(this.next, result.result);
};

_Turn.prototype.generateChainingFunctions = function() {
	var _turn = this;
	var turn = _turn.interface;

	//Create payoff setter/branch router functions.
	//recurse adds a wrapper around this function which supplies the path.
	recurse(_turn.choiceMap, turn, function(path, payoffs) {
		//If user supplied payoffs in array form, then translate to object based on which players are involved in the choices
		if (Array.isArray(payoffs)) {
			if (payoffs.length !== _turn.choices.length) {
				//If array isn't right length, then this is unintelligible.
				log(
					"error",
					"Payoff array does not match Turn dimensions, cannot assign payoffs."
				);
				return Promise.reject(new Error("Payoff array is not correct length"));
			}

			var originalPayoffs = payoffs.slice();
			payoffs = {};

			outcomeTreeSetValue(_turn.payoffsImplicit, path, originalPayoffs);
		} else if (isObject(payoffs)) {
			payoffs = JSON.parse(JSON.stringify(payoffs));
			outcomeTreeSetValue(_turn.payoffsExplicit, path, payoffs);
		}

		return SynchronousPromise.resolve({
			playable: turn,
			path: path
		});
	});
};

_Turn.prototype.setAllPayoffs = function(payoffArray) {
	var turn = this;

	//Recurse through the options in input, to come up with a path to every combination of options in the array of arrays.
	function recurse(input, numPlayers, payoffs, path = [], coordinates = []) {
		return SynchronousPromise.resolve(path).then(function(path) {
			//Since we slice the array each time, if there are no more entries left then we're done with this branch.
			if (input.length == 0) return SynchronousPromise.resolve(path);

			//Among all values from the array
			return SynchronousPromise.all(
				input[0].map(function(item, index) {
					var splitPath = path.slice(0).concat(item);
					var splitCoordinates = coordinates.slice(0).concat(index);
					var splitPayoffs = payoffs[index];

					//If we're at the last position in the array of options, then we have a complete path.
					if (input.length == 1) {
						/* you might need these later
					console.log("path ", splitPath);
					console.log("coordinates ", splitCoordinates)
					console.log("payoff ",splitPayoffs)
					*/

						splitPayoffs = JSON.parse(JSON.stringify(splitPayoffs));

						//Allow the first few array elements to be implicit payoffs. Check that they are actually there and are numbers
						var implicit = splitPayoffs.slice(0, numPlayers);
						if (
							implicit.length == numPlayers &&
							implicit.every(function(payoff) {
								return !isNaN(payoff);
							})
						) {
							outcomeTreeSetValue(turn.payoffsImplicit, splitPath, implicit);
						}

						//Any remaining should be assigned as explicit payoffs, if they're objects.
						splitPayoffs.slice(numPlayers).forEach(function(explicit) {
							if (isObject(explicit))
								outcomeTreeSetValue(turn.payoffsExplicit, splitPath, explicit);
						});
					}

					//If there are more items to iterate over, include them in the output then recurse.
					return recurse(
						input.slice(1),
						numPlayers,
						splitPayoffs,
						splitPath,
						splitCoordinates
					);
				})
			);
		});
	}

	return recurse(turn.choiceMap, turn.choices.length, payoffArray).catch(
		function(reason) {
			log("error", reason);
		}
	);
};

// Adding more complicated summary entry
_Turn.prototype.summaryThis = function(summary, entries, shortCircuit = false) {
	// Fetch summaries for each choice.
	summary.choices = [];
	this.choices.forEach(function(choice, index) {
		summary.choices[index] = choice.summarize(
			summary.choices[index],
			entries,
			true
		);
	});

	// Include payoffs
	summary.payoffs = JSON.parse(
		JSON.stringify({
			implicit: this.payoffsImplicit,
			explicit: this.payoffsExplicit
		})
	);

	return summary;
};

//
_Turn.prototype.summaryNext = function(summary, entries) {
	var turn = this;

	// Create map
	summary.next = {};
	var count = 0;
	recurse(this.choiceMap, summary.next, null, function(path) {
		return outcomeTreeGetValue(turn.next, path).map(function(playable) {
			++count;
			return playable.summarize();
		});
	});

	// If there is no next, delete the key.
	if (count == 0) delete summary.next;
};

function Turn(choices, parameters = {}) {
	var id = idHandler(parameters.id, "turn");

	//Create backend choice object
	var _turn = new _Turn(id, choices, parameters);

	//Return this reference object to the user. Run the function to select a source
	var turn = Playable(_turn);

	_turn.generateChainingFunctions();

	//Function to set all payoffs at once
	turn.setAllPayoffs = function(payoffs) {
		//TODO: Include error handling if array given isn't expected dimensions.
		_turn.setAllPayoffs(payoffs);
	};

	//Way for user to interact with payoffs
	turn.payoffs = function() {
		return JSON.parse(
			JSON.stringify({
				implicit: _turn.payoffsImplicit,
				explicit: _turn.payoffsExplicit
			})
		);
	};

	// Returns the payoffs in nested array form, to make cloning easier, ie. t2.setAllPayoffs(t1.payoffsMatrix())
	turn.payoffsMatrix = function() {

		// recursion to construct payoff matrix
		var mapper = function(obj, path = []) {
			//If it's an array, then we've reached the payoffs
			if (Array.isArray(obj)) {
				var payoff = obj.slice(0)
				// Add explicit payoffs too
				var explicit = outcomeTreeGetValue(_turn.payoffsExplicit, path);

				// Only add an entry if the explicit payoffs object is not empty
				return Object.keys(explicit).length > 0 ? payoff.concat([outcomeTreeGetValue(_turn.payoffsExplicit,
					path)]) : payoff
			}

			// Otherwise, dig in deeper
			else return Object.keys(obj).map(function(key) { return mapper(obj[key], path.slice(0).concat([key])) })
		}
		return mapper(_turn.payoffsImplicit)
	}

	return turn;
}

module.exports = { _Turn, Turn };

},{"../helperFunctions":8,"../history":25,"../information":26,"../logger":27,"../state":51,"./playable":35,"synchronous-promise":72}],43:[function(require,module,exports){
"use strict";

var log = require('./logger');

//Game state controllers
var { registry } = require('./state');

//Helper functions
var { idHandler } = require('./helperFunctions')("state");
var { chainerGenerator } = require('./helperFunctions')("playable");

var { UserHistory } = require('./history');

// Plugins
var PluginManager = require("./plugin-manager")

//Backend for Player
function _Player(id, { name = "", assign = null } = {}) {
	log('silly', 'Creating interal player object.');

	this.id = id
	this.score = 0
	this.name = name;

	this.history = [];

	if (assign) this.assign(assign);

	this.alive = true;
	this.available = true;

	registry.players[id] = this;
}


//Make a copy of the player, in order to take a snapshot. ////TODO try this again sometime.
/*
_Player.prototype.clone = function(){
	//Make new copy. Don't keep more than one.
	delete this.copy

	var clone = new _Player(this.id);

	//Loop through properties and assign them.
	for (var key in this){
		clone[key] = this[key];
	}
	//Do not add to registry. This will keep duplicates out of population.

	//Do add reference so we can find it again.
	this.copy = clone;

	return clone;
};
*/


//Assign strategy to player
_Player.prototype.assign = function(strategy, ...args) {

	//TODO: verify strategy type
	if (registry.strategies[strategy]) {
		this.strategy = new registry.strategies[strategy](...args);
		this.strategy._id = strategy
		this.strategy._args = args
	} else throw new Error("Strategy '" + strategy + "' is not defined");
};


//Call strategy to make a choice
_Player.prototype.choose = function(options, information = {}) { //TODO: check that there's a strategy assigned before trying to play
	var player = this;
	if (player.strategy) {
		let result = player.strategy.choose(options, information)
		if (result) return Promise.resolve(result.toString());
		// If no response, give warning
		else log("warning", "No response from player " + player.id + ". Using default option.")
	}
	// If no strategy, give warning
	else
		log("warning", "No strategy assigned to player " + player.id + ". Using default option.");
	return Promise.resolve(null);
};


//Takes a JSON.parse(JSON.stringify()) copy of _player. Returns a cleaned up version
_Player.prototype.infoClean = function(infoObject) {
	delete infoObject.interface;
	infoObject.strategy = infoObject.strategy ? infoObject.strategy._id : null;

	return infoObject;
};


//Kill player. TODO: add player to some sort of "dead" list to avoid being picked to do things.
_Player.prototype.kill = function() {
	this.alive = false;
};



//Class that is the reference for the user to hold onto
function player() {}


//Frontend for Player
function Player(parameters = {}) {
	var id = idHandler(parameters.id, "player");

	//Create backend player object
	var _player = new _Player(id, parameters);


	//Return this reference object to the user
	var playerInterface = new player(); //Probably add functionality here

	//Tag-back. Store the front-end object in the back-end object, for retrieval
	_player.interface = playerInterface;

	playerInterface.alive = function() {
		return registry.players[id].alive;
	}

	playerInterface.assign = function(strategy, ...args) {
		registry.players[id].assign(strategy, ...args);
	};

	playerInterface.available = function() {
		return registry.players[id].available
	};

	playerInterface.busy = function() {
		registry.players[id].available = false;
	};

	playerInterface.history = function() {
		return new UserHistory(registry.players[id].history);
	};

	playerInterface.id = function() { return id; };

	playerInterface.kill = function() {
		registry.players[id].kill();
	}

	playerInterface.release = function() {
		registry.players[id].available = true;
	};

	playerInterface.resetScore = function() {
		registry.players[id].score = 0;
	}

	playerInterface.score = function() {
		return registry.players[id].score;
	};

	playerInterface.strategy = function() {
		return registry.players[id].strategy._id;
	};

	// PLUGIN: run after player creation
	PluginManager.run("player-create", _player)

	return playerInterface
}




module.exports = { _Player, Player };

},{"./helperFunctions":8,"./history":25,"./logger":27,"./plugin-manager":45,"./state":51}],44:[function(require,module,exports){
/**
 *
 * @type {{}}
 */

function AsyncCtx(callback) {
	this.callback = callback;
	this.sync = true;
}

AsyncCtx.prototype.async = function() {
	this.sync = false;
	return this.callback;
};

/**
 * This is an API meant to be used only from synchronous
 * callbacks into an asynchronous like hook.
 *
 * it represent continuity from the "sync()" or "waterfall()"
 * plugin management
 */
AsyncCtx.prototype.stop = function() {
	var callback = this.async();
	callback(true);
};

module.exports = AsyncCtx;
},{}],45:[function(require,module,exports){
// Stolen liberally and brazenly from "polite-plugin-manager".
"use strict";

const pluginDirectoryPath = "../../plugins/"
// Hack to compile Glob files for browserify. DonÂ´t call this function!
function $_DONOTCALL() {
	require('../../plugins/balance-sheet-complex.js');require('../../plugins/balance-sheet.js')
}

/**
 * Polite Plugin Manager
 * register and run hooks granting extendability
 *
 */


// Global Dependencies
var fs = require('fs'),
	path = require('path'),
	extend = require('extend'),
	async = require('async'),

	// Local Modules
	AsyncCtx = require('./async-ctx'),
	WaterfallCtx = require('./waterfall-ctx'),
	PluginNameError = require('./plugin-name-error'),
	PluginCallbackError = require('./plugin-callback-error');


// ------------------------------------------------------------------------------------ //
// ---[[   C O N S T R U C T O R   A N D   L I F E C Y C L E   U T I L I T I E S   ]]-- //
// ------------------------------------------------------------------------------------ //

var PluginManager = {},
	packages = [],
	packageNames = [],
	hooks = {},
	skipProps = ['module', 'name', 'priority', 'active', 'init', 'require', 'stop', 'public', 'settings'];



PluginManager.reset = function() {
	packages = [];
	packageNames = [];
	hooks = {};
	return this;
};

/**
 * Apply package sorting,
 * register packages into hooks,
 * run packages init() method
 */
PluginManager.start = function(callback) {

	var self = this,
		inits = [];

	// sort by priorities
	packages.sort(function(a, b) {
		return a.priority > b.priority;
	});

	// register init & hooks
	// hooks are all functions who are not special properties
	// identified by "skipProps" list
	packages.forEach(function(pkg) {
		if (pkg.init) {
			inits.push(pkg.init);
		}
		for (var prop in pkg) {
			if (skipProps.indexOf(prop) === -1 && typeof pkg[prop] == 'function') {
				PluginManager.registerHook(prop, pkg[prop]);
			}
		}
	});

	// run all package.init() method in series!
	if (inits.length) {
		async.eachSeries(inits, function(fn, done) {

			var context = new AsyncCtx(done),
				result = fn.apply(context);

			// sync false stop initialization cycle!
			if (context.sync) {
				if (result === false) {
					callback.call(self);
				} else {
					done(result);
				}
			}

		}, callback.bind(this));
	} else {
		callback.call(self);
	}

	return this;
};




// --------------------------------- //
// ---[[   H O O K S   A P I   ]]--- //
// --------------------------------- //

PluginManager.registerHook = function(hookName, hookFn, hookPriority = 100) {
	hookFn.priority = hookPriority;

	if (!hooks[hookName]) {
		hooks[hookName] = [];
	}

	hooks[hookName].push(hookFn);
	return this;
};


PluginManager.isEmpty = function(hookName) {
	if (hooks[hookName] && hooks[hookName].length) {
		return false;
	} else {
		return true;
	}
};



/**
 * Run registered hook callbacks in series
 * (it supports asynchronous callbacks)
 */
PluginManager.run = function(hookName, ...args) {

	// Use the runWithCallback but with blank callback.
	PluginManager.runWithCallback(hookName, ...args, function() {})
};

// Same as above, but use last argument as callback
PluginManager.runWithCallback = function(hookName, ...args) {

	// collect hookName property
	if (!hookName) throw new PluginNameError('missing plugin name!');

	// obtain async callback
	if (!args.length || typeof args[args.length - 1] !== 'function') {
		throw new PluginCallbackError('[' + hookName + '] missing callback for async plugin!');
	} else {
		var callback = args.pop();
	}


	// check for some callbacks existance
	// [???] may give out an exception when no callbacks were found!
	if (!hooks[hookName] || !hooks[hookName].length) {
		callback(false);
		return false;
	}

	// Sort hooks by priority
	hooks[hookName].sort(function(a, b) {
		return a.priority > b.priority
	})

	// run async queque
	// NOTE: a step function should stop the queque by done(true)
	async.eachSeries(hooks[hookName], function(fn, done) {
		var context = new AsyncCtx(done),
			result = fn.apply(context, args);

		if (context.sync) {
			if (result === false) {
				callback();
			} else {
				done(result);
			}
		}
	}, callback);

	return true;
}

/**
 * Run registered hook callbacks in parallel
 * (it supports asynchronous callbacks)
 * @param hookName
 */

PluginManager.parallel = function() {

	var hookName = '',
		callback = null,
		args = Array.prototype.slice.call(arguments);

	// collect hookName property
	if (!args.length) {
		throw new PluginNameError('missing plugin name!');
	} else {
		hookName = args.shift();
	}

	// obtain async callback
	if (!args.length || typeof args[args.length - 1] !== 'function') {
		throw new PluginCallbackError('[' + hookName + '] missing callback for async plugin!');
	} else {
		callback = args[args.length - 1];
	}

	// check for some callbacks existance
	// [???] may give out an exception when no callbacks were found!
	if (!hooks[hookName] || !hooks[hookName].length) {
		callback(false);
		return false;
	}

	// run async in parallel
	// NOTE: a step function should stop the queque by done(true)
	async.each(hooks[hookName], function(fn, done) {
		var context = new AsyncCtx(done),
			result = fn.apply(context, args);

		// handle sync callbacks
		if (context.sync) {
			done(result);
		}
	}, callback);

	return true;
};


/**
 * WATERFALL
 * Run a hook as a normal function in a fully syncronous mode
 * Each hookFn should return a value who's forward as first argument for the next one
 * last hookFn return value is the final output
 */
PluginManager.waterfall = function(hookName) {

	if (!hookName) {
		throw new PluginNameError('missing plugin name!');
	}

	var args = Array.prototype.slice.call(arguments);
	args.shift();

	if (hooks[hookName]) {
		// use known exception to exit forEach cycle implementing a stoppable watefall
		// (http://stackoverflow.com/questions/2641347/how-to-short-circuit-array-foreach-like-calling-break?answertab=votes#tab-top)
		var WaterfallBreakException = {};
		try {
			hooks[hookName].forEach(function(fn) {
				var context = new WaterfallCtx(),
					result = fn.apply(context, args);

				if (args.length) {
					args[0] = result;
				}

				if (context.stopped) {
					throw WaterfallBreakException;
				}

			});
		} catch (e) {
			if (e !== WaterfallBreakException) throw e;
		}
	}

	if (args.length) {
		return args[0];
	} else {
		return;
	}
};




// --------------------------------------- //
// ---[[   P A C K A G E S   A P I   ]]--- //
// --------------------------------------- //

function getPackageByName(name) {
	var list = packages.filter(function(pkg) { return (pkg.name === name) })
	if (list.length == 1) return list[0]
	else return list;
}

// Package class
function Package(module, name = null, context = null) {
	// Basic assignment and default values
	Object.assign(this, {
		module,
		name,
		priority: 100,
		active: false,
		init: function() {},
		require: function() {},
		stop: function() {},
		settings: function() {},
		public: {}
	})
	// Package-defined values and hooks
	Object.assign(this, module(context || {}))

	// add to registry
	// Check to see if it's the same module being loaded twice, or different modules with the same name
	if (packageNames.includes(this.name)) {
		if (this.module === getPackageByName(this.name).module) {
			// Same module. Do nothing
		} else {
			// Different modules with same name, handle name conflict.
			//TODO: figure out how to handle name conflict.
		}
	}
	// No name conflict, add to registry
	else {
		packages.push(this);
		packageNames.push(this.name)
	}
}

Package.prototype.registerHooks = function() {
	var pkg = this;
	for (var prop in pkg) {
		if (skipProps.indexOf(prop) === -1 && typeof pkg[prop] == 'function') {
			PluginManager.registerHook(prop, pkg[prop]);
		}
	}
}

// Create interface for user to interact with package.
function PackageInterface(pkg) {

	// Merge any public items specified by the package with this interface format
	return Object.assign({}, pkg.public, {
		name: function() { return pkg.name },
		priority: function() { return pkg.priority },
		active: function() { return pkg.active },

		init: function(...args) {
			pkg.init(...args);
			pkg.registerHooks();
			pkg.active = true;
			return Object.assign(this, pkg.publicIfActive);
		},
		require: function(...args) {
			if (pkg.active) pkg.require(...args);
			else {
				pkg.init(...args);
				pkg.registerHooks();
				Object.assign(this, pkg.publicIfActive);
			}
			pkg.active = true;

			return this;
		},
		stop: function(...args) {
			if (pkg.active) pkg.stop(...args);
			pkg.active = false;
		},
		settings: function(...args) {
			return pkg.settings(...args);
		}

	}, pkg.active ? pkg.publicIfActive : null);
}




/**
 * Load a plugin package by folder path
 * @param sourceFolder
 */
PluginManager.package = function(source, context) {
	if (packageNames.includes(source)) {
		// Already loaded module, just return it
		return PackageInterface(getPackageByName(source))
	} else {
		var name = path.basename(source),
			module = require(pluginDirectoryPath + source + '.js')

		// obtain package informations and apply some default values
		var pkg = new Package(module, name, context)
		return PackageInterface(pkg)
	}
}

/*
			load: function(callback = function() {}, ...initArgs) {
				var self = pm,
					inits = [],


					// register init & hooks
					// hooks are all functions who are not special properties
					// identified by "skipProps" list

					if (pkg.init) {
						inits.push(pkg.init);
					}


				// run all package.init() method in series! //EDIT: will only be the one
				if (inits.length) {
					async.eachSeries(inits, function(fn, done) {

						var context = new AsyncCtx(done),
							result = fn.apply(context, initArgs);

						// sync false stop initialization cycle!
						if (context.sync) {
							if (result === false) {
								callback.call(self);
							} else {
								done(result);
							}
						}

					}, callback.bind(self));
				} else {
					callback.call(self);
				}

				return self;
			}

		};
	};
*/

/** TODO: this doesn't work right now
 * Load all packages from a given folder path
 * (syncronous)
 */
PluginManager.registerMany = function(sourceFolder, context) {
	var self = this;

	if (fs.existsSync(sourceFolder)) {
		fs.readdirSync(sourceFolder).forEach(function(item) {
			var itemPath = sourceFolder + '/' + item,
				itemStat = fs.lstatSync(itemPath);

			if (itemStat.isDirectory()) {
				self.loadPackage(itemPath, context);
			}
		});
	}

	return this;
};

module.exports = PluginManager

},{"../../plugins/balance-sheet-complex.js":73,"../../plugins/balance-sheet.js":74,"./async-ctx":44,"./plugin-callback-error":46,"./plugin-name-error":47,"./waterfall-ctx":48,"async":56,"extend":63,"fs":1,"path":2}],46:[function(require,module,exports){

function PluginCallbackError(message) {
	this.name = "PluginCallbackError";
	this.message = (message || "");
}


PluginCallbackError.prototype = new Error();
PluginCallbackError.prototype.constructor = PluginCallbackError;

module.exports = PluginCallbackError;
},{}],47:[function(require,module,exports){

function PluginNameError(message) {
	this.name = "PluginNameError";
	this.message = (message || "");
}


PluginNameError.prototype = new Error();
PluginNameError.prototype.constructor = PluginNameError;

module.exports = PluginNameError;
},{}],48:[function(require,module,exports){
/**
 *
 * @type {{}}
 */

function WaterfallCtx() {
	this.stopped = false;
}

WaterfallCtx.prototype.stop = function() {
	this.stopped = true;
};

module.exports = WaterfallCtx;
},{}],49:[function(require,module,exports){
"use strict";

var log = require("./logger");

//Helper functions
var { isFunction, isObject } = require("./helperFunctions")("general");

//Game state controllers
var { registry } = require("./state");

var { _Player } = require("./player");

//Class PlayerList is a list of players which includes some extra functionality. UserPlayerList takes a playerList and
//sanitizes it for the user (ie returns .interface for each player).

function PlayerList(...args) {
	if (Array.isArray(args[0])) args = args[0].slice(0);
	if (args == "all") return gamePopulation();

	// We'll need to retain the original arguments in order to create the generator
	var originalArgs = []

	// Loop over the arguments, save the originals, parse them to _players
	for (var i = 0, len = args.length; i < len; i++) {
		originalArgs.push(args[i]);
		if (isFunction(args[i].id)) args[i] = registry.players[args[i].id()];
		else if (typeof args[i] === 'string') args[i] = registry.players[args[i]]
	}

	Object.setPrototypeOf(args, PlayerList.prototype);

	// returns the same playerlist, but updated, using the original args.
	args.generator = function() {
		return new PlayerList(originalArgs);
	};

	return args;
}

PlayerList.prototype = Object.create(Array.prototype);
PlayerList.prototype.constructor = PlayerList;


// Assign a strategy en masse
PlayerList.prototype.assign = function(strategyName) {
	this.forEach(function(player) {
		player.assign(strategyName)
	})
	return this;
}


//Return a PlayerList minus the specified players.
//Argument can be _player, interface, or a player's id.
PlayerList.prototype.exclude = function(playerArg) {
	if (Array.isArray(playerArg))
		return playerArg.reduce(function(running, item) {
			return running.exclude(item);
		}, this);

	return new PlayerList(
		this.filter(function(player) {
			if (
				playerArg === player ||
				playerArg == player.interface ||
				playerArg == player.id ||
				(isObject(playerArg) && playerArg.id == player.id)
			)
				return false;
			else return true;
		})
	);
};


// Placeholder for generator method.
PlayerList.prototype.generator = function() {
	// This will get shadowed when the constructor is called, but it needs to be here so that the
	// UserPlayerList and InfoPlayerList constructors can see it.
}


//Create an InfoPlayerList out of this PlayerList. Useful for getting summary view.
PlayerList.prototype.info = function() {
	return new InfoPlayerList(this);
};


//Return array of ids of each player in the list
PlayerList.prototype.ids = function() {
	return this.map(function(player) {
		return player.id;
	});
};


//Kill all players in the playerList
PlayerList.prototype.kill = function() {
	this.forEach(function(player) {
		player.kill();
	});
	return this;
};


//Returns the single player with the highest score
PlayerList.prototype.leader = function() {
	var players = this.slice();

	players.sort(function(a, b) {
		return b.score - a.score;
	});

	players = players.filter(function(player) {
		return player.score == players[0].score
	})


	return players.length > 1 ? new PlayerList(players) : players[0];
};


PlayerList.prototype.release = function() {
	this.forEach(function(player) {
		player.available = true;
	});
	return this;
};



//Return a playerList with only the players who are available
PlayerList.prototype.onlyAlive = function() {
	return new PlayerList(
		this.filter(function(player) {
			return player.alive;
		})
	);
};


//Return a playerList with only the players who are available
PlayerList.prototype.onlyAvailable = function() {
	return new PlayerList(
		this.filter(function(player) {
			return player.available;
		})
	);
};


//Returns an array of scores of each player in the list
PlayerList.prototype.scores = function() {
	var scores = [];

	this.forEach(function(player) {
		scores.push(player.score); //Use the interface function to avoid users re-assigning the reference
	});
	return scores;
};


// Returns an object where each key is a strategy and each value is an array of the scores of players with that strategy.
// TODO: finish .total() method, which will sum the arrays (duplicating .scoresByStrategyTotals)
PlayerList.prototype.scoresByStrategy = function() {
	var scores = {};
	var list = this;

	list.strategies().map(function(strategy) {
		scores[strategy] = list.usingStrategy(strategy).scores();
	});

	scores.total = function() {
		var score = {};
		var scores = this;
		Object.keys(scores).forEach(function(strategy) {
			if (Array.isArray(scores[strategy])) score[strategy] = scores[strategy].reduce(function(a, b) {
				return a + b;
			}, 0);
		});
		return score;
	};

	return scores;
};

// Returns an object where each key is a strategy and each value is the sum of scores of all players with that value
PlayerList.prototype.scoresByStrategyTotals = function() {
	var scores = {};
	var list = this;

	list.strategies().map(function(strategy) {
		scores[strategy] = list
			.usingStrategy(strategy)
			.scores()
			.reduce(function(a, b) {
				return a + b;
			}, 0);
	});

	return scores;
};

//Returns an object where the keys are the player ids and the values
//are the players' score
PlayerList.prototype.scoresObject = function() {
	var scores = {};

	this.forEach(function(player) {
		scores[player.id] = player.score;
	});

	return scores;
};

//Mean of the scores
PlayerList.prototype.scoresMean = function() {
	var scores = this.scores();

	var mean =
		scores.reduce(function(sum, value) {
			return sum + value;
		}, 0) / scores.length;

	return mean;
};

//Array with 2 entries, the lowest and highest score
PlayerList.prototype.scoresRange = function() {
	var scores = this.scores();

	scores.sort(function(a, b) {
		return a - b;
	});

	return [scores[0], scores[scores.length - 1]];
};

//The standard deviation of the scores
PlayerList.prototype.scoresStd = function() {
	var scores = this.scores();
	var mean = this.scoresMean();

	var variance =
		scores.reduce(function(sum, value) {
			return sum + Math.pow(value - mean, 2);
		}, 0) / scores.length;

	var std = Math.sqrt(variance);

	return std;
};


//Return an array of the strategy of each player in the list
PlayerList.prototype.strategies = function() {
	return this.map(function(player) {
		return player.strategy ? player.strategy._id : "";
	});
};

//Return a PlayerList with only players using a given strategy
PlayerList.prototype.usingStrategy = function(strategy) {
	return new PlayerList(
		this.filter(function(player) {
			if (
				player.strategy == strategy ||
				player.strategy._id == strategy ||
				(isFunction(strategy) && player.strategy instanceof strategy)
			)
				return true;
			else return false;
		})
	);
};

/*

TODO figure out how to make this work

//Returns an object where the keys are strategy names and the values are arrays of players.
//This needs to be overridden on the UserPlayerList prototype, because the normal wrapper logic
//for UserPlayerList cannot sanitize this.
PlayerList.prototype.byStrategy = function(){
	var list = this;
	var data = {};

	Object.keys(registry.strategies).forEach(function(strategy){
		data[strategy] = list.usingStrategy(strategy);
	});

	return data;
};
*/

//Returns an object where the keys are each strategy and the values
//are the number of players in the list who are using it.
PlayerList.prototype.strategyDistribution = function() {
	var counts = {};

	this.forEach(function(player) {
		var s = player.strategy._id;
		counts[s] = (counts[s] || 0) + 1;
	});

	return counts;
};



PlayerList.prototype.resetScores = function() {
	this.forEach(function(player) {
		player.score = 0;
	});
	return this;
};

//Accept a PlayerList and return one suitable for the user, or create a playerlist and return one suitable for the user
function UserPlayerList(...playerList) {
	if (Array.isArray(playerList[0])) playerList = playerList[0];

	// If we've got a playerList, return the interface of each player
	if (playerList instanceof PlayerList) {
		var userPlayerList = playerList.map(function(player) {
			return player.interface;
		});
	}
	// If not, first create a playerList, then call this function again to wrap it.
	else return new UserPlayerList(new PlayerList(playerList));

	Object.setPrototypeOf(userPlayerList, UserPlayerList.prototype);

	//Attach methods from PlayerList, wrapped in a function. If those methods return a playerList,
	//then the function will convert that to a UserPlayerList.
	for (var method in PlayerList.prototype) {
		if (isFunction(playerList[method])) {
			if (method != "constructor")
				userPlayerList[method] = (function(method) {
					return function() {
						var result = playerList[method].apply(playerList, arguments);
						if (result instanceof PlayerList) return new UserPlayerList(result);
						else if (result instanceof _Player) return result.interface;
						else return result;
					};
				})(method);
		}
	}

	return userPlayerList;
}

UserPlayerList.prototype = Object.create(PlayerList.prototype);
UserPlayerList.prototype.constructor = UserPlayerList;

//Accept a PlayerList and return one suitable for a strategy information set.
function InfoPlayerList(playerList) {
	var infoPlayerList = playerList.map(function(player) {
		return player.infoClean(JSON.parse(JSON.stringify(player)));
	});

	Object.setPrototypeOf(infoPlayerList, InfoPlayerList.prototype);

	//Attach selected methods from PlayerList, wrapped in a function. If those methods return a playerList,
	//then the function will convert that to an InfoPlayerList.
	var methodsToInclude = [
		"onlyAlive",
		"onlyAvailable",
		"ids",
		"exclude",
		"generator",
		"strategies",
		"usingStrategy",
		"strategyDistribution",
		"scores",
		"scoresObject",
		"scoresMean",
		"scoresRange",
		"scoresStd",
		"leader"
	];

	for (var method in PlayerList.prototype) {
		if (isFunction(playerList[method])) {
			if (methodsToInclude.indexOf(method) > -1)
				infoPlayerList[method] = (function(method) {
					return function() {
						var result = playerList[method].apply(playerList, arguments);
						if (result instanceof PlayerList) return new InfoPlayerList(result);
						else if (result instanceof _Player)
							return result.infoClean(JSON.parse(JSON.stringify(result)));
						else return result;
					};
				})(method);
		}
	}

	return infoPlayerList;
}

InfoPlayerList.prototype = Object.create(Array.prototype);
InfoPlayerList.prototype.constructor = InfoPlayerList;

//Extra method to return a single player from an infoPlayerList
InfoPlayerList.prototype.get = function(playerID) {
	return this.find(function(player) {
		return player.id == playerID;
	});
};

//Generates a PlayerList containing all players.
var gamePopulation = function() {
	var population = [];

	for (var player in registry.players) {
		population.push(registry.players[player]);
	}

	return new PlayerList(population);
};

//Does the same, but a UserPlayerList
var Population = function() {
	return new UserPlayerList(gamePopulation());
};

//Does the same, but an InfoPlayerList
var InfoPopulation = function() {
	return new InfoPlayerList(gamePopulation());
};

//A short-hand to return total population size without creating a PlayerList
Population.size = function() {
	return Object.keys(registry.players).length;
};

module.exports = {
	PlayerList,
	UserPlayerList,
	InfoPlayerList,
	gamePopulation,
	Population,
	InfoPopulation
};

},{"./helperFunctions":8,"./logger":27,"./player":43,"./state":51}],50:[function(require,module,exports){
"use strict";

// External dependency
var jsonata = require("jsonata");

// Game state
var { registry, idCounters } = require("./state")
registry._addType_("queries")
idCounters._addType_("query")

// The code which evaluates all queries, no matter where they come from.
function evaluateQuery(queryString, target, ...args) {
	// Check for pre-programmed query, designated by '@'
	if (queryString[0] == "@" && registry.queries[queryString]) queryString = registry.queries[queryString].query
	else if (queryString[0] == "@") queryString = queryString.slice(1)

	return new QueryResult(queryString, jsonata(queryString).evaluate(target, ...args)).pack();
}



function Query(shortcut, query, description, format = "shortcut") {

	// Only include requested properties, to avoid visual clutter
	if (format == "code" || format == "all") this.query = query;
	if (format == "shortcut" || format == "all") {
		this.shortcut = shortcut

		if (format !== "all") {
			// Normally we'd use the prototype method to save memory, but in this case it won't work, so attach another
			this.evaluate = function(target, ...args) {
				return evaluateQuery(query, target, ...args);
			}
		}

	}
	this.description = description
}

Query.prototype.evaluate = function(target, ...args) {
	return evaluateQuery(this.query, target, ...args)
};



// A class to share results with. A simple QueryResult has a `result` and
// a `queryString` property, and a `.pack` method. Calling `.pack` will
// create a new object whose value is the `result` property, but whose
//prototype is the original object. This gives a clean result, that still
// has a `.queryString` property, to view the string that generated it.
function QueryResult(query, result) {
	// Can't add properties to undefined, to change to a string
	if (result == undefined) result = null

	this.query = query
	this.result = result
}
QueryResult.prototype = Object.create(Array.prototype)
QueryResult.prototype.constructor = QueryResult;

// Returns an object that is the results of the query, but whose
// prototype contains .query (unless the result was just a string)
QueryResult.prototype.pack = function() {
	// If result is string,
	if (typeof this.result === "string") {
		var packed = new String(this.result)
		packed.query = this.query
		return packed;
	}
	// If it's array
	else if (Array.isArray(this.result)) {
		var packed = Object.create(this)
		packed.push(...this.result)
		return packed
	}
	//Normal object
	else return Object.assign(Object.create(this), this.result)
}


// User object for dealing with these things.
function Queries(queryString, target, ...args) {
	// If no query string, display all available shortcuts
	if (!queryString) {
		return Object.keys(registry.queries).map(function(query) {
			var q = registry.queries[query]
			return new Query(query, q.query, q.description, "shortcut")
		})
	}
	// If query string, either run query or return query
	else {
		// If no target, return query
		if (!target) {
			var q = registry.queries[queryString]
			if (q) return new Query(queryString, q.query, q.description, "code")
		}
		// If yes target, run query on target and return result
		else {
			return evaluateQuery(queryString, target, ...args)
		}
	}
}


module.exports = { Queries, Query, QueryResult, evaluateQuery }

},{"./state":51,"jsonata":65}],51:[function(require,module,exports){
"use strict";

var log = require('./logger');

log("debug", "state: Creating game state variables.")


var registry = {}
registry._addType_ = function(type){	
	registry[type] = {};
	log("silly", "state: adding registry entry: ", type)
};


var idCounters = {}
idCounters._addType_ = function(type){
	idCounters[type] = 0
	log("silly", "state: adding counter entry: ", type)
};





module.exports = {registry, idCounters};
},{"./logger":27}],52:[function(require,module,exports){
"use strict";

const nashName = "./core"; //Change this when published, probably to 'nash-js'

var fs = require("fs");

var { registerStrategy, registerStrategyObject } = require('./strategy');

//Check to see if parsed expression is call to require or eval
function isBannedCall(node) {
	return (node.type === 'CallExpression') &&
		(node.callee.type === 'MemberExpression') &&
		(node.callee.object.type === 'Identifier') &&
		((node.callee.object.name === 'require') || (node.callee.object.name === 'eval'));
}


function removeCalls(source) {
	const entries = [];
	esprima.parseScript(source, {}, function(node, meta) {
		if (isBannedCall(node)) {
			entries.push({
				start: meta.start.offset,
				end: meta.end.offset
			});
		}
	});
	entries.sort((a, b) => { return b.end - a.end }).forEach(n => {
		source = source.slice(0, n.start) + " null; " + source.slice(n.end);
	});
	return source;
}



var loadStrategy = function(filepath, trusted = false) {
	var compiler = require('expression-sandbox');

	var source = fs.readFileSync(filepath);

	if (!trusted) {
		var originalSource = source;
		var parsedSource = removeCalls(source);

		if (originalSource != parsedSource) throw new Error("Strategy " + filepath + " uses require or eval.");
	}

	source = "\"use strict\"; \n " + source;
	compiler(source)({ registerStrategy, registerStrategyObject });

}; //TODO: change this so that strategies can't require any modules.



function loadStrategyFolder(path, trusted = false) {
	var files = fs.readdirSync(path);
	files.forEach(function(file) {
		var filePath = path + '/' + file;
		loadStrategy(filepath);
	});
};


module.exports = { loadStrategy, loadStrategyFolder };

},{"./strategy":53,"expression-sandbox":61,"fs":1}],53:[function(require,module,exports){
"use strict";

var log = require('./logger');

//Javascript code parser
var esprima = require('esprima');

//Game state controllers
var { registry } = require('./state');

//Helper functions
var { idHandler } = require('./helperFunctions')("state");



//User interface to declare strategy type.
function registerStrategy(strategy, name, description = "No description given.", playerName = "") {
	var id = idHandler(name, "strategy");

	if (id !== name) {
		//There was already a strategy registered with this name.
		//Check to see if it's the same strategy or not.
		if (!registry.strategies[id] === strategy) {
			//They're different, so we have a name conflict.
			throw new Error("Strategy name conflict with " + name);

		} else {
			// They're the same, do nothing.
			return true;
		}
	}

	// No name conflict and strategy not loaded yet. Add to registry.
	log("debug", "Loading strategy '" + id + "'")
	strategy.playerName = playerName;
	strategy.description = description;
	registry.strategies[id] = strategy;
	return name;
}

function registerStrategyObject(strategyObject) {
	// If multiple strategies, split into individuals
	if (Array.isArray(strategyObject)) return strategyObject.map(registerStrategyObject)

	return registerStrategy(strategyObject.strategy, strategyObject.name, strategyObject.description,
		strategyObject.playerName)
}

//Strip out requires and such
function sanitizeStrategy(strategy) {
	// console.log(x) or console['error'](y)
	function isRequireCall(node) {
		return (node.type === 'CallExpression') &&
			(node.callee.type === 'MemberExpression') &&
			(node.callee.object.type === 'Identifier') &&
			(node.callee.object.name === 'require');
	}

	function removeCalls(source) {
		const entries = [];
		esprima.parseScript(source, {}, function(node, meta) {
			if (isRequireCall(node)) {
				entries.push({
					start: meta.start.offset,
					end: meta.end.offset
				});
			}
		});
		entries.sort((a, b) => { return b.end - a.end }).forEach(n => {
			source = source.slice(0, n.start) + source.slice(n.end);
		});
		return source;
	}

	removeCalls(strategy.toString());

}

//Returns to the user an array of all registered strategies. TODO: have this mirror PlayerList, to provide functionality like onlyAlive and scoresObject.
function Strategies() {
	var strategies = [];
	for (var strategy in registry.strategies) strategies.push(strategy);
	return strategies;
};

// Fetch the descriptions of the strategies.
Strategies.descriptions = function() {
	var strategies = {};
	for (var strategy in registry.strategies) strategies[strategy] = registry.strategies[strategy].description;
	return strategies;
}


// A built-in debugging strategy. Calling this function loads the strategy.
// The strategy just calles 'debugger' when asked to choose.
Strategies.debugger = function() {
	registerStrategy(function() {
		this.choose = function(options, information) {
			debugger;
		}
	}, "debugger")
	return "debugger"
}

Strategies.logger = function() {
	registerStrategy(function() {
		this.choose = function(options, information) {
			console.log("Options: ", options);
			console.log("Information: ", information)
		}
	}, "logger")
	return "logger"
}

module.exports = { registerStrategy, registerStrategyObject, Strategies };

},{"./helperFunctions":8,"./logger":27,"./state":51,"esprima":60}],54:[function(require,module,exports){
'use strict';
module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};

},{}],55:[function(require,module,exports){
'use strict';

function assembleStyles () {
	var styles = {
		modifiers: {
			reset: [0, 0],
			bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		colors: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39]
		},
		bgColors: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49]
		}
	};

	// fix humans
	styles.colors.grey = styles.colors.gray;

	Object.keys(styles).forEach(function (groupName) {
		var group = styles[groupName];

		Object.keys(group).forEach(function (styleName) {
			var style = group[styleName];

			styles[styleName] = group[styleName] = {
				open: '\u001b[' + style[0] + 'm',
				close: '\u001b[' + style[1] + 'm'
			};
		});

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	});

	return styles;
}

Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});

},{}],56:[function(require,module,exports){
(function (process){
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                }
            }));
        });
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _each(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor !== Array) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (test()) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (!test()) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if(data.constructor !== Array) {
              data = [data];
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain) cargo.drain();
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.compose = function (/* functions... */) {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // Node.js
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))

},{"_process":3}],57:[function(require,module,exports){
(function (process){
'use strict';
var escapeStringRegexp = require('escape-string-regexp');
var ansiStyles = require('ansi-styles');
var stripAnsi = require('strip-ansi');
var hasAnsi = require('has-ansi');
var supportsColor = require('supports-color');
var defineProps = Object.defineProperties;
var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);

function Chalk(options) {
	// detect mode if not set manually
	this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
}

// use bright blue on Windows as the normal blue color is illegible
if (isSimpleWindowsTerm) {
	ansiStyles.blue.open = '\u001b[94m';
}

var styles = (function () {
	var ret = {};

	Object.keys(ansiStyles).forEach(function (key) {
		ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

		ret[key] = {
			get: function () {
				return build.call(this, this._styles.concat(key));
			}
		};
	});

	return ret;
})();

var proto = defineProps(function chalk() {}, styles);

function build(_styles) {
	var builder = function () {
		return applyStyle.apply(builder, arguments);
	};

	builder._styles = _styles;
	builder.enabled = this.enabled;
	// __proto__ is used because we must return a function, but there is
	// no way to create a function with a different prototype.
	/* eslint-disable no-proto */
	builder.__proto__ = proto;

	return builder;
}

function applyStyle() {
	// support varags, but simply cast to string in case there's only one arg
	var args = arguments;
	var argsLen = args.length;
	var str = argsLen !== 0 && String(arguments[0]);

	if (argsLen > 1) {
		// don't slice `arguments`, it prevents v8 optimizations
		for (var a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || !str) {
		return str;
	}

	var nestedStyles = this._styles;
	var i = nestedStyles.length;

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	var originalDim = ansiStyles.dim.open;
	if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
		ansiStyles.dim.open = '';
	}

	while (i--) {
		var code = ansiStyles[nestedStyles[i]];

		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;
	}

	// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
	ansiStyles.dim.open = originalDim;

	return str;
}

function init() {
	var ret = {};

	Object.keys(styles).forEach(function (name) {
		ret[name] = {
			get: function () {
				return build.call(this, [name]);
			}
		};
	});

	return ret;
}

defineProps(Chalk.prototype, init());

module.exports = new Chalk();
module.exports.styles = ansiStyles;
module.exports.hasColor = hasAnsi;
module.exports.stripColor = stripAnsi;
module.exports.supportsColor = supportsColor;

}).call(this,require('_process'))

},{"_process":3,"ansi-styles":55,"escape-string-regexp":59,"has-ansi":64,"strip-ansi":71,"supports-color":58}],58:[function(require,module,exports){
(function (process){
'use strict';
var argv = process.argv;

var terminator = argv.indexOf('--');
var hasFlag = function (flag) {
	flag = '--' + flag;
	var pos = argv.indexOf(flag);
	return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
};

module.exports = (function () {
	if ('FORCE_COLOR' in process.env) {
		return true;
	}

	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false')) {
		return false;
	}

	if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
})();

}).call(this,require('_process'))

},{"_process":3}],59:[function(require,module,exports){
'use strict';

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(matchOperatorsRe, '\\$&');
};

},{}],60:[function(require,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
/* istanbul ignore next */
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
/* istanbul ignore next */
	else if(typeof exports === 'object')
		exports["esprima"] = factory();
	else
		root["esprima"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/* istanbul ignore if */
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/*
	  Copyright JS Foundation and other contributors, https://js.foundation/

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	var comment_handler_1 = __webpack_require__(1);
	var jsx_parser_1 = __webpack_require__(3);
	var parser_1 = __webpack_require__(8);
	var tokenizer_1 = __webpack_require__(15);
	function parse(code, options, delegate) {
	    var commentHandler = null;
	    var proxyDelegate = function (node, metadata) {
	        if (delegate) {
	            delegate(node, metadata);
	        }
	        if (commentHandler) {
	            commentHandler.visit(node, metadata);
	        }
	    };
	    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;
	    var collectComment = false;
	    if (options) {
	        collectComment = (typeof options.comment === 'boolean' && options.comment);
	        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);
	        if (collectComment || attachComment) {
	            commentHandler = new comment_handler_1.CommentHandler();
	            commentHandler.attach = attachComment;
	            options.comment = true;
	            parserDelegate = proxyDelegate;
	        }
	    }
	    var isModule = false;
	    if (options && typeof options.sourceType === 'string') {
	        isModule = (options.sourceType === 'module');
	    }
	    var parser;
	    if (options && typeof options.jsx === 'boolean' && options.jsx) {
	        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
	    }
	    else {
	        parser = new parser_1.Parser(code, options, parserDelegate);
	    }
	    var program = isModule ? parser.parseModule() : parser.parseScript();
	    var ast = program;
	    if (collectComment && commentHandler) {
	        ast.comments = commentHandler.comments;
	    }
	    if (parser.config.tokens) {
	        ast.tokens = parser.tokens;
	    }
	    if (parser.config.tolerant) {
	        ast.errors = parser.errorHandler.errors;
	    }
	    return ast;
	}
	exports.parse = parse;
	function parseModule(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'module';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseModule = parseModule;
	function parseScript(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'script';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseScript = parseScript;
	function tokenize(code, options, delegate) {
	    var tokenizer = new tokenizer_1.Tokenizer(code, options);
	    var tokens;
	    tokens = [];
	    try {
	        while (true) {
	            var token = tokenizer.getNextToken();
	            if (!token) {
	                break;
	            }
	            if (delegate) {
	                token = delegate(token);
	            }
	            tokens.push(token);
	        }
	    }
	    catch (e) {
	        tokenizer.errorHandler.tolerate(e);
	    }
	    if (tokenizer.errorHandler.tolerant) {
	        tokens.errors = tokenizer.errors();
	    }
	    return tokens;
	}
	exports.tokenize = tokenize;
	var syntax_1 = __webpack_require__(2);
	exports.Syntax = syntax_1.Syntax;
	// Sync with *.json manifests.
	exports.version = '4.0.0';


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	var CommentHandler = (function () {
	    function CommentHandler() {
	        this.attach = false;
	        this.comments = [];
	        this.stack = [];
	        this.leading = [];
	        this.trailing = [];
	    }
	    CommentHandler.prototype.insertInnerComments = function (node, metadata) {
	        //  innnerComments for properties empty block
	        //  `function a() {/** comments **\/}`
	        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
	            var innerComments = [];
	            for (var i = this.leading.length - 1; i >= 0; --i) {
	                var entry = this.leading[i];
	                if (metadata.end.offset >= entry.start) {
	                    innerComments.unshift(entry.comment);
	                    this.leading.splice(i, 1);
	                    this.trailing.splice(i, 1);
	                }
	            }
	            if (innerComments.length) {
	                node.innerComments = innerComments;
	            }
	        }
	    };
	    CommentHandler.prototype.findTrailingComments = function (metadata) {
	        var trailingComments = [];
	        if (this.trailing.length > 0) {
	            for (var i = this.trailing.length - 1; i >= 0; --i) {
	                var entry_1 = this.trailing[i];
	                if (entry_1.start >= metadata.end.offset) {
	                    trailingComments.unshift(entry_1.comment);
	                }
	            }
	            this.trailing.length = 0;
	            return trailingComments;
	        }
	        var entry = this.stack[this.stack.length - 1];
	        if (entry && entry.node.trailingComments) {
	            var firstComment = entry.node.trailingComments[0];
	            if (firstComment && firstComment.range[0] >= metadata.end.offset) {
	                trailingComments = entry.node.trailingComments;
	                delete entry.node.trailingComments;
	            }
	        }
	        return trailingComments;
	    };
	    CommentHandler.prototype.findLeadingComments = function (metadata) {
	        var leadingComments = [];
	        var target;
	        while (this.stack.length > 0) {
	            var entry = this.stack[this.stack.length - 1];
	            if (entry && entry.start >= metadata.start.offset) {
	                target = entry.node;
	                this.stack.pop();
	            }
	            else {
	                break;
	            }
	        }
	        if (target) {
	            var count = target.leadingComments ? target.leadingComments.length : 0;
	            for (var i = count - 1; i >= 0; --i) {
	                var comment = target.leadingComments[i];
	                if (comment.range[1] <= metadata.start.offset) {
	                    leadingComments.unshift(comment);
	                    target.leadingComments.splice(i, 1);
	                }
	            }
	            if (target.leadingComments && target.leadingComments.length === 0) {
	                delete target.leadingComments;
	            }
	            return leadingComments;
	        }
	        for (var i = this.leading.length - 1; i >= 0; --i) {
	            var entry = this.leading[i];
	            if (entry.start <= metadata.start.offset) {
	                leadingComments.unshift(entry.comment);
	                this.leading.splice(i, 1);
	            }
	        }
	        return leadingComments;
	    };
	    CommentHandler.prototype.visitNode = function (node, metadata) {
	        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
	            return;
	        }
	        this.insertInnerComments(node, metadata);
	        var trailingComments = this.findTrailingComments(metadata);
	        var leadingComments = this.findLeadingComments(metadata);
	        if (leadingComments.length > 0) {
	            node.leadingComments = leadingComments;
	        }
	        if (trailingComments.length > 0) {
	            node.trailingComments = trailingComments;
	        }
	        this.stack.push({
	            node: node,
	            start: metadata.start.offset
	        });
	    };
	    CommentHandler.prototype.visitComment = function (node, metadata) {
	        var type = (node.type[0] === 'L') ? 'Line' : 'Block';
	        var comment = {
	            type: type,
	            value: node.value
	        };
	        if (node.range) {
	            comment.range = node.range;
	        }
	        if (node.loc) {
	            comment.loc = node.loc;
	        }
	        this.comments.push(comment);
	        if (this.attach) {
	            var entry = {
	                comment: {
	                    type: type,
	                    value: node.value,
	                    range: [metadata.start.offset, metadata.end.offset]
	                },
	                start: metadata.start.offset
	            };
	            if (node.loc) {
	                entry.comment.loc = node.loc;
	            }
	            node.type = type;
	            this.leading.push(entry);
	            this.trailing.push(entry);
	        }
	    };
	    CommentHandler.prototype.visit = function (node, metadata) {
	        if (node.type === 'LineComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (node.type === 'BlockComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (this.attach) {
	            this.visitNode(node, metadata);
	        }
	    };
	    return CommentHandler;
	}());
	exports.CommentHandler = CommentHandler;


/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Syntax = {
	    AssignmentExpression: 'AssignmentExpression',
	    AssignmentPattern: 'AssignmentPattern',
	    ArrayExpression: 'ArrayExpression',
	    ArrayPattern: 'ArrayPattern',
	    ArrowFunctionExpression: 'ArrowFunctionExpression',
	    AwaitExpression: 'AwaitExpression',
	    BlockStatement: 'BlockStatement',
	    BinaryExpression: 'BinaryExpression',
	    BreakStatement: 'BreakStatement',
	    CallExpression: 'CallExpression',
	    CatchClause: 'CatchClause',
	    ClassBody: 'ClassBody',
	    ClassDeclaration: 'ClassDeclaration',
	    ClassExpression: 'ClassExpression',
	    ConditionalExpression: 'ConditionalExpression',
	    ContinueStatement: 'ContinueStatement',
	    DoWhileStatement: 'DoWhileStatement',
	    DebuggerStatement: 'DebuggerStatement',
	    EmptyStatement: 'EmptyStatement',
	    ExportAllDeclaration: 'ExportAllDeclaration',
	    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	    ExportNamedDeclaration: 'ExportNamedDeclaration',
	    ExportSpecifier: 'ExportSpecifier',
	    ExpressionStatement: 'ExpressionStatement',
	    ForStatement: 'ForStatement',
	    ForOfStatement: 'ForOfStatement',
	    ForInStatement: 'ForInStatement',
	    FunctionDeclaration: 'FunctionDeclaration',
	    FunctionExpression: 'FunctionExpression',
	    Identifier: 'Identifier',
	    IfStatement: 'IfStatement',
	    ImportDeclaration: 'ImportDeclaration',
	    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	    ImportSpecifier: 'ImportSpecifier',
	    Literal: 'Literal',
	    LabeledStatement: 'LabeledStatement',
	    LogicalExpression: 'LogicalExpression',
	    MemberExpression: 'MemberExpression',
	    MetaProperty: 'MetaProperty',
	    MethodDefinition: 'MethodDefinition',
	    NewExpression: 'NewExpression',
	    ObjectExpression: 'ObjectExpression',
	    ObjectPattern: 'ObjectPattern',
	    Program: 'Program',
	    Property: 'Property',
	    RestElement: 'RestElement',
	    ReturnStatement: 'ReturnStatement',
	    SequenceExpression: 'SequenceExpression',
	    SpreadElement: 'SpreadElement',
	    Super: 'Super',
	    SwitchCase: 'SwitchCase',
	    SwitchStatement: 'SwitchStatement',
	    TaggedTemplateExpression: 'TaggedTemplateExpression',
	    TemplateElement: 'TemplateElement',
	    TemplateLiteral: 'TemplateLiteral',
	    ThisExpression: 'ThisExpression',
	    ThrowStatement: 'ThrowStatement',
	    TryStatement: 'TryStatement',
	    UnaryExpression: 'UnaryExpression',
	    UpdateExpression: 'UpdateExpression',
	    VariableDeclaration: 'VariableDeclaration',
	    VariableDeclarator: 'VariableDeclarator',
	    WhileStatement: 'WhileStatement',
	    WithStatement: 'WithStatement',
	    YieldExpression: 'YieldExpression'
	};


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
/* istanbul ignore next */
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var character_1 = __webpack_require__(4);
	var JSXNode = __webpack_require__(5);
	var jsx_syntax_1 = __webpack_require__(6);
	var Node = __webpack_require__(7);
	var parser_1 = __webpack_require__(8);
	var token_1 = __webpack_require__(13);
	var xhtml_entities_1 = __webpack_require__(14);
	token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
	token_1.TokenName[101 /* Text */] = 'JSXText';
	// Fully qualified element name, e.g. <svg:path> returns "svg:path"
	function getQualifiedElementName(elementName) {
	    var qualifiedName;
	    switch (elementName.type) {
	        case jsx_syntax_1.JSXSyntax.JSXIdentifier:
	            var id = elementName;
	            qualifiedName = id.name;
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
	            var ns = elementName;
	            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +
	                getQualifiedElementName(ns.name);
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
	            var expr = elementName;
	            qualifiedName = getQualifiedElementName(expr.object) + '.' +
	                getQualifiedElementName(expr.property);
	            break;
	        /* istanbul ignore next */
	        default:
	            break;
	    }
	    return qualifiedName;
	}
	var JSXParser = (function (_super) {
	    __extends(JSXParser, _super);
	    function JSXParser(code, options, delegate) {
	        return _super.call(this, code, options, delegate) || this;
	    }
	    JSXParser.prototype.parsePrimaryExpression = function () {
	        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
	    };
	    JSXParser.prototype.startJSX = function () {
	        // Unwind the scanner before the lookahead token.
	        this.scanner.index = this.startMarker.index;
	        this.scanner.lineNumber = this.startMarker.line;
	        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
	    };
	    JSXParser.prototype.finishJSX = function () {
	        // Prime the next lookahead.
	        this.nextToken();
	    };
	    JSXParser.prototype.reenterJSX = function () {
	        this.startJSX();
	        this.expectJSX('}');
	        // Pop the closing '}' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	    };
	    JSXParser.prototype.createJSXNode = function () {
	        this.collectComments();
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.createJSXChildNode = function () {
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.scanXHTMLEntity = function (quote) {
	        var result = '&';
	        var valid = true;
	        var terminated = false;
	        var numeric = false;
	        var hex = false;
	        while (!this.scanner.eof() && valid && !terminated) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === quote) {
	                break;
	            }
	            terminated = (ch === ';');
	            result += ch;
	            ++this.scanner.index;
	            if (!terminated) {
	                switch (result.length) {
	                    case 2:
	                        // e.g. '&#123;'
	                        numeric = (ch === '#');
	                        break;
	                    case 3:
	                        if (numeric) {
	                            // e.g. '&#x41;'
	                            hex = (ch === 'x');
	                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
	                            numeric = numeric && !hex;
	                        }
	                        break;
	                    default:
	                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
	                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
	                        break;
	                }
	            }
	        }
	        if (valid && terminated && result.length > 2) {
	            // e.g. '&#x41;' becomes just '#x41'
	            var str = result.substr(1, result.length - 2);
	            if (numeric && str.length > 1) {
	                result = String.fromCharCode(parseInt(str.substr(1), 10));
	            }
	            else if (hex && str.length > 2) {
	                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
	            }
	            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
	                result = xhtml_entities_1.XHTMLEntities[str];
	            }
	        }
	        return result;
	    };
	    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
	    JSXParser.prototype.lexJSX = function () {
	        var cp = this.scanner.source.charCodeAt(this.scanner.index);
	        // < > / : = { }
	        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
	            var value = this.scanner.source[this.scanner.index++];
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index - 1,
	                end: this.scanner.index
	            };
	        }
	        // " '
	        if (cp === 34 || cp === 39) {
	            var start = this.scanner.index;
	            var quote = this.scanner.source[this.scanner.index++];
	            var str = '';
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source[this.scanner.index++];
	                if (ch === quote) {
	                    break;
	                }
	                else if (ch === '&') {
	                    str += this.scanXHTMLEntity(quote);
	                }
	                else {
	                    str += ch;
	                }
	            }
	            return {
	                type: 8 /* StringLiteral */,
	                value: str,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // ... or .
	        if (cp === 46) {
	            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
	            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
	            var value = (n1 === 46 && n2 === 46) ? '...' : '.';
	            var start = this.scanner.index;
	            this.scanner.index += value.length;
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // `
	        if (cp === 96) {
	            // Only placeholder, since it will be rescanned as a real assignment expression.
	            return {
	                type: 10 /* Template */,
	                value: '',
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index,
	                end: this.scanner.index
	            };
	        }
	        // Identifer can not contain backslash (char code 92).
	        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {
	            var start = this.scanner.index;
	            ++this.scanner.index;
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source.charCodeAt(this.scanner.index);
	                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {
	                    ++this.scanner.index;
	                }
	                else if (ch === 45) {
	                    // Hyphen (char code 45) can be part of an identifier.
	                    ++this.scanner.index;
	                }
	                else {
	                    break;
	                }
	            }
	            var id = this.scanner.source.slice(start, this.scanner.index);
	            return {
	                type: 100 /* Identifier */,
	                value: id,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        return this.scanner.lex();
	    };
	    JSXParser.prototype.nextJSXToken = function () {
	        this.collectComments();
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = this.lexJSX();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        if (this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.nextJSXText = function () {
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var start = this.scanner.index;
	        var text = '';
	        while (!this.scanner.eof()) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === '{' || ch === '<') {
	                break;
	            }
	            ++this.scanner.index;
	            text += ch;
	            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.scanner.lineNumber;
	                if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
	                    ++this.scanner.index;
	                }
	                this.scanner.lineStart = this.scanner.index;
	            }
	        }
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = {
	            type: 101 /* Text */,
	            value: text,
	            lineNumber: this.scanner.lineNumber,
	            lineStart: this.scanner.lineStart,
	            start: start,
	            end: this.scanner.index
	        };
	        if ((text.length > 0) && this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.peekJSXToken = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.lexJSX();
	        this.scanner.restoreState(state);
	        return next;
	    };
	    // Expect the next JSX token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    JSXParser.prototype.expectJSX = function (value) {
	        var token = this.nextJSXToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next JSX token matches the specified punctuator.
	    JSXParser.prototype.matchJSX = function (value) {
	        var next = this.peekJSXToken();
	        return next.type === 7 /* Punctuator */ && next.value === value;
	    };
	    JSXParser.prototype.parseJSXIdentifier = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 100 /* Identifier */) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
	    };
	    JSXParser.prototype.parseJSXElementName = function () {
	        var node = this.createJSXNode();
	        var elementName = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = elementName;
	            this.expectJSX(':');
	            var name_1 = this.parseJSXIdentifier();
	            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
	        }
	        else if (this.matchJSX('.')) {
	            while (this.matchJSX('.')) {
	                var object = elementName;
	                this.expectJSX('.');
	                var property = this.parseJSXIdentifier();
	                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
	            }
	        }
	        return elementName;
	    };
	    JSXParser.prototype.parseJSXAttributeName = function () {
	        var node = this.createJSXNode();
	        var attributeName;
	        var identifier = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = identifier;
	            this.expectJSX(':');
	            var name_2 = this.parseJSXIdentifier();
	            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
	        }
	        else {
	            attributeName = identifier;
	        }
	        return attributeName;
	    };
	    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 8 /* StringLiteral */) {
	            this.throwUnexpectedToken(token);
	        }
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    JSXParser.prototype.parseJSXExpressionAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.finishJSX();
	        if (this.match('}')) {
	            this.tolerateError('JSX attributes must only be assigned a non-empty expression');
	        }
	        var expression = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXAttributeValue = function () {
	        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :
	            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
	    };
	    JSXParser.prototype.parseJSXNameValueAttribute = function () {
	        var node = this.createJSXNode();
	        var name = this.parseJSXAttributeName();
	        var value = null;
	        if (this.matchJSX('=')) {
	            this.expectJSX('=');
	            value = this.parseJSXAttributeValue();
	        }
	        return this.finalize(node, new JSXNode.JSXAttribute(name, value));
	    };
	    JSXParser.prototype.parseJSXSpreadAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.expectJSX('...');
	        this.finishJSX();
	        var argument = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
	    };
	    JSXParser.prototype.parseJSXAttributes = function () {
	        var attributes = [];
	        while (!this.matchJSX('/') && !this.matchJSX('>')) {
	            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :
	                this.parseJSXNameValueAttribute();
	            attributes.push(attribute);
	        }
	        return attributes;
	    };
	    JSXParser.prototype.parseJSXOpeningElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXBoundaryElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        if (this.matchJSX('/')) {
	            this.expectJSX('/');
	            var name_3 = this.parseJSXElementName();
	            this.expectJSX('>');
	            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
	        }
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXEmptyExpression = function () {
	        var node = this.createJSXChildNode();
	        this.collectComments();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        return this.finalize(node, new JSXNode.JSXEmptyExpression());
	    };
	    JSXParser.prototype.parseJSXExpressionContainer = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        var expression;
	        if (this.matchJSX('}')) {
	            expression = this.parseJSXEmptyExpression();
	            this.expectJSX('}');
	        }
	        else {
	            this.finishJSX();
	            expression = this.parseAssignmentExpression();
	            this.reenterJSX();
	        }
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXChildren = function () {
	        var children = [];
	        while (!this.scanner.eof()) {
	            var node = this.createJSXChildNode();
	            var token = this.nextJSXText();
	            if (token.start < token.end) {
	                var raw = this.getTokenRaw(token);
	                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
	                children.push(child);
	            }
	            if (this.scanner.source[this.scanner.index] === '{') {
	                var container = this.parseJSXExpressionContainer();
	                children.push(container);
	            }
	            else {
	                break;
	            }
	        }
	        return children;
	    };
	    JSXParser.prototype.parseComplexJSXElement = function (el) {
	        var stack = [];
	        while (!this.scanner.eof()) {
	            el.children = el.children.concat(this.parseJSXChildren());
	            var node = this.createJSXChildNode();
	            var element = this.parseJSXBoundaryElement();
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
	                var opening = element;
	                if (opening.selfClosing) {
	                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
	                    el.children.push(child);
	                }
	                else {
	                    stack.push(el);
	                    el = { node: node, opening: opening, closing: null, children: [] };
	                }
	            }
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
	                el.closing = element;
	                var open_1 = getQualifiedElementName(el.opening.name);
	                var close_1 = getQualifiedElementName(el.closing.name);
	                if (open_1 !== close_1) {
	                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
	                }
	                if (stack.length > 0) {
	                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
	                    el = stack[stack.length - 1];
	                    el.children.push(child);
	                    stack.pop();
	                }
	                else {
	                    break;
	                }
	            }
	        }
	        return el;
	    };
	    JSXParser.prototype.parseJSXElement = function () {
	        var node = this.createJSXNode();
	        var opening = this.parseJSXOpeningElement();
	        var children = [];
	        var closing = null;
	        if (!opening.selfClosing) {
	            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
	            children = el.children;
	            closing = el.closing;
	        }
	        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
	    };
	    JSXParser.prototype.parseJSXRoot = function () {
	        // Pop the opening '<' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	        this.startJSX();
	        var element = this.parseJSXElement();
	        this.finishJSX();
	        return element;
	    };
	    JSXParser.prototype.isStartOfExpression = function () {
	        return _super.prototype.isStartOfExpression.call(this) || this.match('<');
	    };
	    return JSXParser;
	}(parser_1.Parser));
	exports.JSXParser = JSXParser;


/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// See also tools/generate-unicode-regex.js.
	var Regex = {
	    // Unicode v8.0.0 NonAsciiIdentifierStart:
	    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
	    // Unicode v8.0.0 NonAsciiIdentifierPart:
	    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	};
	exports.Character = {
	    /* tslint:disable:no-bitwise */
	    fromCodePoint: function (cp) {
	        return (cp < 0x10000) ? String.fromCharCode(cp) :
	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
	                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
	    },
	    // https://tc39.github.io/ecma262/#sec-white-space
	    isWhiteSpace: function (cp) {
	        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
	            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
	    },
	    // https://tc39.github.io/ecma262/#sec-line-terminators
	    isLineTerminator: function (cp) {
	        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
	    },
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    isIdentifierStart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));
	    },
	    isIdentifierPart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp >= 0x30 && cp <= 0x39) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));
	    },
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    isDecimalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39); // 0..9
	    },
	    isHexDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39) ||
	            (cp >= 0x41 && cp <= 0x46) ||
	            (cp >= 0x61 && cp <= 0x66); // a..f
	    },
	    isOctalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x37); // 0..7
	    }
	};


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var jsx_syntax_1 = __webpack_require__(6);
	/* tslint:disable:max-classes-per-file */
	var JSXClosingElement = (function () {
	    function JSXClosingElement(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
	        this.name = name;
	    }
	    return JSXClosingElement;
	}());
	exports.JSXClosingElement = JSXClosingElement;
	var JSXElement = (function () {
	    function JSXElement(openingElement, children, closingElement) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXElement;
	        this.openingElement = openingElement;
	        this.children = children;
	        this.closingElement = closingElement;
	    }
	    return JSXElement;
	}());
	exports.JSXElement = JSXElement;
	var JSXEmptyExpression = (function () {
	    function JSXEmptyExpression() {
	        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
	    }
	    return JSXEmptyExpression;
	}());
	exports.JSXEmptyExpression = JSXEmptyExpression;
	var JSXExpressionContainer = (function () {
	    function JSXExpressionContainer(expression) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
	        this.expression = expression;
	    }
	    return JSXExpressionContainer;
	}());
	exports.JSXExpressionContainer = JSXExpressionContainer;
	var JSXIdentifier = (function () {
	    function JSXIdentifier(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
	        this.name = name;
	    }
	    return JSXIdentifier;
	}());
	exports.JSXIdentifier = JSXIdentifier;
	var JSXMemberExpression = (function () {
	    function JSXMemberExpression(object, property) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
	        this.object = object;
	        this.property = property;
	    }
	    return JSXMemberExpression;
	}());
	exports.JSXMemberExpression = JSXMemberExpression;
	var JSXAttribute = (function () {
	    function JSXAttribute(name, value) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
	        this.name = name;
	        this.value = value;
	    }
	    return JSXAttribute;
	}());
	exports.JSXAttribute = JSXAttribute;
	var JSXNamespacedName = (function () {
	    function JSXNamespacedName(namespace, name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
	        this.namespace = namespace;
	        this.name = name;
	    }
	    return JSXNamespacedName;
	}());
	exports.JSXNamespacedName = JSXNamespacedName;
	var JSXOpeningElement = (function () {
	    function JSXOpeningElement(name, selfClosing, attributes) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
	        this.name = name;
	        this.selfClosing = selfClosing;
	        this.attributes = attributes;
	    }
	    return JSXOpeningElement;
	}());
	exports.JSXOpeningElement = JSXOpeningElement;
	var JSXSpreadAttribute = (function () {
	    function JSXSpreadAttribute(argument) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
	        this.argument = argument;
	    }
	    return JSXSpreadAttribute;
	}());
	exports.JSXSpreadAttribute = JSXSpreadAttribute;
	var JSXText = (function () {
	    function JSXText(value, raw) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXText;
	        this.value = value;
	        this.raw = raw;
	    }
	    return JSXText;
	}());
	exports.JSXText = JSXText;


/***/ },
/* 6 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JSXSyntax = {
	    JSXAttribute: 'JSXAttribute',
	    JSXClosingElement: 'JSXClosingElement',
	    JSXElement: 'JSXElement',
	    JSXEmptyExpression: 'JSXEmptyExpression',
	    JSXExpressionContainer: 'JSXExpressionContainer',
	    JSXIdentifier: 'JSXIdentifier',
	    JSXMemberExpression: 'JSXMemberExpression',
	    JSXNamespacedName: 'JSXNamespacedName',
	    JSXOpeningElement: 'JSXOpeningElement',
	    JSXSpreadAttribute: 'JSXSpreadAttribute',
	    JSXText: 'JSXText'
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	/* tslint:disable:max-classes-per-file */
	var ArrayExpression = (function () {
	    function ArrayExpression(elements) {
	        this.type = syntax_1.Syntax.ArrayExpression;
	        this.elements = elements;
	    }
	    return ArrayExpression;
	}());
	exports.ArrayExpression = ArrayExpression;
	var ArrayPattern = (function () {
	    function ArrayPattern(elements) {
	        this.type = syntax_1.Syntax.ArrayPattern;
	        this.elements = elements;
	    }
	    return ArrayPattern;
	}());
	exports.ArrayPattern = ArrayPattern;
	var ArrowFunctionExpression = (function () {
	    function ArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = false;
	    }
	    return ArrowFunctionExpression;
	}());
	exports.ArrowFunctionExpression = ArrowFunctionExpression;
	var AssignmentExpression = (function () {
	    function AssignmentExpression(operator, left, right) {
	        this.type = syntax_1.Syntax.AssignmentExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentExpression;
	}());
	exports.AssignmentExpression = AssignmentExpression;
	var AssignmentPattern = (function () {
	    function AssignmentPattern(left, right) {
	        this.type = syntax_1.Syntax.AssignmentPattern;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentPattern;
	}());
	exports.AssignmentPattern = AssignmentPattern;
	var AsyncArrowFunctionExpression = (function () {
	    function AsyncArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = true;
	    }
	    return AsyncArrowFunctionExpression;
	}());
	exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
	var AsyncFunctionDeclaration = (function () {
	    function AsyncFunctionDeclaration(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionDeclaration;
	}());
	exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
	var AsyncFunctionExpression = (function () {
	    function AsyncFunctionExpression(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionExpression;
	}());
	exports.AsyncFunctionExpression = AsyncFunctionExpression;
	var AwaitExpression = (function () {
	    function AwaitExpression(argument) {
	        this.type = syntax_1.Syntax.AwaitExpression;
	        this.argument = argument;
	    }
	    return AwaitExpression;
	}());
	exports.AwaitExpression = AwaitExpression;
	var BinaryExpression = (function () {
	    function BinaryExpression(operator, left, right) {
	        var logical = (operator === '||' || operator === '&&');
	        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return BinaryExpression;
	}());
	exports.BinaryExpression = BinaryExpression;
	var BlockStatement = (function () {
	    function BlockStatement(body) {
	        this.type = syntax_1.Syntax.BlockStatement;
	        this.body = body;
	    }
	    return BlockStatement;
	}());
	exports.BlockStatement = BlockStatement;
	var BreakStatement = (function () {
	    function BreakStatement(label) {
	        this.type = syntax_1.Syntax.BreakStatement;
	        this.label = label;
	    }
	    return BreakStatement;
	}());
	exports.BreakStatement = BreakStatement;
	var CallExpression = (function () {
	    function CallExpression(callee, args) {
	        this.type = syntax_1.Syntax.CallExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return CallExpression;
	}());
	exports.CallExpression = CallExpression;
	var CatchClause = (function () {
	    function CatchClause(param, body) {
	        this.type = syntax_1.Syntax.CatchClause;
	        this.param = param;
	        this.body = body;
	    }
	    return CatchClause;
	}());
	exports.CatchClause = CatchClause;
	var ClassBody = (function () {
	    function ClassBody(body) {
	        this.type = syntax_1.Syntax.ClassBody;
	        this.body = body;
	    }
	    return ClassBody;
	}());
	exports.ClassBody = ClassBody;
	var ClassDeclaration = (function () {
	    function ClassDeclaration(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassDeclaration;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassDeclaration;
	}());
	exports.ClassDeclaration = ClassDeclaration;
	var ClassExpression = (function () {
	    function ClassExpression(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassExpression;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassExpression;
	}());
	exports.ClassExpression = ClassExpression;
	var ComputedMemberExpression = (function () {
	    function ComputedMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = true;
	        this.object = object;
	        this.property = property;
	    }
	    return ComputedMemberExpression;
	}());
	exports.ComputedMemberExpression = ComputedMemberExpression;
	var ConditionalExpression = (function () {
	    function ConditionalExpression(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.ConditionalExpression;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return ConditionalExpression;
	}());
	exports.ConditionalExpression = ConditionalExpression;
	var ContinueStatement = (function () {
	    function ContinueStatement(label) {
	        this.type = syntax_1.Syntax.ContinueStatement;
	        this.label = label;
	    }
	    return ContinueStatement;
	}());
	exports.ContinueStatement = ContinueStatement;
	var DebuggerStatement = (function () {
	    function DebuggerStatement() {
	        this.type = syntax_1.Syntax.DebuggerStatement;
	    }
	    return DebuggerStatement;
	}());
	exports.DebuggerStatement = DebuggerStatement;
	var Directive = (function () {
	    function Directive(expression, directive) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	        this.directive = directive;
	    }
	    return Directive;
	}());
	exports.Directive = Directive;
	var DoWhileStatement = (function () {
	    function DoWhileStatement(body, test) {
	        this.type = syntax_1.Syntax.DoWhileStatement;
	        this.body = body;
	        this.test = test;
	    }
	    return DoWhileStatement;
	}());
	exports.DoWhileStatement = DoWhileStatement;
	var EmptyStatement = (function () {
	    function EmptyStatement() {
	        this.type = syntax_1.Syntax.EmptyStatement;
	    }
	    return EmptyStatement;
	}());
	exports.EmptyStatement = EmptyStatement;
	var ExportAllDeclaration = (function () {
	    function ExportAllDeclaration(source) {
	        this.type = syntax_1.Syntax.ExportAllDeclaration;
	        this.source = source;
	    }
	    return ExportAllDeclaration;
	}());
	exports.ExportAllDeclaration = ExportAllDeclaration;
	var ExportDefaultDeclaration = (function () {
	    function ExportDefaultDeclaration(declaration) {
	        this.type = syntax_1.Syntax.ExportDefaultDeclaration;
	        this.declaration = declaration;
	    }
	    return ExportDefaultDeclaration;
	}());
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	var ExportNamedDeclaration = (function () {
	    function ExportNamedDeclaration(declaration, specifiers, source) {
	        this.type = syntax_1.Syntax.ExportNamedDeclaration;
	        this.declaration = declaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ExportNamedDeclaration;
	}());
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	var ExportSpecifier = (function () {
	    function ExportSpecifier(local, exported) {
	        this.type = syntax_1.Syntax.ExportSpecifier;
	        this.exported = exported;
	        this.local = local;
	    }
	    return ExportSpecifier;
	}());
	exports.ExportSpecifier = ExportSpecifier;
	var ExpressionStatement = (function () {
	    function ExpressionStatement(expression) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	    }
	    return ExpressionStatement;
	}());
	exports.ExpressionStatement = ExpressionStatement;
	var ForInStatement = (function () {
	    function ForInStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForInStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	        this.each = false;
	    }
	    return ForInStatement;
	}());
	exports.ForInStatement = ForInStatement;
	var ForOfStatement = (function () {
	    function ForOfStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForOfStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	    }
	    return ForOfStatement;
	}());
	exports.ForOfStatement = ForOfStatement;
	var ForStatement = (function () {
	    function ForStatement(init, test, update, body) {
	        this.type = syntax_1.Syntax.ForStatement;
	        this.init = init;
	        this.test = test;
	        this.update = update;
	        this.body = body;
	    }
	    return ForStatement;
	}());
	exports.ForStatement = ForStatement;
	var FunctionDeclaration = (function () {
	    function FunctionDeclaration(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionDeclaration;
	}());
	exports.FunctionDeclaration = FunctionDeclaration;
	var FunctionExpression = (function () {
	    function FunctionExpression(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionExpression;
	}());
	exports.FunctionExpression = FunctionExpression;
	var Identifier = (function () {
	    function Identifier(name) {
	        this.type = syntax_1.Syntax.Identifier;
	        this.name = name;
	    }
	    return Identifier;
	}());
	exports.Identifier = Identifier;
	var IfStatement = (function () {
	    function IfStatement(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.IfStatement;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return IfStatement;
	}());
	exports.IfStatement = IfStatement;
	var ImportDeclaration = (function () {
	    function ImportDeclaration(specifiers, source) {
	        this.type = syntax_1.Syntax.ImportDeclaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ImportDeclaration;
	}());
	exports.ImportDeclaration = ImportDeclaration;
	var ImportDefaultSpecifier = (function () {
	    function ImportDefaultSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportDefaultSpecifier;
	        this.local = local;
	    }
	    return ImportDefaultSpecifier;
	}());
	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	var ImportNamespaceSpecifier = (function () {
	    function ImportNamespaceSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
	        this.local = local;
	    }
	    return ImportNamespaceSpecifier;
	}());
	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
	var ImportSpecifier = (function () {
	    function ImportSpecifier(local, imported) {
	        this.type = syntax_1.Syntax.ImportSpecifier;
	        this.local = local;
	        this.imported = imported;
	    }
	    return ImportSpecifier;
	}());
	exports.ImportSpecifier = ImportSpecifier;
	var LabeledStatement = (function () {
	    function LabeledStatement(label, body) {
	        this.type = syntax_1.Syntax.LabeledStatement;
	        this.label = label;
	        this.body = body;
	    }
	    return LabeledStatement;
	}());
	exports.LabeledStatement = LabeledStatement;
	var Literal = (function () {
	    function Literal(value, raw) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	    }
	    return Literal;
	}());
	exports.Literal = Literal;
	var MetaProperty = (function () {
	    function MetaProperty(meta, property) {
	        this.type = syntax_1.Syntax.MetaProperty;
	        this.meta = meta;
	        this.property = property;
	    }
	    return MetaProperty;
	}());
	exports.MetaProperty = MetaProperty;
	var MethodDefinition = (function () {
	    function MethodDefinition(key, computed, value, kind, isStatic) {
	        this.type = syntax_1.Syntax.MethodDefinition;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.static = isStatic;
	    }
	    return MethodDefinition;
	}());
	exports.MethodDefinition = MethodDefinition;
	var Module = (function () {
	    function Module(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'module';
	    }
	    return Module;
	}());
	exports.Module = Module;
	var NewExpression = (function () {
	    function NewExpression(callee, args) {
	        this.type = syntax_1.Syntax.NewExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return NewExpression;
	}());
	exports.NewExpression = NewExpression;
	var ObjectExpression = (function () {
	    function ObjectExpression(properties) {
	        this.type = syntax_1.Syntax.ObjectExpression;
	        this.properties = properties;
	    }
	    return ObjectExpression;
	}());
	exports.ObjectExpression = ObjectExpression;
	var ObjectPattern = (function () {
	    function ObjectPattern(properties) {
	        this.type = syntax_1.Syntax.ObjectPattern;
	        this.properties = properties;
	    }
	    return ObjectPattern;
	}());
	exports.ObjectPattern = ObjectPattern;
	var Property = (function () {
	    function Property(kind, key, computed, value, method, shorthand) {
	        this.type = syntax_1.Syntax.Property;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.method = method;
	        this.shorthand = shorthand;
	    }
	    return Property;
	}());
	exports.Property = Property;
	var RegexLiteral = (function () {
	    function RegexLiteral(value, raw, pattern, flags) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	        this.regex = { pattern: pattern, flags: flags };
	    }
	    return RegexLiteral;
	}());
	exports.RegexLiteral = RegexLiteral;
	var RestElement = (function () {
	    function RestElement(argument) {
	        this.type = syntax_1.Syntax.RestElement;
	        this.argument = argument;
	    }
	    return RestElement;
	}());
	exports.RestElement = RestElement;
	var ReturnStatement = (function () {
	    function ReturnStatement(argument) {
	        this.type = syntax_1.Syntax.ReturnStatement;
	        this.argument = argument;
	    }
	    return ReturnStatement;
	}());
	exports.ReturnStatement = ReturnStatement;
	var Script = (function () {
	    function Script(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'script';
	    }
	    return Script;
	}());
	exports.Script = Script;
	var SequenceExpression = (function () {
	    function SequenceExpression(expressions) {
	        this.type = syntax_1.Syntax.SequenceExpression;
	        this.expressions = expressions;
	    }
	    return SequenceExpression;
	}());
	exports.SequenceExpression = SequenceExpression;
	var SpreadElement = (function () {
	    function SpreadElement(argument) {
	        this.type = syntax_1.Syntax.SpreadElement;
	        this.argument = argument;
	    }
	    return SpreadElement;
	}());
	exports.SpreadElement = SpreadElement;
	var StaticMemberExpression = (function () {
	    function StaticMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = false;
	        this.object = object;
	        this.property = property;
	    }
	    return StaticMemberExpression;
	}());
	exports.StaticMemberExpression = StaticMemberExpression;
	var Super = (function () {
	    function Super() {
	        this.type = syntax_1.Syntax.Super;
	    }
	    return Super;
	}());
	exports.Super = Super;
	var SwitchCase = (function () {
	    function SwitchCase(test, consequent) {
	        this.type = syntax_1.Syntax.SwitchCase;
	        this.test = test;
	        this.consequent = consequent;
	    }
	    return SwitchCase;
	}());
	exports.SwitchCase = SwitchCase;
	var SwitchStatement = (function () {
	    function SwitchStatement(discriminant, cases) {
	        this.type = syntax_1.Syntax.SwitchStatement;
	        this.discriminant = discriminant;
	        this.cases = cases;
	    }
	    return SwitchStatement;
	}());
	exports.SwitchStatement = SwitchStatement;
	var TaggedTemplateExpression = (function () {
	    function TaggedTemplateExpression(tag, quasi) {
	        this.type = syntax_1.Syntax.TaggedTemplateExpression;
	        this.tag = tag;
	        this.quasi = quasi;
	    }
	    return TaggedTemplateExpression;
	}());
	exports.TaggedTemplateExpression = TaggedTemplateExpression;
	var TemplateElement = (function () {
	    function TemplateElement(value, tail) {
	        this.type = syntax_1.Syntax.TemplateElement;
	        this.value = value;
	        this.tail = tail;
	    }
	    return TemplateElement;
	}());
	exports.TemplateElement = TemplateElement;
	var TemplateLiteral = (function () {
	    function TemplateLiteral(quasis, expressions) {
	        this.type = syntax_1.Syntax.TemplateLiteral;
	        this.quasis = quasis;
	        this.expressions = expressions;
	    }
	    return TemplateLiteral;
	}());
	exports.TemplateLiteral = TemplateLiteral;
	var ThisExpression = (function () {
	    function ThisExpression() {
	        this.type = syntax_1.Syntax.ThisExpression;
	    }
	    return ThisExpression;
	}());
	exports.ThisExpression = ThisExpression;
	var ThrowStatement = (function () {
	    function ThrowStatement(argument) {
	        this.type = syntax_1.Syntax.ThrowStatement;
	        this.argument = argument;
	    }
	    return ThrowStatement;
	}());
	exports.ThrowStatement = ThrowStatement;
	var TryStatement = (function () {
	    function TryStatement(block, handler, finalizer) {
	        this.type = syntax_1.Syntax.TryStatement;
	        this.block = block;
	        this.handler = handler;
	        this.finalizer = finalizer;
	    }
	    return TryStatement;
	}());
	exports.TryStatement = TryStatement;
	var UnaryExpression = (function () {
	    function UnaryExpression(operator, argument) {
	        this.type = syntax_1.Syntax.UnaryExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = true;
	    }
	    return UnaryExpression;
	}());
	exports.UnaryExpression = UnaryExpression;
	var UpdateExpression = (function () {
	    function UpdateExpression(operator, argument, prefix) {
	        this.type = syntax_1.Syntax.UpdateExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = prefix;
	    }
	    return UpdateExpression;
	}());
	exports.UpdateExpression = UpdateExpression;
	var VariableDeclaration = (function () {
	    function VariableDeclaration(declarations, kind) {
	        this.type = syntax_1.Syntax.VariableDeclaration;
	        this.declarations = declarations;
	        this.kind = kind;
	    }
	    return VariableDeclaration;
	}());
	exports.VariableDeclaration = VariableDeclaration;
	var VariableDeclarator = (function () {
	    function VariableDeclarator(id, init) {
	        this.type = syntax_1.Syntax.VariableDeclarator;
	        this.id = id;
	        this.init = init;
	    }
	    return VariableDeclarator;
	}());
	exports.VariableDeclarator = VariableDeclarator;
	var WhileStatement = (function () {
	    function WhileStatement(test, body) {
	        this.type = syntax_1.Syntax.WhileStatement;
	        this.test = test;
	        this.body = body;
	    }
	    return WhileStatement;
	}());
	exports.WhileStatement = WhileStatement;
	var WithStatement = (function () {
	    function WithStatement(object, body) {
	        this.type = syntax_1.Syntax.WithStatement;
	        this.object = object;
	        this.body = body;
	    }
	    return WithStatement;
	}());
	exports.WithStatement = WithStatement;
	var YieldExpression = (function () {
	    function YieldExpression(argument, delegate) {
	        this.type = syntax_1.Syntax.YieldExpression;
	        this.argument = argument;
	        this.delegate = delegate;
	    }
	    return YieldExpression;
	}());
	exports.YieldExpression = YieldExpression;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var error_handler_1 = __webpack_require__(10);
	var messages_1 = __webpack_require__(11);
	var Node = __webpack_require__(7);
	var scanner_1 = __webpack_require__(12);
	var syntax_1 = __webpack_require__(2);
	var token_1 = __webpack_require__(13);
	var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
	var Parser = (function () {
	    function Parser(code, options, delegate) {
	        if (options === void 0) { options = {}; }
	        this.config = {
	            range: (typeof options.range === 'boolean') && options.range,
	            loc: (typeof options.loc === 'boolean') && options.loc,
	            source: null,
	            tokens: (typeof options.tokens === 'boolean') && options.tokens,
	            comment: (typeof options.comment === 'boolean') && options.comment,
	            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant
	        };
	        if (this.config.loc && options.source && options.source !== null) {
	            this.config.source = String(options.source);
	        }
	        this.delegate = delegate;
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = this.config.tolerant;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = this.config.comment;
	        this.operatorPrecedence = {
	            ')': 0,
	            ';': 0,
	            ',': 0,
	            '=': 0,
	            ']': 0,
	            '||': 1,
	            '&&': 2,
	            '|': 3,
	            '^': 4,
	            '&': 5,
	            '==': 6,
	            '!=': 6,
	            '===': 6,
	            '!==': 6,
	            '<': 7,
	            '>': 7,
	            '<=': 7,
	            '>=': 7,
	            '<<': 8,
	            '>>': 8,
	            '>>>': 8,
	            '+': 9,
	            '-': 9,
	            '*': 11,
	            '/': 11,
	            '%': 11
	        };
	        this.lookahead = {
	            type: 2 /* EOF */,
	            value: '',
	            lineNumber: this.scanner.lineNumber,
	            lineStart: 0,
	            start: 0,
	            end: 0
	        };
	        this.hasLineTerminator = false;
	        this.context = {
	            isModule: false,
	            await: false,
	            allowIn: true,
	            allowStrictDirective: true,
	            allowYield: true,
	            firstCoverInitializedNameError: null,
	            isAssignmentTarget: false,
	            isBindingElement: false,
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            labelSet: {},
	            strict: false
	        };
	        this.tokens = [];
	        this.startMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.lastMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.nextToken();
	        this.lastMarker = {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    }
	    Parser.prototype.throwError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.lastMarker.line;
	        var column = this.lastMarker.column + 1;
	        throw this.errorHandler.createError(index, line, column, msg);
	    };
	    Parser.prototype.tolerateError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.scanner.lineNumber;
	        var column = this.lastMarker.column + 1;
	        this.errorHandler.tolerateError(index, line, column, msg);
	    };
	    // Throw an exception because of the token.
	    Parser.prototype.unexpectedTokenError = function (token, message) {
	        var msg = message || messages_1.Messages.UnexpectedToken;
	        var value;
	        if (token) {
	            if (!message) {
	                msg = (token.type === 2 /* EOF */) ? messages_1.Messages.UnexpectedEOS :
	                    (token.type === 3 /* Identifier */) ? messages_1.Messages.UnexpectedIdentifier :
	                        (token.type === 6 /* NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :
	                            (token.type === 8 /* StringLiteral */) ? messages_1.Messages.UnexpectedString :
	                                (token.type === 10 /* Template */) ? messages_1.Messages.UnexpectedTemplate :
	                                    messages_1.Messages.UnexpectedToken;
	                if (token.type === 4 /* Keyword */) {
	                    if (this.scanner.isFutureReservedWord(token.value)) {
	                        msg = messages_1.Messages.UnexpectedReserved;
	                    }
	                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
	                        msg = messages_1.Messages.StrictReservedWord;
	                    }
	                }
	            }
	            value = token.value;
	        }
	        else {
	            value = 'ILLEGAL';
	        }
	        msg = msg.replace('%0', value);
	        if (token && typeof token.lineNumber === 'number') {
	            var index = token.start;
	            var line = token.lineNumber;
	            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
	            var column = token.start - lastMarkerLineStart + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	        else {
	            var index = this.lastMarker.index;
	            var line = this.lastMarker.line;
	            var column = this.lastMarker.column + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	    };
	    Parser.prototype.throwUnexpectedToken = function (token, message) {
	        throw this.unexpectedTokenError(token, message);
	    };
	    Parser.prototype.tolerateUnexpectedToken = function (token, message) {
	        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
	    };
	    Parser.prototype.collectComments = function () {
	        if (!this.config.comment) {
	            this.scanner.scanComments();
	        }
	        else {
	            var comments = this.scanner.scanComments();
	            if (comments.length > 0 && this.delegate) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var node = void 0;
	                    node = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
	                    };
	                    if (this.config.range) {
	                        node.range = e.range;
	                    }
	                    if (this.config.loc) {
	                        node.loc = e.loc;
	                    }
	                    var metadata = {
	                        start: {
	                            line: e.loc.start.line,
	                            column: e.loc.start.column,
	                            offset: e.range[0]
	                        },
	                        end: {
	                            line: e.loc.end.line,
	                            column: e.loc.end.column,
	                            offset: e.range[1]
	                        }
	                    };
	                    this.delegate(node, metadata);
	                }
	            }
	        }
	    };
	    // From internal representation to an external structure
	    Parser.prototype.getTokenRaw = function (token) {
	        return this.scanner.source.slice(token.start, token.end);
	    };
	    Parser.prototype.convertToken = function (token) {
	        var t = {
	            type: token_1.TokenName[token.type],
	            value: this.getTokenRaw(token)
	        };
	        if (this.config.range) {
	            t.range = [token.start, token.end];
	        }
	        if (this.config.loc) {
	            t.loc = {
	                start: {
	                    line: this.startMarker.line,
	                    column: this.startMarker.column
	                },
	                end: {
	                    line: this.scanner.lineNumber,
	                    column: this.scanner.index - this.scanner.lineStart
	                }
	            };
	        }
	        if (token.type === 9 /* RegularExpression */) {
	            var pattern = token.pattern;
	            var flags = token.flags;
	            t.regex = { pattern: pattern, flags: flags };
	        }
	        return t;
	    };
	    Parser.prototype.nextToken = function () {
	        var token = this.lookahead;
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        this.collectComments();
	        if (this.scanner.index !== this.startMarker.index) {
	            this.startMarker.index = this.scanner.index;
	            this.startMarker.line = this.scanner.lineNumber;
	            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        }
	        var next = this.scanner.lex();
	        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
	        if (next && this.context.strict && next.type === 3 /* Identifier */) {
	            if (this.scanner.isStrictModeReservedWord(next.value)) {
	                next.type = 4 /* Keyword */;
	            }
	        }
	        this.lookahead = next;
	        if (this.config.tokens && next.type !== 2 /* EOF */) {
	            this.tokens.push(this.convertToken(next));
	        }
	        return token;
	    };
	    Parser.prototype.nextRegexToken = function () {
	        this.collectComments();
	        var token = this.scanner.scanRegExp();
	        if (this.config.tokens) {
	            // Pop the previous token, '/' or '/='
	            // This is added from the lookahead token.
	            this.tokens.pop();
	            this.tokens.push(this.convertToken(token));
	        }
	        // Prime the next lookahead.
	        this.lookahead = token;
	        this.nextToken();
	        return token;
	    };
	    Parser.prototype.createNode = function () {
	        return {
	            index: this.startMarker.index,
	            line: this.startMarker.line,
	            column: this.startMarker.column
	        };
	    };
	    Parser.prototype.startNode = function (token) {
	        return {
	            index: token.start,
	            line: token.lineNumber,
	            column: token.start - token.lineStart
	        };
	    };
	    Parser.prototype.finalize = function (marker, node) {
	        if (this.config.range) {
	            node.range = [marker.index, this.lastMarker.index];
	        }
	        if (this.config.loc) {
	            node.loc = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column
	                }
	            };
	            if (this.config.source) {
	                node.loc.source = this.config.source;
	            }
	        }
	        if (this.delegate) {
	            var metadata = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                    offset: marker.index
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column,
	                    offset: this.lastMarker.index
	                }
	            };
	            this.delegate(node, metadata);
	        }
	        return node;
	    };
	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    Parser.prototype.expect = function (value) {
	        var token = this.nextToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
	    Parser.prototype.expectCommaSeparator = function () {
	        if (this.config.tolerant) {
	            var token = this.lookahead;
	            if (token.type === 7 /* Punctuator */ && token.value === ',') {
	                this.nextToken();
	            }
	            else if (token.type === 7 /* Punctuator */ && token.value === ';') {
	                this.nextToken();
	                this.tolerateUnexpectedToken(token);
	            }
	            else {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
	            }
	        }
	        else {
	            this.expect(',');
	        }
	    };
	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.
	    Parser.prototype.expectKeyword = function (keyword) {
	        var token = this.nextToken();
	        if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next token matches the specified punctuator.
	    Parser.prototype.match = function (value) {
	        return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
	    };
	    // Return true if the next token matches the specified keyword
	    Parser.prototype.matchKeyword = function (keyword) {
	        return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token matches the specified contextual keyword
	    // (where an identifier is sometimes a keyword depending on the context)
	    Parser.prototype.matchContextualKeyword = function (keyword) {
	        return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token is an assignment operator
	    Parser.prototype.matchAssign = function () {
	        if (this.lookahead.type !== 7 /* Punctuator */) {
	            return false;
	        }
	        var op = this.lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '**=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    };
	    // Cover grammar support.
	    //
	    // When an assignment expression position starts with an left parenthesis, the determination of the type
	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	    //
	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
	    // after the outermost pair is closed. They are:
	    //
	    //   1. AssignmentExpression
	    //   2. BindingElements
	    //   3. AssignmentTargets
	    //
	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
	    // binding element or assignment target.
	    //
	    // The three productions have the relationship:
	    //
	    //   BindingElements â AssignmentTargets â AssignmentExpression
	    //
	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	    //
	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	    // the CoverInitializedName check is conducted.
	    //
	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	    // pattern. The CoverInitializedName check is deferred.
	    Parser.prototype.isolateCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        if (this.context.firstCoverInitializedNameError !== null) {
	            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
	        }
	        this.context.isBindingElement = previousIsBindingElement;
	        this.context.isAssignmentTarget = previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.inheritCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
	        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.consumeSemicolon = function () {
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else if (!this.hasLineTerminator) {
	            if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.lastMarker.index = this.startMarker.index;
	            this.lastMarker.line = this.startMarker.line;
	            this.lastMarker.column = this.startMarker.column;
	        }
	    };
	    // https://tc39.github.io/ecma262/#sec-primary-expression
	    Parser.prototype.parsePrimaryExpression = function () {
	        var node = this.createNode();
	        var expr;
	        var token, raw;
	        switch (this.lookahead.type) {
	            case 3 /* Identifier */:
	                if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
	                    this.tolerateUnexpectedToken(this.lookahead);
	                }
	                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
	                break;
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	                if (this.context.strict && this.lookahead.octal) {
	                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
	                }
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 1 /* BooleanLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
	                break;
	            case 5 /* NullLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(null, raw));
	                break;
	            case 10 /* Template */:
	                expr = this.parseTemplateLiteral();
	                break;
	            case 7 /* Punctuator */:
	                switch (this.lookahead.value) {
	                    case '(':
	                        this.context.isBindingElement = false;
	                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
	                        break;
	                    case '[':
	                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
	                        break;
	                    case '{':
	                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
	                        break;
	                    case '/':
	                    case '/=':
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                        this.scanner.index = this.startMarker.index;
	                        token = this.nextRegexToken();
	                        raw = this.getTokenRaw(token);
	                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
	                        break;
	                    default:
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                }
	                break;
	            case 4 /* Keyword */:
	                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
	                    expr = this.parseIdentifierName();
	                }
	                else if (!this.context.strict && this.matchKeyword('let')) {
	                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
	                }
	                else {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    if (this.matchKeyword('function')) {
	                        expr = this.parseFunctionExpression();
	                    }
	                    else if (this.matchKeyword('this')) {
	                        this.nextToken();
	                        expr = this.finalize(node, new Node.ThisExpression());
	                    }
	                    else if (this.matchKeyword('class')) {
	                        expr = this.parseClassExpression();
	                    }
	                    else {
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                    }
	                }
	                break;
	            default:
	                expr = this.throwUnexpectedToken(this.nextToken());
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-array-initializer
	    Parser.prototype.parseSpreadElement = function () {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
	        return this.finalize(node, new Node.SpreadElement(arg));
	    };
	    Parser.prototype.parseArrayInitializer = function () {
	        var node = this.createNode();
	        var elements = [];
	        this.expect('[');
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else if (this.match('...')) {
	                var element = this.parseSpreadElement();
	                if (!this.match(']')) {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    this.expect(',');
	                }
	                elements.push(element);
	            }
	            else {
	                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayExpression(elements));
	    };
	    // https://tc39.github.io/ecma262/#sec-object-initializer
	    Parser.prototype.parsePropertyMethod = function (params) {
	        this.context.isAssignmentTarget = false;
	        this.context.isBindingElement = false;
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = params.simple;
	        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
	        if (this.context.strict && params.firstRestricted) {
	            this.tolerateUnexpectedToken(params.firstRestricted, params.message);
	        }
	        if (this.context.strict && params.stricted) {
	            this.tolerateUnexpectedToken(params.stricted, params.message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        return body;
	    };
	    Parser.prototype.parsePropertyMethodFunction = function () {
	        var isGenerator = false;
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = false;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    Parser.prototype.parsePropertyMethodAsyncFunction = function () {
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        var previousAwait = this.context.await;
	        this.context.allowYield = false;
	        this.context.await = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        this.context.await = previousAwait;
	        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
	    };
	    Parser.prototype.parseObjectPropertyKey = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        var key;
	        switch (token.type) {
	            case 8 /* StringLiteral */:
	            case 6 /* NumericLiteral */:
	                if (this.context.strict && token.octal) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
	                }
	                var raw = this.getTokenRaw(token);
	                key = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 3 /* Identifier */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 4 /* Keyword */:
	                key = this.finalize(node, new Node.Identifier(token.value));
	                break;
	            case 7 /* Punctuator */:
	                if (token.value === '[') {
	                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    this.expect(']');
	                }
	                else {
	                    key = this.throwUnexpectedToken(token);
	                }
	                break;
	            default:
	                key = this.throwUnexpectedToken(token);
	        }
	        return key;
	    };
	    Parser.prototype.isPropertyKey = function (key, value) {
	        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||
	            (key.type === syntax_1.Syntax.Literal && key.value === value);
	    };
	    Parser.prototype.parseObjectProperty = function (hasProto) {
	        var node = this.createNode();
	        var token = this.lookahead;
	        var kind;
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var shorthand = false;
	        var isAsync = false;
	        if (token.type === 3 /* Identifier */) {
	            var id = token.value;
	            this.nextToken();
	            computed = this.match('[');
	            isAsync = !this.hasLineTerminator && (id === 'async') &&
	                !this.match(':') && !this.match('(') && !this.match('*');
	            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
	        }
	        else if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
	            kind = 'get';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.context.allowYield = false;
	            value = this.parseGetterMethod();
	        }
	        else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
	            kind = 'set';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseSetterMethod();
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        else {
	            if (!key) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            kind = 'init';
	            if (this.match(':') && !isAsync) {
	                if (!computed && this.isPropertyKey(key, '__proto__')) {
	                    if (hasProto.value) {
	                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
	                    }
	                    hasProto.value = true;
	                }
	                this.nextToken();
	                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
	            }
	            else if (this.match('(')) {
	                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	                method = true;
	            }
	            else if (token.type === 3 /* Identifier */) {
	                var id = this.finalize(node, new Node.Identifier(token.value));
	                if (this.match('=')) {
	                    this.context.firstCoverInitializedNameError = this.lookahead;
	                    this.nextToken();
	                    shorthand = true;
	                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
	                }
	                else {
	                    shorthand = true;
	                    value = id;
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectInitializer = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var properties = [];
	        var hasProto = { value: false };
	        while (!this.match('}')) {
	            properties.push(this.parseObjectProperty(hasProto));
	            if (!this.match('}')) {
	                this.expectCommaSeparator();
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectExpression(properties));
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literals
	    Parser.prototype.parseTemplateHead = function () {
	        assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateElement = function () {
	        if (this.lookahead.type !== 10 /* Template */) {
	            this.throwUnexpectedToken();
	        }
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateLiteral = function () {
	        var node = this.createNode();
	        var expressions = [];
	        var quasis = [];
	        var quasi = this.parseTemplateHead();
	        quasis.push(quasi);
	        while (!quasi.tail) {
	            expressions.push(this.parseExpression());
	            quasi = this.parseTemplateElement();
	            quasis.push(quasi);
	        }
	        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
	    };
	    // https://tc39.github.io/ecma262/#sec-grouping-operator
	    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	            case syntax_1.Syntax.MemberExpression:
	            case syntax_1.Syntax.RestElement:
	            case syntax_1.Syntax.AssignmentPattern:
	                break;
	            case syntax_1.Syntax.SpreadElement:
	                expr.type = syntax_1.Syntax.RestElement;
	                this.reinterpretExpressionAsPattern(expr.argument);
	                break;
	            case syntax_1.Syntax.ArrayExpression:
	                expr.type = syntax_1.Syntax.ArrayPattern;
	                for (var i = 0; i < expr.elements.length; i++) {
	                    if (expr.elements[i] !== null) {
	                        this.reinterpretExpressionAsPattern(expr.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectExpression:
	                expr.type = syntax_1.Syntax.ObjectPattern;
	                for (var i = 0; i < expr.properties.length; i++) {
	                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
	                }
	                break;
	            case syntax_1.Syntax.AssignmentExpression:
	                expr.type = syntax_1.Syntax.AssignmentPattern;
	                delete expr.operator;
	                this.reinterpretExpressionAsPattern(expr.left);
	                break;
	            default:
	                // Allow other node type for tolerant parsing.
	                break;
	        }
	    };
	    Parser.prototype.parseGroupExpression = function () {
	        var expr;
	        this.expect('(');
	        if (this.match(')')) {
	            this.nextToken();
	            if (!this.match('=>')) {
	                this.expect('=>');
	            }
	            expr = {
	                type: ArrowParameterPlaceHolder,
	                params: [],
	                async: false
	            };
	        }
	        else {
	            var startToken = this.lookahead;
	            var params = [];
	            if (this.match('...')) {
	                expr = this.parseRestElement(params);
	                this.expect(')');
	                if (!this.match('=>')) {
	                    this.expect('=>');
	                }
	                expr = {
	                    type: ArrowParameterPlaceHolder,
	                    params: [expr],
	                    async: false
	                };
	            }
	            else {
	                var arrow = false;
	                this.context.isBindingElement = true;
	                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                if (this.match(',')) {
	                    var expressions = [];
	                    this.context.isAssignmentTarget = false;
	                    expressions.push(expr);
	                    while (this.lookahead.type !== 2 /* EOF */) {
	                        if (!this.match(',')) {
	                            break;
	                        }
	                        this.nextToken();
	                        if (this.match(')')) {
	                            this.nextToken();
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else if (this.match('...')) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            expressions.push(this.parseRestElement(params));
	                            this.expect(')');
	                            if (!this.match('=>')) {
	                                this.expect('=>');
	                            }
	                            this.context.isBindingElement = false;
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else {
	                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        if (arrow) {
	                            break;
	                        }
	                    }
	                    if (!arrow) {
	                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	                    }
	                }
	                if (!arrow) {
	                    this.expect(')');
	                    if (this.match('=>')) {
	                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: [expr],
	                                async: false
	                            };
	                        }
	                        if (!arrow) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            if (expr.type === syntax_1.Syntax.SequenceExpression) {
	                                for (var i = 0; i < expr.expressions.length; i++) {
	                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);
	                                }
	                            }
	                            else {
	                                this.reinterpretExpressionAsPattern(expr);
	                            }
	                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: parameters,
	                                async: false
	                            };
	                        }
	                    }
	                    this.context.isBindingElement = false;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
	    Parser.prototype.parseArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAssignmentExpression);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.isIdentifierName = function (token) {
	        return token.type === 3 /* Identifier */ ||
	            token.type === 4 /* Keyword */ ||
	            token.type === 1 /* BooleanLiteral */ ||
	            token.type === 5 /* NullLiteral */;
	    };
	    Parser.prototype.parseIdentifierName = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (!this.isIdentifierName(token)) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseNewExpression = function () {
	        var node = this.createNode();
	        var id = this.parseIdentifierName();
	        assert_1.assert(id.name === 'new', 'New expression must start with `new`');
	        var expr;
	        if (this.match('.')) {
	            this.nextToken();
	            if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
	                var property = this.parseIdentifierName();
	                expr = new Node.MetaProperty(id, property);
	            }
	            else {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
	            var args = this.match('(') ? this.parseArguments() : [];
	            expr = new Node.NewExpression(callee, args);
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return this.finalize(node, expr);
	    };
	    Parser.prototype.parseAsyncArgument = function () {
	        var arg = this.parseAssignmentExpression();
	        this.context.firstCoverInitializedNameError = null;
	        return arg;
	    };
	    Parser.prototype.parseAsyncArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAsyncArgument);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
	        var startToken = this.lookahead;
	        var maybeAsync = this.matchContextualKeyword('async');
	        var previousAllowIn = this.context.allowIn;
	        this.context.allowIn = true;
	        var expr;
	        if (this.matchKeyword('super') && this.context.inFunctionBody) {
	            expr = this.createNode();
	            this.nextToken();
	            expr = this.finalize(expr, new Node.Super());
	            if (!this.match('(') && !this.match('.') && !this.match('[')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        }
	        while (true) {
	            if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.match('(')) {
	                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = false;
	                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
	                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
	                if (asyncArrow && this.match('=>')) {
	                    for (var i = 0; i < args.length; ++i) {
	                        this.reinterpretExpressionAsPattern(args[i]);
	                    }
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: args,
	                        async: true
	                    };
	                }
	            }
	            else if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        this.context.allowIn = previousAllowIn;
	        return expr;
	    };
	    Parser.prototype.parseSuper = function () {
	        var node = this.createNode();
	        this.expectKeyword('super');
	        if (!this.match('[') && !this.match('.')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        return this.finalize(node, new Node.Super());
	    };
	    Parser.prototype.parseLeftHandSideExpression = function () {
	        assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
	        var node = this.startNode(this.lookahead);
	        var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :
	            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        while (true) {
	            if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-update-expressions
	    Parser.prototype.parseUpdateExpression = function () {
	        var expr;
	        var startToken = this.lookahead;
	        if (this.match('++') || this.match('--')) {
	            var node = this.startNode(startToken);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
	            }
	            if (!this.context.isAssignmentTarget) {
	                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	            }
	            var prefix = true;
	            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
	                if (this.match('++') || this.match('--')) {
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
	                    }
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    var operator = this.nextToken().value;
	                    var prefix = false;
	                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-unary-operators
	    Parser.prototype.parseAwaitExpression = function () {
	        var node = this.createNode();
	        this.nextToken();
	        var argument = this.parseUnaryExpression();
	        return this.finalize(node, new Node.AwaitExpression(argument));
	    };
	    Parser.prototype.parseUnaryExpression = function () {
	        var expr;
	        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||
	            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
	            var node = this.startNode(this.lookahead);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
	            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
	                this.tolerateError(messages_1.Messages.StrictDelete);
	            }
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else if (this.context.await && this.matchContextualKeyword('await')) {
	            expr = this.parseAwaitExpression();
	        }
	        else {
	            expr = this.parseUpdateExpression();
	        }
	        return expr;
	    };
	    Parser.prototype.parseExponentiationExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-exp-operator
	    // https://tc39.github.io/ecma262/#sec-multiplicative-operators
	    // https://tc39.github.io/ecma262/#sec-additive-operators
	    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
	    // https://tc39.github.io/ecma262/#sec-relational-operators
	    // https://tc39.github.io/ecma262/#sec-equality-operators
	    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
	    // https://tc39.github.io/ecma262/#sec-binary-logical-operators
	    Parser.prototype.binaryPrecedence = function (token) {
	        var op = token.value;
	        var precedence;
	        if (token.type === 7 /* Punctuator */) {
	            precedence = this.operatorPrecedence[op] || 0;
	        }
	        else if (token.type === 4 /* Keyword */) {
	            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;
	        }
	        else {
	            precedence = 0;
	        }
	        return precedence;
	    };
	    Parser.prototype.parseBinaryExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
	        var token = this.lookahead;
	        var prec = this.binaryPrecedence(token);
	        if (prec > 0) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var markers = [startToken, this.lookahead];
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            var stack = [left, token.value, right];
	            var precedences = [prec];
	            while (true) {
	                prec = this.binaryPrecedence(this.lookahead);
	                if (prec <= 0) {
	                    break;
	                }
	                // Reduce: make a binary expression from the three topmost entries.
	                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {
	                    right = stack.pop();
	                    var operator = stack.pop();
	                    precedences.pop();
	                    left = stack.pop();
	                    markers.pop();
	                    var node = this.startNode(markers[markers.length - 1]);
	                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
	                }
	                // Shift.
	                stack.push(this.nextToken().value);
	                precedences.push(prec);
	                markers.push(this.lookahead);
	                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
	            }
	            // Final reduce to clean-up the stack.
	            var i = stack.length - 1;
	            expr = stack[i];
	            markers.pop();
	            while (i > 1) {
	                var node = this.startNode(markers.pop());
	                var operator = stack[i - 1];
	                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
	                i -= 2;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-conditional-operator
	    Parser.prototype.parseConditionalExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
	        if (this.match('?')) {
	            this.nextToken();
	            var previousAllowIn = this.context.allowIn;
	            this.context.allowIn = true;
	            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowIn = previousAllowIn;
	            this.expect(':');
	            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-assignment-operators
	    Parser.prototype.checkPatternParam = function (options, param) {
	        switch (param.type) {
	            case syntax_1.Syntax.Identifier:
	                this.validateParam(options, param, param.name);
	                break;
	            case syntax_1.Syntax.RestElement:
	                this.checkPatternParam(options, param.argument);
	                break;
	            case syntax_1.Syntax.AssignmentPattern:
	                this.checkPatternParam(options, param.left);
	                break;
	            case syntax_1.Syntax.ArrayPattern:
	                for (var i = 0; i < param.elements.length; i++) {
	                    if (param.elements[i] !== null) {
	                        this.checkPatternParam(options, param.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectPattern:
	                for (var i = 0; i < param.properties.length; i++) {
	                    this.checkPatternParam(options, param.properties[i].value);
	                }
	                break;
	            default:
	                break;
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	    };
	    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
	        var params = [expr];
	        var options;
	        var asyncArrow = false;
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	                break;
	            case ArrowParameterPlaceHolder:
	                params = expr.params;
	                asyncArrow = expr.async;
	                break;
	            default:
	                return null;
	        }
	        options = {
	            simple: true,
	            paramSet: {}
	        };
	        for (var i = 0; i < params.length; ++i) {
	            var param = params[i];
	            if (param.type === syntax_1.Syntax.AssignmentPattern) {
	                if (param.right.type === syntax_1.Syntax.YieldExpression) {
	                    if (param.right.argument) {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                    param.right.type = syntax_1.Syntax.Identifier;
	                    param.right.name = 'yield';
	                    delete param.right.argument;
	                    delete param.right.delegate;
	                }
	            }
	            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.checkPatternParam(options, param);
	            params[i] = param;
	        }
	        if (this.context.strict || !this.context.allowYield) {
	            for (var i = 0; i < params.length; ++i) {
	                var param = params[i];
	                if (param.type === syntax_1.Syntax.YieldExpression) {
	                    this.throwUnexpectedToken(this.lookahead);
	                }
	            }
	        }
	        if (options.message === messages_1.Messages.StrictParamDupe) {
	            var token = this.context.strict ? options.stricted : options.firstRestricted;
	            this.throwUnexpectedToken(token, options.message);
	        }
	        return {
	            simple: options.simple,
	            params: params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.parseAssignmentExpression = function () {
	        var expr;
	        if (!this.context.allowYield && this.matchKeyword('yield')) {
	            expr = this.parseYieldExpression();
	        }
	        else {
	            var startToken = this.lookahead;
	            var token = startToken;
	            expr = this.parseConditionalExpression();
	            if (token.type === 3 /* Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {
	                if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
	                    var arg = this.parsePrimaryExpression();
	                    this.reinterpretExpressionAsPattern(arg);
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: [arg],
	                        async: true
	                    };
	                }
	            }
	            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
	                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                var isAsync = expr.async;
	                var list = this.reinterpretAsCoverFormalsList(expr);
	                if (list) {
	                    if (this.hasLineTerminator) {
	                        this.tolerateUnexpectedToken(this.lookahead);
	                    }
	                    this.context.firstCoverInitializedNameError = null;
	                    var previousStrict = this.context.strict;
	                    var previousAllowStrictDirective = this.context.allowStrictDirective;
	                    this.context.allowStrictDirective = list.simple;
	                    var previousAllowYield = this.context.allowYield;
	                    var previousAwait = this.context.await;
	                    this.context.allowYield = true;
	                    this.context.await = isAsync;
	                    var node = this.startNode(startToken);
	                    this.expect('=>');
	                    var body = void 0;
	                    if (this.match('{')) {
	                        var previousAllowIn = this.context.allowIn;
	                        this.context.allowIn = true;
	                        body = this.parseFunctionSourceElements();
	                        this.context.allowIn = previousAllowIn;
	                    }
	                    else {
	                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    }
	                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
	                    if (this.context.strict && list.firstRestricted) {
	                        this.throwUnexpectedToken(list.firstRestricted, list.message);
	                    }
	                    if (this.context.strict && list.stricted) {
	                        this.tolerateUnexpectedToken(list.stricted, list.message);
	                    }
	                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :
	                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
	                    this.context.strict = previousStrict;
	                    this.context.allowStrictDirective = previousAllowStrictDirective;
	                    this.context.allowYield = previousAllowYield;
	                    this.context.await = previousAwait;
	                }
	            }
	            else {
	                if (this.matchAssign()) {
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
	                        var id = expr;
	                        if (this.scanner.isRestrictedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
	                        }
	                        if (this.scanner.isStrictModeReservedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	                        }
	                    }
	                    if (!this.match('=')) {
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                    }
	                    else {
	                        this.reinterpretExpressionAsPattern(expr);
	                    }
	                    token = this.nextToken();
	                    var operator = token.value;
	                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
	                    this.context.firstCoverInitializedNameError = null;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-comma-operator
	    Parser.prototype.parseExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        if (this.match(',')) {
	            var expressions = [];
	            expressions.push(expr);
	            while (this.lookahead.type !== 2 /* EOF */) {
	                if (!this.match(',')) {
	                    break;
	                }
	                this.nextToken();
	                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	            }
	            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-block
	    Parser.prototype.parseStatementListItem = function () {
	        var statement;
	        this.context.isAssignmentTarget = true;
	        this.context.isBindingElement = true;
	        if (this.lookahead.type === 4 /* Keyword */) {
	            switch (this.lookahead.value) {
	                case 'export':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
	                    }
	                    statement = this.parseExportDeclaration();
	                    break;
	                case 'import':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
	                    }
	                    statement = this.parseImportDeclaration();
	                    break;
	                case 'const':
	                    statement = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'function':
	                    statement = this.parseFunctionDeclaration();
	                    break;
	                case 'class':
	                    statement = this.parseClassDeclaration();
	                    break;
	                case 'let':
	                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
	                    break;
	                default:
	                    statement = this.parseStatement();
	                    break;
	            }
	        }
	        else {
	            statement = this.parseStatement();
	        }
	        return statement;
	    };
	    Parser.prototype.parseBlock = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var block = [];
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            block.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.BlockStatement(block));
	    };
	    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations
	    Parser.prototype.parseLexicalBinding = function (kind, options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, kind);
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (kind === 'const') {
	            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
	                if (this.match('=')) {
	                    this.nextToken();
	                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                }
	                else {
	                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
	                }
	            }
	        }
	        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {
	            this.expect('=');
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseBindingList = function (kind, options) {
	        var list = [this.parseLexicalBinding(kind, options)];
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseLexicalBinding(kind, options));
	        }
	        return list;
	    };
	    Parser.prototype.isLexicalDeclaration = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.scanner.lex();
	        this.scanner.restoreState(state);
	        return (next.type === 3 /* Identifier */) ||
	            (next.type === 7 /* Punctuator */ && next.value === '[') ||
	            (next.type === 7 /* Punctuator */ && next.value === '{') ||
	            (next.type === 4 /* Keyword */ && next.value === 'let') ||
	            (next.type === 4 /* Keyword */ && next.value === 'yield');
	    };
	    Parser.prototype.parseLexicalDeclaration = function (options) {
	        var node = this.createNode();
	        var kind = this.nextToken().value;
	        assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
	        var declarations = this.parseBindingList(kind, options);
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
	    };
	    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
	    Parser.prototype.parseBindingRestElement = function (params, kind) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params, kind);
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseArrayPattern = function (params, kind) {
	        var node = this.createNode();
	        this.expect('[');
	        var elements = [];
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else {
	                if (this.match('...')) {
	                    elements.push(this.parseBindingRestElement(params, kind));
	                    break;
	                }
	                else {
	                    elements.push(this.parsePatternWithDefault(params, kind));
	                }
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayPattern(elements));
	    };
	    Parser.prototype.parsePropertyPattern = function (params, kind) {
	        var node = this.createNode();
	        var computed = false;
	        var shorthand = false;
	        var method = false;
	        var key;
	        var value;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            var keyToken = this.lookahead;
	            key = this.parseVariableIdentifier();
	            var init = this.finalize(node, new Node.Identifier(keyToken.value));
	            if (this.match('=')) {
	                params.push(keyToken);
	                shorthand = true;
	                this.nextToken();
	                var expr = this.parseAssignmentExpression();
	                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
	            }
	            else if (!this.match(':')) {
	                params.push(keyToken);
	                shorthand = true;
	                value = init;
	            }
	            else {
	                this.expect(':');
	                value = this.parsePatternWithDefault(params, kind);
	            }
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.expect(':');
	            value = this.parsePatternWithDefault(params, kind);
	        }
	        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectPattern = function (params, kind) {
	        var node = this.createNode();
	        var properties = [];
	        this.expect('{');
	        while (!this.match('}')) {
	            properties.push(this.parsePropertyPattern(params, kind));
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectPattern(properties));
	    };
	    Parser.prototype.parsePattern = function (params, kind) {
	        var pattern;
	        if (this.match('[')) {
	            pattern = this.parseArrayPattern(params, kind);
	        }
	        else if (this.match('{')) {
	            pattern = this.parseObjectPattern(params, kind);
	        }
	        else {
	            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
	                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
	            }
	            params.push(this.lookahead);
	            pattern = this.parseVariableIdentifier(kind);
	        }
	        return pattern;
	    };
	    Parser.prototype.parsePatternWithDefault = function (params, kind) {
	        var startToken = this.lookahead;
	        var pattern = this.parsePattern(params, kind);
	        if (this.match('=')) {
	            this.nextToken();
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = true;
	            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowYield = previousAllowYield;
	            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
	        }
	        return pattern;
	    };
	    // https://tc39.github.io/ecma262/#sec-variable-statement
	    Parser.prototype.parseVariableIdentifier = function (kind) {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (token.type === 4 /* Keyword */ && token.value === 'yield') {
	            if (this.context.strict) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else if (!this.context.allowYield) {
	                this.throwUnexpectedToken(token);
	            }
	        }
	        else if (token.type !== 3 /* Identifier */) {
	            if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else {
	                if (this.context.strict || token.value !== 'let' || kind !== 'var') {
	                    this.throwUnexpectedToken(token);
	                }
	            }
	        }
	        else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
	            this.tolerateUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseVariableDeclaration = function (options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, 'var');
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (this.match('=')) {
	            this.nextToken();
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
	            this.expect('=');
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseVariableDeclarationList = function (options) {
	        var opt = { inFor: options.inFor };
	        var list = [];
	        list.push(this.parseVariableDeclaration(opt));
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseVariableDeclaration(opt));
	        }
	        return list;
	    };
	    Parser.prototype.parseVariableStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('var');
	        var declarations = this.parseVariableDeclarationList({ inFor: false });
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
	    };
	    // https://tc39.github.io/ecma262/#sec-empty-statement
	    Parser.prototype.parseEmptyStatement = function () {
	        var node = this.createNode();
	        this.expect(';');
	        return this.finalize(node, new Node.EmptyStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-expression-statement
	    Parser.prototype.parseExpressionStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ExpressionStatement(expr));
	    };
	    // https://tc39.github.io/ecma262/#sec-if-statement
	    Parser.prototype.parseIfClause = function () {
	        if (this.context.strict && this.matchKeyword('function')) {
	            this.tolerateError(messages_1.Messages.StrictFunction);
	        }
	        return this.parseStatement();
	    };
	    Parser.prototype.parseIfStatement = function () {
	        var node = this.createNode();
	        var consequent;
	        var alternate = null;
	        this.expectKeyword('if');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            consequent = this.parseIfClause();
	            if (this.matchKeyword('else')) {
	                this.nextToken();
	                alternate = this.parseIfClause();
	            }
	        }
	        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
	    };
	    // https://tc39.github.io/ecma262/#sec-do-while-statement
	    Parser.prototype.parseDoWhileStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('do');
	        var previousInIteration = this.context.inIteration;
	        this.context.inIteration = true;
	        var body = this.parseStatement();
	        this.context.inIteration = previousInIteration;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	        }
	        else {
	            this.expect(')');
	            if (this.match(';')) {
	                this.nextToken();
	            }
	        }
	        return this.finalize(node, new Node.DoWhileStatement(body, test));
	    };
	    // https://tc39.github.io/ecma262/#sec-while-statement
	    Parser.prototype.parseWhileStatement = function () {
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.parseStatement();
	            this.context.inIteration = previousInIteration;
	        }
	        return this.finalize(node, new Node.WhileStatement(test, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-for-statement
	    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
	    Parser.prototype.parseForStatement = function () {
	        var init = null;
	        var test = null;
	        var update = null;
	        var forIn = true;
	        var left, right;
	        var node = this.createNode();
	        this.expectKeyword('for');
	        this.expect('(');
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else {
	            if (this.matchKeyword('var')) {
	                init = this.createNode();
	                this.nextToken();
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                var declarations = this.parseVariableDeclarationList({ inFor: true });
	                this.context.allowIn = previousAllowIn;
	                if (declarations.length === 1 && this.matchKeyword('in')) {
	                    var decl = declarations[0];
	                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
	                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
	                    }
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.expect(';');
	                }
	            }
	            else if (this.matchKeyword('const') || this.matchKeyword('let')) {
	                init = this.createNode();
	                var kind = this.nextToken().value;
	                if (!this.context.strict && this.lookahead.value === 'in') {
	                    init = this.finalize(init, new Node.Identifier(kind));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else {
	                    var previousAllowIn = this.context.allowIn;
	                    this.context.allowIn = false;
	                    var declarations = this.parseBindingList(kind, { inFor: true });
	                    this.context.allowIn = previousAllowIn;
	                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseExpression();
	                        init = null;
	                    }
	                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseAssignmentExpression();
	                        init = null;
	                        forIn = false;
	                    }
	                    else {
	                        this.consumeSemicolon();
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                    }
	                }
	            }
	            else {
	                var initStartToken = this.lookahead;
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                this.context.allowIn = previousAllowIn;
	                if (this.matchKeyword('in')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (this.matchContextualKeyword('of')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    if (this.match(',')) {
	                        var initSeq = [init];
	                        while (this.match(',')) {
	                            this.nextToken();
	                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
	                    }
	                    this.expect(';');
	                }
	            }
	        }
	        if (typeof left === 'undefined') {
	            if (!this.match(';')) {
	                test = this.parseExpression();
	            }
	            this.expect(';');
	            if (!this.match(')')) {
	                update = this.parseExpression();
	            }
	        }
	        var body;
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.isolateCoverGrammar(this.parseStatement);
	            this.context.inIteration = previousInIteration;
	        }
	        return (typeof left === 'undefined') ?
	            this.finalize(node, new Node.ForStatement(init, test, update, body)) :
	            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :
	                this.finalize(node, new Node.ForOfStatement(left, right, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-continue-statement
	    Parser.prototype.parseContinueStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('continue');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            label = id;
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration) {
	            this.throwError(messages_1.Messages.IllegalContinue);
	        }
	        return this.finalize(node, new Node.ContinueStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-break-statement
	    Parser.prototype.parseBreakStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('break');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	            label = id;
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration && !this.context.inSwitch) {
	            this.throwError(messages_1.Messages.IllegalBreak);
	        }
	        return this.finalize(node, new Node.BreakStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-return-statement
	    Parser.prototype.parseReturnStatement = function () {
	        if (!this.context.inFunctionBody) {
	            this.tolerateError(messages_1.Messages.IllegalReturn);
	        }
	        var node = this.createNode();
	        this.expectKeyword('return');
	        var hasArgument = !this.match(';') && !this.match('}') &&
	            !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */;
	        var argument = hasArgument ? this.parseExpression() : null;
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ReturnStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-with-statement
	    Parser.prototype.parseWithStatement = function () {
	        if (this.context.strict) {
	            this.tolerateError(messages_1.Messages.StrictModeWith);
	        }
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('with');
	        this.expect('(');
	        var object = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            body = this.parseStatement();
	        }
	        return this.finalize(node, new Node.WithStatement(object, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-switch-statement
	    Parser.prototype.parseSwitchCase = function () {
	        var node = this.createNode();
	        var test;
	        if (this.matchKeyword('default')) {
	            this.nextToken();
	            test = null;
	        }
	        else {
	            this.expectKeyword('case');
	            test = this.parseExpression();
	        }
	        this.expect(':');
	        var consequent = [];
	        while (true) {
	            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
	                break;
	            }
	            consequent.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.SwitchCase(test, consequent));
	    };
	    Parser.prototype.parseSwitchStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('switch');
	        this.expect('(');
	        var discriminant = this.parseExpression();
	        this.expect(')');
	        var previousInSwitch = this.context.inSwitch;
	        this.context.inSwitch = true;
	        var cases = [];
	        var defaultFound = false;
	        this.expect('{');
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            var clause = this.parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }
	        this.expect('}');
	        this.context.inSwitch = previousInSwitch;
	        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
	    };
	    // https://tc39.github.io/ecma262/#sec-labelled-statements
	    Parser.prototype.parseLabelledStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var statement;
	        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {
	            this.nextToken();
	            var id = expr;
	            var key = '$' + id.name;
	            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
	            }
	            this.context.labelSet[key] = true;
	            var body = void 0;
	            if (this.matchKeyword('class')) {
	                this.tolerateUnexpectedToken(this.lookahead);
	                body = this.parseClassDeclaration();
	            }
	            else if (this.matchKeyword('function')) {
	                var token = this.lookahead;
	                var declaration = this.parseFunctionDeclaration();
	                if (this.context.strict) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
	                }
	                else if (declaration.generator) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
	                }
	                body = declaration;
	            }
	            else {
	                body = this.parseStatement();
	            }
	            delete this.context.labelSet[key];
	            statement = new Node.LabeledStatement(id, body);
	        }
	        else {
	            this.consumeSemicolon();
	            statement = new Node.ExpressionStatement(expr);
	        }
	        return this.finalize(node, statement);
	    };
	    // https://tc39.github.io/ecma262/#sec-throw-statement
	    Parser.prototype.parseThrowStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('throw');
	        if (this.hasLineTerminator) {
	            this.throwError(messages_1.Messages.NewlineAfterThrow);
	        }
	        var argument = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ThrowStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-try-statement
	    Parser.prototype.parseCatchClause = function () {
	        var node = this.createNode();
	        this.expectKeyword('catch');
	        this.expect('(');
	        if (this.match(')')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        var params = [];
	        var param = this.parsePattern(params);
	        var paramMap = {};
	        for (var i = 0; i < params.length; i++) {
	            var key = '$' + params[i].value;
	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
	                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
	            }
	            paramMap[key] = true;
	        }
	        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(param.name)) {
	                this.tolerateError(messages_1.Messages.StrictCatchVariable);
	            }
	        }
	        this.expect(')');
	        var body = this.parseBlock();
	        return this.finalize(node, new Node.CatchClause(param, body));
	    };
	    Parser.prototype.parseFinallyClause = function () {
	        this.expectKeyword('finally');
	        return this.parseBlock();
	    };
	    Parser.prototype.parseTryStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('try');
	        var block = this.parseBlock();
	        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
	        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
	        if (!handler && !finalizer) {
	            this.throwError(messages_1.Messages.NoCatchOrFinally);
	        }
	        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
	    };
	    // https://tc39.github.io/ecma262/#sec-debugger-statement
	    Parser.prototype.parseDebuggerStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('debugger');
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.DebuggerStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
	    Parser.prototype.parseStatement = function () {
	        var statement;
	        switch (this.lookahead.type) {
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	            case 10 /* Template */:
	            case 9 /* RegularExpression */:
	                statement = this.parseExpressionStatement();
	                break;
	            case 7 /* Punctuator */:
	                var value = this.lookahead.value;
	                if (value === '{') {
	                    statement = this.parseBlock();
	                }
	                else if (value === '(') {
	                    statement = this.parseExpressionStatement();
	                }
	                else if (value === ';') {
	                    statement = this.parseEmptyStatement();
	                }
	                else {
	                    statement = this.parseExpressionStatement();
	                }
	                break;
	            case 3 /* Identifier */:
	                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
	                break;
	            case 4 /* Keyword */:
	                switch (this.lookahead.value) {
	                    case 'break':
	                        statement = this.parseBreakStatement();
	                        break;
	                    case 'continue':
	                        statement = this.parseContinueStatement();
	                        break;
	                    case 'debugger':
	                        statement = this.parseDebuggerStatement();
	                        break;
	                    case 'do':
	                        statement = this.parseDoWhileStatement();
	                        break;
	                    case 'for':
	                        statement = this.parseForStatement();
	                        break;
	                    case 'function':
	                        statement = this.parseFunctionDeclaration();
	                        break;
	                    case 'if':
	                        statement = this.parseIfStatement();
	                        break;
	                    case 'return':
	                        statement = this.parseReturnStatement();
	                        break;
	                    case 'switch':
	                        statement = this.parseSwitchStatement();
	                        break;
	                    case 'throw':
	                        statement = this.parseThrowStatement();
	                        break;
	                    case 'try':
	                        statement = this.parseTryStatement();
	                        break;
	                    case 'var':
	                        statement = this.parseVariableStatement();
	                        break;
	                    case 'while':
	                        statement = this.parseWhileStatement();
	                        break;
	                    case 'with':
	                        statement = this.parseWithStatement();
	                        break;
	                    default:
	                        statement = this.parseExpressionStatement();
	                        break;
	                }
	                break;
	            default:
	                statement = this.throwUnexpectedToken(this.lookahead);
	        }
	        return statement;
	    };
	    // https://tc39.github.io/ecma262/#sec-function-definitions
	    Parser.prototype.parseFunctionSourceElements = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var body = this.parseDirectivePrologues();
	        var previousLabelSet = this.context.labelSet;
	        var previousInIteration = this.context.inIteration;
	        var previousInSwitch = this.context.inSwitch;
	        var previousInFunctionBody = this.context.inFunctionBody;
	        this.context.labelSet = {};
	        this.context.inIteration = false;
	        this.context.inSwitch = false;
	        this.context.inFunctionBody = true;
	        while (this.lookahead.type !== 2 /* EOF */) {
	            if (this.match('}')) {
	                break;
	            }
	            body.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        this.context.labelSet = previousLabelSet;
	        this.context.inIteration = previousInIteration;
	        this.context.inSwitch = previousInSwitch;
	        this.context.inFunctionBody = previousInFunctionBody;
	        return this.finalize(node, new Node.BlockStatement(body));
	    };
	    Parser.prototype.validateParam = function (options, param, name) {
	        var key = '$' + name;
	        if (this.context.strict) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        else if (!options.firstRestricted) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            else if (this.scanner.isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictReservedWord;
	            }
	            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        /* istanbul ignore next */
	        if (typeof Object.defineProperty === 'function') {
	            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
	        }
	        else {
	            options.paramSet[key] = true;
	        }
	    };
	    Parser.prototype.parseRestElement = function (params) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params);
	        if (this.match('=')) {
	            this.throwError(messages_1.Messages.DefaultRestParameter);
	        }
	        if (!this.match(')')) {
	            this.throwError(messages_1.Messages.ParameterAfterRestParameter);
	        }
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseFormalParameter = function (options) {
	        var params = [];
	        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
	        for (var i = 0; i < params.length; i++) {
	            this.validateParam(options, params[i], params[i].value);
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	        options.params.push(param);
	    };
	    Parser.prototype.parseFormalParameters = function (firstRestricted) {
	        var options;
	        options = {
	            simple: true,
	            params: [],
	            firstRestricted: firstRestricted
	        };
	        this.expect('(');
	        if (!this.match(')')) {
	            options.paramSet = {};
	            while (this.lookahead.type !== 2 /* EOF */) {
	                this.parseFormalParameter(options);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expect(',');
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return {
	            simple: options.simple,
	            params: options.params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.matchAsyncFunction = function () {
	        var match = this.matchContextualKeyword('async');
	        if (match) {
	            var state = this.scanner.saveState();
	            this.scanner.scanComments();
	            var next = this.scanner.lex();
	            this.scanner.restoreState(state);
	            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Keyword */) && (next.value === 'function');
	        }
	        return match;
	    };
	    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted = null;
	        if (!identifierIsOptional || !this.match('(')) {
	            var token = this.lookahead;
	            id = this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :
	            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
	    };
	    Parser.prototype.parseFunctionExpression = function () {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted;
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        if (!this.match('(')) {
	            var token = this.lookahead;
	            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :
	            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
	    Parser.prototype.parseDirective = function () {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;
	        this.consumeSemicolon();
	        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
	    };
	    Parser.prototype.parseDirectivePrologues = function () {
	        var firstRestricted = null;
	        var body = [];
	        while (true) {
	            var token = this.lookahead;
	            if (token.type !== 8 /* StringLiteral */) {
	                break;
	            }
	            var statement = this.parseDirective();
	            body.push(statement);
	            var directive = statement.directive;
	            if (typeof directive !== 'string') {
	                break;
	            }
	            if (directive === 'use strict') {
	                this.context.strict = true;
	                if (firstRestricted) {
	                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
	                }
	                if (!this.context.allowStrictDirective) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
	                }
	            }
	            else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }
	        return body;
	    };
	    // https://tc39.github.io/ecma262/#sec-method-definitions
	    Parser.prototype.qualifiedPropertyName = function (token) {
	        switch (token.type) {
	            case 3 /* Identifier */:
	            case 8 /* StringLiteral */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 4 /* Keyword */:
	                return true;
	            case 7 /* Punctuator */:
	                return token.value === '[';
	            default:
	                break;
	        }
	        return false;
	    };
	    Parser.prototype.parseGetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = false;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length > 0) {
	            this.tolerateError(messages_1.Messages.BadGetterArity);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseSetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = false;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length !== 1) {
	            this.tolerateError(messages_1.Messages.BadSetterArity);
	        }
	        else if (formalParameters.params[0] instanceof Node.RestElement) {
	            this.tolerateError(messages_1.Messages.BadSetterRestParameter);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseGeneratorMethod = function () {
	        var node = this.createNode();
	        var isGenerator = true;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        this.context.allowYield = false;
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-generator-function-definitions
	    Parser.prototype.isStartOfExpression = function () {
	        var start = true;
	        var value = this.lookahead.value;
	        switch (this.lookahead.type) {
	            case 7 /* Punctuator */:
	                start = (value === '[') || (value === '(') || (value === '{') ||
	                    (value === '+') || (value === '-') ||
	                    (value === '!') || (value === '~') ||
	                    (value === '++') || (value === '--') ||
	                    (value === '/') || (value === '/='); // regular expression literal
	                break;
	            case 4 /* Keyword */:
	                start = (value === 'class') || (value === 'delete') ||
	                    (value === 'function') || (value === 'let') || (value === 'new') ||
	                    (value === 'super') || (value === 'this') || (value === 'typeof') ||
	                    (value === 'void') || (value === 'yield');
	                break;
	            default:
	                break;
	        }
	        return start;
	    };
	    Parser.prototype.parseYieldExpression = function () {
	        var node = this.createNode();
	        this.expectKeyword('yield');
	        var argument = null;
	        var delegate = false;
	        if (!this.hasLineTerminator) {
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = false;
	            delegate = this.match('*');
	            if (delegate) {
	                this.nextToken();
	                argument = this.parseAssignmentExpression();
	            }
	            else if (this.isStartOfExpression()) {
	                argument = this.parseAssignmentExpression();
	            }
	            this.context.allowYield = previousAllowYield;
	        }
	        return this.finalize(node, new Node.YieldExpression(argument, delegate));
	    };
	    // https://tc39.github.io/ecma262/#sec-class-definitions
	    Parser.prototype.parseClassElement = function (hasConstructor) {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var kind = '';
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var isStatic = false;
	        var isAsync = false;
	        if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            var id = key;
	            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
	                token = this.lookahead;
	                isStatic = true;
	                computed = this.match('[');
	                if (this.match('*')) {
	                    this.nextToken();
	                }
	                else {
	                    key = this.parseObjectPropertyKey();
	                }
	            }
	            if ((token.type === 3 /* Identifier */) && !this.hasLineTerminator && (token.value === 'async')) {
	                var punctuator = this.lookahead.value;
	                if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
	                    isAsync = true;
	                    token = this.lookahead;
	                    key = this.parseObjectPropertyKey();
	                    if (token.type === 3 /* Identifier */) {
	                        if (token.value === 'get' || token.value === 'set') {
	                            this.tolerateUnexpectedToken(token);
	                        }
	                        else if (token.value === 'constructor') {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
	                        }
	                    }
	                }
	            }
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */) {
	            if (token.value === 'get' && lookaheadPropertyKey) {
	                kind = 'get';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                this.context.allowYield = false;
	                value = this.parseGetterMethod();
	            }
	            else if (token.value === 'set' && lookaheadPropertyKey) {
	                kind = 'set';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                value = this.parseSetterMethod();
	            }
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        if (!kind && key && this.match('(')) {
	            kind = 'init';
	            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	            method = true;
	        }
	        if (!kind) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        if (kind === 'init') {
	            kind = 'method';
	        }
	        if (!computed) {
	            if (isStatic && this.isPropertyKey(key, 'prototype')) {
	                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
	            }
	            if (!isStatic && this.isPropertyKey(key, 'constructor')) {
	                if (kind !== 'method' || !method || (value && value.generator)) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
	                }
	                if (hasConstructor.value) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
	                }
	                else {
	                    hasConstructor.value = true;
	                }
	                kind = 'constructor';
	            }
	        }
	        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
	    };
	    Parser.prototype.parseClassElementList = function () {
	        var body = [];
	        var hasConstructor = { value: false };
	        this.expect('{');
	        while (!this.match('}')) {
	            if (this.match(';')) {
	                this.nextToken();
	            }
	            else {
	                body.push(this.parseClassElement(hasConstructor));
	            }
	        }
	        this.expect('}');
	        return body;
	    };
	    Parser.prototype.parseClassBody = function () {
	        var node = this.createNode();
	        var elementList = this.parseClassElementList();
	        return this.finalize(node, new Node.ClassBody(elementList));
	    };
	    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Identifier */)) ? null : this.parseVariableIdentifier();
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
	    };
	    Parser.prototype.parseClassExpression = function () {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (this.lookahead.type === 3 /* Identifier */) ? this.parseVariableIdentifier() : null;
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
	    };
	    // https://tc39.github.io/ecma262/#sec-scripts
	    // https://tc39.github.io/ecma262/#sec-modules
	    Parser.prototype.parseModule = function () {
	        this.context.strict = true;
	        this.context.isModule = true;
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Module(body));
	    };
	    Parser.prototype.parseScript = function () {
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Script(body));
	    };
	    // https://tc39.github.io/ecma262/#sec-imports
	    Parser.prototype.parseModuleSpecifier = function () {
	        var node = this.createNode();
	        if (this.lookahead.type !== 8 /* StringLiteral */) {
	            this.throwError(messages_1.Messages.InvalidModuleSpecifier);
	        }
	        var token = this.nextToken();
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    // import {<foo as bar>} ...;
	    Parser.prototype.parseImportSpecifier = function () {
	        var node = this.createNode();
	        var imported;
	        var local;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            imported = this.parseVariableIdentifier();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	        }
	        else {
	            imported = this.parseIdentifierName();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.ImportSpecifier(local, imported));
	    };
	    // {foo, bar as bas}
	    Parser.prototype.parseNamedImports = function () {
	        this.expect('{');
	        var specifiers = [];
	        while (!this.match('}')) {
	            specifiers.push(this.parseImportSpecifier());
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return specifiers;
	    };
	    // import <foo> ...;
	    Parser.prototype.parseImportDefaultSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportDefaultSpecifier(local));
	    };
	    // import <* as foo> ...;
	    Parser.prototype.parseImportNamespaceSpecifier = function () {
	        var node = this.createNode();
	        this.expect('*');
	        if (!this.matchContextualKeyword('as')) {
	            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
	        }
	        this.nextToken();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
	    };
	    Parser.prototype.parseImportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalImportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('import');
	        var src;
	        var specifiers = [];
	        if (this.lookahead.type === 8 /* StringLiteral */) {
	            // import 'foo';
	            src = this.parseModuleSpecifier();
	        }
	        else {
	            if (this.match('{')) {
	                // import {bar}
	                specifiers = specifiers.concat(this.parseNamedImports());
	            }
	            else if (this.match('*')) {
	                // import * as foo
	                specifiers.push(this.parseImportNamespaceSpecifier());
	            }
	            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
	                // import foo
	                specifiers.push(this.parseImportDefaultSpecifier());
	                if (this.match(',')) {
	                    this.nextToken();
	                    if (this.match('*')) {
	                        // import foo, * as foo
	                        specifiers.push(this.parseImportNamespaceSpecifier());
	                    }
	                    else if (this.match('{')) {
	                        // import foo, {bar}
	                        specifiers = specifiers.concat(this.parseNamedImports());
	                    }
	                    else {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            src = this.parseModuleSpecifier();
	        }
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
	    };
	    // https://tc39.github.io/ecma262/#sec-exports
	    Parser.prototype.parseExportSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        var exported = local;
	        if (this.matchContextualKeyword('as')) {
	            this.nextToken();
	            exported = this.parseIdentifierName();
	        }
	        return this.finalize(node, new Node.ExportSpecifier(local, exported));
	    };
	    Parser.prototype.parseExportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalExportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('export');
	        var exportDeclaration;
	        if (this.matchKeyword('default')) {
	            // export default ...
	            this.nextToken();
	            if (this.matchKeyword('function')) {
	                // export default function foo () {}
	                // export default function () {}
	                var declaration = this.parseFunctionDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchKeyword('class')) {
	                // export default class foo {}
	                var declaration = this.parseClassDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchContextualKeyword('async')) {
	                // export default async function f () {}
	                // export default async function () {}
	                // export default async x => x
	                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else {
	                if (this.matchContextualKeyword('from')) {
	                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
	                }
	                // export default {};
	                // export default [];
	                // export default (1 + 2);
	                var declaration = this.match('{') ? this.parseObjectInitializer() :
	                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
	                this.consumeSemicolon();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	        }
	        else if (this.match('*')) {
	            // export * from 'foo';
	            this.nextToken();
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            var src = this.parseModuleSpecifier();
	            this.consumeSemicolon();
	            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
	        }
	        else if (this.lookahead.type === 4 /* Keyword */) {
	            // export var f = 1;
	            var declaration = void 0;
	            switch (this.lookahead.value) {
	                case 'let':
	                case 'const':
	                    declaration = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'var':
	                case 'class':
	                case 'function':
	                    declaration = this.parseStatementListItem();
	                    break;
	                default:
	                    this.throwUnexpectedToken(this.lookahead);
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else if (this.matchAsyncFunction()) {
	            var declaration = this.parseFunctionDeclaration();
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else {
	            var specifiers = [];
	            var source = null;
	            var isExportFromIdentifier = false;
	            this.expect('{');
	            while (!this.match('}')) {
	                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
	                specifiers.push(this.parseExportSpecifier());
	                if (!this.match('}')) {
	                    this.expect(',');
	                }
	            }
	            this.expect('}');
	            if (this.matchContextualKeyword('from')) {
	                // export {default} from 'foo';
	                // export {foo} from 'foo';
	                this.nextToken();
	                source = this.parseModuleSpecifier();
	                this.consumeSemicolon();
	            }
	            else if (isExportFromIdentifier) {
	                // export {default}; // missing fromClause
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            else {
	                // export {foo};
	                this.consumeSemicolon();
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
	        }
	        return exportDeclaration;
	    };
	    return Parser;
	}());
	exports.Parser = Parser;


/***/ },
/* 9 */
/***/ function(module, exports) {

	"use strict";
	// Ensure the condition is true, otherwise throw an error.
	// This is only to have a better contract semantic, i.e. another safety net
	// to catch a logic error. The condition shall be fulfilled in normal case.
	// Do NOT use this to enforce a certain condition on any user input.
	Object.defineProperty(exports, "__esModule", { value: true });
	function assert(condition, message) {
	    /* istanbul ignore if */
	    if (!condition) {
	        throw new Error('ASSERT: ' + message);
	    }
	}
	exports.assert = assert;


/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	/* tslint:disable:max-classes-per-file */
	Object.defineProperty(exports, "__esModule", { value: true });
	var ErrorHandler = (function () {
	    function ErrorHandler() {
	        this.errors = [];
	        this.tolerant = false;
	    }
	    ErrorHandler.prototype.recordError = function (error) {
	        this.errors.push(error);
	    };
	    ErrorHandler.prototype.tolerate = function (error) {
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    ErrorHandler.prototype.constructError = function (msg, column) {
	        var error = new Error(msg);
	        try {
	            throw error;
	        }
	        catch (base) {
	            /* istanbul ignore else */
	            if (Object.create && Object.defineProperty) {
	                error = Object.create(base);
	                Object.defineProperty(error, 'column', { value: column });
	            }
	        }
	        /* istanbul ignore next */
	        return error;
	    };
	    ErrorHandler.prototype.createError = function (index, line, col, description) {
	        var msg = 'Line ' + line + ': ' + description;
	        var error = this.constructError(msg, col);
	        error.index = index;
	        error.lineNumber = line;
	        error.description = description;
	        return error;
	    };
	    ErrorHandler.prototype.throwError = function (index, line, col, description) {
	        throw this.createError(index, line, col, description);
	    };
	    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
	        var error = this.createError(index, line, col, description);
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    return ErrorHandler;
	}());
	exports.ErrorHandler = ErrorHandler;


/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// Error messages should be identical to V8.
	exports.Messages = {
	    BadGetterArity: 'Getter must not have any formal parameters',
	    BadSetterArity: 'Setter must have exactly one formal parameter',
	    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
	    ConstructorIsAsync: 'Class constructor may not be an async method',
	    ConstructorSpecialMethod: 'Class constructor may not be an accessor',
	    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
	    DefaultRestParameter: 'Unexpected token =',
	    DuplicateBinding: 'Duplicate binding %0',
	    DuplicateConstructor: 'A class may only have one constructor',
	    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
	    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
	    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
	    IllegalBreak: 'Illegal break statement',
	    IllegalContinue: 'Illegal continue statement',
	    IllegalExportDeclaration: 'Unexpected token',
	    IllegalImportDeclaration: 'Unexpected token',
	    IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
	    IllegalReturn: 'Illegal return statement',
	    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
	    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
	    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	    InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
	    InvalidModuleSpecifier: 'Unexpected token',
	    InvalidRegExp: 'Invalid regular expression',
	    LetInLexicalBinding: 'let is disallowed as a lexically bound name',
	    MissingFromClause: 'Unexpected token',
	    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	    NewlineAfterThrow: 'Illegal newline after throw',
	    NoAsAfterImportNamespace: 'Unexpected token',
	    NoCatchOrFinally: 'Missing catch or finally after try',
	    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
	    Redeclaration: '%0 \'%1\' has already been declared',
	    StaticPrototype: 'Classes may not have static property named prototype',
	    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	    StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
	    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictModeWith: 'Strict mode code may not include a with statement',
	    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	    StrictReservedWord: 'Use of future reserved word in strict mode',
	    StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
	    UnexpectedEOS: 'Unexpected end of input',
	    UnexpectedIdentifier: 'Unexpected identifier',
	    UnexpectedNumber: 'Unexpected number',
	    UnexpectedReserved: 'Unexpected reserved word',
	    UnexpectedString: 'Unexpected string',
	    UnexpectedTemplate: 'Unexpected quasi %0',
	    UnexpectedToken: 'Unexpected token %0',
	    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
	    UnknownLabel: 'Undefined label \'%0\'',
	    UnterminatedRegExp: 'Invalid regular expression: missing /'
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var character_1 = __webpack_require__(4);
	var messages_1 = __webpack_require__(11);
	function hexValue(ch) {
	    return '0123456789abcdef'.indexOf(ch.toLowerCase());
	}
	function octalValue(ch) {
	    return '01234567'.indexOf(ch);
	}
	var Scanner = (function () {
	    function Scanner(code, handler) {
	        this.source = code;
	        this.errorHandler = handler;
	        this.trackComment = false;
	        this.length = code.length;
	        this.index = 0;
	        this.lineNumber = (code.length > 0) ? 1 : 0;
	        this.lineStart = 0;
	        this.curlyStack = [];
	    }
	    Scanner.prototype.saveState = function () {
	        return {
	            index: this.index,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart
	        };
	    };
	    Scanner.prototype.restoreState = function (state) {
	        this.index = state.index;
	        this.lineNumber = state.lineNumber;
	        this.lineStart = state.lineStart;
	    };
	    Scanner.prototype.eof = function () {
	        return this.index >= this.length;
	    };
	    Scanner.prototype.throwUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    Scanner.prototype.tolerateUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    // https://tc39.github.io/ecma262/#sec-comments
	    Scanner.prototype.skipSingleLineComment = function (offset) {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - offset;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - offset
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            ++this.index;
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (this.trackComment) {
	                    loc.end = {
	                        line: this.lineNumber,
	                        column: this.index - this.lineStart - 1
	                    };
	                    var entry = {
	                        multiLine: false,
	                        slice: [start + offset, this.index - 1],
	                        range: [start, this.index - 1],
	                        loc: loc
	                    };
	                    comments.push(entry);
	                }
	                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                return comments;
	            }
	        }
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: false,
	                slice: [start + offset, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        return comments;
	    };
	    Scanner.prototype.skipMultiLineComment = function () {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - 2;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - 2
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                ++this.index;
	                this.lineStart = this.index;
	            }
	            else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (this.source.charCodeAt(this.index + 1) === 0x2F) {
	                    this.index += 2;
	                    if (this.trackComment) {
	                        loc.end = {
	                            line: this.lineNumber,
	                            column: this.index - this.lineStart
	                        };
	                        var entry = {
	                            multiLine: true,
	                            slice: [start + 2, this.index - 2],
	                            range: [start, this.index],
	                            loc: loc
	                        };
	                        comments.push(entry);
	                    }
	                    return comments;
	                }
	                ++this.index;
	            }
	            else {
	                ++this.index;
	            }
	        }
	        // Ran off the end of the file - the whole thing is a comment
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: true,
	                slice: [start + 2, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        this.tolerateUnexpectedToken();
	        return comments;
	    };
	    Scanner.prototype.scanComments = function () {
	        var comments;
	        if (this.trackComment) {
	            comments = [];
	        }
	        var start = (this.index === 0);
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isWhiteSpace(ch)) {
	                ++this.index;
	            }
	            else if (character_1.Character.isLineTerminator(ch)) {
	                ++this.index;
	                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                start = true;
	            }
	            else if (ch === 0x2F) {
	                ch = this.source.charCodeAt(this.index + 1);
	                if (ch === 0x2F) {
	                    this.index += 2;
	                    var comment = this.skipSingleLineComment(2);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                    start = true;
	                }
	                else if (ch === 0x2A) {
	                    this.index += 2;
	                    var comment = this.skipMultiLineComment();
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (start && ch === 0x2D) {
	                // U+003E is '>'
	                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    this.index += 3;
	                    var comment = this.skipSingleLineComment(3);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (ch === 0x3C) {
	                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
	                    this.index += 4; // `<!--`
	                    var comment = this.skipSingleLineComment(4);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else {
	                break;
	            }
	        }
	        return comments;
	    };
	    // https://tc39.github.io/ecma262/#sec-future-reserved-words
	    Scanner.prototype.isFutureReservedWord = function (id) {
	        switch (id) {
	            case 'enum':
	            case 'export':
	            case 'import':
	            case 'super':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isStrictModeReservedWord = function (id) {
	        switch (id) {
	            case 'implements':
	            case 'interface':
	            case 'package':
	            case 'private':
	            case 'protected':
	            case 'public':
	            case 'static':
	            case 'yield':
	            case 'let':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isRestrictedWord = function (id) {
	        return id === 'eval' || id === 'arguments';
	    };
	    // https://tc39.github.io/ecma262/#sec-keywords
	    Scanner.prototype.isKeyword = function (id) {
	        switch (id.length) {
	            case 2:
	                return (id === 'if') || (id === 'in') || (id === 'do');
	            case 3:
	                return (id === 'var') || (id === 'for') || (id === 'new') ||
	                    (id === 'try') || (id === 'let');
	            case 4:
	                return (id === 'this') || (id === 'else') || (id === 'case') ||
	                    (id === 'void') || (id === 'with') || (id === 'enum');
	            case 5:
	                return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                    (id === 'class') || (id === 'super');
	            case 6:
	                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                    (id === 'switch') || (id === 'export') || (id === 'import');
	            case 7:
	                return (id === 'default') || (id === 'finally') || (id === 'extends');
	            case 8:
	                return (id === 'function') || (id === 'continue') || (id === 'debugger');
	            case 10:
	                return (id === 'instanceof');
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.codePointAt = function (i) {
	        var cp = this.source.charCodeAt(i);
	        if (cp >= 0xD800 && cp <= 0xDBFF) {
	            var second = this.source.charCodeAt(i + 1);
	            if (second >= 0xDC00 && second <= 0xDFFF) {
	                var first = cp;
	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            }
	        }
	        return cp;
	    };
	    Scanner.prototype.scanHexEscape = function (prefix) {
	        var len = (prefix === 'u') ? 4 : 2;
	        var code = 0;
	        for (var i = 0; i < len; ++i) {
	            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                code = code * 16 + hexValue(this.source[this.index++]);
	            }
	            else {
	                return null;
	            }
	        }
	        return String.fromCharCode(code);
	    };
	    Scanner.prototype.scanUnicodeCodePointEscape = function () {
	        var ch = this.source[this.index];
	        var code = 0;
	        // At least, one hex digit is required.
	        if (ch === '}') {
	            this.throwUnexpectedToken();
	        }
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
	                break;
	            }
	            code = code * 16 + hexValue(ch);
	        }
	        if (code > 0x10FFFF || ch !== '}') {
	            this.throwUnexpectedToken();
	        }
	        return character_1.Character.fromCodePoint(code);
	    };
	    Scanner.prototype.getIdentifier = function () {
	        var start = this.index++;
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            else if (ch >= 0xD800 && ch < 0xDFFF) {
	                // Need to handle surrogate pairs.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            if (character_1.Character.isIdentifierPart(ch)) {
	                ++this.index;
	            }
	            else {
	                break;
	            }
	        }
	        return this.source.slice(start, this.index);
	    };
	    Scanner.prototype.getComplexIdentifier = function () {
	        var cp = this.codePointAt(this.index);
	        var id = character_1.Character.fromCodePoint(cp);
	        this.index += id.length;
	        // '\u' (U+005C, U+0075) denotes an escaped character.
	        var ch;
	        if (cp === 0x5C) {
	            if (this.source.charCodeAt(this.index) !== 0x75) {
	                this.throwUnexpectedToken();
	            }
	            ++this.index;
	            if (this.source[this.index] === '{') {
	                ++this.index;
	                ch = this.scanUnicodeCodePointEscape();
	            }
	            else {
	                ch = this.scanHexEscape('u');
	                if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken();
	                }
	            }
	            id = ch;
	        }
	        while (!this.eof()) {
	            cp = this.codePointAt(this.index);
	            if (!character_1.Character.isIdentifierPart(cp)) {
	                break;
	            }
	            ch = character_1.Character.fromCodePoint(cp);
	            id += ch;
	            this.index += ch.length;
	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (cp === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (this.source.charCodeAt(this.index) !== 0x75) {
	                    this.throwUnexpectedToken();
	                }
	                ++this.index;
	                if (this.source[this.index] === '{') {
	                    ++this.index;
	                    ch = this.scanUnicodeCodePointEscape();
	                }
	                else {
	                    ch = this.scanHexEscape('u');
	                    if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                        this.throwUnexpectedToken();
	                    }
	                }
	                id += ch;
	            }
	        }
	        return id;
	    };
	    Scanner.prototype.octalToDecimal = function (ch) {
	        // \0 is not octal escape sequence
	        var octal = (ch !== '0');
	        var code = octalValue(ch);
	        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	            octal = true;
	            code = code * 8 + octalValue(this.source[this.index++]);
	            // 3 digits are only allowed when string starts
	            // with 0, 1, 2, 3
	            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                code = code * 8 + octalValue(this.source[this.index++]);
	            }
	        }
	        return {
	            code: code,
	            octal: octal
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    Scanner.prototype.scanIdentifier = function () {
	        var type;
	        var start = this.index;
	        // Backslash (U+005C) starts an escaped character.
	        var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();
	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = 3 /* Identifier */;
	        }
	        else if (this.isKeyword(id)) {
	            type = 4 /* Keyword */;
	        }
	        else if (id === 'null') {
	            type = 5 /* NullLiteral */;
	        }
	        else if (id === 'true' || id === 'false') {
	            type = 1 /* BooleanLiteral */;
	        }
	        else {
	            type = 3 /* Identifier */;
	        }
	        if (type !== 3 /* Identifier */ && (start + id.length !== this.index)) {
	            var restore = this.index;
	            this.index = start;
	            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
	            this.index = restore;
	        }
	        return {
	            type: type,
	            value: id,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-punctuators
	    Scanner.prototype.scanPunctuator = function () {
	        var start = this.index;
	        // Check for most common single-character punctuators.
	        var str = this.source[this.index];
	        switch (str) {
	            case '(':
	            case '{':
	                if (str === '{') {
	                    this.curlyStack.push('{');
	                }
	                ++this.index;
	                break;
	            case '.':
	                ++this.index;
	                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
	                    // Spread operator: ...
	                    this.index += 2;
	                    str = '...';
	                }
	                break;
	            case '}':
	                ++this.index;
	                this.curlyStack.pop();
	                break;
	            case ')':
	            case ';':
	            case ',':
	            case '[':
	            case ']':
	            case ':':
	            case '?':
	            case '~':
	                ++this.index;
	                break;
	            default:
	                // 4-character punctuator.
	                str = this.source.substr(this.index, 4);
	                if (str === '>>>=') {
	                    this.index += 4;
	                }
	                else {
	                    // 3-character punctuators.
	                    str = str.substr(0, 3);
	                    if (str === '===' || str === '!==' || str === '>>>' ||
	                        str === '<<=' || str === '>>=' || str === '**=') {
	                        this.index += 3;
	                    }
	                    else {
	                        // 2-character punctuators.
	                        str = str.substr(0, 2);
	                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
	                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
	                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
	                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
	                            str === '<=' || str === '>=' || str === '=>' || str === '**') {
	                            this.index += 2;
	                        }
	                        else {
	                            // 1-character punctuators.
	                            str = this.source[this.index];
	                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
	                                ++this.index;
	                            }
	                        }
	                    }
	                }
	        }
	        if (this.index === start) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 7 /* Punctuator */,
	            value: str,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    Scanner.prototype.scanHexLiteral = function (start) {
	        var num = '';
	        while (!this.eof()) {
	            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt('0x' + num, 16),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanBinaryLiteral = function (start) {
	        var num = '';
	        var ch;
	        while (!this.eof()) {
	            ch = this.source[this.index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            // only 0b or 0B
	            this.throwUnexpectedToken();
	        }
	        if (!this.eof()) {
	            ch = this.source.charCodeAt(this.index);
	            /* istanbul ignore else */
	            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
	                this.throwUnexpectedToken();
	            }
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 2),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanOctalLiteral = function (prefix, start) {
	        var num = '';
	        var octal = false;
	        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
	            octal = true;
	            num = '0' + this.source[this.index++];
	        }
	        else {
	            ++this.index;
	        }
	        while (!this.eof()) {
	            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (!octal && num.length === 0) {
	            // only 0o or 0O
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 8),
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.isImplicitOctalLiteral = function () {
	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (var i = this.index + 1; i < this.length; ++i) {
	            var ch = this.source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                return true;
	            }
	        }
	        return true;
	    };
	    Scanner.prototype.scanNumericLiteral = function () {
	        var start = this.index;
	        var ch = this.source[start];
	        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
	        var num = '';
	        if (ch !== '.') {
	            num = this.source[this.index++];
	            ch = this.source[this.index];
	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (num === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++this.index;
	                    return this.scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++this.index;
	                    return this.scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O') {
	                    return this.scanOctalLiteral(ch, start);
	                }
	                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                    if (this.isImplicitOctalLiteral()) {
	                        return this.scanOctalLiteral(ch, start);
	                    }
	                }
	            }
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === '.') {
	            num += this.source[this.index++];
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === 'e' || ch === 'E') {
	            num += this.source[this.index++];
	            ch = this.source[this.index];
	            if (ch === '+' || ch === '-') {
	                num += this.source[this.index++];
	            }
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                    num += this.source[this.index++];
	                }
	            }
	            else {
	                this.throwUnexpectedToken();
	            }
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseFloat(num),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-string-literals
	    Scanner.prototype.scanStringLiteral = function () {
	        var start = this.index;
	        var quote = this.source[start];
	        assert_1.assert((quote === '\'' || quote === '"'), 'String literal must starts with a quote');
	        ++this.index;
	        var octal = false;
	        var str = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === quote) {
	                quote = '';
	                break;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                str += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var unescaped_1 = this.scanHexEscape(ch);
	                                if (unescaped_1 === null) {
	                                    this.throwUnexpectedToken();
	                                }
	                                str += unescaped_1;
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            str += unescaped;
	                            break;
	                        case 'n':
	                            str += '\n';
	                            break;
	                        case 'r':
	                            str += '\r';
	                            break;
	                        case 't':
	                            str += '\t';
	                            break;
	                        case 'b':
	                            str += '\b';
	                            break;
	                        case 'f':
	                            str += '\f';
	                            break;
	                        case 'v':
	                            str += '\x0B';
	                            break;
	                        case '8':
	                        case '9':
	                            str += ch;
	                            this.tolerateUnexpectedToken();
	                            break;
	                        default:
	                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                var octToDec = this.octalToDecimal(ch);
	                                octal = octToDec.octal || octal;
	                                str += String.fromCharCode(octToDec.code);
	                            }
	                            else {
	                                str += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            }
	            else {
	                str += ch;
	            }
	        }
	        if (quote !== '') {
	            this.index = start;
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 8 /* StringLiteral */,
	            value: str,
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
	    Scanner.prototype.scanTemplate = function () {
	        var cooked = '';
	        var terminated = false;
	        var start = this.index;
	        var head = (this.source[start] === '`');
	        var tail = false;
	        var rawOffset = 2;
	        ++this.index;
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === '`') {
	                rawOffset = 1;
	                tail = true;
	                terminated = true;
	                break;
	            }
	            else if (ch === '$') {
	                if (this.source[this.index] === '{') {
	                    this.curlyStack.push('${');
	                    ++this.index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'n':
	                            cooked += '\n';
	                            break;
	                        case 'r':
	                            cooked += '\r';
	                            break;
	                        case 't':
	                            cooked += '\t';
	                            break;
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                cooked += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var restore = this.index;
	                                var unescaped_2 = this.scanHexEscape(ch);
	                                if (unescaped_2 !== null) {
	                                    cooked += unescaped_2;
	                                }
	                                else {
	                                    this.index = restore;
	                                    cooked += ch;
	                                }
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            cooked += unescaped;
	                            break;
	                        case 'b':
	                            cooked += '\b';
	                            break;
	                        case 'f':
	                            cooked += '\f';
	                            break;
	                        case 'v':
	                            cooked += '\v';
	                            break;
	                        default:
	                            if (ch === '0') {
	                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                                    // Illegal: \01 \02 and so on
	                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                                }
	                                cooked += '\0';
	                            }
	                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                // Illegal: \1 \2
	                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                            }
	                            else {
	                                cooked += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.lineNumber;
	                if (ch === '\r' && this.source[this.index] === '\n') {
	                    ++this.index;
	                }
	                this.lineStart = this.index;
	                cooked += '\n';
	            }
	            else {
	                cooked += ch;
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken();
	        }
	        if (!head) {
	            this.curlyStack.pop();
	        }
	        return {
	            type: 10 /* Template */,
	            value: this.source.slice(start + 1, this.index - rawOffset),
	            cooked: cooked,
	            head: head,
	            tail: tail,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	    Scanner.prototype.testRegExp = function (pattern, flags) {
	        // The BMP character to use as a replacement for astral symbols when
	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
	        // approximation.
	        // Note: replacing with '\uFFFF' enables false positives in unlikely
	        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
	        // pattern that would not be detected by this substitution.
	        var astralSubstitute = '\uFFFF';
	        var tmp = pattern;
	        var self = this;
	        if (flags.indexOf('u') >= 0) {
	            tmp = tmp
	                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
	                var codePoint = parseInt($1 || $2, 16);
	                if (codePoint > 0x10FFFF) {
	                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	                }
	                if (codePoint <= 0xFFFF) {
	                    return String.fromCharCode(codePoint);
	                }
	                return astralSubstitute;
	            })
	                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
	        }
	        // First, detect invalid regular expressions.
	        try {
	            RegExp(tmp);
	        }
	        catch (e) {
	            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	        }
	        // Return a regular expression object for this pattern-flag pair, or
	        // `null` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        }
	        catch (exception) {
	            /* istanbul ignore next */
	            return null;
	        }
	    };
	    Scanner.prototype.scanRegExpBody = function () {
	        var ch = this.source[this.index];
	        assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
	        var str = this.source[this.index++];
	        var classMarker = false;
	        var terminated = false;
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = this.source[this.index++];
	                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	            }
	            else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            }
	            else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                }
	                else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	        }
	        // Exclude leading and trailing slash.
	        return str.substr(1, str.length - 2);
	    };
	    Scanner.prototype.scanRegExpFlags = function () {
	        var str = '';
	        var flags = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index];
	            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }
	            ++this.index;
	            if (ch === '\\' && !this.eof()) {
	                ch = this.source[this.index];
	                if (ch === 'u') {
	                    ++this.index;
	                    var restore = this.index;
	                    var char = this.scanHexEscape('u');
	                    if (char !== null) {
	                        flags += char;
	                        for (str += '\\u'; restore < this.index; ++restore) {
	                            str += this.source[restore];
	                        }
	                    }
	                    else {
	                        this.index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    this.tolerateUnexpectedToken();
	                }
	                else {
	                    str += '\\';
	                    this.tolerateUnexpectedToken();
	                }
	            }
	            else {
	                flags += ch;
	                str += ch;
	            }
	        }
	        return flags;
	    };
	    Scanner.prototype.scanRegExp = function () {
	        var start = this.index;
	        var pattern = this.scanRegExpBody();
	        var flags = this.scanRegExpFlags();
	        var value = this.testRegExp(pattern, flags);
	        return {
	            type: 9 /* RegularExpression */,
	            value: '',
	            pattern: pattern,
	            flags: flags,
	            regex: value,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.lex = function () {
	        if (this.eof()) {
	            return {
	                type: 2 /* EOF */,
	                value: '',
	                lineNumber: this.lineNumber,
	                lineStart: this.lineStart,
	                start: this.index,
	                end: this.index
	            };
	        }
	        var cp = this.source.charCodeAt(this.index);
	        if (character_1.Character.isIdentifierStart(cp)) {
	            return this.scanIdentifier();
	        }
	        // Very common: ( and ) and ;
	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
	            return this.scanPunctuator();
	        }
	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (cp === 0x27 || cp === 0x22) {
	            return this.scanStringLiteral();
	        }
	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (cp === 0x2E) {
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
	                return this.scanNumericLiteral();
	            }
	            return this.scanPunctuator();
	        }
	        if (character_1.Character.isDecimalDigit(cp)) {
	            return this.scanNumericLiteral();
	        }
	        // Template literals start with ` (U+0060) for template head
	        // or } (U+007D) for template middle or template tail.
	        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${')) {
	            return this.scanTemplate();
	        }
	        // Possible identifier start in a surrogate pair.
	        if (cp >= 0xD800 && cp < 0xDFFF) {
	            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
	                return this.scanIdentifier();
	            }
	        }
	        return this.scanPunctuator();
	    };
	    return Scanner;
	}());
	exports.Scanner = Scanner;


/***/ },
/* 13 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TokenName = {};
	exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
	exports.TokenName[2 /* EOF */] = '<end>';
	exports.TokenName[3 /* Identifier */] = 'Identifier';
	exports.TokenName[4 /* Keyword */] = 'Keyword';
	exports.TokenName[5 /* NullLiteral */] = 'Null';
	exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
	exports.TokenName[7 /* Punctuator */] = 'Punctuator';
	exports.TokenName[8 /* StringLiteral */] = 'String';
	exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
	exports.TokenName[10 /* Template */] = 'Template';


/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	// Generated by generate-xhtml-entities.js. DO NOT MODIFY!
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.XHTMLEntities = {
	    quot: '\u0022',
	    amp: '\u0026',
	    apos: '\u0027',
	    gt: '\u003E',
	    nbsp: '\u00A0',
	    iexcl: '\u00A1',
	    cent: '\u00A2',
	    pound: '\u00A3',
	    curren: '\u00A4',
	    yen: '\u00A5',
	    brvbar: '\u00A6',
	    sect: '\u00A7',
	    uml: '\u00A8',
	    copy: '\u00A9',
	    ordf: '\u00AA',
	    laquo: '\u00AB',
	    not: '\u00AC',
	    shy: '\u00AD',
	    reg: '\u00AE',
	    macr: '\u00AF',
	    deg: '\u00B0',
	    plusmn: '\u00B1',
	    sup2: '\u00B2',
	    sup3: '\u00B3',
	    acute: '\u00B4',
	    micro: '\u00B5',
	    para: '\u00B6',
	    middot: '\u00B7',
	    cedil: '\u00B8',
	    sup1: '\u00B9',
	    ordm: '\u00BA',
	    raquo: '\u00BB',
	    frac14: '\u00BC',
	    frac12: '\u00BD',
	    frac34: '\u00BE',
	    iquest: '\u00BF',
	    Agrave: '\u00C0',
	    Aacute: '\u00C1',
	    Acirc: '\u00C2',
	    Atilde: '\u00C3',
	    Auml: '\u00C4',
	    Aring: '\u00C5',
	    AElig: '\u00C6',
	    Ccedil: '\u00C7',
	    Egrave: '\u00C8',
	    Eacute: '\u00C9',
	    Ecirc: '\u00CA',
	    Euml: '\u00CB',
	    Igrave: '\u00CC',
	    Iacute: '\u00CD',
	    Icirc: '\u00CE',
	    Iuml: '\u00CF',
	    ETH: '\u00D0',
	    Ntilde: '\u00D1',
	    Ograve: '\u00D2',
	    Oacute: '\u00D3',
	    Ocirc: '\u00D4',
	    Otilde: '\u00D5',
	    Ouml: '\u00D6',
	    times: '\u00D7',
	    Oslash: '\u00D8',
	    Ugrave: '\u00D9',
	    Uacute: '\u00DA',
	    Ucirc: '\u00DB',
	    Uuml: '\u00DC',
	    Yacute: '\u00DD',
	    THORN: '\u00DE',
	    szlig: '\u00DF',
	    agrave: '\u00E0',
	    aacute: '\u00E1',
	    acirc: '\u00E2',
	    atilde: '\u00E3',
	    auml: '\u00E4',
	    aring: '\u00E5',
	    aelig: '\u00E6',
	    ccedil: '\u00E7',
	    egrave: '\u00E8',
	    eacute: '\u00E9',
	    ecirc: '\u00EA',
	    euml: '\u00EB',
	    igrave: '\u00EC',
	    iacute: '\u00ED',
	    icirc: '\u00EE',
	    iuml: '\u00EF',
	    eth: '\u00F0',
	    ntilde: '\u00F1',
	    ograve: '\u00F2',
	    oacute: '\u00F3',
	    ocirc: '\u00F4',
	    otilde: '\u00F5',
	    ouml: '\u00F6',
	    divide: '\u00F7',
	    oslash: '\u00F8',
	    ugrave: '\u00F9',
	    uacute: '\u00FA',
	    ucirc: '\u00FB',
	    uuml: '\u00FC',
	    yacute: '\u00FD',
	    thorn: '\u00FE',
	    yuml: '\u00FF',
	    OElig: '\u0152',
	    oelig: '\u0153',
	    Scaron: '\u0160',
	    scaron: '\u0161',
	    Yuml: '\u0178',
	    fnof: '\u0192',
	    circ: '\u02C6',
	    tilde: '\u02DC',
	    Alpha: '\u0391',
	    Beta: '\u0392',
	    Gamma: '\u0393',
	    Delta: '\u0394',
	    Epsilon: '\u0395',
	    Zeta: '\u0396',
	    Eta: '\u0397',
	    Theta: '\u0398',
	    Iota: '\u0399',
	    Kappa: '\u039A',
	    Lambda: '\u039B',
	    Mu: '\u039C',
	    Nu: '\u039D',
	    Xi: '\u039E',
	    Omicron: '\u039F',
	    Pi: '\u03A0',
	    Rho: '\u03A1',
	    Sigma: '\u03A3',
	    Tau: '\u03A4',
	    Upsilon: '\u03A5',
	    Phi: '\u03A6',
	    Chi: '\u03A7',
	    Psi: '\u03A8',
	    Omega: '\u03A9',
	    alpha: '\u03B1',
	    beta: '\u03B2',
	    gamma: '\u03B3',
	    delta: '\u03B4',
	    epsilon: '\u03B5',
	    zeta: '\u03B6',
	    eta: '\u03B7',
	    theta: '\u03B8',
	    iota: '\u03B9',
	    kappa: '\u03BA',
	    lambda: '\u03BB',
	    mu: '\u03BC',
	    nu: '\u03BD',
	    xi: '\u03BE',
	    omicron: '\u03BF',
	    pi: '\u03C0',
	    rho: '\u03C1',
	    sigmaf: '\u03C2',
	    sigma: '\u03C3',
	    tau: '\u03C4',
	    upsilon: '\u03C5',
	    phi: '\u03C6',
	    chi: '\u03C7',
	    psi: '\u03C8',
	    omega: '\u03C9',
	    thetasym: '\u03D1',
	    upsih: '\u03D2',
	    piv: '\u03D6',
	    ensp: '\u2002',
	    emsp: '\u2003',
	    thinsp: '\u2009',
	    zwnj: '\u200C',
	    zwj: '\u200D',
	    lrm: '\u200E',
	    rlm: '\u200F',
	    ndash: '\u2013',
	    mdash: '\u2014',
	    lsquo: '\u2018',
	    rsquo: '\u2019',
	    sbquo: '\u201A',
	    ldquo: '\u201C',
	    rdquo: '\u201D',
	    bdquo: '\u201E',
	    dagger: '\u2020',
	    Dagger: '\u2021',
	    bull: '\u2022',
	    hellip: '\u2026',
	    permil: '\u2030',
	    prime: '\u2032',
	    Prime: '\u2033',
	    lsaquo: '\u2039',
	    rsaquo: '\u203A',
	    oline: '\u203E',
	    frasl: '\u2044',
	    euro: '\u20AC',
	    image: '\u2111',
	    weierp: '\u2118',
	    real: '\u211C',
	    trade: '\u2122',
	    alefsym: '\u2135',
	    larr: '\u2190',
	    uarr: '\u2191',
	    rarr: '\u2192',
	    darr: '\u2193',
	    harr: '\u2194',
	    crarr: '\u21B5',
	    lArr: '\u21D0',
	    uArr: '\u21D1',
	    rArr: '\u21D2',
	    dArr: '\u21D3',
	    hArr: '\u21D4',
	    forall: '\u2200',
	    part: '\u2202',
	    exist: '\u2203',
	    empty: '\u2205',
	    nabla: '\u2207',
	    isin: '\u2208',
	    notin: '\u2209',
	    ni: '\u220B',
	    prod: '\u220F',
	    sum: '\u2211',
	    minus: '\u2212',
	    lowast: '\u2217',
	    radic: '\u221A',
	    prop: '\u221D',
	    infin: '\u221E',
	    ang: '\u2220',
	    and: '\u2227',
	    or: '\u2228',
	    cap: '\u2229',
	    cup: '\u222A',
	    int: '\u222B',
	    there4: '\u2234',
	    sim: '\u223C',
	    cong: '\u2245',
	    asymp: '\u2248',
	    ne: '\u2260',
	    equiv: '\u2261',
	    le: '\u2264',
	    ge: '\u2265',
	    sub: '\u2282',
	    sup: '\u2283',
	    nsub: '\u2284',
	    sube: '\u2286',
	    supe: '\u2287',
	    oplus: '\u2295',
	    otimes: '\u2297',
	    perp: '\u22A5',
	    sdot: '\u22C5',
	    lceil: '\u2308',
	    rceil: '\u2309',
	    lfloor: '\u230A',
	    rfloor: '\u230B',
	    loz: '\u25CA',
	    spades: '\u2660',
	    clubs: '\u2663',
	    hearts: '\u2665',
	    diams: '\u2666',
	    lang: '\u27E8',
	    rang: '\u27E9'
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var error_handler_1 = __webpack_require__(10);
	var scanner_1 = __webpack_require__(12);
	var token_1 = __webpack_require__(13);
	var Reader = (function () {
	    function Reader() {
	        this.values = [];
	        this.curly = this.paren = -1;
	    }
	    // A function following one of those tokens is an expression.
	    Reader.prototype.beforeFunctionExpression = function (t) {
	        return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	            'return', 'case', 'delete', 'throw', 'void',
	            // assignment operators
	            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',
	            '&=', '|=', '^=', ',',
	            // binary/unary operators
	            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
	    };
	    // Determine if forward slash (/) is an operator or part of a regular expression
	    // https://github.com/mozilla/sweet.js/wiki/design
	    Reader.prototype.isRegexStart = function () {
	        var previous = this.values[this.values.length - 1];
	        var regex = (previous !== null);
	        switch (previous) {
	            case 'this':
	            case ']':
	                regex = false;
	                break;
	            case ')':
	                var keyword = this.values[this.paren - 1];
	                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');
	                break;
	            case '}':
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                regex = false;
	                if (this.values[this.curly - 3] === 'function') {
	                    // Anonymous function, e.g. function(){} /42
	                    var check = this.values[this.curly - 4];
	                    regex = check ? !this.beforeFunctionExpression(check) : false;
	                }
	                else if (this.values[this.curly - 4] === 'function') {
	                    // Named function, e.g. function f(){} /42/
	                    var check = this.values[this.curly - 5];
	                    regex = check ? !this.beforeFunctionExpression(check) : true;
	                }
	                break;
	            default:
	                break;
	        }
	        return regex;
	    };
	    Reader.prototype.push = function (token) {
	        if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
	            if (token.value === '{') {
	                this.curly = this.values.length;
	            }
	            else if (token.value === '(') {
	                this.paren = this.values.length;
	            }
	            this.values.push(token.value);
	        }
	        else {
	            this.values.push(null);
	        }
	    };
	    return Reader;
	}());
	var Tokenizer = (function () {
	    function Tokenizer(code, config) {
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;
	        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;
	        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;
	        this.buffer = [];
	        this.reader = new Reader();
	    }
	    Tokenizer.prototype.errors = function () {
	        return this.errorHandler.errors;
	    };
	    Tokenizer.prototype.getNextToken = function () {
	        if (this.buffer.length === 0) {
	            var comments = this.scanner.scanComments();
	            if (this.scanner.trackComment) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
	                    var comment = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: value
	                    };
	                    if (this.trackRange) {
	                        comment.range = e.range;
	                    }
	                    if (this.trackLoc) {
	                        comment.loc = e.loc;
	                    }
	                    this.buffer.push(comment);
	                }
	            }
	            if (!this.scanner.eof()) {
	                var loc = void 0;
	                if (this.trackLoc) {
	                    loc = {
	                        start: {
	                            line: this.scanner.lineNumber,
	                            column: this.scanner.index - this.scanner.lineStart
	                        },
	                        end: {}
	                    };
	                }
	                var startRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();
	                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
	                this.reader.push(token);
	                var entry = {
	                    type: token_1.TokenName[token.type],
	                    value: this.scanner.source.slice(token.start, token.end)
	                };
	                if (this.trackRange) {
	                    entry.range = [token.start, token.end];
	                }
	                if (this.trackLoc) {
	                    loc.end = {
	                        line: this.scanner.lineNumber,
	                        column: this.scanner.index - this.scanner.lineStart
	                    };
	                    entry.loc = loc;
	                }
	                if (token.type === 9 /* RegularExpression */) {
	                    var pattern = token.pattern;
	                    var flags = token.flags;
	                    entry.regex = { pattern: pattern, flags: flags };
	                }
	                this.buffer.push(entry);
	            }
	        }
	        return this.buffer.shift();
	    };
	    return Tokenizer;
	}());
	exports.Tokenizer = Tokenizer;


/***/ }
/******/ ])
});
;
},{}],61:[function(require,module,exports){
'use strict'
var readonlyProxies = new WeakMap
var currentSandbox = undefined
var GLOBAL = new Function('return this')()
var unscopablesSymbol = Symbol.unscopables
var FunctionConstructor = 0..constructor.constructor

function compileExpression(src) {
	if (typeof src !== 'string') {
		throw new TypeError('Expected argument to be a string.')
	}
	
	new FunctionConstructor('"use strict"; return ' + src) // Tests for syntax errors without running the code
	var code = new FunctionConstructor('sandbox', 'with (sandbox) {return (function () {"use strict"; return ' + src + '}).call(this)}')
	
	return function (sandbox) {
		if (!isObject(sandbox)) {
			throw new TypeError('Expected argument to be an object or function.')
		}
		if (currentSandbox) {
			throw new Error('You cannot run sandboxed code inside an already-running sandbox.')
		}
		var sandboxProxy = getProxy(sandbox)
		var result, error
		
		currentSandbox = sandbox
		try {
			result = code.call(sandboxProxy, sandboxProxy)
			currentSandbox = undefined
		} catch (ex) {
			currentSandbox = undefined
			if (ex instanceof Error) {
				error = new ex.constructor('' + ex.message)
				error.stack = '' + ex.stack
				throw error
			}
			throw new Error(String(ex))
		}
		if (isObject(result)) {
			throw TypeError('Sandboxes are only allowed to return primitive values.')
		}
		return result
	}
}
module.exports = compileExpression

var traps = {
	get: function (target, key, receiver) {
		if (currentSandbox) {
			if (key === unscopablesSymbol && target === currentSandbox) {
				return undefined
			}
			if (!notPrivate(key)) {
				return undefined
			}
			return getProxyOrPrimitive(Reflect.get(target, key, receiver))
		}
		return Reflect.get(target, key, receiver)
	},
	set: function (target, key, value, receiver) {
		if (currentSandbox) {
			throw new TypeError('You cannot set properties on a sandboxed object.')
		}
		return Reflect.set(target, key, value, receiver)
	},
	has: function (target, key) {
		if (currentSandbox) {
			if (target === currentSandbox) {
				return true
			}
			if (!notPrivate(key)) {
				return false
			}
			return getProxyOrPrimitive(Reflect.has(target, key))
		}
		return Reflect.has(target, key)
	},
	getPrototypeOf: function (target) {
		if (currentSandbox) {
			return getProxyOrPrimitive(Reflect.getPrototypeOf(target))
		}
		return Reflect.getPrototypeOf(target)
	},
	setPrototypeOf: function (target, proto) {
		if (currentSandbox) {
			throw new TypeError('You cannot set the prototype of a sandboxed object.')
		}
		return Reflect.setPrototypeOf(target, proto)
	},
	isExtensible: function (target) {
		if (currentSandbox) {
			return getProxyOrPrimitive(Reflect.isExtensible(target))
		}
		return Reflect.isExtensible(target)
	},
	preventExtensions: function (target) {
		if (currentSandbox) {
			throw new TypeError('You cannot change the extensibility of a sandboxed object.')
		}
		return Reflect.preventExtensions(target)
	},
	getOwnPropertyDescriptor: function (target, key) {
		if (currentSandbox) {
			if (key === Symbol.unscopables && target === currentSandbox) {
				return undefined
			}
			if (!notPrivate(key)) {
				return undefined
			}
			return getProxyOrPrimitive(Reflect.getOwnPropertyDescriptor(target, key))
		}
		return Reflect.getOwnPropertyDescriptor(target, key)
	},
	defineProperty: function (target, key, descriptor) {
		if (currentSandbox) {
			throw new TypeError('You cannot define properties on a sandboxed object.')
		}
		return Reflect.defineProperty(target, key, descriptor)
	},
	deleteProperty: function (target, key) {
		if (currentSandbox) {
			throw new TypeError('You cannot delete properties on a sandboxed object.')
		}
		return Reflect.deleteProperty(target, key)
	},
	ownKeys: function (target) {
		if (currentSandbox) {
			return getProxyOrPrimitive(Reflect.ownKeys(target).filter(notPrivate))
		}
		return Reflect.ownKeys(target)
	},
	apply: function (target, thisArg, argumentsList) {
		if (currentSandbox) {
			if (target === FunctionConstructor || target === FunctionConstructorProxy) {
				throw new TypeError('You cannot use the Function constructor in a sandboxed context.')
			}
			return getProxyOrPrimitive(Reflect.apply(target, thisArg, argumentsList))
		}
		return Reflect.apply(target, thisArg, argumentsList)
	},
	construct: function (target, argumentsList, newTarget) {
		if (currentSandbox) {
			if (target === FunctionConstructor || target === FunctionConstructorProxy) {
				throw new TypeError('You cannot use the Function constructor in a sandboxed context.')
			}
			return getProxyOrPrimitive(Reflect.construct(target, argumentsList, newTarget))
		}
		return Reflect.construct(target, argumentsList, newTarget)
	}
}

function isObject(value) {
	return typeof value === 'function' || (value !== null && typeof value === 'object')
}

function getProxyOrPrimitive(value) {
	if (isObject(value)) {
		return safeObjects.indexOf(value) >= 0 ? value : getProxy(value)
	}
	return value
}

function getProxy(object, hideOriginal) {
	if (object === GLOBAL) {
		throw new TypeError('The global object is forbidden from entering a sandboxed context.')
	}
	if (object === evalFunction) {
		throw new TypeError('The eval function is forbidden from entering a sandboxed context.')
	}
	var proxy = readonlyProxies.get(object)
	if (typeof proxy === 'undefined') {
		proxy = new Proxy(object, traps)
		readonlyProxies.set(hideOriginal ? proxy : object, proxy)
	}
	return proxy
}

function notPrivate(key) {
	return typeof key !== 'string' || key[0] !== '_'
}

// Freeze and proxy anything that is accessible through JavaScript syntax alone
// This should include any value that you can get from JavaScript syntax itself.
// For example:
//     "my string".foobar
//     try {throw 1} catch (err) {err.foobar}
// Symbols are included here because they are not protected by our proxying
// because they are primitives.
var safeObjects = require('./lib/make-safe')([
	Boolean.prototype,
	Number.prototype,
	String.prototype,
	Symbol.prototype,
	Function.prototype,
	Object.prototype,
	Array.prototype,
	RegExp.prototype,
	Error.prototype,
	EvalError.prototype,
	RangeError.prototype,
	ReferenceError.prototype,
	SyntaxError.prototype,
	TypeError.prototype,
	URIError.prototype,
	Promise.prototype,
	Object.getPrototypeOf(function*(){}),
	Object.getPrototypeOf(function*(){}())
], isObject, getProxy, GLOBAL)

var evalFunction = GLOBAL.eval
var FunctionConstructorProxy = 0..constructor.constructor

module.exports.equals = function (a, b) {
	return a === b || (readonlyProxies.get(a) || a) === (readonlyProxies.get(b) || b)
}



},{"./lib/make-safe":62}],62:[function(require,module,exports){
'use strict'

module.exports = function (unsafeObjects, isObject, getProxy, GLOBAL) {
	var proxies = []
	var safeObjects = []
	var returnsSafeValues = [
		Function.prototype[Symbol.hasInstance]
	]
	var globalKeys = Object.getOwnPropertyNames(GLOBAL).filter(function (key) {return key !== 'root' && key !== 'GLOBAL' && key !== 'global' && key !== 'window' && key !== 'self'})
	var globalValues = globalKeys.map(function (key) {return this[key]}, GLOBAL)
	
	while (unsafeObjects.length) {
		makeSafe(unsafeObjects.shift())
	}
	
	function makeSafe(object) {
		if (isSafe(object)) {
			return
		}
		
		var reachable = Object.getOwnPropertyNames(object)
			.concat(Object.getOwnPropertySymbols(object))
		
		if (object === Function.prototype) {
			reachable = reachable.filter(ignoredKeys)
		}
		
		reachable.forEach(replaceWithProxy, object)
		Object.freeze(object)
		safeObjects.push(object)
		
		unsafeObjects.push(Object.getPrototypeOf(object))
	}
	
	function ignoredKeys(key) {
		return key !== 'caller' && key !== 'arguments'
	}
	
	function isSafe(value) {
		return !isObject(value) || proxies.indexOf(value) >= 0 || safeObjects.indexOf(value) >= 0
	}
	
	function replaceWithProxy(key) {
		var d = Object.getOwnPropertyDescriptor(this, key)
		if (!('value' in d)) {
			if (key === '__proto__' && isSafe(this[key])) {
				return
			}
			if (!d.configurable) {
				d.get && unsafeObjects.push(d.get)
				d.set && unsafeObjects.push(d.set)
				// This getter/setter could potentially return a non-proxied object
				console.warn('Potentially vulnerable getter/setter at %s in %s', key, this)
				return
			}
			var getter = d.get && getProxy(d.get, true)
			var setter = d.set && getProxy(d.set, true)
			Object.defineProperty(this, key, {
				get: getter,
				set: setter,
				enumerable: d.enumerable,
				configurable: false
			})
			getter && proxies.push(getter)
			setter && proxies.push(setter)
			return
		}
		
		var value = this[key]
		if (isSafe(value)) {
			return
		}
		
		if (d.writable) {
			var proxy = getProxy(value, true)
			proxies.push(this[key] = proxy)
			replaceInGlobal(value, proxy)
			return
		}
		
		if (d.configurable) {
			var proxy = getProxy(value, true)
			Object.defineProperty(this, key, {
				value: proxy,
				writable: false,
				enumerable: d.enumerable,
				configurable: false
			})
			replaceInGlobal(value, proxy)
			proxies.push(proxy)
			return
		}
		
		unsafeObjects.push(value)
		if (typeof value === 'function' && returnsSafeValues.indexOf(value) === -1) {
			// This function could potentially return a non-proxied object
			console.warn('Potentially vulnerable function at %s in %s', key, this)
		}
	}
	
	function replaceInGlobal(value, proxy) {
		var index = globalValues.indexOf(value)
		if (index >= 0) {
			var key = globalKeys[index]
			var d = Object.getOwnPropertyDescriptor(GLOBAL, key)
			if (d.writable) {
				GLOBAL[key] = proxy
			} else if (d.configurable) {
				Object.defineProperty(GLOBAL, key, {
					value: proxy,
					writable: false,
					enumerable: d.enumerable,
					configurable: false
				})
			} else {
				console.warn('Was not able to replace %s in global object', key)
			}
		}
	}
	
	return safeObjects
}

},{}],63:[function(require,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

function isPlainObject(obj) {
	if (!obj || toString.call(obj) !== '[object Object]' || obj.nodeType || obj.setInterval)
		return false;

	var has_own_constructor = hasOwn.call(obj, 'constructor');
	var has_is_property_of_method = hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !has_own_constructor && !has_is_property_of_method)
		return false;

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for ( key in obj ) {}

	return key === undefined || hasOwn.call( obj, key );
};

module.exports = function extend() {
	var options, name, src, copy, copyIsArray, clone,
	    target = arguments[0] || {},
	    i = 1,
	    length = arguments.length,
	    deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && typeof target !== "function") {
		target = {};
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( isPlainObject(copy) || (copyIsArray = Array.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray(src) ? src : [];

					} else {
						clone = src && isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

},{}],64:[function(require,module,exports){
'use strict';
var ansiRegex = require('ansi-regex');
var re = new RegExp(ansiRegex().source); // remove the `g` flag
module.exports = re.test.bind(re);

},{"ansi-regex":54}],65:[function(require,module,exports){
(function (global){
/**
 * Â© Copyright IBM Corp. 2016, 2017 All Rights Reserved
 *   Project name: JSONata
 *   This project is licensed under the MIT License, see LICENSE
 */

/**
 * @module JSONata
 * @description JSON query and transformation language
 */

/**
 * jsonata
 * @function
 * @param {Object} expr - JSONata expression
 * @returns {{evaluate: evaluate, assign: assign}} Evaluated expression
 */
var jsonata = (function() {
    'use strict';

    var operators = {
        '.': 75,
        '[': 80,
        ']': 0,
        '{': 70,
        '}': 0,
        '(': 80,
        ')': 0,
        ',': 0,
        '@': 75,
        '#': 70,
        ';': 80,
        ':': 80,
        '?': 20,
        '+': 50,
        '-': 50,
        '*': 60,
        '/': 60,
        '%': 60,
        '|': 20,
        '=': 40,
        '<': 40,
        '>': 40,
        '^': 40,
        '**': 60,
        '..': 20,
        ':=': 10,
        '!=': 40,
        '<=': 40,
        '>=': 40,
        '~>': 40,
        'and': 30,
        'or': 25,
        'in': 40,
        '&': 50,
        '!': 0,   // not an operator, but needed as a stop character for name tokens
        '~': 0   // not an operator, but needed as a stop character for name tokens
    };

    var escapes = {  // JSON string escape sequences - see json.org
        '"': '"',
        '\\': '\\',
        '/': '/',
        'b': '\b',
        'f': '\f',
        'n': '\n',
        'r': '\r',
        't': '\t'
    };

    // Tokenizer (lexer) - invoked by the parser to return one token at a time
    var tokenizer = function (path) {
        var position = 0;
        var length = path.length;

        var create = function (type, value) {
            var obj = {type: type, value: value, position: position};
            return obj;
        };

        var scanRegex = function() {
            // the prefix '/' will have been previously scanned. Find the end of the regex.
            // search for closing '/' ignoring any that are escaped, or within brackets
            var start = position;
            var depth = 0;
            var pattern;
            var flags;
            while(position < length) {
                var currentChar = path.charAt(position);
                if(currentChar === '/' && path.charAt(position - 1) !== '\\' && depth === 0) {
                    // end of regex found
                    pattern = path.substring(start, position);
                    if(pattern === '') {
                        throw {
                            code: "S0301",
                            stack: (new Error()).stack,
                            position: position
                        };
                    }
                    position++;
                    currentChar = path.charAt(position);
                    // flags
                    start = position;
                    while(currentChar === 'i' || currentChar === 'm') {
                        position++;
                        currentChar = path.charAt(position);
                    }
                    flags = path.substring(start, position) + 'g';
                    return new RegExp(pattern, flags);
                }
                if((currentChar === '(' || currentChar === '[' || currentChar === '{') && path.charAt(position - 1) !== '\\' ) {
                    depth++;
                }
                if((currentChar === ')' || currentChar === ']' || currentChar === '}') && path.charAt(position - 1) !== '\\' ) {
                    depth--;
                }

                position++;
            }
            throw {
                code: "S0302",
                stack: (new Error()).stack,
                position: position
            };
        };

        var next = function (prefix) {
            if (position >= length) return null;
            var currentChar = path.charAt(position);
            // skip whitespace
            while (position < length && ' \t\n\r\v'.indexOf(currentChar) > -1) {
                position++;
                currentChar = path.charAt(position);
            }
            // test for regex
            if (prefix !== true && currentChar === '/') {
                position++;
                return create('regex', scanRegex());
            }
            // handle double-char operators
            if (currentChar === '.' && path.charAt(position + 1) === '.') {
                // double-dot .. range operator
                position += 2;
                return create('operator', '..');
            }
            if (currentChar === ':' && path.charAt(position + 1) === '=') {
                // := assignment
                position += 2;
                return create('operator', ':=');
            }
            if (currentChar === '!' && path.charAt(position + 1) === '=') {
                // !=
                position += 2;
                return create('operator', '!=');
            }
            if (currentChar === '>' && path.charAt(position + 1) === '=') {
                // >=
                position += 2;
                return create('operator', '>=');
            }
            if (currentChar === '<' && path.charAt(position + 1) === '=') {
                // <=
                position += 2;
                return create('operator', '<=');
            }
            if (currentChar === '*' && path.charAt(position + 1) === '*') {
                // **  descendant wildcard
                position += 2;
                return create('operator', '**');
            }
            if (currentChar === '~' && path.charAt(position + 1) === '>') {
                // ~>  chain function
                position += 2;
                return create('operator', '~>');
            }
            // test for single char operators
            if (operators.hasOwnProperty(currentChar)) {
                position++;
                return create('operator', currentChar);
            }
            // test for string literals
            if (currentChar === '"' || currentChar === "'") {
                var quoteType = currentChar;
                // double quoted string literal - find end of string
                position++;
                var qstr = "";
                while (position < length) {
                    currentChar = path.charAt(position);
                    if (currentChar === '\\') { // escape sequence
                        position++;
                        currentChar = path.charAt(position);
                        if (escapes.hasOwnProperty(currentChar)) {
                            qstr += escapes[currentChar];
                        } else if (currentChar === 'u') {
                            // \u should be followed by 4 hex digits
                            var octets = path.substr(position + 1, 4);
                            if (/^[0-9a-fA-F]+$/.test(octets)) {
                                var codepoint = parseInt(octets, 16);
                                qstr += String.fromCharCode(codepoint);
                                position += 4;
                            } else {
                                throw {
                                    code: "S0104",
                                    stack: (new Error()).stack,
                                    position: position
                                };
                            }
                        } else {
                            // illegal escape sequence
                            throw {
                                code: "S0103",
                                stack: (new Error()).stack,
                                position: position,
                                token: currentChar
                            };

                        }
                    } else if (currentChar === quoteType) {
                        position++;
                        return create('string', qstr);
                    } else {
                        qstr += currentChar;
                    }
                    position++;
                }
                throw {
                    code: "S0101",
                    stack: (new Error()).stack,
                    position: position
                };
            }
            // test for numbers
            var numregex = /^-?(0|([1-9][0-9]*))(\.[0-9]+)?([Ee][-+]?[0-9]+)?/;
            var match = numregex.exec(path.substring(position));
            if (match !== null) {
                var num = parseFloat(match[0]);
                if (!isNaN(num) && isFinite(num)) {
                    position += match[0].length;
                    return create('number', num);
                } else {
                    throw {
                        code: "S0102",
                        stack: (new Error()).stack,
                        position: position,
                        token: match[0]
                    };
                }
            }
            // test for quoted names (backticks)
            var name;
            if(currentChar === '`') {
                // scan for closing quote
                position++;
                var end = path.indexOf('`', position);
                if(end !== -1) {
                    name = path.substring(position, end);
                    position = end + 1;
                    return create('name', name);
                }
                position = length;
                throw {
                    code: "S0105",
                    stack: (new Error()).stack,
                    position: position
                };
            }
            // test for names
            var i = position;
            var ch;
            for (;;) {
                ch = path.charAt(i);
                if (i === length || ' \t\n\r\v'.indexOf(ch) > -1 || operators.hasOwnProperty(ch)) {
                    if (path.charAt(position) === '$') {
                        // variable reference
                        name = path.substring(position + 1, i);
                        position = i;
                        return create('variable', name);
                    } else {
                        name = path.substring(position, i);
                        position = i;
                        switch (name) {
                            case 'or':
                            case 'in':
                            case 'and':
                                return create('operator', name);
                            case 'true':
                                return create('value', true);
                            case 'false':
                                return create('value', false);
                            case 'null':
                                return create('value', null);
                            default:
                                if (position === length && name === '') {
                                    // whitespace at end of input
                                    return null;
                                }
                                return create('name', name);
                        }
                    }
                } else {
                    i++;
                }
            }
        };

        return next;
    };

    /**
     * Parses a function signature definition and returns a validation function
     * @param {string} signature - the signature between the <angle brackets>
     * @returns {Function} validation function
     */
    function parseSignature(signature) {
        // create a Regex that represents this signature and return a function that when invoked,
        // returns the validated (possibly fixed-up) arguments, or throws a validation error
        // step through the signature, one symbol at a time
        var position = 1;
        var params = [];
        var param = {};
        var prevParam = param;
        while (position < signature.length) {
            var symbol = signature.charAt(position);
            if(symbol === ':') {
                // TODO figure out what to do with the return type
                // ignore it for now
                break;
            }

            var next = function() {
                params.push(param);
                prevParam = param;
                param = {};
            };

            var findClosingBracket = function(str, start, openSymbol, closeSymbol) {
                // returns the position of the closing symbol (e.g. bracket) in a string
                // that balances the opening symbol at position start
                var depth = 1;
                var position = start;
                while(position < str.length) {
                    position++;
                    symbol = str.charAt(position);
                    if(symbol === closeSymbol) {
                        depth--;
                        if(depth === 0) {
                            // we're done
                            break; // out of while loop
                        }
                    } else if(symbol === openSymbol) {
                        depth++;
                    }
                }
                return position;
            };

            switch (symbol) {
                case 's': // string
                case 'n': // number
                case 'b': // boolean
                case 'l': // not so sure about expecting null?
                case 'o': // object
                    param.regex = '[' + symbol + 'm]';
                    param.type = symbol;
                    next();
                    break;
                case 'a': // array
                    //  normally treat any value as singleton array
                    param.regex = '[asnblfom]';
                    param.type = symbol;
                    param.array = true;
                    next();
                    break;
                case 'f': // function
                    param.regex = 'f';
                    param.type = symbol;
                    next();
                    break;
                case 'j': // any JSON type
                    param.regex = '[asnblom]';
                    param.type = symbol;
                    next();
                    break;
                case 'x': // any type
                    param.regex = '[asnblfom]';
                    param.type = symbol;
                    next();
                    break;
                case '-': // use context if param not supplied
                    prevParam.context = true;
                    prevParam.contextRegex = new RegExp(prevParam.regex); // pre-compiled to test the context type at runtime
                    prevParam.regex += '?';
                    break;
                case '?': // optional param
                case '+': // one or more
                    prevParam.regex += symbol;
                    break;
                case '(': // choice of types
                    // search forward for matching ')'
                    var endParen = findClosingBracket(signature, position, '(', ')');
                    var choice = signature.substring(position + 1, endParen);
                    if(choice.indexOf('<') === -1) {
                        // no parameterized types, simple regex
                        param.regex = '[' + choice + 'm]';
                    } else {
                        // TODO harder
                        throw {
                            code: "S0402",
                            stack: (new Error()).stack,
                            value: choice,
                            offset: position
                        };
                    }
                    param.type = '(' + choice + ')';
                    position = endParen;
                    next();
                    break;
                case '<': // type parameter - can only be applied to 'a' and 'f'
                    if(prevParam.type === 'a' || prevParam.type === 'f') {
                        // search forward for matching '>'
                        var endPos = findClosingBracket(signature, position, '<', '>');
                        prevParam.subtype = signature.substring(position + 1, endPos);
                        position = endPos;
                    } else {
                        throw {
                            code: "S0401",
                            stack: (new Error()).stack,
                            value: prevParam.type,
                            offset: position
                        };
                    }
                    break;
            }
            position++;
        }
        var regexStr = '^' +
          params.map(function(param) {
              return '(' + param.regex + ')';
          }).join('') +
          '$';
        var regex = new RegExp(regexStr);
        var getSymbol = function(value) {
            var symbol;
            if(isFunction(value)) {
                symbol = 'f';
            } else {
                var type = typeof value;
                switch (type) {
                    case 'string':
                        symbol = 's';
                        break;
                    case 'number':
                        symbol = 'n';
                        break;
                    case 'boolean':
                        symbol = 'b';
                        break;
                    case 'object':
                        if (value === null) {
                            symbol = 'l';
                        } else if (Array.isArray(value)) {
                            symbol = 'a';
                        } else {
                            symbol = 'o';
                        }
                        break;
                    case 'undefined':
                        // any value can be undefined, but should be allowed to match
                        symbol = 'm'; // m for missing
                }
            }
            return symbol;
        };

        var throwValidationError = function(badArgs, badSig) {
            // to figure out where this went wrong we need apply each component of the
            // regex to each argument until we get to the one that fails to match
            var partialPattern = '^';
            var goodTo = 0;
            for(var index = 0; index < params.length; index++) {
                partialPattern += params[index].regex;
                var match = badSig.match(partialPattern);
                if(match === null) {
                    // failed here
                    throw {
                        code: "T0410",
                        stack: (new Error()).stack,
                        value: badArgs[goodTo],
                        index: goodTo + 1
                    };
                }
                goodTo = match[0].length;
            }
            // if it got this far, it's probably because of extraneous arguments (we
            // haven't added the trailing '$' in the regex yet.
            throw {
                code: "T0410",
                stack: (new Error()).stack,
                value: badArgs[goodTo],
                index: goodTo + 1
            };
        };

        return {
            definition: signature,
            validate: function(args, context) {
                var suppliedSig = '';
                args.forEach(function(arg) {
                    suppliedSig += getSymbol(arg);
                });
                var isValid = regex.exec(suppliedSig);
                if(isValid) {
                    var validatedArgs = [];
                    var argIndex = 0;
                    params.forEach(function(param, index) {
                        var arg = args[argIndex];
                        var match = isValid[index + 1];
                        if(match === '') {
                            if (param.context) {
                                // substitute context value for missing arg
                                // first check that the context value is the right type
                                var contextType = getSymbol(context);
                                // test contextType against the regex for this arg (without the trailing ?)
                                if(param.contextRegex.test(contextType)) {
                                    validatedArgs.push(context);
                                } else {
                                    // context value not compatible with this argument
                                    throw {
                                        code: "T0411",
                                        stack: (new Error()).stack,
                                        value: context,
                                        index: argIndex + 1
                                    };
                                }
                            } else {
                                validatedArgs.push(arg);
                                argIndex++;
                            }
                        } else {
                            // may have matched multiple args (if the regex ends with a '+'
                            // split into single tokens
                            match.split('').forEach(function(single) {
                                if (param.type === 'a') {
                                    if (single === 'm') {
                                        // missing (undefined)
                                        arg = undefined;
                                    } else {
                                        arg = args[argIndex];
                                        var arrayOK = true;
                                        // is there type information on the contents of the array?
                                        if (typeof param.subtype !== 'undefined') {
                                            if (single !== 'a' && match !== param.subtype) {
                                                arrayOK = false;
                                            } else if (single === 'a') {
                                                if (arg.length > 0) {
                                                    var itemType = getSymbol(arg[0]);
                                                    if (itemType !== param.subtype.charAt(0)) { // TODO recurse further
                                                        arrayOK = false;
                                                    } else {
                                                        // make sure every item in the array is this type
                                                        var differentItems = arg.filter(function (val) {
                                                            return (getSymbol(val) !== itemType);
                                                        });
                                                        arrayOK = (differentItems.length === 0);
                                                    }
                                                }
                                            }
                                        }
                                        if (!arrayOK) {
                                            throw {
                                                code: "T0412",
                                                stack: (new Error()).stack,
                                                value: arg,
                                                index: argIndex + 1,
                                                type: param.subtype // TODO translate symbol to type name
                                            };
                                        }
                                        // the function expects an array. If it's not one, make it so
                                        if (single !== 'a') {
                                            arg = [arg];
                                        }
                                    }
                                    validatedArgs.push(arg);
                                    argIndex++;
                                } else {
                                    validatedArgs.push(arg);
                                    argIndex++;
                                }
                            });
                        }
                    });
                    return validatedArgs;
                }
                throwValidationError(args, suppliedSig);
            }
        };
    }

    // This parser implements the 'Top down operator precedence' algorithm developed by Vaughan R Pratt; http://dl.acm.org/citation.cfm?id=512931.
    // and builds on the Javascript framework described by Douglas Crockford at http://javascript.crockford.com/tdop/tdop.html
    // and in 'Beautiful Code', edited by Andy Oram and Greg Wilson, Copyright 2007 O'Reilly Media, Inc. 798-0-596-51004-6

    var parser = function (source, recover) {
        var node;
        var lexer;

        var symbol_table = {};
        var errors = [];

        var remainingTokens = function() {
            var remaining = [];
            if(node.id !== '(end)') {
                remaining.push({type: node.type, value: node.value, position: node.position});
            }
            var nxt = lexer();
            while(nxt !== null) {
                remaining.push(nxt);
                nxt = lexer();
            }
            return remaining;
        };

        var base_symbol = {
            nud: function () {
                // error - symbol has been invoked as a unary operator
                var err = {
                    code: 'S0211',
                    token: this.value,
                    position: this.position
                };

                if(recover) {
                    err.remaining = remainingTokens();
                    err.type = 'error';
                    errors.push(err);
                    return err;
                } else {
                    err.stack = (new Error()).stack;
                    throw err;
                }
            }
        };

        var symbol = function (id, bp) {
            var s = symbol_table[id];
            bp = bp || 0;
            if (s) {
                if (bp >= s.lbp) {
                    s.lbp = bp;
                }
            } else {
                s = Object.create(base_symbol);
                s.id = s.value = id;
                s.lbp = bp;
                symbol_table[id] = s;
            }
            return s;
        };

        var handleError = function(err) {
            if(recover) {
                // tokenize the rest of the buffer and add it to an error token
                err.remaining = remainingTokens();
                errors.push(err);
                var symbol = symbol_table["(error)"];
                node = Object.create(symbol);
                node.error = err;
                node.type = "(error)";
                return node;
            } else {
                err.stack = (new Error()).stack;
                throw err;
            }
        };

        var advance = function (id, infix) {
            if (id && node.id !== id) {
                var code;
                if(node.id === '(end)') {
                    // unexpected end of buffer
                    code = "S0203";
                } else {
                    code = "S0202";
                }
                var err = {
                    code: code,
                    position: node.position,
                    token: node.value,
                    value: id
                };
                return handleError(err);
            }
            var next_token = lexer(infix);
            if (next_token === null) {
                node = symbol_table["(end)"];
                node.position = source.length;
                return node;
            }
            var value = next_token.value;
            var type = next_token.type;
            var symbol;
            switch (type) {
                case 'name':
                case 'variable':
                    symbol = symbol_table["(name)"];
                    break;
                case 'operator':
                    symbol = symbol_table[value];
                    if (!symbol) {
                        return handleError( {
                            code: "S0204",
                            stack: (new Error()).stack,
                            position: next_token.position,
                            token: value
                        });
                    }
                    break;
                case 'string':
                case 'number':
                case 'value':
                    type = "literal";
                    symbol = symbol_table["(literal)"];
                    break;
                case 'regex':
                    type = "regex";
                    symbol = symbol_table["(regex)"];
                    break;
                    /* istanbul ignore next */
                default:
                    return handleError( {
                        code: "S0205",
                        stack: (new Error()).stack,
                        position: next_token.position,
                        token: value
                    });
            }

            node = Object.create(symbol);
            node.value = value;
            node.type = type;
            node.position = next_token.position;
            return node;
        };

        // Pratt's algorithm
        var expression = function (rbp) {
            var left;
            var t = node;
            advance(null, true);
            left = t.nud();
            while (rbp < node.lbp) {
                t = node;
                advance();
                left = t.led(left);
            }
            return left;
        };

        var terminal = function(id) {
            var s = symbol(id, 0);
            s.nud = function() {
                return this;
            };
        };

        // match infix operators
        // <expression> <operator> <expression>
        // left associative
        var infix = function (id, bp, led) {
            var bindingPower = bp || operators[id];
            var s = symbol(id, bindingPower);
            s.led = led || function (left) {
                this.lhs = left;
                this.rhs = expression(bindingPower);
                this.type = "binary";
                return this;
            };
            return s;
        };

        // match infix operators
        // <expression> <operator> <expression>
        // right associative
        var infixr = function (id, bp, led) {
            var bindingPower = bp || operators[id];
            var s = symbol(id, bindingPower);
            s.led = led || function (left) {
                this.lhs = left;
                this.rhs = expression(bindingPower - 1); // subtract 1 from bindingPower for right associative operators
                this.type = "binary";
                return this;
            };
            return s;
        };

        // match prefix operators
        // <operator> <expression>
        var prefix = function (id, nud) {
            var s = symbol(id);
            s.nud = nud || function () {
                this.expression = expression(70);
                this.type = "unary";
                return this;
            };
            return s;
        };

        terminal("(end)");
        terminal("(name)");
        terminal("(literal)");
        terminal("(regex)");
        symbol(":");
        symbol(";");
        symbol(",");
        symbol(")");
        symbol("]");
        symbol("}");
        symbol(".."); // range operator
        infix("."); // field reference
        infix("+"); // numeric addition
        infix("-"); // numeric subtraction
        infix("*"); // numeric multiplication
        infix("/"); // numeric division
        infix("%"); // numeric modulus
        infix("="); // equality
        infix("<"); // less than
        infix(">"); // greater than
        infix("!="); // not equal to
        infix("<="); // less than or equal
        infix(">="); // greater than or equal
        infix("&"); // string concatenation
        infix("and"); // Boolean AND
        infix("or"); // Boolean OR
        infix("in"); // is member of array
        terminal("and"); // the 'keywords' can also be used as terminals (field names)
        terminal("or"); //
        terminal("in"); //
        infixr(":="); // bind variable
        prefix("-"); // unary numeric negation
        infix("~>"); // function application

        infixr("(error)", 10, function(left) {
            this.lhs = left;

            this.error = node.error;
            this.remaining = remainingTokens();
            this.type = 'error';
            return this;
        });

        // field wildcard (single level)
        prefix('*', function () {
            this.type = "wildcard";
            return this;
        });

        // descendant wildcard (multi-level)
        prefix('**', function () {
            this.type = "descendant";
            return this;
        });

        // function invocation
        infix("(", operators['('], function (left) {
            // left is is what we are trying to invoke
            this.procedure = left;
            this.type = 'function';
            this.arguments = [];
            if (node.id !== ')') {
                for (;;) {
                    if (node.type === 'operator' && node.id === '?') {
                        // partial function application
                        this.type = 'partial';
                        this.arguments.push(node);
                        advance('?');
                    } else {
                        this.arguments.push(expression(0));
                    }
                    if (node.id !== ',') break;
                    advance(',');
                }
            }
            advance(")", true);
            // if the name of the function is 'function' or Î», then this is function definition (lambda function)
            if (left.type === 'name' && (left.value === 'function' || left.value === '\u03BB')) {
                // all of the args must be VARIABLE tokens
                this.arguments.forEach(function (arg, index) {
                    if (arg.type !== 'variable') {
                        return handleError( {
                            code: "S0208",
                            stack: (new Error()).stack,
                            position: arg.position,
                            token: arg.value,
                            value: index + 1
                        });
                    }
                });
                this.type = 'lambda';
                // is the next token a '<' - if so, parse the function signature
                if(node.id === '<') {
                    var sigPos = node.position;
                    var depth = 1;
                    var sig = '<';
                    while(depth > 0 && node.id !== '{' && node.id !== '(end)') {
                        var tok = advance();
                        if(tok.id === '>') {
                            depth--;
                        } else if(tok.id === '<') {
                            depth++;
                        }
                        sig += tok.value;
                    }
                    advance('>');
                    try {
                        this.signature = parseSignature(sig);
                    } catch(err) {
                        // insert the position into this error
                        err.position = sigPos + err.offset;
                        return handleError( err );
                    }
                }
                // parse the function body
                advance('{');
                this.body = expression(0);
                advance('}');
            }
            return this;
        });

        // parenthesis - block expression
        prefix("(", function () {
            var expressions = [];
            while (node.id !== ")") {
                expressions.push(expression(0));
                if (node.id !== ";") {
                    break;
                }
                advance(";");
            }
            advance(")", true);
            this.type = 'block';
            this.expressions = expressions;
            return this;
        });

        // array constructor
        prefix("[", function () {
            var a = [];
            if (node.id !== "]") {
                for (;;) {
                    var item = expression(0);
                    if (node.id === "..") {
                        // range operator
                        var range = {type: "binary", value: "..", position: node.position, lhs: item};
                        advance("..");
                        range.rhs = expression(0);
                        item = range;
                    }
                    a.push(item);
                    if (node.id !== ",") {
                        break;
                    }
                    advance(",");
                }
            }
            advance("]", true);
            this.expressions = a;
            this.type = "unary";
            return this;
        });

        // filter - predicate or array index
        infix("[", operators['['], function (left) {
            if(node.id === "]") {
                // empty predicate means maintain singleton arrays in the output
                var step = left;
                while(step && step.type === 'binary' && step.value === '[') {
                    step = step.lhs;
                }
                step.keepArray = true;
                advance("]");
                return left;
            } else {
                this.lhs = left;
                this.rhs = expression(operators[']']);
                this.type = 'binary';
                advance("]", true);
                return this;
            }
        });

        // order-by
        infix("^", operators['^'], function (left) {
            advance("(");
            var terms = [];
            for(;;) {
                var term = {
                    descending: false
                };
                if (node.id === "<") {
                    // ascending sort
                    advance("<");
                } else if (node.id === ">") {
                    // descending sort
                    term.descending = true;
                    advance(">");
                } else {
                    //unspecified - default to ascending
                }
                term.expression = expression(0);
                terms.push(term);
                if(node.id !== ",") {
                    break;
                }
                advance(",");
            }
            advance(")");
            this.lhs = left;
            this.rhs = terms;
            this.type = 'binary';
            return this;
        });

        var objectParser = function (left) {
            var a = [];
            if (node.id !== "}") {
                for (;;) {
                    var n = expression(0);
                    advance(":");
                    var v = expression(0);
                    a.push([n, v]); // holds an array of name/value expression pairs
                    if (node.id !== ",") {
                        break;
                    }
                    advance(",");
                }
            }
            advance("}", true);
            if(typeof left === 'undefined') {
                // NUD - unary prefix form
                this.lhs = a;
                this.type = "unary";
            } else {
                // LED - binary infix form
                this.lhs = left;
                this.rhs = a;
                this.type = 'binary';
            }
            return this;
        };

        // object constructor
        prefix("{", objectParser);

        // object grouping
        infix("{", operators['{'], objectParser);

        // if/then/else ternary operator ?:
        infix("?", operators['?'], function (left) {
            this.type = 'condition';
            this.condition = left;
            this.then = expression(0);
            if (node.id === ':') {
                // else condition
                advance(":");
                this.else = expression(0);
            }
            return this;
        });

        // object transformer
        prefix("|", function () {
            this.type = 'transform';
            this.pattern = expression(0);
            advance('|');
            this.update = expression(0);
            if(node.id === ',') {
                advance(',');
                this.delete = expression(0);
            }
            advance('|');
            return this;
        });

        // tail call optimization
        // this is invoked by the post parser to analyse lambda functions to see
        // if they make a tail call.  If so, it is replaced by a thunk which will
        // be invoked by the trampoline loop during function application.
        // This enables tail-recursive functions to be written without growing the stack
        var tail_call_optimize = function(expr) {
            var result;
            if(expr.type === 'function') {
                var thunk = {type: 'lambda', thunk: true, arguments: [], position: expr.position};
                thunk.body = expr;
                result = thunk;
            } else if(expr.type === 'condition') {
                // analyse both branches
                expr.then = tail_call_optimize(expr.then);
                if(typeof expr.else !== 'undefined') {
                    expr.else = tail_call_optimize(expr.else);
                }
                result = expr;
            } else if(expr.type === 'block') {
                // only the last expression in the block
                var length = expr.expressions.length;
                if(length > 0) {
                    expr.expressions[length - 1] = tail_call_optimize(expr.expressions[length - 1]);
                }
                result = expr;
            } else {
                result = expr;
            }
            return result;
        };

        // post-parse stage
        // the purpose of this is flatten the parts of the AST representing location paths,
        // converting them to arrays of steps which in turn may contain arrays of predicates.
        // following this, nodes containing '.' and '[' should be eliminated from the AST.
        var ast_optimize = function (expr) {
            var result;
            switch (expr.type) {
                case 'binary':
                    switch (expr.value) {
                        case '.':
                            var lstep = ast_optimize(expr.lhs);
                            result = {type: 'path', steps: []};
                            if (lstep.type === 'path') {
                                Array.prototype.push.apply(result.steps, lstep.steps);
                            } else {
                                result.steps = [lstep];
                            }
                            var rest = ast_optimize(expr.rhs);
                            if(rest.type === 'function' &&
                              rest.procedure.type === 'path' &&
                              rest.procedure.steps.length === 1 &&
                              rest.procedure.steps[0].type === 'name' &&
                              result.steps[result.steps.length-1].type === 'function') {
                                // next function in chain of functions - will override a thenable
                                result.steps[result.steps.length-1].nextFunction = rest.procedure.steps[0].value;
                            }
                            if(rest.type !== 'path') {
                                rest = {type: 'path', steps: [rest]};
                            }
                            Array.prototype.push.apply(result.steps, rest.steps);
                            // any steps within a path that are literals, should be changed to 'name'
                            result.steps.filter(function(step) {
                                return step.type === 'literal';
                            }).forEach(function(lit) {
                                lit.type = 'name';
                            });
                            // any step that signals keeping a singleton array, should be flagged on the path
                            if(result.steps.filter(function(step) { return step.keepArray === true;}).length > 0) {
                                result.keepSingletonArray = true;
                            }
                            // if first step is a path constructor, flag it for special handling
                            if(result.steps[0].type === 'unary' && result.steps[0].value === '[') {
                                result.steps[0].consarray = true;
                            }
                            break;
                        case '[':
                            // predicated step
                            // LHS is a step or a predicated step
                            // RHS is the predicate expr
                            result = ast_optimize(expr.lhs);
                            var step = result;
                            if(result.type === 'path') {
                                step = result.steps[result.steps.length - 1];
                            }
                            if (typeof step.group !== 'undefined') {
                                throw {
                                    code: "S0209",
                                    stack: (new Error()).stack,
                                    position: expr.position
                                };
                            }
                            if (typeof step.predicate === 'undefined') {
                                step.predicate = [];
                            }
                            step.predicate.push(ast_optimize(expr.rhs));
                            break;
                        case '{':
                            // group-by
                            // LHS is a step or a predicated step
                            // RHS is the object constructor expr
                            result = ast_optimize(expr.lhs);
                            if (typeof result.group !== 'undefined') {
                                throw {
                                    code: "S0210",
                                    stack: (new Error()).stack,
                                    position: expr.position
                                };
                            }
                            // object constructor - process each pair
                            result.group = {
                                lhs: expr.rhs.map(function (pair) {
                                    return [ast_optimize(pair[0]), ast_optimize(pair[1])];
                                }),
                                position: expr.position
                            };
                            break;
                        case '^':
                            // order-by
                            // LHS is the array to be ordered
                            // RHS defines the terms
                            result = {type: 'sort', value: expr.value, position: expr.position};
                            result.lhs = ast_optimize(expr.lhs);
                            result.rhs = expr.rhs.map(function (terms) {
                                return {
                                    descending: terms.descending,
                                    expression: ast_optimize(terms.expression)
                                };
                            });
                            break;
                        case ':=':
                            result = {type: 'bind', value: expr.value, position: expr.position};
                            result.lhs = ast_optimize(expr.lhs);
                            result.rhs = ast_optimize(expr.rhs);
                            break;
                        case '~>':
                            result = {type: 'apply', value: expr.value, position: expr.position};
                            result.lhs = ast_optimize(expr.lhs);
                            result.rhs = ast_optimize(expr.rhs);
                            break;
                        default:
                            result = {type: expr.type, value: expr.value, position: expr.position};
                            result.lhs = ast_optimize(expr.lhs);
                            result.rhs = ast_optimize(expr.rhs);
                    }
                    break;
                case 'unary':
                    result = {type: expr.type, value: expr.value, position: expr.position};
                    if (expr.value === '[') {
                        // array constructor - process each item
                        result.expressions = expr.expressions.map(function (item) {
                            return ast_optimize(item);
                        });
                    } else if (expr.value === '{') {
                        // object constructor - process each pair
                        result.lhs = expr.lhs.map(function (pair) {
                            return [ast_optimize(pair[0]), ast_optimize(pair[1])];
                        });
                    } else {
                        // all other unary expressions - just process the expression
                        result.expression = ast_optimize(expr.expression);
                        // if unary minus on a number, then pre-process
                        if (expr.value === '-' && result.expression.type === 'literal' && isNumeric(result.expression.value)) {
                            result = result.expression;
                            result.value = -result.value;
                        }
                    }
                    break;
                case 'function':
                case 'partial':
                    result = {type: expr.type, name: expr.name, value: expr.value, position: expr.position};
                    result.arguments = expr.arguments.map(function (arg) {
                        return ast_optimize(arg);
                    });
                    result.procedure = ast_optimize(expr.procedure);
                    break;
                case 'lambda':
                    result = {type: expr.type, arguments: expr.arguments, signature: expr.signature, position: expr.position};
                    var body = ast_optimize(expr.body);
                    result.body = tail_call_optimize(body);
                    break;
                case 'condition':
                    result = {type: expr.type, position: expr.position};
                    result.condition = ast_optimize(expr.condition);
                    result.then = ast_optimize(expr.then);
                    if (typeof expr.else !== 'undefined') {
                        result.else = ast_optimize(expr.else);
                    }
                    break;
                case 'transform':
                    result = {type: expr.type, position: expr.position};
                    result.pattern = ast_optimize(expr.pattern);
                    result.update = ast_optimize(expr.update);
                    if(typeof expr.delete !== 'undefined') {
                        result.delete = ast_optimize(expr.delete);
                    }
                    break;
                case 'block':
                    result = {type: expr.type, position: expr.position};
                    // array of expressions - process each one
                    result.expressions = expr.expressions.map(function (item) {
                        return ast_optimize(item);
                    });
                    // TODO scan the array of expressions to see if any of them assign variables
                    // if so, need to mark the block as one that needs to create a new frame
                    break;
                case 'name':
                    result = {type: 'path', steps: [expr]};
                    if(expr.keepArray) {
                        result.keepSingletonArray = true;
                    }
                    break;
                case 'literal':
                case 'wildcard':
                case 'descendant':
                case 'variable':
                case 'regex':
                    result = expr;
                    break;
                case 'operator':
                    // the tokens 'and' and 'or' might have been used as a name rather than an operator
                    if (expr.value === 'and' || expr.value === 'or' || expr.value === 'in') {
                        expr.type = 'name';
                        result = ast_optimize(expr);
                    } else /* istanbul ignore else */ if (expr.value === '?') {
                        // partial application
                        result = expr;
                    } else {
                        throw {
                            code: "S0201",
                            stack: (new Error()).stack,
                            position: expr.position,
                            token: expr.value
                        };
                    }
                    break;
                case 'error':
                    result = expr;
                    if(expr.lhs) {
                        result = ast_optimize(expr.lhs);
                    }
                    break;
                default:
                    var code = "S0206";
                    /* istanbul ignore else */
                    if (expr.id === '(end)') {
                        code = "S0207";
                    }
                    var err = {
                        code: code,
                        position: expr.position,
                        token: expr.value
                    };
                    if(recover) {
                        errors.push(err);
                        return {type: 'error', error: err};
                    } else {
                        err.stack = (new Error()).stack;
                        throw err;
                    }
            }
            return result;
        };

        // now invoke the tokenizer and the parser and return the syntax tree
        lexer = tokenizer(source);
        advance();
        // parse the tokens
        var expr = expression(0);
        if (node.id !== '(end)') {
            var err = {
                code: "S0201",
                position: node.position,
                token: node.value
            };
            handleError(err);
        }
        expr = ast_optimize(expr);

        if(errors.length > 0) {
            expr.errors = errors;
        }

        return expr;
    };

    // Start of Evaluator code

    var staticFrame = createFrame(null);

    /**
     * Check if value is a finite number
     * @param {float} n - number to evaluate
     * @returns {boolean} True if n is a finite number
     */
    function isNumeric(n) {
        var isNum = false;
        if(typeof n === 'number') {
            var num = parseFloat(n);
            isNum = !isNaN(num);
            if (isNum && !isFinite(num)) {
                throw {
                    code: "D1001",
                    value: n,
                    stack: (new Error()).stack
                };
            }
        }
        return isNum;
    }

    /**
     * Returns true if the arg is an array of strings
     * @param {*} arg - the item to test
     * @returns {boolean} True if arg is an array of strings
     */
    function isArrayOfStrings(arg) {
        var result = false;
        /* istanbul ignore else */
        if(Array.isArray(arg)) {
            result = (arg.filter(function(item){return typeof item !== 'string';}).length === 0);
        }
        return result;
    }

    /**
     * Returns true if the arg is an array of numbers
     * @param {*} arg - the item to test
     * @returns {boolean} True if arg is an array of numbers
     */
    function isArrayOfNumbers(arg) {
        var result = false;
        if(Array.isArray(arg)) {
            result = (arg.filter(function(item){return !isNumeric(item);}).length === 0);
        }
        return result;
    }

    // Polyfill
    /* istanbul ignore next */
    Number.isInteger = Number.isInteger || function(value) {
        return typeof value === "number" &&
          isFinite(value) &&
          Math.floor(value) === value;
    };

    /**
     * Evaluate expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluate(expr, input, environment) {
        var result;

        var entryCallback = environment.lookup('__evaluate_entry');
        if(entryCallback) {
            entryCallback(expr, input, environment);
        }

        switch (expr.type) {
            case 'path':
                result = yield * evaluatePath(expr.steps, input, environment);
                result = normalizeSequence(result, expr.keepSingletonArray);
                break;
            case 'binary':
                result = yield * evaluateBinary(expr, input, environment);
                break;
            case 'unary':
                result = yield * evaluateUnary(expr, input, environment);
                break;
            case 'name':
                result = evaluateName(expr, input, environment);
                break;
            case 'literal':
                result = evaluateLiteral(expr, input, environment);
                break;
            case 'wildcard':
                result = evaluateWildcard(expr, input, environment);
                break;
            case 'descendant':
                result = evaluateDescendants(expr, input, environment);
                break;
            case 'condition':
                result = yield * evaluateCondition(expr, input, environment);
                break;
            case 'block':
                result = yield * evaluateBlock(expr, input, environment);
                break;
            case 'bind':
                result = yield * evaluateBindExpression(expr, input, environment);
                break;
            case 'regex':
                result = evaluateRegex(expr, input, environment);
                break;
            case 'function':
                result = yield * evaluateFunction(expr, input, environment);
                break;
            case 'variable':
                result = evaluateVariable(expr, input, environment);
                break;
            case 'lambda':
                result = evaluateLambda(expr, input, environment);
                break;
            case 'partial':
                result = yield * evaluatePartialApplication(expr, input, environment);
                break;
            case 'apply':
                result = yield * evaluateApplyExpression(expr, input, environment);
                break;
            case 'sort':
                result = yield * evaluateSortExpression(expr, input, environment);
                break;
            case 'transform':
                result = evaluateTransformExpression(expr, input, environment);
                break;
        }

        if(environment.lookup('__jsonata_async') &&
          (typeof result === 'undefined' || result === null || typeof result.then !== 'function')) {
            result = Promise.resolve(result);
        }
        if(environment.lookup('__jsonata_async') && typeof result.then === 'function' && expr.nextFunction && typeof result[expr.nextFunction] === 'function') {
            // although this is a 'thenable', it is chaining a different function
            // so don't yield since yielding will trigger the .then()
        } else {
            result = yield result;
        }


        if (expr.hasOwnProperty('predicate')) {
            result = yield * applyPredicates(expr.predicate, result, environment);
            result = normalizeSequence(result);

        }
        if (expr.hasOwnProperty('group')) {
            result = yield * evaluateGroupExpression(expr.group, result, environment);
        }

        var exitCallback = environment.lookup('__evaluate_exit');
        if(exitCallback) {
            exitCallback(expr, input, environment, result);
        }

        return result;
    }

    /**
     * Evaluate path expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluatePath(expr, input, environment) {
        var inputSequence;
        // expr is an array of steps
        // if the first step is a variable reference ($...), including root reference ($$),
        //   then the path is absolute rather than relative
        if (expr[0].type === 'variable') {
            inputSequence = [input]; // dummy singleton sequence for first (absolute) step
        } else if (Array.isArray(input)) {
            inputSequence = input;
        } else {
            // if input is not an array, make it so
            inputSequence = [input];
        }

        var resultSequence;

        // evaluate each step in turn
        for(var ii = 0; ii < expr.length; ii++) {
            var step = expr[ii];

            // if the first step is an explicit array constructor, then just evaluate that (i.e. don't iterate over a context array)
            if(ii === 0 && step.consarray) {
                resultSequence = yield * evaluate(step, inputSequence, environment);
            } else {
                resultSequence = yield * evaluateStep(step, inputSequence, environment);
            }

            if(typeof resultSequence === 'undefined' || resultSequence.length === 0) {
                break;
            }
            inputSequence = resultSequence;
        }

        return resultSequence;
    }

    /**
     * Normalize a JSONata sequence - singleton arrays become atomic values
     * @param {Array} sequence - input sequence
     * @param {Boolean} keepSingleton - keep singleton sequences as arrays
     * @returns {*} normalized sequence
     */
    function normalizeSequence(sequence, keepSingleton) {
        var result;
        if(typeof sequence === 'undefined') {
            result = undefined;
        } else if(!Array.isArray(sequence)) {
            result = sequence;
        } else if (sequence.length === 1) {
            if(keepSingleton) {
                result = sequence;
            } else {
                result = sequence[0];
            }
        } else if (sequence.length > 1) {
            result = sequence;
        }
        return result;
    }

    /**
     * Evaluate a step within a path
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateStep(expr, input, environment) {
        var result = [];


        for(var ii = 0; ii < input.length; ii++) {
            var res = yield * evaluate(expr, input[ii], environment);
            if (!(Array.isArray(res) && (expr.value !== '[' )) && !expr.consarray) {
                res = [res];
            }
            // is res an array - if so, flatten it into the parent array
            res.forEach(function (innerRes) {
                if (typeof innerRes !== 'undefined') {
                    result.push(innerRes);
                }
            });
        }
        return result;
    }

    /**
     * Apply predicates to input data
     * @param {Object} predicates - Predicates
     * @param {Object} input - Input data to apply predicates against
     * @param {Object} environment - Environment
     * @returns {*} Result after applying predicates
     */
    function* applyPredicates(predicates, input, environment) {
        var inputSequence = input;
        // lhs potentially holds an array
        // we want to iterate over the array, and only keep the items that are
        // truthy when applied to the predicate.
        // if the predicate evaluates to an integer, then select that index

        var results = [];
        for(var ii = 0; ii < predicates.length; ii++) {
            var predicate = predicates[ii];
            // if it's not an array, turn it into one
            // since in XPath >= 2.0 an item is equivalent to a singleton sequence of that item
            // if input is not an array, make it so
            if (!Array.isArray(inputSequence)) {
                inputSequence = [inputSequence];
            }
            results = [];
            if (predicate.type === 'literal' && isNumeric(predicate.value)) {
                var index = predicate.value;
                if (!Number.isInteger(index)) {
                    // round it down
                    index = Math.floor(index);
                }
                if (index < 0) {
                    // count in from end of array
                    index = inputSequence.length + index;
                }
                results = inputSequence[index];
            } else {
                results = yield * evaluateFilter(predicate, inputSequence, environment);
            }
            inputSequence = results;
        }
        return results;
    }

    /**
     * Apply filter predicate to input data
     * @param {Object} predicate - filter expression
     * @param {Object} input - Input data to apply predicates against
     * @param {Object} environment - Environment
     * @returns {*} Result after applying predicates
     */
    function* evaluateFilter(predicate, input, environment) {
        var results = [];
        for(var index = 0; index < input.length; index++) {
            var item = input[index];
            var res = yield * evaluate(predicate, item, environment);
            if (isNumeric(res)) {
                res = [res];
            }
            if(isArrayOfNumbers(res)) {
                res.forEach(function(ires) {
                    if (!Number.isInteger(ires)) {
                        // round it down
                        ires = Math.floor(ires);
                    }
                    if (ires < 0) {
                        // count in from end of array
                        ires = input.length + ires;
                    }
                    if (ires === index) {
                        results.push(item);
                    }
                });
            } else if (functionBoolean(res)) { // truthy
                results.push(item);
            }
        }
        return results;
    }

    /**
     * Evaluate binary expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function * evaluateBinary(expr, input, environment) {
        var result;
        var lhs = yield * evaluate(expr.lhs, input, environment);
        var rhs = yield * evaluate(expr.rhs, input, environment);
        var op = expr.value;

        try {
            switch (op) {
                case '+':
                case '-':
                case '*':
                case '/':
                case '%':
                    result = evaluateNumericExpression(lhs, rhs, op);
                    break;
                case '=':
                case '!=':
                case '<':
                case '<=':
                case '>':
                case '>=':
                    result = evaluateComparisonExpression(lhs, rhs, op);
                    break;
                case '&':
                    result = evaluateStringConcat(lhs, rhs);
                    break;
                case 'and':
                case 'or':
                    result = evaluateBooleanExpression(lhs, rhs, op);
                    break;
                case '..':
                    result = evaluateRangeExpression(lhs, rhs);
                    break;
                case 'in':
                    result = evaluateIncludesExpression(lhs, rhs);
                    break;
            }
        } catch(err) {
            err.position = expr.position;
            err.token = op;
            throw err;
        }
        return result;
    }

    /**
     * Evaluate unary expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateUnary(expr, input, environment) {
        var result;

        switch (expr.value) {
            case '-':
                result = yield * evaluate(expr.expression, input, environment);
                if (isNumeric(result)) {
                    result = -result;
                } else {
                    throw {
                        code: "D1002",
                        stack: (new Error()).stack,
                        position: expr.position,
                        token: expr.value,
                        value: result
                    };
                }
                break;
            case '[':
                // array constructor - evaluate each item
                result = [];
                for(var ii = 0; ii < expr.expressions.length; ii++) {
                    var item = expr.expressions[ii];
                    var value = yield * evaluate(item, input, environment);
                    if (typeof value !== 'undefined') {
                        if(item.value === '[') {
                            result.push(value);
                        } else {
                            result = functionAppend(result, value);
                        }
                    }
                }
                break;
            case '{':
                // object constructor - apply grouping
                result = yield * evaluateGroupExpression(expr, input, environment);
                break;

        }
        return result;
    }

    /**
     * Evaluate name object against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function evaluateName(expr, input, environment) {
        // lookup the 'name' item in the input
        var result;
        if (Array.isArray(input)) {
            result = [];
            for(var ii = 0; ii < input.length; ii++) {
                var res =  evaluateName(expr, input[ii], environment);
                if (typeof res !== 'undefined') {
                    result.push(res);
                }
            }
        } else if (input !== null && typeof input === 'object') {
            result = input[expr.value];
        }
        result = normalizeSequence(result);
        return result;
    }

    /**
     * Evaluate literal against input data
     * @param {Object} expr - JSONata expression
     * @returns {*} Evaluated input data
     */
    function evaluateLiteral(expr) {
        return expr.value;
    }

    /**
     * Evaluate wildcard against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @returns {*} Evaluated input data
     */
    function evaluateWildcard(expr, input) {
        var result;
        var results = [];
        if (input !== null && typeof input === 'object') {
            Object.keys(input).forEach(function (key) {
                var value = input[key];
                if(Array.isArray(value)) {
                    value = flatten(value);
                    results = functionAppend(results, value);
                } else {
                    results.push(value);
                }
            });
        }

        result = normalizeSequence(results);
        return result;
    }

    /**
     * Returns a flattened array
     * @param {Array} arg - the array to be flatten
     * @param {Array} flattened - carries the flattened array - if not defined, will initialize to []
     * @returns {Array} - the flattened array
     */
    function flatten(arg, flattened) {
        if(typeof flattened === 'undefined') {
            flattened = [];
        }
        if(Array.isArray(arg)) {
            arg.forEach(function (item) {
                flatten(item, flattened);
            });
        } else {
            flattened.push(arg);
        }
        return flattened;
    }

    /**
     * Evaluate descendants against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @returns {*} Evaluated input data
     */
    function evaluateDescendants(expr, input) {
        var result;
        var resultSequence = [];
        if (typeof input !== 'undefined') {
            // traverse all descendants of this object/array
            recurseDescendants(input, resultSequence);
            if (resultSequence.length === 1) {
                result = resultSequence[0];
            } else {
                result = resultSequence;
            }
        }
        return result;
    }

    /**
     * Recurse through descendants
     * @param {Object} input - Input data
     * @param {Object} results - Results
     */
    function recurseDescendants(input, results) {
        // this is the equivalent of //* in XPath
        if (!Array.isArray(input)) {
            results.push(input);
        }
        if (Array.isArray(input)) {
            input.forEach(function (member) {
                recurseDescendants(member, results);
            });
        } else if (input !== null && typeof input === 'object') {
            Object.keys(input).forEach(function (key) {
                recurseDescendants(input[key], results);
            });
        }
    }

    /**
     * Evaluate numeric expression against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @param {Object} op - opcode
     * @returns {*} Result
     */
    function evaluateNumericExpression(lhs, rhs, op) {
        var result;

        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {
            // if either side is undefined, the result is undefined
            return result;
        }

        if (!isNumeric(lhs)) {
            throw {
                code: "T2001",
                stack: (new Error()).stack,
                value: lhs
            };
        }
        if (!isNumeric(rhs)) {
            throw {
                code: "T2002",
                stack: (new Error()).stack,
                value: rhs
            };
        }

        switch (op) {
            case '+':
                result = lhs + rhs;
                break;
            case '-':
                result = lhs - rhs;
                break;
            case '*':
                result = lhs * rhs;
                break;
            case '/':
                result = lhs / rhs;
                break;
            case '%':
                result = lhs % rhs;
                break;
        }
        return result;
    }

    /**
     * Evaluate comparison expression against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @param {Object} op - opcode
     * @returns {*} Result
     */
    function evaluateComparisonExpression(lhs, rhs, op) {
        var result;

        // type checks
        var ltype = typeof lhs;
        var rtype = typeof rhs;

        if (ltype === 'undefined' || rtype === 'undefined') {
            // if either side is undefined, the result is false
            return false;
        }

        var validate = function() {
            // if aa or bb are not string or numeric values, then throw an error
            if (!(ltype === 'string' || ltype === 'number') || !(rtype === 'string' || rtype === 'number')) {
                throw {
                    code: "T2010",
                    stack: (new Error()).stack,
                    value: !(ltype === 'string' || ltype === 'number') ? lhs : rhs
                };
            }

            //if aa and bb are not of the same type
            if (ltype !== rtype) {
                throw {
                    code: "T2009",
                    stack: (new Error()).stack,
                    value: lhs,
                    value2: rhs
                };
            }
        };

        switch (op) {
            case '=':
                result = lhs === rhs;
                break;
            case '!=':
                result = (lhs !== rhs);
                break;
            case '<':
                validate();
                result = lhs < rhs;
                break;
            case '<=':
                validate();
                result = lhs <= rhs;
                break;
            case '>':
                validate();
                result = lhs > rhs;
                break;
            case '>=':
                validate();
                result = lhs >= rhs;
                break;
        }
        return result;
    }

    /**
     * Inclusion operator - in
     *
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @returns {boolean} - true if lhs is a member of rhs
     */
    function evaluateIncludesExpression(lhs, rhs) {
        var result = false;

        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {
            // if either side is undefined, the result is false
            return false;
        }

        if(!Array.isArray(rhs)) {
            rhs = [rhs];
        }

        for(var i = 0; i < rhs.length; i++) {
            if(rhs[i] === lhs) {
                result = true;
                break;
            }
        }

        return result;
    }

    /**
     * Evaluate boolean expression against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @param {Object} op - opcode
     * @returns {*} Result
     */
    function evaluateBooleanExpression(lhs, rhs, op) {
        var result;

        switch (op) {
            case 'and':
                result = functionBoolean(lhs) && functionBoolean(rhs);
                break;
            case 'or':
                result = functionBoolean(lhs) || functionBoolean(rhs);
                break;
        }
        return result;
    }

    /**
     * Evaluate string concatenation against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @returns {string|*} Concatenated string
     */
    function evaluateStringConcat(lhs, rhs) {
        var result;

        var lstr = '';
        var rstr = '';
        if (typeof lhs !== 'undefined') {
            lstr = functionString(lhs);
        }
        if (typeof rhs !== 'undefined') {
            rstr = functionString(rhs);
        }

        result = lstr.concat(rstr);
        return result;
    }

    /**
     * Evaluate group expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {{}} Evaluated input data
     */
    function* evaluateGroupExpression(expr, input, environment) {
        var result = {};
        var groups = {};
        // group the input sequence by 'key' expression
        if (!Array.isArray(input)) {
            input = [input];
        }
        for(var itemIndex = 0; itemIndex < input.length; itemIndex++) {
            var item = input[itemIndex];
            for(var pairIndex = 0; pairIndex < expr.lhs.length; pairIndex++) {
                var pair = expr.lhs[pairIndex];
                var key = yield * evaluate(pair[0], item, environment);
                // key has to be a string
                if (typeof  key !== 'string') {
                    throw {
                        code: "T1003",
                        stack: (new Error()).stack,
                        position: expr.position,
                        value: key
                    };
                }
                var entry = {data: item, expr: pair[1]};
                if (groups.hasOwnProperty(key)) {
                    // a value already exists in this slot
                    // append it as an array
                    groups[key].data = functionAppend(groups[key].data, item);
                } else {
                    groups[key] = entry;
                }
            }
        }

        // iterate over the groups to evaluate the 'value' expression
        for (key in groups) {
            entry = groups[key];
            var value = yield * evaluate(entry.expr, entry.data, environment);
            if(typeof value !== 'undefined') {
                result[key] = value;
            }
        }

        return result;
    }

    /**
     * Evaluate range expression against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @returns {Array} Resultant array
     */
    function evaluateRangeExpression(lhs, rhs) {
        var result;

        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {
            // if either side is undefined, the result is undefined
            return result;
        }

        if (lhs > rhs) {
            // if the lhs is greater than the rhs, return undefined
            return result;
        }

        if (!Number.isInteger(lhs)) {
            throw {
                code: "T2003",
                stack: (new Error()).stack,
                value: lhs
            };
        }
        if (!Number.isInteger(rhs)) {
            throw {
                code: "T2004",
                stack: (new Error()).stack,
                value: rhs
            };
        }

        result = new Array(rhs - lhs + 1);
        for (var item = lhs, index = 0; item <= rhs; item++, index++) {
            result[index] = item;
        }
        return result;
    }

    /**
     * Evaluate bind expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateBindExpression(expr, input, environment) {
        // The RHS is the expression to evaluate
        // The LHS is the name of the variable to bind to - should be a VARIABLE token
        var value = yield * evaluate(expr.rhs, input, environment);
        if (expr.lhs.type !== 'variable') {
            throw {
                code: "D2005",
                stack: (new Error()).stack,
                position: expr.position,
                token: expr.value,
                value: expr.lhs.type === 'path' ? expr.lhs.steps[0].value : expr.lhs.value
            };
        }
        environment.bind(expr.lhs.value, value);
        return value;
    }

    /**
     * Evaluate condition against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateCondition(expr, input, environment) {
        var result;
        var condition = yield * evaluate(expr.condition, input, environment);
        if (functionBoolean(condition)) {
            result = yield * evaluate(expr.then, input, environment);
        } else if (typeof expr.else !== 'undefined') {
            result = yield * evaluate(expr.else, input, environment);
        }
        return result;
    }

    /**
     * Evaluate block against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateBlock(expr, input, environment) {
        var result;
        // create a new frame to limit the scope of variable assignments
        // TODO, only do this if the post-parse stage has flagged this as required
        var frame = createFrame(environment);
        // invoke each expression in turn
        // only return the result of the last one
        for(var ii = 0; ii < expr.expressions.length; ii++) {
            result = yield * evaluate(expr.expressions[ii], input, frame);
        }

        return result;
    }

    /**
     * Prepare a regex
     * @param {Object} expr - expression containing regex
     * @returns {Function} Higher order function representing prepared regex
     */
    function evaluateRegex(expr) {
        expr.value.lastIndex = 0;
        var closure = function(str) {
            var re = expr.value;
            var result;
            var match = re.exec(str);
            if(match !== null) {
                result = {
                    match: match[0],
                    start: match.index,
                    end: match.index + match[0].length,
                    groups: []
                };
                if(match.length > 1) {
                    for(var i = 1; i < match.length; i++) {
                        result.groups.push(match[i]);
                    }
                }
                result.next = function() {
                    if(re.lastIndex >= str.length) {
                        return undefined;
                    } else {
                        var next = closure(str);
                        if(next && next.match === '' && re.lastIndex === expr.value.lastIndex) {
                            // matches zero length string; this will never progress
                            throw {
                                code: "D1004",
                                stack: (new Error()).stack,
                                position: expr.position,
                                value: expr.value.source
                            };
                        }
                        return next;
                    }
                };
            }

            return result;
        };
        return closure;
    }

    /**
     * Evaluate variable against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function evaluateVariable(expr, input, environment) {
        // lookup the variable value in the environment
        var result;
        // if the variable name is empty string, then it refers to context value
        if (expr.value === '') {
            result = input;
        } else {
            result = environment.lookup(expr.value);
        }
        return result;
    }

    /**
     * sort / order-by operator
     * @param {Object} expr - AST for operator
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Ordered sequence
     */
    function* evaluateSortExpression(expr, input, environment) {
        var result;

        // evaluate the lhs, then sort the results in order according to rhs expression
        var lhs = yield * evaluate(expr.lhs, input, environment);

        // sort the lhs array
        // use comparator function
        var comparator = function(a, b) {
            // expr.rhs is an array of order-by in priority order
            var comp = 0;
            for(var index = 0; comp === 0 && index < expr.rhs.length; index++) {
                var term = expr.rhs[index];
                //evaluate the rhs expression in the context of a
                var aa = driveGenerator(term.expression, a, environment);
                //evaluate the rhs expression in the context of b
                var bb = driveGenerator(term.expression, b, environment);

                // type checks
                var atype = typeof aa;
                var btype = typeof bb;
                // undefined should be last in sort order
                if(atype === 'undefined') {
                    // swap them, unless btype is also undefined
                    comp = (btype === 'undefined') ? 0 : 1;
                    continue;
                }
                if(btype === 'undefined') {
                    comp = -1;
                    continue;
                }

                // if aa or bb are not string or numeric values, then throw an error
                if(!(atype === 'string' || atype === 'number') || !(btype === 'string' || btype === 'number')) {
                    throw {
                        code: "T2008",
                        stack: (new Error()).stack,
                        position: expr.position,
                        value: !(atype === 'string' || atype === 'number') ? aa : bb
                    };
                }

                //if aa and bb are not of the same type
                if(atype !== btype) {
                    throw {
                        code: "T2007",
                        stack: (new Error()).stack,
                        position: expr.position,
                        value: aa,
                        value2: bb
                    };
                }
                if(aa === bb) {
                    // both the same - move on to next term
                    continue;
                } else if (aa < bb) {
                    comp = -1;
                } else {
                    comp = 1;
                }
                if(term.descending === true) {
                    comp = -comp;
                }
            }
            // only swap a & b if comp equals 1
            return comp === 1;
        };

        result = functionSort(lhs, comparator);

        return result;
    }

    /**
     * create a transformer function
     * @param {Object} expr - AST for operator
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} tranformer function
     */
    function evaluateTransformExpression(expr, input, environment) {
        // create a function to implement the transform definition
        var transformer = function*(obj) { // signature <(oa):o>
            // undefined inputs always return undefined
            if(typeof obj === 'undefined') {
                return undefined;
            }

            // this function returns a copy of obj with changes specified by the pattern/operation
            var cloneFunction = environment.lookup('clone');
            if(!isFunction(cloneFunction)) {
                // throw type error
                throw {
                    code: "T2013",
                    stack: (new Error()).stack,
                    position: expr.position
                };
            }
            var result = yield * apply(cloneFunction, [obj], environment);
            var matches = yield * evaluate(expr.pattern, result, environment);
            if(typeof matches !== 'undefined') {
                if(!Array.isArray(matches)) {
                    matches = [matches];
                }
                for(var ii = 0; ii < matches.length; ii++) {
                    var match = matches[ii];
                    // evaluate the update value for each match
                    var update = yield * evaluate(expr.update, match, environment);
                    // update must be an object
                    var updateType = typeof update;
                    if(updateType !== 'undefined') {
                        if(updateType !== 'object' || update === null) {
                            // throw type error
                            throw {
                                code: "T2011",
                                stack: (new Error()).stack,
                                position: expr.update.position,
                                value: update
                            };
                        }
                        // merge the update
                        for(var prop in update) {
                            match[prop] = update[prop];
                        }
                    }

                    // delete, if specified, must be an array of strings (or single string)
                    if(typeof expr.delete !== 'undefined') {
                        var deletions = yield * evaluate(expr.delete, match, environment);
                        if(typeof deletions !== 'undefined') {
                            var val = deletions;
                            if (!Array.isArray(deletions)) {
                                deletions = [deletions];
                            }
                            if (!isArrayOfStrings(deletions)) {
                                // throw type error
                                throw {
                                    code: "T2012",
                                    stack: (new Error()).stack,
                                    position: expr.delete.position,
                                    value: val
                                };
                            }
                            for (var jj = 0; jj < deletions.length; jj++) {
                                delete match[deletions[jj]];
                            }
                        }
                    }
                }
            }

            return result;
        };

        return defineFunction(transformer, '<(oa):o>');
    }

    /**
     * Evaluate an expression by driving the generator to completion
     * Used when it's not possible to yield
     * @param {Object} expr - AST
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} result
     */
    function driveGenerator(expr, input, environment) {
        var gen = evaluate(expr, input, environment);
        // returns a generator - so iterate over it
        var comp = gen.next();
        while (!comp.done) {
            comp = gen.next(comp.value);
        }
        return comp.value;
    }

    var chain = driveGenerator(parser('function($f, $g) { function($x){ $g($f($x)) } }'), null, staticFrame);

    /**
     * Apply the function on the RHS using the sequence on the LHS as the first argument
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateApplyExpression(expr, input, environment) {
        var result;


        if(expr.rhs.type === 'function') {
            // this is a function _invocation_; invoke it with lhs expression as the first argument
            expr.rhs.arguments.unshift(expr.lhs);
            result = yield * evaluateFunction(expr.rhs, input, environment);
            expr.rhs.arguments.shift();
        } else {
            var lhs = yield * evaluate(expr.lhs, input, environment);
            var func = yield * evaluate(expr.rhs, input, environment);

            if(!isFunction(func)) {
                throw {
                    code: "T2006",
                    stack: (new Error()).stack,
                    position: expr.position,
                    value: func
                };
            }

            if(isFunction(lhs)) {
                // this is function chaining (func1 ~> func2)
                // Î»($f, $g) { Î»($x){ $g($f($x)) } }
                result = yield * apply(chain, [lhs, func], environment, null);
            } else {
                result = yield * apply(func, [lhs], environment, null);
            }

        }

        return result;
    }

    /**
     *
     * @param {Object} arg - expression to test
     * @returns {boolean} - true if it is a function (lambda or built-in)
     */
    function isFunction(arg) {
        return ((arg && (arg._jsonata_function === true || arg._jsonata_lambda === true)) || typeof arg === 'function');
    }

    /**
     * Tests whether arg is a lambda function
     * @param {*} arg - the value to test
     * @returns {boolean} - true if it is a lambda function
     */
    function isLambda(arg) {
        return arg && arg._jsonata_lambda === true;
    }

    /**
     * @param {Object} arg - expression to test
     * @returns {boolean} - true if it is a generator i.e. the result from calling a
     * generator function
     */
    function isGenerator(arg) {
        return (
            typeof arg === 'object' &&
            arg !== null &&
            Symbol.iterator in arg &&
            typeof arg[Symbol.iterator] === 'function' &&
            'next' in arg &&
            typeof arg.next === 'function'
        );
    }

    /**
     * Evaluate function against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @param {Object} [applyto] - LHS of ~> operator
     * @returns {*} Evaluated input data
     */
    function* evaluateFunction(expr, input, environment) {
        var result;

        // create the procedure
        // can't assume that expr.procedure is a lambda type directly
        // could be an expression that evaluates to a function (e.g. variable reference, parens expr etc.
        // evaluate it generically first, then check that it is a function.  Throw error if not.
        var proc = yield * evaluate(expr.procedure, input, environment);

        if (typeof proc === 'undefined' && expr.procedure.type === 'path' && environment.lookup(expr.procedure.steps[0].value)) {
            // help the user out here if they simply forgot the leading $
            throw {
                code: "T1005",
                stack: (new Error()).stack,
                position: expr.position,
                token: expr.procedure.steps[0].value
            };
        }

        var evaluatedArgs = [];
        // eager evaluation - evaluate the arguments
        for (var jj = 0; jj < expr.arguments.length; jj++) {
            // only evaluate 'eager' arguments at this stage; wrap the 'lazy' ones in a closure
            evaluatedArgs.push(yield* evaluate(expr.arguments[jj], input, environment));
        }
        // apply the procedure
        try {
            // if(input instanceof Object) {
            //     Object.defineProperty(input, '__env__', {
            //         enumerable: false,
            //         configurable: true,
            //         get: function () {
            //             return environment;
            //         }
            //     });
            // }
            result = yield * apply(proc, evaluatedArgs, input);
        } catch (err) {
            // add the position field to the error
            err.position = expr.position;
            // and the function identifier
            err.token = expr.procedure.type === 'path' ? expr.procedure.steps[0].value : expr.procedure.value;
            throw err;
        }
        return result;
    }

    /**
     * Apply procedure or function
     * @param {Object} proc - Procedure
     * @param {Array} args - Arguments
     * @param {Object} self - Self
     * @returns {*} Result of procedure
     */
    function* apply(proc, args, self) {
        var result;
        result = yield * applyInner(proc, args, self);
        while(isLambda(result) && result.thunk === true) {
            // trampoline loop - this gets invoked as a result of tail-call optimization
            // the function returned a tail-call thunk
            // unpack it, evaluate its arguments, and apply the tail call
            var next = yield * evaluate(result.body.procedure, result.input, result.environment);
            var evaluatedArgs = [];
            for(var ii = 0; ii < result.body.arguments.length; ii++) {
                evaluatedArgs.push(yield * evaluate(result.body.arguments[ii], result.input, result.environment));
            }

            result = yield * applyInner(next, evaluatedArgs, self);
        }
        return result;
    }

    /**
     * Apply procedure or function
     * @param {Object} proc - Procedure
     * @param {Array} args - Arguments
     * @param {Object} self - Self
     * @returns {*} Result of procedure
     */
    function* applyInner(proc, args, self) {
        var result;
        var validatedArgs = args;
        if(proc) {
            validatedArgs = validateArguments(proc.signature, args, self);
        }
        if (isLambda(proc)) {
            result = yield * applyProcedure(proc, validatedArgs);
        } else if (proc && proc._jsonata_function === true) {
            result = proc.implementation.apply(self, validatedArgs);
            // `proc.implementation` might be a generator function
            // and `result` might be a generator - if so, yield
            if(isGenerator(result)) {
                result = yield *result;
            }
        } else if (typeof proc === 'function') {
            result = proc.apply(self, validatedArgs);
            /* istanbul ignore next */
            if(isGenerator(result)) {
                result = yield *result;
            }
        } else {
            throw {
                code: "T1006",
                stack: (new Error()).stack
            };
        }
        return result;
    }

    /**
     * Evaluate lambda against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {{lambda: boolean, input: *, environment: *, arguments: *, body: *}} Evaluated input data
     */
    function evaluateLambda(expr, input, environment) {
        // make a function (closure)
        var procedure = {
            _jsonata_lambda: true,
            input: input,
            environment: environment,
            arguments: expr.arguments,
            signature: expr.signature,
            body: expr.body
        };
        if(expr.thunk === true) {
            procedure.thunk = true;
        }
        return procedure;
    }

    /**
     * Evaluate partial application
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluatePartialApplication(expr, input, environment) {
        // partially apply a function
        var result;
        // evaluate the arguments
        var evaluatedArgs = [];
        for(var ii = 0; ii < expr.arguments.length; ii++) {
            var arg = expr.arguments[ii];
            if (arg.type === 'operator' && arg.value === '?') {
                evaluatedArgs.push(arg);
            } else {
                evaluatedArgs.push(yield * evaluate(arg, input, environment));
            }
        }
        // lookup the procedure
        var proc = yield * evaluate(expr.procedure, input, environment);
        if (typeof proc === 'undefined' && expr.procedure.type === 'path' && environment.lookup(expr.procedure.steps[0].value)) {
            // help the user out here if they simply forgot the leading $
            throw {
                code: "T1007",
                stack: (new Error()).stack,
                position: expr.position,
                token: expr.procedure.steps[0].value
            };
        }
        if (isLambda(proc)) {
            result = partialApplyProcedure(proc, evaluatedArgs);
        } else if (proc && proc._jsonata_function === true) {
            result = partialApplyNativeFunction(proc.implementation, evaluatedArgs);
        } else if (typeof proc === 'function') {
            result = partialApplyNativeFunction(proc, evaluatedArgs);
        } else {
            throw {
                code: "T1008",
                stack: (new Error()).stack,
                position: expr.position,
                token: expr.procedure.type === 'path' ? expr.procedure.steps[0].value : expr.procedure.value
            };
        }
        return result;
    }

    /**
     * Validate the arguments against the signature validator (if it exists)
     * @param {Function} signature - validator function
     * @param {Array} args - function arguments
     * @param {*} context - context value
     * @returns {Array} - validated arguments
     */
    function validateArguments(signature, args, context) {
        if(typeof signature === 'undefined') {
            // nothing to validate
            return args;
        }
        var validatedArgs = signature.validate(args, context);
        return validatedArgs;
    }

    /**
     * Apply procedure
     * @param {Object} proc - Procedure
     * @param {Array} args - Arguments
     * @returns {*} Result of procedure
     */
    function* applyProcedure(proc, args) {
        var result;
        var env = createFrame(proc.environment);
        proc.arguments.forEach(function (param, index) {
            env.bind(param.value, args[index]);
        });
        if (typeof proc.body === 'function') {
            // this is a lambda that wraps a native function - generated by partially evaluating a native
            result = yield * applyNativeFunction(proc.body, env);
        } else {
            result = yield * evaluate(proc.body, proc.input, env);
        }
        return result;
    }

    /**
     * Partially apply procedure
     * @param {Object} proc - Procedure
     * @param {Array} args - Arguments
     * @returns {{lambda: boolean, input: *, environment: {bind, lookup}, arguments: Array, body: *}} Result of partially applied procedure
     */
    function partialApplyProcedure(proc, args) {
        // create a closure, bind the supplied parameters and return a function that takes the remaining (?) parameters
        var env = createFrame(proc.environment);
        var unboundArgs = [];
        proc.arguments.forEach(function (param, index) {
            var arg = args[index];
            if (arg && arg.type === 'operator' && arg.value === '?') {
                unboundArgs.push(param);
            } else {
                env.bind(param.value, arg);
            }
        });
        var procedure = {
            _jsonata_lambda: true,
            input: proc.input,
            environment: env,
            arguments: unboundArgs,
            body: proc.body
        };
        return procedure;
    }

    /**
     * Partially apply native function
     * @param {Function} native - Native function
     * @param {Array} args - Arguments
     * @returns {{lambda: boolean, input: *, environment: {bind, lookup}, arguments: Array, body: *}} Result of partially applying native function
     */
    function partialApplyNativeFunction(native, args) {
        // create a lambda function that wraps and invokes the native function
        // get the list of declared arguments from the native function
        // this has to be picked out from the toString() value
        var sigArgs = getNativeFunctionArguments(native);
        sigArgs = sigArgs.map(function (sigArg) {
            return '$' + sigArg.trim();
        });
        var body = 'function(' + sigArgs.join(', ') + '){ _ }';

        var bodyAST = parser(body);
        bodyAST.body = native;

        var partial = partialApplyProcedure(bodyAST, args);
        return partial;
    }

    /**
     * Apply native function
     * @param {Object} proc - Procedure
     * @param {Object} env - Environment
     * @returns {*} Result of applying native function
     */
    function* applyNativeFunction(proc, env) {
        var sigArgs = getNativeFunctionArguments(proc);
        // generate the array of arguments for invoking the function - look them up in the environment
        var args = sigArgs.map(function (sigArg) {
            return env.lookup(sigArg.trim());
        });

        var result = proc.apply(null, args);
        if(isGenerator(result)) {
            result = yield * result;
        }
        return result;
    }

    /**
     * Get native function arguments
     * @param {Function} func - Function
     * @returns {*|Array} Native function arguments
     */
    function getNativeFunctionArguments(func) {
        var signature = func.toString();
        var sigParens = /\(([^)]*)\)/.exec(signature)[1]; // the contents of the parens
        var sigArgs = sigParens.split(',');
        return sigArgs;
    }

    /**
     * Creates a function definition
     * @param {Function} func - function implementation in Javascript
     * @param {string} signature - JSONata function signature definition
     * @returns {{implementation: *, signature: *}} function definition
     */
    function defineFunction(func, signature) {
        var definition = {
            _jsonata_function: true,
            implementation: func
        };
        if(typeof signature !== 'undefined') {
            definition.signature = parseSignature(signature);
        }
        return definition;
    }

    /**
     * Sum function
     * @param {Object} args - Arguments
     * @returns {number} Total value of arguments
     */
    function functionSum(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined') {
            return undefined;
        }

        var total = 0;
        args.forEach(function(num){total += num;});
        return total;
    }

    /**
     * Count function
     * @param {Object} args - Arguments
     * @returns {number} Number of elements in the array
     */
    function functionCount(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined') {
            return 0;
        }

        return args.length;
    }

    /**
     * Max function
     * @param {Object} args - Arguments
     * @returns {number} Max element in the array
     */
    function functionMax(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined' || args.length === 0) {
            return undefined;
        }

        return Math.max.apply(Math, args);
    }

    /**
     * Min function
     * @param {Object} args - Arguments
     * @returns {number} Min element in the array
     */
    function functionMin(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined' || args.length === 0) {
            return undefined;
        }

        return Math.min.apply(Math, args);
    }

    /**
     * Average function
     * @param {Object} args - Arguments
     * @returns {number} Average element in the array
     */
    function functionAverage(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined' || args.length === 0) {
            return undefined;
        }

        var total = 0;
        args.forEach(function(num){total += num;});
        return total/args.length;
    }

    /**
     * Stingify arguments
     * @param {Object} arg - Arguments
     * @returns {String} String from arguments
     */
    function functionString(arg) {
        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        var str;

        if (typeof arg === 'string') {
            // already a string
            str = arg;
        } else if(isFunction(arg)) {
            // functions (built-in and lambda convert to empty string
            str = '';
        } else if (typeof arg === 'number' && !isFinite(arg)) {
            throw {
                code: "D3001",
                value: arg,
                stack: (new Error()).stack
            };
        } else
            str = JSON.stringify(arg, function (key, val) {
                return (typeof val !== 'undefined' && val !== null && val.toPrecision && isNumeric(val)) ? Number(val.toPrecision(13)) :
                    (val && isFunction(val)) ? '' : val;
            });
        return str;
    }

    /**
     * Create substring based on character number and length
     * @param {String} str - String to evaluate
     * @param {Integer} start - Character number to start substring
     * @param {Integer} [length] - Number of characters in substring
     * @returns {string|*} Substring
     */
    function functionSubstring(str, start, length) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        return str.substr(start, length);
    }

    /**
     * Create substring up until a character
     * @param {String} str - String to evaluate
     * @param {String} chars - Character to define substring boundary
     * @returns {*} Substring
     */
    function functionSubstringBefore(str, chars) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        var pos = str.indexOf(chars);
        if (pos > -1) {
            return str.substr(0, pos);
        } else {
            return str;
        }
    }

    /**
     * Create substring after a character
     * @param {String} str - String to evaluate
     * @param {String} chars - Character to define substring boundary
     * @returns {*} Substring
     */
    function functionSubstringAfter(str, chars) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        var pos = str.indexOf(chars);
        if (pos > -1) {
            return str.substr(pos + chars.length);
        } else {
            return str;
        }
    }

    /**
     * Lowercase a string
     * @param {String} str - String to evaluate
     * @returns {string} Lowercase string
     */
    function functionLowercase(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        return str.toLowerCase();
    }

    /**
     * Uppercase a string
     * @param {String} str - String to evaluate
     * @returns {string} Uppercase string
     */
    function functionUppercase(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        return str.toUpperCase();
    }

    /**
     * length of a string
     * @param {String} str - string
     * @returns {Number} The number of characters in the string
     */
    function functionLength(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        return str.length;
    }

    /**
     * Normalize and trim whitespace within a string
     * @param {string} str - string to be trimmed
     * @returns {string} - trimmed string
     */
    function functionTrim(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        // normalize whitespace
        var result = str.replace(/[ \t\n\r]+/gm, ' ');
        if(result.charAt(0) === ' ') {
            // strip leading space
            result = result.substring(1);
        }
        if(result.charAt(result.length - 1) === ' ') {
            // strip trailing space
            result = result.substring(0, result.length - 1);
        }
        return result;
    }

    /**
     * Pad a string to a minimum width by adding characters to the start or end
     * @param {string} str - string to be padded
     * @param {number} width - the minimum width; +ve pads to the right, -ve pads to the left
     * @param {string} [char] - the pad character(s); defaults to ' '
     * @returns {string} - padded string
     */
    function functionPad(str, width, char) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        if(typeof char === 'undefined' || char.length === 0) {
            char = ' ';
        }

        var result;
        var padLength = Math.abs(width) - str.length;
        if(padLength > 0) {
            var padding = (new Array(padLength + 1)).join(char);
            if(char.length > 1) {
                padding = padding.substring(0, padLength);
            }
            if(width > 0) {
                result = str + padding;
            } else {
                result = padding + str;
            }
        } else {
            result = str;
        }
        return result;
    }

    /**
     * Tests if the str contains the token
     * @param {String} str - string to test
     * @param {String} token - substring or regex to find
     * @returns {Boolean} - true if str contains token
     */
    function functionContains(str, token) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        var result;

        if(typeof token === 'string') {
            result = (str.indexOf(token) !== -1);
        } else {
            var matches = token(str);
            result = (typeof matches !== 'undefined');
        }

        return result;
    }

    /**
     * Match a string with a regex returning an array of object containing details of each match
     * @param {String} str - string
     * @param {String} regex - the regex applied to the string
     * @param {Integer} [limit] - max number of matches to return
     * @returns {Array} The array of match objects
     */
    function functionMatch(str, regex, limit) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        // limit, if specified, must be a non-negative number
        if(limit < 0) {
            throw {
                stack: (new Error()).stack,
                value: limit,
                code: 'D3040',
                index: 3
            };
        }

        var result = [];

        if(typeof limit === 'undefined' || limit > 0) {
            var count = 0;
            var matches = regex(str);
            if (typeof matches !== 'undefined') {
                while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {
                    result.push({
                        match: matches.match,
                        index: matches.start,
                        groups: matches.groups
                    });
                    matches = matches.next();
                    count++;
                }
            }
        }

        return result;
    }

    /**
     * Match a string with a regex returning an array of object containing details of each match
     * @param {String} str - string
     * @param {String} pattern - the substring/regex applied to the string
     * @param {String} replacement - text to replace the matched substrings
     * @param {Integer} [limit] - max number of matches to return
     * @returns {Array} The array of match objects
     */
    function* functionReplace(str, pattern, replacement, limit) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        // pattern cannot be an empty string
        if(pattern === '') {
            throw {
                code: "D3010",
                stack: (new Error()).stack,
                value: pattern,
                index: 2
            };
        }

        // limit, if specified, must be a non-negative number
        if(limit < 0) {
            throw {
                code: "D3011",
                stack: (new Error()).stack,
                value: limit,
                index: 4
            };
        }

        var replacer;
        if(typeof replacement === 'string') {
            replacer = function (regexMatch) {
                var substitute = '';
                // scan forward, copying the replacement text into the substitute string
                // and replace any occurrence of $n with the values matched by the regex
                var position = 0;
                var index = replacement.indexOf('$', position);
                while (index !== -1 && position < replacement.length) {
                    substitute += replacement.substring(position, index);
                    position = index + 1;
                    var dollarVal = replacement.charAt(position);
                    if (dollarVal === '$') {
                        // literal $
                        substitute += '$';
                        position++;
                    } else if (dollarVal === '0') {
                        substitute += regexMatch.match;
                        position++;
                    } else {
                        var maxDigits;
                        if(regexMatch.groups.length === 0) {
                            // no sub-matches; any $ followed by a digit will be replaced by an empty string
                            maxDigits = 1;
                        } else {
                            // max number of digits to parse following the $
                            maxDigits = Math.floor(Math.log(regexMatch.groups.length) * Math.LOG10E) + 1;
                        }
                        index = parseInt(replacement.substring(position, position + maxDigits), 10);
                        if(maxDigits > 1 && index > regexMatch.groups.length) {
                            index = parseInt(replacement.substring(position, position + maxDigits - 1), 10);
                        }
                        if (!isNaN(index)) {
                            if(regexMatch.groups.length > 0 ) {
                                var submatch = regexMatch.groups[index - 1];
                                if (typeof submatch !== 'undefined') {
                                    substitute += submatch;
                                }
                            }
                            position += index.toString().length;
                        } else {
                            // not a capture group, treat the $ as literal
                            substitute += '$';
                        }
                    }
                    index = replacement.indexOf('$', position);
                }
                substitute += replacement.substring(position);
                return substitute;
            };
        } else {
            replacer = replacement;
        }

        var result = '';
        var position = 0;

        if(typeof limit === 'undefined' || limit > 0) {
            var count = 0;
            if(typeof pattern === 'string') {
                var index = str.indexOf(pattern, position);
                while(index !== -1 && (typeof limit === 'undefined' || count < limit)) {
                    result += str.substring(position, index);
                    result += replacement;
                    position = index + pattern.length;
                    count++;
                    index = str.indexOf(pattern, position);
                }
                result += str.substring(position);
            } else {
                var matches = pattern(str);
                if (typeof matches !== 'undefined') {
                    while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {
                        result += str.substring(position, matches.start);
                        var replacedWith = yield * apply(replacer, [matches], null);
                        // check replacedWith is a string
                        if(typeof replacedWith === 'string') {
                            result += replacedWith;
                        } else {
                            // not a string - throw error
                            throw {
                                code: "D3012",
                                stack: (new Error()).stack,
                                value: replacedWith
                            };
                        }
                        position = matches.start + matches.match.length;
                        count++;
                        matches = matches.next();
                    }
                    result += str.substring(position);
                } else {
                    result = str;
                }
            }
        } else {
            result = str;
        }

        return result;
    }

    /**
     * Base64 encode a string
     * @param {String} str - string
     * @returns {String} Base 64 encoding of the binary data
     */
    function functionBase64encode(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }
        // Use btoa in a browser, or Buffer in Node.js

        var btoa = typeof window !== 'undefined' ?
            /* istanbul ignore next */ window.btoa :
            function(str) {
                // Simply doing `new Buffer` at this point causes Browserify to pull
                // in the entire Buffer browser library, which is large and unnecessary.
                // Using `global.Buffer` defeats this.
                return new global.Buffer(str, 'binary').toString('base64');
            };
        return btoa(str);
    }

    /**
     * Base64 decode a string
     * @param {String} str - string
     * @returns {String} Base 64 encoding of the binary data
     */
    function functionBase64decode(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }
        // Use btoa in a browser, or Buffer in Node.js
        var atob = typeof window !== 'undefined' ?
            /* istanbul ignore next */ window.atob :
            function(str) {
                // Simply doing `new Buffer` at this point causes Browserify to pull
                // in the entire Buffer browser library, which is large and unnecessary.
                // Using `global.Buffer` defeats this.
                return new global.Buffer(str, 'base64').toString('binary');
            };
        return atob(str);
    }

    /**
     * Split a string into an array of substrings
     * @param {String} str - string
     * @param {String} separator - the token or regex that splits the string
     * @param {Integer} [limit] - max number of substrings
     * @returns {Array} The array of string
     */
    function functionSplit(str, separator, limit) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        // limit, if specified, must be a non-negative number
        if(limit < 0) {
            throw {
                code: "D3020",
                stack: (new Error()).stack,
                value: limit,
                index: 3
            };
        }

        var result = [];

        if(typeof limit === 'undefined' || limit > 0) {
            if (typeof separator === 'string') {
                result = str.split(separator, limit);
            } else {
                var count = 0;
                var matches = separator(str);
                if (typeof matches !== 'undefined') {
                    var start = 0;
                    while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {
                        result.push(str.substring(start, matches.start));
                        start = matches.end;
                        matches = matches.next();
                        count++;
                    }
                    if(typeof limit === 'undefined' || count < limit) {
                        result.push(str.substring(start));
                    }
                } else {
                    result = [str];
                }
            }
        }

        return result;
    }

    /**
     * Join an array of strings
     * @param {Array} strs - array of string
     * @param {String} [separator] - the token that splits the string
     * @returns {String} The concatenated string
     */
    function functionJoin(strs, separator) {
        // undefined inputs always return undefined
        if(typeof strs === 'undefined') {
            return undefined;
        }

        // if separator is not specified, default to empty string
        if(typeof separator === 'undefined') {
            separator = "";
        }

        return strs.join(separator);
    }

    /**
     * Formats a number into a decimal string representation using XPath 3.1 F&O fn:format-number spec
     * @param {number} value - number to format
     * @param {String} picture - picture string definition
     * @param {Object} [options] - override locale defaults
     * @returns {String} The formatted string
     */
    function functionFormatNumber(value, picture, options) {
        var defaults = {
            "decimal-separator": ".",
            "grouping-separator": ",",
            "exponent-separator": "e",
            "infinity": "Infinity",
            "minus-sign": "-",
            "NaN": "NaN",
            "percent": "%",
            "per-mille": "\u2030",
            "zero-digit": "0",
            "digit": "#",
            "pattern-separator": ";"
        };

        // if `options` is specified, then its entries override defaults
        var properties = defaults;
        if(typeof options !== 'undefined') {
            Object.keys(options).forEach(function (key) {
                properties[key] = options[key];
            });
        }

        var decimalDigitFamily = [];
        var zeroCharCode = properties['zero-digit'].charCodeAt(0);
        for(var ii = zeroCharCode; ii < zeroCharCode + 10; ii++) {
            decimalDigitFamily.push(String.fromCharCode(ii));
        }

        var activeChars = decimalDigitFamily.concat([properties['decimal-separator'], properties['exponent-separator'], properties['grouping-separator'], properties.digit, properties['pattern-separator']]);

        var subPictures = picture.split(properties['pattern-separator']);

        if(subPictures.length > 2) {
            throw {
                code: 'D3080',
                stack: (new Error()).stack
            };
        }

        var splitParts = function(subpicture) {
            var prefix = (function() {
                var ch;
                for(var ii = 0; ii < subpicture.length; ii++) {
                    ch = subpicture.charAt(ii);
                    if(activeChars.indexOf(ch) !== -1 && ch !== properties['exponent-separator']) {
                        return subpicture.substring(0, ii);
                    }
                }
            })();
            var suffix = (function() {
                var ch;
                for(var ii = subpicture.length - 1; ii >= 0; ii--) {
                    ch = subpicture.charAt(ii);
                    if(activeChars.indexOf(ch) !== -1 && ch !== properties['exponent-separator']) {
                        return subpicture.substring(ii + 1);
                    }
                }
            })();
            var activePart = subpicture.substring(prefix.length, subpicture.length - suffix.length);
            var mantissaPart, exponentPart, integerPart, fractionalPart;
            var exponentPosition = subpicture.indexOf(properties['exponent-separator'], prefix.length);
            if(exponentPosition === -1 || exponentPosition > subpicture.length - suffix.length) {
                mantissaPart = activePart;
                exponentPart = undefined;
            } else {
                mantissaPart = activePart.substring(0, exponentPosition);
                exponentPart = activePart.substring(exponentPosition + 1);
            }
            var decimalPosition = mantissaPart.indexOf(properties['decimal-separator']);
            if(decimalPosition === -1) {
                integerPart = mantissaPart;
                fractionalPart = suffix;
            } else {
                integerPart = mantissaPart.substring(0, decimalPosition);
                fractionalPart = mantissaPart.substring(decimalPosition + 1);
            }
            return {
                prefix: prefix,
                suffix: suffix,
                activePart: activePart,
                mantissaPart: mantissaPart,
                exponentPart: exponentPart,
                integerPart: integerPart,
                fractionalPart: fractionalPart,
                subpicture: subpicture
            };
        };

        // validate the picture string, F&O 4.7.3
        var validate = function(parts) {
            var error;
            var ii;
            var subpicture = parts.subpicture;
            var decimalPos = subpicture.indexOf(properties['decimal-separator']);
            if(decimalPos !== subpicture.lastIndexOf(properties['decimal-separator'])) {
                error = 'D3081';
            }
            if(subpicture.indexOf(properties.percent) !== subpicture.lastIndexOf(properties.percent)) {
                error = 'D3082';
            }
            if(subpicture.indexOf(properties['per-mille']) !== subpicture.lastIndexOf(properties['per-mille'])) {
                error = 'D3083';
            }
            if(subpicture.indexOf(properties.percent) !== -1 && subpicture.indexOf(properties['per-mille']) !== -1) {
                error = 'D3084';
            }
            var valid = false;
            for(ii = 0; ii < parts.mantissaPart.length; ii++) {
                var ch = parts.mantissaPart.charAt(ii);
                if(decimalDigitFamily.indexOf(ch) !== -1 || ch === properties.digit) {
                    valid = true;
                    break;
                }
            }
            if(!valid) {
                error = 'D3085';
            }
            var charTypes = parts.activePart.split('').map(function(char) {
                return activeChars.indexOf(char) === -1 ? 'p' : 'a';
            }).join('');
            if(charTypes.indexOf('p') !== -1) {
                error = 'D3086';
            }
            if(decimalPos !== -1) {
                if(subpicture.charAt(decimalPos - 1) === properties['grouping-separator'] || subpicture.charAt(decimalPos + 1) === properties['grouping-separator']) {
                    error = 'D3087';
                }
            } else if(parts.integerPart.charAt(parts.integerPart.length - 1) === properties['grouping-separator']) {
                error = 'D3088';
            }
            if(subpicture.indexOf(properties['grouping-separator'] + properties['grouping-separator']) !== -1) {
                error = 'D3089';
            }
            var optionalDigitPos = parts.integerPart.indexOf(properties.digit);
            if(optionalDigitPos !== -1 && parts.integerPart.substring(0, optionalDigitPos).split('').filter(function(char) {
                return decimalDigitFamily.indexOf(char) > -1;
            }).length > 0) {
                error = 'D3090';
            }
            optionalDigitPos = parts.fractionalPart.lastIndexOf(properties.digit);
            if(optionalDigitPos !== -1 && parts.fractionalPart.substring(optionalDigitPos).split('').filter(function(char) {
                return decimalDigitFamily.indexOf(char) > -1;
            }).length > 0) {
                error = 'D3091';
            }
            var exponentExists = (typeof parts.exponentPart === 'string');
            if(exponentExists && parts.exponentPart.length > 0 && (subpicture.indexOf(properties.percent) !== -1 || subpicture.indexOf(properties['per-mille']) !== -1)) {
                error = 'D3092';
            }
            if(exponentExists && (parts.exponentPart.length === 0 || parts.exponentPart.split('').filter(function(char) {
                return decimalDigitFamily.indexOf(char) === -1;
            }).length > 0)) {
                error = 'D3093';
            }
            if(error) {
                throw {
                    code: error,
                    stack: (new Error()).stack
                };
            }
        };

        // analyse the picture string, F&O 4.7.4
        var analyse = function(parts) {
            var getGroupingPositions = function(part, toLeft) {
                var positions = [];
                var groupingPosition = part.indexOf(properties['grouping-separator']);
                while(groupingPosition !== -1) {
                    var charsToTheRight = (toLeft ? part.substring(0, groupingPosition) : part.substring(groupingPosition)).split('').filter(function(char) {
                        return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit;
                    }).length;
                    positions.push(charsToTheRight);
                    groupingPosition = parts.integerPart.indexOf(properties['grouping-separator'], groupingPosition + 1);
                }
                return positions;
            };
            var integerPartGroupingPositions = getGroupingPositions(parts.integerPart);
            var regular = function(indexes) {
                // are the grouping positions regular? i.e. same interval between each of them
                if(indexes.length === 0) {
                    return 0;
                }
                var gcd = function(a, b) {
                    return b === 0 ? a : gcd(b, a % b);
                };
                // find the greatest common divisor of all the positions
                var factor = indexes.reduce(gcd);
                // is every position separated by this divisor? If so, it's regular
                for(var index = 1; index <= indexes.length; index++) {
                    if(indexes.indexOf(index * factor) === -1) {
                        return 0;
                    }
                }
                return factor;
            };

            var regularGrouping = regular(integerPartGroupingPositions);
            var fractionalPartGroupingPositions = getGroupingPositions(parts.fractionalPart, true);

            var minimumIntegerPartSize = parts.integerPart.split('').filter(function(char) { return decimalDigitFamily.indexOf(char) !== -1; }).length;
            var scalingFactor = minimumIntegerPartSize;

            var fractionalPartArray = parts.fractionalPart.split('');
            var minimumFactionalPartSize = fractionalPartArray.filter(function(char) { return decimalDigitFamily.indexOf(char) !== -1; }).length;
            var maximumFactionalPartSize = fractionalPartArray.filter(function(char) { return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit; }).length;
            var exponentPresent = typeof parts.exponentPart === 'string';
            if(minimumIntegerPartSize === 0 && maximumFactionalPartSize === 0) {
                if(exponentPresent) {
                    minimumFactionalPartSize = 1;
                    maximumFactionalPartSize = 1;
                } else {
                    minimumIntegerPartSize = 1;
                }
            }
            if(exponentPresent && minimumIntegerPartSize === 0 && parts.integerPart.indexOf(properties.digit) !== -1) {
                minimumIntegerPartSize = 1;
            }
            if(minimumIntegerPartSize === 0 && minimumFactionalPartSize === 0) {
                minimumFactionalPartSize = 1;
            }
            var minimumExponentSize = 0;
            if(exponentPresent) {
                minimumExponentSize = parts.exponentPart.split('').filter(function(char) { return decimalDigitFamily.indexOf(char) !== -1; }).length;
            }

            return {
                integerPartGroupingPositions: integerPartGroupingPositions,
                regularGrouping: regularGrouping,
                minimumIntegerPartSize: minimumIntegerPartSize,
                scalingFactor: scalingFactor,
                prefix: parts.prefix,
                fractionalPartGroupingPositions: fractionalPartGroupingPositions,
                minimumFactionalPartSize: minimumFactionalPartSize,
                maximumFactionalPartSize: maximumFactionalPartSize,
                minimumExponentSize: minimumExponentSize,
                suffix: parts.suffix,
                picture: parts.subpicture
            };
        };

        var parts = subPictures.map(splitParts);
        parts.forEach(validate);

        var variables = parts.map(analyse);

        if(variables.length === 1) {
            variables.push(JSON.parse(JSON.stringify(variables[0])));
            variables[1].prefix = properties['minus-sign'] + variables[1].prefix;
        }

        // TODO cache the result of the analysis

        // format the number
        // bullet 1: TODO: NaN - not sure we'd ever get this in JSON
        var pic;
        // bullet 2:
        if(value >= 0) {
            pic = variables[0];
        } else {
            pic = variables[1];
        }
        var adjustedNumber;
        // bullet 3:
        if(pic.picture.indexOf(properties.percent) !== -1) {
            adjustedNumber = value * 100;
        } else if(pic.picture.indexOf(properties['per-mille']) !== -1) {
            adjustedNumber = value * 1000;
        } else {
            adjustedNumber = value;
        }
        // bullet 4:
        // TODO: infinity - not sure we'd ever get this in JSON
        // bullet 5:
        var mantissa, exponent;
        if(pic.minimumExponentSize === 0) {
            mantissa = adjustedNumber;
        } else {
            // mantissa * 10^exponent = adjustedNumber
            var maxMantissa = Math.pow(10, pic.scalingFactor);
            var minMantissa = Math.pow(10, pic.scalingFactor - 1);
            mantissa = adjustedNumber;
            exponent = 0;
            while(mantissa < minMantissa) {
                mantissa *= 10;
                exponent -= 1;
            }
            while(mantissa > maxMantissa) {
                mantissa /= 10;
                exponent += 1;
            }
        }
        // bullet 6:
        var roundedNumber = functionRound(mantissa, pic.maximumFactionalPartSize);
        // bullet 7:
        var makeString = function(value, dp) {
            var str = Math.abs(value).toFixed(dp);
            if (properties['zero-digit'] !== '0') {
                str = str.split('').map(function (digit) {
                    if(digit >= '0' && digit <='9') {
                        return decimalDigitFamily[digit.charCodeAt(0) - 48];
                    } else {
                        return digit;
                    }
                }).join('');
            }
            return str;
        };
        var stringValue = makeString(roundedNumber, pic.maximumFactionalPartSize);
        var decimalPos = stringValue.indexOf('.');
        if(decimalPos === -1) {
            stringValue = stringValue + properties['decimal-separator'];
        } else {
            stringValue = stringValue.replace('.', properties['decimal-separator']);
        }
        while(stringValue.charAt(0) === properties['zero-digit']) {
            stringValue = stringValue.substring(1);
        }
        while(stringValue.charAt(stringValue.length - 1) === properties['zero-digit']) {
            stringValue = stringValue.substring(0, stringValue.length - 1);
        }
        // bullets 8 & 9:
        decimalPos = stringValue.indexOf(properties['decimal-separator']);
        var padLeft = pic.minimumIntegerPartSize - decimalPos;
        var padRight = pic.minimumFactionalPartSize - (stringValue.length - decimalPos - 1);
        stringValue = (padLeft > 0 ? new Array(padLeft + 1).join('0') : '') + stringValue;
        stringValue = stringValue + (padRight > 0 ? new Array(padRight + 1).join('0') : '');
        decimalPos = stringValue.indexOf(properties['decimal-separator']);
        // bullet 10:
        if(pic.regularGrouping > 0) {
            var groupCount = Math.floor((decimalPos - 1) / pic.regularGrouping);
            for(var group = 1; group <= groupCount; group++) {
                stringValue = [stringValue.slice(0, decimalPos - group * pic.regularGrouping), properties['grouping-separator'], stringValue.slice(decimalPos - group * pic.regularGrouping)].join('');
            }
        } else {
            pic.integerPartGroupingPositions.forEach(function (pos) {
                stringValue = [stringValue.slice(0, decimalPos - pos), properties['grouping-separator'], stringValue.slice(decimalPos - pos)].join('');
                decimalPos++;
            });
        }
        // bullet 11:
        decimalPos = stringValue.indexOf(properties['decimal-separator']);
        pic.fractionalPartGroupingPositions.forEach(function(pos) {
            stringValue = [stringValue.slice(0, pos + decimalPos + 1), properties['grouping-separator'], stringValue.slice(pos + decimalPos + 1)].join('');
        });
        // bullet 12:
        decimalPos = stringValue.indexOf(properties['decimal-separator']);
        if(pic.picture.indexOf(properties['decimal-separator']) === -1 || decimalPos === stringValue.length - 1) {
            stringValue = stringValue.substring(0, stringValue.length - 1);
        }
        // bullet 13:
        if(typeof exponent !== 'undefined') {
            var stringExponent = makeString(exponent, 0);
            padLeft = pic.minimumExponentSize - stringExponent.length;
            if(padLeft > 0) {
                stringExponent = new Array(padLeft + 1).join('0') + stringExponent;
            }
            stringValue = stringValue + properties['exponent-separator'] + (exponent < 0 ? properties['minus-sign'] : '') + stringExponent;
        }
        // bullet 14:
        stringValue = pic.prefix + stringValue + pic.suffix;
        return stringValue;
    }

    /**
     * Converts a number to a string using a specified number base
     * @param {string} value - the number to convert
     * @param {number} [radix] - the number base; must be between 2 and 36. Defaults to 10
     * @returns {string} - the converted string
     */
    function functionFormatBase(value, radix) {
        // undefined inputs always return undefined
        if(typeof value === 'undefined') {
            return undefined;
        }

        value = functionRound(value);

        if(typeof radix === 'undefined') {
            radix = 10;
        } else {
            radix = functionRound(radix);
        }

        if(radix < 2 || radix > 36) {
            throw {
                code: 'D3100',
                stack: (new Error()).stack,
                value: radix
            };

        }

        var result = value.toString(radix);

        return result;
    }

    /**
     * Cast argument to number
     * @param {Object} arg - Argument
     * @returns {Number} numeric value of argument
     */
    function functionNumber(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        if (typeof arg === 'number') {
            // already a number
            result = arg;
        } else if(typeof arg === 'string' && /^-?(0|([1-9][0-9]*))(\.[0-9]+)?([Ee][-+]?[0-9]+)?$/.test(arg) && !isNaN(parseFloat(arg)) && isFinite(arg)) {
            result = parseFloat(arg);
        } else {
            throw {
                code: "D3030",
                value: arg,
                stack: (new Error()).stack,
                index: 1
            };
        }
        return result;
    }

    /**
     * Absolute value of a number
     * @param {Number} arg - Argument
     * @returns {Number} absolute value of argument
     */
    function functionAbs(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        result = Math.abs(arg);
        return result;
    }

    /**
     * Rounds a number down to integer
     * @param {Number} arg - Argument
     * @returns {Number} rounded integer
     */
    function functionFloor(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        result = Math.floor(arg);
        return result;
    }

    /**
     * Rounds a number up to integer
     * @param {Number} arg - Argument
     * @returns {Number} rounded integer
     */
    function functionCeil(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        result = Math.ceil(arg);
        return result;
    }

    /**
     * Round to half even
     * @param {Number} arg - Argument
     * @param {Number} precision - number of decimal places
     * @returns {Number} rounded integer
     */
    function functionRound(arg, precision) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        if(precision) {
            // shift the decimal place - this needs to be done in a string since multiplying
            // by a power of ten can introduce floating point precision errors which mess up
            // this rounding algorithm - See 'Decimal rounding' in
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round
            // Shift
            var value = arg.toString().split('e');
            arg = +(value[0] + 'e' + (value[1] ? (+value[1] + precision) : precision));

        }

        // round up to nearest int
        result = Math.round(arg);
        var diff = result - arg;
        if(Math.abs(diff) === 0.5 && Math.abs(result % 2) === 1) {
            // rounded the wrong way - adjust to nearest even number
            result = result - 1;
        }
        if(precision) {
            // Shift back
            value = result.toString().split('e');
            /* istanbul ignore next */
            result = +(value[0] + 'e' + (value[1] ? (+value[1] - precision) : -precision));
        }
        if(Object.is(result, -0)) { // ESLint rule 'no-compare-neg-zero' suggests this way
            // JSON doesn't do -0
            result = 0;
        }
        return result;
    }

    /**
     * Square root of number
     * @param {Number} arg - Argument
     * @returns {Number} square root
     */
    function functionSqrt(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        if(arg < 0) {
            throw {
                stack: (new Error()).stack,
                code: "D3060",
                index: 1,
                value: arg
            };
        }

        result = Math.sqrt(arg);

        return result;
    }

    /**
     * Raises number to the power of the second number
     * @param {Number} arg - the base
     * @param {Number} exp - the exponent
     * @returns {Number} rounded integer
     */
    function functionPower(arg, exp) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        result = Math.pow(arg, exp);

        if(!isFinite(result)) {
            throw {
                stack: (new Error()).stack,
                code: "D3061",
                index: 1,
                value: arg,
                exp: exp
            };
        }

        return result;
    }

    /**
     * Returns a random number 0 <= n < 1
     * @returns {number} random number
     */
    function functionRandom() {
        return Math.random();
    }

    /**
     * Evaluate an input and return a boolean
     * @param {*} arg - Arguments
     * @returns {boolean} Boolean
     */
    function functionBoolean(arg) {
        // cast arg to its effective boolean value
        // boolean: unchanged
        // string: zero-length -> false; otherwise -> true
        // number: 0 -> false; otherwise -> true
        // null -> false
        // array: empty -> false; length > 1 -> true
        // object: empty -> false; non-empty -> true
        // function -> false

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        var result = false;
        if (Array.isArray(arg)) {
            if (arg.length === 1) {
                result = functionBoolean(arg[0]);
            } else if (arg.length > 1) {
                var trues = arg.filter(function(val) {return functionBoolean(val);});
                result = trues.length > 0;
            }
        } else if (typeof arg === 'string') {
            if (arg.length > 0) {
                result = true;
            }
        } else if (isNumeric(arg)) {
            if (arg !== 0) {
                result = true;
            }
        } else if (arg !== null && typeof arg === 'object') {
            if (Object.keys(arg).length > 0) {
                // make sure it's not a lambda function
                if (!(isLambda(arg) || arg._jsonata_function)) {
                    result = true;
                }
            }
        } else if (typeof arg === 'boolean' && arg === true) {
            result = true;
        }
        return result;
    }

    /**
     * returns the Boolean NOT of the arg
     * @param {*} arg - argument
     * @returns {boolean} - NOT arg
     */
    function functionNot(arg) {
        return !functionBoolean(arg);
    }

    /**
     * Create a map from an array of arguments
     * @param {Array} [arr] - array to map over
     * @param {Function} func - function to apply
     * @returns {Array} Map array
     */
    function* functionMap(arr, func) {
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        var result = [];
        // do the map - iterate over the arrays, and invoke func
        for (var i = 0; i < arr.length; i++) {
            var func_args = [arr[i]]; // the first arg (value) is required
            // the other two are optional - only supply it if the function can take it
            var length = typeof func === 'function' ? func.length :
                func._jsonata_function === true ? func.implementation.length : func.arguments.length;
            if(length >= 2) {
                func_args.push(i);
            }
            if(length >= 3) {
                func_args.push(arr);
            }
            // invoke func
            var res = yield * apply(func, func_args, null);
            if(typeof res !== 'undefined') {
                result.push(res);
            }
        }

        return result;
    }

    // This generator function does not have a yield(), presumably to make it
    // consistent with other similar functions.
    /**
     * Create a map from an array of arguments
     * @param {Array} [arr] - array to filter
     * @param {Function} func - predicate function
     * @returns {Array} Map array
     */
    function* functionFilter(arr, func) { // eslint-disable-line require-yield
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        var result = [];

        var predicate = function (value, index, array) {
            var it = apply(func, [value, index, array], null);
            // returns a generator - so iterate over it
            var res = it.next();
            while (!res.done) {
                res = it.next(res.value);
            }
            return res.value;
        };

        for(var i = 0; i < arr.length; i++) {
            var entry = arr[i];
            if(functionBoolean(predicate(entry, i, arr))) {
                result.push(entry);
            }
        }

        return result;
    }

    /**
     * Convolves (zips) each value from a set of arrays
     * @param {Array} [args] - arrays to zip
     * @returns {Array} Zipped array
     */
    function functionZip() {
        // this can take a variable number of arguments
        var result = [];
        var args = Array.prototype.slice.call(arguments);
        // length of the shortest array
        var length = Math.min.apply(Math, args.map(function(arg) {
            if(Array.isArray(arg)) {
                return arg.length;
            }
            return 0;
        }));
        for(var i = 0; i < length; i++) {
            var tuple = args.map((arg) => {return arg[i];});
            result.push(tuple);
        }
        return result;
    }

    /**
     * Fold left function
     * @param {Array} sequence - Sequence
     * @param {Function} func - Function
     * @param {Object} init - Initial value
     * @returns {*} Result
     */
    function* functionFoldLeft(sequence, func, init) {
        // undefined inputs always return undefined
        if(typeof sequence === 'undefined') {
            return undefined;
        }

        var result;

        if (!(func.length === 2 || (func._jsonata_function === true && func.implementation.length === 2) || func.arguments.length === 2)) {
            throw {
                stack: (new Error()).stack,
                code: "D3050",
                index: 1
            };
        }

        var index;
        if (typeof init === 'undefined' && sequence.length > 0) {
            result = sequence[0];
            index = 1;
        } else {
            result = init;
            index = 0;
        }

        while (index < sequence.length) {
            result = yield * apply(func, [result, sequence[index]], null);
            index++;
        }

        return result;
    }

    /**
     * Return keys for an object
     * @param {Object} arg - Object
     * @returns {Array} Array of keys
     */
    function functionKeys(arg) {
        var result = [];

        if(Array.isArray(arg)) {
            // merge the keys of all of the items in the array
            var merge = {};
            arg.forEach(function(item) {
                var keys = functionKeys(item);
                if(Array.isArray(keys)) {
                    keys.forEach(function(key) {
                        merge[key] = true;
                    });
                }
            });
            result = functionKeys(merge);
        } else if(arg !== null && typeof arg === 'object' && !(isLambda(arg))) {
            result = Object.keys(arg);
            if(result.length === 0) {
                result = undefined;
            }
        } else {
            result = undefined;
        }
        return result;
    }

    /**
     * Return value from an object for a given key
     * @param {Object} object - Object
     * @param {String} key - Key in object
     * @returns {*} Value of key in object
     */
    function functionLookup(object, key) {
        var result = evaluateName({value: key}, object);
        return result;
    }

    /**
     * Append second argument to first
     * @param {Array|Object} arg1 - First argument
     * @param {Array|Object} arg2 - Second argument
     * @returns {*} Appended arguments
     */
    function functionAppend(arg1, arg2) {
        // disregard undefined args
        if (typeof arg1 === 'undefined') {
            return arg2;
        }
        if (typeof arg2 === 'undefined') {
            return arg1;
        }
        // if either argument is not an array, make it so
        if (!Array.isArray(arg1)) {
            arg1 = [arg1];
        }
        if (!Array.isArray(arg2)) {
            arg2 = [arg2];
        }
        Array.prototype.push.apply(arg1, arg2);
        return arg1;
    }

    /**
     * Determines if the argument is undefined
     * @param {*} arg - argument
     * @returns {boolean} False if argument undefined, otherwise true
     */
    function functionExists(arg){
        if (typeof arg === 'undefined') {
            return false;
        } else {
            return true;
        }
    }

    /**
     * Splits an object into an array of object with one property each
     * @param {*} arg - the object to split
     * @returns {*} - the array
     */
    function functionSpread(arg) {
        var result = [];

        if(Array.isArray(arg)) {
            // spread all of the items in the array
            arg.forEach(function(item) {
                result = functionAppend(result, functionSpread(item));
            });
        } else if(arg !== null && typeof arg === 'object' && !isLambda(arg)) {
            for(var key in arg) {
                var obj = {};
                obj[key] = arg[key];
                result.push(obj);
            }
        } else {
            result = arg;
        }
        return result;
    }

    /**
     * Merges an array of objects into a single object.  Duplicate properties are
     * overridden by entries later in the array
     * @param {*} arg - the objects to merge
     * @returns {*} - the object
     */
    function functionMerge(arg) {
        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        var result = {};

        arg.forEach(function(obj) {
            for(var prop in obj) {
                result[prop] = obj[prop];
            }
        });
        return result;
    }

    /**
     * Reverses the order of items in an array
     * @param {Array} arr - the array to reverse
     * @returns {Array} - the reversed array
     */
    function functionReverse(arr) {
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        if(arr.length <= 1) {
            return arr;
        }

        var length = arr.length;
        var result = new Array(length);
        for(var i = 0; i < length; i++) {
            result[length - i - 1] = arr[i];
        }

        return result;
    }

    /**
     *
     * @param {*} obj - the input object to iterate over
     * @param {*} func - the function to apply to each key/value pair
     * @returns {Array} - the resultant array
     */
    function* functionEach(obj, func) {
        var result = [];

        for(var key in obj) {
            var func_args = [obj[key], key];
            // invoke func
            result.push(yield * apply(func, func_args, null));
        }

        return result;
    }

    /**
     * Implements the merge sort (stable) with optional comparator function
     *
     * @param {Array} arr - the array to sort
     * @param {*} comparator - comparator function
     * @returns {Array} - sorted array
     */
    function functionSort(arr, comparator) {
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        if(arr.length <= 1) {
            return arr;
        }

        var comp;
        if(typeof comparator === 'undefined') {
            // inject a default comparator - only works for numeric or string arrays
            if (!isArrayOfNumbers(arr) && !isArrayOfStrings(arr)) {
                throw {
                    stack: (new Error()).stack,
                    code: "D3070",
                    index: 1
                };
            }

            comp = function (a, b) {
                return a > b;
            };
        } else if(typeof comparator === 'function') {
            // for internal usage of functionSort (i.e. order-by syntax)
            comp = comparator;
        } else {
            comp = function (a, b) {
                var it = apply(comparator, [a, b], null);
                // returns a generator - so iterate over it
                var comp = it.next();
                while (!comp.done) {
                    comp = it.next(comp.value);
                }
                return comp.value;
            };
        }

        var merge = function(l, r) {
            var merge_iter = function(result, left, right) {
                if (left.length === 0) {
                    Array.prototype.push.apply(result, right);
                } else if (right.length === 0) {
                    Array.prototype.push.apply(result, left);
                } else if (comp(left[0], right[0])) { // invoke the comparator function
                    // if it returns true - swap left and right
                    result.push(right[0]);
                    merge_iter(result, left, right.slice(1));
                } else {
                    // otherwise keep the same order
                    result.push(left[0]);
                    merge_iter(result, left.slice(1), right);
                }
            };
            var merged = [];
            merge_iter(merged, l, r);
            return merged;
        };

        var sort = function(array) {
            if(array.length <= 1) {
                return array;
            } else {
                var middle = Math.floor(array.length / 2);
                var left = array.slice(0, middle);
                var right = array.slice(middle);
                left = sort(left);
                right = sort(right);
                return merge(left, right);
            }
        };

        var result = sort(arr);

        return result;
    }

    /**
     * Randomly shuffles the contents of an array
     * @param {Array} arr - the input array
     * @returns {Array} the shuffled array
     */
    function functionShuffle(arr) {
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        if(arr.length <= 1) {
            return arr;
        }

        // shuffle using the 'inside-out' variant of the Fisher-Yates algorithm
        var result = new Array(arr.length);
        for(var i = 0; i < arr.length; i++) {
            var j = Math.floor(Math.random() * (i + 1)); // random integer such that 0 â¤ j â¤ i
            if(i !== j) {
                result[i] = result[j];
            }
            result[j] = arr[i];
        }

        return result;
    }

    /**
     * Applies a predicate function to each key/value pair in an object, and returns an object containing
     * only the key/value pairs that passed the predicate
     *
     * @param {object} arg - the object to be sifted
     * @param {object} func - the predicate function (lambda or native)
     * @returns {object} - sifted object
     */
    function functionSift(arg, func) {
        var result = {};

        var predicate = function (value, key, object) {
            var it = apply(func, [value, key, object], null);
            // returns a generator - so iterate over it
            var res = it.next();
            while (!res.done) {
                res = it.next(res.value);
            }
            return res.value;
        };

        for(var item in arg) {
            var entry = arg[item];
            if(functionBoolean(predicate(entry, item, arg))) {
                result[item] = entry;
            }
        }

        // empty objects should be changed to undefined
        if(Object.keys(result).length === 0) {
            result = undefined;
        }

        return result;
    }

    // Regular expression to match an ISO 8601 formatted timestamp
    var iso8601regex = new RegExp('^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z)$');

    /**
     * Converts an ISO 8601 timestamp to milliseconds since the epoch
     *
     * @param {string} timestamp - the ISO 8601 timestamp to be converted
     * @returns {Number} - milliseconds since the epoch
     */
    function functionToMillis(timestamp) {
        // undefined inputs always return undefined
        if(typeof timestamp === 'undefined') {
            return undefined;
        }

        if(!iso8601regex.test(timestamp)) {
            throw {
                stack: (new Error()).stack,
                code: "D3110",
                value: timestamp
            };
        }

        return Date.parse(timestamp);
    }

    /**
     * Converts milliseconds since the epoch to an ISO 8601 timestamp
     * @param {Number} millis - milliseconds since the epoch to be converted
     * @returns {String} - an ISO 8601 formatted timestamp
     */
    function functionFromMillis(millis) {
        // undefined inputs always return undefined
        if(typeof millis === 'undefined') {
            return undefined;
        }

        return new Date(millis).toISOString();
    }

    /**
     * Clones an object
     * @param {Object} arg - object to clone (deep copy)
     * @returns {*} - the cloned object
     */
    function functionClone(arg) {
        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        return JSON.parse(functionString(arg));
    }

    /**
     * Create frame
     * @param {Object} enclosingEnvironment - Enclosing environment
     * @returns {{bind: bind, lookup: lookup}} Created frame
     */
    function createFrame(enclosingEnvironment) {
        var bindings = {};
        return {
            bind: function (name, value) {
                bindings[name] = value;
            },
            lookup: function (name) {
                var value;
                if(bindings.hasOwnProperty(name)) {
                    value = bindings[name];
                } else if (enclosingEnvironment) {
                    value = enclosingEnvironment.lookup(name);
                }
                return value;
            }
        };
    }

    // Function registration
    staticFrame.bind('sum', defineFunction(functionSum, '<a<n>:n>'));
    staticFrame.bind('count', defineFunction(functionCount, '<a:n>'));
    staticFrame.bind('max', defineFunction(functionMax, '<a<n>:n>'));
    staticFrame.bind('min', defineFunction(functionMin, '<a<n>:n>'));
    staticFrame.bind('average', defineFunction(functionAverage, '<a<n>:n>'));
    staticFrame.bind('string', defineFunction(functionString, '<x-:s>'));
    staticFrame.bind('substring', defineFunction(functionSubstring, '<s-nn?:s>'));
    staticFrame.bind('substringBefore', defineFunction(functionSubstringBefore, '<s-s:s>'));
    staticFrame.bind('substringAfter', defineFunction(functionSubstringAfter, '<s-s:s>'));
    staticFrame.bind('lowercase', defineFunction(functionLowercase, '<s-:s>'));
    staticFrame.bind('uppercase', defineFunction(functionUppercase, '<s-:s>'));
    staticFrame.bind('length', defineFunction(functionLength, '<s-:n>'));
    staticFrame.bind('trim', defineFunction(functionTrim, '<s-:s>'));
    staticFrame.bind('pad', defineFunction(functionPad, '<s-ns?:s>'));
    staticFrame.bind('match', defineFunction(functionMatch, '<s-f<s:o>n?:a<o>>'));
    staticFrame.bind('contains', defineFunction(functionContains, '<s-(sf):b>')); // TODO <s-(sf<s:o>):b>
    staticFrame.bind('replace', defineFunction(functionReplace, '<s-(sf)(sf)n?:s>')); // TODO <s-(sf<s:o>)(sf<o:s>)n?:s>
    staticFrame.bind('split', defineFunction(functionSplit, '<s-(sf)n?:a<s>>')); // TODO <s-(sf<s:o>)n?:a<s>>
    staticFrame.bind('join', defineFunction(functionJoin, '<a<s>s?:s>'));
    staticFrame.bind('formatNumber', defineFunction(functionFormatNumber, '<n-so?:s>'));
    staticFrame.bind('formatBase', defineFunction(functionFormatBase, '<n-n?:s>'));
    staticFrame.bind('number', defineFunction(functionNumber, '<(ns)-:n>'));
    staticFrame.bind('floor', defineFunction(functionFloor, '<n-:n>'));
    staticFrame.bind('ceil', defineFunction(functionCeil, '<n-:n>'));
    staticFrame.bind('round', defineFunction(functionRound, '<n-n?:n>'));
    staticFrame.bind('abs', defineFunction(functionAbs, '<n-:n>'));
    staticFrame.bind('sqrt', defineFunction(functionSqrt, '<n-:n>'));
    staticFrame.bind('power', defineFunction(functionPower, '<n-n:n>'));
    staticFrame.bind('random', defineFunction(functionRandom, '<:n>'));
    staticFrame.bind('boolean', defineFunction(functionBoolean, '<x-:b>'));
    staticFrame.bind('not', defineFunction(functionNot, '<x-:b>'));
    staticFrame.bind('map', defineFunction(functionMap, '<af>'));
    staticFrame.bind('zip', defineFunction(functionZip, '<a+>'));
    staticFrame.bind('filter', defineFunction(functionFilter, '<af>'));
    staticFrame.bind('reduce', defineFunction(functionFoldLeft, '<afj?:j>')); // TODO <f<jj:j>a<j>j?:j>
    staticFrame.bind('sift', defineFunction(functionSift, '<o-f?:o>'));
    staticFrame.bind('keys', defineFunction(functionKeys, '<x-:a<s>>'));
    staticFrame.bind('lookup', defineFunction(functionLookup, '<x-s:x>'));
    staticFrame.bind('append', defineFunction(functionAppend, '<xx:a>'));
    staticFrame.bind('exists', defineFunction(functionExists, '<x:b>'));
    staticFrame.bind('spread', defineFunction(functionSpread, '<x-:a<o>>'));
    staticFrame.bind('merge', defineFunction(functionMerge, '<a<o>:o>'));
    staticFrame.bind('reverse', defineFunction(functionReverse, '<a:a>'));
    staticFrame.bind('each', defineFunction(functionEach, '<o-f:a>'));
    staticFrame.bind('sort', defineFunction(functionSort, '<af?:a>'));
    staticFrame.bind('shuffle', defineFunction(functionShuffle, '<a:a>'));
    staticFrame.bind('base64encode', defineFunction(functionBase64encode, '<s-:s>'));
    staticFrame.bind('base64decode', defineFunction(functionBase64decode, '<s-:s>'));
    staticFrame.bind('toMillis', defineFunction(functionToMillis, '<s-:n>'));
    staticFrame.bind('fromMillis', defineFunction(functionFromMillis, '<n-:s>'));
    staticFrame.bind('clone', defineFunction(functionClone, '<(oa)-:o>'));

    /**
     * Error codes
     *
     */
    var errorCodes = {
        "S0101": "String literal must be terminated by a matching quote",
        "S0102": "Number out of range: {{token}}",
        "S0103": "Unsupported escape sequence: \\{{token}}",
        "S0104": "The escape sequence \\u must be followed by 4 hex digits",
        "S0105": "Quoted property name must be terminated with a backquote (`)",
        "S0201": "Syntax error: {{token}}",
        "S0202": "Expected {{value}}, got {{token}}",
        "S0203": "Expected {{value}} before end of expression",
        "S0204": "Unknown operator: {{token}}",
        "S0205": "Unexpected token: {{token}}",
        "S0206": "Unknown expression type: {{token}}",
        "S0207": "Unexpected end of expression",
        "S0208": "Parameter {{value}} of function definition must be a variable name (start with $)",
        "S0209": "A predicate cannot follow a grouping expression in a step",
        "S0210": "Each step can only have one grouping expression",
        "S0211": "The symbol {{token}} cannot be used as a unary operator",
        "S0301": "Empty regular expressions are not allowed",
        "S0302": "No terminating / in regular expression",
        "S0402": "Choice groups containing parameterized types are not supported",
        "S0401": "Type parameters can only be applied to functions and arrays",
        "S0500": "Attempted to evaluate an expression containing syntax error(s)",
        "T0410": "Argument {{index}} of function {{token}} does not match function signature",
        "T0411": "Context value is not a compatible type with argument {{index}} of function {{token}}",
        "T0412": "Argument {{index}} of function {{token}} must be an array of {{type}}",
        "D1001": "Number out of range: {{value}}",
        "D1002": "Cannot negate a non-numeric value: {{value}}",
        "T1003": "Key in object structure must evaluate to a string; got: {{value}}",
        "D1004": "Regular expression matches zero length string",
        "T1005": "Attempted to invoke a non-function. Did you mean ${{{token}}}?",
        "T1006": "Attempted to invoke a non-function",
        "T1007": "Attempted to partially apply a non-function. Did you mean ${{{token}}}?",
        "T1008": "Attempted to partially apply a non-function",
        "T2001": "The left side of the {{token}} operator must evaluate to a number",
        "T2002": "The right side of the {{token}} operator must evaluate to a number",
        "T2003": "The left side of the range operator (..) must evaluate to an integer",
        "T2004": "The right side of the range operator (..) must evaluate to an integer",
        "D2005": "The left side of := must be a variable name (start with $)",
        "T2006": "The right side of the function application operator ~> must be a function",
        "T2007": "Type mismatch when comparing values {{value}} and {{value2}} in order-by clause",
        "T2008": "The expressions within an order-by clause must evaluate to numeric or string values",
        "T2009": "The values {{value}} and {{value2}} either side of operator {{token}} must be of the same data type",
        "T2010": "The expressions either side of operator {{token}} must evaluate to numeric or string values",
        "T2011": "The insert/update clause of the transform expression must evaluate to an object: {{value}}",
        "T2012": "The delete clause of the transform expression must evaluate to a string or array of strings: {{value}}",
        "T2013": "The transform expression clones the input object using the $clone() function.  This has been overridden in the current scope by a non-function.",
        "D3001": "Attempting to invoke string function on Infinity or NaN",
        "D3010": "Second argument of replace function cannot be an empty string",
        "D3011": "Fourth argument of replace function must evaluate to a positive number",
        "D3012": "Attempted to replace a matched string with a non-string value",
        "D3020": "Third argument of split function must evaluate to a positive number",
        "D3030": "Unable to cast value to a number: {{value}}",
        "D3040": "Third argument of match function must evaluate to a positive number",
        "D3050": "First argument of reduce function must be a function with two arguments",
        "D3060": "The sqrt function cannot be applied to a negative number: {{value}}",
        "D3061": "The power function has resulted in a value that cannot be represented as a JSON number: base={{value}}, exponent={{exp}}",
        "D3070": "The single argument form of the sort function can only be applied to an array of strings or an array of numbers.  Use the second argument to specify a comparison function",
        "D3080": "The picture string must only contain a maximum of two sub-pictures",
        "D3081": "The sub-picture must not contain more than one instance of the 'decimal-separator' character",
        "D3082": "The sub-picture must not contain more than one instance of the 'percent' character",
        "D3083": "The sub-picture must not contain more than one instance of the 'per-mille' character",
        "D3084": "The sub-picture must not contain both a 'percent' and a 'per-mille' character",
        "D3085": "The mantissa part of a sub-picture must contain at least one character that is either an 'optional digit character' or a member of the 'decimal digit family'",
        "D3086": "The sub-picture must not contain a passive character that is preceded by an active character and that is followed by another active character",
        "D3087": "The sub-picture must not contain a 'grouping-separator' character that appears adjacent to a 'decimal-separator' character",
        "D3088": "The sub-picture must not contain a 'grouping-separator' at the end of the integer part",
        "D3089": "The sub-picture must not contain two adjacent instances of the 'grouping-separator' character",
        "D3090": "The integer part of the sub-picture must not contain a member of the 'decimal digit family' that is followed by an instance of the 'optional digit character'",
        "D3091": "The fractional part of the sub-picture must not contain an instance of the 'optional digit character' that is followed by a member of the 'decimal digit family'",
        "D3092": "A sub-picture that contains a 'percent' or 'per-mille' character must not contain a character treated as an 'exponent-separator'",
        "D3093": "The exponent part of the sub-picture must comprise only of one or more characters that are members of the 'decimal digit family'",
        "D3100": "The radix of the formatBase function must be between 2 and 36.  It was given {{value}}",
        "D3110": "The argument of the toMillis function must be an ISO 8601 formatted timestamp. Given {{value}}"
    };

    /**
     * lookup a message template from the catalog and substitute the inserts
     * @param {string} err - error code to lookup
     * @returns {string} message
     */
    function lookupMessage(err) {
        var message = 'Unknown error';
        if(typeof err.message !== 'undefined') {
            message = err.message;
        }
        var template = errorCodes[err.code];
        if(typeof template !== 'undefined') {
            // if there are any handlebars, replace them with the field references
            // triple braces - replace with value
            // double braces - replace with json stringified value
            message = template.replace(/\{\{\{([^}]+)}}}/g, function() {
                return err[arguments[1]];
            });
            message = message.replace(/\{\{([^}]+)}}/g, function() {
                return JSON.stringify(err[arguments[1]]);
            });
        }
        return message;
    }

    /**
     * JSONata
     * @param {Object} expr - JSONata expression
     * @param {boolean} options - recover: attempt to recover on parse error
     * @returns {{evaluate: evaluate, assign: assign}} Evaluated expression
     */
    function jsonata(expr, options) {
        var ast;
        var errors;
        try {
            ast = parser(expr, options && options.recover);
            errors = ast.errors;
            delete ast.errors;
        } catch(err) {
            // insert error message into structure
            err.message = lookupMessage(err);
            throw err;
        }
        var environment = createFrame(staticFrame);

        var timestamp = new Date(); // will be overridden on each call to evalute()
        environment.bind('now', defineFunction(function() {
            return timestamp.toJSON();
        }, '<:s>'));
        environment.bind('millis', defineFunction(function() {
            return timestamp.getTime();
        }, '<:n>'));

        return {
            evaluate: function (input, bindings, callback) {
                // throw if the expression compiled with syntax errors
                if(typeof errors !== 'undefined') {
                    var err = {
                        code: 'S0500',
                        position: 0
                    };
                    err.message = lookupMessage(err);
                    throw err;
                }

                if (typeof bindings !== 'undefined') {
                    var exec_env;
                    // the variable bindings have been passed in - create a frame to hold these
                    exec_env = createFrame(environment);
                    for (var v in bindings) {
                        exec_env.bind(v, bindings[v]);
                    }
                } else {
                    exec_env = environment;
                }
                // put the input document into the environment as the root object
                exec_env.bind('$', input);

                // capture the timestamp and put it in the execution environment
                // the $now() and $millis() functions will return this value - whenever it is called
                timestamp = new Date();

                var result, it;
                // if a callback function is supplied, then drive the generator in a promise chain
                if(typeof callback === 'function') {
                    exec_env.bind('__jsonata_async', true);
                    var thenHandler = function (response) {
                        result = it.next(response);
                        if (result.done) {
                            callback(null, result.value);
                        } else {
                            result.value.then(thenHandler)
                                .catch(function (err) {
                                    err.message = lookupMessage(err);
                                    callback(err, null);
                                });
                        }
                    };
                    it = evaluate(ast, input, exec_env);
                    result = it.next();
                    result.value.then(thenHandler);
                } else {
                    // no callback function - drive the generator to completion synchronously
                    try {
                        it = evaluate(ast, input, exec_env);
                        result = it.next();
                        while (!result.done) {
                            result = it.next(result.value);
                        }
                        return result.value;
                    } catch (err) {
                        // insert error message into structure
                        err.message = lookupMessage(err);
                        throw err;
                    }
                }
            },
            assign: function (name, value) {
                environment.bind(name, value);
            },
            registerFunction: function(name, implementation, signature) {
                var func = defineFunction(implementation, signature);
                environment.bind(name, func);
            },
            ast: function() {
                return ast;
            },
            errors: function() {
                return errors;
            }
        };
    }

    jsonata.parser = parser; // TODO remove this in a future release - use ast() instead

    return jsonata;

})();

// node.js only - export the jsonata and parser functions
// istanbul ignore else
if(typeof module !== 'undefined') {
    module.exports = jsonata;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],66:[function(require,module,exports){
(function (process){
'use strict';

var loglevel = require('loglevel');
var chalk = require('chalk');

var loggers = {};

module.exports = getLogger;

function getLogger() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$level = _ref.level,
      level = _ref$level === undefined ? getDefaultLevel() : _ref$level,
      _ref$prefix = _ref.prefix,
      prefix = _ref$prefix === undefined ? '' : _ref$prefix;

  if (loggers[prefix]) {
    return loggers[prefix];
  }
  var coloredPrefix = prefix ? `${chalk.dim(prefix)} ` : '';
  var levelPrefix = {
    TRACE: chalk.dim('[TRACE]'),
    DEBUG: chalk.cyan('[DEBUG]'),
    INFO: chalk.blue('[INFO]'),
    WARN: chalk.yellow('[WARN]'),
    ERROR: chalk.red('[ERROR]')
  };

  var logger = loglevel.getLogger(`${prefix}-logger`);

  // this is the plugin "api"
  var originalFactory = logger.methodFactory;
  logger.methodFactory = methodFactory;

  var originalSetLevel = logger.setLevel;
  logger.setLevel = setLevel;
  logger.setLevel(level);
  loggers[prefix] = logger;
  return logger;

  function methodFactory() {
    for (var _len = arguments.length, factoryArgs = Array(_len), _key = 0; _key < _len; _key++) {
      factoryArgs[_key] = arguments[_key];
    }

    var logLevel = factoryArgs[0];

    var rawMethod = originalFactory.apply(undefined, factoryArgs);
    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return rawMethod.apply(undefined, [`${coloredPrefix}${levelPrefix[logLevel.toUpperCase()]}:`].concat(args));
    };
  }

  function setLevel(levelToSetTo) {
    var persist = false; // uses browser localStorage
    return originalSetLevel.call(logger, levelToSetTo, persist);
  }
}

function getDefaultLevel() {
  var logLevel = process.env.LOG_LEVEL;

  if (logLevel === 'undefined' || !logLevel) {
    return 'warn';
  }
  return logLevel;
}
}).call(this,require('_process'))

},{"_process":3,"chalk":57,"loglevel":67}],67:[function(require,module,exports){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (typeof define === 'function' && define.amd) {
        define(definition);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = definition();
    } else {
        root.log = definition();
    }
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));

},{}],68:[function(require,module,exports){
(function (global){
var performance = global.performance || {};

var present = (function () {
  var names = ['now', 'webkitNow', 'msNow', 'mozNow', 'oNow'];
  while (names.length) {
    var name = names.shift();
    if (name in performance) {
      return performance[name].bind(performance);
    }
  }

  var dateNow = Date.now || function () { return new Date().getTime(); };
  var navigationStart = (performance.timing || {}).navigationStart || dateNow();
  return function () {
    return dateNow() - navigationStart;
  };
}());

present.performanceNow = performance.now;
present.noConflict = function () {
  performance.now = present.performanceNow;
};
present.conflict = function () {
  performance.now = present;
};
present.conflict();

module.exports = present;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],69:[function(require,module,exports){
// Export ./lib/randgen

module.exports = require("./lib/randgen");

},{"./lib/randgen":70}],70:[function(require,module,exports){
/*jslint indent: 2, plusplus: true, sloppy: true */
// Generate uniformly distributed random numbers
// Gives a random number on the interval [min, max).
// If discrete is true, the number will be an integer.
function runif(min, max, discrete) {
  if (min === undefined) {
    min = 0;
  }
  if (max === undefined) {
    max = 1;
  }
  if (discrete === undefined) {
    discrete = false;
  }
  if (discrete) {
    return Math.floor(runif(min, max, false));
  }
  return Math.random() * (max - min) + min;
}

// Generate normally-distributed random nubmers
// Algorithm adapted from:
// http://c-faq.com/lib/gaussian.html
function rnorm(mean, stdev) {
  var u1, u2, v1, v2, s;
  if (mean === undefined) {
    mean = 0.0;
  }
  if (stdev === undefined) {
    stdev = 1.0;
  }
  if (rnorm.v2 === null) {
    do {
      u1 = Math.random();
      u2 = Math.random();

      v1 = 2 * u1 - 1;
      v2 = 2 * u2 - 1;
      s = v1 * v1 + v2 * v2;
    } while (s === 0 || s >= 1);

    rnorm.v2 = v2 * Math.sqrt(-2 * Math.log(s) / s);
    return stdev * v1 * Math.sqrt(-2 * Math.log(s) / s) + mean;
  }

  v2 = rnorm.v2;
  rnorm.v2 = null;
  return stdev * v2 + mean;
}

rnorm.v2 = null;

// Generate Chi-square distributed random numbers
function rchisq(degreesOfFreedom) {
  if (degreesOfFreedom === undefined) {
    degreesOfFreedom = 1;
  }
  var i, z, sum = 0.0;
  for (i = 0; i < degreesOfFreedom; i++) {
    z = rnorm();
    sum += z * z;
  }

  return sum;
}

// Generate Poisson distributed random numbers
function rpoisson(lambda) {
  if (lambda === undefined) {
    lambda = 1;
  }
  var l = Math.exp(-lambda),
    k = 0,
    p = 1.0;
  do {
    k++;
    p *= Math.random();
  } while (p > l);

  return k - 1;
}

// Generate Cauchy distributed random numbers
function rcauchy(loc, scale) {
  if (loc === undefined) {
    loc = 0.0;
  }
  if (scale === undefined) {
    scale = 1.0;
  }
  var n2, n1 = rnorm();
  do {
    n2 = rnorm();
  } while (n2 === 0.0);

  return loc + scale * n1 / n2;
}

// Bernoulli distribution: gives 1 with probability p
function rbernoulli(p) {
  return Math.random() < p ? 1 : 0;
}

// Vectorize a random generator
function vectorize(generator) {
  return function () {
    var n, result, i, args;
    args = [].slice.call(arguments)
    n = args.shift();
    result = [];
    for (i = 0; i < n; i++) {
      result.push(generator.apply(this, args));
    }
    return result;
  };
}

// Generate a histogram from a list of numbers
function histogram(data, binCount) {
  binCount = binCount || 10;

  var bins, i, scaled,
    max = Math.max.apply(this, data),
    min = Math.min.apply(this, data);

  // edge case: max == min
  if (max === min) {
    return [data.length];
  }

  bins = [];

  // zero each bin
  for (i = 0; i < binCount; i++) {
    bins.push(0);
  }

  for (i = 0; i < data.length; i++) {
    // scale it to be between 0 and 1
    scaled = (data[i] - min) / (max - min);

    // scale it up to the histogram size
    scaled *= binCount;

    // drop it in a bin
    scaled = Math.floor(scaled);

    // edge case: the max
    if (scaled === binCount) { scaled--; }

    bins[scaled]++;
  }

  return bins;
}

/**
 * Get a random element from a list
 */
function rlist(list) {
  return list[runif(0, list.length, true)];
}

exports.runif = runif;
exports.rnorm = rnorm;
exports.rchisq = rchisq;
exports.rpoisson = rpoisson;
exports.rcauchy = rcauchy;
exports.rbernoulli = rbernoulli;
exports.rlist = rlist;

exports.rvunif = vectorize(runif);
exports.rvnorm = vectorize(rnorm);
exports.rvchisq = vectorize(rchisq);
exports.rvpoisson = vectorize(rpoisson);
exports.rvcauchy = vectorize(rcauchy);
exports.rvbernoulli = vectorize(rbernoulli);
exports.rvlist = vectorize(rlist);

exports.histogram = histogram;

},{}],71:[function(require,module,exports){
'use strict';
var ansiRegex = require('ansi-regex')();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};

},{"ansi-regex":54}],72:[function(require,module,exports){
/* jshint node: true */
"use strict";
function makeArrayFrom(obj) {
  return Array.prototype.slice.apply(obj);
}
var
  PENDING = "pending",
  RESOLVED = "resolved",
  REJECTED = "rejected";

function SynchronousPromise(handler) {
  this.status = PENDING;
  this._continuations = [];
  this._parent = null;
  this._paused = false;
  if (handler) {
    handler.call(
      this,
      this._continueWith.bind(this),
      this._failWith.bind(this)
    );
  }
}

function looksLikeAPromise(obj) {
  return obj && typeof (obj.then) === "function";
}

SynchronousPromise.prototype = {
  then: function (nextFn, catchFn) {
    var next = SynchronousPromise.unresolved()._setParent(this);
    if (this._isRejected()) {
      if (this._paused) {
        this._continuations.push({
          promise: next,
          nextFn: nextFn,
          catchFn: catchFn
        });
        return next;
      }
      if (catchFn) {
        try {
          var catchResult = catchFn(this._error);
          if (looksLikeAPromise(catchResult)) {
            this._chainPromiseData(catchResult, next);
            return next;
          } else {
            return SynchronousPromise.resolve(catchResult)._setParent(this);
          }
        } catch (e) {
          return SynchronousPromise.reject(e)._setParent(this);
        }
      }
      return SynchronousPromise.reject(this._error)._setParent(this);
    }
    this._continuations.push({
      promise: next,
      nextFn: nextFn,
      catchFn: catchFn
    });
    this._runResolutions();
    return next;
  },
  catch: function (handler) {
    if (this._isResolved()) {
      return SynchronousPromise.resolve(this._data)._setParent(this);
    }
    var next = SynchronousPromise.unresolved()._setParent(this);
    this._continuations.push({
      promise: next,
      catchFn: handler
    });
    this._runRejections();
    return next;
  },
  pause: function () {
    this._paused = true;
    return this;
  },
  resume: function () {
    var firstPaused = this._findFirstPaused();
    if (firstPaused) {
      firstPaused._paused = false;
      firstPaused._runResolutions();
      firstPaused._runRejections();
    }
    return this;
  },
  _findAncestry: function () {
    return this._continuations.reduce(function (acc, cur) {
      if (cur.promise) {
        var node = {
          promise: cur.promise,
          children: cur.promise._findAncestry()
        };
        acc.push(node);
      }
      return acc;
    }, []);
  },
  _setParent: function (parent) {
    if (this._parent) {
      throw new Error("parent already set");
    }
    this._parent = parent;
    return this;
  },
  _continueWith: function (data) {
    var firstPending = this._findFirstPending();
    if (firstPending) {
      firstPending._data = data;
      firstPending._setResolved();
    }
  },
  _findFirstPending: function () {
    return this._findFirstAncestor(function (test) {
      return test._isPending && test._isPending();
    });
  },
  _findFirstPaused: function () {
    return this._findFirstAncestor(function (test) {
      return test._paused;
    });
  },
  _findFirstAncestor: function (matching) {
    var test = this;
    var result;
    while (test) {
      if (matching(test)) {
        result = test;
      }
      test = test._parent;
    }
    return result;
  },
  _failWith: function (error) {
    var firstRejected = this._findFirstPending();
    if (firstRejected) {
      firstRejected._error = error;
      firstRejected._setRejected();
    }
  },
  _takeContinuations: function () {
    return this._continuations.splice(0, this._continuations.length);
  },
  _runRejections: function () {
    if (this._paused || !this._isRejected()) {
      return;
    }
    var
      error = this._error,
      continuations = this._takeContinuations(),
      self = this;
    continuations.forEach(function (cont) {
      if (cont.catchFn) {
        var catchResult = cont.catchFn(error);
        self._handleUserFunctionResult(catchResult, cont.promise);
      } else {
        cont.promise.reject(error);
      }
    });
  },
  _runResolutions: function () {
    if (this._paused || !this._isResolved()) {
      return;
    }
    var continuations = this._takeContinuations();
    if (looksLikeAPromise(this._data)) {
      return this._handleWhenResolvedDataIsPromise(this._data);
    }
    var data = this._data;
    var self = this;
    continuations.forEach(function (cont) {
      if (cont.nextFn) {
        try {
          var result = cont.nextFn(data);
          self._handleUserFunctionResult(result, cont.promise);
        } catch (e) {
          self._handleResolutionError(e, cont);
        }
      } else if (cont.promise) {
        cont.promise.resolve(data);
      }
    });
  },
  _handleResolutionError: function (e, continuation) {
    this._setRejected();
    if (continuation.catchFn) {
      try {
        continuation.catchFn(e);
        return;
      } catch (e2) {
        e = e2;
      }
    }
    if (continuation.promise) {
      continuation.promise.reject(e);
    }
  },
  _handleWhenResolvedDataIsPromise: function (data) {
    var self = this;
    return data.then(function (result) {
      self._data = result;
      self._runResolutions();
    }).catch(function (error) {
      self._error = error;
      self._setRejected();
      self._runRejections();
    });
  },
  _handleUserFunctionResult: function (data, nextSynchronousPromise) {
    if (looksLikeAPromise(data)) {
      this._chainPromiseData(data, nextSynchronousPromise);
    } else {
      nextSynchronousPromise.resolve(data);
    }
  },
  _chainPromiseData: function (promiseData, nextSynchronousPromise) {
    promiseData.then(function (newData) {
      nextSynchronousPromise.resolve(newData);
    }).catch(function (newError) {
      nextSynchronousPromise.reject(newError);
    });
  },
  _setResolved: function () {
    this.status = RESOLVED;
    if (!this._paused) {
      this._runResolutions();
    }
  },
  _setRejected: function () {
    this.status = REJECTED;
    if (!this._paused) {
      this._runRejections();
    }
  },
  _isPending: function () {
    return this.status === PENDING;
  },
  _isResolved: function () {
    return this.status === RESOLVED;
  },
  _isRejected: function () {
    return this.status === REJECTED;
  }
};

SynchronousPromise.resolve = function (result) {
  return new SynchronousPromise(function (resolve, reject) {
    if (looksLikeAPromise(result)) {
      result.then(function (newResult) {
        resolve(newResult);
      }).catch(function (error) {
        reject(error);
      });
    } else {
      resolve(result);
    }
  });
};

SynchronousPromise.reject = function (result) {
  return new SynchronousPromise(function (resolve, reject) {
    reject(result);
  });
};

SynchronousPromise.unresolved = function () {
  return new SynchronousPromise(function (resolve, reject) {
    this.resolve = resolve;
    this.reject = reject;
  });
};

SynchronousPromise.all = function () {
  var args = makeArrayFrom(arguments);
  if (Array.isArray(args[0])) {
    args = args[0];
  }
  if (!args.length) {
    return SynchronousPromise.resolve([]);
  }
  return new SynchronousPromise(function (resolve, reject) {
    var
      allData = [],
      numResolved = 0,
      doResolve = function () {
        if (numResolved === args.length) {
          resolve(allData);
        }
      },
      rejected = false,
      doReject = function (err) {
        if (rejected) {
          return;
        }
        rejected = true;
        reject(err);
      };
    args.forEach(function (arg, idx) {
      SynchronousPromise.resolve(arg).then(function (thisResult) {
        allData[idx] = thisResult;
        numResolved += 1;
        doResolve();
      }).catch(function (err) {
        doReject(err);
      });
    });
  });
};

/* jshint ignore:start */
if (Promise === SynchronousPromise) {
  throw new Error("Please use SynchronousPromise.installGlobally() to install globally");
}
var RealPromise = Promise;
SynchronousPromise.installGlobally = function(__awaiter) {
  if (Promise === SynchronousPromise) {
    return __awaiter;
  } 
  var result = patchAwaiterIfRequired(__awaiter);
  Promise = SynchronousPromise;
  return result;
};

SynchronousPromise.uninstallGlobally = function() {
  if (Promise === SynchronousPromise) {
    Promise = RealPromise;
  }
};

function patchAwaiterIfRequired(__awaiter) {
  if (typeof(__awaiter) === "undefined" || __awaiter.__patched) {
    return __awaiter;
  }
  var originalAwaiter = __awaiter;
  __awaiter = function() {
    var Promise = RealPromise;
    originalAwaiter.apply(this, makeArrayFrom(arguments));
  };
  __awaiter.__patched = true;
  return __awaiter;
}
/* jshint ignore:end */

module.exports = {
  SynchronousPromise: SynchronousPromise
};
},{}],73:[function(require,module,exports){
"use strict";

// Plugin to add 'property' (as in personal property) property to Players when they are initialized. Meant to be used for
// simulations involving personal posessions, for instance economic simulations.

// NashJS engine components
var Engine = require("../lib/engine")

// Game state
var { registry, gamePopulation } = Engine.Backend.State;

// Let's add some PlayerList functionality
var { PlayerList } = Engine.Backend.Classes;


var BalanceSheet = function() {

	// Variables to store settings, and defaults
	var settings = {
		addBalanceSheetOnClaim: true,
		cleanZeros: true,
		negativeAssets: false
	}
	//TODO make negativeAssets (and negativeLiabilities) work


	// Assets Classes

	// Claim parent class
	var Claim = function(claimant, amount) {
		// Add balance sheet if necessary and permitted
		if (!claimant.balanceSheet) {
			if (settings.addBalanceSheetOnClaim) addEntries(registry.players[claimant.id()])
			// Fail if not permitted to add necessary balance sheet.
			else return false;
		}

		this.amount = amount;
		this.claimant = claimant
		claimant.endow(this)
		return true;
	}

	// End ownership claim
	Claim.prototype.erase = function() {
		this.claimant.revoke(this)
		this.claimant = null;
		this.amount = 0
	}

	// Merge claims if they're the same family but different amounts
	Claim.prototype.merge = function(otherClaim) {
		if (this.claimant !== otherClaim.claimant) return false
		// Add amounts
		this.amount = this.amount + otherClaim.amount

		// Remove from balance sheet
		otherClaim.erase();
	}

	// Split this into two separate claims, with different amounts
	Claim.prototype.split = function(newAmount) {
		var clone = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
		clone.amount = newAmount;
		this.amount = this.amount - newAmount;
		this.claimant.endow(clone, false)
		return clone;
	}

	// Transfer to new owner
	Claim.prototype.transfer = function(newClaimant, amount = "all") {
		// Add balance sheet if necessary and permitted
		if (!newClaimant.balanceSheet) {
			if (settings.addBalanceSheetOnClaim) addEntries(registry.players[newClaimant.id()])
			// Fail if not permitted to add necessary balance sheet.
			else return false;
		}

		// Transfer all of it
		if (amount == "all" || amount == this.amount) {
			var oldClaimant = this.claimant;
			this.claimant.revoke(this);
			this.claimant = newClaimant;
			newClaimant.endow(this);

		}
		// or only a portion
		else {
			var newClaim = this.split(amount);
			newClaim.transfer(newClaimant, "all")
			cleanAsset(this)
		}

	}



	// Claims on real things (like cars, houses, gold)
	var RealClaim = function(claimant, good, amount) {
		if (!Claim.call(this, claimant, amount)) return false;
		this.good = good;
	}
	RealClaim.prototype = Object.create(Claim.prototype)
	RealClaim.prototype.constructor = RealClaim

	// Lose value by percentage
	RealClaim.prototype.depreciate = function(rate = .1) {
		this.amount = this.amount * (1 - rate)
	}

	// Add good enforcement to merge
	RealClaim.prototype.merge = function(otherClaim) {
		if (this.good === otherClaim.good) return Claim.prototype.merge.call(this, otherClaim);
	}

	// Replace player object with id when stringifying
	RealClaim.prototype.toJSON = function() {
		return {
			claimant: this.claimant.id(),
			good: this.good,
			amount: this.amount
		}
	}

	// Claims on other entities with balance sheets
	var FinancialClaim = function(claimant, claimed, amount, instrument = "Debt") {
		// Add balance sheet if necessary and permitted
		if (!claimed.balanceSheet) {
			if (settings.addBalanceSheetOnClaim) addEntries(registry.players[claimed.id()])
			// Fail if not permitted to add necessary balance sheet.
			else return false;
		}
		this.claimed = claimed;
		this.instrument = instrument;

		if (!Claim.call(this, claimant, amount)) return false;

		claimed.indebt(this)
	}
	FinancialClaim.prototype = Object.create(Claim.prototype)
	FinancialClaim.prototype.constructor = FinancialClaim

	// Add to erase function, to erase from claimed's balance sheet too
	FinancialClaim.prototype.erase = function() {
		var bs = registry.players[this.claimed.id()].balanceSheet.liabilities
		bs.splice(bs.indexOf(this), 1)
		this.claimed = null;

		return Claim.prototype.erase.call(this)
	}

	// Add claimed enforcement to merge
	FinancialClaim.prototype.merge = function(otherClaim) {
		if (this.claimed === otherClaim.claimed) return Claim.prototype.merge.call(this, otherClaim);
	}


	// Add to split function, to split on claimed's balance sheet too
	FinancialClaim.prototype.split = function(newAmount) {
		var clone = Claim.prototype.split.call(this, newAmount);
		clone.claimed.indebt(clone, false);
		return clone;
	}

	// Replace player object with id when stringifying
	FinancialClaim.prototype.toJSON = function() {
		return {
			claimant: this.claimant.id(),
			claimed: this.claimed.id(),
			instrument: this.instrument,
			amount: this.amount
		}
	}


	// Clean the similar claims on the claimant supplied
	var cleanAsset = function(claim) {
		var bs = registry.players[claim.claimant.id()].balanceSheet.assets;

		var dirty = bs.filter(function(entry) {
			return (entry !== claim && entry.good === claim.good && entry.instrument === claim.instrument);
		})

		dirty.forEach(function(dirt) {
			claim.merge(dirt)
		})

		if (settings.cleanZeros && claim.amount == 0) claim.erase()
	}

	var cleanLiability = function(claim) {
		var bs = registry.players[claim.claimed.id()].balanceSheet.liabilities;

		var dirty = bs.filter(function(entry) {
			return (entry !== claim && entry.claimant === claim.claimant && entry.instrument === claim.instrument);
		})

		dirty.forEach(function(dirt) {
			claim.merge(dirt)
		})

		if (settings.cleanZeros && claim.amount == 0) claim.erase
	}



	// Add balance sheet object and methods to player.
	var addEntries = function(player) {

		//_player properties/methods
		player.balanceSheet = { assets: [], liabilities: [] }

		/*
		var lookup = function(type) {
			this.reduce(function(accumulator, value) {
				if (type === value.good) accumulator += value.amount
				else if (type instanceof Object && type.instrument == value.instrument && (type.claimed === value.claimed))
					accumulator += value.amount
				return accumulator;
			}, 0)
		}
		player.balanceSheet.assets.lookup = lookup;
		player.balanceSheet.liabilities.lookup = lookup;
		*/

		player.netWorth = function() {

			var assets = this.balanceSheet.assets.reduce(function(accumulator, currentValue) {
				return accumulator + currentValue.amount
			}, 0);

			var liabilities = this.balanceSheet.liabilities.reduce(function(accumulator,
				currentValue) {
				return accumulator + currentValue.amount
			}, 0);

			return assets - liabilities;
		}

		// User interface
		player.interface.balanceSheet = function() {
			return JSON.parse(JSON.stringify(registry.players[player.id].balanceSheet));
		}

		player.interface.netWorth = function() {
			return registry.players[player.id].netWorth();
		}

		// TODO validate object.
		player.interface.endow = function(asset, clean = true) {
			if (asset instanceof Claim) {
				registry.players[player.id].balanceSheet.assets.push(asset);
				if (clean) cleanAsset(asset);
			}
		}

		player.interface.indebt = function(liability, clean = true) {
			if (liability instanceof FinancialClaim) {
				registry.players[player.id].balanceSheet.liabilities.push(
					liability);
				if (clean) cleanLiability(liability);
			}
		}

		player.interface.revoke = function(asset) {
			if (asset instanceof Claim) {
				var bs = registry.players[player.id].balanceSheet.assets
				bs.splice(bs.indexOf(asset), 1)
			}
		}

		// TODO convert this over
		player.interface.lend = function(borrower, amount, instrument = "Debt") {
			return new FinancialClaim(player.interface, borrower, amount, instrument)
		}
	}



	// The plugin object.
	var Plugin = {
		name: "balance-sheet-complex",

		settings: function(parameters = {}) {
			Object.assign(settings, parameters)
		},

		// Option to initialize by creating 'property' for a group of players.
		init(players = []) {
			// Add some playerlist functionality
			PlayerList.prototype.balanceSheets = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet();
					else return null;
				})
			};

			PlayerList.prototype.assets = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet().assets;
					else return null;
				})
			};

			PlayerList.prototype.liabilities = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet().liabilities;
					else return null;
				})
			};

			PlayerList.prototype.netWorth = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.netWorth();
					else return null;
				})
			};

			PlayerList.prototype.zeroBalanceSheets = function() {
				this.forEach(function(player) {
					addEntries(player)
				});
				return this;
			}

			// Add bs for specified players
			players.forEach(function(player) {
				addEntries(registry.players[player.id()]);
			})
		},

		// If we've init-ed alredy, just add bs's to the current player list if they don't have already
		require(players = []) {
			players.forEach(function(player) {
				if (!player.balanceSheet) addEntries(registry.players[player.id()]);
			});
		},

		stop() {
			// remove prototype addEntries
			delete PlayerList.prototype.balanceSheets;
			delete PlayerList.prototype.assets;
			delete PlayerList.prototype.liabilities;
			delete PlayerList.prototype.netWorth;

			// delete balance sheet properties from every player and interface.
			gamePopulation().forEach(function(player) {
				delete player.balanceSheet;
				delete player.netWorth;
				delete player.interface.balanceSheet;
				delete player.interface.netWorth;
				delete player.interface.endowAssets;
				delete player.interface.lend;
			})
		},

		// Public classes for asset/liability
		publicIfActive: {
			RealClaim,
			FinancialClaim
		},

		// create property and interface function when player is created
		'player-create': addEntries,

		// Blank property when player is re-initialized
		"player-reinitialize" (player) {
			player.balanceSheet = { assets: [], liabilities: [] }
		}
	}

	return Plugin;
}



module.exports = BalanceSheet;

},{"../lib/engine":6}],74:[function(require,module,exports){
"use strict";

// Plugin to add 'property' (as in personal property) property to Players when they are initialized. Meant to be used for
// simulations involving personal posessions, for instance economic simulations.

// NashJS engine components
var Engine = require("../lib/engine")

// Game state
var { registry, gamePopulation } = Engine.Backend.State;

// Let's add some PlayerList functionality
var { PlayerList } = Engine.Backend.Classes;


var BalanceSheet = function() {

	var addEntries = function(player) {
		//_player properties/methods
		player.balanceSheet = { assets: {}, liabilities: {} }

		player.netWorth = function() {

			var assets = Object.entries(this.balanceSheet.assets).reduce(function(accumulator, currentValue) {
				return accumulator + currentValue[1]
			}, 0);

			var liabilities = Object.entries(this.balanceSheet.liabilities).reduce(function(accumulator,
				currentValue) {
				return accumulator + currentValue[1]
			}, 0);

			return assets - liabilities;
		}

		// User interface
		player.interface.balanceSheet = function() {
			return JSON.parse(JSON.stringify(registry.players[player.id].balanceSheet));
		}

		player.interface.netWorth = function() {
			return registry.players[player.id].netWorth();
		}

		// TODO validate object. Should be of form {apples:2, dogs:1}
		player.interface.endowAssets = function(assetObject) {

			Object.assign(registry.players[player.id].balanceSheet.assets, assetObject)
		}

		player.interface.lend = function(loanObject) {
			//TODO validate object. Should be of form {player1:{mortgage:10}}
			var lender = registry.players[player.id].balanceSheet.assets
			Object.entries(loanObject).forEach(function(loanTo) {
				var debts;
				lender[loanTo[0]] ?
					debts = lender[loanTo[0]] : debts = lender[loanTo[0]] = {};

				Object.entries(loanTo[1]).forEach(function(newLoan) {
					debts[newLoan[0]] ? debts[newLoan[0]] += newLoan[1] : debts[newLoan[0]] = newLoan[1]
					registry.players[loanTo[0]].balanceSheet.liabilities[newLoan[0]] ? registry.players[loanTo[0]].balanceSheet
						.liabilities[newLoan[0]] += newLoan[1] : registry.players[loanTo[0]].balanceSheet.liabilities[
							newLoan[0]] = newLoan[1];
				});
			});
		}
	}



	// The plugin object.
	var Plugin = {
		name: "balance-sheet",

		// Option to initialize by creating 'property' for a group of players.
		init(players = []) {
			// Add some playerlist functionality
			PlayerList.prototype.balanceSheets = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet();
					else return null;
				})
			};

			PlayerList.prototype.assets = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet().assets;
					else return null;
				})
			};

			PlayerList.prototype.liabilities = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet().liabilities;
					else return null;
				})
			};

			PlayerList.prototype.netWorth = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.netWorth();
					else return null;
				})
			};

			PlayerList.prototype.zeroBalanceSheets = function() {
				this.forEach(function(player) {
					addEntries(player)
				});
				return this;
			}

			// Add bs for specified players
			players.forEach(function(player) {
				addEntries(registry.players[player.id()]);
			})
		},

		// If we've init-ed alredy, just add bs's to the current player list if they don't have already
		require(players = []) {
			players.forEach(function(player) {
				if (!player.balanceSheet) addEntries(registry.players[player.id()]);
			});
		},

		stop() {
			// remove prototype addEntries
			delete PlayerList.prototype.balanceSheets;
			delete PlayerList.prototype.assets;
			delete PlayerList.prototype.liabilities;
			delete PlayerList.prototype.netWorth;

			// delete balance sheet properties from every player and interface.
			gamePopulation().forEach(function(player) {
				delete player.balanceSheet;
				delete player.netWorth;
				delete player.interface.balanceSheet;
				delete player.interface.netWorth;
				delete player.interface.endowAssets;
				delete player.interface.lend;
			})
		},

		// create property and interface function when player is created
		'player-create': addEntries,

		// Blank property when player is re-initialized
		"player-reinitialize" (player) {
			player.balanceSheet = { assets: [], liabilities: [] }
		}
	}

	return Plugin;
}


module.exports = BalanceSheet;

},{"../lib/engine":6}],75:[function(require,module,exports){
"use strict";

// game pieces
var prisonerDilemma = require("./iterated-prisoner-dilemma").createGenerator;
var roundRobin = require("./round-robin");

// NashJS engine components
var Engine = require("../lib/engine")

var { Loop } = Engine.Frontend.Playables;

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")
var { generatePopulation } = Engine.Backend.HelperFunctions("tournament");

// Population interfaces
var { Population } = Engine.Frontend.Population;


var AxelrodTournament = gameWrapper(function(players, parameters = {}) {
	var { generatePlayers = true, repeats = 5, gameLength = 200 } = parameters;

	// Either create an entire population
	if (generatePlayers) {
		// Get two sets of players. The second is so players can play themselves
		players = generatePopulation();
		var copies = generatePopulation();
		parameters.copies = copies;
	}

	// or use the supplied players
	else if (players) {
		// do nothing
	} else {
		// or use the players already present
		players = Population().onlyAlive().onlyAvailable();
	}

	// assign parameters and generate the game
	parameters.initializePlayers = players;
	var iteration = roundRobin(players, prisonerDilemma(gameLength), parameters);

	return Loop(iteration, repeats, { id: "Axelrod-Tournament" });
});



module.exports = AxelrodTournament;

},{"../lib/engine":6,"./iterated-prisoner-dilemma":80,"./round-robin":86}],76:[function(require,module,exports){
"use strict";

//base game
var TwoPlayerNormal = require("./simple-normal");

// helper functions
var { gameWrapper } = require("../lib/engine").Backend.HelperFunctions("stock-games")


// Battle of the Sexes
var BattleOfTheSexes = gameWrapper(function(players, parameters = {}) {
	parameters.id = parameters.id || "Battle-of-the-Sexes";

	var choices = [
		["Opera", "Football"],
		["Opera", "Football"]
	];
	var payoffs = [
		[
			[2, 1],
			[0, 0]
		],
		[
			[0, 0],
			[1, 2]
		]
	];

	return TwoPlayerNormal(players, choices, payoffs, parameters);
});

module.exports = BattleOfTheSexes;

},{"../lib/engine":6,"./simple-normal":87}],77:[function(require,module,exports){
"use strict";

// NashJS engine components
var Engine = require("../lib/engine")

// User data
var { Population } = Engine.Frontend

// Playables
var { Lambda, Simultaneous, Sequence, Loop } = Engine.Frontend.Playables;

// Helper functions
var { isFunction } = Engine.Backend.HelperFunctions("general");


//Cultural evolution
//
// TODO: add instructions here
function CulturalEvolution(gameGenerator, numLoops = 1, {
	id = "CulturalEvolution",
	gameProbability = .25,
	pairProbability = .25,
	generatePopulation = null,
	loop = true
} = {}) {

	if (loop && isNaN(numLoops)) throw new Error("CulturalEvolution argument 'numLoops must be a number");
	if (!isFunction(gameGenerator)) throw new Error(
		"CulturalEvolution argument 'gameGenerator' must be a function");
	if (isNaN(gameProbability) || gameProbability < 0 || gameProbability > 1) throw new Error(
		"CulturalEvolution argument 'gameProbability' must be between 0 and 1");
	if (isNaN(pairProbability) || pairProbability < 0 || pairProbability > 1) throw new Error(
		"CulturalEvolution argument 'pairProbability' must be between 0 and 1");

	// Generate population if user wants us to.
	if (isFunction(generatePopulation)) generatePopulation();

	//Reset the scores each round.
	var ResetScores = Lambda(function() {
		Population().onlyAlive().resetScores();
	});

	// Calculate number of matches
	var n = Math.floor(Population().onlyAlive().length * gameProbability);

	// Create matches.
	var matches = [...Array(n)]
	for (var i = 0; i < n; i++) {
		matches[i] = gameGenerator();
		if (!matches[i].play) throw new Error("CulturalEvolution argument 'gameGenerator' must return a Playable");
	}

	//Run all matches simultaneously
	var Round = Simultaneous(matches);

	//Calculate number of pairings
	var n = Math.floor(Population().onlyAlive().length * pairProbability)

	//Create pairings
	var pairings = [...Array(n)];
	for (i = 0; i < n; i++) {

		pairings[i] = Lambda(function() {

			//Find some available players
			var pool = Population().onlyAlive().onlyAvailable();
			var p1 = pool[Math.floor(Math.random() * pool.length)];
			var p2 = pool[Math.floor(Math.random() * pool.length)];

			//Mark them busy
			p1.busy();
			p2.busy();

			// Assign strategy of player with higher score
			if (p1.score() > p2.score()) p2.assign(p1.strategy());
			else if (p1.score() == p2.score()) null;
			else p1.assign(p2.strategy());

			//Return value of player ids, so the log makes some sense.
			return [p1.id(), p2.id()];
		});
	}

	// Run pairings simultaneously
	var Pairing = Simultaneous(pairings);

	// After pairings, mark all players as available.
	var ReleasePlayers = Lambda(function() {
		Population().onlyAlive().release();
	});

	// Define the game.
	Round(ResetScores);
	Pairing(Round);
	ReleasePlayers(Pairing);
	var Iteration = Sequence(ResetScores, ReleasePlayers);

	// User can set loop parameter to false, to avoid wrapping this in a loop.
	if (loop)
		var CE = Loop(Iteration, numLoops, { playableParameters: { initializePlayers: true } });
	else
		var CE = Iteration;

	return CE;
}

//TODO: fix parameters. User should be able to supply parameters which either
// end up as parameters for the Loop or the Sequence.


module.exports = CulturalEvolution;

},{"../lib/engine":6}],78:[function(require,module,exports){
"use strict";

// base game
var TwoPlayerNormal = require("./simple-normal").TwoPlayerNormal;

// NashJS engine components
var Engine = require("../lib/engine")

// Nash engine components
var { Sequence, Lambda } = Engine.Frontend.Playables;

// Game state
var { registry } = Engine.Backend.State

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// We'll need the 'balance-sheet' plugin
var PluginManager = Engine.Backend.PluginManager;

function invertTerms(termsOfTrade) {
	var inverse = {}
	Object.entries(termsOfTrade).forEach(function(term) {
		if (term[0] == "borrow") {
			inverse.lend = term[1]
		} else if (term[0] == "lend") {
			inverse.borrow = term[1]
		} else {
			inverse[term[0]] = term[1] * -1
		}
	});
	return inverse;
}

// termsOfTrade should be an object reflecting the outcomes for player 1.
// Example {apple:2, orange:-2}. To borrow or lend, create a sub-object describing the loan terms.
// eg {apple:2, borrow:{IOU:5}}, or {couch:-10, lend:{'credit card':50}}
var Exchange = gameWrapper(function(players, termsOfTrade = {}, parameters = {}) {
	var { utilityFunctions, utilityMode = "absolute", initialEndowment = [{}, {}] } = parameters //utilityFunctions should be an array of 2 functions, which take a results object and return a change in utility
	parameters.id = "Exchange" || parameters.id;




	// To play this game, players will need a balance sheet. This plugin will add balance sheets to the players,
	// as well as ensure that new players are created with one, and that they are re-initialized properly.
	var balanceSheet = PluginManager.package("balance-sheet-complex").require(players);
	balanceSheet.settings({ cleanZeros: false })

	var p1 = registry.players[players[0].id()];
	var p2 = registry.players[players[1].id()];

	// Do initial endowments if there are any. Format same as for terms of trade.
	initialEndowment.forEach(function(endowment, index) {
		var player = players[index]
		var invertPlayer = players[Number(!index)]
		Object.entries(endowment).forEach(function(term) {
			if (term[0] == "borrow") {
				var loanTerms = Object.entries(term[1])[0]
				new balanceSheet.FinancialClaim(invertPlayer, player, loanTerms[1], loanTerms[0])
			} else if (term[0] == "lend") {
				var loanTerms = Object.entries(term[1])[0]
				new balanceSheet.FinancialClaim(player, invertPlayer, loanTerms[1], loanTerms[0])
			} else {
				new balanceSheet.RealClaim(player, term[0], term[1])
			}
		})
	})

	// The actual playable
	var Decision = TwoPlayerNormal(players, [
		["Accept", "Reject"],
		["Accept", "Reject"]
	], null, {
		id: "Decision",
		informationFilter: function(info) { //TODO might need to wrap user-supplied informationFilter?
			info.termsOfTrade = {
				[p1.id]: termsOfTrade,
				[p2.id]: invertTerms(termsOfTrade)
			}
			return info;
		}
	})

	// Distribute the goods
	var Distribute = Lambda(function() {

		var results = [];

		Object.entries(termsOfTrade).forEach(function(term) {
			if (term[0] == "borrow") {
				var loanTerms = Object.entries(term[1])[0]
				var loan = new balanceSheet.FinancialClaim(p2.interface, p1.interface, loanTerms[1], loanTerms[0])

				results.push({
					player: p1.id,
					borrow: {
						[loanTerms[0]]: loanTerms[1]
					}
				});

				results.push({
					player: p2.id,
					lend: {
						[p1.id]: {
							[loanTerms[0]]: loanTerms[1]
						}
					}
				});

			} else if (term[0] == "lend") {
				var loanTerms = Object.entries(term[1])[0]
				var loan = new balanceSheet.FinancialClaim(p1.interface, p2.interface, loanTerms[1], loanTerms[0])

				results.push({
					player: p2.id,
					borrow: {
						[loanTerms[0]]: loanTerms[1]
					}
				});

				results.push({
					player: p1.id,
					lend: {
						[p2.id]: {
							[loanTerms[0]]: loanTerms[1]
						}
					}
				});

			} else {
				var good = new balanceSheet.RealClaim(p1.interface, term[0], 0)
				good.transfer(p2.interface, term[1] * -1)

				results.push({ player: p1.id, [term[0]]: term[1] });
				results.push({ player: p2.id, [term[0]]: -1 * term[1] });
			}
		});


		if (utilityFunctions) {

			p1.score = utilityMode.toLowerCase() == "relative" ? p1.score + utilityFunctions[0](results) :
				utilityFunctions[0](results)
			p2.score = utilityMode.toLowerCase() == "relative" ? p2.score + utilityFunctions[1](results) :
				utilityFunctions[1](results)
		}

		return results;
	}, { id: "Distribution" });

	//But only do it if the trade goes through.
	Distribute(Decision.Accept.Accept())



	return Sequence(Decision, Distribute, parameters);
}, {
	argumentValidator(players, termsOfTrade) {
		// TODO: validate parameters
		return true;
	}

});

module.exports = Exchange;

},{"../lib/engine":6,"./simple-normal":87}],79:[function(require,module,exports){
"use strict";

var StockGames = {
	//Game skeletons
	"Two-Player Normal": require("./simple-normal").TwoPlayerNormal,
	"Normal": require("./simple-normal").Normal,
	"Simple Zero-Sum": require("./simple-zero-sum"),

	// Classic games
	"Battle Of The Sexes": require("./battle-of-the-sexes"),
	"Matching Pennies": require("./matching-pennies"),
	"Prisoner's Dilemma": require("./prisoner-dilemma"),
	"Rock-Paper-Scissors": require("./rock-paper-scissors"),

	// Iterated games
	"Iterated": require("./iterated"),
	"Iterated Prisoner's Dilemma": require("./iterated-prisoner-dilemma"),

	// Evolutionary games
	"Cultural Evolution": require("./cultural-evolution"),

	//Tournaments
	"Round Robin": require("./round-robin"),
	"Axelrod Tournament": require("./axelrod-tournament"),

	// Probability Theory
	"Monty Hall": require("./monty-hall"),

	//Neoclassical economics
	"Exchange": require("./exchange-complex"),

	// Function to display loaded query shortcuts.
	queries() {
		return Object.keys(registry.queries).map(function(query) {
			return {
				[query]: registry.queries[query].description
			}
		})
	}
};



module.exports = StockGames;

},{"./axelrod-tournament":75,"./battle-of-the-sexes":76,"./cultural-evolution":77,"./exchange-complex":78,"./iterated":81,"./iterated-prisoner-dilemma":80,"./matching-pennies":82,"./monty-hall":83,"./prisoner-dilemma":84,"./rock-paper-scissors":85,"./round-robin":86,"./simple-normal":87,"./simple-zero-sum":88}],80:[function(require,module,exports){
"use strict";

// Base game
var prisonerDilemma = require("./prisoner-dilemma").createGenerator();

// NashJS engine components
var Engine = require("../lib/engine")

// game engine
var { Loop } = Engine.Frontend.Playables;

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// Game utility
var Iterated = require("./iterated")



var IteratedPrisonerDilemma = gameWrapper(function(players, numberIterations = 50, parameters = {}) {
	return Iterated(players, prisonerDilemma, "Prisoner-Dilemma", numberIterations, parameters)
}, {
	queries: [{
			shortcut: "@IPD-choices",
			query: "$map($.[action].results, function($l){$l.result})",
			description: "Results, organized by round."
		},
		{
			shortcut: "@IPD-players",
			query: "$map($.[action].results, function($l){$l.player})",
			description: "Players, organized by round."
		},
		{
			shortcut: "@IPD-payouts",
			query: "$.action.payouts",
			description: "Payouts, as array of objects."
		}
	],
	strategyLoader() {
		return [{
				name: "Tit For Tat",
				description: "Do whatever your opponent did last turn. Cooperate if this is the first turn.",
				strategy: function titForTat() {
					this.choose = function(choices, information) {
						if (information.opponent.history.length) return information.opponent.history[information.opponent
								.history.length - 1]
							.result
						else return "Cooperate";
					}
				}
			},
			{
				name: "Grudger",
				description: "Cooperate until your opponent doesn't, then Defect.",
				strategy: function grudger() {
					this.cooperating = true

					this.choose = function(choices, information) {

						// If opponent just defected, then stop cooperating
						if (information.opponent.history.length) {
							if (information.opponent.history[information.opponent.history.length - 1].result == "Defect") this
								.cooperating = false;
						}

						if (this.cooperating) return "Cooperate";
						else return "Defect";
					}
				}
			},

			{
				name: "Naive Prober",
				description: "Like Tit For Tat, but occasionally Defects with small probability",
				strategy: function prober(probability = 0.1) {
					this.choose = function(choices, information) {
						if (Math.random() < probability) return "Defect";

						if (information.opponent.history.length) return information.opponent.history[information.opponent
								.history.length - 1]
							.result
						else return "Cooperate";
					}
				}
			},

			{
				name: "Tit For Two Tats",
				description: "Cooperates on the first move, then Defects only when the opponent Defects two times",
				strategy: function TF2T() {
					this.choose = function(choices, information) {
						if (information.opponent.history.length > 1) {
							if (information.opponent.history[information.opponent.history.length - 1].result == "Defect" &&
								information.opponent.history[information.opponent.history.length - 2].result == "Defect") return "Defect";
							else return "Cooperate";
						} else return "Cooperate";
					}
				}
			}

		]
	}
});
// TODO validate arguments

module.exports = IteratedPrisonerDilemma

},{"../lib/engine":6,"./iterated":81,"./prisoner-dilemma":84}],81:[function(require,module,exports){
"use strict";

// NashJS engine components
var Engine = require("../lib/engine")

// game engine
var { Loop } = Engine.Frontend.Playables;

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")


var Iterated = gameWrapper(function(players, gameGenerator, gameName, numberIterations = 50, parameters = {}) {

	var { parameters: gameParameters = {} } = parameters

	gameParameters.id = gameParameters.id || gameName
	parameters.id = parameters.id || "Iterated-" + gameName;

	return Loop(gameGenerator(players, gameParameters), numberIterations, parameters);
})

// TODO validate arguments

module.exports = Iterated;

},{"../lib/engine":6}],82:[function(require,module,exports){
"use strict";

// base game
var SimpleZeroSum = require("./simple-zero-sum");

// NashJS engine components
var Engine = require("../lib/engine")

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// Play-time logic
var { Expression } = Engine.Frontend


var MatchingPennies = gameWrapper(function(players, parameters = {}) {
	parameters.id = parameters.id || "Matching-Pennies";
	payoff = parameters.payoff || 1;

	var win = payoff;
	var lose = Expression(function() {
		return -payoff;
	});

	var choices = [
		["Heads", "Tails"],
		["Heads", "Tails"]
	];

	var payoffs = [
		[win, lose],
		[lose, win]
	];

	return SimpleZeroSum(players, choices, payoffs, parameters);
});

// Matching Pennies
module.exports = MatchingPennies;

},{"../lib/engine":6,"./simple-zero-sum":88}],83:[function(require,module,exports){
"use strict"

// NashJS engine components
var Engine = require("../lib/engine");

// Playables
var { Choice, Lambda } = Engine.Frontend.Playables;

// logic
var { Variable, ComplexVariable } = Engine.Frontend

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games");


var MontyHall = gameWrapper(function(player, parameters = {}) {
	parameters.id = parameters.id || "Monty-Hall"
	var numDoors = parameters.numDoors || 3;
	var numPrizes = parameters.numPrizes || 1;
	var numReveals = parameters.numReveals || 1;
	var prize = parameters.prize || 5;

	// Allow array or single player
	if (Array.isArray(player)) player = player[0]

	//Generate list of doors
	var doors = [];
	for (var i = 0; i < numDoors; i++) {
		doors.push("Door " + i.toString())
	}

	var Choose = Choice(player, doors, { id: "Choose" });


	var prizes
	var scores = Array.apply(null, Array(doors.length)).map(function() {
		return Variable(0)
	})

	//Need to set this here in order for scoring to work
	var doors2 = ComplexVariable(doors.slice());

	var Reveal = Lambda(function({ history }) {

		// Re-initialize payoffs.
		prizes = []
		for (var i = 0; i < scores.length; i++) {
			scores[i].set(0)
		}

		// What door did the player open?
		var playerChoice = history.log.query("$[choice='" + Choose.id() + "'][-1]").result // TODO does this work?

		// Select which doors have prizes
		var revealFrom = doors.slice(); // Copy the doors list
		for (var i = 0; i < numPrizes; i++) {
			var prizeIndex = Math.floor(Math.random() * revealFrom.length) // Select a door from the doors copy
			prizes.push(revealFrom[prizeIndex]) // Add the prize to the lists
			scores[prizeIndex].set(prize) // Set payoffs appropriately
			revealFrom.splice(prizeIndex, 1) // Remove the prized door from the doors copy, so that we don't select it more than once
		}

		//Remove player choice from doors copy
		var playerChoiceIndex = revealFrom.indexOf(playerChoice)
		if (playerChoiceIndex > -1) revealFrom.splice(playerChoiceIndex, 1)

		// Choose doors to reveal
		var reveal = [];
		for (var i = 0; i < numReveals; i++) {
			reveal.push(revealFrom[Math.floor(Math.random()) * revealFrom.length])
		}

		// Copy doors list to send onward, then remove the revealed doors from list
		doors2.set(doors.slice()); // Need to set this here so revealing to work
		for (var i = 0; i < reveal.length; i++) {
			let index = doors2.indexOf(reveal[i])
			doors2().splice(index, 1)
		}

		return reveal.length == 1 ? reveal[0] : reveal;
	}, { id: "Reveal" })

	var SecondChoice = Choice(player, doors2, { id: "Stay-or-Switch", usePayoffs: true });
	SecondChoice.setAllPayoffs(scores)

	Reveal(Choose)
	SecondChoice(Reveal)

	return Sequence(Choose, SecondChoice, parameters);
}, {

	strategyLoader() {
		return [{
				name: "Always Switch",
				description: "Randomly select a door. Then, always switch to a different one.",

				strategy: function alwaysSwitch() {

					this.door = null;

					this.choose = function(options, information) {
						var choice
						if (this.door) {
							options.splice(options.indexOf(this.door), 1)
							this.door = null;
							choice = options[Math.floor(Math.random() * options.length)]
						} else {
							choice = options[Math.floor(Math.random() * options.length)]
							this.door = choice
						}

						return choice
					}
				}
			},
			{
				name: "Always Stay",
				description: "Randomly select a door. Then, always stay with that door.",

				strategy: function alwaysStay() {
					this.door = null;

					//TODO add strategy description feature
					this.choose = function(options, information) {
						var choice
						if (this.door) {
							choice = this.door
							this.door = null;

						} else {
							choice = options[Math.floor(Math.random() * options.length)]
							this.door = choice
						}

						return choice
					}
				}
			}
		]
	}
})

module.exports = MontyHall

},{"../lib/engine":6}],84:[function(require,module,exports){
"use strict";

// base game
var TwoPlayerNormal = require("./simple-normal").TwoPlayerNormal;

//NashJS engine components
var Engine = require("../lib/engine")

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games");

// play-time logic
var { Variable, Expression } = Engine.Frontend;


var prisonerDilemma = gameWrapper(function(players, parameters = {}) {
	parameters.id = parameters.id || "Prisoner-Dilemma";
	var payoffs = parameters.payoffs || [Variable(1), Variable(2), Variable(3), Variable(4)];


	// sort numbers because the wrong order would screw up the game
	payoffs.sort()
	var sucker = payoffs[0]
	var punishment = payoffs[1]
	var reward = payoffs[2]
	var temptation = payoffs[3]


	var choices = [
		["Cooperate", "Defect"],
		["Cooperate", "Defect"]
	];
	var gamePayoffs = [
		[
			[reward, reward],
			[sucker, temptation]
		],
		[
			[temptation, sucker],
			[punishment, punishment]
		]
	];

	return TwoPlayerNormal(players, choices, gamePayoffs, parameters);
});


module.exports = prisonerDilemma;

},{"../lib/engine":6,"./simple-normal":87}],85:[function(require,module,exports){
"use strict";

// base game
var SimpleZeroSum = require("./simple-zero-sum");

var Engine = require("../lib/engine")

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// Play-time logic
var { Expression } = Engine.Frontend


// Rock-Paper-Scissors
var RockPaperScissors = gameWrapper(function(players, parameters = {}) {
	parameters.id = parameters.id || "Rock-Paper-Scissors";
	parameters.payoff = parameters.payoff || 1;

	var win = parameters.payoff;
	var lose = Expression(function() {
		return -payoff;
	});

	var choices = [
		["Rock", "Paper", "Scissors"],
		["Rock", "Paper", "Scissors"]
	];
	var payoffs = [
		[0, lose, win],
		[win, 0, lose],
		[lose, win, 0]
	];

	return SimpleZeroSum(players, choices, payoffs, parameters);
});

module.exports = RockPaperScissors

},{"../lib/engine":6,"./simple-zero-sum":88}],86:[function(require,module,exports){
"use strict";

//NashJS Engine
var Engine = require("../lib/engine")

// helper function
var { shuffle } = Engine.Backend.HelperFunctions("general");
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// nashJS engine component
var { Sequence, Simultaneous } = Engine.Frontend.Playables;

//for information mechanics
var { Information, History, PlayerList } = Engine.Backend.Classes;


// gameGenerator should be a function whose first argument is an array of players
var RoundRobin = gameWrapper(function(players, gameGenerator, parameters = {}) {
	parameters.id = parameters.id || "Round-Robin";
	parameters.initializePlayers = parameters.initializePlayers && true;

	// Create array of each combination of players
	var matches = [];

	players.forEach(function(player1, index1) {
		for (var index2 = 0; index2 < index1; index2++) {
			matches.push([players[index2], player1]);
		}

		// optional parameter 'copies.' Pass an extra copy of each player, to play themselves
		if (parameters.copies) matches.push([parameters.copies[index1], player1]);
	});

	//randomize the order
	shuffle(matches);

	// Track scores
	var scoresRecord = [];

	//
	var addRound = function(players, parameters = {}) {
		// information mechanics and other parameters
		var population = new PlayerList(players).generator
		parameters.compartmentalize = { population }
		parameters.initializePlayers = population;

		// generate round
		var round = gameGenerator(players, parameters);

		// track the scores
		var recordScores = Lambda(function() {
			var score = {}
			for (let [strategy, scores] of Object.entries(population().scoresByStrategy())) {
				if (Array.isArray(scores)) {
					if (scores.length == 1) scores = scores[0]
					score[strategy] = scores;
				}
			}
			scoresRecord.push(score);

			//return score for history
			return score;
		}, { id: "Record-Scores" });

		//Chain together
		recordScores(round);

		// return both
		return [round, recordScores
			// ,Sequence(round, recordScores) // Uncomment for Simultaneous implementation
		];
	};



	// Sequential implementation
	// load the first match manually
	var [firstRound, firstRecord] = addRound(
		matches.shift(),
		parameters.parameters
	);

	//then load subsequent matches
	var record = firstRecord;
	var lastRecord, lastRound;

	matches.forEach(function(match) {
		[lastRound, lastRecord] = addRound(match, parameters.parameters);

		lastRound(record);
		record = lastRecord;
	});


	return Sequence(firstRound, lastRecord, parameters);

	/* // Simultaneous implementation
	var rounds = [];
	matches.forEach(function(match) {
	  rounds.push(addRound(match, parameters.gameParameters)[2]);
	});

	return Simultaneous(rounds, parameters); */
});

module.exports = RoundRobin;

},{"../lib/engine":6}],87:[function(require,module,exports){
"use strict";

//Game engine
var Engine = require("../lib/engine")

//Helper functions
var { isFunction } = Engine.Backend.HelperFunctions("general")
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// Playables
var { Turn, Choice, RandomPlayerChoice } = Engine.Frontend.Playables;

//Play-time Logic
var { RandomVariable } = Engine.Frontend

var Normal = gameWrapper(function(players, choiceLists, payoffs = null, parameters = {}) {

		//propogate the information filter
		parameters.parameters ? parameters.parameters.informationFilter = parameters.informationFilter :
			parameters.parameters = { informationFilter: parameters.informationFilter }

		// construct the choices
		var choices = choiceLists.map(function(list, index) {
			return players == "random" ? RandomPlayerChoice(list, parameters.parameters) : Choice(players[index],
				list, parameters.parameters);
		});

		var game = Turn(choices, parameters);

		if (payoffs) game.setAllPayoffs(payoffs);

		return game;
	}, {
		queries: [{
				shortcut: "@N-choices",
				query: "$.results{player:result}",
				description: "Normal: Players and their choice."
			},
			{
				shortcut: "@N-payouts",
				query: "$.payouts",
				description: "Normal: Payouts object, by player."
			},
			{
				shortcut: "@N-players",
				query: "$.results.player",
				description: "Normal: Who played."
			}
		],
		strategyLoader: function() {
			return [{
					strategy: function chooseFirst() {
						this.choose = function(choices, information) {
							return choices[0]
						}
					},
					name: "Choose First",
					description: "Always choose first available option."
				},

				{
					strategy: function chooseSecond() {
						this.choose = function(choices, information) {
							return choices[1]
						}
					},
					name: "Choose Second",
					description: "Always choose second available option."
				},

				{
					strategy: function randomize(choices = [0, 1]) {
						// Creating a map will make picking a random value easier
						choices = choices.map(function(item, index) {
							return [index, item]
						});
						var choiceMap = new Map(choices)

						this.choose = function(choices, information) {
							return choices[choiceMap.get(Math.floor(Math.random() * choiceMap.size))];
						}
					},
					name: "Randomize",
					description: "Choose randomly from available options."
				}
			];
		}
	} // 										TODO: validate all arguments
);


var TwoPlayerNormal = gameWrapper(function(players, choices, payoffs = null, parameters = {}) {

	// Information mechanics.. There are only two players, so we can have a 'me' and 'opponent' entry.
	// If user supplied an information filter, wrap that filter in ours.
	var { informationFilter } = parameters;
	if (!isFunction(informationFilter)) informationFilter = null;

	// Wrap the user's filter
	var wrappedFilter = function(information) {
		// Figure out who I am and who the opponent is
		var me = information.me.id
		var players = [information.turn.choices[0].choice.player, information.turn.choices[1].choice.player]
		var opponent = players.splice(players.indexOf(me), 1) && players[0];

		// add entry for opponent
		var opponentDetail = information.population.filter(function(player) {
			return (player.id == opponent)
		})[0];
		information.opponent = opponentDetail;

		// run the user's information filter
		if (informationFilter) information = informationFilter(information);

		return information;
	}

	// Pass the information filter
	parameters.informationFilter = wrappedFilter

	return Normal(players, choices, payoffs, parameters)
}); //				 																												TODO: may want to validate arguments here too



module.exports = { TwoPlayerNormal, Normal };

},{"../lib/engine":6}],88:[function(require,module,exports){
"use strict";

// base game
var TwoPlayerNormal = require("./simple-normal").TwoPlayerNormal;

// NashJS components
var Engine = require("../lib/engine")

// Game state controller
var { registry } = Engine.Backend.State
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games");

// Play-time logic
var { Variable, Expression } = Engine.Frontend;

/* beautify preserve:start */
var SimpleZeroSum = gameWrapper(function(players, choices, payoffs = [[0, 0],	[0, 0]], parameters={}) {
/* beautify preserve:end */

	var game = TwoPlayerNormal(players, choices, null, parameters)

	var e;

	choices[0].forEach(function(choice0, index0) {
		choices[1].forEach(function(choice1, index1) {

			// Set expression
			e = Expression(function() {
				//Return the negative payoff, or zero
				return (0 - registry.turns[game.id()].payoffsImplicit[choice0][choice1][0] || 0);
			});

			//Set payoffs
			game[choice0][choice1]([payoffs[index0][index1], e]);
		});
	});

	return game;
}); //					TODO: validate arguments



module.exports = SimpleZeroSum;

},{"../lib/engine":6,"./simple-normal":87}]},{},[5])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwiLi4vLi4vLi4vLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJpbmRleC5qcyIsImxhYi9sYWIuanMiLCJsaWIvZW5naW5lLmpzIiwibGliL2hlbHBlckZ1bmN0aW9ucy9nZW5lcmFsLmpzIiwibGliL2hlbHBlckZ1bmN0aW9ucy9pbmRleC5qcyIsImxpYi9oZWxwZXJGdW5jdGlvbnMvbG9naWMuanMiLCJsaWIvaGVscGVyRnVuY3Rpb25zL3BsYXlhYmxlLmpzIiwibGliL2hlbHBlckZ1bmN0aW9ucy9wbGF5ZXIuanMiLCJsaWIvaGVscGVyRnVuY3Rpb25zL3N0YXRlLmpzIiwibGliL2hlbHBlckZ1bmN0aW9ucy9zdG9jay1nYW1lcy5qcyIsImxpYi9oZWxwZXJGdW5jdGlvbnMvdG91cm5hbWVudC5qcyIsImxpYi9oZWxwZXJGdW5jdGlvbnMvdHVybi5qcyIsImxpYi9oaXN0b3J5LmpzIiwibGliL2luZm9ybWF0aW9uLmpzIiwibGliL2xvZ2dlci5qcyIsImxpYi9sb2dpYy5qcyIsImxpYi9wbGF5YWJsZXMvY2hvaWNlLmpzIiwibGliL3BsYXlhYmxlcy9jb25zZWN1dGl2ZS5qcyIsImxpYi9wbGF5YWJsZXMvaGFsdC1pZi5qcyIsImxpYi9wbGF5YWJsZXMvaW5kZXguanMiLCJsaWIvcGxheWFibGVzL2xhbWJkYS5qcyIsImxpYi9wbGF5YWJsZXMvbG9vcC5qcyIsImxpYi9wbGF5YWJsZXMvcGxheWFibGUuanMiLCJsaWIvcGxheWFibGVzL3BvcHVsYXRpb24tZHluYW1pY3MuanMiLCJsaWIvcGxheWFibGVzL3JhbmRvbS1wbGF5ZXItY2hvaWNlLmpzIiwibGliL3BsYXlhYmxlcy9zZXF1ZW5jZS5qcyIsImxpYi9wbGF5YWJsZXMvc2ltdWx0YW5lb3VzLmpzIiwibGliL3BsYXlhYmxlcy9zdG9jaGFzdGljLWhhbHQuanMiLCJsaWIvcGxheWFibGVzL3N0b2NoYXN0aWNMb29wLmpzIiwibGliL3BsYXlhYmxlcy90dXJuLmpzIiwibGliL3BsYXllci5qcyIsImxpYi9wbHVnaW4tbWFuYWdlci9hc3luYy1jdHguanMiLCJsaWIvcGx1Z2luLW1hbmFnZXIvaW5kZXguanMiLCJsaWIvcGx1Z2luLW1hbmFnZXIvcGx1Z2luLWNhbGxiYWNrLWVycm9yLmpzIiwibGliL3BsdWdpbi1tYW5hZ2VyL3BsdWdpbi1uYW1lLWVycm9yLmpzIiwibGliL3BsdWdpbi1tYW5hZ2VyL3dhdGVyZmFsbC1jdHguanMiLCJsaWIvcG9wdWxhdGlvbi5qcyIsImxpYi9xdWVyeS5qcyIsImxpYi9zdGF0ZS5qcyIsImxpYi9zdHJhdGVneS1sb2FkZXIuanMiLCJsaWIvc3RyYXRlZ3kuanMiLCJub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hbnNpLXN0eWxlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9saWIvYXN5bmMuanMiLCJub2RlX21vZHVsZXMvY2hhbGsvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2hhbGsvbm9kZV9tb2R1bGVzL3N1cHBvcnRzLWNvbG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzY2FwZS1zdHJpbmctcmVnZXhwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzcHJpbWEvZGlzdC9lc3ByaW1hLmpzIiwibm9kZV9tb2R1bGVzL2V4cHJlc3Npb24tc2FuZGJveC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9leHByZXNzaW9uLXNhbmRib3gvbGliL21ha2Utc2FmZS5qcyIsIm5vZGVfbW9kdWxlcy9leHRlbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLWFuc2kvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbmF0YS9qc29uYXRhLmpzIiwibm9kZV9tb2R1bGVzL2xvZ2xldmVsLWNvbG9yZWQtbGV2ZWwtcHJlZml4L2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIiwibm9kZV9tb2R1bGVzL3ByZXNlbnQvbGliL3ByZXNlbnQtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yYW5kZ2VuL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JhbmRnZW4vbGliL3JhbmRnZW4uanMiLCJub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zeW5jaHJvbm91cy1wcm9taXNlL2luZGV4LmpzIiwicGx1Z2lucy9iYWxhbmNlLXNoZWV0LWNvbXBsZXguanMiLCJwbHVnaW5zL2JhbGFuY2Utc2hlZXQuanMiLCJzdG9jay1nYW1lcy9heGVscm9kLXRvdXJuYW1lbnQuanMiLCJzdG9jay1nYW1lcy9iYXR0bGUtb2YtdGhlLXNleGVzLmpzIiwic3RvY2stZ2FtZXMvY3VsdHVyYWwtZXZvbHV0aW9uLmpzIiwic3RvY2stZ2FtZXMvZXhjaGFuZ2UtY29tcGxleC5qcyIsInN0b2NrLWdhbWVzL2luZGV4LmpzIiwic3RvY2stZ2FtZXMvaXRlcmF0ZWQtcHJpc29uZXItZGlsZW1tYS5qcyIsInN0b2NrLWdhbWVzL2l0ZXJhdGVkLmpzIiwic3RvY2stZ2FtZXMvbWF0Y2hpbmctcGVubmllcy5qcyIsInN0b2NrLWdhbWVzL21vbnR5LWhhbGwuanMiLCJzdG9jay1nYW1lcy9wcmlzb25lci1kaWxlbW1hLmpzIiwic3RvY2stZ2FtZXMvcm9jay1wYXBlci1zY2lzc29ycy5qcyIsInN0b2NrLWdhbWVzL3JvdW5kLXJvYmluLmpzIiwic3RvY2stZ2FtZXMvc2ltcGxlLW5vcm1hbC5qcyIsInN0b2NrLWdhbWVzL3NpbXBsZS16ZXJvLXN1bS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOTdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2lOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsMkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9cmV0dXJuIGV9KSgpIiwiIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPVxuICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xudmFyIHNwbGl0UGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbn07XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGgocGF0aClbM107XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLy9NYWluIG1vZHVsZSBjb2RlXHJcbnZhciBOYXNoSlMgPSByZXF1aXJlKCcuL2xpYi9lbmdpbmUnKS5Gcm9udGVuZDtcclxuXHJcbi8vU3RvY2stZ2FtZXNcclxuTmFzaEpTLlN0b2NrR2FtZXMgPSByZXF1aXJlKCcuL3N0b2NrLWdhbWVzJyk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOYXNoSlM7XHJcbiIsIih7XHJcblx0UGxheWVyLFxyXG5cdF9QbGF5ZXIsXHJcblx0Z2FtZVBvcHVsYXRpb24sXHJcblx0UG9wdWxhdGlvbixcclxuXHRQbGF5ZXJMaXN0LFxyXG5cdHJlZ2lzdGVyU3RyYXRlZ3ksXHJcblx0U3RyYXRlZ2llcyxcclxuXHRzdHJhdGVneUxvYWRlcixcclxuXHRfZXhwb3NlLFxyXG5cdHJlZ2lzdHJ5LFxyXG5cdFZhcmlhYmxlLFxyXG5cdEV4cHJlc3Npb24sXHJcblx0UmFuZG9tVmFyaWFibGUsXHJcblx0Q29tcGxleFZhcmlhYmxlLFxyXG5cdEhpc3RvcnksXHJcblx0UXVlcmllcyxcclxuXHRleGNsdWRlZFBsYXllcnMsXHJcblx0c3RhcnRSRVBMLFxyXG5cdG5oaXN0b3J5LFxyXG5cdEluZm9ybWF0aW9uLFxyXG5cdFBlcmZlY3RJbmZvcm1hdGlvbixcclxuXHRQbHVnaW5NYW5hZ2VyXHJcbn0gPSByZXF1aXJlKFwiLi4vaW5kZXhcIikpO1xyXG4oe1xyXG5cdENob2ljZSxcclxuXHRUdXJuLFxyXG5cdFNlcXVlbmNlLFxyXG5cdENvbnNlY3V0aXZlLFxyXG5cdExvb3AsXHJcblx0U3RvY2hhc3RpY0xvb3AsXHJcblx0SGFsdElmLFxyXG5cdFN0b2NoYXN0aWNIYWx0LFxyXG5cdExhbWJkYSxcclxuXHRSYW5kb21QbGF5ZXJDaG9pY2UsXHJcblx0UG9wdWxhdGlvbkR5bmFtaWNzLFxyXG5cdFNpbXVsdGFuZW91c1xyXG59ID0gcmVxdWlyZShcIi4uL2luZGV4XCIpLlBsYXlhYmxlcyk7XHJcblN0b2NrR2FtZXMgPSByZXF1aXJlKFwiLi4vaW5kZXhcIikuU3RvY2tHYW1lcztcclxuXHJcblxyXG5cclxucDEgPSBQbGF5ZXIoKTtcclxucDIgPSBQbGF5ZXIoKTtcclxucDMgPSBQbGF5ZXIoKTtcclxuaXBkID0gU3RvY2tHYW1lc1tcIkl0ZXJhdGVkIFByaXNvbmVyJ3MgRGlsZW1tYVwiXShbcDEsIHAyXSwgMjApXHJcbi8qXHJcblN0b2NrR2FtZXNbXCJQcmlzb25lcidzIERpbGVtbWFcIl0oW3AxLCBwMl0pXHJcblxyXG5wMS5hc3NpZ24oXCJjaG9vc2VGaXJzdFwiKVxyXG5wMi5hc3NpZ24oXCJyYW5kb21pemVcIik7XHJcblxyXG5wMyA9IFBsYXllcigpO1xyXG5wMy5hc3NpZ24oXCJjaG9vc2VTZWNvbmRcIik7XHJcbnA0ID0gUGxheWVyKCk7XHJcbnA0LmFzc2lnbihcInJhbmRvbWl6ZVwiKVxyXG5cclxuYzEgPSBDaG9pY2UocDEsIFtcImNvb3BlcmF0ZVwiLCBcImRlZmVjdFwiXSk7XHJcbi8vYzFbJ2xlZnQnXSg1KSA7XHJcbi8vYzFbJ3JpZ2h0J10oMik7XHJcbmMyID0gQ2hvaWNlKHAyLCBbXCJDb29wZXJhdGVcIiwgXCJEZWZlY3RcIl0pO1xyXG4vL2MyWyd1cCddKDEpO1xyXG4vL2MyWydkb3duJ10oNyk7XHJcblxyXG50MiA9IFR1cm4oW2MxLCBjMl0pO1xyXG50MyA9IFR1cm4oW2MxLCBjMl0pO1xyXG50NCA9IFR1cm4oW2MxLCBjMl0pO1xyXG50NSA9IFR1cm4oW2MxLCBjMl0pO1xyXG5zMSA9IFNpbXVsdGFuZW91cyhbdDIsIHQzLCB0NCwgdDVdKVxyXG5cclxuYyA9IENvbnNlY3V0aXZlKFtcclxuXHRUdXJuKFtjMSwgYzJdKSxcclxuXHRUdXJuKFtjMiwgYzFdKSxcclxuXHRDaG9pY2UocDEsIFtcImNvb3BlcmF0ZVwiLCBcImRlZmVjdFwiXSksXHJcblx0TGFtYmRhKGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZyhcImhpXCIpIH0pLFxyXG5cdEhhbHRJZihmdW5jdGlvbigpIHsgcmV0dXJuIHRydWUgfSlcclxuXSlcclxuXHJcbmMzID0gUmFuZG9tUGxheWVyQ2hvaWNlKFtcImNvb3BlcmF0ZVwiLCBcImRlZmVjdFwiXSk7XHJcbmM0ID0gUmFuZG9tUGxheWVyQ2hvaWNlKFtcIkNvb3BlcmF0ZVwiLCBcIkRlZmVjdFwiXSk7XHJcblxyXG50MSA9IFR1cm4oW2MzLCBjNF0pO1xyXG5cclxudjEgPSBuZXcgVmFyaWFibGUoMyk7XHJcblxyXG50MS5kZWZlY3QuRGVmZWN0KFsyLCAyXSk7XHJcbnQxLmRlZmVjdC5Db29wZXJhdGUoWzQsIDFdKTtcclxudDEuY29vcGVyYXRlLkRlZmVjdChbMSwgNF0pO1xyXG50MS5jb29wZXJhdGUuQ29vcGVyYXRlKFt2MSwgdjFdKTtcclxuXHJcbkwxID0gTGFtYmRhKGZ1bmN0aW9uKCkge1xyXG5cdHYxLnNldCh2MSArIDEpO1xyXG59KTtcclxuXHJcbnBkMSA9IFBvcHVsYXRpb25EeW5hbWljcygxLjUsIDEpO1xyXG5cclxuaDIgPSBIYWx0SWYoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFBvcHVsYXRpb24oKS5vbmx5QWxpdmUoKS5sZW5ndGggPT0gMDtcclxufSk7XHJcblxyXG5MMSh0MSk7XHJcbnBkMShMMSk7XHJcbmgyKHBkMSk7XHJcblxyXG4vL3MxID0gU2VxdWVuY2UodDEsIGgyKTtcclxuXHJcbi8vbDEgPSBMb29wKHMxLCAxMCwgeyBsb2dDb250aW51ZTogdHJ1ZSB9KTtcclxuXHJcbi8vY29uc29sZS5sb2coX2V4cG9zZSh0MSkubmV4dClcclxuLy9jb25zb2xlLmxvZyhfZXhwb3NlKHQxKS5uZXh0LmNvb3BlcmF0ZS5Db29wZXJhdGUpXHJcblxyXG5oMiA9IEhhbHRJZihmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gUG9wdWxhdGlvbigpLm9ubHlBbGl2ZSgpLmxlbmd0aCA9PSAwO1xyXG59KTtcclxuXHJcbkwyID0gTGFtYmRhKGZ1bmN0aW9uKCkge1xyXG5cdHAxLmtpbGwoKTtcclxufSk7XHJcblxyXG50MihMMik7XHJcblxyXG5nZW5lcmF0ZVBvcHVsYXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHRmb3IgKGkgPSAwOyBpIDwgMzA7IGkrKykge1xyXG5cdFx0UGxheWVyKHsgYXNzaWduOiBcImNob29zZUZpcnN0XCIgfSk7XHJcblx0fVxyXG5cdGZvciAoaSA9IDA7IGkgPCAzMDsgaSsrKSB7XHJcblx0XHRQbGF5ZXIoeyBhc3NpZ246IFwiY2hvb3NlU2Vjb25kXCIgfSk7XHJcblx0fVxyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2FtZUdlbmVyYXRvcigpIHtcclxuXHR2YXIgdCA9IFR1cm4oW1xyXG5cdFx0UmFuZG9tUGxheWVyQ2hvaWNlKFtcImNvb3BlcmF0ZVwiLCBcImRlZmVjdFwiXSksXHJcblx0XHRSYW5kb21QbGF5ZXJDaG9pY2UoW1wiQ29vcGVyYXRlXCIsIFwiRGVmZWN0XCJdKVxyXG5cdF0pO1xyXG5cclxuXHR0LmRlZmVjdC5EZWZlY3QoWzIsIDJdKTtcclxuXHR0LmRlZmVjdC5Db29wZXJhdGUoWzQsIDFdKTtcclxuXHR0LmNvb3BlcmF0ZS5EZWZlY3QoWzEsIDRdKTtcclxuXHR0LmNvb3BlcmF0ZS5Db29wZXJhdGUoWzMsIDNdKTtcclxuXHJcblx0cmV0dXJuIHQ7XHJcbn1cclxuLy9cclxuLy9cclxuLy9cclxuXHJcbi8vQ0UgPSBTdG9ja0dhbWVzW1wiQ3VsdHVyYWwgRXZvbHV0aW9uXCJdKGdhbWVHZW5lcmF0b3IsIDEsIHtnZW5lcmF0ZVBvcHVsYXRpb259KTtcclxuXHJcbi8vbiA9IFN0b2NrR2FtZXNbXCJUd28tUGxheWVyIE5vcm1hbFwiXShwMSxwMixbW1wibGVmdFwiLFwicmlnaHRcIl0sW1widXBcIixcImRvd25cIl1dKTtcclxuLy9wZDEgPSBTdG9ja0dhbWVzW1wiUHJpc29uZXIncyBEaWxlbW1hXCJdKFtwMSwgcDJdKTtcclxuLy9wZDIgPSBTdG9ja0dhbWVzW1wiUHJpc29uZXIncyBEaWxlbW1hXCJdKFtwMywgcDRdKTtcclxuXHJcbi8vcyA9IFNpbXVsdGFuZW91cyhbcGQxLCBwZDJdKVxyXG5cclxudjIgPSBWYXJpYWJsZSgxKTtcclxuXHJcbi8vbiA9IFN0b2NrR2FtZXNbXCJTaW1wbGUgWmVyby1TdW1cIl0ocDEscDIsW1tcImxlZnRcIixcInJpZ2h0XCJdLFtcInVwXCIsXCJkb3duXCJdXSwgW1t2MiwyXSxbMyw0XV0pO1xyXG5cclxuLy9ycGMgPSBTdG9ja0dhbWVzW1wiUm9jay1QYXBlci1TY2lzc29yc1wiXShbcDEsIHAyXSk7XHJcbi8vdCA9IFN0b2NrR2FtZXNbXCJBeGVscm9kIFRvdXJuYW1lbnRcIl07XHJcbi8vdCA9IFN0b2NrR2FtZXNbXCJJdGVyYXRlZCBQcmlzb25lcidzIERpbGVtbWFcIl0oW3AxLCBwMl0pO1xyXG4vL1RoZSBjb2RlIGJlbG93IGlzIHRvIHJ1biB0aGUgcmVwbCBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cclxuLy92YXIgdG9SZXBsID0ge19leHBvc2UsIHJlZ2lzdHJ5LFBsYXllcixDaG9pY2UsVHVybixTZXF1ZW5jZSxMb29wLFN0b2NoYXN0aWNMb29wLEhhbHRJZiwgU3RvY2hhc3RpY0hhbHQsIExhbWJkYSwgcDEsYzEsYzIsdDF9O1xyXG4vL3N0YXJ0UkVQTCh0b1JlcGwpO1xyXG4qL1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIFN0YXJ0IHBsdWctaW4gbWFuYWdlclxyXG52YXIgUGx1Z2luTWFuYWdlciA9IHJlcXVpcmUoXCIuL3BsdWdpbi1tYW5hZ2VyXCIpXHJcblBsdWdpbk1hbmFnZXIuc3RhcnQoZnVuY3Rpb24oKSB7fSlcclxuXHJcblxyXG4vL0xvZ2dpbmdcclxudmFyIGxvZyA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcclxuLy9sb2cudXNlV2luc3RvbigpOyAgXHRcdFx0XHRXaW5zdG9uIGRvZXNuJ3Qgd29yayB3aXRoIGJyb3dzZXJpZnksIHNvIHRoaXMgaXMgYSBzaGltLiBVbmNvbW1lbnQgdG8gdXNlIFdpbnN0b24uXHJcbmxvZy5zZXRMZXZlbChcImRlYnVnXCIpO1xyXG5sb2coXCJpbmZvXCIsIFwiU3RhcnRpbmcgTmFzaEpTXCIpO1xyXG5cclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSwgaWRDb3VudGVycyB9ID0gcmVxdWlyZSgnLi9zdGF0ZScpO1xyXG5cclxuXHJcbi8vIFF1ZXJ5IGxhbmd1YWdlIGFuZCBzaG9ydGN1dHNcclxudmFyIHsgUXVlcmllcywgUXVlcnksIFF1ZXJ5UmVzdWx0LCBldmFsdWF0ZVF1ZXJ5IH0gPSByZXF1aXJlKFwiLi9xdWVyeVwiKTtcclxuXHJcblxyXG4vLyBIaXN0b3J5XHJcbnZhciB7IGdhbWVIaXN0b3J5LCB1c2VyR2FtZUhpc3RvcnksIEhpc3RvcnksIFVzZXJIaXN0b3J5IH0gPSByZXF1aXJlKCcuL2hpc3RvcnknKTtcclxuXHJcblxyXG4vL1BsYXllcnNcclxudmFyIHsgX1BsYXllciwgUGxheWVyIH0gPSByZXF1aXJlKCcuL3BsYXllcicpO1xyXG5yZWdpc3RyeS5fYWRkVHlwZV8oXCJwbGF5ZXJzXCIpO1xyXG5pZENvdW50ZXJzLl9hZGRUeXBlXyhcInBsYXllclwiKTtcclxuXHJcblxyXG4vL1BvcHVsYXRpb25cclxudmFyIHsgZ2FtZVBvcHVsYXRpb24sIFBvcHVsYXRpb24sIFBsYXllckxpc3QsIFVzZXJQbGF5ZXJMaXN0IH0gPSByZXF1aXJlKCcuL3BvcHVsYXRpb24nKTtcclxuXHJcblxyXG4vL0luZm9ybWF0aW9uIG1lY2hhbmljc1xyXG52YXIgeyBJbmZvcm1hdGlvbiwgUGVyZmVjdEluZm9ybWF0aW9uIH0gPSByZXF1aXJlKFwiLi9pbmZvcm1hdGlvblwiKTtcclxuXHJcblxyXG4vL1BsYXlhYmxlc1xyXG52YXIgeyBwbGF5YWJsZUNsYXNzZXMsIHBsYXlhYmxlSW50ZXJmYWNlcyB9ID0gcmVxdWlyZSgnLi9wbGF5YWJsZXMvJylcclxuZm9yICh2YXIgX2NsYXNzIGluIHBsYXlhYmxlQ2xhc3Nlcykge1xyXG5cdHJlZ2lzdHJ5Ll9hZGRUeXBlXyhwbGF5YWJsZUNsYXNzZXNbX2NsYXNzXS5yZWdpc3RyeU5hbWUpO1xyXG5cdGlkQ291bnRlcnMuX2FkZFR5cGVfKHBsYXlhYmxlQ2xhc3Nlc1tfY2xhc3NdLmNvdW50ZXJOYW1lKTtcclxufVxyXG5cclxuLy9TeW1ib2xpYyBMb2dpY1xyXG52YXIge1xyXG5cdHZhcmlhYmxlUHJvdG90eXBlLFxyXG5cdFZhcmlhYmxlLFxyXG5cdGV4cHJlc3Npb25Qcm90b3R5cGUsXHJcblx0RXhwcmVzc2lvbixcclxuXHRSYW5kb21WYXJpYWJsZSxcclxuXHRDb21wbGV4VmFyaWFibGVcclxufSA9IHJlcXVpcmUoXCIuL2xvZ2ljXCIpO1xyXG5cclxuXHJcbi8vU3RyYXRlZ2llc1xyXG5yZWdpc3RyeS5fYWRkVHlwZV8oXCJzdHJhdGVnaWVzXCIpO1xyXG5pZENvdW50ZXJzLl9hZGRUeXBlXyhcInN0cmF0ZWd5XCIpO1xyXG5cclxudmFyIHsgcmVnaXN0ZXJTdHJhdGVneSwgcmVnaXN0ZXJTdHJhdGVneU9iamVjdCwgU3RyYXRlZ2llcyB9ID0gcmVxdWlyZSgnLi9zdHJhdGVneScpO1xyXG52YXIgeyBsb2FkU3RyYXRlZ3ksIGxvYWRTdHJhdGVneUZvbGRlciB9ID0gcmVxdWlyZSgnLi9zdHJhdGVneS1sb2FkZXInKTtcclxuXHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gbG9hZGVyXHJcbnZhciBIZWxwZXJGdW5jdGlvbnMgPSByZXF1aXJlKCcuL2hlbHBlckZ1bmN0aW9ucycpO1xyXG5cclxuXHJcbi8vVEhJUyBGVU5DVElPTiBJUyBPTkxZIEZPUiBERUJVR0dJTkcuIFJFTU9WRSBJVCBGUk9NIE1PRFVMRSBFWFBPUlRTIFdIRU4gUFVCTElTSElOR1xyXG5mdW5jdGlvbiBFeHBvc2UoaW50ZXJmYWNlUGxheWFibGUpIHtcclxuXHRyZXR1cm4gcmVnaXN0cnkucGxheWFibGVzW2ludGVyZmFjZVBsYXlhYmxlLmlkKCldO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gc3RhcnRSRVBMKHRvUkVQTCkge1xyXG5cdHZhciByZXBsID0gcmVxdWlyZShcInJlcGxcIik7XHJcblxyXG5cdHZhciByZXBsU2VydmVyID0gcmVwbC5zdGFydCh7XHJcblx0XHRwcm9tcHQ6IFwiTmFzaCA+PiBcIlxyXG5cdH0pO1xyXG5cclxuXHRPYmplY3QuYXNzaWduKHJlcGxTZXJ2ZXIuY29udGV4dCwgdG9SRVBMKTtcclxufVxyXG5cclxuXHJcblxyXG52YXIgRW5naW5lID0ge1xyXG5cdEZyb250ZW5kOiB7XHJcblx0XHRQbGF5ZXIsXHJcblx0XHRfUGxheWVyLCAvL1JFTU9WRSBUSElTIExJTkUgV0hFTiBQVUJMSVNISU5HXHJcblx0XHRnYW1lUG9wdWxhdGlvbiwgLy9SRU1PVkUgVEhJUyBMSU5FIFdIRU4gUFVCTElTSElOR1xyXG5cdFx0J1BsYXllckxpc3QnOiBVc2VyUGxheWVyTGlzdCxcclxuXHRcdFBvcHVsYXRpb24sXHJcblx0XHRJbmZvcm1hdGlvbiwgLy9SRU1PVkUgVEhJUyBMSU5FIFdIRU4gUFVCTElTSElOR1xyXG5cdFx0UGVyZmVjdEluZm9ybWF0aW9uLCAvL1JFTU9WRSBUSElTIExJTkUgV0hFTiBQVUJMSVNISU5HXHJcblx0XHQnUGxheWFibGVzJzogcGxheWFibGVJbnRlcmZhY2VzLFxyXG5cdFx0cmVnaXN0ZXJTdHJhdGVneSxcclxuXHRcdHJlZ2lzdGVyU3RyYXRlZ3lPYmplY3QsXHJcblx0XHRTdHJhdGVnaWVzLFxyXG5cdFx0bG9hZFN0cmF0ZWd5LFxyXG5cdFx0bG9hZFN0cmF0ZWd5Rm9sZGVyLFxyXG5cdFx0SGlzdG9yeTogdXNlckdhbWVIaXN0b3J5LFxyXG5cdFx0UXVlcmllcyxcclxuXHRcdEV4cG9zZSwgLy9SRU1PVkUgVEhJUyBMSU5FIFdIRU4gUFVCTElTSElOR1xyXG5cdFx0cmVnaXN0cnksIC8vUkVNT1ZFIFRISVMgTElORSBXSEVOIFBVQkxJU0hJTkdcclxuXHRcdHN0YXJ0UkVQTCwgLy9TaG91bGQgdGhpcyBsaW5lIGJlIHJlbW92ZWQgd2hlbiBwdWJsaXNoaW5nP1xyXG5cdFx0VmFyaWFibGUsXHJcblx0XHRFeHByZXNzaW9uLFxyXG5cdFx0UmFuZG9tVmFyaWFibGUsXHJcblx0XHRDb21wbGV4VmFyaWFibGUsXHJcblx0XHRQbHVnaW5NYW5hZ2VyIC8vUkVNT1ZFIFRISVMgTElORSBXSEVOIFBVQkxJU0hJTkdcclxuXHR9LFxyXG5cclxuXHRCYWNrZW5kOiB7XHJcblx0XHRsb2dnZXI6IGxvZyxcclxuXHRcdFN0YXRlOiB7IHJlZ2lzdHJ5LCBpZENvdW50ZXJzLCBnYW1lSGlzdG9yeSwgZ2FtZVBvcHVsYXRpb24sIFBlcmZlY3RJbmZvcm1hdGlvbiB9LFxyXG5cdFx0Q2xhc3Nlczoge1xyXG5cdFx0XHRQbGF5ZXI6IF9QbGF5ZXIsXHJcblx0XHRcdEhpc3RvcnksXHJcblx0XHRcdFVzZXJIaXN0b3J5LFxyXG5cdFx0XHRQbGF5ZXJMaXN0LFxyXG5cdFx0XHRVc2VyUGxheWVyTGlzdCxcclxuXHRcdFx0SW5mb3JtYXRpb24sXHJcblx0XHRcdFBsYXlhYmxlQ2xhc3NlczogeyBwbGF5YWJsZUNsYXNzZXMgfSxcclxuXHRcdFx0UXVlcnksXHJcblx0XHRcdFF1ZXJ5UmVzdWx0LFxyXG5cdFx0XHR2YXJpYWJsZVByb3RvdHlwZSxcclxuXHRcdFx0ZXhwcmVzc2lvblByb3RvdHlwZVxyXG5cdFx0fSxcclxuXHRcdEhlbHBlckZ1bmN0aW9ucyxcclxuXHRcdFBsdWdpbk1hbmFnZXIsXHJcblx0XHRFeHBvc2VcclxuXHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRW5naW5lO1xyXG4iLCJ2YXIgZ2VuZXJhbCA9IHtcclxuXHQvL0NoZWNrIGlmIHZhcmlhYmxlIGlzIGFuIE9iamVjdFxyXG5cdGlzT2JqZWN0KGEpIHtcclxuXHRcdHJldHVybiAhIWEgJiYgYS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xyXG5cdH0sXHJcblxyXG5cdC8vV2hhdCBkbyB5b3UgdGhpbms/XHJcblx0aXNGdW5jdGlvbihhKSB7XHJcblx0XHRyZXR1cm4gdHlwZW9mIGEgPT09IFwiZnVuY3Rpb25cIjtcclxuXHR9LFxyXG5cclxuXHQvL1Byb3ZpZGUgYSBmdW5jdGlvbiwgYSBjb250ZXh0ICgndGhpcycpLCBhbmQgYW4gYXJndW1lbnQgYXJyYXkuXHJcblx0Ly9SZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgY2FsbGVkLlxyXG5cdGFwcGx5QmluZChmdW5jLCB0aGF0LCBhcmdBcnJheSkge1xyXG5cdFx0cmV0dXJuIGZ1bmMuYmluZC5hcHBseShmdW5jLCBbdGhhdF0uY29uY2F0KGFyZ0FycmF5KSk7XHJcblx0fSxcclxuXHJcblx0Ly9XcmFwcyBhIGZ1bmN0aW9uIHRvIGVuc3VyZSBpdCBvbmx5IGdldHMgY2FsbGVkIG9uZSB0aW1lLlxyXG5cdG9uY2UoZm4sIGNvbnRleHQpIHtcclxuXHRcdHZhciByZXN1bHQ7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRpZiAoZm4pIHtcclxuXHRcdFx0XHRyZXN1bHQgPSBmbi5hcHBseShjb250ZXh0IHx8IHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHRcdFx0Zm4gPSBudWxsO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvLyBSYW5kb21seSByZS1vcmRlciBhcnJheVxyXG5cdHNodWZmbGUoYXJyYXkpIHtcclxuXHRcdHZhciBjdXJyZW50SW5kZXggPSBhcnJheS5sZW5ndGgsXHJcblx0XHRcdHRlbXBvcmFyeVZhbHVlLFxyXG5cdFx0XHRyYW5kb21JbmRleDtcclxuXHJcblx0XHQvLyBXaGlsZSB0aGVyZSByZW1haW4gZWxlbWVudHMgdG8gc2h1ZmZsZS4uLlxyXG5cdFx0d2hpbGUgKDAgIT09IGN1cnJlbnRJbmRleCkge1xyXG5cdFx0XHQvLyBQaWNrIGEgcmVtYWluaW5nIGVsZW1lbnQuLi5cclxuXHRcdFx0cmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjdXJyZW50SW5kZXgpO1xyXG5cdFx0XHRjdXJyZW50SW5kZXggLT0gMTtcclxuXHJcblx0XHRcdC8vIEFuZCBzd2FwIGl0IHdpdGggdGhlIGN1cnJlbnQgZWxlbWVudC5cclxuXHRcdFx0dGVtcG9yYXJ5VmFsdWUgPSBhcnJheVtjdXJyZW50SW5kZXhdO1xyXG5cdFx0XHRhcnJheVtjdXJyZW50SW5kZXhdID0gYXJyYXlbcmFuZG9tSW5kZXhdO1xyXG5cdFx0XHRhcnJheVtyYW5kb21JbmRleF0gPSB0ZW1wb3JhcnlWYWx1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYXJyYXk7XHJcblx0fVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmFsO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xyXG5cclxubG9nKFwiZGVidWdcIiwgXCJoZWxwZXJGdW5jdGlvbnMtaW5kZXg6IExvYWRpbmcgaGVscGVyIGZ1bmN0aW9ucyBsb2FkZXIuXCIpO1xyXG5cclxuLypcclxudmFyIGdlbmVyYWwgID0gcmVxdWlyZSgnLi9nZW5lcmFsJyk7XHJcbnZhciBwbGF5ZXIgICA9IHJlcXVpcmUoJy4vcGxheWVyJyk7XHJcbnZhciBwbGF5YWJsZSA9IHJlcXVpcmUoJy4vcGxheWFibGUnKTtcclxudmFyIHR1cm4gXHQgPSByZXF1aXJlKCcuL3R1cm4nKTtcclxudmFyIHN0YXRlIFx0ID0gcmVxdWlyZSgnLi9zdGF0ZScpOyBcclxuKi9cclxuXHJcbmZ1bmN0aW9uIGxvYWRlcihmaWxlKSB7XHJcblx0cmV0dXJuIHJlcXVpcmUoXCIuL1wiICsgZmlsZSArIFwiLmpzXCIpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGxvYWRlcjtcclxuLy9tb2R1bGUuZXhwb3J0cyA9IHtnZW5lcmFsLCBwbGF5ZXIsIHBsYXlhYmxlLCB0dXJuLCBzdGF0ZX07XHJcblxyXG4vLyBIYWNrIHRvIGNvbXBpbGUgR2xvYiBmaWxlcyAoaW4gYnJvd3NlcmlmeSkuIERvbsK0dCBjYWxsIHRoaXMgZnVuY3Rpb24hXHJcbihmdW5jdGlvbigpIHtcclxuXHRyZXF1aXJlKCcuL2dlbmVyYWwuanMnKTtyZXF1aXJlKCcuL2luZGV4LmpzJyk7cmVxdWlyZSgnLi9sb2dpYy5qcycpO3JlcXVpcmUoJy4vcGxheWFibGUuanMnKTtyZXF1aXJlKCcuL3BsYXllci5qcycpO3JlcXVpcmUoJy4vc3RhdGUuanMnKTtyZXF1aXJlKCcuL3N0b2NrLWdhbWVzLmpzJyk7cmVxdWlyZSgnLi90b3VybmFtZW50LmpzJyk7cmVxdWlyZSgnLi90dXJuLmpzJyk7XHJcbn0pO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2dpYyA9IHtcclxuXHJcblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIG9iamVjdCBpcyBWYXJpYWJsZS9FeHByZXNzaW9uIG9yIG5vdC4gUmV0dXJucyB0cnVlL2ZhbHNlXHJcblx0aXNMb2dpYyhsb2dpYykge1xyXG5cclxuXHRcdGlmIChsb2dpYyBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIGxvZ2ljID09IGxvZ2ljICogMSkgcmV0dXJuIHRydWVcclxuXHRcdGVsc2UgcmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbG9naWM7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIHsgU3luY2hyb25vdXNQcm9taXNlIH0gPSByZXF1aXJlKCdzeW5jaHJvbm91cy1wcm9taXNlJyk7XHJcblxyXG4vL0dhbWUgc3RhdGUgY29udHJvbGxlcnNcclxudmFyIHsgcmVnaXN0cnkgfSA9IHJlcXVpcmUoJy4uL3N0YXRlJyk7XHJcblxyXG52YXIgcGxheWFibGUgPSB7XHJcblx0Ly8gR2VuZXJhdGVzIHRoZSBmdW5jdGlvbiB0aGF0IGdldHMgcmV0dXJuZWQgd2hlbiBhIFBsYXlhYmxlIGlzIGNhbGxlZCwgd2hpY2ggY2FuIHRoZW4gYmUgY2FsbGVkIHRvIGNoYWluIHBsYXlhYmxlcyB0b2dldGhlci5cclxuXHRjaGFpbmVyR2VuZXJhdG9yKGV4dGVybmFsT2JqLCBpbnRlcm5hbE9iaikge1xyXG5cdFx0ZXh0ZXJuYWxPYmogPSB0aGlzO1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHNvdXJjZSkge1xyXG5cdFx0XHR2YXIgcHJldmlvdXNQbGF5YWJsZSwgcGF0aDtcclxuXHJcblx0XHRcdC8vVE9ETzogdmVyaWZ5IHRoYXQgc291cmNlIGlzIHRoZSByaWdodCB0eXBlXHJcblxyXG5cdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLmFsbChbZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0aWYgKHNvdXJjZSBpbnN0YW5jZW9mIFByb21pc2UgfHwgc291cmNlIGluc3RhbmNlb2YgU3luY2hyb25vdXNQcm9taXNlKSB7XHJcblx0XHRcdFx0XHRzb3VyY2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0XHRcdFx0cHJldmlvdXNQbGF5YWJsZSA9IHJlZ2lzdHJ5LnBsYXlhYmxlc1tyZXN1bHQucGxheWFibGUuaWQoKV07XHJcblx0XHRcdFx0XHRcdHBhdGggPSByZXN1bHQucGF0aFxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoKVxyXG5cdFx0XHR9KCksIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFByb21pc2UgfHwgc291cmNlIGluc3RhbmNlb2YgU3luY2hyb25vdXNQcm9taXNlKSkge1xyXG5cdFx0XHRcdFx0cHJldmlvdXNQbGF5YWJsZSA9IHJlZ2lzdHJ5LnBsYXlhYmxlc1tzb3VyY2UuaWQoKV07XHJcblx0XHRcdFx0XHRwYXRoID0gc291cmNlLnBhdGg7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZSgpO1xyXG5cdFx0XHR9KCldKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cclxuXHRcdFx0XHRpZiAocGF0aCA9PSBcImFsbFwiKSBwcmV2aW91c1BsYXlhYmxlLmFkZE5leHQoaW50ZXJuYWxPYmopO1xyXG5cdFx0XHRcdGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdG91dGNvbWVUcmVlR2V0VmFsdWUocHJldmlvdXNQbGF5YWJsZS5uZXh0LCBwYXRoKS5wdXNoKGludGVybmFsT2JqKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vcHJldmlvdXNQbGF5YWJsZS5uZXh0W3NlbGVjdGVkXS5wdXNoKF9jaG9pY2UpO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoe1xyXG5cdFx0XHRcdFx0J3BsYXlhYmxlJzogZXh0ZXJuYWxPYmosXHJcblx0XHRcdFx0XHRwYXRoOiBcImFsbFwiXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly9Vc2UgdG8gc2V0IGV2ZXJ5IHZhbHVlIG9mIGFuIG91dGNvbWUgdHJlZVxyXG5cdG91dGNvbWVUcmVlQWRkQWxsKHRyZWUsIHZhbHVlKSB7XHJcblxyXG5cdFx0Ly9JZiBpdCdzIGFuIGFycmF5LCB0aGVuIHdlJ3JlIGFscmVhZHkgZG9uZS5cclxuXHRcdGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XHJcblx0XHRcdHRyZWUucHVzaCh2YWx1ZSk7IC8vVXNlIHB1c2ggaGVyZSBiZWNhdXNlIHRoaXMgd2lsbCBiZSBhIHVuaXF1ZSBhcnJheVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHJlY3Vyc2UgPSBmdW5jdGlvbihvYmosIHZhbCkge1xyXG5cclxuXHRcdFx0XHRmb3IgKHZhciBrZXlzIGluIG9iaikge1xyXG5cclxuXHRcdFx0XHRcdC8vSWYgbm8ga2V5cyBsZWZ0IHRvIHRyYXZlcnNlLCB0aGVuIGFzc2lnbiB2YWx1ZS4gSWYgbm90LCByZWN1cnNlLlxyXG5cdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkob2JqW2tleXNdKSkge1xyXG5cdFx0XHRcdFx0XHRvYmpba2V5c10gPSBvYmpba2V5c10uc2xpY2UoKS5jb25jYXQodmFsKTsgLy9Vc2Ugc2xpY2UtY29uY2F0IGhlcmUgYmVjYXVzZSB0aGlzIG1pZ2h0IG5vdCBiZSBhIHVuaXF1ZSBhcnJheSAodGhlIGNyZWF0aW9uIHByb2Nlc3MgZHVwbGljYXRlcyB0aGVtKVxyXG5cdFx0XHRcdFx0fSBlbHNlIHJlY3Vyc2Uob2JqW2tleXNdLCB2YWwpO1xyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHRcdHJlY3Vyc2UodHJlZSwgdmFsdWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cclxuXHQvL1RyYXZlcnNlIGFuIG91dGNvbWUgdHJlZSB0byBvYnRhaW4gdGhlIHZhbHVlIGZvciBhIGRlc2lyZWQga2V5LXNldFxyXG5cdC8vQXJndW1lbnQgb25lIGlzIGEgbmVzdGVkIG9iamVjdCwgd2hpbGUgYXJndW1lbnQgMiBpcyBhbiBhcnJheSBvZiBrZXlzIGZvciB0aGUgb2JqZWN0LCAxIGxheWVyIGF0IGEgdGltZS5cclxuXHRvdXRjb21lVHJlZUdldFZhbHVlKHRyZWUsIHNlbGVjdG9yKSB7XHJcblxyXG5cdFx0Ly9GaW5kIHRoZSBuZXh0IGl0ZW0gaW4gdGhlIGNoYWluIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVzdWx0YW50IG91dGNvbWVcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWxlY3Rvci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR0cmVlID0gdHJlZVtzZWxlY3RvcltpXV07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRyZWU7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vVHJhdmVyc2UgYW4gb3V0Y29tZSB0cmVlIHRvIHNldCB0aGUgdmFsdWUgZm9yIGEgZGVzaXJlZCBrZXktc2V0XHJcblx0Ly9Bcmd1bWVudCBvbmUgaXMgYSBuZXN0ZWQgb2JqZWN0LCB3aGlsZSBhcmd1bWVudCAyIGlzIGFuIGFycmF5IG9mIGtleXMgZm9yIHRoZSBvYmplY3QsIDEgbGF5ZXIgYXQgYSB0aW1lLlxyXG5cdG91dGNvbWVUcmVlU2V0VmFsdWUodHJlZSwgc2VsZWN0b3IsIHZhbHVlKSB7XHJcblxyXG5cdFx0Ly9GaW5kIHRoZSBuZXh0IGl0ZW0gaW4gdGhlIGNoYWluIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVzdWx0YW50IG91dGNvbWVcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWxlY3Rvci5sZW5ndGggLSAxOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dHJlZSA9IHRyZWVbc2VsZWN0b3JbaV1dO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cmVlW3NlbGVjdG9yW2ldXSA9IHZhbHVlO1xyXG5cdH1cclxufVxyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHBsYXlhYmxlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vICBHYW1lIHN0YXRlXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKFwiLi4vc3RhdGVcIik7XHJcblxyXG4vLyBoZWxwZXIgZnVuY3Rpb25cclxudmFyIHsgaXNGdW5jdGlvbiB9ID0gcmVxdWlyZShcIi4vZ2VuZXJhbFwiKTtcclxuXHJcbi8vIFBsYXllciBjbGFhc3NcclxudmFyIHsgX1BsYXllciB9ID0gcmVxdWlyZShcIi4uL3BsYXllclwiKTtcclxuXHJcbi8vIFBvcHVsYXRpb25cclxudmFyIHsgZ2FtZVBvcHVsYXRpb24gfSA9IHJlcXVpcmUoXCIuLi9wb3B1bGF0aW9uXCIpXHJcblxyXG4vLyBQbHVnaW5zXHJcbnZhciBQbHVnaW5NYW5hZ2VyID0gcmVxdWlyZShcIi4uL3BsdWdpbi1tYW5hZ2VyL1wiKVxyXG5cclxudmFyIHBsYXllciA9IHtcclxuXHJcblx0Ly9yZXNldCBhbGwgcGxheWVycy4gUmVjcmVhdGUgZnJvbSBjbGFzcywgcmUtYXNzaWduIHN0cmF0ZWd5LCBsb29wIHRocm91Z2ggb2JqZWN0cyB0aGF0IHJlZmVyZW5jZSBwbGF5ZXIgdG8gc2V0IG5ldyByZWZlcmVuY2UuIHJlc3VsdCBhcmd1bWVudCBpcyBvbmx5IGZvciBwYXNzLXRocm91Z2guXHJcblx0cmVpbml0aWFsaXplUGxheWVycyhwb3B1bGF0aW9uID0gXCJhbGxcIiwgcmVzdWx0ID0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciBvbGRQbGF5ZXIsIHN0cmF0ZWd5LCBzdHJhdGVneUFyZ3MsIHBhcmFtZXRlcnM7XHJcblxyXG5cdFx0XHQvLyBpZiBubyBwb3B1bGF0aW9uIGlzIHN1cHBsaWVkLCBmZXRjaCBldmVyeWJvZHlcclxuXHRcdFx0aWYgKHBvcHVsYXRpb24gPT09IFwiYWxsXCIpIHBvcHVsYXRpb24gPSBPYmplY3Qua2V5cyhyZWdpc3RyeS5wbGF5ZXJzKVxyXG5cdFx0XHRlbHNlKHBvcHVsYXRpb24gPSBwb3B1bGF0aW9uLmlkcygpKVxyXG5cclxuXHRcdFx0Ly9SZWRlZmluZSBlYWNoIHBsYXllclxyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBvcHVsYXRpb24ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgcGxheWVyID0gcG9wdWxhdGlvbltpXTtcclxuXHJcblx0XHRcdFx0b2xkUGxheWVyID0gcmVnaXN0cnkucGxheWVyc1twbGF5ZXJdO1xyXG5cdFx0XHRcdHN0cmF0ZWd5ID0gb2xkUGxheWVyLnN0cmF0ZWd5ID8gb2xkUGxheWVyLnN0cmF0ZWd5Ll9pZCA6IG51bGw7XHJcblx0XHRcdFx0c3RyYXRlZ3lBcmdzID0gc3RyYXRlZ3kgPyBvbGRQbGF5ZXIuc3RyYXRlZ3kuX2FyZ3MgOiBbXTtcclxuXHRcdFx0XHRwYXJhbWV0ZXJzID0ge307IC8vVE9ETzogd2hlbiBhZGRpbmcgcGxheWVyIHBhcmFtZXRlcnMsIGJlIHN1cmUgdGhleSdyZSBpbmNsdWRlZCBoZXJlXHJcblxyXG5cdFx0XHRcdHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyXSA9IG5ldyBfUGxheWVyKG9sZFBsYXllci5pZCwgcGFyYW1ldGVycyk7XHJcblx0XHRcdFx0cmVnaXN0cnkucGxheWVyc1twbGF5ZXJdLmludGVyZmFjZSA9IG9sZFBsYXllci5pbnRlcmZhY2U7XHJcblx0XHRcdFx0c3RyYXRlZ3kgJiYgcmVnaXN0cnkucGxheWVyc1twbGF5ZXJdLmFzc2lnbihzdHJhdGVneSwgLi4uc3RyYXRlZ3lBcmdzKTtcclxuXHJcblx0XHRcdFx0Ly8gUGx1Z2luLCB0byBhbHRlciBwbGF5ZXJzIGluIHJlLWluaXRpYWxpemF0aW9uXHJcblx0XHRcdFx0UGx1Z2luTWFuYWdlci5ydW4oXCJwbGF5ZXItcmVpbml0aWFsaXplXCIsIHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vRm9yIGVhY2ggY2hvaWNlLCByZWNyZWF0ZSBwbGF5ZXIgcmVmZXJlbmNlc1xyXG5cdFx0XHRmb3IgKHZhciBjaG9pY2UgaW4gcmVnaXN0cnkuY2hvaWNlcykge1xyXG5cdFx0XHRcdGlmIChyZWdpc3RyeS5jaG9pY2VzW2Nob2ljZV0ucGxheWVyKVxyXG5cdFx0XHRcdFx0cmVnaXN0cnkuY2hvaWNlc1tjaG9pY2VdLnBsYXllciA9IHJlZ2lzdHJ5LnBsYXllcnNbcmVnaXN0cnkuY2hvaWNlc1tjaG9pY2VdLnBsYXllci5pZF07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcGxheWVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxuXHJcbi8vIFN0YXRlIHZhcmlhYmxlc1xyXG52YXIge2lkQ291bnRlcnMsIHJlZ2lzdHJ5fSA9IHJlcXVpcmUoJy4uL3N0YXRlJyk7XHJcblxyXG52YXIgc3RhdGUgPSB7XHJcblx0XHJcblx0Ly9IYW5kbGUgSUQgc2V0dGluZyBmb3IgYWxsIG9iamVjdHMgdGhhdCBnZXQgc3RvcmVkIGluIHRoZSByZWdpc3RyeVxyXG5cdGlkSGFuZGxlcjogZnVuY3Rpb24gaWRIYW5kbGVyKGlkLCB0eXBlLCByZWN1cnNpbmc9ZmFsc2Upe1xyXG5cdFx0Ly9Bc3NpZ24gaWRcclxuXHRcdFxyXG5cdFx0aWRDb3VudGVyc1t0eXBlXSsrO1xyXG5cdFx0dmFyIGNvdW50ZXIgPSBpZENvdW50ZXJzW3R5cGVdO1xyXG5cdFx0XHJcblx0XHRpZiAoIWlkKSB7XHJcblx0XHRcdHJldHVybiB0eXBlICsgY291bnRlci50b1N0cmluZygpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBDaGVjayB0aGF0IGlkIGlzbid0IHRha2VuLiBJZiBpdCBpcywgY29uc3RydWN0IGEgbmV3IG9uZS5cclxuXHRcdFx0XHJcblx0XHRcdC8vQ29uc3RydWN0IGxpc3Qgb2YgYWxsIG9iamVjdHMgYnkgZXh0cmFjdGluZyBhbGwgcmVnaXN0cnkgZW50cmllc1xyXG5cdFx0XHR2YXIgaXRlbXMgPSBbXVxyXG5cdFx0XHRPYmplY3Qua2V5cyhyZWdpc3RyeSkuZm9yRWFjaChmdW5jdGlvbihyZWcpe2l0ZW1zLnB1c2guYXBwbHkoaXRlbXMsIE9iamVjdC5rZXlzKHJlZ2lzdHJ5W3JlZ10pKX0pXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBpZiBpZCBpcyBhbHJlYWR5IHRha2VuLCBnZW5lcmF0ZSBhIG5ldyBvbmUgYnkgYWRkaW5nIGEgbnVtYmVyIGF0IHRoZSBlbmQuXHJcblx0XHRcdGlmIChpdGVtcy5pbmRleE9mKGlkKSA+IC0xKSB7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0dmFyIG1hdGNoLCBvbGROdW0sIGV4cCwgbmV3SWQ7XHJcblx0XHRcdFx0dmFyIG9sZElkID0gaWQ7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0ZG8ge1xyXG5cdFx0XHRcdFx0Ly8gVGhpcyBmaW5kcyBhIG51bWJlciBhdCB0aGUgZW5kLCBhbmQgaW5jcmVtZW50cyBpdCwgb3Igc3RhcnRzIHdpdGggMSBpZiB0aGVyZSB3YXNuJ3Qgb25lLlxyXG5cdFx0XHRcdFx0bWF0Y2ggPSAvXFxkKyQvLmV4ZWMoaWQpO1xyXG5cdFx0XHRcdFx0b2xkTnVtID0gbWF0Y2ggPyBtYXRjaFswXSA6IFwiXCI7XHJcblx0XHRcdFx0XHRleHAgPSBuZXcgUmVnRXhwKG9sZE51bSArIFwiJFwiKTtcclxuXHRcdFx0XHRcdGlkID0gaWQucmVwbGFjZShleHAsIE51bWJlcihvbGROdW0pICsgMSlcclxuXHRcdFx0XHRcclxuXHRcdFx0XHR9XHRcclxuXHRcdFx0XHR3aGlsZSAoaXRlbXMuaW5kZXhPZihpZCkgPi0xKVxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIExvZyB3YXJuaW5nXHJcblx0XHRcdFx0bG9nKFwid2FyblwiLCBcIklEIFwiICsgb2xkSWQgKyBcIiBpcyB0YWtlbi4gVXNpbmcgaW5zdGVhZCBcIiArIGlkKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0cmV0dXJuIGlkXHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBzdGF0ZTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIFN0cmF0ZWd5IHJlZ2lzdHJhdGlvblxyXG52YXIgeyByZWdpc3RlclN0cmF0ZWd5T2JqZWN0IH0gPSByZXF1aXJlKFwiLi4vZW5naW5lXCIpLkZyb250ZW5kO1xyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpc0Z1bmN0aW9uLCBvbmNlIH0gPSByZXF1aXJlKFwiLi9nZW5lcmFsXCIpO1xyXG5cclxuLy9FeHRlcm5hbCBkZXBlbmRlbmN5XHJcbnZhciBlc3ByaW1hID0gcmVxdWlyZShcImVzcHJpbWFcIik7XHJcblxyXG5cclxuLy8gRm9yIGhhbmRsaW5nIHF1ZXJpZXNcclxudmFyIHsgcmVnaXN0cnkgfSA9IHJlcXVpcmUoXCIuLi9lbmdpbmVcIikuQmFja2VuZC5TdGF0ZVxyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoXCIuL3N0YXRlXCIpXHJcblxyXG52YXIgcmVnaXN0ZXJRdWVyeU9iamVjdCA9IGZ1bmN0aW9uKHF1ZXJ5T2JqZWN0LCBnYW1lTmFtZSkge1xyXG5cdC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBxdWVyaWVzLCByZWN1cnNlXHJcblx0aWYgKEFycmF5LmlzQXJyYXkocXVlcnlPYmplY3QpKSByZXR1cm4gcXVlcnlPYmplY3QubWFwKGZ1bmN0aW9uKHF1ZXJ5KSB7XHJcblx0XHRyZXR1cm4gcmVnaXN0ZXJRdWVyeU9iamVjdChxdWVyeSlcclxuXHR9KTtcclxuXHJcblx0dmFyIHsgc2hvcnRjdXQsIHF1ZXJ5LCBkZXNjcmlwdGlvbiA9IFwiTm8gZGVzY3JpcHRpb24gZ2l2ZW4uXCIgfSA9IHF1ZXJ5T2JqZWN0O1xyXG5cdC8vIEVuZm9yY2UgbmFtaW5nIGNvbnZlbnRpb24sIGZpcnN0IGNoYXJhY3RlciAnQCdcclxuXHRpZiAoc2hvcnRjdXRbMF0gIT0gXCJAXCIpIHNob3J0Y3V0ID0gXCJAXCIuY29uY2F0KHNob3J0Y3V0KVxyXG5cclxuXHQvLyBDaGVjayBmb3IgZHVwbGljYXRlcy4gQWJvcnQgaWYgc28sIGJ1dCByZXR1cm4gdGhlIGRhdGEgZm9yIGRpc3BsYXkgcHVycG9zZXMuXHJcblx0aWYgKHJlZ2lzdHJ5LnF1ZXJpZXNbc2hvcnRjdXRdICYmIHJlZ2lzdHJ5LnF1ZXJpZXNbc2hvcnRjdXRdLnF1ZXJ5ID09IHF1ZXJ5ICYmXHJcblx0XHRyZWdpc3RyeS5xdWVyaWVzW3Nob3J0Y3V0XS5kZXNjcmlwdGlvbiA9PSBkZXNjcmlwdGlvbilcclxuXHRcdHJldHVybiB7IHNob3J0Y3V0LCBkZXNjcmlwdGlvbiB9O1xyXG5cclxuXHQvLyBhc3NpZ24gaWQgYW5kIGFkZCB0byByZWdpc3RyeVxyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihzaG9ydGN1dCwgXCJxdWVyeVwiKVxyXG5cdHJlZ2lzdHJ5LnF1ZXJpZXNbaWRdID0geyBxdWVyeSwgZGVzY3JpcHRpb24gfVxyXG5cclxuXHQvL3JldHVybiB0aGUgZGF0YSBmb3IgZGlzcGxheSBwdXJwb3Nlc1xyXG5cdHJldHVybiB7IGlkLCBkZXNjcmlwdGlvbiB9XHJcbn1cclxuXHJcblxyXG5cclxudmFyIHN0b2NrR2FtZXMgPSB7XHJcblx0Ly8gdXRpbGl0eSBmdW5jdGlvbiB0byBjcmVhdGUgdHdvIHdheXMgdG8gY2FsbCBhIGdhbWUsIGVpdGhlciB3aXRoIGFsbCB0aGUgYXJndW1lbnRzLCBvciBjdXJyaWVkLCB3aGVyZSB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gdGFrZXMgcGxheWVycyBhbmQgcGFyYW1ldGVyc1xyXG5cdC8vIFRoZSBjb21iaW5lUGFyYW1ldGVycyBzZXR0aW5nIHdpbGxcclxuXHRnYW1lV3JhcHBlcihnYW1lLCB7XHJcblx0XHRhcmd1bWVudFZhbGlkYXRvciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSxcclxuXHRcdGNvbWJpbmVQYXJhbWV0ZXJzID0gdHJ1ZSxcclxuXHRcdGdhbWVEZXNjcmlwdGlvbiA9IFwiTm8gZGVzY3JpcHRpb24gZ2l2ZW4uXCIsXHJcblx0XHRzdHJhdGVneUxvYWRlciA9IG51bGwsXHJcblx0XHRxdWVyaWVzID0gbnVsbFxyXG5cdH0gPSB7fSkge1xyXG5cclxuXHRcdHZhciBnZW5lcmF0ZTtcclxuXHJcblx0XHQvLyBJZiB0aGVyZSdzIGEgc3RyYXRlZ3kgbG9hZGVyLCBtYWtlIHN1cmUgaXQgb25seSBydW5zIG9uY2VcclxuXHRcdHZhciBsb2FkU3RyYXRlZ2llc1xyXG5cdFx0aWYgKGlzRnVuY3Rpb24oc3RyYXRlZ3lMb2FkZXIpKSBsb2FkU3RyYXRlZ2llcyA9IG9uY2UoZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiByZWdpc3RlclN0cmF0ZWd5T2JqZWN0KHN0cmF0ZWd5TG9hZGVyKCkpO1xyXG5cdFx0fSk7XHJcblx0XHRlbHNlIGxvYWRTdHJhdGVnaWVzID0gZnVuY3Rpb24oKSB7fVxyXG5cclxuXHRcdC8vIElmIHRoZXJlJ3MgYSBxdWVyeSBsb2FkZXIsIG1ha2Ugc3VyZSBpdCBvbmx5IHJ1bnMgb25jZVxyXG5cdFx0dmFyIGxvYWRRdWVyaWVzXHJcblx0XHRpZiAocXVlcmllcykgbG9hZFF1ZXJpZXMgPSBvbmNlKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gcmVnaXN0ZXJRdWVyeU9iamVjdChxdWVyaWVzKTtcclxuXHRcdH0pO1xyXG5cdFx0ZWxzZSBsb2FkUXVlcmllcyA9IGZ1bmN0aW9uKCkge31cclxuXHJcblx0XHQvLyBydW4gdGhlIGdhbWUuIE9wdGlvbmFsbHksIHZhbGlkYXRlIHRoZSBhcmd1bWVudHMgYW5kIGxvYWQgc3RyYWdlaWVzIGZpcnN0XHJcblx0XHRnZW5lcmF0ZSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcclxuXHRcdFx0dmFyIHJlc3VsdCA9IGFyZ3VtZW50VmFsaWRhdG9yKC4uLmFyZ3MpXHJcblx0XHRcdGlmIChyZXN1bHQgPT09IHRydWUpIHtcclxuXHRcdFx0XHRsb2FkU3RyYXRlZ2llcygpO1xyXG5cdFx0XHRcdGxvYWRRdWVyaWVzKCk7XHJcblx0XHRcdFx0cmV0dXJuIGdhbWUoLi4uYXJncyk7XHJcblx0XHRcdH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IocmVzdWx0KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjcmVhdGVzIGEgd3JhcHBlciBhcm91bmQgdGhlIGdhbWUsIHdoaWNoIGFjY2VwdHMgdGhlIGZpcnN0IGFyZ3VtZW50IChwbGF5ZXJzKSBhbmQgbGFzdCBhcmd1bWVudCAocGFyYW1ldGVycyksIGFuZCBwYXNzZXMgaXQgZm9yd2FyZC5cclxuXHRcdC8vIElmIGNvbWJpbmVQYXJhbWV0ZXJzIGlzIHNldCB0byB0cnVlLCB0aGVuIHRoZSBzZWNvbmQgYXJndW1lbnQgb2YgdGhlIHJldHVybmVkIGZ1bmN0aW9uIHdpbGwgZ2V0IG1lcmdlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50XHJcblx0XHQvLyBnaXZlbiB3aGVuIGdlbmVyYXRvciBpcyBjYWxsZWQuXHJcblx0XHRnZW5lcmF0ZS5jcmVhdGVHZW5lcmF0b3IgPSBmdW5jdGlvbiguLi5hcmdzKSB7XHJcblxyXG5cdFx0XHR2YXIgZ2FtZUNvZGUgPSBlc3ByaW1hLnBhcnNlU2NyaXB0KFwiKFwiICsgZ2FtZS50b1N0cmluZygpICsgXCIpXCIpXHJcblxyXG5cdFx0XHR2YXIgZ2FtZUFyZ3MgPSBnYW1lQ29kZS5ib2R5WzBdLmV4cHJlc3Npb24ucGFyYW1zXHJcblx0XHRcdHZhciBsYXN0QXJnID0gZ2FtZUFyZ3NbZ2FtZUFyZ3MubGVuZ3RoIC0gMV1cclxuXHJcblx0XHRcdHZhciBvcmlnaW5hbFBhcmFtZXRlcnNcclxuXHRcdFx0aWYgKChsYXN0QXJnLm5hbWUgJiYgbGFzdEFyZy5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwicGFyYW1ldGVyc1wiKSB8fCBsYXN0QXJnLnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiIHx8XHJcblx0XHRcdFx0KGxhc3RBcmcudHlwZSA9PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIgJiYgbGFzdEFyZy5sZWZ0LnR5cGUgPT0gXCJPYmplY3RQYXR0ZXJuXCIpKSB7XHJcblx0XHRcdFx0Ly8gQ2hlY2sgdGhhdCB0aGUgZ2FtZSBhcmd1bWVudHMgYW5kIGNyZWF0ZUdlbmVyYXRvciBhcmd1bWVudHMgYXJlIHRoZSBjb3JyZWN0IGxlbmd0aHMuIGNyZWF0ZUdlbmVyYXRvciBzaG91bGQgYmVcclxuXHRcdFx0XHQvLyAxIGxlc3MgdGhhbiBnYW1lLCBiZWNhdXNlIHBsYXllcnMgaXMgb21pdHRlZC5cclxuXHRcdFx0XHQvLyBUT0RPOiB1c2UgZXNwcmltYSB0byBhbGxvdyBwbGF5ZXJzIHRvIGJlIGFueXdoZXJlIGluIHRoZSBnYW1lIGRlZmluaXRpb24gKG9yIGV2ZW4gb21pdHRlZCkgcmF0aGVyIHRoYW4gZmlyc3RcclxuXHRcdFx0XHRpZiAoYXJncy5sZW5ndGggPT0gZ2FtZUFyZ3MubGVuZ3RoIC0gMSkgb3JpZ2luYWxQYXJhbWV0ZXJzID0gYXJncy5wb3AoKTtcclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbihwbGF5ZXJzLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHJcblx0XHRcdFx0Ly8gSWYgY29tYmluaW5nIHBhcmFtZXRlcnMsIG1lcmdlIGFuZCByZW1vdmUgZnJvbSBhcmd1bWVudHNcclxuXHRcdFx0XHRpZiAoY29tYmluZVBhcmFtZXRlcnMgJiYgb3JpZ2luYWxQYXJhbWV0ZXJzKSBwYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luYWxQYXJhbWV0ZXJzLFxyXG5cdFx0XHRcdFx0cGFyYW1ldGVycylcclxuXHJcblx0XHRcdFx0cmV0dXJuIGdlbmVyYXRlKHBsYXllcnMsIC4uLmFyZ3MsIHBhcmFtZXRlcnMpXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBBbGxvdyBmb3IgZ2FtZSBkZXNjcmlwdGlvbiBmZWF0dXJlXHJcblx0XHRnZW5lcmF0ZS5kZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gZ2FtZURlc2NyaXB0aW9uO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBEaXNwbGF5IGFueSBxdWVyaWVzXHJcblx0XHRnZW5lcmF0ZS5xdWVyaWVzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiBxdWVyaWVzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBnZW5lcmF0ZTtcclxuXHR9XHJcblxyXG5cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBzdG9ja0dhbWVzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIFN0cmF0ZWdpZXNcclxudmFyIHsgU3RyYXRlZ2llcyB9ID0gcmVxdWlyZShcIi4uL3N0cmF0ZWd5XCIpO1xyXG5cclxuLy8gUGxheWVyc1xyXG52YXIgeyBQbGF5ZXIgfSA9IHJlcXVpcmUoXCIuLi9wbGF5ZXJcIik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHQvLyBDcmVhdGUgYSBwbGF5ZXIgZm9yIGVhY2ggYXZhaWxhYmxlIHN0cmF0ZWd5XHJcblx0Z2VuZXJhdGVQb3B1bGF0aW9uKCkge1xyXG5cdFx0dmFyIHBsYXllcnMgPSBbXTtcclxuXHJcblx0XHRTdHJhdGVnaWVzKCkuZm9yRWFjaChmdW5jdGlvbihzdHJhdGVneSkge1xyXG5cdFx0XHRwbGF5ZXJzLnB1c2goUGxheWVyKHsgYXNzaWduOiBzdHJhdGVneSB9KSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gcGxheWVycztcclxuXHR9XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIHtTeW5jaHJvbm91c1Byb21pc2V9ID0gcmVxdWlyZSgnc3luY2hyb25vdXMtcHJvbWlzZScpO1xyXG5cclxudmFyIHR1cm4gPSB7XHJcblx0XHJcblx0Ly9SZWN1cnNlIHRocm91Z2ggdGhlIG9wdGlvbnMgaW4gaW5wdXQsIGFuZCB3cml0ZSB2YWwgdG8gb3V0cHV0LiBcclxuXHRyZWN1cnNlIDogZnVuY3Rpb24gcmVjdXJzZShpbnB1dCwgb3V0cHV0LCB2YWwsIHZhbEdlbmVyYXRvcj1mdW5jdGlvbigpe30sIHBhdGg9W10pe1xyXG5cdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKHBhdGgpLnRoZW4oZnVuY3Rpb24ocGF0aCl7XHJcblx0XHRcdFxyXG5cdFx0XHQvL1NpbmNlIHdlIHNsaWNlIHRoZSBhcnJheSBlYWNoIHRpbWUsIGlmIHRoZXJlIGFyZSBubyBtb3JlIGVudHJpZXMgbGVmdCB0aGVuIHdlJ3JlIGRvbmUgd2l0aCB0aGlzIGJyYW5jaC5cclxuXHRcdFx0aWYgKGlucHV0Lmxlbmd0aCA9PSAwKSByZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUocGF0aClcclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFx0XHQvL0Ftb25nIGFsbCB2YWx1ZXMgZnJvbSB0aGUgYXJyYXlcclxuXHRcdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5hbGwoaW5wdXRbMF0ubWFwKGZ1bmN0aW9uKGl0ZW0pe1xyXG5cdFx0XHRcdHZhciB2YWx1ZTtcclxuXHRcdFx0XHR2YXIgc3BsaXRQYXRoID0gcGF0aC5zbGljZSgwKS5jb25jYXQoaXRlbSk7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly9JZiB0aGVyZSBhcmUgbW9yZSBpdGVtcyB0byBpdGVyYXRlIG92ZXIsIGluY2x1ZGUgdGhlbSBpbiB0aGUgb3V0cHV0IHRoZW4gcmVjdXJzZS5cclxuXHRcdFx0XHQvL0lmIG5vdCwgcHV0IGluIHRoZSBuZXcgdmFsdWUuXHJcblx0XHRcdFx0aWYgKGlucHV0Lmxlbmd0aCA9PSAxKSB7XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdC8vSWYgdmFsIGlzIGEgZnVuY3Rpb24sIHdyYXAgaXQgaW4gYSBmdW5jdGlvbiB0aGF0IHdpbGwgZ2V0IHN1cHBsaWVkIGFuIGFyZ3VtZW50IHdpdGggd2hlcmUgd2UgYXJlXHRcdFx0XHRcclxuXHRcdFx0XHRcdGlmICh0eXBlb2YgdmFsID09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGZ1bmN0aW9uKCl7XHRcclxuXHRcdFx0XHRcdFx0XHR2YXIgYXJncyA9IFtzcGxpdFBhdGhdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB2YWx1ZSA9IHZhbCB8fCB2YWxHZW5lcmF0b3Ioc3BsaXRQYXRoKTtcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0b3V0cHV0W2l0ZW1dID0gdmFsdWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Ugb3V0cHV0W2l0ZW1dID0ge307XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0cmV0dXJuIHJlY3Vyc2UoaW5wdXQuc2xpY2UoMSksb3V0cHV0W2l0ZW1dLCB2YWwsIHZhbEdlbmVyYXRvciwgc3BsaXRQYXRoKTtcclxuXHRcdFx0fSkpO1x0XHRcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHR1cm47IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgeyBldmFsdWF0ZVF1ZXJ5IH0gPSByZXF1aXJlKFwiLi9xdWVyeVwiKVxyXG5cclxudmFyIHsgcmVnaXN0cnkgfSA9IHJlcXVpcmUoXCIuL3N0YXRlXCIpXHJcblxyXG52YXIgeyBpc09iamVjdCwgaXNGdW5jdGlvbiB9ID0gcmVxdWlyZShcIi4vaGVscGVyZnVuY3Rpb25zXCIpKFwiZ2VuZXJhbFwiKTtcclxuXHJcbi8vRXh0ZW5zaW9uIG9mIGFycmF5IHRvIGhhbmRsZSBoaXN0b3J5IGxpc3RzLlxyXG5mdW5jdGlvbiBIaXN0b3J5KC4uLmFyZ3MpIHtcclxuXHRpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkgYXJncyA9IGFyZ3NbMF07XHJcblxyXG5cdE9iamVjdC5zZXRQcm90b3R5cGVPZihhcmdzLCBIaXN0b3J5LnByb3RvdHlwZSk7XHJcblxyXG5cdGFyZ3MubG9nID0gYXJncy5zbGljZSgpO1xyXG5cdGFyZ3MubG9nLnRyZWUgPSBhcmdzO1xyXG5cdE9iamVjdC5zZXRQcm90b3R5cGVPZihhcmdzLmxvZywgSGlzdG9yeS5wcm90b3R5cGUpO1xyXG5cclxuXHRhcmdzLnNjb3JlcyA9IFtdO1xyXG5cdGFyZ3Muc2NvcmVzLnRyZWUgPSBhcmdzO1xyXG5cdE9iamVjdC5zZXRQcm90b3R5cGVPZihhcmdzLnNjb3JlcywgSGlzdG9yeS5wcm90b3R5cGUpO1xyXG5cclxuXHRyZXR1cm4gYXJncztcclxufVxyXG5cclxuSGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFycmF5LnByb3RvdHlwZSk7XHJcbkhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGlzdG9yeTtcclxuXHJcbi8vVG8gYWRkIGVudHJ5XHJcbkhpc3RvcnkucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGVudHJ5KSB7XHJcblx0Ly9BZGQgdG8gaGlzdG9yeSBhbmQgdG8gbG9nXHJcblx0dGhpcy5wdXNoKGVudHJ5KTtcclxuXHRpZiAodGhpcy5sb2cpIHRoaXMubG9nLnB1c2goZW50cnkpO1xyXG5cclxuXHQvL0N5Y2xlIHVwIHRoZSBwYXJlbnQgdHJlZSwgYWRkIHRvIGVhY2ggbG9nXHJcblx0dmFyIGNoZWNrID0gdGhpcztcclxuXHRpZiAoY2hlY2sudHJlZSBpbnN0YW5jZW9mIEhpc3RvcnkgJiYgY2hlY2sudHJlZS5wYXJlbnQgaW5zdGFuY2VvZiBIaXN0b3J5KSB7XHJcblx0XHRjaGVjay50cmVlLnBhcmVudC5sb2cuYWRkKGVudHJ5KTtcclxuXHR9XHJcblx0aWYgKGNoZWNrLnBhcmVudCBpbnN0YW5jZW9mIEhpc3RvcnkpIHtcclxuXHRcdGNoZWNrLnBhcmVudC5sb2cuYWRkKGVudHJ5KTtcclxuXHR9XHJcblxyXG5cdC8vSWYgd2UncmUgYmVpbmcgY2FsbGVkIGZyXHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy9UbyBhZGQgZW50cnkgd2l0aG91dCBsb2dnaW5nIChmb3IgcGxheWFibGVzIHRoYXQgd291bGQgbGlrZSB0aGUgdHJlZSBoaXN0b3J5XHJcbi8vdG8gYmUgc3RydWN0dXJlZCBkaWZmZXJlbnRseSB0aGFuIHRoZSBsb2cgaGlzdG9yeS5cclxuSGlzdG9yeS5wcm90b3R5cGUuYWRkTm9Mb2cgPSBmdW5jdGlvbihlbnRyeSkge1xyXG5cdHRoaXMucHVzaChlbnRyeSk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5cclxuSGlzdG9yeS5wcm90b3R5cGUuYWRkU2NvcmVzID0gZnVuY3Rpb24oZW50cnkpIHtcclxuXHQvL0FkZCB0byBoaXN0b3J5XHJcblx0dGhpcy5zY29yZXMucHVzaChlbnRyeSk7XHJcblxyXG5cdC8vQ3ljbGUgdXAgdGhlIHBhcmVudCB0cmVlLCBhZGQgdG8gZWFjaCBsb2dcclxuXHR2YXIgY2hlY2sgPSB0aGlzO1xyXG5cdGlmIChjaGVjay5wYXJlbnQgaW5zdGFuY2VvZiBIaXN0b3J5KSB7XHJcblx0XHRjaGVjay5wYXJlbnQuYWRkU2NvcmVzKGVudHJ5KTtcclxuXHR9XHJcblxyXG5cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5cclxuLy9BIHRlbXBvcmFyeSBIaXN0b3J5IHRoYXQgY2FuIGJlIG1lcmdlZCBiYWNrIGluIGxhdGVyLiBUaGUgY2hpbGQgYW5kIHBhcmVudCBhcmUgbGlua2VkIHVudGlsIC5vcnBoYW4oKSBpcyBjYWxsZWQuXHJcbkhpc3RvcnkucHJvdG90eXBlLmNoaWxkID0gZnVuY3Rpb24ocGFyZW50ID0gdGhpcykge1xyXG5cdHZhciBoID0gbmV3IEhpc3RvcnkoKTtcclxuXHRoLnBhcmVudCA9IHBhcmVudDtcclxuXHRyZXR1cm4gaDtcclxufTtcclxuXHJcbi8vU2FtZSBhcyAuY2hpbGQgZXhjZXB0IGluY2x1ZGVzIHByaW9yIHBhcmVudCBoaXN0b3J5IHdoZW4gLnByaW50KCkgaXMgY2FsbGVkLlxyXG5IaXN0b3J5LnByb3RvdHlwZS5jaGlsZFdpdGhDb250ZW50ID0gZnVuY3Rpb24ocGFyZW50ID0gdGhpcykge1xyXG5cdHZhciBzdG9yZWRMb2cgPSBwYXJlbnQuc2xpY2UoKTtcclxuXHR2YXIgc3RvcmVkU2NvcmVzID0gcGFyZW50LnNsaWNlKCk7XHJcblxyXG5cdHZhciBoID0gbmV3IEhpc3RvcnkoKTtcclxuXHJcblxyXG5cdGgubG9nLnByaW50ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRIaXN0b3J5LnByb3RvdHlwZS5wcmludC5jYWxsKHN0b3JlZExvZy5jb25jYXQoaC5sb2cpKVxyXG5cdH1cclxuXHRoLnNjb3Jlcy5wcmludCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0SGlzdG9yeS5wcm90b3R5cGUucHJpbnQuY2FsbChzdG9yZWRTY29yZXMuY29uY2F0KGguc2NvcmVzKSlcclxuXHR9XHJcblxyXG5cdGgucGFyZW50ID0gcGFyZW50O1xyXG5cdHJldHVybiBoO1xyXG59O1xyXG5cclxuLy9UaGlzIHNldmVycyB0aGUgbGluayBiZXR3ZWVuIHRoZSB0ZW1wb3JhcnkgaGlzdG9yeSBhbmQgaXRzIHBhcmVudC4gVXNlIHRoaXMgd2hlbiBtZXJnaW5nIGNvbXBvc2l0ZSBlbnRyaWVzLlxyXG5IaXN0b3J5LnByb3RvdHlwZS5vcnBoYW4gPSBmdW5jdGlvbigpIHtcclxuXHRkZWxldGUgdGhpcy5wYXJlbnQ7XHJcblx0ZGVsZXRlIHRoaXMubG9nO1xyXG5cdGRlbGV0ZSB0aGlzLnNjb3JlcztcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vQ2xlYXIgaGlzdG9yeVxyXG5IaXN0b3J5LnByb3RvdHlwZS5jbGVhckhpc3RvcnkgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLnNwbGljZSgwLCB0aGlzLmxlbmd0aCk7XHJcblx0aWYgKHRoaXMubG9nKSB0aGlzLmxvZy5zcGxpY2UoMCwgdGhpcy5sb2cubGVuZ3RoKTtcclxuXHRpZiAodGhpcy5zY29yZXMpIHRoaXMuc2NvcmVzLnNwbGljZSgwLCB0aGlzLnNjb3Jlcy5sZW5ndGgpO1xyXG5cdGRlbGV0ZSB0aGlzLnBhcmVudDtcclxufTtcclxuXHJcbi8vRW5kIHRoZSBnYW1lLlxyXG5IaXN0b3J5LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLnN0b3AgPSB0cnVlO1xyXG5cdGlmICh0aGlzLnBhcmVudCkgdGhpcy5wYXJlbnQuZW5kKCk7XHJcbn07XHJcblxyXG4vL0dldCBhIHBhcnRpY3VsYXIgc29ydCBvZiBlbnRyeSwgZWcuIFR1cm4uXHJcbkhpc3RvcnkucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbih0eXBlKSB7XHJcblx0cmV0dXJuIG5ldyBIaXN0b3J5KFxyXG5cdFx0dGhpcy5maWx0ZXIoZnVuY3Rpb24oZW50cnkpIHtcclxuXHRcdFx0Ly9JZiBpdCdzIG5vdCBhbiBvYmplY3QsIGRvbid0IGV2ZW4gYm90aGVyLlxyXG5cdFx0XHRpZiAoIWlzT2JqZWN0KGVudHJ5KSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIga2V5IGluIGVudHJ5KSB7XHJcblx0XHRcdFx0aWYgKGtleSA9PSB0eXBlKSByZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fSlcclxuXHQpO1xyXG59O1xyXG5cclxuSGlzdG9yeS5wcm90b3R5cGUubW9zdFJlY2VudCA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzW3RoaXMubGVuZ3RoIC0gMV1cclxufVxyXG5cclxuLy9IZWxwIHJlYWQgdGhlIGhpc3RvcnkgaW4gQ2hyb21lIHdpdGggbGVzcyBjbHV0dGVyLlxyXG5IaXN0b3J5LnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBoaXN0b3J5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzKSk7XHJcblx0aGlzdG9yeS5xdWVyeSA9IEhpc3RvcnkucHJvdG90eXBlLnF1ZXJ5XHJcblx0cmV0dXJuIGhpc3Rvcnk7XHJcbn07XHJcblxyXG5IaXN0b3J5LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHF1ZXJ5U3RyaW5nLCAuLi5hcmdzKSB7XHJcblx0cmV0dXJuIGV2YWx1YXRlUXVlcnkocXVlcnlTdHJpbmcsIHRoaXMsIC4uLmFyZ3MpXHJcbn1cclxuXHJcbi8vU3VwcGx5IGFuIGVudHJ5LCBpdCB3aWxsIGNoZWNrIGZvciBhIHByb3BlcnR5IHRoYXQgaXMgYSBIaXN0b3J5XHJcbkhpc3RvcnkucHJvdG90eXBlLnJlY3Vyc2UgPSBmdW5jdGlvbih0eXBlKSB7XHJcblx0dmFyIGxpc3QgPSB0aGlzO1xyXG5cclxuXHRyZXR1cm4gbmV3IEhpc3RvcnkoXHJcblx0XHRsaXN0Lm1hcChmdW5jdGlvbihlbnRyeSkge1xyXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gZW50cnkpIHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhrZXksIGVudHJ5KTtcclxuXHRcdFx0XHRpZiAoZW50cnlba2V5XSBpbnN0YW5jZW9mIEhpc3RvcnkpIHJldHVybiBlbnRyeVtrZXldLnJlY3Vyc2UodHlwZSk7XHJcblx0XHRcdFx0ZWxzZSBpZiAoa2V5ID09IHR5cGUpIHJldHVybiBlbnRyeTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH0pXHJcblx0KTtcclxufTtcclxuXHJcbi8vQWNjZXB0IGEgSGlzdG9yeSBhbmQgcmV0dXJuIG9uZSBzdWl0YWJsZSBmb3IgdGhlIHVzZXJcclxuZnVuY3Rpb24gVXNlckhpc3RvcnkoaGlzdG9yeSkge1xyXG5cdHZhciB1c2VySGlzdG9yeSA9IGhpc3RvcnkubWFwKGZ1bmN0aW9uKGVudHJ5KSB7XHJcblx0XHRyZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbnRyeSkpO1xyXG5cdH0pO1xyXG5cdGlmIChoaXN0b3J5LmxvZykge1xyXG5cdFx0dXNlckhpc3RvcnkubG9nID0gbmV3IFVzZXJIaXN0b3J5KGhpc3RvcnkubG9nKVxyXG5cdH07XHJcblx0aWYgKGhpc3Rvcnkuc2NvcmVzKSB7XHJcblx0XHR1c2VySGlzdG9yeS5zY29yZXMgPSBuZXcgVXNlckhpc3RvcnkoaGlzdG9yeS5zY29yZXMpXHJcblx0fVxyXG5cclxuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YodXNlckhpc3RvcnksIFVzZXJIaXN0b3J5LnByb3RvdHlwZSk7XHJcblxyXG5cdC8vQXR0YWNoIG1ldGhvZHMgZnJvbSBIaXN0b3J5LCB3cmFwcGVkIGluIGEgZnVuY3Rpb24uIElmIHRob3NlIG1ldGhvZHMgcmV0dXJuIGEgaGlzdG9yeSxcclxuXHQvL3RoZW4gdGhlIGZ1bmN0aW9uIHdpbGwgY29udmVydCB0aGF0IHRvIGEgdXNlckhpc3RvcnkuXHJcblx0Zm9yICh2YXIgbWV0aG9kIGluIEhpc3RvcnkucHJvdG90eXBlKSB7XHJcblx0XHRpZiAoaXNGdW5jdGlvbihoaXN0b3J5W21ldGhvZF0pKSB7XHJcblx0XHRcdGlmIChtZXRob2QgIT0gXCJjb25zdHJ1Y3RvclwiKVxyXG5cdFx0XHRcdHVzZXJIaXN0b3J5W21ldGhvZF0gPSAoZnVuY3Rpb24obWV0aG9kKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdHZhciByZXN1bHQgPSBoaXN0b3J5W21ldGhvZF0uYXBwbHkoaGlzdG9yeSwgYXJndW1lbnRzKTtcclxuXHRcdFx0XHRcdFx0aWYgKHJlc3VsdCBpbnN0YW5jZW9mIEhpc3RvcnkpIHJldHVybiBuZXcgVXNlckhpc3RvcnkocmVzdWx0KTtcclxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoaXNPYmplY3QocmVzdWx0KSlcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcclxuXHRcdFx0XHRcdFx0ZWxzZSByZXR1cm4gcmVzdWx0O1xyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHR9KShtZXRob2QpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHVzZXJIaXN0b3J5O1xyXG59XHJcblxyXG5Vc2VySGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEhpc3RvcnkucHJvdG90eXBlKTtcclxuVXNlckhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVXNlckhpc3Rvcnk7XHJcblxyXG52YXIgZ2FtZUhpc3RvcnkgPSBuZXcgSGlzdG9yeSgpOyAvL1RPRE86IGFkZCBjaG9pY2Utb25seSBoaXN0b3J5XHJcblxyXG52YXIgdXNlckdhbWVIaXN0b3J5ID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBVc2VySGlzdG9yeShnYW1lSGlzdG9yeSlcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IEhpc3RvcnksIFVzZXJIaXN0b3J5LCBnYW1lSGlzdG9yeSwgdXNlckdhbWVIaXN0b3J5IH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy9XaGVuIGEgc3RyYXRlZ3kncyAuY2hvb3NlKCkgZnVuY3Rpb24gaXMgY2FsbGVkLCBpdCBpcyBnaXZlbiBhbiBpbmZvcm1hdGlvbiBzZXQuIFRoYXQgZGF0YSBpcyBhIGxpbWl0ZWQgbWFwIG9mIHRoZSBpbnRlcm5hbCBvYmplY3RzIG9mIHRoZSBnYW1lIGVuZ2luZSwgaW5jbHVkaW5nIGluZm9ybWF0aW9uIG9uIHRoZSBnYW1lIGhpc3RvcnkgYW5kIHRoZSBwbGF5ZXJzLiBUaGlzIGlzIHRocmVhZGVkIHRocm91Z2ggcGxheWFibGVzLCBtdWNoIGxpa2UgSGlzdG9yeSwgc28gdGhhdCBhIHBhcmVudCBwbGF5YWJsZSBjYW4gc3BlY2lmeSBhbiBpbmZvcm1hdGlvbiBzZXQgZm9yIHRoZSBwbGF5YWJsZXMgaXQgY2FsbHMsIG9yIGVsc2UgdGhlIGRlZmF1bHQgY29uc3RydWN0aW9uIHdpbGwgYmUgdXNlZC4gQWRkaXRpb25hbGx5LCB0aGUgdXNlciBjYW4gcHJvdmlkZSBhIGZpbHRlciBmdW5jdGlvbiwgdG8gc2VsZWN0aXZlbHkgZGVsZXRlIChvciBhZGQpIGluZm9ybWF0aW9uIGVsZW1lbnRzIGJlZm9yZSB0aGV5IGFyZSBwYXNzZWQgdG8gLmNob29zZSgpLlxyXG5cclxuLy9IaXN0b3J5IGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lSGlzdG9yeSwgSGlzdG9yeSB9ID0gcmVxdWlyZSgnLi9oaXN0b3J5Jyk7XHJcblxyXG4vL1BvcHVsYXRpb24gZnVuY3Rpb25zXHJcbnZhciB7IGdhbWVQb3B1bGF0aW9uLCBQbGF5ZXJMaXN0IH0gPSByZXF1aXJlKCcuL3BvcHVsYXRpb24nKTtcclxuXHJcblxyXG5mdW5jdGlvbiBJbmZvcm1hdGlvbihoaXN0b3J5ID0gZ2FtZUhpc3RvcnksIHBvcHVsYXRpb24gPSBnYW1lUG9wdWxhdGlvbiwgeyBwYXJlbnRIaXN0b3J5ID0gW10gfSA9IHt9KSB7XHJcblx0dGhpcy5oaXN0b3J5ID0gaGlzdG9yeTtcclxuXHR0aGlzLnBvcHVsYXRpb24gPSBwb3B1bGF0aW9uO1xyXG5cclxuXHQvLyBSZWNvcmQgYW55IGhpc3RvcnkgZW50cmllcyB0aGF0IG5lZWQgdG8gYmUgYWRkZWQgdG8gdGhlIHJlY29yZHNcclxuXHR0aGlzLnBhcmVudEhpc3RvcnkgPSBwYXJlbnRIaXN0b3J5LnNsaWNlKDApO1xyXG5cclxuXHR0aGlzLmFkZGl0aW9uYWwgPSBbXTtcclxuXHJcblx0dGhpcy51cGRhdGUoKTtcclxufTtcclxuXHJcbi8vQ2hlY2sgdGhlIHNvdXJjZSB0aGVuIGNhY2hlIGEgaGFyZC1jb3B5LlxyXG5JbmZvcm1hdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ocGxheWVyLCBsb2NhbCkge1xyXG5cdHRoaXMuaW5mb1BvcHVsYXRpb24gPSB0aGlzLnBvcHVsYXRpb24oKS5pbmZvKCk7XHJcblxyXG5cdHRoaXMuaW5mb0hpc3RvcnkgPSB7IGxvZzogdGhpcy5wYXJlbnRIaXN0b3J5LmNvbmNhdCh0aGlzLmhpc3RvcnkubG9nKS5zbGljZSgwKSwgc2NvcmVzOiB0aGlzLmhpc3Rvcnkuc2NvcmVzXHJcblx0XHRcdC5zbGljZSgwKSB9O1xyXG5cclxuXHR0aGlzLmFkZGl0aW9uYWwgPSBbXTtcclxuXHJcblx0Ly9SZXR1cm4gdmFsdWUuIE1pbWljcyAuZGVsaXZlcigpXHJcblx0dmFyIGluZm9ybWF0aW9uID0ge1xyXG5cdFx0aGlzdG9yeTogeyBsb2c6IHRoaXMuaW5mb0hpc3RvcnkubG9nLCBzY29yZXM6IHRoaXMuaW5mb0hpc3Rvcnkuc2NvcmVzIH0sXHJcblx0XHRwb3B1bGF0aW9uOiB0aGlzXHJcblx0XHRcdC5pbmZvUG9wdWxhdGlvblxyXG5cdH1cclxuXHRpZiAocGxheWVyKSBpbmZvcm1hdGlvbi5tZSA9IGluZm9ybWF0aW9uLnBvcHVsYXRpb24uZ2V0KHBsYXllci5pZCk7XHJcblx0aWYgKGxvY2FsKSBPYmplY3QuYXNzaWduKGluZm9ybWF0aW9uLCBsb2NhbCk7XHJcblxyXG5cdHJldHVybiBpbmZvcm1hdGlvbjtcclxufTtcclxuXHJcbi8vQ2xvbmUgdGhlIGNhY2hlZCBjb3BpZXMgYW5kIHByb3ZpZGUgdGhlbS4gV2lsbCBkZWxpdmVyIHRoZSBzYW1lIHRoaW5nIGV2ZXJ5IHRpbWUgdW50aWwgdXBkYXRlIGlzIGNhbGxlZC5cclxuSW5mb3JtYXRpb24ucHJvdG90eXBlLmRlbGl2ZXIgPSBmdW5jdGlvbihwbGF5ZXIsIGxvY2FsKSB7XHJcblx0dmFyIGluZm9ybWF0aW9uID0ge1xyXG5cdFx0aGlzdG9yeTogeyBsb2c6IHRoaXMuaW5mb0hpc3RvcnkubG9nLCBzY29yZXM6IHRoaXMuaW5mb0hpc3Rvcnkuc2NvcmVzIH0sXHJcblx0XHRwb3B1bGF0aW9uOiB0aGlzXHJcblx0XHRcdC5pbmZvUG9wdWxhdGlvblxyXG5cdH1cclxuXHJcblxyXG5cdGlmIChwbGF5ZXIpIGluZm9ybWF0aW9uLm1lID0gaW5mb3JtYXRpb24ucG9wdWxhdGlvbi5nZXQocGxheWVyLmlkKTtcclxuXHRpZiAobG9jYWwpIE9iamVjdC5hc3NpZ24oaW5mb3JtYXRpb24sIGxvY2FsKTtcclxuXHRpZiAodGhpcy5hZGRpdGlvbmFsKSB0aGlzLmFkZGl0aW9uYWwuZm9yRWFjaChmdW5jdGlvbihlbnRyeSkgeyBPYmplY3QuYXNzaWduKGluZm9ybWF0aW9uLCBlbnRyeSkgfSk7XHJcblxyXG5cdHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGluZm9ybWF0aW9uKSk7XHJcbn07XHJcblxyXG4vL1RoaXMgcHJvYmFibHkgZG9lc24ndCBuZWVkIHRvIGJlIGEgc2VwYXJhdGUgZnVuY3Rpb24sIGJ1dCBhZGRpbmcgaXQgaW4gY2FzZSBpdCBleHBhbmRzIGxhdGVyLlxyXG5JbmZvcm1hdGlvbi5wcm90b3R5cGUuYWRkQWRkaXRpb25hbCA9IGZ1bmN0aW9uKGVudHJ5ID0gbnVsbCkge1xyXG5cdGlmIChlbnRyeSkgdGhpcy5hZGRpdGlvbmFsLnB1c2goZW50cnkpO1xyXG59O1xyXG5cclxuLy9NYWtlIGNvcHkgb2YgdGhpcyBpbmZvcm1hdGlvbiBmdW5jdGlvbiwgd2hpY2ggYWxsb3dzIGZvciB1cGRhdGluZyBhbmQgZnJlZXppbmcuXHJcbkluZm9ybWF0aW9uLnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBpbmZvcm1hdGlvbiA9IG5ldyBJbmZvcm1hdGlvbih0aGlzLmhpc3RvcnksIHRoaXMucG9wdWxhdGlvbiwgeyBwYXJlbnRIaXN0b3J5OiB0aGlzLnBhcmVudEhpc3RvcnkgfSk7XHJcblxyXG5cdHJldHVybiBpbmZvcm1hdGlvbjtcclxufTtcclxuXHJcblxyXG5cclxuLy9HYW1lIHN0YXRlLCBhbmFsb2dvdXMgdG8gZ2FtZUhpc3RvcnlcclxudmFyIFBlcmZlY3RJbmZvcm1hdGlvbiA9IG5ldyBJbmZvcm1hdGlvbihnYW1lSGlzdG9yeSwgZ2FtZVBvcHVsYXRpb24pO1xyXG5cclxuLy9PdmVyd3JpdGUgLmRlbGl2ZXIoKS4gUGVyZmVjdEluZm9ybWF0aW9uIGlzIGFsd2F5cyB1cC10by1kYXRlISBUaHVzIG5vIG5lZWQgdG8gZG8gYSAybmQgSlNPTi5zdHJpbmdpZnkuXHJcblBlcmZlY3RJbmZvcm1hdGlvbi5kZWxpdmVyID0gZnVuY3Rpb24ocGxheWVyLCBsb2NhbCkge1xyXG5cclxuXHR2YXIgaW5mb3JtYXRpb24gPSB0aGlzLnVwZGF0ZShwbGF5ZXIsIGxvY2FsKTtcclxuXHJcblx0aWYgKHBsYXllcikgaW5mb3JtYXRpb24ubWUgPSBpbmZvcm1hdGlvbi5wb3B1bGF0aW9uLmdldChwbGF5ZXIuaWQpO1xyXG5cdGlmIChsb2NhbCkgT2JqZWN0LmFzc2lnbihpbmZvcm1hdGlvbiwgbG9jYWwpO1xyXG5cclxuXHRyZXR1cm4gaW5mb3JtYXRpb247XHJcbn07XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IEluZm9ybWF0aW9uLCBQZXJmZWN0SW5mb3JtYXRpb24gfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuXHJcbnZhciBsb2dnZXIgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYXJncyA9IFsuLi5hcmd1bWVudHNdO1xyXG5cdHZhciBsZXZlbCA9IChhcmdzWzBdID09IFwic2lsbHlcIiB8fCAhYXJnc1swXSkgPyBcInRyYWNlXCIgOiBhcmdzWzBdO1xyXG5cdHZhciBsZXZlbCA9IGxldmVsID09IFwid2FybmluZ1wiID8gXCJ3YXJuXCIgOiBsZXZlbDtcclxuXHRhcmdzLnNoaWZ0KCk7XHJcblxyXG5cdGxvZ2dlci5sb2dnZXJbbGV2ZWxdLmFwcGx5KGxvZ2dlci5sb2dnZXIsIGFyZ3MpO1xyXG59O1xyXG5cclxuLy9sb2dnZXIubG9nZ2VyID0gY29uc29sZTtcdFx0XHRcdFx0Ly9UT0RPIGNsZWFuIHRoaXMgYWxsIHVwIGEgbG90LlxyXG5cclxudmFyIGdldExvZ2dlciA9IHJlcXVpcmUoXCJsb2dsZXZlbC1jb2xvcmVkLWxldmVsLXByZWZpeFwiKTtcclxudmFyIG9wdGlvbnMgPSB7IHByZWZpeDogJ25hc2hKUycsIGxldmVsOiAndHJhY2UnIH1cclxubG9nZ2VyLmxvZ2dlciA9IGdldExvZ2dlcihvcHRpb25zKVxyXG5cclxubG9nZ2VyLnNldExldmVsID0gZnVuY3Rpb24obGV2ZWwpIHtcclxuXHRsb2dnZXIubG9nZ2VyLmxldmVsID0gbGV2ZWw7XHJcblx0bG9nZ2VyLmxvZ2dlci5zZXRMZXZlbChsZXZlbClcclxufTtcclxuXHJcbi8qXHJcbmxvZ2dlci51c2VXaW5zdG9uID0gZnVuY3Rpb24oKXtcclxuXHJcblx0dmFyIHdpbnN0b24gPSByZXF1aXJlKCd3aW5zdG9uJyk7XHJcblx0dmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XHJcblxyXG5cdHdpbnN0b24ubGV2ZWwgPSBcIndhcm5cIjtcclxuXHJcblx0d2luc3Rvbi5jbGVhcigpXHJcblx0d2luc3Rvbi5hZGQod2luc3Rvbi50cmFuc3BvcnRzLkNvbnNvbGUsIHtcclxuXHRcdGxldmVsOiAndHJhY2UnLFxyXG5cdFx0cHJldHR5UHJpbnQ6ICBmdW5jdGlvbiAoIG9iamVjdCApe1xyXG5cdFx0XHRyZXR1cm4gdXRpbC5pbnNwZWN0KG9iamVjdCk7XHJcblx0XHR9LFxyXG5cdFx0Y29sb3JpemU6IHRydWUsXHJcblx0XHRzaWxlbnQ6IGZhbHNlLFxyXG5cdFx0dGltZXN0YW1wOiBmYWxzZVxyXG5cdH0pO1xyXG5cclxuXHR0aGlzLmxvZ2dlciA9IHdpbnN0b247XHJcbn07XHJcbiovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGxvZ2dlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZShcIi4vbG9nZ2VyXCIpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlzRnVuY3Rpb24gfSA9IHJlcXVpcmUoXCIuL2hlbHBlckZ1bmN0aW9uc1wiKShcImdlbmVyYWxcIik7XHJcblxyXG4vLyBFeHRlbmQgZnVuY3Rpb24sIHRoZSBzbmVha3kgd2F5LlxyXG52YXIgdmFyaWFibGVQcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZ1bmN0aW9uLnByb3RvdHlwZSk7XHJcblxyXG52YXJpYWJsZVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKHZhbHVlLCB7IGVuZm9yY2VOdW1iZXIgPSB0cnVlIH0gPSB7fSkge1xyXG5cdHZhciB2YXJpYWJsZSA9IHRoaXM7XHJcblx0dmFyaWFibGUudmFsdWUgPSBlbmZvcmNlTnVtYmVyID8gdmFsdWUgKiAxIDogdmFsdWU7XHJcblx0dmFyaWFibGUuZW5mb3JjZU51bWJlciA9IGVuZm9yY2VOdW1iZXJcclxuXHJcblx0dGhpcy5pZCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIF9wbGF5YWJsZS5pZDtcclxuXHR9OyAvL1RPRE86IHdvcmsgb24gaWRzIGFuZCByZWdpc3RyYXRpb25cclxufTtcclxuXHJcbnZhcmlhYmxlUHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy52YWx1ZTtcclxufTtcclxuXHJcbnZhcmlhYmxlUHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmNhbGwoKTtcclxufTtcclxudmFyaWFibGVQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5jYWxsKCk7XHJcbn07XHJcbnZhcmlhYmxlUHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5jYWxsKCk7XHJcbn07XHJcblxyXG52YXJpYWJsZVByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuZXdWYWx1ZSkge1xyXG5cdHRoaXMudmFsdWUgPSB0aGlzLmVuZm9yY2VOdW1iZXIgPyBuZXdWYWx1ZSAqIDEgOiBuZXdWYWx1ZVxyXG5cdHJldHVybiB0aGlzLnZhbHVlO1xyXG59O1xyXG5cclxuLy9SZXB1cnBvc2UgdGhlIHZlcnktc2ltaWxhciBjb2RlIGZvciBWYXJpYWJsZSwgYnV0IHJlLXdyaXRlIGNlcnRhaW4ga2V5c1xyXG52YXIgZXhwcmVzc2lvblByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRnVuY3Rpb24ucHJvdG90eXBlKTtcclxuXHJcbmV4cHJlc3Npb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBmdW5jdGlvbihleHByZXNzaW9uKSB7XHJcblx0aWYgKCFpc0Z1bmN0aW9uKGV4cHJlc3Npb24pKSBsb2coXCJlcnJvclwiLCBcIkV4cHJlc3Npb24gbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcclxuXHJcblx0dmFyIHZhbHVlID0gZXhwcmVzc2lvbigpO1xyXG5cdGlmIChpc05hTih2YWx1ZSkpIGxvZyhcImVycm9yXCIsIFwiRXhwcmVzc2lvbiBtdXN0IHJldHVybiBhIG51bWJlclwiKTsgLy9UT0RPOiBzaG91bGQgRXhwcmVzc2lvbnMvVmFyaWFibGVzIGFsbG93IHN0cmluZ3M/XHJcblxyXG5cdHRoaXMudmFsdWUgPSBleHByZXNzaW9uO1xyXG5cclxuXHRyZXR1cm4gdmFsdWU7XHJcbn07XHJcblxyXG5leHByZXNzaW9uUHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy52YWx1ZSgpICogMTtcclxufTtcclxuXHJcbmV4cHJlc3Npb25Qcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuY2FsbCgpO1xyXG59O1xyXG5leHByZXNzaW9uUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuY2FsbCgpO1xyXG59O1xyXG5leHByZXNzaW9uUHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5jYWxsKCk7XHJcbn07XHJcblxyXG5leHByZXNzaW9uUHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5ld0V4cHJlc3Npb24pIHtcclxuXHRpZiAoIWlzRnVuY3Rpb24obmV3RXhwcmVzc2lvbikpXHJcblx0XHRsb2coXCJlcnJvclwiLCBcIkV4cHJlc3Npb24gbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcclxuXHJcblx0dmFyIHZhbHVlID0gbmV3RXhwcmVzc2lvbigpO1xyXG5cdHRoaXMudmFsdWUgPSBuZXdFeHByZXNzaW9uO1xyXG5cclxuXHRyZXR1cm4gdmFsdWU7XHJcbn07XHJcblxyXG4vL1Byb2R1Y2VzIHRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgcHJvZHVjZSB0aGUgZW5kIHJlc3VsdC4gVGhpcyBwYXJ0IGlzIHJldXNhYmxlIGlmIHlvdSBuZWVkIHRvIGRvIHRoaXMgYWdhaW4uXHJcbnZhciBjbGFzc0ZhY3RvcnkgPSBmdW5jdGlvbihwcm90bykge1xyXG5cdHJldHVybiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBmID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiBmLmNhbGwuYXBwbHkoZiwgYXJndW1lbnRzKTtcclxuXHRcdH07XHJcblxyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwiY29uc3RydWN0b3JcIiwge1xyXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXHJcblx0XHRcdHdyaXRhYmxlOiB0cnVlXHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcImNhbGxcIiwge1xyXG5cdFx0XHR3cml0YWJsZTogdHJ1ZVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJ0b1N0cmluZ1wiLCB7XHJcblx0XHRcdHdyaXRhYmxlOiB0cnVlXHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcInZhbHVlT2ZcIiwge1xyXG5cdFx0XHR3cml0YWJsZTogdHJ1ZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0T2JqZWN0LmtleXMocHJvdG8pLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcblx0XHRcdGZba2V5XSA9IHByb3RvW2tleV07XHJcblx0XHR9KTtcclxuXHJcblx0XHRmLmNvbnN0cnVjdG9yLmFwcGx5KGYsIGFyZ3VtZW50cyk7XHJcblxyXG5cdFx0cmV0dXJuIGY7XHJcblx0fTtcclxufTtcclxuXHJcbnZhciBWYXJpYWJsZSA9IGNsYXNzRmFjdG9yeSh2YXJpYWJsZVByb3RvdHlwZSk7XHJcbnZhciBFeHByZXNzaW9uID0gY2xhc3NGYWN0b3J5KGV4cHJlc3Npb25Qcm90b3R5cGUpO1xyXG4vLyBjYWxsZWQgYXM6IHZhciBpbnN0YW5jZSA9IFZhcmlhYmxlKCk7XHJcblxyXG4vLyBBIHByZS1idWlsdCBFeHByZXNzaW9uIGdlbmVyYXRvciwgZm9yIGdlbmVyYXRpbmcgcmFuZG9tIG51bWJlcnNcclxudmFyIFJhbmRvbVZhcmlhYmxlID0gZnVuY3Rpb24oeyBsb3dlcmJvdW5kID0gMCwgdXBwZXJib3VuZCA9IDEwLCBnZW5lcmF0b3IgPSBcInVuaWZvcm1cIiB9KSB7XHJcblxyXG5cdGlmIChpc0Z1bmN0aW9uKGdlbmVyYXRvcikpIHtcclxuXHRcdHZhciBleHByZXNzaW9uID0gRXhwcmVzc2lvbihnZW5lcmF0b3IpO1xyXG5cdFx0ZXhwcmVzc2lvbi5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XHJcblx0XHRyZXR1cm4gZXhwcmVzc2lvbjtcclxuXHJcblx0fSBlbHNlIGlmIChnZW5lcmF0b3IudG9Mb3dlckNhc2UoKSA9PSBcInVuaWZvcm1cIikge1xyXG5cdFx0Z2VuZXJhdG9yID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAodXBwZXJib3VuZCAtIGxvd2VyYm91bmQgKyAxKSArIGxvd2VyYm91bmQpO1xyXG5cdFx0fTtcclxuXHRcdC8vXHRUT0RPOiBhZGQgbW9yZSBkaXN0cmlidXRpb25zIGhlcmUuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gRXhwcmVzc2lvbihnZW5lcmF0b3IpO1xyXG59O1xyXG5cclxuXHJcblxyXG4vLyBBIHdheSB0byBoYXZlIFZhcmlhYmxlcyB3aGljaCBhcmUgbW9yZSBjb21wbGljYXRlZCB0aGluZ3MsIGxpa2UgYXJyYXlzIG9yIG9iZWN0c1xyXG52YXIgQ29tcGxleFZhcmlhYmxlID0gZnVuY3Rpb24odmFsdWUpIHtcclxuXHR2YXIgdmFyaWFibGUgPSBWYXJpYWJsZSh2YWx1ZSwgeyBlbmZvcmNlTnVtYmVyOiBmYWxzZSB9KVxyXG5cclxuXHR2YXIgZXhjbHVkZUxpc3QgPSBbXCJzZXRcIiwgXCJjYWxsXCIsIFwidG9KU09OXCIsIFwidG9TdHJpbmdcIiwgXCJ2YWx1ZU9mXCJdXHJcblxyXG5cdHZhciBoYW5kbGVyID0ge1xyXG5cdFx0Z2V0KHRhcmdldCwga2V5KSB7XHJcblx0XHRcdHZhciBwcm9wO1xyXG5cdFx0XHRpZiAoZXhjbHVkZUxpc3QuaW5kZXhPZihrZXkpID4gLTEpIHByb3AgPSB0YXJnZXRba2V5XS5iaW5kKHRhcmdldCk7XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHByb3AgPSB0YXJnZXQudmFsdWVba2V5XVxyXG5cdFx0XHRcdGlmIChpc0Z1bmN0aW9uKHByb3ApKSBwcm9wID0gcHJvcC5iaW5kKHRhcmdldC52YWx1ZSlcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHByb3BcclxuXHRcdH0sXHJcblx0XHRzZXQodGFyZ2V0LCBrZXksIHByb3ApIHtcclxuXHRcdFx0dGFyZ2V0LnZhbHVlW2tleV0gPSBwcm9wO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG5ldyBQcm94eSh2YXJpYWJsZSwgaGFuZGxlcilcclxufVxyXG5cclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0dmFyaWFibGVQcm90b3R5cGUsXHJcblx0VmFyaWFibGUsXHJcblx0ZXhwcmVzc2lvblByb3RvdHlwZSxcclxuXHRFeHByZXNzaW9uLFxyXG5cdFJhbmRvbVZhcmlhYmxlLFxyXG5cdENvbXBsZXhWYXJpYWJsZVxyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgQ2xhc3M6IENob2ljZVwiKTtcclxuXHJcbi8vIEV4dGVybmFsIGRlcGVuZGVuY3lcclxudmFyIHsgU3luY2hyb25vdXNQcm9taXNlIH0gPSByZXF1aXJlKFwic3luY2hyb25vdXMtcHJvbWlzZVwiKTtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZShcIi4uL3N0YXRlXCIpO1xyXG52YXIgeyBnYW1lSGlzdG9yeSB9ID0gcmVxdWlyZShcIi4uL2hpc3RvcnlcIik7XHJcbnZhciB7IFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0gcmVxdWlyZShcIi4uL2luZm9ybWF0aW9uXCIpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlkSGFuZGxlciB9ID0gcmVxdWlyZShcIi4uL2hlbHBlckZ1bmN0aW9uc1wiKShcInN0YXRlXCIpO1xyXG52YXIgeyBpc0Z1bmN0aW9uIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyRnVuY3Rpb25zXCIpKFwiZ2VuZXJhbFwiKTtcclxudmFyIHsgY2hhaW5lckdlbmVyYXRvciB9ID0gcmVxdWlyZShcIi4uL2hlbHBlckZ1bmN0aW9uc1wiKShcInBsYXlhYmxlXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9ID0gcmVxdWlyZShcIi4vcGxheWFibGVcIik7XHJcblxyXG4vL0JhY2tlbmQgZnVuY3Rpb24gY2xhc3MgZm9yIENob2ljZVxyXG5mdW5jdGlvbiBfQ2hvaWNlKGlkLCBwbGF5ZXIsIG9wdGlvbnMsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdF9QbGF5YWJsZS5jYWxsKHRoaXMsIGlkKTtcclxuXHJcblx0dGhpcy5uZXh0ID0ge307XHJcblxyXG5cdHRoaXMucGxheWVyID0gcmVnaXN0cnkucGxheWVyc1twbGF5ZXJdO1xyXG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0dGhpcy5kZWZhdWx0T3B0aW9uID0gcGFyYW1ldGVycy5kZWZhdWx0T3B0aW9uIHx8IG9wdGlvbnNbMF07IC8vVE9ETzogbWFrZSBkZWZhdWx0T3B0aW9uIGZ1bmN0aW9uYWxcclxuXHR0aGlzLmluZm9ybWF0aW9uRmlsdGVyID0gcGFyYW1ldGVycy5pbmZvcm1hdGlvbkZpbHRlciB8fCBudWxsO1xyXG5cdHRoaXMudXNlUGF5b2ZmcyA9IHBhcmFtZXRlcnMudXNlUGF5b2ZmcyB8fCBmYWxzZTtcclxuXHJcblx0cmVnaXN0cnkuY2hvaWNlc1tpZF0gPSB0aGlzO1xyXG5cclxuXHR2YXIgY2hvaWNlID0gdGhpcztcclxuXHR0aGlzLm9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRjaG9pY2UubmV4dFtpdGVtXSA9IFtdO1xyXG5cdH0pO1xyXG59XHJcblxyXG5fQ2hvaWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX1BsYXlhYmxlLnByb3RvdHlwZSk7XHJcbl9DaG9pY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gX0Nob2ljZTtcclxuXHJcbl9DaG9pY2UucmVnaXN0cnlOYW1lID0gXCJjaG9pY2VzXCI7XHJcbl9DaG9pY2UuY291bnRlck5hbWUgPSBcImNob2ljZVwiO1xyXG5cclxuX0Nob2ljZS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKHtcclxuXHR1c2VQYXlvZmZzID0gdGhpcy51c2VQYXlvZmZzLFxyXG5cdGhpc3RvcnkgPSBnYW1lSGlzdG9yeSxcclxuXHRpbmZvcm1hdGlvbjogcmF3SW5mb3JtYXRpb24gPSBQZXJmZWN0SW5mb3JtYXRpb24sXHJcblx0cmVsZWFzZVBsYXllciA9IHRydWUsXHJcblx0aW5mb3JtYXRpb25GaWx0ZXIgPSB0aGlzLmluZm9ybWF0aW9uRmlsdGVyLFxyXG5cdF9jb21waWxlSW5mb3JtYXRpb24gPSBudWxsXHJcbn0gPSB7fSkge1xyXG5cdHZhciBjaG9pY2UgPSB0aGlzO1xyXG5cclxuXHRpZiAoIWNob2ljZS5wbGF5ZXIuYWxpdmUpXHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3Qoe1xyXG5cdFx0XHRyZXN1bHQ6IGNob2ljZS5pZCArIFwiOiBQbGF5ZXIgXCIgKyBjaG9pY2UucGxheWVyLmlkICsgXCIgaXMgZGVhZC5cIlxyXG5cdFx0fSk7XHJcblxyXG5cdC8vV2hpbGUgdGhpcyBjaG9pY2UgaXMgaGFwcGVuaW5nLCBkb24ndCBhbGxvdyBvdGhlciBjaG9pY2VzIHRvIHVzZSB0aGlzIHBsYXllci5cclxuXHRjaG9pY2UucGxheWVyLmF2YWlsYWJsZSA9IGZhbHNlO1xyXG5cclxuXHQvL0luZm9ybWF0aW9uIG1lY2hhbmljcy4gSWYgd2UncmUgZGVhbGluZyB3aXRoIFBlcmZlY3RJbmZvcm1hdGlvbiwgdGhpcyB3b24ndCBnZXQgZGVsaXZlcmVkLCBzbyB3ZSdsbCBpbmNsdWRlIGl0IGluIHRoZSBjYWxsIHRvIC5kZWxpdmVyKCkuIElmIHdlJ3JlIHVzaW5nIGFuIGluZm9ybWF0aW9uIHN1cHBsaWVkIGZyb20gc29tZSBvdGhlciBwbGF5YWJsZSwgdGhlbiB0aGV5IGNhbiBkbyB3aGF0IHRoZXkgbGlrZSB3aXRoIGl0LlxyXG5cdHZhciBjaG9pY2VJbmZvID0ge1xyXG5cdFx0Y2hvaWNlOiB7XHJcblx0XHRcdGlkOiBjaG9pY2UuaWQsXHJcblx0XHRcdHBsYXllcjogY2hvaWNlLnBsYXllci5pZCxcclxuXHRcdFx0b3B0aW9uczogY2hvaWNlLm9wdGlvbnNcclxuXHRcdH1cclxuXHR9O1xyXG5cdHJhd0luZm9ybWF0aW9uLmFkZEFkZGl0aW9uYWwoY2hvaWNlSW5mbyk7XHJcblx0Ly9QZXJmb3JtIHNvbWUgZGF0YSBwcm9jZXNzaW5nIGlmIG90aGVyIHBsYXlhYmxlcyBuZWVkIGl0LlxyXG5cdGlmIChfY29tcGlsZUluZm9ybWF0aW9uKSBfY29tcGlsZUluZm9ybWF0aW9uKHJhd0luZm9ybWF0aW9uKTtcclxuXHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXHJcblx0XHQudGhlbihmdW5jdGlvbigpIHtcclxuXHRcdFx0Ly9QcmVwIGluZm9ybWF0aW9uXHJcblx0XHRcdHZhciBpbmZvcm1hdGlvbiA9IHJhd0luZm9ybWF0aW9uLmRlbGl2ZXIoY2hvaWNlLnBsYXllciwgY2hvaWNlSW5mbyk7XHJcblx0XHRcdGlmIChpbmZvcm1hdGlvbkZpbHRlcikgaW5mb3JtYXRpb24gPSBpbmZvcm1hdGlvbkZpbHRlcihpbmZvcm1hdGlvbik7XHJcblxyXG5cdFx0XHRyZXR1cm4gY2hvaWNlLnBsYXllci5jaG9vc2UoY2hvaWNlLm9wdGlvbnMuc2xpY2UoMCksIGluZm9ybWF0aW9uKTtcclxuXHRcdH0pXHJcblx0XHQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0dmFyIHBsYXllciA9IGNob2ljZS5wbGF5ZXI7XHJcblx0XHRcdHZhciBpZCA9IGNob2ljZS5pZDtcclxuXHJcblx0XHRcdC8vQWRkIHRvIHBsYXllcidzIGluZGl2aWR1YWwgaGlzdG9yeTtcclxuXHRcdFx0cGxheWVyLmhpc3RvcnkucHVzaCh7XHJcblx0XHRcdFx0Y2hvaWNlOiBpZCxcclxuXHRcdFx0XHRvcHRpb25zOiBjaG9pY2Uub3B0aW9ucyxcclxuXHRcdFx0XHRyZXN1bHRcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRyZXN1bHQgPSByZXN1bHQgfHwgY2hvaWNlLmRlZmF1bHRPcHRpb247XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0T2JqZWN0ID0ge1xyXG5cdFx0XHRcdHJlc3VsdCxcclxuXHRcdFx0XHRoaXN0b3J5RW50cnk6IHtcclxuXHRcdFx0XHRcdGNob2ljZTogaWQsXHJcblx0XHRcdFx0XHRwbGF5ZXI6IHBsYXllci5pZCxcclxuXHRcdFx0XHRcdHJlc3VsdFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdC8vVGhpcyB3aWxsIHByb2JhYmx5IG9ubHkgaGFwcGVuIGlmIGl0J3MgYSBzaW5nbGUtcGxheWVyIGdhbWUsIG90aGVyd2lzZSB3ZSdsbCB1c2UgcGxheW9mZnMgZGVmaW5lZCBpbiBhIFR1cm5cclxuXHRcdFx0aWYgKHVzZVBheW9mZnMpIHtcclxuXHRcdFx0XHR2YXIgcGF5b3V0ID0gY2hvaWNlLnBheW9mZnNbcmVzdWx0XTtcclxuXHJcblx0XHRcdFx0cGxheWVyLnNjb3JlICs9IHBheW91dDtcclxuXHJcblx0XHRcdFx0Ly90cmFjayB0aGUgcGF5b2ZmXHJcblx0XHRcdFx0dmFyIHNjb3JlRW50cnkgPSB7XHJcblx0XHRcdFx0XHRjaG9pY2U6IGlkLFxyXG5cdFx0XHRcdFx0cGF5b3V0czoge1xyXG5cdFx0XHRcdFx0XHRbcGxheWVyLmlkXTogTnVtYmVyKHBheW91dClcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRoaXN0b3J5LmFkZFNjb3JlcyhzY29yZUVudHJ5KTtcclxuXHRcdFx0XHRyZXN1bHRPYmplY3QuaGlzdG9yeUVudHJ5LnBheW91dHMgPSB7XHJcblx0XHRcdFx0XHRbcGxheWVyLmlkXTogcGF5b3V0XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bG9nKFxyXG5cdFx0XHRcdFwic2lsbHlcIixcclxuXHRcdFx0XHRcIl9DaG9pY2UucGxheTogcmVtb3ZpbmcgZnJvbSBvY2N1cGllZFBsYXllcnM6IFwiLFxyXG5cdFx0XHRcdGNob2ljZS5wbGF5ZXIuaWRcclxuXHRcdFx0KTtcclxuXHRcdFx0aWYgKHJlbGVhc2VQbGF5ZXIpIGNob2ljZS5yZWxlYXNlUGxheWVyKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdE9iamVjdCk7IC8vVE9ETzogYWRkIGluZm9ybWF0aW9uIG1lY2hhbmlzbXNcclxuXHRcdH0pO1xyXG59O1xyXG5cclxuLy9SZWxlYXNlIHBsYXllciBmcm9tIGV4Y2x1ZGVkIHBsYXllcnMgbGlzdCwgc28gdGhhdCBvdGhlciBvYmplY3RzIGNhbiB1c2UgaXQuXHJcbl9DaG9pY2UucHJvdG90eXBlLnJlbGVhc2VQbGF5ZXIgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLnBsYXllci5hdmFpbGFibGUgPSB0cnVlO1xyXG59O1xyXG5cclxuX0Nob2ljZS5wcm90b3R5cGUuZmluZE5leHQgPSBmdW5jdGlvbih7IHJlc3VsdCB9ID0ge30pIHtcclxuXHRyZXR1cm4gdGhpcy5uZXh0W3Jlc3VsdC5yZXN1bHRdO1xyXG59O1xyXG5cclxuX0Nob2ljZS5wcm90b3R5cGUuZ2VuZXJhdGVDaGFpbmluZ0Z1bmN0aW9ucyA9IGZ1bmN0aW9uKGNob2ljZSkge1xyXG5cdHZhciBfY2hvaWNlID0gdGhpcztcclxuXHJcblx0X2Nob2ljZS5vcHRpb25zLmZvckVhY2goZnVuY3Rpb24ob3B0aW9uKSB7XHJcblx0XHRfY2hvaWNlLnBheW9mZnNbb3B0aW9uXSA9IDA7IC8vU3RhcnQgcGF5b2ZmcyBhdCB6ZXJvXHJcblxyXG5cdFx0Y2hvaWNlW29wdGlvbl0gPSBmdW5jdGlvbihwYXlvZmYpIHtcclxuXHRcdFx0Ly9DcmVhdGUgZnVuY3Rpb25zIGZvciB1c2VyIHRvIGFzc2lnbiBwYXlvZmZzXHJcblx0XHRcdGlmICghaXNOYU4ocGF5b2ZmKSkgX2Nob2ljZS5wYXlvZmZzW29wdGlvbl0gPSBwYXlvZmY7XHJcblx0XHRcdHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZSh7XHJcblx0XHRcdFx0cGxheWFibGU6IGNob2ljZSxcclxuXHRcdFx0XHRwYXRoOiBbb3B0aW9uXVxyXG5cdFx0XHR9KTtcclxuXHRcdH07XHJcblx0fSk7XHJcbn07XHJcblxyXG5fQ2hvaWNlLnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnkpIHtcclxuXHRzdW1tYXJ5LnBsYXllciA9IHRoaXMucGxheWVyLmlkO1xyXG5cdHN1bW1hcnkub3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zbGljZSgpO1xyXG5cclxuXHRyZXR1cm4gc3VtbWFyeTtcclxufTtcclxuXHJcbi8vVE9ETzogdW4tZnVjayB0aGlzLlxyXG5fQ2hvaWNlLnByb3RvdHlwZS5zdW1tYXJ5TmV4dCA9IGZ1bmN0aW9uKFxyXG5cdHN1bW1hcnksXHJcblx0ZW50cmllcyA9IHt9LFxyXG5cdHNob3J0Q2lyY3VpdCA9IGZhbHNlLFxyXG5cdG1heEVudHJpZXMgPSAxMFxyXG4pIHtcclxuXHQvLyBDb3B5IG92ZXIgdGhlIGNob2ljZSBvcHRpb25zXHJcblx0c3VtbWFyeS5uZXh0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5uZXh0KTtcclxuXHJcblx0Ly8gTG9vcCB0aHJvdWdoIHRoZW0gYW5kIHN1bW1hcml6ZSBhdCBlYWNoIHN0ZXAuXHJcblx0dmFyIGNvdW50ID0gMDtcclxuXHRmb3IgKHZhciBrZXkgaW4gc3VtbWFyeS5uZXh0KSB7XHJcblx0XHRzdW1tYXJ5Lm5leHRba2V5XSA9IHN1bW1hcnkubmV4dFtrZXldLm1hcChmdW5jdGlvbihwbGF5YWJsZSkge1xyXG5cdFx0XHRjb3VudCsrO1xyXG5cdFx0XHRyZXR1cm4gcGxheWFibGUuc3VtbWFyaXplKHt9LCBlbnRyaWVzKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Ly8gSWYgdGhlcmUgd2VyZW4ndCBhbnkgbmV4dCBzdGVwcywgZGVsZXRlIHRoZSBuZXh0IGtleSwgdG8gcmVkdWNlIGNsdXR0ZXIuXHJcblx0aWYgKGNvdW50ID09IDApIGRlbGV0ZSBzdW1tYXJ5Lm5leHQ7XHJcblxyXG5cdHJldHVybiBzdW1tYXJ5O1xyXG59O1xyXG5cclxuLy9TZXQgYWxsIHBheW9mZnMgdG8gemVyby5cclxuX0Nob2ljZS5wcm90b3R5cGUuemVyb1BheW9mZnMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgY2hvaWNlID0gdGhpcztcclxuXHJcblx0Y2hvaWNlLnBheW9mZnMgPSB7fTtcclxuXHJcblx0Y2hvaWNlLm9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbihvcHRpb24pIHtcclxuXHRcdGNob2ljZS5wYXlvZmZzW29wdGlvbl0gPSAwO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gQ2hvaWNlKHBsYXllciwgb3B0aW9ucywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHBhcmFtZXRlcnMuaWQsIFwiY2hvaWNlXCIpO1xyXG5cclxuXHQvL0lmIGluZm9ybWF0aW9uRmlsdGVyIHdhcyBzdXBwbGllZCwgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uXHJcblx0aWYgKHBhcmFtZXRlcnMuaW5mb3JtYXRpb25GaWx0ZXIgJiYgIWlzRnVuY3Rpb24ocGFyYW1ldGVycy5pbmZvcm1hdGlvbkZpbHRlcikpXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJpbmZvcm1hdGlvbkZpbHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XHJcblxyXG5cdC8vQ3JlYXRlIGJhY2tlbmQgY2hvaWNlIG9iamVjdFxyXG5cdHZhciBfY2hvaWNlID0gbmV3IF9DaG9pY2UoaWQsIHBsYXllci5pZCgpLCBvcHRpb25zLCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0Ly9SZXR1cm4gdGhpcyByZWZlcmVuY2Ugb2JqZWN0IHRvIHRoZSB1c2VyLiBSdW4gdGhlIGZ1bmN0aW9uIHRvIHNlbGVjdCBhIHNvdXJjZVxyXG5cdHZhciBjaG9pY2UgPSBQbGF5YWJsZShfY2hvaWNlKTtcclxuXHJcblx0Ly9JbnRlcmZhY2UgdG8gc3BlY2lmeSBzaW5nbGUtcGxheWVyIHBheW9mZnMgaW4gc2luZ2xlLXBsYXllci9zaW5nbGUtY2hvaWNlIGdhbWVzXHJcblx0X2Nob2ljZS56ZXJvUGF5b2ZmcygpO1xyXG5cclxuXHRfY2hvaWNlLmdlbmVyYXRlQ2hhaW5pbmdGdW5jdGlvbnMoY2hvaWNlKTtcclxuXHJcblx0LypcclxuXHRvcHRpb25zLmZvckVhY2goZnVuY3Rpb24ob3B0aW9uKXtcclxuXHRcdF9jaG9pY2UucGF5b2Zmc1tvcHRpb25dID0gMDtcdFx0XHQvL1N0YXJ0IHBheW9mZnMgYXQgemVyb1xyXG5cclxuXHRcdGNob2ljZVtvcHRpb25dID0gZnVuY3Rpb24ocGF5b2ZmKXtcdFx0XHRcdFx0Ly9DcmVhdGUgZnVuY3Rpb25zIGZvciB1c2VyIHRvIGFzc2lnbiBwYXlvZmZzXHJcblx0XHRcdGlmICghaXNOYU4ocGF5b2ZmKSlfY2hvaWNlLnBheW9mZnNbb3B0aW9uXSA9IHBheW9mZjtcclxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XHJcblx0XHRcdFx0cGxheWFibGU6Y2hvaWNlLFxyXG5cdFx0XHRcdHBhdGg6W29wdGlvbl1cclxuXHRcdFx0fSlcclxuXHRcdH07XHJcblx0fSk7XHJcblx0Ki9cclxuXHJcblx0Ly9GdW5jdGlvbiB0byBzZXQgYWxsIHBheW9mZnMgYXQgb25jZVxyXG5cdGNob2ljZS5zZXRBbGxQYXlvZmZzID0gZnVuY3Rpb24ocGF5b2Zmcykge1xyXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KHBheW9mZnMpKSB0aHJvdyBuZXcgRXJyb3IoXCJQYXlvZmZzIG11c3QgYmUgYXJyYXlcIilcclxuXHRcdGlmIChwYXlvZmZzLmxlbmd0aCAhPSByZWdpc3RyeS5jaG9pY2VzW2lkXS5vcHRpb25zLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKFxyXG5cdFx0XHRcIlBheW9mZnMgbXVzdCBiZSBzYW1lIGRpbWVuc2lvbnMgYXMgY2hvaWNlIG9wdGlvbnNcIilcclxuXHJcblx0XHRwYXlvZmZzLmZvckVhY2goZnVuY3Rpb24ocGF5b2ZmLCBpbmRleCkge1xyXG5cdFx0XHRyZWdpc3RyeS5jaG9pY2VzW2lkXS5wYXlvZmZzW29wdGlvbnNbaW5kZXhdXSA9IHBheW9mZjtcclxuXHRcdH0pXHJcblx0XHQvL1RPRE86IG1ha2UgdGhpcyB3b3JrLiBJbmNsdWRlIGVycm9yIGhhbmRsaW5nIGlmIGFycmF5IGdpdmVuIGlzbid0IGV4cGVjdGVkIGRpbWVuc2lvbnMuXHJcblx0fTtcclxuXHJcblx0Ly9XYXkgZm9yIHVzZXIgdG8gaW50ZXJhY3Qgd2l0aCBwYXlvZmZzXHJcblx0Y2hvaWNlLnBheW9mZnMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiByZWdpc3RyeS5jaG9pY2VzW2lkXS5wYXlvZmZzO1xyXG5cdH07XHJcblxyXG5cdHJldHVybiBjaG9pY2U7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBfQ2hvaWNlLCBDaG9pY2UgfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBDb25zZWN1dGl2ZVwiKTtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZShcIi4uL3N0YXRlXCIpO1xyXG52YXIgeyBnYW1lSGlzdG9yeSB9ID0gcmVxdWlyZShcIi4uL2hpc3RvcnlcIik7XHJcblxyXG4vL0hlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgaWRIYW5kbGVyIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyRnVuY3Rpb25zXCIpKFwic3RhdGVcIik7XHJcblxyXG4vL0luZm9ybWF0aW9uXHJcbnZhciB7IEluZm9ybWF0aW9uLCBQZXJmZWN0SW5mb3JtYXRpb24gfSA9IHJlcXVpcmUoXCIuLi9pbmZvcm1hdGlvblwiKTtcclxuXHJcbi8vUGFyZW50IGNsYXNzXHJcbnZhciB7IF9QbGF5YWJsZSwgUGxheWFibGUgfSA9IHJlcXVpcmUoXCIuL3BsYXlhYmxlXCIpO1xyXG5cclxuLy9CYWNrZW5kIGZ1bmN0aW9uIGNsYXNzIGZvciBDb25zZWN1dGl2ZVxyXG5mdW5jdGlvbiBfQ29uc2VjdXRpdmUoaWQsIHBsYXlhYmxlc0FycmF5LCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRfUGxheWFibGUuY2FsbCh0aGlzLCBpZCwgcGFyYW1ldGVycyk7XHJcblxyXG5cdHBsYXlhYmxlc0FycmF5ID0gcGxheWFibGVzQXJyYXkubWFwKGZ1bmN0aW9uKHBsYXlhYmxlKSB7XHJcblx0XHRyZXR1cm4gcmVnaXN0cnkucGxheWFibGVzW3BsYXlhYmxlLmlkKCldXHJcblx0fSlcclxuXHR0aGlzLnBsYXlhYmxlc0FycmF5ID0gcGxheWFibGVzQXJyYXlcclxuXHJcblx0cmVnaXN0cnkuY29uc2VjdXRpdmVzW2lkXSA9IHRoaXM7XHJcbn1cclxuX0NvbnNlY3V0aXZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX1BsYXlhYmxlLnByb3RvdHlwZSk7XHJcbl9Db25zZWN1dGl2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBfQ29uc2VjdXRpdmU7XHJcblxyXG5fQ29uc2VjdXRpdmUucmVnaXN0cnlOYW1lID0gXCJjb25zZWN1dGl2ZXNcIjtcclxuX0NvbnNlY3V0aXZlLmNvdW50ZXJOYW1lID0gXCJjb25zZWN1dGl2ZVwiO1xyXG5cclxuX0NvbnNlY3V0aXZlLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oe1xyXG5cdGhpc3RvcnkgPSBnYW1lSGlzdG9yeSxcclxuXHRpbmZvcm1hdGlvbiA9IHRoaXMuaW5mb3JtYXRpb24gfHxcclxuXHRQZXJmZWN0SW5mb3JtYXRpb25cclxufSA9IHt9KSB7XHJcblxyXG5cdHZhciBjb25zZWN1dGl2ZSA9IHRoaXM7XHJcblxyXG5cdC8vTG9nIHRoZSBoaXN0b3J5IGFwcHJvcHJpYXRlbHlcclxuXHR2YXIgc3RhcnRFbnRyeSA9IHtcclxuXHRcdGNvbnNlY3V0aXZlOiBjb25zZWN1dGl2ZS5pZCxcclxuXHRcdGFjdGlvbjogXCJzdGFydFwiXHJcblx0fTtcclxuXHRoaXN0b3J5LmxvZy5hZGQoc3RhcnRFbnRyeSk7XHJcblxyXG5cdC8vSGlzdG9yeSBvYmplY3QgdG8gZ2l2ZSB0byBjb25zZWN1dGl2ZWQgcGxheWFibGVzLlxyXG5cdHZhciBjb25zZWN1dGl2ZUhpc3RvcnkgPSBoaXN0b3J5LmNoaWxkKCk7XHJcblxyXG5cdC8vY29tcGFydG1lbnRhbGl6ZSBpZiBzZXQuIFwiY29tcGFydG1lbnRhbGl6ZVwiIG1lYW5zIHBhc3Mgb24gaW5mb3JtYXRpb24gYXMgaWYgdGhpcyBwbGF5YWJsZSBpcyB0aGUgZW50aXJlIGdhbWUuXHJcblx0aWYgKGNvbnNlY3V0aXZlLmNvbXBhcnRtZW50YWxpemUpIHtcclxuXHRcdGluZm9ybWF0aW9uID0gbmV3IEluZm9ybWF0aW9uKGNvbnNlY3V0aXZlLmNvbXBhcnRtZW50YWxpemUuaGlzdG9yeSB8fCBjb25zZWN1dGl2ZUhpc3RvcnksXHJcblx0XHRcdGNvbnNlY3V0aXZlLmNvbXBhcnRtZW50YWxpemUucG9wdWxhdGlvbiB8fCBpbmZvcm1hdGlvbi5wb3B1bGF0aW9uKTtcclxuXHR9XHJcblxyXG5cdHZhciBhY3Rpb24gPSBmdW5jdGlvbiBhY3Rpb24ocGxheWFibGVzQXJyYXkpIHtcclxuXHRcdC8vU3RvcCBpZiB0aGUgZ2FtZSBpcyBvdmVyLlxyXG5cdFx0aWYgKGhpc3Rvcnkuc3RvcCkgcmV0dXJuIHsgcGxheWFibGU6IGNvbnNlY3V0aXZlIH07XHJcblxyXG5cdFx0aWYgKHBsYXlhYmxlc0FycmF5Lmxlbmd0aCA+IDApIHtcclxuXHRcdFx0cmV0dXJuIHBsYXlhYmxlc0FycmF5LnNoaWZ0KCkucGxheSh7IHNob3J0Q2lyY3VpdDogdHJ1ZSwgaGlzdG9yeTogY29uc2VjdXRpdmVIaXN0b3J5LCBpbmZvcm1hdGlvbiB9KVxyXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGFjdGlvbihwbGF5YWJsZXNBcnJheSkgfHwgcmVzdWx0XHJcblx0XHRcdFx0fSlcclxuXHRcdH0gZWxzZSByZXR1cm4gZmFsc2VcclxuXHR9XHJcblxyXG5cdHJldHVybiBhY3Rpb24oY29uc2VjdXRpdmUucGxheWFibGVzQXJyYXkuc2xpY2UoKSlcclxuXHRcdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHRyZXN1bHQuaGlzdG9yeUVudHJ5ID0ge1xyXG5cdFx0XHRcdGNvbnNlY3V0aXZlOiBjb25zZWN1dGl2ZS5pZCxcclxuXHRcdFx0XHRhY3Rpb246IGNvbnNlY3V0aXZlSGlzdG9yeS5vcnBoYW4oKVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0Ly9UT0RPOiBhZGQgaW5mb3JtYXRpb24gbWVjaGFuaXNtc1xyXG5cclxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdFx0fSk7XHJcbn07XHJcblxyXG4vL092ZXJ3cml0ZSBoaXN0b3J5IGhhbmRsZXIgc28gdGhhdCB0cmVlIGRvZXNuJ3QgaGF2ZSBcInN0YXJ0XCIgYW5kIFwiZmluaXNoXCIgZW50cmllcy5cclxuX0NvbnNlY3V0aXZlLnByb3RvdHlwZS5oYW5kbGVIaXN0b3J5ID0gZnVuY3Rpb24oeyBoaXN0b3J5ID0gZ2FtZUhpc3RvcnkgfSA9IHt9LFxyXG5cdHJlc3VsdFxyXG4pIHtcclxuXHR2YXIgY29uc2VjdXRpdmUgPSB0aGlzO1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdGhpc3RvcnkubG9nLmFkZCh7XHJcblx0XHRcdGNvbnNlY3V0aXZlOiBjb25zZWN1dGl2ZS5pZCxcclxuXHRcdFx0YWN0aW9uOiBcImZpbmlzaFwiLFxyXG5cdFx0XHRkdXJhdGlvbjogcmVzdWx0Lmhpc3RvcnlFbnRyeS5kdXJhdGlvblxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aGlzdG9yeS5hZGROb0xvZyhyZXN1bHQuaGlzdG9yeUVudHJ5KTtcclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vVE9ETzogZmluaXNoIHRoaXMhXHJcbl9Db25zZWN1dGl2ZS5wcm90b3R5cGUuc3VtbWFyeVRoaXMgPSBmdW5jdGlvbihzdW1tYXJ5LCBlbnRyaWVzLCBzaG9ydENpcmN1aXQpIHtcclxuXHRzdW1tYXJ5LmFjdGlvbiA9IHt9O1xyXG5cclxuXHR0aGlzLnBsYXlhYmxlU3RhcnQuc3VtbWFyaXplKFxyXG5cdFx0c3VtbWFyeS5hY3Rpb24sXHJcblx0XHRlbnRyaWVzLFxyXG5cdFx0KHNob3J0Q2lyY3VpdCA9IHRoaXMucGxheWFibGVGaW5pc2gpXHJcblx0KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIENvbnNlY3V0aXZlKHBsYXlhYmxlc0FycmF5LCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHR2YXIgaWQgPSBpZEhhbmRsZXIocGFyYW1ldGVycy5pZCwgXCJjb25zZWN1dGl2ZVwiKTtcclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBsb29wIG9iamVjdFxyXG5cdHZhciBfY29uc2VjdXRpdmUgPSBuZXcgX0NvbnNlY3V0aXZlKGlkLCBwbGF5YWJsZXNBcnJheSwgcGFyYW1ldGVycyk7XHJcblxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgY29uc2VjdXRpdmUgPSBQbGF5YWJsZShfY29uc2VjdXRpdmUpO1xyXG5cclxuXHRjb25zZWN1dGl2ZS5pZHMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBwbGF5YWJsZXNBcnJheS5tYXAoZnVuY3Rpb24ocGxheWFibGUpIHtcclxuXHRcdFx0cmV0dXJuIHBsYXlhYmxlLmlkKCk7XHJcblx0XHR9KVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNvbnNlY3V0aXZlO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX0NvbnNlY3V0aXZlLCBDb25zZWN1dGl2ZSB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBIYWx0SWZcIilcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIge3JlZ2lzdHJ5fSA9IHJlcXVpcmUoJy4uL3N0YXRlJyk7XHJcbnZhciB7Z2FtZUhpc3Rvcnl9ID0gcmVxdWlyZSgnLi4vaGlzdG9yeScpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7aXNGdW5jdGlvbn1cdD0gcmVxdWlyZSgnLi4vaGVscGVyRnVuY3Rpb25zJykoXCJnZW5lcmFsXCIpO1xyXG52YXIge2lkSGFuZGxlcn0gXHQ9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwic3RhdGVcIik7XHJcblxyXG4vL1BhcmVudCBjbGFzc1xyXG52YXIge19QbGF5YWJsZSwgUGxheWFibGV9ID0gcmVxdWlyZSgnLi9wbGF5YWJsZScpO1xyXG5cclxuXHJcblxyXG4vL0JhY2tlbmQgZnVuY3Rpb24gY2xhc3MgZm9yIEdhbWVcclxuZnVuY3Rpb24gX0hhbHQoaWQsdGVzdENvbmRpdGlvbiwge2xvZ0NvbnRpbnVlID0gZmFsc2V9KXtcclxuXHRfUGxheWFibGUuY2FsbCh0aGlzLGlkKTtcclxuXHRcclxuXHR0aGlzLnRlc3RDb25kaXRpb24gPSB0ZXN0Q29uZGl0aW9uO1xyXG5cdHRoaXMubG9nQ29udGludWUgPSBsb2dDb250aW51ZTtcclxuXHRcclxuXHRyZWdpc3RyeS5oYWx0c1tpZF0gPSB0aGlzO1xyXG59XHJcblxyXG5fSGFsdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9QbGF5YWJsZS5wcm90b3R5cGUpO1xyXG5fSGFsdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBfSGFsdDtcclxuXHJcbl9IYWx0LnJlZ2lzdHJ5TmFtZSA9IFwiaGFsdHNcIjtcclxuX0hhbHQuY291bnRlck5hbWUgPSBcImhhbHRJZlwiO1xyXG5cclxuX0hhbHQucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7aW5pdGlhbGl6ZVBsYXllcnM9ZmFsc2UsIHNob3J0Q2lyY3VpdD1mYWxzZSwgaGlzdG9yeT1nYW1lSGlzdG9yeX09e30pe1xyXG5cdFxyXG5cdHZhciBoYWx0ID0gdGhpcztcclxuXHRcclxuXHR2YXIgcmVzdWx0T2JqZWN0ID0ge1xyXG5cdFx0J3BsYXlhYmxlJzpoYWx0LFxyXG5cdFx0J2hpc3RvcnlFbnRyeSc6e1xyXG5cdFx0XHQnaGFsdCc6aGFsdC5pZFxyXG5cdFx0fVxyXG5cdH07XHJcblx0XHJcblx0XHJcblx0dmFyIHRlc3QgPSBoYWx0LnRlc3RDb25kaXRpb24oKTtcclxuXHRcclxuXHRcclxuXHRpZiAodGVzdCkge1xyXG5cdFx0bG9nKFwiaW5mb1wiLCBcIkhhbHRpbmcgYXQgXCIgKyBoYWx0LmlkKVxyXG5cdFx0XHJcblx0XHRyZXN1bHRPYmplY3QuaGlzdG9yeUVudHJ5LmFjdGlvbiA9IFwiaGFsdFwiO1xyXG5cdFx0cmVzdWx0T2JqZWN0LnJlc3VsdCA9IFwiSGFsdFwiO1xyXG5cdFxyXG5cdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KHJlc3VsdE9iamVjdCk7XHJcblx0fVxyXG5cdFxyXG5cdC8vSGFsdCBwcm9iYWJseSBnZXRzIHVzZWQgZm9yIGxvb3BzLCBhbmQgd2UgbWlnaHQgbm90IHdhbnQgdG8gc2VlIGxvdHMgb2YgY29udGludWUgbWVzc2FnZXMsIHNvIFwibG9nQ29udGludWVcIiB3aWxsIG9taXQgdGhlbS5cclxuXHRpZiAoaGFsdC5sb2dDb250aW51ZSkge1xyXG5cdFx0cmVzdWx0T2JqZWN0Lmhpc3RvcnlFbnRyeS5hY3Rpb24gPSBcImNvbnRpbnVlXCI7XHJcblx0fVxyXG5cdGVsc2UgZGVsZXRlIHJlc3VsdE9iamVjdC5oaXN0b3J5RW50cnlcclxuXHRcclxuXHRcclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdE9iamVjdClcclxufTtcclxuXHJcblxyXG5fSGFsdC5wcm90b3R5cGUuc3VtbWFyeVRoaXMgPSBmdW5jdGlvbihzdW1tYXJ5KXtcclxuXHRzdW1tYXJ5LmNvbmRpdGlvbiA9IHRoaXMudGVzdENvbmRpdGlvbi50b1N0cmluZygpO1xyXG59XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIEhhbHRJZih0ZXN0Q29uZGl0aW9uPWZ1bmN0aW9uKCl7fSwge2lkPW51bGwsIGxvZ0NvbnRpbnVlPWZhbHNlfT17fSl7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKGlkLFwiaGFsdElmXCIpXHJcblx0XHJcblx0aWYgKCFpc0Z1bmN0aW9uKHRlc3RDb25kaXRpb24pKSBsb2coXCJ3YXJuXCIsaWQgKyBcIjogdGVzdENvbmRpdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiwgb3IgZWxzZSBnYW1lIHdpbGwgbm90IGhhbHQuXCIpXHJcblxyXG5cdC8vQ3JlYXRlIGJhY2tlbmQgbG9vcCBvYmplY3RcclxuXHR2YXIgX2hhbHQgPSBuZXcgX0hhbHQoaWQsIHRlc3RDb25kaXRpb24sIHtsb2dDb250aW51ZX0pO1xyXG5cdFxyXG5cdFxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgaGFsdCA9IFBsYXlhYmxlKF9oYWx0KTtcdFxyXG5cdHJldHVybiBoYWx0O1x0XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtfSGFsdCwgSGFsdElmfTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vTG9hZHMgdGhlIHBsYXlhYmxlcyB0aGF0IHdpbGwgYmUgdXNlZCBieSBOYXNoLiBUaGlzIGlzIGJhc2ljYWxseSB0aGUgY29udHJvbGxlciBsaXN0OiBpZiBpdCdzIG5vdCBpbiB0aGVzZSBsaXN0cyxcclxuLy8gdGhlbiBpdCB3b24ndCBiZSBhdmFpbGFibGUgZm9yIHVzLlxyXG5cclxuLy9FeHRlcm5hbCBkZXBlbmRlbmN5XHJcbnZhciBwcmVzZW50ID0gcmVxdWlyZShcInByZXNlbnRcIik7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcclxuXHJcbnZhciB7IGFwcGx5QmluZCB9ID0gcmVxdWlyZShcIi4uL2hlbHBlckZ1bmN0aW9uc1wiKShcImdlbmVyYWxcIik7XHJcblxyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgUGxheWFibGUgQ2xhc3NlczogXCIpO1xyXG5cclxuLy9QbGF5YWJsZXNcclxudmFyIHsgX1BsYXlhYmxlIH0gPSByZXF1aXJlKFwiLi9wbGF5YWJsZVwiKTtcclxudmFyIHsgX0Nob2ljZSwgQ2hvaWNlIH0gPSByZXF1aXJlKFwiLi9jaG9pY2VcIik7XHJcbnZhciB7IF9UdXJuLCBUdXJuIH0gPSByZXF1aXJlKFwiLi90dXJuXCIpO1xyXG52YXIgeyBfU2VxdWVuY2UsIFNlcXVlbmNlIH0gPSByZXF1aXJlKFwiLi9zZXF1ZW5jZVwiKTtcclxudmFyIHsgX0NvbnNlY3V0aXZlLCBDb25zZWN1dGl2ZSB9ID0gcmVxdWlyZShcIi4vY29uc2VjdXRpdmVcIik7XHJcbnZhciB7IF9Mb29wLCBMb29wIH0gPSByZXF1aXJlKFwiLi9sb29wXCIpO1xyXG52YXIgeyBfU0xvb3AsIFN0b2NoYXN0aWNMb29wIH0gPSByZXF1aXJlKFwiLi9zdG9jaGFzdGljTG9vcFwiKTtcclxudmFyIHsgX0hhbHQsIEhhbHRJZiB9ID0gcmVxdWlyZShcIi4vaGFsdC1pZlwiKTtcclxudmFyIHsgX1NIYWx0LCBTdG9jaGFzdGljSGFsdCB9ID0gcmVxdWlyZShcIi4vc3RvY2hhc3RpYy1oYWx0XCIpO1xyXG52YXIgeyBfTGFtYmRhLCBMYW1iZGEgfSA9IHJlcXVpcmUoXCIuL2xhbWJkYVwiKTtcclxudmFyIHsgX1JQQ2hvaWNlLCBSYW5kb21QbGF5ZXJDaG9pY2UgfSA9IHJlcXVpcmUoXCIuL3JhbmRvbS1wbGF5ZXItY2hvaWNlXCIpO1xyXG52YXIgeyBfUG9wdWxhdGlvbkR5bmFtaWNzLCBQb3B1bGF0aW9uRHluYW1pY3MgfSA9IHJlcXVpcmUoXCIuL3BvcHVsYXRpb24tZHluYW1pY3NcIik7XHJcbnZhciB7IF9TaW11bHRhbmVvdXMsIFNpbXVsdGFuZW91cyB9ID0gcmVxdWlyZShcIi4vc2ltdWx0YW5lb3VzXCIpO1xyXG5cclxuLy9SdW5zIHdoZW4gbG9hZGluZyBQbGF5YWJsZSBjbGFzc2VzLlxyXG5mdW5jdGlvbiBpbml0aWFsaXplUGxheWFibGVDbGFzcyhwbGF5YWJsZUNsYXNzKSB7XHJcblx0Ly9SZXBsYWNlIHRoZSAucGxheSgpIG1ldGhvZCB3aXRoIGEgd3JhcHBlciB3aGljaCBjYWxscyBpdCBhbmQgYSBmZXcgb3RoZXIgZnVuY3Rpb25zXHJcblx0aWYgKHBsYXlhYmxlQ2xhc3MucHJvdG90eXBlLmhhc093blByb3BlcnR5KFwicGxheVwiKSkge1xyXG5cdFx0cGxheWFibGVDbGFzcy5wcm90b3R5cGUucGxheSA9IChmdW5jdGlvbihwbGF5KSB7XHJcblx0XHRcdHJldHVybiBmdW5jdGlvbih7IGhpc3RvcnkgPSBnYW1lSGlzdG9yeSB9ID0ge30pIHtcclxuXHRcdFx0XHR2YXIgcGxheWFibGUgPSB0aGlzO1xyXG5cdFx0XHRcdHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG5cclxuXHRcdFx0XHQvLyBTZXQgb3VyIGhpc3RvcnlcclxuXHRcdFx0XHRhcmdzWzBdLmhpc3RvcnkgPyBudWxsIDogYXJnc1swXS5oaXN0b3J5ID0gdGhpcy5oaXN0b3J5IHx8IGdhbWVIaXN0b3J5XHJcblxyXG5cdFx0XHRcdC8vIGhvdyB0byBoYWx0IHRoZSBnYW1lIHdpdGhvdXQgZXJyb3JzLiBUT0RPIHRoaXMgaXMgcHJvYmFibHkgZnVja2VkXHJcblx0XHRcdFx0aWYgKGhpc3Rvcnkuc3RvcCkgcmV0dXJuIHsgcGxheWFibGUgfTtcclxuXHJcblxyXG5cdFx0XHRcdHJldHVybiBfUGxheWFibGUucHJvdG90eXBlLl9zdGFydFRpbWVyXHJcblx0XHRcdFx0XHQuYXBwbHkocGxheWFibGUsIGFyZ3MpXHJcblx0XHRcdFx0XHQudGhlbihhcHBseUJpbmQocGxheWFibGUuY2hlY2tJbml0LCBwbGF5YWJsZSwgYXJncykpXHJcblx0XHRcdFx0XHQudGhlbihhcHBseUJpbmQocGxheWFibGUucHJlUGxheSwgcGxheWFibGUsIGFyZ3MpKVxyXG5cdFx0XHRcdFx0LnRoZW4oYXBwbHlCaW5kKHBsYXksIHBsYXlhYmxlLCBhcmdzKSlcclxuXHRcdFx0XHRcdC50aGVuKGFwcGx5QmluZChwbGF5YWJsZS5wb3N0UGxheSwgcGxheWFibGUsIGFyZ3MpKVxyXG5cdFx0XHRcdFx0LnRoZW4oYXBwbHlCaW5kKF9QbGF5YWJsZS5wcm90b3R5cGUuX3N0b3BUaW1lciwgcGxheWFibGUsIGFyZ3MpKVxyXG5cdFx0XHRcdFx0LnRoZW4oYXBwbHlCaW5kKHBsYXlhYmxlLmhhbmRsZUhpc3RvcnksIHBsYXlhYmxlLCBhcmdzKSlcclxuXHRcdFx0XHRcdC50aGVuKGFwcGx5QmluZChfUGxheWFibGUucHJvdG90eXBlLnByb2NlZWQsIHBsYXlhYmxlLCBhcmdzKSk7XHJcblx0XHRcdH07XHJcblx0XHR9KShwbGF5YWJsZUNsYXNzLnByb3RvdHlwZS5wbGF5KTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydHMucGxheWFibGVDbGFzc2VzID0ge1xyXG5cdF9QbGF5YWJsZSxcclxuXHRfQ2hvaWNlLFxyXG5cdF9UdXJuLFxyXG5cdF9TZXF1ZW5jZSxcclxuXHRfQ29uc2VjdXRpdmUsXHJcblx0X0xvb3AsXHJcblx0X1NMb29wLFxyXG5cdF9IYWx0LFxyXG5cdF9TSGFsdCxcclxuXHRfTGFtYmRhLFxyXG5cdF9SUENob2ljZSxcclxuXHRfUG9wdWxhdGlvbkR5bmFtaWNzLFxyXG5cdF9TaW11bHRhbmVvdXNcclxufTtcclxuZXhwb3J0cy5wbGF5YWJsZUludGVyZmFjZXMgPSB7XHJcblx0Q2hvaWNlLFxyXG5cdFR1cm4sXHJcblx0U2VxdWVuY2UsXHJcblx0Q29uc2VjdXRpdmUsXHJcblx0TG9vcCxcclxuXHRTdG9jaGFzdGljTG9vcCxcclxuXHRIYWx0SWYsXHJcblx0U3RvY2hhc3RpY0hhbHQsXHJcblx0TGFtYmRhLFxyXG5cdFJhbmRvbVBsYXllckNob2ljZSxcclxuXHRQb3B1bGF0aW9uRHluYW1pY3MsXHJcblx0U2ltdWx0YW5lb3VzXHJcbn07XHJcblxyXG5mb3IgKHZhciBwbGF5YWJsZUNsYXNzIGluIGV4cG9ydHMucGxheWFibGVDbGFzc2VzKSB7XHJcblx0aWYgKHBsYXlhYmxlQ2xhc3MgIT0gXCJfUGxheWFibGVcIilcclxuXHRcdGluaXRpYWxpemVQbGF5YWJsZUNsYXNzKGV4cG9ydHMucGxheWFibGVDbGFzc2VzW3BsYXlhYmxlQ2xhc3NdKTtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBMYW1iZGFcIilcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSwgZ2FtZUhpc3RvcnkgfSA9IHJlcXVpcmUoJy4uL3N0YXRlJyk7XHJcblxyXG4vLyBJbmZvcm1hdGlvbiBtZWNoYW5pY3NcclxudmFyIHsgUGVyZmVjdEluZm9ybWF0aW9uIH0gPSByZXF1aXJlKFwiLi4vaW5mb3JtYXRpb25cIik7XHJcblxyXG4vL0hlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgaXNGdW5jdGlvbiB9ID0gcmVxdWlyZSgnLi4vaGVscGVyRnVuY3Rpb25zJykoXCJnZW5lcmFsXCIpO1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwic3RhdGVcIik7XHJcblxyXG4vL1BhcmVudCBjbGFzc1xyXG52YXIgeyBfUGxheWFibGUsIFBsYXlhYmxlIH0gPSByZXF1aXJlKCcuL3BsYXlhYmxlJyk7XHJcblxyXG5cclxuXHJcbi8vQmFja2VuZCBmdW5jdGlvbiBjbGFzcyBmb3IgR2FtZVxyXG5mdW5jdGlvbiBfTGFtYmRhKGlkLCBhY3Rpb24sIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdF9QbGF5YWJsZS5jYWxsKHRoaXMsIGlkKTtcclxuXHJcblx0dGhpcy5hY3Rpb24gPSBhY3Rpb247XHJcblxyXG5cdHJlZ2lzdHJ5LmxhbWJkYXNbaWRdID0gdGhpcztcclxufVxyXG5fTGFtYmRhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX1BsYXlhYmxlLnByb3RvdHlwZSk7XHJcbl9MYW1iZGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gX0xhbWJkYVxyXG5cclxuX0xhbWJkYS5yZWdpc3RyeU5hbWUgPSBcImxhbWJkYXNcIjtcclxuX0xhbWJkYS5jb3VudGVyTmFtZSA9IFwibGFtYmRhXCI7XHJcblxyXG5cclxuX0xhbWJkYS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKHsgaW5pdGlhbGl6ZVBsYXllcnMgPSBmYWxzZSwgc2hvcnRDaXJjdWl0ID0gZmFsc2UsIGhpc3RvcnkgPSBnYW1lSGlzdG9yeSxcclxuXHRpbmZvcm1hdGlvbiA9IFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0ge30pIHtcclxuXHJcblx0dmFyIGxhbWJkYSA9IHRoaXM7XHJcblxyXG5cdHZhciByZXN1bHQgPSBsYW1iZGEuYWN0aW9uKHsgaGlzdG9yeSwgaW5mb3JtYXRpb24gfSlcclxuXHJcblx0dmFyIHJlc3VsdE9iamVjdCA9IHtcclxuXHRcdHJlc3VsdCxcclxuXHRcdCdwbGF5YWJsZSc6IGxhbWJkYSxcclxuXHRcdGhpc3RvcnlFbnRyeToge1xyXG5cdFx0XHRsYW1iZGE6IGxhbWJkYS5pZCxcclxuXHRcdFx0cmVzdWx0XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRPYmplY3QpXHJcbn07XHJcblxyXG4vLyBTaW1wbGUgaGVscGVyIHRvIGp1c3QgcnVuIHN5bmNocm9ub3VzbHkgd2hhdGV2ZXIgdGhlIExhbWJkYSBpcy4gVXNlZnVsIGZvciBkZWJ1Z2dpbmcuXHJcbl9MYW1iZGEucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmFjdGlvbigpO1xyXG59XHJcblxyXG5fTGFtYmRhLnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnkpIHtcclxuXHRzdW1tYXJ5LmFjdGlvbiA9IHRoaXMuYWN0aW9uLnRvU3RyaW5nKCk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBMYW1iZGEoYWN0aW9uID0gZnVuY3Rpb24oKSB7fSwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHBhcmFtZXRlcnMuaWQsIFwibGFtYmRhXCIpXHJcblxyXG5cdGlmICghaXNGdW5jdGlvbihhY3Rpb24pKSBsb2coXCJ3YXJuXCIsIGlkICsgXCI6IGFjdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbi5cIilcclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBsYW1iZGEgb2JqZWN0XHJcblx0dmFyIF9sYW1iZGEgPSBuZXcgX0xhbWJkYShpZCwgYWN0aW9uLCBwYXJhbWV0ZXJzKTtcclxuXHJcblxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgbGFtYmRhID0gUGxheWFibGUoX2xhbWJkYSk7XHJcblxyXG5cclxuXHRsYW1iZGEucnVuID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gX2xhbWJkYS5ydW4oKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBsYW1iZGE7XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX0xhbWJkYSwgTGFtYmRhIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XHJcbmxvZyhcImRlYnVnXCIsIFwiTG9hZGluZyBDbGFzczogTG9vcFwiKTtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZShcIi4uL3N0YXRlXCIpO1xyXG52YXIgeyBnYW1lSGlzdG9yeSwgSGlzdG9yeSB9ID0gcmVxdWlyZShcIi4uL2hpc3RvcnlcIik7XHJcblxyXG4vL0hlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgaWRIYW5kbGVyIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyRnVuY3Rpb25zXCIpKFwic3RhdGVcIik7XHJcbnZhciB7IGNoYWluZXJHZW5lcmF0b3IgfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJGdW5jdGlvbnNcIikoXCJwbGF5YWJsZVwiKTtcclxuXHJcbi8vIEluZm9ybWF0aW9uIG1lY2hhbmljc1xyXG52YXIgeyBJbmZvcm1hdGlvbiwgUGVyZmVjdEluZm9ybWF0aW9uIH0gPSByZXF1aXJlKFwiLi4vaW5mb3JtYXRpb25cIik7XHJcbnZhciB7IGdhbWVQb3B1bGF0aW9uIH0gPSByZXF1aXJlKFwiLi4vcG9wdWxhdGlvblwiKTtcclxuXHJcbi8vUGFyZW50IGNsYXNzXHJcbnZhciB7IF9QbGF5YWJsZSwgUGxheWFibGUgfSA9IHJlcXVpcmUoXCIuL3BsYXlhYmxlXCIpO1xyXG5cclxuLy9CYWNrZW5kIGZ1bmN0aW9uIGNsYXNzIGZvciBMb29wXHJcblxyXG5mdW5jdGlvbiBfTG9vcChpZCwgcGxheWFibGUsIGNvdW50LCBwYXJhbWV0ZXJzKSB7XHJcblx0X1BsYXlhYmxlLmNhbGwodGhpcywgaWQsIHBhcmFtZXRlcnMpO1xyXG5cclxuXHR2YXIgeyBsb2dDb250aW51ZSA9IHRydWUsIHBsYXlhYmxlUGFyYW1ldGVycyA9IHt9IH0gPSBwYXJhbWV0ZXJzO1xyXG5cclxuXHR0aGlzLnBsYXlhYmxlID0gcmVnaXN0cnkucGxheWFibGVzW3BsYXlhYmxlLmlkKCldO1xyXG5cdHRoaXMubG9nQ29udGludWUgPSBsb2dDb250aW51ZTtcclxuXHR0aGlzLnBsYXlhYmxlUGFyYW1ldGVycyA9IHBsYXlhYmxlUGFyYW1ldGVycztcclxuXHJcblx0dGhpcy5jb3VudCA9IGNvdW50O1xyXG5cclxuXHRyZWdpc3RyeS5sb29wc1tpZF0gPSB0aGlzO1xyXG59XHJcbl9Mb29wLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX1BsYXlhYmxlLnByb3RvdHlwZSk7XHJcbl9Mb29wLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9Mb29wO1xyXG5cclxuX0xvb3AucmVnaXN0cnlOYW1lID0gXCJsb29wc1wiO1xyXG5fTG9vcC5jb3VudGVyTmFtZSA9IFwibG9vcFwiO1xyXG5cclxuX0xvb3AucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7XHJcblx0aGlzdG9yeSA9IHRoaXMuaGlzdG9yeSB8fCBnYW1lSGlzdG9yeSxcclxuXHRpbmZvcm1hdGlvbiA9IHRoaXMuaW5mb3JtYXRpb24gfHwgUGVyZmVjdEluZm9ybWF0aW9uLFxyXG5cdHBsYXlhYmxlUGFyYW1ldGVycyA9IHRoaXMucGxheWFibGVQYXJhbWV0ZXJzXHJcbn0gPSB7fSkge1xyXG5cclxuXHR2YXIgbG9vcCA9IHRoaXM7XHJcblx0bG9vcC5jb3VudGVyID0gMDtcclxuXHJcblx0Ly8gU3BsaXQgdGhlIGhpc3RvcnkgZW50cnlcclxuXHR2YXIgbG9vcEhpc3RvcnkgPSBoaXN0b3J5LmNoaWxkKCk7XHJcblxyXG5cdC8vIGluZm9ybWF0aW9uIG1lY2hhbmljcy5cclxuXHQvL2NvbXBhcnRtZW50YWxpemUgSWYgc2V0XHJcblx0aWYgKGxvb3AuY29tcGFydG1lbnRhbGl6ZSkge1xyXG5cdFx0aW5mb3JtYXRpb24gPSBuZXcgSW5mb3JtYXRpb24obG9vcC5jb21wYXJ0bWVudGFsaXplLmhpc3RvcnkgfHwgbG9vcEhpc3RvcnksXHJcblx0XHRcdGxvb3AuY29tcGFydG1lbnRhbGl6ZS5wb3B1bGF0aW9uIHx8IGluZm9ybWF0aW9uLnBvcHVsYXRpb24pO1xyXG5cdH1cclxuXHQvLyBQYXNzIGFsb25nXHJcblx0cGxheWFibGVQYXJhbWV0ZXJzLmluZm9ybWF0aW9uID0gaW5mb3JtYXRpb25cclxuXHJcblxyXG5cdHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcblxyXG5cdHZhciBhY3Rpb24gPSBmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdC8vSWYgdGhlIGdhbWUgaGFzIGJlZW4gZW5kZWQgZWFybHksIGRvbid0IGNvbnRpbnVlLlxyXG5cdFx0aWYgKGhpc3Rvcnkuc3RvcCkgcmV0dXJuIHsgcGxheWFibGU6IGxvb3AgfTtcclxuXHJcblx0XHRsb29wLmNvdW50ZXIrKztcclxuXHRcdGlmICghcmVzdWx0KSByZXN1bHQgPSB7fTtcclxuXHJcblx0XHQvL0RlYWwgd2l0aCBoaXN0b3J5XHJcblx0XHRoaXN0b3J5LmxvZy5hZGQoe1xyXG5cdFx0XHRsb29wOiBsb29wLmlkLFxyXG5cdFx0XHRsb29wVG86IGxvb3AucGxheWFibGUuaWQsXHJcblx0XHRcdGNvdW50OiBsb29wLmNvdW50ZXJcclxuXHRcdH0pO1xyXG5cclxuXHRcdHBsYXlhYmxlUGFyYW1ldGVycy5zaG9ydENpcmN1aXQgPSB0cnVlO1xyXG5cdFx0cGxheWFibGVQYXJhbWV0ZXJzLmhpc3RvcnkgPSBsb29wSGlzdG9yeTtcclxuXHJcblx0XHRyZXR1cm4gbG9vcC5wbGF5YWJsZS5wbGF5KHBsYXlhYmxlUGFyYW1ldGVycykudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0Ly9SZS1mb3JtYXQgcmVzdWx0LCByZXBsYWNlIHBsYXlhYmxlIHdpdGggTG9vcCBwbGF5YWJsZVxyXG5cdFx0XHRyZXN1bHQucGxheWFibGUgPSBsb29wO1xyXG5cclxuXHRcdFx0Ly9UT0RPOiBhZGQgaW5mb3JtYXRpb24gbWVjaGFuaXNtc1xyXG5cclxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0Ly9SZXBlYXQgdGhlIHBsYXlhYmxlIGxvb3AuY291bnQgdGltZXMsIGJ5IGNoYWluaW5nIHByb21pc2VzLlxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbG9vcC5jb3VudDsgaSsrKSB7XHJcblx0XHRwcm9taXNlID0gcHJvbWlzZS50aGVuKGFjdGlvbik7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0cmVzdWx0Lmhpc3RvcnlFbnRyeSA9IHtcclxuXHRcdFx0bG9vcDogbG9vcC5pZCxcclxuXHRcdFx0Y291bnQ6IGxvb3AuY291bnRlcixcclxuXHRcdFx0YWN0aW9uOiBsb29wSGlzdG9yeS5vcnBoYW4oKVxyXG5cdFx0fTtcclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vT3ZlcndyaXRlIGhpc3RvcnkgaGFuZGxlciB0byBwcmV2ZW50IFwibG9vcCBmaW5pc2hlZFwiIGVudHJ5IGZyb20gaGl0dGluZyB0aGUgdHJlZS5cclxuX0xvb3AucHJvdG90eXBlLmhhbmRsZUhpc3RvcnkgPSBmdW5jdGlvbih7XHJcblx0XHRoaXN0b3J5ID0gdGhpcy5oaXN0b3J5IHx8IGdhbWVIaXN0b3J5LFxyXG5cdFx0aW5mb3JtYXRpb24gPSB0aGlzLmluZm9ybWF0aW9uIHx8IFBlcmZlY3RJbmZvcm1hdGlvbixcclxuXHRcdGxvZ0NvbnRpbnVlID0gdGhpcy5sb2dDb250aW51ZVxyXG5cdH0gPSB7fSxcclxuXHRyZXN1bHRcclxuKSB7XHJcblx0dmFyIGxvb3AgPSB0aGlzO1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdC8vV3JpdGUgZmluYWwgZW50cnkgaWYgbG9nQ29udGludWUgaXMgc2V0IHRvIHRydWVcclxuXHRcdGlmIChsb2dDb250aW51ZSkge1xyXG5cdFx0XHRoaXN0b3J5LmxvZy5hZGQoe1xyXG5cdFx0XHRcdGxvb3A6IGxvb3AuaWQsXHJcblx0XHRcdFx0bG9vcFRvOiBcIkxvb3AgZmluaXNoZWQuXCIsXHJcblx0XHRcdFx0Y291bnQ6IGxvb3AuY291bnRlclxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRoaXN0b3J5LmFkZE5vTG9nKHJlc3VsdC5oaXN0b3J5RW50cnkpO1xyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fSk7XHJcbn07XHJcblxyXG4vLyBBZGQgZGV0YWlsL25lc3RpbmcgdG8gc3VtbWFyeS5cclxuX0xvb3AucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSwgZW50cmllcykge1xyXG5cdHN1bW1hcnkuY291bnQgPSB0aGlzLmNvdW50O1xyXG5cclxuXHRzdW1tYXJ5LmFjdGlvbiA9IHt9O1xyXG5cdHRoaXMucGxheWFibGUuc3VtbWFyaXplKHN1bW1hcnkuYWN0aW9uLCBlbnRyaWVzLCB0cnVlKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIExvb3AocGxheWFibGUsIGNvdW50ID0gMSwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHBhcmFtZXRlcnMuaWQsIFwibG9vcFwiKTtcclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBsb29wIG9iamVjdFxyXG5cdHZhciBfbG9vcCA9IG5ldyBfTG9vcChpZCwgcGxheWFibGUsIGNvdW50LCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0Ly9SZXR1cm4gdGhpcyByZWZlcmVuY2Ugb2JqZWN0IHRvIHRoZSB1c2VyLiBSdW4gdGhlIGZ1bmN0aW9uIHRvIHNlbGVjdCBhIHNvdXJjZVxyXG5cdHZhciBsb29wID0gUGxheWFibGUoX2xvb3ApO1xyXG5cdHJldHVybiBsb29wO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX0xvb3AsIExvb3AgfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBQbGF5YWJsZVwiKTtcclxuXHJcbnZhciB7IFN5bmNocm9ub3VzUHJvbWlzZSB9ID0gcmVxdWlyZShcInN5bmNocm9ub3VzLXByb21pc2VcIik7XHJcbnZhciBwcmVzZW50ID0gcmVxdWlyZShcInByZXNlbnRcIik7XHJcblxyXG4vL0dhbWUgc3RhdGUgY29udHJvbGxlcnNcclxudmFyIHsgcmVnaXN0cnksIGlkQ291bnRlcnMgfSA9IHJlcXVpcmUoXCIuLi9zdGF0ZVwiKTtcclxudmFyIHsgZ2FtZUhpc3RvcnksIEhpc3RvcnkgfSA9IHJlcXVpcmUoXCIuLi9oaXN0b3J5XCIpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlzRnVuY3Rpb24gfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJGdW5jdGlvbnNcIikoXCJnZW5lcmFsXCIpO1xyXG52YXIgeyBvdXRjb21lVHJlZUFkZEFsbCwgb3V0Y29tZVRyZWVHZXRWYWx1ZSB9ID0gcmVxdWlyZShcIi4uL2hlbHBlckZ1bmN0aW9uc1wiKShcInBsYXlhYmxlXCIpO1xyXG52YXIgeyByZWluaXRpYWxpemVQbGF5ZXJzIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyRnVuY3Rpb25zXCIpKFwicGxheWVyXCIpO1xyXG5cclxuLy9UbyByZXR1cm4gdG8gdXNlclxyXG52YXIgeyBQb3B1bGF0aW9uLCBQbGF5ZXJMaXN0IH0gPSByZXF1aXJlKFwiLi4vcG9wdWxhdGlvblwiKTtcclxuXHJcbi8vX3BsYXlhYmxlIGNsYXNzLCBzdXBlcmNsYXNzIGZvciBvYmplY3RzIHdoaWNoIGNhbiBleGVjdXRlIGdhbWUgc3RlcHMgKGNob2ljZSwgdHVybiwgZ2FtZSlcclxuZnVuY3Rpb24gX1BsYXlhYmxlKGlkLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHR0aGlzLmlkID0gaWQ7XHJcblx0dGhpcy5uZXh0ID0gW107XHJcblx0cmVnaXN0cnkucGxheWFibGVzW2lkXSA9IHRoaXM7XHJcblx0aWRDb3VudGVycy5wbGF5YWJsZSsrO1xyXG5cclxuXHRwYXJhbWV0ZXJzLmNvbXBhcnRtZW50YWxpemUgPyB0aGlzLmNvbXBhcnRtZW50YWxpemUgPSBwYXJhbWV0ZXJzLmNvbXBhcnRtZW50YWxpemUgOiBudWxsO1xyXG5cdHBhcmFtZXRlcnMuaGlzdG9yeSA/ICh0aGlzLmhpc3RvcnkgPSBwYXJhbWV0ZXJzLmhpc3RvcnkpIDogbnVsbDtcclxuXHRwYXJhbWV0ZXJzLmluZm9ybWF0aW9uID8gKHRoaXMuaW5mb3JtYXRpb24gPSBwYXJhbWV0ZXJzLmluZm9ybWF0aW9uKSA6IG51bGw7XHJcblx0cGFyYW1ldGVycy5pbml0aWFsaXplUGxheWVycyA/ICh0aGlzLmluaXRpYWxpemVQbGF5ZXJzID0gcGFyYW1ldGVycy5pbml0aWFsaXplUGxheWVycykgOiBudWxsO1xyXG59XHJcblxyXG5fUGxheWFibGUucmVnaXN0cnlOYW1lID0gXCJwbGF5YWJsZXNcIjtcclxuX1BsYXlhYmxlLmNvdW50ZXJOYW1lID0gXCJwbGF5YWJsZVwiO1xyXG5cclxuLy9BZGQgcmVmZXJlbmNlIHRvIG5leHQgcGxheWFibGUgYnJhbmNoLCB0byBjaGFpbiBwbGF5YWJsZXMgdG9nZXRoZXIuXHJcbl9QbGF5YWJsZS5wcm90b3R5cGUuYWRkTmV4dCA9IGZ1bmN0aW9uKG5leHRQbGF5YWJsZSkge1xyXG5cdG91dGNvbWVUcmVlQWRkQWxsKHRoaXMubmV4dCwgbmV4dFBsYXlhYmxlKTtcclxufTtcclxuXHJcbi8vQ2FsbGVkIGJlZm9yZSAucGxheSgpIHRvIHN0YXJ0IHRpbWluZy5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5fc3RhcnRUaW1lciA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuX3RpbWVyID0gcHJlc2VudCgpO1xyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxufTtcclxuXHJcbi8vQ2FsbGVkIGJlZm9yZSBwcmVQbGF5LCBpbml0aWFsaXplIHBsYXllcnMgaWYgdHJ1ZS5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5jaGVja0luaXQgPSBmdW5jdGlvbih7IGluaXRpYWxpemVQbGF5ZXJzID0gdGhpcy5pbml0aWFsaXplUGxheWVycyB9ID0ge30sIHJlc3VsdCkge1xyXG5cdC8vIGlmIHdlIGdldCBzb21ldGhpbmdcclxuXHRpZiAoaW5pdGlhbGl6ZVBsYXllcnMpIHtcclxuXHRcdC8vIGlmIGl0J3MganVzdCB0cnVlLCB0aGVuIHJlaW5pdGlhbGl6ZSBldmVyeWJvZHlcclxuXHRcdGlmIChpbml0aWFsaXplUGxheWVycyA9PT0gdHJ1ZSkgcmV0dXJuIHJlaW5pdGlhbGl6ZVBsYXllcnMoXCJhbGxcIiwgcmVzdWx0KVxyXG5cclxuXHRcdC8vIGlmIGl0J3MgYSBwbGF5ZXJMaXN0LCB1c2UgdGhhdFxyXG5cdFx0ZWxzZSBpZiAoaW5pdGlhbGl6ZVBsYXllcnMgaW5zdGFuY2VvZiBQbGF5ZXJMaXN0KSByZXR1cm4gcmVpbml0aWFsaXplUGxheWVycyhpbml0aWFsaXplUGxheWVycylcclxuXHJcblx0XHQvLyBpZiB3ZSBnZXQgYSBmdW5jdGlvbiwgdGhlbiBydW4gdGhlIGZ1bmN0aW9uIGFuZCBjaGVjayB0aGF0IGl0J3MgcmV0dXJuaW5nIGEgcGxheWVyTGlzdFxyXG5cdFx0ZWxzZSBpZiAoaXNGdW5jdGlvbihpbml0aWFsaXplUGxheWVycykpIHtcclxuXHRcdFx0dmFyIGxpc3QgPSBpbml0aWFsaXplUGxheWVycygpXHJcblx0XHRcdGlmIChsaXN0IGluc3RhbmNlb2YgUGxheWVyTGlzdCkgcmV0dXJuIHJlaW5pdGlhbGl6ZVBsYXllcnMobGlzdCwgcmVzdWx0KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvdGhlcndpc2UsIGNvbnZlcnQgaXQgdG8gYSBwbGF5ZXJMaXN0IGFuZCBsZXQgUGxheWVyTGlzdCBkZWFsIHdpdGggaXQuXHJcblx0XHRlbHNlIHJldHVybiByZWluaXRpYWxpemVQbGF5ZXJzKG5ldyBQbGF5ZXJMaXN0KGluaXRpYWxpemVQbGF5ZXJzKSwgcmVzdWx0KTtcclxuXHR9XHJcblxyXG5cdC8vIGlmIHdlIGRpZG4ndCBnZXQgYW55dGhpbmcgb3IgZ290IGZhbHNlLCB3ZSdyZSBkb25lIGhlcmUuXHJcblx0ZWxzZSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcbn07XHJcblxyXG5cclxuLy9DYWxsZWQgYmVmb3JlIC5wbGF5KCkgYnV0IGFmdGVyIF9zdGFydFRpbWVyXHJcbl9QbGF5YWJsZS5wcm90b3R5cGUucHJlUGxheSA9IGZ1bmN0aW9uKHt9ID0ge30sIHJlc3VsdCkge1xyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxufTtcclxuXHJcbi8vQ2FsbGVkIGFmdGVyIC5wbGF5KCksIG92ZXJ3cml0YWJsZS5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5wb3N0UGxheSA9IGZ1bmN0aW9uKHt9ID0ge30sIHJlc3VsdCkge1xyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxufTtcclxuXHJcbi8vQ2FsbGVkIGFmdGVyIC5wb3N0UGxheSgpIHRvIHN0b3AgdGltZXIgYW5kIGxvZy5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5fc3RvcFRpbWVyID0gZnVuY3Rpb24oe30gPSB7fSwgcmVzdWx0KSB7XHJcblx0aWYgKHJlc3VsdC5oaXN0b3J5RW50cnkpXHJcblx0XHRyZXN1bHQuaGlzdG9yeUVudHJ5LmR1cmF0aW9uID0gcHJlc2VudCgpIC0gdGhpcy5fdGltZXI7XHJcblx0ZGVsZXRlIHRoaXMuX3RpbWVyO1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcbn07XHJcblxyXG4vL0NhbGxlZCBhZnRlciB0aW1lciBzdG9wcywgdG8gd3JpdGUgbG9nLiBPdmVyd2l0ZWFibGUgaWYgcGxheWFibGUgaGFzIHNwZWNpZmljIGxvZ2dpbmcgYmVoYXZpb3IuXHJcbl9QbGF5YWJsZS5wcm90b3R5cGUuaGFuZGxlSGlzdG9yeSA9IGZ1bmN0aW9uKHsgaGlzdG9yeSA9IGdhbWVIaXN0b3J5IH0gPSB7fSxcclxuXHRyZXN1bHRcclxuKSB7XHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRpZiAocmVzdWx0Lmhpc3RvcnlFbnRyeSkgaGlzdG9yeS5hZGQocmVzdWx0Lmhpc3RvcnlFbnRyeSk7XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcblx0fSk7XHJcbn07XHJcblxyXG4vL0RldGVybWluZSB3aGV0aGVyIHRvIHBsYXkgbmV4dCwgYW5kIGlmIHNvLCBkby5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5wcm9jZWVkID0gZnVuY3Rpb24oeyBzaG9ydENpcmN1aXQgfSA9IHt9LCByZXN1bHQpIHtcclxuXHR2YXIgcGxheWFibGUgPSB0aGlzO1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdC8vUmVwbGFjZSByZXBvcnRlZCBwbGF5YWJsZSB3aXRoIGxhdGVzdCBydW5uaW5nIHBsYXlhYmxlICh0aGlzIGlzIG5lY2Vzc2FyeSBmb3Igc2hvcnQtY2lyY3VpdCBsb2dpYylcclxuXHRcdHJlc3VsdC5wbGF5YWJsZSA9IHBsYXlhYmxlO1xyXG5cclxuXHRcdC8vU2hvcnQtY2lyY3VpdCBsb2dpYyBhbGxvd3MgaGlnaGVyLW9yZGVyIHBsYXlhYmxlIHRvIGZpZ3VyZSBvdXQgd2hhdCB0byBkbyBuZXh0LlxyXG5cdFx0aWYgKHNob3J0Q2lyY3VpdCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cclxuXHRcdHJldHVybiBwbGF5YWJsZS5wbGF5TmV4dChyZXN1bHQpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuLy9QbGF5IG5leHQuXHJcbl9QbGF5YWJsZS5wcm90b3R5cGUucGxheU5leHQgPSBmdW5jdGlvbihyZXN1bHQsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHZhciBwbGF5YWJsZSA9IHRoaXM7XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0Ly9GaW5kIG91dCB3aGVyZSB0byBnbyBuZXh0XHJcblx0XHR2YXIgbmV4dCA9IHBsYXlhYmxlLmZpbmROZXh0KHsgcmVzdWx0IH0pO1xyXG5cclxuXHRcdC8vSWYgdGhlcmUncyBzb21ld2hlcmUgdG8gZ28sIHRoZW4gZ28uXHJcblx0XHRpZiAobmV4dFswXSBpbnN0YW5jZW9mIF9QbGF5YWJsZSlcclxuXHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKFxyXG5cdFx0XHRcdG5leHQubWFwKGZ1bmN0aW9uKHBsYXlhYmxlKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gcGxheWFibGUucGxheShwYXJhbWV0ZXJzKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdC8vT3RoZXJ3aXNlLCB3ZSdyZSBkb25lIGhlcmVcclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vIFJldHVybiB0aGUgbmV4dCBwbGF5YWJsZSBpbiB0aGUgc2VxdWVuY2UuIE92ZXJ3cml0ZWFibGUgZm9yIHBsYXlhYmxlcyB3aXRoIG1vcmUgY29tcGxpY2F0ZWQgYnJhbmNoaW5nLlxyXG5fUGxheWFibGUucHJvdG90eXBlLmZpbmROZXh0ID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMubmV4dDtcclxufTtcclxuXHJcbl9QbGF5YWJsZS5wcm90b3R5cGUuX3N1bW1hcml6ZSA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4vLyBTdW1tYXJpemUgdGhlIGdhbWUgc3RydWN0dXJlLiBDYWxscyBzdW1tYXJ5VGhpcyBhbmQgc3VtbWFyeU5leHQsIHdoaWNoIGFyZSBvdmVyd3JpdGFibGUuXHJcbl9QbGF5YWJsZS5wcm90b3R5cGUuc3VtbWFyaXplID0gZnVuY3Rpb24oXHJcblx0c3VtbWFyeSA9IHt9LFxyXG5cdGVudHJpZXMgPSB7fSxcclxuXHRzaG9ydENpcmN1aXQgPSBmYWxzZSxcclxuXHRtYXhFbnRyaWVzID0gMTBcclxuKSB7XHJcblx0Ly8gU3RhcnQgc3VtbWFyeSBmb3IgdGhpcyBwbGF5YWJsZVxyXG5cdHN1bW1hcnlbdGhpcy5jb25zdHJ1Y3Rvci5jb3VudGVyTmFtZV0gPSB0aGlzLmlkO1xyXG5cclxuXHQvLyBUcmFjayBob3cgbWFueSB0aW1lcyB3ZSd2ZSBiZWVuIGhlcmUgYmVmb3JlLCB0byBhdm9pZCBjaXJjdWxhciByZWN1cnNpb25cclxuXHRlbnRyaWVzW3RoaXMuaWRdID8gKytlbnRyaWVzW3RoaXMuaWRdIDogKGVudHJpZXNbdGhpcy5pZF0gPSAxKTtcclxuXHRpZiAoZW50cmllc1t0aGlzLmlkXSA+IG1heEVudHJpZXMpIHNob3J0Q2lyY3VpdCA9IHRydWU7XHJcblxyXG5cdC8vIEFkZCBzdW1tYXJ5XHJcblx0dGhpcy5zdW1tYXJ5VGhpcyhzdW1tYXJ5LCBlbnRyaWVzKTtcclxuXHJcblx0Ly8gUHJvY2VlZCB0byBuZXh0IHN0ZXBzXHJcblx0aWYgKCFzaG9ydENpcmN1aXQgfHwgc2hvcnRDaXJjdWl0ICE9PSB0aGlzKVxyXG5cdFx0dGhpcy5zdW1tYXJ5TmV4dChzdW1tYXJ5LCBlbnRyaWVzKTtcclxuXHJcblx0cmV0dXJuIHN1bW1hcnk7XHJcbn07XHJcblxyXG4vLyBBZGRzIHRoZSBzdW1tYXJ5IGluZm9ybWF0aW9uIG9uIHRoaXMgcGxheWFibGUuIE92ZXJ3cml0ZSB0aGlzIGluIG9yZGVyIHRvIGFkZCBzcGVjaWZpYyBpbmZvcm1hdGlvbi5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnkgPSB7fSwgZW50cmllcyA9IHt9KSB7XHJcblx0cmV0dXJuIHN1bW1hcnk7XHJcbn07XHJcblxyXG4vLyBBZGRzIHN1bW1hcnkgaW5mb3JtYXRpb24gZG93biB0aGUgbmV4dC1wYXRoLiBPdmVyd2l0ZSB0aGlzIGZvciBwbGF5YWJsZXMgd2l0aCBtb3JlIGNvbXBsZXggYnJhbmNoaW5nLlxyXG5fUGxheWFibGUucHJvdG90eXBlLnN1bW1hcnlOZXh0ID0gZnVuY3Rpb24oc3VtbWFyeSA9IHt9LCBlbnRyaWVzID0ge30pIHtcclxuXHQvLyBJZiB0aGVyZSdzIGEgbmV4dC1lbnRyeVxyXG5cdGlmICh0aGlzLm5leHQubGVuZ3RoID4gMCkge1xyXG5cdFx0Ly8gTG9vcCBvdmVyIGVhY2ggbmV4dC1pdGVtLCBhbmQgc3VtbWFyaXplIGl0LlxyXG5cdFx0c3VtbWFyeS5uZXh0ID0gdGhpcy5uZXh0Lm1hcChmdW5jdGlvbihwbGF5YWJsZSkge1xyXG5cdFx0XHRyZXR1cm4gcGxheWFibGUuc3VtbWFyaXplKHt9LCBlbnRyaWVzKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIElmIHRoZXJlJ3Mgb25seSBvbmUgaXRlbSwgbm8gbmVlZCBmb3IgYW4gYXJyYXkuXHJcblx0XHRpZiAoc3VtbWFyeS5uZXh0Lmxlbmd0aCA9PSAxKSBzdW1tYXJ5Lm5leHQgPSBzdW1tYXJ5Lm5leHRbMF07XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbi8vQ29udm9sdXRlZCBjb2RlIGhlcmUgdG8gcHJvZHVjZSB0aGUgb2JqZWN0IHRoYXQgdXNlciBpbnRlcmFjdHMgd2l0aCAoaWUgYzEgaW4gJ2MxID0gQ2hvaWNlKCknKVxyXG4vL1RoaXMgbWltaWNzIGNyZWF0aW5nIGEgY2xhc3MgdGhhdCBpbmhlcml0cyBmcm9tIEZ1bmN0aW9uLiBGaXJzdCBkZWZpbmUgdGhlIFwicHJvdG90eXBlXCIsIHdoaWNoIGluY2x1ZGVzXHJcbi8vYSBcImNvbnN0cnVjdG9yXCIsIGEgXCJjYWxsXCIgbWV0aG9kIHRoYXQgd2lsbCBnZXQgY2FsbGVkLCBhbmQgYW55IG90aGVyIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXHJcbi8vVGhlbiAnY2xhc3NGYWN0b3J5JyBwcm9kdWNlcyB0aGUgY2xhc3MvY29uc3RydWN0aW5nIG9iamVjdCAoc2VlIGJlbG93KSwgd2hpY2ggeW91IGNhbiB1c2UgdG9cclxuLy9wcm9kdWNlIHRoZSBhY3R1YWwgb2JqZWN0cy5cclxuXHJcbnZhciBwbGF5YWJsZVByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRnVuY3Rpb24ucHJvdG90eXBlKTtcclxuXHJcbnBsYXlhYmxlUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZnVuY3Rpb24oX3BsYXlhYmxlKSB7XHJcblx0dmFyIHBsYXlhYmxlID0gdGhpcztcclxuXHJcblx0Ly9UYWctYmFjay4gU3RvcmUgdGhlIGZyb250LWVuZCBvYmplY3QgaW4gdGhlIGJhY2stZW5kIG9iamVjdCwgZm9yIHJldHJpZXZhbFxyXG5cdF9wbGF5YWJsZS5pbnRlcmZhY2UgPSBwbGF5YWJsZTtcclxuXHJcblx0dGhpcy5jYWxsID0gZnVuY3Rpb24oc291cmNlKSB7XHJcblx0XHR2YXIgcHJldmlvdXNQbGF5YWJsZSwgcGF0aDtcclxuXHJcblx0XHQvL1RPRE86IHZlcmlmeSB0aGF0IHNvdXJjZSBpcyB0aGUgcmlnaHQgdHlwZVxyXG5cclxuXHRcdHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UuYWxsKFtcclxuXHRcdFx0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmIChzb3VyY2UgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHNvdXJjZSBpbnN0YW5jZW9mIFN5bmNocm9ub3VzUHJvbWlzZSkge1xyXG5cdFx0XHRcdFx0c291cmNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdFx0XHRcdHByZXZpb3VzUGxheWFibGUgPSByZWdpc3RyeS5wbGF5YWJsZXNbcmVzdWx0LnBsYXlhYmxlLmlkKCldO1xyXG5cdFx0XHRcdFx0XHRwYXRoID0gcmVzdWx0LnBhdGg7XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKHBhdGgpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoKTtcclxuXHRcdFx0fSkoKSxcclxuXHRcdFx0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFByb21pc2UgfHwgc291cmNlIGluc3RhbmNlb2YgU3luY2hyb25vdXNQcm9taXNlKSkge1xyXG5cdFx0XHRcdFx0cHJldmlvdXNQbGF5YWJsZSA9IHJlZ2lzdHJ5LnBsYXlhYmxlc1tzb3VyY2UuaWQoKV07XHJcblx0XHRcdFx0XHRwYXRoID0gc291cmNlLnBhdGg7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoKTtcclxuXHRcdFx0fSkoKVxyXG5cdFx0XSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0Y29uc29sZS5sb2cocGF0aCk7XHJcblx0XHRcdGxvZyhcclxuXHRcdFx0XHRcImRlYnVnXCIsXHJcblx0XHRcdFx0XCJBZGRpbmcgbmV4dCBwbGF5YWJsZSB0byBcIiArXHJcblx0XHRcdFx0cHJldmlvdXNQbGF5YWJsZS5pZCArXHJcblx0XHRcdFx0XCIsIG5vZGUgXCIgK1xyXG5cdFx0XHRcdF9wbGF5YWJsZS5pZFxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0aWYgKHBhdGggPT0gXCJhbGxcIikgcHJldmlvdXNQbGF5YWJsZS5hZGROZXh0KF9wbGF5YWJsZSk7XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdG91dGNvbWVUcmVlR2V0VmFsdWUocHJldmlvdXNQbGF5YWJsZS5uZXh0LCBwYXRoKS5wdXNoKF9wbGF5YWJsZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxvZyhcInNpbGx5XCIsIHByZXZpb3VzUGxheWFibGUubmV4dCk7XHJcblx0XHRcdC8vcHJldmlvdXNQbGF5YWJsZS5uZXh0W3NlbGVjdGVkXS5wdXNoKF9jaG9pY2UpO1xyXG5cclxuXHRcdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKHtcclxuXHRcdFx0XHRwbGF5YWJsZTogcGxheWFibGUsXHJcblx0XHRcdFx0cGF0aDogXCJhbGxcIlxyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdHRoaXMuaWQgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBfcGxheWFibGUuaWQ7XHJcblx0fTtcclxuXHJcblx0dGhpcy5wbGF5ID0gZnVuY3Rpb24oe1xyXG5cdFx0aW5pdGlhbGl6ZVBsYXllcnMgPSBmYWxzZSxcclxuXHRcdHVzZVBheW9mZnMgPSB0cnVlLFxyXG5cdFx0c2hvcnRDaXJjdWl0ID0gZmFsc2UsXHJcblx0XHR3cml0ZUhpc3RvcnkgPSB0cnVlLFxyXG5cdFx0Y2xlYXJIaXN0b3J5ID0gdHJ1ZSxcclxuXHRcdHJlbGVhc2VQbGF5ZXJzID0gdHJ1ZVxyXG5cdH0gPSB7fSkge1xyXG5cclxuXHRcdGlmIChjbGVhckhpc3RvcnkpIGdhbWVIaXN0b3J5LmNsZWFySGlzdG9yeSgpO1xyXG5cclxuXHRcdHZhciBoaXN0b3J5ID0gd3JpdGVIaXN0b3J5ID9cclxuXHRcdFx0X3BsYXlhYmxlLmhpc3RvcnkgfHwgZ2FtZUhpc3RvcnkgOlxyXG5cdFx0XHRuZXcgSGlzdG9yeSgpO1xyXG5cclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxyXG5cdFx0XHQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0XHRyZXR1cm4gX3BsYXlhYmxlLnBsYXkoeyBpbml0aWFsaXplUGxheWVycywgdXNlUGF5b2Zmcywgc2hvcnRDaXJjdWl0LCBoaXN0b3J5LCByZWxlYXNlUGxheWVycyB9KTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmNhdGNoKGZ1bmN0aW9uKHJlYXNvbikge1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKHJlYXNvbik7XHJcblxyXG5cdFx0XHRcdC8vSWYgdGhlIGdhbWUgd2FzIHN0b3BwZWQgYnkgYSBIYWx0IHBsYXlhYmxlIG9yIGV2ZXJ5Ym9keSdzIGRlYWQsIHdlJ2xsIGVuZCB1cCBoZXJlLCBhbmQgdGhpbmdzIGFyZSBmaW5lLiBKdXN0IGxvZyBpdC5cclxuXHRcdFx0XHRpZiAocmVhc29uLnJlc3VsdCA9PSBcIkhhbHRcIikge1xyXG5cdFx0XHRcdFx0Z2FtZUhpc3RvcnkuYWRkKHJlYXNvbi5oaXN0b3J5RW50cnkpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFzb24ucmVzdWx0KTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHJlYXNvbi5yZXN1bHQgPT0gXCJQb3B1bGF0aW9uIENvbGxhcHNlXCIpXHJcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYXNvbi5yZXN1bHQpO1xyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0aGlzdG9yeS5sb2cuYWRkKHsgZXJyb3I6IHJlYXNvbiB9KTtcclxuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSlcclxuXHRcdFx0LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdFx0Ly9SZXBsYWNlIHJlc3VsdCwgc28gdGhhdCB1c2VyIGNhbid0IGdldCBhY2Nlc3MgdG8gX3BsYXlhYmxlc1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcclxuXHRcdFx0XHRcdFBvcHVsYXRpb246IFBvcHVsYXRpb24oKSxcclxuXHRcdFx0XHRcdGdhbWVIaXN0b3J5XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdHRoaXMuc3VtbWFyaXplID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gX3BsYXlhYmxlLnN1bW1hcml6ZSh7fSk7XHJcblx0fTtcclxufTtcclxuXHJcbnBsYXlhYmxlUHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbigpIHtcclxuXHQvL1RoaXMgd2lsbCBnZXQgb3ZlcndyaXR0ZW4gd2hlbiB0aGUgXCJjb25zdHJ1Y3RvclwiIGlzIGNhbGxlZCwgYnV0IGxlYXZpbmcgaXQgaGVyZSBzbyB5b3UgY2FuIGZpZ3VyZSBvdXQgaG93IHRoZSBoZWxsIHRoaXMgd29ya3MuXHJcbn07XHJcblxyXG5wbGF5YWJsZVByb3RvdHlwZS5wYXRoID0gXCJhbGxcIjtcclxuXHJcbi8vUHJvZHVjZXMgdGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBwcm9kdWNlIHRoZSBlbmQgcmVzdWx0LiBUaGlzIHBhcnQgaXMgcmV1c2FibGUgaWYgeW91IG5lZWQgdG8gZG8gdGhpcyBhZ2Fpbi5cclxudmFyIGNsYXNzRmFjdG9yeSA9IGZ1bmN0aW9uKHByb3RvKSB7XHJcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGYgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIGYuY2FsbC5hcHBseShmLCBhcmd1bWVudHMpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJjb25zdHJ1Y3RvclwiLCB7XHJcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuXHRcdFx0d3JpdGFibGU6IHRydWVcclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwiY2FsbFwiLCB7IHdyaXRhYmxlOiB0cnVlIH0pO1xyXG5cclxuXHRcdE9iamVjdC5rZXlzKHByb3RvKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG5cdFx0XHRmW2tleV0gPSBwcm90b1trZXldO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Zi5jb25zdHJ1Y3Rvci5hcHBseShmLCBhcmd1bWVudHMpO1xyXG5cclxuXHRcdGRlbGV0ZSBmLmNvbnN0cnVjdG9yOyAvL0FkZGVkIHRoaXMgYml0IGhlcmUsIHRvIHByZXZlbnQgdGhlIHVzZXIgZnJvbSB0cnlpbmcgdG8gY3JlYXRlIG5ldyBvYmplY3RzLlxyXG5cclxuXHRcdHJldHVybiBmO1xyXG5cdH07XHJcbn07XHJcblxyXG52YXIgUGxheWFibGUgPSBjbGFzc0ZhY3RvcnkocGxheWFibGVQcm90b3R5cGUpO1xyXG4vLyBjYWxsZWQgYXM6IHZhciBpbnN0YW5jZSA9IFBsYXlhYmxlKC8qIHNvbWUgaW50ZXJuYWwgb2JqZWN0IGxpa2UgX2Nob2ljZSAqLyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxuXHJcbi8vRXh0ZXJuYWwgZGVwZW5kZW5jeVxyXG52YXIgcG9pc3NvbiA9IHJlcXVpcmUoJ3JhbmRnZW4nKS5ycG9pc3NvbjtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIge3JlZ2lzdHJ5LCBnYW1lSGlzdG9yeX0gPSByZXF1aXJlKCcuLi9zdGF0ZScpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7aXNGdW5jdGlvbn1cdD0gcmVxdWlyZSgnLi4vaGVscGVyRnVuY3Rpb25zJykoXCJnZW5lcmFsXCIpO1xyXG52YXIge2lkSGFuZGxlcn0gXHQ9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwic3RhdGVcIik7XHJcblxyXG4vL1BhcmVudCBjbGFzc1xyXG52YXIge19QbGF5YWJsZSwgUGxheWFibGV9ID0gcmVxdWlyZSgnLi9wbGF5YWJsZScpO1xyXG5cclxuLy9QbGF5ZXIgY29udHJvbGxlcnNcclxudmFyIHtfUGxheWVyLCBQbGF5ZXJ9ID0gcmVxdWlyZSgnLi4vcGxheWVyJyk7XHJcbnZhciB7UGxheWVyTGlzdCwgVXNlclBsYXllckxpc3QsIGdhbWVQb3B1bGF0aW9uLCBQb3B1bGF0aW9ufSA9IHJlcXVpcmUoJy4uL3BvcHVsYXRpb24nKTtcclxuXHJcbi8vVXBkYXRlIHRoaXMgZWFjaCB0aW1lIC5wbGF5IGlzIGNhbGxlZCwgYnV0IGxlYXZlIGl0IGF2YWlsYWJsZSB0byB0aGUgd2hvbGUgc2NvcGUgc28gdGhhdCBcclxuLy9ncm93dGggYW5kIGRlY2F5IGNhbiBhY2Nlc3MgaXRcclxudmFyIHBvcHVsYXRpb247XHJcblxyXG4vL0RlZmF1bHQgZ3Jvd3RoIGZ1bmN0aW9uXHJcbnZhciBncm93dGhEZWZhdWx0ID0gZnVuY3Rpb24gZ3Jvd3RoKHBsYXllciwgcG9wdWxhdGlvbiwgYmlydGhSYXRlLCBzZWxlY3RpdmVNdWx0aXBsaWVyKSB7XHJcblx0dmFyIHNjb3JlID0gcGxheWVyLnNjb3JlO1xyXG5cdHZhciBtZWFuID0gcG9wdWxhdGlvbi5zY29yZXNNZWFuKCk7XHJcblx0dmFyIHN0ZCA9IHBvcHVsYXRpb24uc2NvcmVzU3RkKCk7XHJcblx0XHJcblx0dmFyIFogPSAhKGlzTmFOKHN0ZCkgfHwgc3RkPT0wKSA/IChzY29yZS1tZWFuKS9zdGQgOiAwXHJcblx0XHJcblx0Y29uc29sZS5sb2coc2NvcmUsIG1lYW4sIHN0ZCxaKTtcclxuXHRcclxuXHR2YXIgcmF0ZSA9IGJpcnRoUmF0ZSArIHNlbGVjdGl2ZU11bHRpcGxpZXIqWjtcclxuXHJcblx0dmFyIGdlbmVyYXRlZCA9IHBvaXNzb24ocmF0ZSk7XHJcblx0bG9nKFwic2lsbHlcIixcImdyb3d0aERlZmF1bHQ6IGdlbmVyYXRlZCByYW5kb20gbnVtYmVyIFwiICsgZ2VuZXJhdGVkLnRvU3RyaW5nKCkrIFwiIHVzaW5nIHJhdGUgXCIrIHJhdGUudG9TdHJpbmcoKSk7XHJcblx0XHJcblx0cmV0dXJuIGdlbmVyYXRlZDtcclxufVxyXG5cclxuLy9EZWZhdWx0IGRlY2F5IGZ1bmN0aW9uXHJcbnZhciBkZWNheURlZmF1bHQgPSBmdW5jdGlvbiBkZWNheShwbGF5ZXIsIHBvcHVsYXRpb24sIGRlYXRoUmF0ZSwgc2VsZWN0aXZlTXVsdGlwbGllcikge1xyXG5cdHZhciBzY29yZSA9IHBsYXllci5zY29yZTtcclxuXHR2YXIgbWVhbiA9IHBvcHVsYXRpb24uc2NvcmVzTWVhbigpO1xyXG5cdHZhciBzdGQgPSBwb3B1bGF0aW9uLnNjb3Jlc1N0ZCgpO1xyXG5cdFxyXG5cdGNvbnNvbGUubG9nKHNjb3JlLCBtZWFuLCBzdGQpO1xyXG5cdFxyXG5cdHZhciBaID0gICEoaXNOYU4oc3RkKXx8c3RkPT0wKSA/IChzY29yZS1tZWFuKS9zdGQgOiAwO1xyXG5cdFxyXG5cdGNvbnNvbGUubG9nKFopXHJcblx0dmFyIHJhdGUgPSBkZWF0aFJhdGUgLSBzZWxlY3RpdmVNdWx0aXBsaWVyKlo7XHJcblx0XHJcblx0dmFyIGdlbmVyYXRlZCA9IHBvaXNzb24ocmF0ZSk7XHJcblx0bG9nKFwic2lsbHlcIixcImRlY2F5RGVmYXVsdDogZ2VuZXJhdGVkIHJhbmRvbSBudW1iZXIgXCIgKyBnZW5lcmF0ZWQudG9TdHJpbmcoKSsgXCIgdXNpbmcgcmF0ZSBcIisgcmF0ZS50b1N0cmluZygpKTtcclxuXHRyZXR1cm4gZ2VuZXJhdGVkO1xyXG59XHJcblxyXG5cclxuXHJcbi8vQmFja2VuZCBmdW5jdGlvbiBjbGFzcyBmb3IgUG9wdWxhdGlvbkR5bmFtaWNzXHJcbmZ1bmN0aW9uIF9Qb3B1bGF0aW9uRHluYW1pY3MoaWQsIGJpcnRoUmF0ZSxkZWF0aFJhdGUsIHtncm93dGhGdW5jdGlvbj1ncm93dGhEZWZhdWx0LCBkZWNheUZ1bmN0aW9uPWRlY2F5RGVmYXVsdCwgc2VsZWN0aXZlTXVsdGlwbGllcj0gLjUsIHBsYXllclBhcmFtZXRlcnM9e319PXt9KXtcclxuXHRfUGxheWFibGUuY2FsbCh0aGlzLGlkKTtcclxuXHRcclxuXHR2YXIgcGQgPSB0aGlzO1xyXG5cdFxyXG5cdHRoaXMuYmlydGhSYXRlID0gYmlydGhSYXRlO1xyXG5cdHRoaXMuZGVhdGhSYXRlID0gZGVhdGhSYXRlO1xyXG5cdHRoaXMuc2VsZWN0aXZlTXVsdGlwbGllciA9IHNlbGVjdGl2ZU11bHRpcGxpZXI7XHJcblx0XHJcblx0Ly9XcmFwIHRoZSBncm93dGggYW5kIGRlY2F5IGZ1bmN0aW9ucywgc28gdGhhdCB0aGUgdXNlciBkb2Vzbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgY2FsbGluZyB0aGlzLmJpcnRoUmF0ZSBvciB0aGlzLmRlYXRoUmF0ZVxyXG5cdHRoaXMuZ3Jvd3RoID0gZnVuY3Rpb24ocGxheWVyKXtcclxuXHRcdGxvZyhcInNpbGx5XCIsXCJfcGQuZ3Jvd3RoOiBDaGVja2luZyBncm93IGNvbmRpdGlvblwiKTtcclxuXHRcdHJldHVybiBncm93dGhGdW5jdGlvbihwbGF5ZXIsIHBvcHVsYXRpb24sIHBkLmJpcnRoUmF0ZSwgcGQuc2VsZWN0aXZlTXVsdGlwbGllcilcclxuXHR9O1xyXG5cdHRoaXMuZGVjYXkgPSBmdW5jdGlvbihwbGF5ZXIpe1xyXG5cdFx0bG9nKFwic2lsbHlcIixcIl9wZC5kZWNheTogQ2hlY2tpbmcgZGVjYXkgY29uZGl0aW9uXCIpO1xyXG5cdFx0cmV0dXJuIGRlY2F5RnVuY3Rpb24ocGxheWVyLCBwb3B1bGF0aW9uLCBwZC5kZWF0aFJhdGUsIHBkLnNlbGVjdGl2ZU11bHRpcGxpZXIpO1xyXG5cdH07XHJcblx0XHJcblx0dGhpcy5wbGF5ZXJQYXJhbWV0ZXJzID0gcGxheWVyUGFyYW1ldGVycztcclxuXHRcclxuXHRyZWdpc3RyeS5jb250cm9sbGVyc1tpZF0gPSB0aGlzO1xyXG59XHJcbl9Qb3B1bGF0aW9uRHluYW1pY3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfUGxheWFibGUucHJvdG90eXBlKTtcclxuX1BvcHVsYXRpb25EeW5hbWljcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBfUG9wdWxhdGlvbkR5bmFtaWNzO1xyXG5cclxuX1BvcHVsYXRpb25EeW5hbWljcy5yZWdpc3RyeU5hbWUgPSBcImNvbnRyb2xsZXJzXCI7XHJcbl9Qb3B1bGF0aW9uRHluYW1pY3MuY291bnRlck5hbWUgPSBcInBvcHVsYXRpb25EeW5hbWljc1wiO1xyXG5cclxuXHJcbl9Qb3B1bGF0aW9uRHluYW1pY3MucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7aW5pdGlhbGl6ZVBsYXllcnM9ZmFsc2UsIHNob3J0Q2lyY3VpdD1mYWxzZSwgaGlzdG9yeT1nYW1lSGlzdG9yeX09e30pe1xyXG5cdFxyXG5cdHZhciBwZCA9IHRoaXM7XHJcblx0XHJcblx0dmFyIGJpcnRocyA9IDA7XHJcblx0dmFyIGRlYXRocyA9IDA7XHJcblx0XHJcblx0Ly9VcGRhdGUgcG9wdWxhdGlvbiB1c2luZyB3aG9ldmVyJ3MgYWxpdmUgY3VycmVudGx5XHJcblx0cG9wdWxhdGlvbiA9IGdhbWVQb3B1bGF0aW9uKCkub25seUFsaXZlKCk7XHJcblx0XHRcclxuXHRcclxuXHQvL0tpbGwgY3ljbGVcclxuXHR2YXIga2lsbGVkID0gbmV3IFBsYXllckxpc3QoW10pO1xyXG5cdHBvcHVsYXRpb24uZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpe1xyXG5cdFx0Ly8gSWYgdGhlIGRlY2F5IGZ1bmN0aW9uIGlzIHJldHVybnMgdHJ1dGh5LCBraWxsLlxyXG5cdFx0XHJcblx0XHRpZiAocGQuZGVjYXkocGxheWVyKSkge1xyXG5cdFx0XHRsb2coXCJzaWxseVwiLFwibXVzdCBraWxsLi4uXCIpXHJcblx0XHRcdHBsYXllci5raWxsKCk7XHJcblx0XHRcdGRlYXRocysrO1xyXG5cdFx0XHRraWxsZWQucHVzaChwbGF5ZXIpO1xyXG5cdFx0XHRsb2coXCJzaWxseVwiLFwiZGVhZFwiKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0XHJcblx0fSk7XHJcblx0XHJcblx0Ly9VcGRhdGUgdXBkYXRlIGFnYWluIHRvIHByZXZlbnQgdGhlIHJlY2VudGx5IGRlY2Vhc2VkIGZyb20gcmVwcm9kdWNpbmdcclxuXHRwb3B1bGF0aW9uID0gZ2FtZVBvcHVsYXRpb24oKS5vbmx5QWxpdmUoKTtcclxuXHRcclxuXHRpZiAocG9wdWxhdGlvbi5sZW5ndGggPT0gMCkge1xyXG5cdFx0Ly9FdmVyeWJvZHkncyBkZWFkLiBMZXQncyB3cmFwIGl0IHVwLlxyXG5cdFx0dmFyIHJlYXNvbiA9IHtyZXN1bHQ6XCJQb3B1bGF0aW9uIENvbGxhcHNlXCIsIHBsYXlhYmxlOnBkfTtcclxuXHRcdGhpc3RvcnkuZW5kKCk7XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYXNvbik7XHJcblx0fVxyXG5cdFxyXG5cdC8vQmlydGggY3ljbGVcclxuXHR2YXIgYm9ybiA9IG5ldyBVc2VyUGxheWVyTGlzdChbXSk7XHJcblx0cG9wdWxhdGlvbi5mb3JFYWNoKGZ1bmN0aW9uKHBsYXllcil7XHJcblx0XHQvL0JpcnRoIHdoYXRldmVyIG51bWJlciBpcyByZXR1cm5lZFxyXG5cdFx0dmFyIG51bUJpcnRoID0gcGQuZ3Jvd3RoKHBsYXllcilcclxuXHRcdGNvbnNvbGUubG9nKG51bUJpcnRoKTtcclxuXHRcdGZvciAodmFyIGk9MTsgaTw9bnVtQmlydGg7IGkrKyl7XHJcblx0XHRcdGxvZyhcInNpbGx5XCIsIFwiUGxheWVyIFwiICsgcGxheWVyLmlkICtcIiBnaXZpbmcgYmlydGghXCIpO1xyXG5cdFx0XHRcclxuXHRcdFx0dmFyIHBsYXllclBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LHtcclxuXHRcdFx0XHRcdGFzc2lnbjpwbGF5ZXIuc3RyYXRlZ3kgPyBwbGF5ZXIuc3RyYXRlZ3kuX2lkIDogXCJcIixcclxuXHRcdFx0XHRcdHBhcmVudDpwbGF5ZXIuaWR9XHJcblx0XHRcdFx0LHBkLnBsYXllclBhcmFtZXRlcnMpO1xyXG5cdFx0XHRcclxuXHRcdFx0Ym9ybi5wdXNoKFBsYXllcihwbGF5ZXJQYXJhbWV0ZXJzKSk7XHJcblx0XHR9XHRcclxuXHR9KTtcclxuXHRcclxuXHRcclxuXHR2YXIgcmVzdWx0ID0ge2JpcnRocywgZGVhdGhzfTtcclxuXHRcclxuXHR2YXIgcmVzdWx0T2JqZWN0ID0ge1xyXG5cdFx0cmVzdWx0LFxyXG5cdFx0J3BsYXlhYmxlJzpwZCxcclxuXHRcdGhpc3RvcnlFbnRyeTp7XHJcblx0XHRcdHBvcHVsYXRpb25EeW5hbWljczpwZC5pZCxcclxuXHRcdFx0cmVzdWx0XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdE9iamVjdCk7XHJcbn07XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIFBvcHVsYXRpb25EeW5hbWljcyhiaXJ0aFJhdGU9LjA1LCBkZWF0aFJhdGUgPSAuMDUsIHBhcmFtZXRlcnM9e30pe1xyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihwYXJhbWV0ZXJzLmlkLFwicG9wdWxhdGlvbkR5bmFtaWNzXCIpXHJcblx0XHJcblx0aWYgKHBhcmFtZXRlcnMuZ3Jvd3RoICYmICFpc0Z1bmN0aW9uKGdyb3d0aCkpIGxvZyhcImVycm9yXCIsaWQgKyBcIjogZ3Jvd3RoIHNob3VsZCBiZSBhIGZ1bmN0aW9uLlwiKTtcclxuXHRpZiAocGFyYW1ldGVycy5kZWNheSAmJiAhaXNGdW5jdGlvbihkZWNheSkpICAgbG9nKFwiZXJyb3JcIixpZCArIFwiOiBkZWNheSBzaG91bGQgYmUgYSBmdW5jdGlvbi5cIik7XHJcblx0XHRcclxuXHQvL0NyZWF0ZSBiYWNrZW5kIGxhbWJkYSBvYmplY3RcclxuXHR2YXIgX3BkID0gbmV3IF9Qb3B1bGF0aW9uRHluYW1pY3MoaWQsIGJpcnRoUmF0ZSwgZGVhdGhSYXRlLCBwYXJhbWV0ZXJzKTtcclxuXHRcclxuXHRcclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIHBkID0gUGxheWFibGUoX3BkKTtcdFxyXG5cdHJldHVybiBwZDtcdFxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7X1BvcHVsYXRpb25EeW5hbWljcywgUG9wdWxhdGlvbkR5bmFtaWNzfTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBSYW5kb21QbGF5ZXJDaG9pY2VcIilcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSwgZ2FtZUhpc3RvcnksIG9jY3VwaWVkUGxheWVycyB9ID0gcmVxdWlyZSgnLi4vc3RhdGUnKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwic3RhdGVcIik7XHJcbnZhciB7IGNoYWluZXJHZW5lcmF0b3IgfSA9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwicGxheWFibGVcIik7XHJcblxyXG4vL1BhcmVudCBjbGFzc1xyXG52YXIgeyBfUGxheWFibGUsIFBsYXlhYmxlIH0gPSByZXF1aXJlKCcuL3BsYXlhYmxlJyk7XHJcbnZhciB7IF9DaG9pY2UsIENob2ljZSB9ID0gcmVxdWlyZSgnLi9jaG9pY2UnKTtcclxuXHJcbi8vUG9wdWxhdGlvbiBoZWxwZXJzXHJcbnZhciB7IFBsYXllckxpc3QgfSA9IHJlcXVpcmUoJy4uL3BvcHVsYXRpb24nKTtcclxuXHJcblxyXG4vL0JhY2tlbmQgZnVuY3Rpb24gY2xhc3MgZm9yIFJQQ2hvaWNlXHJcbmZ1bmN0aW9uIF9SUENob2ljZShpZCwgb3B0aW9ucywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblxyXG5cdC8vSWYgdGhleSBzcGVjaWZ5IHBsYXllcnMgdG8gZHJhdyBmcm9tLCB1c2Ugb25seSB0aGF0IGxpc3QuIE90aGVyd2lzZSwgdXNlIHdob2V2ZXIncyBhcm91bmQuXHJcblx0dGhpcy5pbmNsdWRlUGxheWVycyA9IHBhcmFtZXRlcnMuaW5jbHVkZVBsYXllcnMgfHwgXCJhbGxcIjtcclxuXHJcblx0dGhpcy5leGNsdWRlUGxheWVycyA9IHBhcmFtZXRlcnMuZXhjbHVkZVBsYXllcnMgPyBuZXcgUGxheWVyTGlzdChwYXJhbWV0ZXJzLmV4Y2x1ZGVQbGF5ZXJzKSA6IG5ldyBQbGF5ZXJMaXN0KClcclxuXHJcblx0dGhpcy5nZW5lcmF0b3IgPSBNYXRoLnJhbmRvbTtcclxuXHJcblx0dmFyIHBsYXllciA9IG51bGw7XHJcblxyXG5cclxuXHRfQ2hvaWNlLmNhbGwodGhpcywgaWQsIHBsYXllciwgb3B0aW9ucywgcGFyYW1ldGVycyk7XHJcbn1cclxuXHJcbl9SUENob2ljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9DaG9pY2UucHJvdG90eXBlKTtcclxuX1JQQ2hvaWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9SUENob2ljZTtcclxuXHJcbl9SUENob2ljZS5yZWdpc3RyeU5hbWUgPSBcImNob2ljZXNcIjtcclxuX1JQQ2hvaWNlLmNvdW50ZXJOYW1lID0gXCJyYW5kb21QbGF5ZXJDaG9pY2VcIjtcclxuXHJcblxyXG5cclxuLy9TZWxlY3QgdGhlIHBsYXllciB0byBtYWtlIHRoZSBjaG9pY2VcclxuX1JQQ2hvaWNlLnByb3RvdHlwZS5jaG9vc2VQbGF5ZXIgPSBmdW5jdGlvbiBjaG9vc2VQbGF5ZXIoKSB7XHJcblxyXG5cdHZhciBycENob2ljZSA9IHRoaXM7XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdC8vRmluZCBwbGF5ZXJzIHRvIGNob29zZSBmcm9tXHJcblx0XHR2YXIgcG9vbCA9IG5ldyBQbGF5ZXJMaXN0KHJwQ2hvaWNlLmluY2x1ZGVQbGF5ZXJzKS5vbmx5QWxpdmUoKS5vbmx5QXZhaWxhYmxlKCkuZXhjbHVkZShycENob2ljZS5leGNsdWRlUGxheWVycylcclxuXHRcdGlmIChwb29sLmxlbmd0aCA9PSAwKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJObyBhdmFpbGFibGUgcGxheWVycy5cIik7XHJcblxyXG5cdFx0bG9nKFwic2lsbHlcIiwgXCJycENob2ljZS5jaG9vc2VQbGF5ZXI6IGNob29zaW5nIGZyb29tIHBvb2w6IFwiICsgcG9vbC5pZHMoKSk7XHJcblxyXG5cdFx0dmFyIHJhbmRvbU51bWJlciA9IE1hdGguZmxvb3IocnBDaG9pY2UuZ2VuZXJhdG9yKCkgKiBwb29sLmxlbmd0aCk7XHJcblx0XHR2YXIgY2FuZGlkYXRlID0gcG9vbFtyYW5kb21OdW1iZXJdO1xyXG5cclxuXHJcblx0XHRsb2coXCJzaWxseVwiLCBcInJwQ2hvaWNlLmNob29zZVBsYXllcjogc2VsZWN0aW5nIHBsYXllciBcIiwgY2FuZGlkYXRlLmlkKVxyXG5cclxuXHRcdHJwQ2hvaWNlLnBsYXllciA9IGNhbmRpZGF0ZTtcclxuXHRcdGNhbmRpZGF0ZS5hdmFpbGFibGUgPSBmYWxzZTtcclxuXHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhbmRpZGF0ZS5pZCk7XHJcblx0fSk7XHJcbn07XHJcblxyXG5fUlBDaG9pY2UucHJvdG90eXBlLnByZVBsYXkgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5jaG9vc2VQbGF5ZXIoKTtcclxufTtcclxuXHJcblxyXG5fUlBDaG9pY2UucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSkge1xyXG5cdHN1bW1hcnkub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxufTtcclxuXHJcblxyXG5cclxuZnVuY3Rpb24gUmFuZG9tUGxheWVyQ2hvaWNlKG9wdGlvbnMsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHZhciB7IGlkID0gbnVsbCwgZXhjbHVkZVBsYXllcnMgPSBbXSwgcGxheWVyTGlzdCA9IG51bGwgfSA9IHBhcmFtZXRlcnNcclxuXHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKGlkLCBcInJhbmRvbVBsYXllckNob2ljZVwiKVxyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIGNob2ljZSBvYmplY3RcclxuXHR2YXIgX3JwQ2hvaWNlID0gbmV3IF9SUENob2ljZShpZCwgb3B0aW9ucywgcGFyYW1ldGVycyk7XHJcblxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgcnBDaG9pY2UgPSBQbGF5YWJsZShfcnBDaG9pY2UpXHJcblxyXG5cdHJwQ2hvaWNlLnBsYXllckxpc3QgPSBmdW5jdGlvbihwbGF5ZXJMaXN0KSB7XHJcblx0XHRpZiAoQXJyYXkuaXNBcnJheShwbGF5ZXJMaXN0KSkgX3JwQ2hvaWNlLnBsYXllckxpc3QgPSBwbGF5ZXJMaXN0O1xyXG5cdFx0cmV0dXJuIF9ycENob2ljZS5wbGF5ZXJMaXN0XHJcblx0fTtcclxuXHJcblx0cnBDaG9pY2UuZXhjbHVkZVBsYXllcnMgPSBmdW5jdGlvbihleGNsdWRlUGxheWVycykge1xyXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoZXhjbHVkZVBsYXllcnMpKSB7XHJcblx0XHRcdF9ycENob2ljZS5leGNsdWRlUGxheWVycyA9IFtdO1xyXG5cclxuXHRcdFx0ZXhjbHVkZVBsYXllcnMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0XHRfcnBDaG9pY2UuZXhjbHVkZVBsYXllcnMucHVzaChwbGF5ZXIuaWQoKSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdH1cclxuXHRcdHJldHVybiBfcnBDaG9pY2UuZXhjbHVkZVBsYXllcnNcclxuXHR9O1xyXG5cclxuXHQvL0ludGVyZmFjZSB0byBzcGVjaWZ5IHNpbmdsZS1wbGF5ZXIgcGF5b2ZmcyBpbiBzaW5nbGUtcGxheWVyL3NpbmdsZS1jaG9pY2UgZ2FtZXNcclxuXHRfcnBDaG9pY2UuemVyb1BheW9mZnMoKTtcclxuXHJcblx0X3JwQ2hvaWNlLmdlbmVyYXRlQ2hhaW5pbmdGdW5jdGlvbnMocnBDaG9pY2UpO1xyXG5cclxuXHQvL0Z1bmN0aW9uIHRvIHNldCBhbGwgcGF5b2ZmcyBhdCBvbmNlXHJcblx0cnBDaG9pY2Uuc2V0QWxsUGF5b2ZmcyA9IGZ1bmN0aW9uKHBheW9mZnMpIHtcclxuXHRcdC8vVE9ETzogbWFrZSB0aGlzIHdvcmsuIEluY2x1ZGUgZXJyb3IgaGFuZGxpbmcgaWYgYXJyYXkgZ2l2ZW4gaXNuJ3QgZXhwZWN0ZWQgZGltZW5zaW9ucy5cclxuXHR9O1xyXG5cclxuXHJcblx0Ly9XYXkgZm9yIHVzZXIgdG8gaW50ZXJhY3Qgd2l0aCBwYXlvZmZzXHJcblx0cnBDaG9pY2UucGF5b2ZmcyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVnaXN0cnkuY2hvaWNlc1tpZF0ucGF5b2ZmczsgfTtcclxuXHJcblx0cmV0dXJuIHJwQ2hvaWNlO1xyXG59XHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBfUlBDaG9pY2UsIFJhbmRvbVBsYXllckNob2ljZSB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgQ2xhc3M6IFNlcXVlbmNlXCIpO1xyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKFwiLi4vc3RhdGVcIik7XHJcbnZhciB7IGdhbWVIaXN0b3J5IH0gPSByZXF1aXJlKFwiLi4vaGlzdG9yeVwiKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJGdW5jdGlvbnNcIikoXCJzdGF0ZVwiKTtcclxuXHJcbi8vSW5mb3JtYXRpb25cclxudmFyIHsgSW5mb3JtYXRpb24sIFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0gcmVxdWlyZShcIi4uL2luZm9ybWF0aW9uXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9ID0gcmVxdWlyZShcIi4vcGxheWFibGVcIik7XHJcblxyXG4vL0JhY2tlbmQgZnVuY3Rpb24gY2xhc3MgZm9yIFNlcXVlbmNlXHJcbmZ1bmN0aW9uIF9TZXF1ZW5jZShpZCwgcGxheWFibGVTdGFydCwgcGxheWFibGVGaW5pc2gsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdF9QbGF5YWJsZS5jYWxsKHRoaXMsIGlkLCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0dGhpcy5wbGF5YWJsZVN0YXJ0ID0gcmVnaXN0cnkucGxheWFibGVzW3BsYXlhYmxlU3RhcnQuaWQoKV07XHJcblx0dGhpcy5wbGF5YWJsZUZpbmlzaCA9IHJlZ2lzdHJ5LnBsYXlhYmxlc1twbGF5YWJsZUZpbmlzaC5pZCgpXTtcclxuXHJcblx0cmVnaXN0cnkuc2VxdWVuY2VzW2lkXSA9IHRoaXM7XHJcbn1cclxuX1NlcXVlbmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX1BsYXlhYmxlLnByb3RvdHlwZSk7XHJcbl9TZXF1ZW5jZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBfU2VxdWVuY2U7XHJcblxyXG5fU2VxdWVuY2UucmVnaXN0cnlOYW1lID0gXCJzZXF1ZW5jZXNcIjtcclxuX1NlcXVlbmNlLmNvdW50ZXJOYW1lID0gXCJzZXF1ZW5jZVwiO1xyXG5cclxuX1NlcXVlbmNlLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oe1xyXG5cdGhpc3RvcnkgPSBnYW1lSGlzdG9yeSxcclxuXHRpbmZvcm1hdGlvbiA9IHRoaXMuaW5mb3JtYXRpb24gfHxcclxuXHRQZXJmZWN0SW5mb3JtYXRpb25cclxufSA9IHt9KSB7XHJcblxyXG5cdHZhciBzZXF1ZW5jZSA9IHRoaXM7XHJcblxyXG5cdC8vTG9nIHRoZSBoaXN0b3J5IGFwcHJvcHJpYXRlbHlcclxuXHR2YXIgc3RhcnRFbnRyeSA9IHtcclxuXHRcdHNlcXVlbmNlOiBzZXF1ZW5jZS5pZCxcclxuXHRcdGFjdGlvbjogXCJzdGFydFwiXHJcblx0fTtcclxuXHRoaXN0b3J5LmxvZy5hZGQoc3RhcnRFbnRyeSk7XHJcblxyXG5cdC8vSGlzdG9yeSBvYmplY3QgdG8gZ2l2ZSB0byBzZXF1ZW5jZWQgcGxheWFibGVzLlxyXG5cdHZhciBzZXF1ZW5jZUhpc3RvcnkgPSBoaXN0b3J5LmNoaWxkKCk7XHJcblxyXG5cdC8vY29tcGFydG1lbnRhbGl6ZSBpZiBzZXQuIFwiY29tcGFydG1lbnRhbGl6ZVwiIG1lYW5zIHBhc3Mgb24gaW5mb3JtYXRpb24gYXMgaWYgdGhpcyBwbGF5YWJsZSBpcyB0aGUgZW50aXJlIGdhbWUuXHJcblx0aWYgKHNlcXVlbmNlLmNvbXBhcnRtZW50YWxpemUpIHtcclxuXHRcdGluZm9ybWF0aW9uID0gbmV3IEluZm9ybWF0aW9uKHNlcXVlbmNlLmNvbXBhcnRtZW50YWxpemUuaGlzdG9yeSB8fCBzZXF1ZW5jZUhpc3RvcnksXHJcblx0XHRcdHNlcXVlbmNlLmNvbXBhcnRtZW50YWxpemUucG9wdWxhdGlvbiB8fCBpbmZvcm1hdGlvbi5wb3B1bGF0aW9uKTtcclxuXHR9XHJcblxyXG5cdC8vIFJlY3Vyc2lvbiBkb3duIHRoZSBjaGFpbiBvZiBwbGF5YWJsZXNcclxuXHR2YXIgYWN0aW9uID0gZnVuY3Rpb24gYWN0aW9uKHJlc3VsdCkge1xyXG5cdFx0Ly9TdG9wIGlmIHRoZSBnYW1lIGlzIG92ZXIuXHJcblx0XHRpZiAoaGlzdG9yeS5zdG9wKSByZXR1cm4geyBwbGF5YWJsZTogc2VxdWVuY2UgfTtcclxuXHJcblx0XHQvL090aGVyd2lzZSwgcmVjdXJzZSB0byBmaWd1cmUgb3V0IHdoYXQgdG8gZG8gbmV4dC5cclxuXHRcdGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcclxuXHRcdFx0bG9nKFwic2lsbHlcIiwgXCJzZXF1ZW5jZS5wbGF5OiBOZXh0LWl0ZW0gaXMgYW4gYXJyYXksIHNwbGl0dGluZyBpbnRvIHBpZWNlcy5cIik7XHJcblxyXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoXHJcblx0XHRcdFx0cmVzdWx0Lm1hcChmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRcdFx0XHRsb2coXCJzaWxseVwiLCBcInNlcXVlbmNlLnBsYXk6IHJlY3Vyc2luZyBvblwiLCBpdGVtKTtcclxuXHRcdFx0XHRcdHJldHVybiBhY3Rpb24oaXRlbSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAocmVzdWx0LnBsYXlhYmxlICE9PSBzZXF1ZW5jZS5wbGF5YWJsZUZpbmlzaCkge1xyXG5cdFx0XHRsb2coXCJzaWxseVwiLCByZXN1bHQpO1xyXG5cclxuXHRcdFx0aWYgKHJlc3VsdC5wbGF5YWJsZS5maW5kTmV4dCh7IHJlc3VsdCB9KS5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0bG9nKFwic2lsbHlcIiwgXCJQbGF5YWJsZSBoYXMgbmV4dC1pdGVtLCBjb250aW51aW5nIGRvd24gY2hhaW4uXCIpO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0LnBsYXlhYmxlLnBsYXlOZXh0KHJlc3VsdCwgeyBzaG9ydENpcmN1aXQ6IHRydWUsIGhpc3Rvcnk6IHNlcXVlbmNlSGlzdG9yeSwgaW5mb3JtYXRpb24gfSlcclxuXHRcdFx0XHRcdC50aGVuKGFjdGlvbik7IC8vUmVwZWF0IGZvciBuZXh0IHBsYXlhYmxlIGluIGNoYWluXHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdH07XHJcblxyXG5cdHJldHVybiBzZXF1ZW5jZS5wbGF5YWJsZVN0YXJ0XHJcblx0XHQucGxheSh7IHNob3J0Q2lyY3VpdDogdHJ1ZSwgaGlzdG9yeTogc2VxdWVuY2VIaXN0b3J5LCBpbmZvcm1hdGlvbiB9KVxyXG5cdFx0LnRoZW4oYWN0aW9uKVxyXG5cdFx0LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdHJlc3VsdC5oaXN0b3J5RW50cnkgPSB7XHJcblx0XHRcdFx0c2VxdWVuY2U6IHNlcXVlbmNlLmlkLFxyXG5cdFx0XHRcdGFjdGlvbjogc2VxdWVuY2VIaXN0b3J5Lm9ycGhhbigpXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHQvL1RPRE86IGFkZCBpbmZvcm1hdGlvbiBtZWNoYW5pc21zXHJcblxyXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcblx0XHR9KTtcclxufTtcclxuXHJcbi8vT3ZlcndyaXRlIGhpc3RvcnkgaGFuZGxlciBzbyB0aGF0IHRyZWUgZG9lc24ndCBoYXZlIFwic3RhcnRcIiBhbmQgXCJmaW5pc2hcIiBlbnRyaWVzLlxyXG5fU2VxdWVuY2UucHJvdG90eXBlLmhhbmRsZUhpc3RvcnkgPSBmdW5jdGlvbih7IGhpc3RvcnkgPSBnYW1lSGlzdG9yeSB9ID0ge30sXHJcblx0cmVzdWx0XHJcbikge1xyXG5cdHZhciBzZXF1ZW5jZSA9IHRoaXM7XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0aGlzdG9yeS5sb2cuYWRkKHtcclxuXHRcdFx0c2VxdWVuY2U6IHNlcXVlbmNlLmlkLFxyXG5cdFx0XHRhY3Rpb246IFwiZmluaXNoXCIsXHJcblx0XHRcdGR1cmF0aW9uOiByZXN1bHQuaGlzdG9yeUVudHJ5LmR1cmF0aW9uXHJcblx0XHR9KTtcclxuXHJcblx0XHRoaXN0b3J5LmFkZE5vTG9nKHJlc3VsdC5oaXN0b3J5RW50cnkpO1xyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuLy9UT0RPOiBmaW5pc2ggdGhpcyFcclxuX1NlcXVlbmNlLnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnksIGVudHJpZXMsIHNob3J0Q2lyY3VpdCkge1xyXG5cdHN1bW1hcnkuYWN0aW9uID0ge307XHJcblxyXG5cdHRoaXMucGxheWFibGVTdGFydC5zdW1tYXJpemUoXHJcblx0XHRzdW1tYXJ5LmFjdGlvbixcclxuXHRcdGVudHJpZXMsXHJcblx0XHQoc2hvcnRDaXJjdWl0ID0gdGhpcy5wbGF5YWJsZUZpbmlzaClcclxuXHQpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gU2VxdWVuY2UocGxheWFibGVTdGFydCwgcGxheWFibGVGaW5pc2gsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihwYXJhbWV0ZXJzLmlkLCBcInNlcXVlbmNlXCIpO1xyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIGxvb3Agb2JqZWN0XHJcblx0dmFyIF9zZXF1ZW5jZSA9IG5ldyBfU2VxdWVuY2UoaWQsIHBsYXlhYmxlU3RhcnQsIHBsYXlhYmxlRmluaXNoLCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0Ly9SZXR1cm4gdGhpcyByZWZlcmVuY2Ugb2JqZWN0IHRvIHRoZSB1c2VyLiBSdW4gdGhlIGZ1bmN0aW9uIHRvIHNlbGVjdCBhIHNvdXJjZVxyXG5cdHZhciBzZXF1ZW5jZSA9IFBsYXlhYmxlKF9zZXF1ZW5jZSk7XHJcblx0cmV0dXJuIHNlcXVlbmNlO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX1NlcXVlbmNlLCBTZXF1ZW5jZSB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpc09iamVjdCB9ID0gcmVxdWlyZSgnLi4vaGVscGVyRnVuY3Rpb25zJykoXCJnZW5lcmFsXCIpO1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwic3RhdGVcIik7XHJcblxyXG4vL1BhcmVudCBjbGFzc1xyXG52YXIgeyBfUGxheWFibGUsIFBsYXlhYmxlIH0gPSByZXF1aXJlKCcuL3BsYXlhYmxlJyk7XHJcblxyXG4vLyBJbmZvcm1hdGlvbiBtZWNoYW5pY3NcclxudmFyIHsgSW5mb3JtYXRpb24sIFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0gcmVxdWlyZSgnLi4vaW5mb3JtYXRpb24nKTtcclxuXHJcblxyXG4vL0JhY2tlbmQgY2xhc3NcclxuZnVuY3Rpb24gX1NpbXVsdGFuZW91cyhpZCwgcGxheWFibGVBcnJheSwgeyBwbGF5YWJsZVBhcmFtZXRlcnMgPSB7fSB9ID0ge30pIHtcclxuXHRfUGxheWFibGUuY2FsbCh0aGlzLCBpZCk7XHJcblxyXG5cdHRoaXMucGxheWFibGVBcnJheSA9IHBsYXlhYmxlQXJyYXk7XHJcblx0dGhpcy5wbGF5YWJsZVBhcmFtZXRlcnMgPSBwbGF5YWJsZVBhcmFtZXRlcnM7XHJcblxyXG5cdHJlZ2lzdHJ5LmNvbnRyb2xsZXJzW2lkXSA9IHRoaXM7XHJcbn1cclxuXHJcbl9TaW11bHRhbmVvdXMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfUGxheWFibGUucHJvdG90eXBlKTtcclxuX1NpbXVsdGFuZW91cy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBfU2ltdWx0YW5lb3VzO1xyXG5cclxuX1NpbXVsdGFuZW91cy5yZWdpc3RyeU5hbWUgPSBcImNvbnRyb2xsZXJzXCI7XHJcbl9TaW11bHRhbmVvdXMuY291bnRlck5hbWUgPSBcInNpbXVsdGFuZW91c1wiO1xyXG5cclxuXHJcbi8vU2ltdWx0YW5lb3VzIFByb21pc2UuYWxsJ3MgdGhlIHBsYXlhYmxlcywgd2hpY2ggY2F1c2VzIHRoZW0gdG8gcnVuIG1lc2hlZC5cclxuX1NpbXVsdGFuZW91cy5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKHsgaGlzdG9yeSA9IGdhbWVIaXN0b3J5LCBpbmZvcm1hdGlvbiA9IFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0ge30pIHtcclxuXHJcblx0dmFyIHNpbXVsdGFuZW91cyA9IHRoaXM7XHJcblxyXG5cdC8vIERlYWwgd2l0aCBoaXN0b3J5LiBMb2cgc3RhcnQsIHRoZW4gc3BsaXQgaGlzdG9yeSBmb3IgY2hpbGRyZW4gcGxheWFibGVzIHRvIGZpbGwgaW4uXHJcblx0aGlzdG9yeS5sb2cuYWRkKHtcclxuXHRcdHNpbXVsdGFuZW91czogc2ltdWx0YW5lb3VzLmlkLFxyXG5cdFx0YWN0aW9uOiBcIlNpbXVsdGFuZW91cyBzdGFydC5cIlxyXG5cdH0pO1xyXG5cdHZhciBzaW11bHRhbmVvdXNIaXN0b3J5ID0gW11cclxuXHJcblxyXG5cclxuXHQvL1RPRE86IGlzIGluZm9ybWF0aW9uIG1lY2hhbmljcyBjb3JyZWN0P1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5hbGwoc2ltdWx0YW5lb3VzLnBsYXlhYmxlQXJyYXkubWFwKGZ1bmN0aW9uKHBsYXlhYmxlKSB7XHJcblxyXG5cdFx0dmFyIGJyYW5jaEhpc3RvcnkgPSBoaXN0b3J5LmNoaWxkKCk7XHJcblx0XHRzaW11bHRhbmVvdXNIaXN0b3J5LnB1c2goYnJhbmNoSGlzdG9yeSlcclxuXHJcblx0XHQvLyBJbmZvcm1hdGlvbiBtZWNoYW5pY3NcclxuXHRcdHZhciBpbmZvUG9wdWxhdGlvbiwgcGFyZW50SGlzdG9yeSwgaW5mb0hpc3RvcnkgPSBicmFuY2hIaXN0b3J5O1xyXG5cdFx0Ly9jb21wYXJ0bWVudGFsaXplIGlmIHNldC4gXCJjb21wYXJ0bWVudGFsaXplXCIgbWVhbnMgcGFzcyBvbiBpbmZvcm1hdGlvbiBhcyBpZiB0aGlzIHBsYXlhYmxlIGlzIHRoZSBlbnRpcmUgZ2FtZS5cclxuXHRcdGlmIChzaW11bHRhbmVvdXMuY29tcGFydG1lbnRhbGl6ZSkge1xyXG5cdFx0XHRpbmZvUG9wdWxhdGlvbiA9IHNpbXVsdGFuZW91cy5jb21wYXJ0bWVudGFsaXplLnBvcHVsYXRpb24gfHwgaW5mb3JtYXRpb24ucG9wdWxhdGlvbjtcclxuXHRcdFx0cGFyZW50SGlzdG9yeSA9IHNpbXVsdGFuZW91cy5jb21wYXJ0bWVudGFsaXplLmhpc3RvcnkgfHwgaW5mb3JtYXRpb24uaGlzdG9yeTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGluZm9Qb3B1bGF0aW9uID0gaW5mb3JtYXRpb24ucG9wdWxhdGlvbjtcclxuXHRcdFx0cGFyZW50SGlzdG9yeSA9IGluZm9ybWF0aW9uLmhpc3RvcnlcclxuXHRcdH1cclxuXHRcdHZhciBzaW11bHRhbmVvdXNJbmZvcm1hdGlvbiA9IG5ldyBJbmZvcm1hdGlvbihpbmZvSGlzdG9yeSwgaW5mb1BvcHVsYXRpb24sIHsgcGFyZW50SGlzdG9yeSB9KTtcclxuXHJcblxyXG5cclxuXHRcdHJldHVybiBwbGF5YWJsZS5wbGF5KHsgaGlzdG9yeTogYnJhbmNoSGlzdG9yeSwgaW5mb3JtYXRpb246IHNpbXVsdGFuZW91c0luZm9ybWF0aW9uIH0pO1xyXG5cdH0pKS50aGVuKGZ1bmN0aW9uKHJlc3VsdEFycmF5KSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdE9iamVjdCA9IHtcclxuXHRcdFx0cmVzdWx0QXJyYXksXHJcblx0XHRcdHBsYXlhYmxlOiBzaW11bHRhbmVvdXMsXHJcblx0XHRcdGhpc3RvcnlFbnRyeToge1xyXG5cdFx0XHRcdHNpbXVsdGFuZW91czogc2ltdWx0YW5lb3VzLmlkLFxyXG5cdFx0XHRcdGFjdGlvbjogc2ltdWx0YW5lb3VzSGlzdG9yeS5tYXAoZnVuY3Rpb24oaGlzdG9yeSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGhpc3Rvcnkub3JwaGFuKCk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHRcdHJldHVybiByZXN1bHRPYmplY3Q7XHJcblx0fSk7XHJcbn07XHJcblxyXG5cclxuX1NpbXVsdGFuZW91cy5wcm90b3R5cGUuaGFuZGxlSGlzdG9yeSA9IGZ1bmN0aW9uKHsgaGlzdG9yeSA9IGdhbWVIaXN0b3J5IH0gPSB7fSwgcmVzdWx0KSB7XHJcblxyXG5cdGhpc3RvcnkubG9nLmFkZCh7XHJcblx0XHRzaW11bHRhbmVvdXM6IHRoaXMuaWQsXHJcblx0XHRhY3Rpb246IFwiU2ltdWx0YW5lb3VzIGNvbXBsZXRlLlwiXHJcblx0fSk7XHJcblxyXG5cdGhpc3RvcnkuYWRkTm9Mb2cocmVzdWx0Lmhpc3RvcnlFbnRyeSk7XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxufTtcclxuXHJcbl9TaW11bHRhbmVvdXMucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSwgZW50cmllcykge1xyXG5cdHN1bW1hcnkuYWN0aW9uID0gW107XHJcblxyXG5cdHRoaXMucGxheWFibGVBcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHBsYXlhYmxlLCBpbmRleCkge1xyXG5cdFx0c3VtbWFyeS5hY3Rpb25baW5kZXhdID0ge31cclxuXHRcdHBsYXlhYmxlLnN1bW1hcml6ZShzdW1tYXJ5LmFjdGlvbltpbmRleF0sIGVudHJpZXMpO1xyXG5cdH0pO1xyXG59XHJcblxyXG5cclxuLy9Gcm9udGVuZCBjbGFzc1xyXG5mdW5jdGlvbiBTaW11bHRhbmVvdXMocGxheWFibGVBcnJheSwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHBhcmFtZXRlcnMuaWQsIFwic2ltdWx0YW5lb3VzXCIpXHJcblxyXG5cdHBsYXlhYmxlQXJyYXkgPSBwbGF5YWJsZUFycmF5Lm1hcChmdW5jdGlvbihwbGF5YWJsZSkge1xyXG5cdFx0cmV0dXJuIHJlZ2lzdHJ5LnBsYXlhYmxlc1twbGF5YWJsZS5pZCgpXTtcclxuXHR9KTtcclxuXHJcblxyXG5cdC8vQ3JlYXRlIGJhY2tlbmQgaW5zdGFuY2UuXHJcblx0dmFyIF9zaW11bHRhbmVvdXMgPSBuZXcgX1NpbXVsdGFuZW91cyhpZCwgcGxheWFibGVBcnJheSwgcGFyYW1ldGVycyk7XHJcblxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgc2ltdWx0YW5lb3VzID0gUGxheWFibGUoX3NpbXVsdGFuZW91cyk7XHJcblx0cmV0dXJuIHNpbXVsdGFuZW91cztcclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBfU2ltdWx0YW5lb3VzLCBTaW11bHRhbmVvdXMgfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XHJcbmxvZyhcImRlYnVnXCIsIFwiTG9hZGluZyBDbGFzczogU3RvY2hhc3RpYy1IYWx0XCIpXHJcblxyXG4vL0dhbWUgc3RhdGUgY29udHJvbGxlcnNcclxudmFyIHtyZWdpc3RyeSwgZ2FtZUhpc3Rvcnl9ID0gcmVxdWlyZSgnLi4vc3RhdGUnKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIge2lzRnVuY3Rpb259XHQ9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwiZ2VuZXJhbFwiKTtcclxudmFyIHtpZEhhbmRsZXJ9IFx0PSByZXF1aXJlKCcuLi9oZWxwZXJGdW5jdGlvbnMnKShcInN0YXRlXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHtfUGxheWFibGUsIFBsYXlhYmxlfSBcdD0gcmVxdWlyZSgnLi9wbGF5YWJsZScpO1xyXG52YXIge19IYWx0LCBIYWx0fVx0XHRcdD0gcmVxdWlyZSgnLi9oYWx0LWlmJyk7XHJcblxyXG5cclxuLy9CYWNrZW5kIGZ1bmN0aW9uIGNsYXNzIGZvciBTSGFsdFxyXG5mdW5jdGlvbiBfU0hhbHQoaWQsIHByb2JhYmlsaXR5LCBwYXJhbWV0ZXJzKXtcclxuXHRfSGFsdC5jYWxsKHRoaXMsaWQsbnVsbCxwYXJhbWV0ZXJzKTtcclxuXHRcclxuXHR2YXIgc0hhbHQgPSB0aGlzO1xyXG5cdFxyXG5cdHRoaXMucHJvYmFiaWxpdHkgPSBwcm9iYWJpbGl0eTtcclxuXHR0aGlzLmdlbmVyYXRvciA9IE1hdGgucmFuZG9tO1x0XHRcdFx0Ly9UT0RPOiBhbGxvdyB1c2VyIHRvIHNwZWNpZnkgcmFuZG9tIG51bWJlciBnZW5lcmF0b3JcclxuXHRcclxuXHR0aGlzLnRlc3RDb25kaXRpb24gPSBmdW5jdGlvbigpe1xyXG5cdFx0aWYgKHNIYWx0LmdlbmVyYXRvcigpIDwgc0hhbHQucHJvYmFiaWxpdHkpIHJldHVybiB0cnVlO1xyXG5cdH07XHJcblx0XHJcblx0XHJcblx0cmVnaXN0cnkuc0hhbHRzW2lkXSA9IHRoaXM7XHJcbn1cclxuX1NIYWx0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX0hhbHQucHJvdG90eXBlKTtcclxuX1NIYWx0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9TSGFsdDtcclxuXHJcbl9TSGFsdC5yZWdpc3RyeU5hbWUgPSBcInNIYWx0c1wiO1xyXG5fU0hhbHQuY291bnRlck5hbWUgPSBcInN0b2NoYXN0aWNIYWx0XCI7XHJcblxyXG4vKlxyXG5fU0hhbHQucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7aW5pdGlhbGl6ZVBsYXllcnM9ZmFsc2UsIHNob3J0Q2lyY3VpdD1mYWxzZX09e30pe1xyXG5cdFxyXG5cdHZhciBzSGFsdCA9IHRoaXM7XHJcblx0dmFyIHRlc3QgPSBzSGFsdC50ZXN0Q29uZGl0aW9uKCk7XHJcblx0XHJcblx0aWYgKHRlc3QpIHtcclxuXHRcdGxvZyhcImluZm9cIiwgXCJIYWx0aW5nIGF0IFwiICsgc0hhbHQuaWQpXHJcblx0XHRcclxuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdCh7XHJcblx0XHRcdHJlc3VsdDpcIkhhbHRcIixcclxuXHRcdFx0cGxheWFibGU6c0hhbHRcclxuXHRcdH0pO1xyXG5cdH1cclxuXHRcclxuXHR2YXIgcmVzdWx0T2JqZWN0ID0ge1xyXG5cdFx0J3Jlc3VsdCc6XCJDb250aW51ZWRcIixcclxuXHRcdCdwbGF5YWJsZSc6c0hhbHRcclxuXHR9O1xyXG5cdFxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0T2JqZWN0KVxyXG5cdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XHRcclxuXHRcdFxyXG5cdFx0Ly9UT0RPOiBhZGQgaW5mb3JtYXRpb24gbWVjaGFuaXNtc1xyXG5cdFx0XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdClcdFx0XHJcblx0fSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xyXG5cdFx0XHJcblx0XHRyZXR1cm4gc0hhbHQucHJvY2VlZChyZXN1bHQsIHNob3J0Q2lyY3VpdCk7XHJcblx0fSk7XHJcbn07XHJcbiovXHJcblxyXG5fU0hhbHQucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSwgZW50cmllcyl7XHJcblx0c3VtbWFyeS5wcm9iYWJpbGl0eSA9IHRoaXMucHJvYmFiaWxpdHk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBTdG9jaGFzdGljSGFsdChwcm9iYWJpbGl0eSwge2lkPW51bGwsIGxvZ0NvbnRpbnVlPWZhbHNlfT17fSl7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKGlkLFwic3RvY2hhc3RpY0hhbHRcIilcclxuXHRcclxuXHRpZiAoaXNOYU4ocHJvYmFiaWxpdHkpIHx8IHByb2JhYmlsaXR5IDwgMCB8fCBwcm9iYWJpbGl0eSA+IDEpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcm9iYWJpbGl0eScpO1xyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIHNIYWx0IG9iamVjdHNcclxuXHR2YXIgX3NIYWx0ID0gbmV3IF9TSGFsdChpZCwgcHJvYmFiaWxpdHksIHtsb2dDb250aW51ZX0pO1xyXG5cdFxyXG5cdFxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgc0hhbHQgPSBQbGF5YWJsZShfc0hhbHQpO1x0XHJcblx0cmV0dXJuIHNIYWx0O1x0XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtfU0hhbHQsIFN0b2NoYXN0aWNIYWx0fTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBTdG9jaGFzdGljTG9vcFwiKVxyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5LCBnYW1lSGlzdG9yeSB9ID0gcmVxdWlyZSgnLi4vc3RhdGUnKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwic3RhdGVcIik7XHJcbnZhciB7IGNoYWluZXJHZW5lcmF0b3IgfSA9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwicGxheWFibGVcIik7XHJcblxyXG4vL1BhcmVudCBjbGFzc2VzXHJcbnZhciB7IF9QbGF5YWJsZSwgUGxheWFibGUgfSA9IHJlcXVpcmUoJy4vcGxheWFibGUnKTtcclxudmFyIHsgX0xvb3AsIExvb3AgfSA9IHJlcXVpcmUoJy4vbG9vcCcpO1xyXG5cclxuXHJcbi8vQmFja2VuZCBmdW5jdGlvbiBjbGFzcyBmb3IgU3RvY2hhc3RpY0xvb3BcclxuZnVuY3Rpb24gX1NMb29wKGlkLCBwbGF5YWJsZSwgcHJvYmFiaWxpdHksIHBhcmFtZXRlcnMpIHtcclxuXHRfTG9vcC5jYWxsKHRoaXMsIGlkLCBwbGF5YWJsZSwgbnVsbCwgcGFyYW1ldGVycyk7XHJcblxyXG5cdHRoaXMucGxheWFibGUgPSByZWdpc3RyeS5wbGF5YWJsZXNbcGxheWFibGUuaWQoKV07XHJcblxyXG5cdC8vVGhpcyBpbmhlcml0cyBmcm9tIExvb3Agd2hpY2ggdXNlcyBhIGNvdW50LiBEZWxldGUgdGhhdCBhbmQgcmVwbGFjZSB3aXRoIHByb2JhYmlsaXR5LlxyXG5cdGRlbGV0ZSB0aGlzLmNvdW50O1xyXG5cdHRoaXMucHJvYmFiaWxpdHkgPSBwcm9iYWJpbGl0eTtcclxuXHJcblx0dGhpcy5nZW5lcmF0b3IgPSBNYXRoLnJhbmRvbTsgLy9UT0RPOiBhbGxvdyB1c2VyIHRvIHNwZWNpZnkgcmFuZG9tIG51bWJlciBnZW5lcmF0b3JcclxuXHJcblx0cmVnaXN0cnkuc0xvb3BzW2lkXSA9IHRoaXM7XHJcbn1cclxuX1NMb29wLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX0xvb3AucHJvdG90eXBlKTtcclxuX1NMb29wLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9TTG9vcDtcclxuXHJcbl9TTG9vcC5yZWdpc3RyeU5hbWUgPSBcInNMb29wc1wiO1xyXG5fU0xvb3AuY291bnRlck5hbWUgPSBcInN0b2NoYXN0aWNMb29wXCI7XHJcblxyXG5cclxuX1NMb29wLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oe1xyXG5cdGluaXRpYWxpemVQbGF5ZXJzID0gZmFsc2UsXHJcblx0c2hvcnRDaXJjdWl0ID0gZmFsc2UsXHJcblx0aGlzdG9yeSA9IGdhbWVIaXN0b3J5LFxyXG5cdGluZm9ybWF0aW9uOiBQZXJmZWN0SW5mb3JtYXRpb25cclxufSA9IHt9KSB7XHJcblxyXG5cdHZhciBzTG9vcCA9IHRoaXM7XHJcblx0c0xvb3AuY291bnRlciA9IDA7XHJcblx0dmFyIGxvb3BIaXN0b3J5ID0gaGlzdG9yeS5jaGlsZCgpO1xyXG5cclxuXHRpZiAoc0xvb3AuY29tcGFydG1lbnRhbGl6ZSkge1xyXG5cdFx0aW5mb3JtYXRpb24gPSBuZXcgSW5mb3JtYXRpb24oc0xvb3AuY29tcGFydG1lbnRhbGl6ZS5oaXN0b3J5IHx8IGxvb3BIaXN0b3J5LFxyXG5cdFx0XHRzTG9vcC5jb21wYXJ0bWVudGFsaXplLnBvcHVsYXRpb24gfHwgaW5mb3JtYXRpb24ucG9wdWxhdGlvbik7XHJcblx0fVxyXG5cclxuXHJcblx0dmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoe30pO1xyXG5cclxuXHQvL1NlY3Rpb24gdGhhdCB3aWxsIGJlIGxvb3BlZFxyXG5cdHZhciBhY3Rpb24gPSBmdW5jdGlvbihyZXN1bHQpIHtcclxuXHJcblx0XHRzTG9vcC5jb3VudGVyKys7XHJcblx0XHRpZiAoIXJlc3VsdCkgcmVzdWx0ID0ge307XHJcblxyXG5cclxuXHRcdC8vRGVhbCB3aXRoIGhpc3RvcnlcclxuXHRcdGhpc3RvcnkubG9nLmFkZCh7XHJcblx0XHRcdGxvb3A6IHNMb29wLmlkLFxyXG5cdFx0XHRsb29wVG86IHNMb29wLnBsYXlhYmxlLmlkLFxyXG5cdFx0XHRjb3VudDogc0xvb3AuY291bnRlclxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHNMb29wLnBsYXlhYmxlLnBsYXkoeyBzaG9ydENpcmN1aXQ6IHRydWUsIGhpc3Rvcnk6IGxvb3BIaXN0b3J5LCBpbmZvcm1hdGlvbiB9KVxyXG5cdFx0XHQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHJcblx0XHRcdFx0cmVzdWx0LnBsYXlhYmxlID0gc0xvb3A7XHJcblx0XHRcdFx0Ly9UT0RPOiBhZGQgaW5mb3JtYXRpb24gbWVjaGFuaXNtc1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdClcclxuXHRcdFx0fSk7XHJcblx0fTtcclxuXHJcblxyXG5cdC8vR2VuZXJhdGUgcmFuZG9tIG51bWJlcnMsIHJlcGVhdCB3aGlsZSBudW1iZXIgaXMgYWJvdmUgaGFsdGluZyBwcm9iYWJpbGl0eVxyXG5cdHdoaWxlIChzTG9vcC5nZW5lcmF0b3IoKSA+IHNMb29wLnByb2JhYmlsaXR5KSB7XHJcblx0XHRwcm9taXNlID0gcHJvbWlzZS50aGVuKGFjdGlvbik7XHJcblx0fVxyXG5cclxuXHJcblx0cmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHJcblx0XHRyZXN1bHQuaGlzdG9yeUVudHJ5ID0ge1xyXG5cdFx0XHRsb29wOiBzTG9vcC5pZCxcclxuXHRcdFx0Y291bnQ6IHNMb29wLmNvdW50ZXIsXHJcblx0XHRcdGFjdGlvbjogbG9vcEhpc3Rvcnkub3JwaGFuKClcclxuXHRcdH07XHJcblxyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuX1NMb29wLnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnksIGVudHJpZXMpIHtcclxuXHRzdW1tYXJ5LnByb2JhYmlsaXR5ID0gdGhpcy5wcm9iYWJpbGl0eTtcclxuXHJcblx0c3VtbWFyeS5hY3Rpb24gPSB7fVxyXG5cdHRoaXMucGxheWFibGUuc3VtbWFyaXplKHN1bW1hcnkuYWN0aW9uLCBlbnRyaWVzLCB0cnVlKVxyXG59XHJcblxyXG5cclxuLy9Vc2VyIGludGVyZmFjZVxyXG5mdW5jdGlvbiBTdG9jaGFzdGljTG9vcChwbGF5YWJsZSwgcHJvYmFiaWxpdHkgPSAuNSwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHBhcmFtZXRlcnMuaWQsIFwic3RvY2hhc3RpY0xvb3BcIilcclxuXHJcblx0aWYgKGlzTmFOKHByb2JhYmlsaXR5KSB8fCBwcm9iYWJpbGl0eSA8IDAgfHwgcHJvYmFiaWxpdHkgPiAxKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvYmFiaWxpdHknKTtcclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBzTG9vcCBvYmplY3RcclxuXHR2YXIgX3NMb29wID0gbmV3IF9TTG9vcChpZCwgcGxheWFibGUsIHByb2JhYmlsaXR5LCBwYXJhbWV0ZXJzKTtcclxuXHJcblxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgc0xvb3AgPSBQbGF5YWJsZShfc0xvb3ApO1xyXG5cdHJldHVybiBzTG9vcDtcclxufVxyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX1NMb29wLCBTdG9jaGFzdGljTG9vcCB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgQ2xhc3M6IFR1cm5cIik7XHJcblxyXG4vL0V4dGVybmFsIGRlcGVuZGVuY3lcclxudmFyIHsgU3luY2hyb25vdXNQcm9taXNlIH0gPSByZXF1aXJlKFwic3luY2hyb25vdXMtcHJvbWlzZVwiKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpc09iamVjdCwgb25jZSB9ID0gcmVxdWlyZShcIi4uL2hlbHBlckZ1bmN0aW9uc1wiKShcImdlbmVyYWxcIik7XHJcbnZhciB7IGNoYWluZXJHZW5lcmF0b3IsIG91dGNvbWVUcmVlR2V0VmFsdWUsIG91dGNvbWVUcmVlU2V0VmFsdWUgfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJGdW5jdGlvbnNcIikoXCJwbGF5YWJsZVwiKTtcclxudmFyIHsgcmVjdXJzZSB9ID0gcmVxdWlyZShcIi4uL2hlbHBlckZ1bmN0aW9uc1wiKShcInR1cm5cIik7XHJcbnZhciB7IGlkSGFuZGxlciB9ID0gcmVxdWlyZShcIi4uL2hlbHBlckZ1bmN0aW9uc1wiKShcInN0YXRlXCIpO1xyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKFwiLi4vc3RhdGVcIik7XHJcbnZhciB7IGdhbWVIaXN0b3J5IH0gPSByZXF1aXJlKFwiLi4vaGlzdG9yeVwiKTtcclxudmFyIHsgSW5mb3JtYXRpb24sIFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0gcmVxdWlyZShcIi4uL2luZm9ybWF0aW9uXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9ID0gcmVxdWlyZShcIi4vcGxheWFibGVcIik7XHJcblxyXG4vL0JhY2tlbmQgZnVuY3Rpb24gY2xhc3MgZm9yIFR1cm5cclxuZnVuY3Rpb24gX1R1cm4oaWQsIGNob2ljZXMsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdF9QbGF5YWJsZS5jYWxsKHRoaXMsIGlkKTtcclxuXHJcblx0dGhpcy5wYXlvZmZzSW1wbGljaXQgPSB7fTtcclxuXHR0aGlzLnBheW9mZnNFeHBsaWNpdCA9IHt9O1xyXG5cclxuXHR0aGlzLm5leHQgPSB7fTtcclxuXHJcblx0dGhpcy5jaG9pY2VzID0gY2hvaWNlcy5tYXAoZnVuY3Rpb24oY2hvaWNlKSB7XHJcblx0XHRyZXR1cm4gcmVnaXN0cnkuY2hvaWNlc1tjaG9pY2UuaWQoKV07XHJcblx0fSk7XHJcblxyXG5cdHJlZ2lzdHJ5LnR1cm5zW2lkXSA9IHRoaXM7XHJcblxyXG5cdHZhciB0dXJuID0gdGhpcztcclxuXHJcblx0dGhpcy5jaG9pY2VNYXAgPSB0aGlzLmNob2ljZXMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdHJldHVybiBpdGVtLm9wdGlvbnM7XHJcblx0fSk7XHJcblxyXG5cdHJlY3Vyc2UodHVybi5jaG9pY2VNYXAsIHR1cm4ucGF5b2Zmc0ltcGxpY2l0LCBudWxsLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIEFycmF5KHR1cm4uY2hvaWNlTWFwLmxlbmd0aCkuZmlsbCgwKTtcclxuXHRcdH0pXHJcblx0XHQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0bG9nKFwic2lsbHlcIiwgXCJBZGRlZCBpbXBsaWNpdCBwYXlvZmZzIG1hcCB0byB0dXJuLlwiKTtcclxuXHRcdFx0cmV0dXJuIHJlY3Vyc2UodHVybi5jaG9pY2VNYXAsIHR1cm4ucGF5b2Zmc0V4cGxpY2l0LCB7fSk7XHJcblx0XHR9KVxyXG5cdFx0LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdGxvZyhcInNpbGx5XCIsIFwiQWRkZWQgZXhwbGljaXQgcGF5b2ZmcyBtYXAgdG8gdHVybi5cIik7XHJcblx0XHRcdHJldHVybiByZWN1cnNlKHR1cm4uY2hvaWNlTWFwLCB0dXJuLm5leHQsIG51bGwsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBbXTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KVxyXG5cdFx0LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdGxvZyhcInNpbGx5XCIsIFwiQWRkZWQgYmxhbmsgbmV4dCBtYXAgdG8gdHVybi5cIik7XHJcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHRcdH0pXHJcblx0XHQuY2F0Y2goZnVuY3Rpb24ocmVhc29uKSB7XHJcblx0XHRcdGxvZyhcImVycm9yXCIsIHJlYXNvbik7XHJcblx0XHR9KTsgLy9UT0RPOiBlcnJvciBoYW5kbGluZyBoZXJlXHJcbn1cclxuX1R1cm4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfUGxheWFibGUucHJvdG90eXBlKTtcclxuX1R1cm4ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gX1R1cm47XHJcblxyXG5fVHVybi5yZWdpc3RyeU5hbWUgPSBcInR1cm5zXCI7XHJcbl9UdXJuLmNvdW50ZXJOYW1lID0gXCJ0dXJuXCI7XHJcblxyXG5cclxuX1R1cm4ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7XHJcblx0dXNlUGF5b2ZmcyA9IHRydWUsXHJcblx0aGlzdG9yeSA9IGdhbWVIaXN0b3J5LFxyXG5cdGluZm9ybWF0aW9uID0gUGVyZmVjdEluZm9ybWF0aW9uLFxyXG5cdHJlbGVhc2VQbGF5ZXJzID0gdHJ1ZVxyXG59ID0ge30pIHtcclxuXHJcblx0dmFyIHR1cm4gPSB0aGlzO1xyXG5cdHZhciBjaG9pY2VIaXN0b3J5ID0gaGlzdG9yeS5jaGlsZCgpO1xyXG5cdHZhciBjaG9pY2VJbmZvcm1hdGlvbiA9IGluZm9ybWF0aW9uLmNoaWxkKCk7XHJcblxyXG5cdGlmICh0dXJuLmNvbXBhcnRtZW50YWxpemUpIHtcclxuXHRcdGNob2ljZUluZm9ybWF0aW9uID0gbmV3IEluZm9ybWF0aW9uKHR1cm4uY29tcGFydG1lbnRhbGl6ZS5oaXN0b3J5IHx8IGNob2ljZUhpc3RvcnksXHJcblx0XHRcdHR1cm4uY29tcGFydG1lbnRhbGl6ZS5wb3B1bGF0aW9uIHx8IGluZm9ybWF0aW9uLnBvcHVsYXRpb24pO1xyXG5cdH1cclxuXHJcblx0aGlzdG9yeS5sb2cuYWRkKHtcclxuXHRcdHR1cm46IHR1cm4uaWQsXHJcblx0XHRjaG9pY2VzOiB0dXJuLmNob2ljZXMubWFwKGZ1bmN0aW9uKGNob2ljZSkge1xyXG5cdFx0XHRyZXR1cm4gY2hvaWNlLmlkO1xyXG5cdFx0fSlcclxuXHR9KTtcclxuXHJcblx0dmFyIGNvbXBpbGVJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uKHJpKSB7XHJcblx0XHQvL0lmIHRoZXJlJ3Mgbm8gdHVybiBlbnRyeSwgY3JlYXRlIG9uZS5cclxuXHRcdGlmICghY2hvaWNlSW5mb3JtYXRpb24uYWRkaXRpb25hbFswXS50dXJuKSB7XHJcblx0XHRcdHZhciB0dXJuSW5mbyA9IHtcclxuXHRcdFx0XHR0dXJuOiB7XHJcblx0XHRcdFx0XHRpZDogdHVybi5pZCxcclxuXHRcdFx0XHRcdGNob2ljZXM6IFtdLFxyXG5cdFx0XHRcdFx0ZXhjbHVkZShwbGF5ZXIpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY2hvaWNlcy5maWx0ZXIoZnVuY3Rpb24oY2hvaWNlKSB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNob2ljZS5wbGF5ZXIgPT0gcGxheWVyO1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHRcdGNob2ljZUluZm9ybWF0aW9uLmFkZGl0aW9uYWwudW5zaGlmdCh0dXJuSW5mbyk7XHJcblx0XHR9XHJcblx0XHRjaG9pY2VJbmZvcm1hdGlvbi5hZGRpdGlvbmFsWzBdLnR1cm4uY2hvaWNlcy5wdXNoKFxyXG5cdFx0XHRjaG9pY2VJbmZvcm1hdGlvbi5hZGRpdGlvbmFsLnBvcCgpXHJcblx0XHQpO1xyXG5cclxuXHRcdGluZm9ybWF0aW9uLmFkZGl0aW9uYWwuZm9yRWFjaCggLy8gVE9ETzogd2hhdCBkb2VzIHRoaXMgZG8/Pz9cclxuXHRcdFx0Y2hvaWNlSW5mb3JtYXRpb24uYWRkQWRkaXRpb25hbC5iaW5kKGNob2ljZUluZm9ybWF0aW9uKVxyXG5cdFx0KTtcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5hbGwoXHJcblx0XHRcdHR1cm4uY2hvaWNlcy5tYXAoZnVuY3Rpb24oY2hvaWNlKSB7XHJcblx0XHRcdFx0cmV0dXJuIGNob2ljZS5wbGF5KHtcclxuXHRcdFx0XHRcdHNob3J0Q2lyY3VpdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGhpc3Rvcnk6IGNob2ljZUhpc3RvcnksXHJcblx0XHRcdFx0XHRpbmZvcm1hdGlvbjogY2hvaWNlSW5mb3JtYXRpb24sXHJcblx0XHRcdFx0XHRfY29tcGlsZUluZm9ybWF0aW9uOiBjb21waWxlSW5mb3JtYXRpb24sXHJcblx0XHRcdFx0XHRyZWxlYXNlUGxheWVyczogZmFsc2VcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSlcclxuXHRcdClcclxuXHRcdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHQvL1JlLWZvcm1hdCBvdXRwdXQgZnJvbSBhcnJheSBvZiBDaG9pY2UgcmVzdWx0cyB0byBzaW5nbGUgVHVybiByZXN1bHRcclxuXHRcdFx0Ly9BbmQgcmVsZWFzZSBwbGF5ZXJzXHJcblx0XHRcdHZhciByZXN1bHRQYXRoID0gcmVzdWx0Lm1hcChmdW5jdGlvbihjaG9pY2UsIGluZGV4KSB7XHJcblx0XHRcdFx0aWYgKHJlbGVhc2VQbGF5ZXJzKSB0dXJuLmNob2ljZXNbaW5kZXhdLnJlbGVhc2VQbGF5ZXIoKTtcclxuXHRcdFx0XHRyZXR1cm4gY2hvaWNlLnJlc3VsdDtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvL1Bhc3MgYWxvbmcgcmVzdWx0cyBhbmQgcmVjb3JkIGhpc3RvcnlcclxuXHRcdFx0dmFyIHJlc3VsdE9iamVjdCA9IHtcclxuXHRcdFx0XHRyZXN1bHQ6IHJlc3VsdFBhdGgsXHJcblx0XHRcdFx0cGxheWFibGU6IHR1cm4sXHJcblx0XHRcdFx0aGlzdG9yeUVudHJ5OiB7XHJcblx0XHRcdFx0XHR0dXJuOiB0dXJuLmlkLFxyXG5cdFx0XHRcdFx0cmVzdWx0czogY2hvaWNlSGlzdG9yeS5vcnBoYW4oKSxcclxuXHRcdFx0XHRcdHBheW91dHM6IHt9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRPYmplY3QpO1xyXG5cdFx0fSlcclxuXHRcdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHQvL0ltcGxlbWVudCBwYXlvZmZzXHJcblx0XHRcdGlmICh1c2VQYXlvZmZzKSB7XHJcblx0XHRcdFx0dmFyIGltcGxpY2l0UGF5b2ZmcyA9IG91dGNvbWVUcmVlR2V0VmFsdWUoXHJcblx0XHRcdFx0XHR0dXJuLnBheW9mZnNJbXBsaWNpdCxcclxuXHRcdFx0XHRcdHJlc3VsdC5yZXN1bHRcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHRcdHZhciBleHBsaWNpdFBheW9mZnMgPSBvdXRjb21lVHJlZUdldFZhbHVlKFxyXG5cdFx0XHRcdFx0dHVybi5wYXlvZmZzRXhwbGljaXQsXHJcblx0XHRcdFx0XHRyZXN1bHQucmVzdWx0XHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0Ly8gRm9yIHRoZSBsb2dcclxuXHRcdFx0XHR2YXIgcGF5b3V0cyA9IHt9O1xyXG5cclxuXHRcdFx0XHRpbXBsaWNpdFBheW9mZnMuZm9yRWFjaChmdW5jdGlvbihwYXlvZmYsIGluZGV4KSB7XHJcblx0XHRcdFx0XHQvLyBEbyBub3RoaW5nIGlmIHBheW9mZiBpcyB6ZXJvLlxyXG5cdFx0XHRcdFx0aWYgKHBheW9mZiA9PSAwKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdFx0Ly8gZmV0Y2ggcGxheWVyIGFuZCBpbmNyZW1lbnQgc2NvcmVcclxuXHRcdFx0XHRcdHZhciBwbGF5ZXIgPSB0dXJuLmNob2ljZXNbaW5kZXhdLnBsYXllcjtcclxuXHRcdFx0XHRcdHBsYXllci5zY29yZSArPSBwYXlvZmY7XHJcblxyXG5cdFx0XHRcdFx0Ly9BbmQgaW5jbHVkZSBpdCBpbiB0aGUgbG9nIGVudHJ5XHJcblx0XHRcdFx0XHRwYXlvdXRzW3BsYXllci5pZF0gPSBOdW1iZXIocGF5b2ZmKTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0Zm9yICh2YXIgcGxheWVyIGluIGV4cGxpY2l0UGF5b2Zmcykge1xyXG5cdFx0XHRcdFx0cmVnaXN0cnkucGxheWVyc1twbGF5ZXJdLnNjb3JlICs9IGV4cGxpY2l0UGF5b2Zmc1twbGF5ZXJdO1xyXG5cclxuXHRcdFx0XHRcdC8vQW5kIGluY2x1ZGUgaXQgaW4gdGhlIGxvZyBlbnRyeVxyXG5cdFx0XHRcdFx0cGF5b3V0c1twbGF5ZXJdID0gTnVtYmVyKGV4cGxpY2l0UGF5b2Zmc1twbGF5ZXJdKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vTG9nIGZvciB0aGUgc2NvcmVzIGxvZ1xyXG5cdFx0XHRcdHZhciBzY29yZUVudHJ5ID0ge1xyXG5cdFx0XHRcdFx0dHVybjogdHVybi5pZCxcclxuXHRcdFx0XHRcdHJlc3VsdDogcmVzdWx0LnJlc3VsdCxcclxuXHRcdFx0XHRcdHBheW91dHM6IHBheW91dHNcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdGhpc3RvcnkuYWRkU2NvcmVzKHNjb3JlRW50cnkpO1xyXG5cclxuXHJcblx0XHRcdFx0Ly8gTG9nIGZvciB0aGUgZ2FtZSBoaXN0b3J5XHJcblx0XHRcdFx0cmVzdWx0Lmhpc3RvcnlFbnRyeS5wYXlvdXRzID0gcGF5b3V0cztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpOyAvL1RPRE86IGFkZCBpbmZvcm1hdGlvbiBtZWNoYW5pc21zXHJcblx0XHR9KTtcclxufTtcclxuXHJcbi8vT3ZlcndyaXRlIGRlZmF1bHQgaGlzdG9yeSBoYW5kbGVyLCBiZWNhdXNlIHdlIGRvbid0IHdhbnQgYSBzZWNvbmQgZW50cnkgaW4gdGhlIHRyZWVcclxuX1R1cm4ucHJvdG90eXBlLmhhbmRsZUhpc3RvcnkgPSBmdW5jdGlvbih7IGhpc3RvcnkgPSBnYW1lSGlzdG9yeSB9ID0ge30sXHJcblx0cmVzdWx0XHJcbikge1xyXG5cdGhpc3RvcnkuYWRkTm9Mb2cocmVzdWx0Lmhpc3RvcnlFbnRyeSk7XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxufTtcclxuXHJcbl9UdXJuLnByb3RvdHlwZS5maW5kTmV4dCA9IGZ1bmN0aW9uKHsgcmVzdWx0IH0gPSB7fSkge1xyXG5cdHJldHVybiBvdXRjb21lVHJlZUdldFZhbHVlKHRoaXMubmV4dCwgcmVzdWx0LnJlc3VsdCk7XHJcbn07XHJcblxyXG5fVHVybi5wcm90b3R5cGUuZ2VuZXJhdGVDaGFpbmluZ0Z1bmN0aW9ucyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBfdHVybiA9IHRoaXM7XHJcblx0dmFyIHR1cm4gPSBfdHVybi5pbnRlcmZhY2U7XHJcblxyXG5cdC8vQ3JlYXRlIHBheW9mZiBzZXR0ZXIvYnJhbmNoIHJvdXRlciBmdW5jdGlvbnMuXHJcblx0Ly9yZWN1cnNlIGFkZHMgYSB3cmFwcGVyIGFyb3VuZCB0aGlzIGZ1bmN0aW9uIHdoaWNoIHN1cHBsaWVzIHRoZSBwYXRoLlxyXG5cdHJlY3Vyc2UoX3R1cm4uY2hvaWNlTWFwLCB0dXJuLCBmdW5jdGlvbihwYXRoLCBwYXlvZmZzKSB7XHJcblx0XHQvL0lmIHVzZXIgc3VwcGxpZWQgcGF5b2ZmcyBpbiBhcnJheSBmb3JtLCB0aGVuIHRyYW5zbGF0ZSB0byBvYmplY3QgYmFzZWQgb24gd2hpY2ggcGxheWVycyBhcmUgaW52b2x2ZWQgaW4gdGhlIGNob2ljZXNcclxuXHRcdGlmIChBcnJheS5pc0FycmF5KHBheW9mZnMpKSB7XHJcblx0XHRcdGlmIChwYXlvZmZzLmxlbmd0aCAhPT0gX3R1cm4uY2hvaWNlcy5sZW5ndGgpIHtcclxuXHRcdFx0XHQvL0lmIGFycmF5IGlzbid0IHJpZ2h0IGxlbmd0aCwgdGhlbiB0aGlzIGlzIHVuaW50ZWxsaWdpYmxlLlxyXG5cdFx0XHRcdGxvZyhcclxuXHRcdFx0XHRcdFwiZXJyb3JcIixcclxuXHRcdFx0XHRcdFwiUGF5b2ZmIGFycmF5IGRvZXMgbm90IG1hdGNoIFR1cm4gZGltZW5zaW9ucywgY2Fubm90IGFzc2lnbiBwYXlvZmZzLlwiXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiUGF5b2ZmIGFycmF5IGlzIG5vdCBjb3JyZWN0IGxlbmd0aFwiKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBvcmlnaW5hbFBheW9mZnMgPSBwYXlvZmZzLnNsaWNlKCk7XHJcblx0XHRcdHBheW9mZnMgPSB7fTtcclxuXHJcblx0XHRcdG91dGNvbWVUcmVlU2V0VmFsdWUoX3R1cm4ucGF5b2Zmc0ltcGxpY2l0LCBwYXRoLCBvcmlnaW5hbFBheW9mZnMpO1xyXG5cdFx0fSBlbHNlIGlmIChpc09iamVjdChwYXlvZmZzKSkge1xyXG5cdFx0XHRwYXlvZmZzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwYXlvZmZzKSk7XHJcblx0XHRcdG91dGNvbWVUcmVlU2V0VmFsdWUoX3R1cm4ucGF5b2Zmc0V4cGxpY2l0LCBwYXRoLCBwYXlvZmZzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoe1xyXG5cdFx0XHRwbGF5YWJsZTogdHVybixcclxuXHRcdFx0cGF0aDogcGF0aFxyXG5cdFx0fSk7XHJcblx0fSk7XHJcbn07XHJcblxyXG5fVHVybi5wcm90b3R5cGUuc2V0QWxsUGF5b2ZmcyA9IGZ1bmN0aW9uKHBheW9mZkFycmF5KSB7XHJcblx0dmFyIHR1cm4gPSB0aGlzO1xyXG5cclxuXHQvL1JlY3Vyc2UgdGhyb3VnaCB0aGUgb3B0aW9ucyBpbiBpbnB1dCwgdG8gY29tZSB1cCB3aXRoIGEgcGF0aCB0byBldmVyeSBjb21iaW5hdGlvbiBvZiBvcHRpb25zIGluIHRoZSBhcnJheSBvZiBhcnJheXMuXHJcblx0ZnVuY3Rpb24gcmVjdXJzZShpbnB1dCwgbnVtUGxheWVycywgcGF5b2ZmcywgcGF0aCA9IFtdLCBjb29yZGluYXRlcyA9IFtdKSB7XHJcblx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUocGF0aCkudGhlbihmdW5jdGlvbihwYXRoKSB7XHJcblx0XHRcdC8vU2luY2Ugd2Ugc2xpY2UgdGhlIGFycmF5IGVhY2ggdGltZSwgaWYgdGhlcmUgYXJlIG5vIG1vcmUgZW50cmllcyBsZWZ0IHRoZW4gd2UncmUgZG9uZSB3aXRoIHRoaXMgYnJhbmNoLlxyXG5cdFx0XHRpZiAoaW5wdXQubGVuZ3RoID09IDApIHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZShwYXRoKTtcclxuXHJcblx0XHRcdC8vQW1vbmcgYWxsIHZhbHVlcyBmcm9tIHRoZSBhcnJheVxyXG5cdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLmFsbChcclxuXHRcdFx0XHRpbnB1dFswXS5tYXAoZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcclxuXHRcdFx0XHRcdHZhciBzcGxpdFBhdGggPSBwYXRoLnNsaWNlKDApLmNvbmNhdChpdGVtKTtcclxuXHRcdFx0XHRcdHZhciBzcGxpdENvb3JkaW5hdGVzID0gY29vcmRpbmF0ZXMuc2xpY2UoMCkuY29uY2F0KGluZGV4KTtcclxuXHRcdFx0XHRcdHZhciBzcGxpdFBheW9mZnMgPSBwYXlvZmZzW2luZGV4XTtcclxuXHJcblx0XHRcdFx0XHQvL0lmIHdlJ3JlIGF0IHRoZSBsYXN0IHBvc2l0aW9uIGluIHRoZSBhcnJheSBvZiBvcHRpb25zLCB0aGVuIHdlIGhhdmUgYSBjb21wbGV0ZSBwYXRoLlxyXG5cdFx0XHRcdFx0aWYgKGlucHV0Lmxlbmd0aCA9PSAxKSB7XHJcblx0XHRcdFx0XHRcdC8qIHlvdSBtaWdodCBuZWVkIHRoZXNlIGxhdGVyXHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcInBhdGggXCIsIHNwbGl0UGF0aCk7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcImNvb3JkaW5hdGVzIFwiLCBzcGxpdENvb3JkaW5hdGVzKVxyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJwYXlvZmYgXCIsc3BsaXRQYXlvZmZzKVxyXG5cdFx0XHRcdFx0Ki9cclxuXHJcblx0XHRcdFx0XHRcdHNwbGl0UGF5b2ZmcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc3BsaXRQYXlvZmZzKSk7XHJcblxyXG5cdFx0XHRcdFx0XHQvL0FsbG93IHRoZSBmaXJzdCBmZXcgYXJyYXkgZWxlbWVudHMgdG8gYmUgaW1wbGljaXQgcGF5b2Zmcy4gQ2hlY2sgdGhhdCB0aGV5IGFyZSBhY3R1YWxseSB0aGVyZSBhbmQgYXJlIG51bWJlcnNcclxuXHRcdFx0XHRcdFx0dmFyIGltcGxpY2l0ID0gc3BsaXRQYXlvZmZzLnNsaWNlKDAsIG51bVBsYXllcnMpO1xyXG5cdFx0XHRcdFx0XHRpZiAoXHJcblx0XHRcdFx0XHRcdFx0aW1wbGljaXQubGVuZ3RoID09IG51bVBsYXllcnMgJiZcclxuXHRcdFx0XHRcdFx0XHRpbXBsaWNpdC5ldmVyeShmdW5jdGlvbihwYXlvZmYpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAhaXNOYU4ocGF5b2ZmKTtcclxuXHRcdFx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdFx0XHQpIHtcclxuXHRcdFx0XHRcdFx0XHRvdXRjb21lVHJlZVNldFZhbHVlKHR1cm4ucGF5b2Zmc0ltcGxpY2l0LCBzcGxpdFBhdGgsIGltcGxpY2l0KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Ly9BbnkgcmVtYWluaW5nIHNob3VsZCBiZSBhc3NpZ25lZCBhcyBleHBsaWNpdCBwYXlvZmZzLCBpZiB0aGV5J3JlIG9iamVjdHMuXHJcblx0XHRcdFx0XHRcdHNwbGl0UGF5b2Zmcy5zbGljZShudW1QbGF5ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKGV4cGxpY2l0KSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGlzT2JqZWN0KGV4cGxpY2l0KSlcclxuXHRcdFx0XHRcdFx0XHRcdG91dGNvbWVUcmVlU2V0VmFsdWUodHVybi5wYXlvZmZzRXhwbGljaXQsIHNwbGl0UGF0aCwgZXhwbGljaXQpO1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvL0lmIHRoZXJlIGFyZSBtb3JlIGl0ZW1zIHRvIGl0ZXJhdGUgb3ZlciwgaW5jbHVkZSB0aGVtIGluIHRoZSBvdXRwdXQgdGhlbiByZWN1cnNlLlxyXG5cdFx0XHRcdFx0cmV0dXJuIHJlY3Vyc2UoXHJcblx0XHRcdFx0XHRcdGlucHV0LnNsaWNlKDEpLFxyXG5cdFx0XHRcdFx0XHRudW1QbGF5ZXJzLFxyXG5cdFx0XHRcdFx0XHRzcGxpdFBheW9mZnMsXHJcblx0XHRcdFx0XHRcdHNwbGl0UGF0aCxcclxuXHRcdFx0XHRcdFx0c3BsaXRDb29yZGluYXRlc1xyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHQpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVjdXJzZSh0dXJuLmNob2ljZU1hcCwgdHVybi5jaG9pY2VzLmxlbmd0aCwgcGF5b2ZmQXJyYXkpLmNhdGNoKFxyXG5cdFx0ZnVuY3Rpb24ocmVhc29uKSB7XHJcblx0XHRcdGxvZyhcImVycm9yXCIsIHJlYXNvbik7XHJcblx0XHR9XHJcblx0KTtcclxufTtcclxuXHJcbi8vIEFkZGluZyBtb3JlIGNvbXBsaWNhdGVkIHN1bW1hcnkgZW50cnlcclxuX1R1cm4ucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSwgZW50cmllcywgc2hvcnRDaXJjdWl0ID0gZmFsc2UpIHtcclxuXHQvLyBGZXRjaCBzdW1tYXJpZXMgZm9yIGVhY2ggY2hvaWNlLlxyXG5cdHN1bW1hcnkuY2hvaWNlcyA9IFtdO1xyXG5cdHRoaXMuY2hvaWNlcy5mb3JFYWNoKGZ1bmN0aW9uKGNob2ljZSwgaW5kZXgpIHtcclxuXHRcdHN1bW1hcnkuY2hvaWNlc1tpbmRleF0gPSBjaG9pY2Uuc3VtbWFyaXplKFxyXG5cdFx0XHRzdW1tYXJ5LmNob2ljZXNbaW5kZXhdLFxyXG5cdFx0XHRlbnRyaWVzLFxyXG5cdFx0XHR0cnVlXHJcblx0XHQpO1xyXG5cdH0pO1xyXG5cclxuXHQvLyBJbmNsdWRlIHBheW9mZnNcclxuXHRzdW1tYXJ5LnBheW9mZnMgPSBKU09OLnBhcnNlKFxyXG5cdFx0SlNPTi5zdHJpbmdpZnkoe1xyXG5cdFx0XHRpbXBsaWNpdDogdGhpcy5wYXlvZmZzSW1wbGljaXQsXHJcblx0XHRcdGV4cGxpY2l0OiB0aGlzLnBheW9mZnNFeHBsaWNpdFxyXG5cdFx0fSlcclxuXHQpO1xyXG5cclxuXHRyZXR1cm4gc3VtbWFyeTtcclxufTtcclxuXHJcbi8vXHJcbl9UdXJuLnByb3RvdHlwZS5zdW1tYXJ5TmV4dCA9IGZ1bmN0aW9uKHN1bW1hcnksIGVudHJpZXMpIHtcclxuXHR2YXIgdHVybiA9IHRoaXM7XHJcblxyXG5cdC8vIENyZWF0ZSBtYXBcclxuXHRzdW1tYXJ5Lm5leHQgPSB7fTtcclxuXHR2YXIgY291bnQgPSAwO1xyXG5cdHJlY3Vyc2UodGhpcy5jaG9pY2VNYXAsIHN1bW1hcnkubmV4dCwgbnVsbCwgZnVuY3Rpb24ocGF0aCkge1xyXG5cdFx0cmV0dXJuIG91dGNvbWVUcmVlR2V0VmFsdWUodHVybi5uZXh0LCBwYXRoKS5tYXAoZnVuY3Rpb24ocGxheWFibGUpIHtcclxuXHRcdFx0Kytjb3VudDtcclxuXHRcdFx0cmV0dXJuIHBsYXlhYmxlLnN1bW1hcml6ZSgpO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblxyXG5cdC8vIElmIHRoZXJlIGlzIG5vIG5leHQsIGRlbGV0ZSB0aGUga2V5LlxyXG5cdGlmIChjb3VudCA9PSAwKSBkZWxldGUgc3VtbWFyeS5uZXh0O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gVHVybihjaG9pY2VzLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHR2YXIgaWQgPSBpZEhhbmRsZXIocGFyYW1ldGVycy5pZCwgXCJ0dXJuXCIpO1xyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIGNob2ljZSBvYmplY3RcclxuXHR2YXIgX3R1cm4gPSBuZXcgX1R1cm4oaWQsIGNob2ljZXMsIHBhcmFtZXRlcnMpO1xyXG5cclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIHR1cm4gPSBQbGF5YWJsZShfdHVybik7XHJcblxyXG5cdF90dXJuLmdlbmVyYXRlQ2hhaW5pbmdGdW5jdGlvbnMoKTtcclxuXHJcblx0Ly9GdW5jdGlvbiB0byBzZXQgYWxsIHBheW9mZnMgYXQgb25jZVxyXG5cdHR1cm4uc2V0QWxsUGF5b2ZmcyA9IGZ1bmN0aW9uKHBheW9mZnMpIHtcclxuXHRcdC8vVE9ETzogSW5jbHVkZSBlcnJvciBoYW5kbGluZyBpZiBhcnJheSBnaXZlbiBpc24ndCBleHBlY3RlZCBkaW1lbnNpb25zLlxyXG5cdFx0X3R1cm4uc2V0QWxsUGF5b2ZmcyhwYXlvZmZzKTtcclxuXHR9O1xyXG5cclxuXHQvL1dheSBmb3IgdXNlciB0byBpbnRlcmFjdCB3aXRoIHBheW9mZnNcclxuXHR0dXJuLnBheW9mZnMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBKU09OLnBhcnNlKFxyXG5cdFx0XHRKU09OLnN0cmluZ2lmeSh7XHJcblx0XHRcdFx0aW1wbGljaXQ6IF90dXJuLnBheW9mZnNJbXBsaWNpdCxcclxuXHRcdFx0XHRleHBsaWNpdDogX3R1cm4ucGF5b2Zmc0V4cGxpY2l0XHJcblx0XHRcdH0pXHJcblx0XHQpO1xyXG5cdH07XHJcblxyXG5cdC8vIFJldHVybnMgdGhlIHBheW9mZnMgaW4gbmVzdGVkIGFycmF5IGZvcm0sIHRvIG1ha2UgY2xvbmluZyBlYXNpZXIsIGllLiB0Mi5zZXRBbGxQYXlvZmZzKHQxLnBheW9mZnNNYXRyaXgoKSlcclxuXHR0dXJuLnBheW9mZnNNYXRyaXggPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHQvLyByZWN1cnNpb24gdG8gY29uc3RydWN0IHBheW9mZiBtYXRyaXhcclxuXHRcdHZhciBtYXBwZXIgPSBmdW5jdGlvbihvYmosIHBhdGggPSBbXSkge1xyXG5cdFx0XHQvL0lmIGl0J3MgYW4gYXJyYXksIHRoZW4gd2UndmUgcmVhY2hlZCB0aGUgcGF5b2Zmc1xyXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcblx0XHRcdFx0dmFyIHBheW9mZiA9IG9iai5zbGljZSgwKVxyXG5cdFx0XHRcdC8vIEFkZCBleHBsaWNpdCBwYXlvZmZzIHRvb1xyXG5cdFx0XHRcdHZhciBleHBsaWNpdCA9IG91dGNvbWVUcmVlR2V0VmFsdWUoX3R1cm4ucGF5b2Zmc0V4cGxpY2l0LCBwYXRoKTtcclxuXHJcblx0XHRcdFx0Ly8gT25seSBhZGQgYW4gZW50cnkgaWYgdGhlIGV4cGxpY2l0IHBheW9mZnMgb2JqZWN0IGlzIG5vdCBlbXB0eVxyXG5cdFx0XHRcdHJldHVybiBPYmplY3Qua2V5cyhleHBsaWNpdCkubGVuZ3RoID4gMCA/IHBheW9mZi5jb25jYXQoW291dGNvbWVUcmVlR2V0VmFsdWUoX3R1cm4ucGF5b2Zmc0V4cGxpY2l0LFxyXG5cdFx0XHRcdFx0cGF0aCldKSA6IHBheW9mZlxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBPdGhlcndpc2UsIGRpZyBpbiBkZWVwZXJcclxuXHRcdFx0ZWxzZSByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24oa2V5KSB7IHJldHVybiBtYXBwZXIob2JqW2tleV0sIHBhdGguc2xpY2UoMCkuY29uY2F0KFtrZXldKSkgfSlcclxuXHRcdH1cclxuXHRcdHJldHVybiBtYXBwZXIoX3R1cm4ucGF5b2Zmc0ltcGxpY2l0KVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHR1cm47XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBfVHVybiwgVHVybiB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKCcuL3N0YXRlJyk7XHJcblxyXG4vL0hlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgaWRIYW5kbGVyIH0gPSByZXF1aXJlKCcuL2hlbHBlckZ1bmN0aW9ucycpKFwic3RhdGVcIik7XHJcbnZhciB7IGNoYWluZXJHZW5lcmF0b3IgfSA9IHJlcXVpcmUoJy4vaGVscGVyRnVuY3Rpb25zJykoXCJwbGF5YWJsZVwiKTtcclxuXHJcbnZhciB7IFVzZXJIaXN0b3J5IH0gPSByZXF1aXJlKCcuL2hpc3RvcnknKTtcclxuXHJcbi8vIFBsdWdpbnNcclxudmFyIFBsdWdpbk1hbmFnZXIgPSByZXF1aXJlKFwiLi9wbHVnaW4tbWFuYWdlclwiKVxyXG5cclxuLy9CYWNrZW5kIGZvciBQbGF5ZXJcclxuZnVuY3Rpb24gX1BsYXllcihpZCwgeyBuYW1lID0gXCJcIiwgYXNzaWduID0gbnVsbCB9ID0ge30pIHtcclxuXHRsb2coJ3NpbGx5JywgJ0NyZWF0aW5nIGludGVyYWwgcGxheWVyIG9iamVjdC4nKTtcclxuXHJcblx0dGhpcy5pZCA9IGlkXHJcblx0dGhpcy5zY29yZSA9IDBcclxuXHR0aGlzLm5hbWUgPSBuYW1lO1xyXG5cclxuXHR0aGlzLmhpc3RvcnkgPSBbXTtcclxuXHJcblx0aWYgKGFzc2lnbikgdGhpcy5hc3NpZ24oYXNzaWduKTtcclxuXHJcblx0dGhpcy5hbGl2ZSA9IHRydWU7XHJcblx0dGhpcy5hdmFpbGFibGUgPSB0cnVlO1xyXG5cclxuXHRyZWdpc3RyeS5wbGF5ZXJzW2lkXSA9IHRoaXM7XHJcbn1cclxuXHJcblxyXG4vL01ha2UgYSBjb3B5IG9mIHRoZSBwbGF5ZXIsIGluIG9yZGVyIHRvIHRha2UgYSBzbmFwc2hvdC4gLy8vL1RPRE8gdHJ5IHRoaXMgYWdhaW4gc29tZXRpbWUuXHJcbi8qXHJcbl9QbGF5ZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKXtcclxuXHQvL01ha2UgbmV3IGNvcHkuIERvbid0IGtlZXAgbW9yZSB0aGFuIG9uZS5cclxuXHRkZWxldGUgdGhpcy5jb3B5XHJcblxyXG5cdHZhciBjbG9uZSA9IG5ldyBfUGxheWVyKHRoaXMuaWQpO1xyXG5cclxuXHQvL0xvb3AgdGhyb3VnaCBwcm9wZXJ0aWVzIGFuZCBhc3NpZ24gdGhlbS5cclxuXHRmb3IgKHZhciBrZXkgaW4gdGhpcyl7XHJcblx0XHRjbG9uZVtrZXldID0gdGhpc1trZXldO1xyXG5cdH1cclxuXHQvL0RvIG5vdCBhZGQgdG8gcmVnaXN0cnkuIFRoaXMgd2lsbCBrZWVwIGR1cGxpY2F0ZXMgb3V0IG9mIHBvcHVsYXRpb24uXHJcblxyXG5cdC8vRG8gYWRkIHJlZmVyZW5jZSBzbyB3ZSBjYW4gZmluZCBpdCBhZ2Fpbi5cclxuXHR0aGlzLmNvcHkgPSBjbG9uZTtcclxuXHJcblx0cmV0dXJuIGNsb25lO1xyXG59O1xyXG4qL1xyXG5cclxuXHJcbi8vQXNzaWduIHN0cmF0ZWd5IHRvIHBsYXllclxyXG5fUGxheWVyLnByb3RvdHlwZS5hc3NpZ24gPSBmdW5jdGlvbihzdHJhdGVneSwgLi4uYXJncykge1xyXG5cclxuXHQvL1RPRE86IHZlcmlmeSBzdHJhdGVneSB0eXBlXHJcblx0aWYgKHJlZ2lzdHJ5LnN0cmF0ZWdpZXNbc3RyYXRlZ3ldKSB7XHJcblx0XHR0aGlzLnN0cmF0ZWd5ID0gbmV3IHJlZ2lzdHJ5LnN0cmF0ZWdpZXNbc3RyYXRlZ3ldKC4uLmFyZ3MpO1xyXG5cdFx0dGhpcy5zdHJhdGVneS5faWQgPSBzdHJhdGVneVxyXG5cdFx0dGhpcy5zdHJhdGVneS5fYXJncyA9IGFyZ3NcclxuXHR9IGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiU3RyYXRlZ3kgJ1wiICsgc3RyYXRlZ3kgKyBcIicgaXMgbm90IGRlZmluZWRcIik7XHJcbn07XHJcblxyXG5cclxuLy9DYWxsIHN0cmF0ZWd5IHRvIG1ha2UgYSBjaG9pY2VcclxuX1BsYXllci5wcm90b3R5cGUuY2hvb3NlID0gZnVuY3Rpb24ob3B0aW9ucywgaW5mb3JtYXRpb24gPSB7fSkgeyAvL1RPRE86IGNoZWNrIHRoYXQgdGhlcmUncyBhIHN0cmF0ZWd5IGFzc2lnbmVkIGJlZm9yZSB0cnlpbmcgdG8gcGxheVxyXG5cdHZhciBwbGF5ZXIgPSB0aGlzO1xyXG5cdGlmIChwbGF5ZXIuc3RyYXRlZ3kpIHtcclxuXHRcdGxldCByZXN1bHQgPSBwbGF5ZXIuc3RyYXRlZ3kuY2hvb3NlKG9wdGlvbnMsIGluZm9ybWF0aW9uKVxyXG5cdFx0aWYgKHJlc3VsdCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQudG9TdHJpbmcoKSk7XHJcblx0XHQvLyBJZiBubyByZXNwb25zZSwgZ2l2ZSB3YXJuaW5nXHJcblx0XHRlbHNlIGxvZyhcIndhcm5pbmdcIiwgXCJObyByZXNwb25zZSBmcm9tIHBsYXllciBcIiArIHBsYXllci5pZCArIFwiLiBVc2luZyBkZWZhdWx0IG9wdGlvbi5cIilcclxuXHR9XHJcblx0Ly8gSWYgbm8gc3RyYXRlZ3ksIGdpdmUgd2FybmluZ1xyXG5cdGVsc2VcclxuXHRcdGxvZyhcIndhcm5pbmdcIiwgXCJObyBzdHJhdGVneSBhc3NpZ25lZCB0byBwbGF5ZXIgXCIgKyBwbGF5ZXIuaWQgKyBcIi4gVXNpbmcgZGVmYXVsdCBvcHRpb24uXCIpO1xyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbn07XHJcblxyXG5cclxuLy9UYWtlcyBhIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoKSkgY29weSBvZiBfcGxheWVyLiBSZXR1cm5zIGEgY2xlYW5lZCB1cCB2ZXJzaW9uXHJcbl9QbGF5ZXIucHJvdG90eXBlLmluZm9DbGVhbiA9IGZ1bmN0aW9uKGluZm9PYmplY3QpIHtcclxuXHRkZWxldGUgaW5mb09iamVjdC5pbnRlcmZhY2U7XHJcblx0aW5mb09iamVjdC5zdHJhdGVneSA9IGluZm9PYmplY3Quc3RyYXRlZ3kgPyBpbmZvT2JqZWN0LnN0cmF0ZWd5Ll9pZCA6IG51bGw7XHJcblxyXG5cdHJldHVybiBpbmZvT2JqZWN0O1xyXG59O1xyXG5cclxuXHJcbi8vS2lsbCBwbGF5ZXIuIFRPRE86IGFkZCBwbGF5ZXIgdG8gc29tZSBzb3J0IG9mIFwiZGVhZFwiIGxpc3QgdG8gYXZvaWQgYmVpbmcgcGlja2VkIHRvIGRvIHRoaW5ncy5cclxuX1BsYXllci5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuYWxpdmUgPSBmYWxzZTtcclxufTtcclxuXHJcblxyXG5cclxuLy9DbGFzcyB0aGF0IGlzIHRoZSByZWZlcmVuY2UgZm9yIHRoZSB1c2VyIHRvIGhvbGQgb250b1xyXG5mdW5jdGlvbiBwbGF5ZXIoKSB7fVxyXG5cclxuXHJcbi8vRnJvbnRlbmQgZm9yIFBsYXllclxyXG5mdW5jdGlvbiBQbGF5ZXIocGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHBhcmFtZXRlcnMuaWQsIFwicGxheWVyXCIpO1xyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIHBsYXllciBvYmplY3RcclxuXHR2YXIgX3BsYXllciA9IG5ldyBfUGxheWVyKGlkLCBwYXJhbWV0ZXJzKTtcclxuXHJcblxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlclxyXG5cdHZhciBwbGF5ZXJJbnRlcmZhY2UgPSBuZXcgcGxheWVyKCk7IC8vUHJvYmFibHkgYWRkIGZ1bmN0aW9uYWxpdHkgaGVyZVxyXG5cclxuXHQvL1RhZy1iYWNrLiBTdG9yZSB0aGUgZnJvbnQtZW5kIG9iamVjdCBpbiB0aGUgYmFjay1lbmQgb2JqZWN0LCBmb3IgcmV0cmlldmFsXHJcblx0X3BsYXllci5pbnRlcmZhY2UgPSBwbGF5ZXJJbnRlcmZhY2U7XHJcblxyXG5cdHBsYXllckludGVyZmFjZS5hbGl2ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHJlZ2lzdHJ5LnBsYXllcnNbaWRdLmFsaXZlO1xyXG5cdH1cclxuXHJcblx0cGxheWVySW50ZXJmYWNlLmFzc2lnbiA9IGZ1bmN0aW9uKHN0cmF0ZWd5LCAuLi5hcmdzKSB7XHJcblx0XHRyZWdpc3RyeS5wbGF5ZXJzW2lkXS5hc3NpZ24oc3RyYXRlZ3ksIC4uLmFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdHBsYXllckludGVyZmFjZS5hdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiByZWdpc3RyeS5wbGF5ZXJzW2lkXS5hdmFpbGFibGVcclxuXHR9O1xyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2UuYnVzeSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmVnaXN0cnkucGxheWVyc1tpZF0uYXZhaWxhYmxlID0gZmFsc2U7XHJcblx0fTtcclxuXHJcblx0cGxheWVySW50ZXJmYWNlLmhpc3RvcnkgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBuZXcgVXNlckhpc3RvcnkocmVnaXN0cnkucGxheWVyc1tpZF0uaGlzdG9yeSk7XHJcblx0fTtcclxuXHJcblx0cGxheWVySW50ZXJmYWNlLmlkID0gZnVuY3Rpb24oKSB7IHJldHVybiBpZDsgfTtcclxuXHJcblx0cGxheWVySW50ZXJmYWNlLmtpbGwgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJlZ2lzdHJ5LnBsYXllcnNbaWRdLmtpbGwoKTtcclxuXHR9XHJcblxyXG5cdHBsYXllckludGVyZmFjZS5yZWxlYXNlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZWdpc3RyeS5wbGF5ZXJzW2lkXS5hdmFpbGFibGUgPSB0cnVlO1xyXG5cdH07XHJcblxyXG5cdHBsYXllckludGVyZmFjZS5yZXNldFNjb3JlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZWdpc3RyeS5wbGF5ZXJzW2lkXS5zY29yZSA9IDA7XHJcblx0fVxyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2Uuc2NvcmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiByZWdpc3RyeS5wbGF5ZXJzW2lkXS5zY29yZTtcclxuXHR9O1xyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2Uuc3RyYXRlZ3kgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiByZWdpc3RyeS5wbGF5ZXJzW2lkXS5zdHJhdGVneS5faWQ7XHJcblx0fTtcclxuXHJcblx0Ly8gUExVR0lOOiBydW4gYWZ0ZXIgcGxheWVyIGNyZWF0aW9uXHJcblx0UGx1Z2luTWFuYWdlci5ydW4oXCJwbGF5ZXItY3JlYXRlXCIsIF9wbGF5ZXIpXHJcblxyXG5cdHJldHVybiBwbGF5ZXJJbnRlcmZhY2VcclxufVxyXG5cclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IF9QbGF5ZXIsIFBsYXllciB9O1xyXG4iLCIvKipcclxuICpcclxuICogQHR5cGUge3t9fVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEFzeW5jQ3R4KGNhbGxiYWNrKSB7XHJcblx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cdHRoaXMuc3luYyA9IHRydWU7XHJcbn1cclxuXHJcbkFzeW5jQ3R4LnByb3RvdHlwZS5hc3luYyA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuc3luYyA9IGZhbHNlO1xyXG5cdHJldHVybiB0aGlzLmNhbGxiYWNrO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgYW4gQVBJIG1lYW50IHRvIGJlIHVzZWQgb25seSBmcm9tIHN5bmNocm9ub3VzXHJcbiAqIGNhbGxiYWNrcyBpbnRvIGFuIGFzeW5jaHJvbm91cyBsaWtlIGhvb2suXHJcbiAqXHJcbiAqIGl0IHJlcHJlc2VudCBjb250aW51aXR5IGZyb20gdGhlIFwic3luYygpXCIgb3IgXCJ3YXRlcmZhbGwoKVwiXHJcbiAqIHBsdWdpbiBtYW5hZ2VtZW50XHJcbiAqL1xyXG5Bc3luY0N0eC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjYWxsYmFjayA9IHRoaXMuYXN5bmMoKTtcclxuXHRjYWxsYmFjayh0cnVlKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXN5bmNDdHg7IiwiLy8gU3RvbGVuIGxpYmVyYWxseSBhbmQgYnJhemVubHkgZnJvbSBcInBvbGl0ZS1wbHVnaW4tbWFuYWdlclwiLlxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbmNvbnN0IHBsdWdpbkRpcmVjdG9yeVBhdGggPSBcIi4uLy4uL3BsdWdpbnMvXCJcclxuLy8gSGFjayB0byBjb21waWxlIEdsb2IgZmlsZXMgZm9yIGJyb3dzZXJpZnkuIERvbsK0dCBjYWxsIHRoaXMgZnVuY3Rpb24hXHJcbmZ1bmN0aW9uICRfRE9OT1RDQUxMKCkge1xyXG5cdHJlcXVpcmUoJy4uLy4uL3BsdWdpbnMvYmFsYW5jZS1zaGVldC1jb21wbGV4LmpzJyk7cmVxdWlyZSgnLi4vLi4vcGx1Z2lucy9iYWxhbmNlLXNoZWV0LmpzJylcclxufVxyXG5cclxuLyoqXHJcbiAqIFBvbGl0ZSBQbHVnaW4gTWFuYWdlclxyXG4gKiByZWdpc3RlciBhbmQgcnVuIGhvb2tzIGdyYW50aW5nIGV4dGVuZGFiaWxpdHlcclxuICpcclxuICovXHJcblxyXG5cclxuLy8gR2xvYmFsIERlcGVuZGVuY2llc1xyXG52YXIgZnMgPSByZXF1aXJlKCdmcycpLFxyXG5cdHBhdGggPSByZXF1aXJlKCdwYXRoJyksXHJcblx0ZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kJyksXHJcblx0YXN5bmMgPSByZXF1aXJlKCdhc3luYycpLFxyXG5cclxuXHQvLyBMb2NhbCBNb2R1bGVzXHJcblx0QXN5bmNDdHggPSByZXF1aXJlKCcuL2FzeW5jLWN0eCcpLFxyXG5cdFdhdGVyZmFsbEN0eCA9IHJlcXVpcmUoJy4vd2F0ZXJmYWxsLWN0eCcpLFxyXG5cdFBsdWdpbk5hbWVFcnJvciA9IHJlcXVpcmUoJy4vcGx1Z2luLW5hbWUtZXJyb3InKSxcclxuXHRQbHVnaW5DYWxsYmFja0Vycm9yID0gcmVxdWlyZSgnLi9wbHVnaW4tY2FsbGJhY2stZXJyb3InKTtcclxuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuLy8gLS0tW1sgICBDIE8gTiBTIFQgUiBVIEMgVCBPIFIgICBBIE4gRCAgIEwgSSBGIEUgQyBZIEMgTCBFICAgVSBUIEkgTCBJIFQgSSBFIFMgICBdXS0tIC8vXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG5cclxudmFyIFBsdWdpbk1hbmFnZXIgPSB7fSxcclxuXHRwYWNrYWdlcyA9IFtdLFxyXG5cdHBhY2thZ2VOYW1lcyA9IFtdLFxyXG5cdGhvb2tzID0ge30sXHJcblx0c2tpcFByb3BzID0gWydtb2R1bGUnLCAnbmFtZScsICdwcmlvcml0eScsICdhY3RpdmUnLCAnaW5pdCcsICdyZXF1aXJlJywgJ3N0b3AnLCAncHVibGljJywgJ3NldHRpbmdzJ107XHJcblxyXG5cclxuXHJcblBsdWdpbk1hbmFnZXIucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuXHRwYWNrYWdlcyA9IFtdO1xyXG5cdHBhY2thZ2VOYW1lcyA9IFtdO1xyXG5cdGhvb2tzID0ge307XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQXBwbHkgcGFja2FnZSBzb3J0aW5nLFxyXG4gKiByZWdpc3RlciBwYWNrYWdlcyBpbnRvIGhvb2tzLFxyXG4gKiBydW4gcGFja2FnZXMgaW5pdCgpIG1ldGhvZFxyXG4gKi9cclxuUGx1Z2luTWFuYWdlci5zdGFydCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblxyXG5cdHZhciBzZWxmID0gdGhpcyxcclxuXHRcdGluaXRzID0gW107XHJcblxyXG5cdC8vIHNvcnQgYnkgcHJpb3JpdGllc1xyXG5cdHBhY2thZ2VzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0cmV0dXJuIGEucHJpb3JpdHkgPiBiLnByaW9yaXR5O1xyXG5cdH0pO1xyXG5cclxuXHQvLyByZWdpc3RlciBpbml0ICYgaG9va3NcclxuXHQvLyBob29rcyBhcmUgYWxsIGZ1bmN0aW9ucyB3aG8gYXJlIG5vdCBzcGVjaWFsIHByb3BlcnRpZXNcclxuXHQvLyBpZGVudGlmaWVkIGJ5IFwic2tpcFByb3BzXCIgbGlzdFxyXG5cdHBhY2thZ2VzLmZvckVhY2goZnVuY3Rpb24ocGtnKSB7XHJcblx0XHRpZiAocGtnLmluaXQpIHtcclxuXHRcdFx0aW5pdHMucHVzaChwa2cuaW5pdCk7XHJcblx0XHR9XHJcblx0XHRmb3IgKHZhciBwcm9wIGluIHBrZykge1xyXG5cdFx0XHRpZiAoc2tpcFByb3BzLmluZGV4T2YocHJvcCkgPT09IC0xICYmIHR5cGVvZiBwa2dbcHJvcF0gPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdFBsdWdpbk1hbmFnZXIucmVnaXN0ZXJIb29rKHByb3AsIHBrZ1twcm9wXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0Ly8gcnVuIGFsbCBwYWNrYWdlLmluaXQoKSBtZXRob2QgaW4gc2VyaWVzIVxyXG5cdGlmIChpbml0cy5sZW5ndGgpIHtcclxuXHRcdGFzeW5jLmVhY2hTZXJpZXMoaW5pdHMsIGZ1bmN0aW9uKGZuLCBkb25lKSB7XHJcblxyXG5cdFx0XHR2YXIgY29udGV4dCA9IG5ldyBBc3luY0N0eChkb25lKSxcclxuXHRcdFx0XHRyZXN1bHQgPSBmbi5hcHBseShjb250ZXh0KTtcclxuXHJcblx0XHRcdC8vIHN5bmMgZmFsc2Ugc3RvcCBpbml0aWFsaXphdGlvbiBjeWNsZSFcclxuXHRcdFx0aWYgKGNvbnRleHQuc3luYykge1xyXG5cdFx0XHRcdGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHNlbGYpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRkb25lKHJlc3VsdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSwgY2FsbGJhY2suYmluZCh0aGlzKSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGNhbGxiYWNrLmNhbGwoc2VsZik7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG4vLyAtLS1bWyAgIEggTyBPIEsgUyAgIEEgUCBJICAgXV0tLS0gLy9cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblxyXG5QbHVnaW5NYW5hZ2VyLnJlZ2lzdGVySG9vayA9IGZ1bmN0aW9uKGhvb2tOYW1lLCBob29rRm4sIGhvb2tQcmlvcml0eSA9IDEwMCkge1xyXG5cdGhvb2tGbi5wcmlvcml0eSA9IGhvb2tQcmlvcml0eTtcclxuXHJcblx0aWYgKCFob29rc1tob29rTmFtZV0pIHtcclxuXHRcdGhvb2tzW2hvb2tOYW1lXSA9IFtdO1xyXG5cdH1cclxuXHJcblx0aG9va3NbaG9va05hbWVdLnB1c2goaG9va0ZuKTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG5QbHVnaW5NYW5hZ2VyLmlzRW1wdHkgPSBmdW5jdGlvbihob29rTmFtZSkge1xyXG5cdGlmIChob29rc1tob29rTmFtZV0gJiYgaG9va3NbaG9va05hbWVdLmxlbmd0aCkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSdW4gcmVnaXN0ZXJlZCBob29rIGNhbGxiYWNrcyBpbiBzZXJpZXNcclxuICogKGl0IHN1cHBvcnRzIGFzeW5jaHJvbm91cyBjYWxsYmFja3MpXHJcbiAqL1xyXG5QbHVnaW5NYW5hZ2VyLnJ1biA9IGZ1bmN0aW9uKGhvb2tOYW1lLCAuLi5hcmdzKSB7XHJcblxyXG5cdC8vIFVzZSB0aGUgcnVuV2l0aENhbGxiYWNrIGJ1dCB3aXRoIGJsYW5rIGNhbGxiYWNrLlxyXG5cdFBsdWdpbk1hbmFnZXIucnVuV2l0aENhbGxiYWNrKGhvb2tOYW1lLCAuLi5hcmdzLCBmdW5jdGlvbigpIHt9KVxyXG59O1xyXG5cclxuLy8gU2FtZSBhcyBhYm92ZSwgYnV0IHVzZSBsYXN0IGFyZ3VtZW50IGFzIGNhbGxiYWNrXHJcblBsdWdpbk1hbmFnZXIucnVuV2l0aENhbGxiYWNrID0gZnVuY3Rpb24oaG9va05hbWUsIC4uLmFyZ3MpIHtcclxuXHJcblx0Ly8gY29sbGVjdCBob29rTmFtZSBwcm9wZXJ0eVxyXG5cdGlmICghaG9va05hbWUpIHRocm93IG5ldyBQbHVnaW5OYW1lRXJyb3IoJ21pc3NpbmcgcGx1Z2luIG5hbWUhJyk7XHJcblxyXG5cdC8vIG9idGFpbiBhc3luYyBjYWxsYmFja1xyXG5cdGlmICghYXJncy5sZW5ndGggfHwgdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0dGhyb3cgbmV3IFBsdWdpbkNhbGxiYWNrRXJyb3IoJ1snICsgaG9va05hbWUgKyAnXSBtaXNzaW5nIGNhbGxiYWNrIGZvciBhc3luYyBwbHVnaW4hJyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XHJcblx0fVxyXG5cclxuXHJcblx0Ly8gY2hlY2sgZm9yIHNvbWUgY2FsbGJhY2tzIGV4aXN0YW5jZVxyXG5cdC8vIFs/Pz9dIG1heSBnaXZlIG91dCBhbiBleGNlcHRpb24gd2hlbiBubyBjYWxsYmFja3Mgd2VyZSBmb3VuZCFcclxuXHRpZiAoIWhvb2tzW2hvb2tOYW1lXSB8fCAhaG9va3NbaG9va05hbWVdLmxlbmd0aCkge1xyXG5cdFx0Y2FsbGJhY2soZmFsc2UpO1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Ly8gU29ydCBob29rcyBieSBwcmlvcml0eVxyXG5cdGhvb2tzW2hvb2tOYW1lXS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdHJldHVybiBhLnByaW9yaXR5ID4gYi5wcmlvcml0eVxyXG5cdH0pXHJcblxyXG5cdC8vIHJ1biBhc3luYyBxdWVxdWVcclxuXHQvLyBOT1RFOiBhIHN0ZXAgZnVuY3Rpb24gc2hvdWxkIHN0b3AgdGhlIHF1ZXF1ZSBieSBkb25lKHRydWUpXHJcblx0YXN5bmMuZWFjaFNlcmllcyhob29rc1tob29rTmFtZV0sIGZ1bmN0aW9uKGZuLCBkb25lKSB7XHJcblx0XHR2YXIgY29udGV4dCA9IG5ldyBBc3luY0N0eChkb25lKSxcclxuXHRcdFx0cmVzdWx0ID0gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblxyXG5cdFx0aWYgKGNvbnRleHQuc3luYykge1xyXG5cdFx0XHRpZiAocmVzdWx0ID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZG9uZShyZXN1bHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSwgY2FsbGJhY2spO1xyXG5cclxuXHRyZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJ1biByZWdpc3RlcmVkIGhvb2sgY2FsbGJhY2tzIGluIHBhcmFsbGVsXHJcbiAqIChpdCBzdXBwb3J0cyBhc3luY2hyb25vdXMgY2FsbGJhY2tzKVxyXG4gKiBAcGFyYW0gaG9va05hbWVcclxuICovXHJcblxyXG5QbHVnaW5NYW5hZ2VyLnBhcmFsbGVsID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHZhciBob29rTmFtZSA9ICcnLFxyXG5cdFx0Y2FsbGJhY2sgPSBudWxsLFxyXG5cdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcblxyXG5cdC8vIGNvbGxlY3QgaG9va05hbWUgcHJvcGVydHlcclxuXHRpZiAoIWFyZ3MubGVuZ3RoKSB7XHJcblx0XHR0aHJvdyBuZXcgUGx1Z2luTmFtZUVycm9yKCdtaXNzaW5nIHBsdWdpbiBuYW1lIScpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRob29rTmFtZSA9IGFyZ3Muc2hpZnQoKTtcclxuXHR9XHJcblxyXG5cdC8vIG9idGFpbiBhc3luYyBjYWxsYmFja1xyXG5cdGlmICghYXJncy5sZW5ndGggfHwgdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0dGhyb3cgbmV3IFBsdWdpbkNhbGxiYWNrRXJyb3IoJ1snICsgaG9va05hbWUgKyAnXSBtaXNzaW5nIGNhbGxiYWNrIGZvciBhc3luYyBwbHVnaW4hJyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGNhbGxiYWNrID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xyXG5cdH1cclxuXHJcblx0Ly8gY2hlY2sgZm9yIHNvbWUgY2FsbGJhY2tzIGV4aXN0YW5jZVxyXG5cdC8vIFs/Pz9dIG1heSBnaXZlIG91dCBhbiBleGNlcHRpb24gd2hlbiBubyBjYWxsYmFja3Mgd2VyZSBmb3VuZCFcclxuXHRpZiAoIWhvb2tzW2hvb2tOYW1lXSB8fCAhaG9va3NbaG9va05hbWVdLmxlbmd0aCkge1xyXG5cdFx0Y2FsbGJhY2soZmFsc2UpO1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Ly8gcnVuIGFzeW5jIGluIHBhcmFsbGVsXHJcblx0Ly8gTk9URTogYSBzdGVwIGZ1bmN0aW9uIHNob3VsZCBzdG9wIHRoZSBxdWVxdWUgYnkgZG9uZSh0cnVlKVxyXG5cdGFzeW5jLmVhY2goaG9va3NbaG9va05hbWVdLCBmdW5jdGlvbihmbiwgZG9uZSkge1xyXG5cdFx0dmFyIGNvbnRleHQgPSBuZXcgQXN5bmNDdHgoZG9uZSksXHJcblx0XHRcdHJlc3VsdCA9IGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG5cclxuXHRcdC8vIGhhbmRsZSBzeW5jIGNhbGxiYWNrc1xyXG5cdFx0aWYgKGNvbnRleHQuc3luYykge1xyXG5cdFx0XHRkb25lKHJlc3VsdCk7XHJcblx0XHR9XHJcblx0fSwgY2FsbGJhY2spO1xyXG5cclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogV0FURVJGQUxMXHJcbiAqIFJ1biBhIGhvb2sgYXMgYSBub3JtYWwgZnVuY3Rpb24gaW4gYSBmdWxseSBzeW5jcm9ub3VzIG1vZGVcclxuICogRWFjaCBob29rRm4gc2hvdWxkIHJldHVybiBhIHZhbHVlIHdobydzIGZvcndhcmQgYXMgZmlyc3QgYXJndW1lbnQgZm9yIHRoZSBuZXh0IG9uZVxyXG4gKiBsYXN0IGhvb2tGbiByZXR1cm4gdmFsdWUgaXMgdGhlIGZpbmFsIG91dHB1dFxyXG4gKi9cclxuUGx1Z2luTWFuYWdlci53YXRlcmZhbGwgPSBmdW5jdGlvbihob29rTmFtZSkge1xyXG5cclxuXHRpZiAoIWhvb2tOYW1lKSB7XHJcblx0XHR0aHJvdyBuZXcgUGx1Z2luTmFtZUVycm9yKCdtaXNzaW5nIHBsdWdpbiBuYW1lIScpO1xyXG5cdH1cclxuXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG5cdGFyZ3Muc2hpZnQoKTtcclxuXHJcblx0aWYgKGhvb2tzW2hvb2tOYW1lXSkge1xyXG5cdFx0Ly8gdXNlIGtub3duIGV4Y2VwdGlvbiB0byBleGl0IGZvckVhY2ggY3ljbGUgaW1wbGVtZW50aW5nIGEgc3RvcHBhYmxlIHdhdGVmYWxsXHJcblx0XHQvLyAoaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNjQxMzQ3L2hvdy10by1zaG9ydC1jaXJjdWl0LWFycmF5LWZvcmVhY2gtbGlrZS1jYWxsaW5nLWJyZWFrP2Fuc3dlcnRhYj12b3RlcyN0YWItdG9wKVxyXG5cdFx0dmFyIFdhdGVyZmFsbEJyZWFrRXhjZXB0aW9uID0ge307XHJcblx0XHR0cnkge1xyXG5cdFx0XHRob29rc1tob29rTmFtZV0uZm9yRWFjaChmdW5jdGlvbihmbikge1xyXG5cdFx0XHRcdHZhciBjb250ZXh0ID0gbmV3IFdhdGVyZmFsbEN0eCgpLFxyXG5cdFx0XHRcdFx0cmVzdWx0ID0gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblxyXG5cdFx0XHRcdGlmIChhcmdzLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0YXJnc1swXSA9IHJlc3VsdDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjb250ZXh0LnN0b3BwZWQpIHtcclxuXHRcdFx0XHRcdHRocm93IFdhdGVyZmFsbEJyZWFrRXhjZXB0aW9uO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0pO1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRpZiAoZSAhPT0gV2F0ZXJmYWxsQnJlYWtFeGNlcHRpb24pIHRocm93IGU7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAoYXJncy5sZW5ndGgpIHtcclxuXHRcdHJldHVybiBhcmdzWzBdO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcbi8vIC0tLVtbICAgUCBBIEMgSyBBIEcgRSBTICAgQSBQIEkgICBdXS0tLSAvL1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHJcbmZ1bmN0aW9uIGdldFBhY2thZ2VCeU5hbWUobmFtZSkge1xyXG5cdHZhciBsaXN0ID0gcGFja2FnZXMuZmlsdGVyKGZ1bmN0aW9uKHBrZykgeyByZXR1cm4gKHBrZy5uYW1lID09PSBuYW1lKSB9KVxyXG5cdGlmIChsaXN0Lmxlbmd0aCA9PSAxKSByZXR1cm4gbGlzdFswXVxyXG5cdGVsc2UgcmV0dXJuIGxpc3Q7XHJcbn1cclxuXHJcbi8vIFBhY2thZ2UgY2xhc3NcclxuZnVuY3Rpb24gUGFja2FnZShtb2R1bGUsIG5hbWUgPSBudWxsLCBjb250ZXh0ID0gbnVsbCkge1xyXG5cdC8vIEJhc2ljIGFzc2lnbm1lbnQgYW5kIGRlZmF1bHQgdmFsdWVzXHJcblx0T2JqZWN0LmFzc2lnbih0aGlzLCB7XHJcblx0XHRtb2R1bGUsXHJcblx0XHRuYW1lLFxyXG5cdFx0cHJpb3JpdHk6IDEwMCxcclxuXHRcdGFjdGl2ZTogZmFsc2UsXHJcblx0XHRpbml0OiBmdW5jdGlvbigpIHt9LFxyXG5cdFx0cmVxdWlyZTogZnVuY3Rpb24oKSB7fSxcclxuXHRcdHN0b3A6IGZ1bmN0aW9uKCkge30sXHJcblx0XHRzZXR0aW5nczogZnVuY3Rpb24oKSB7fSxcclxuXHRcdHB1YmxpYzoge31cclxuXHR9KVxyXG5cdC8vIFBhY2thZ2UtZGVmaW5lZCB2YWx1ZXMgYW5kIGhvb2tzXHJcblx0T2JqZWN0LmFzc2lnbih0aGlzLCBtb2R1bGUoY29udGV4dCB8fCB7fSkpXHJcblxyXG5cdC8vIGFkZCB0byByZWdpc3RyeVxyXG5cdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHRoZSBzYW1lIG1vZHVsZSBiZWluZyBsb2FkZWQgdHdpY2UsIG9yIGRpZmZlcmVudCBtb2R1bGVzIHdpdGggdGhlIHNhbWUgbmFtZVxyXG5cdGlmIChwYWNrYWdlTmFtZXMuaW5jbHVkZXModGhpcy5uYW1lKSkge1xyXG5cdFx0aWYgKHRoaXMubW9kdWxlID09PSBnZXRQYWNrYWdlQnlOYW1lKHRoaXMubmFtZSkubW9kdWxlKSB7XHJcblx0XHRcdC8vIFNhbWUgbW9kdWxlLiBEbyBub3RoaW5nXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBEaWZmZXJlbnQgbW9kdWxlcyB3aXRoIHNhbWUgbmFtZSwgaGFuZGxlIG5hbWUgY29uZmxpY3QuXHJcblx0XHRcdC8vVE9ETzogZmlndXJlIG91dCBob3cgdG8gaGFuZGxlIG5hbWUgY29uZmxpY3QuXHJcblx0XHR9XHJcblx0fVxyXG5cdC8vIE5vIG5hbWUgY29uZmxpY3QsIGFkZCB0byByZWdpc3RyeVxyXG5cdGVsc2Uge1xyXG5cdFx0cGFja2FnZXMucHVzaCh0aGlzKTtcclxuXHRcdHBhY2thZ2VOYW1lcy5wdXNoKHRoaXMubmFtZSlcclxuXHR9XHJcbn1cclxuXHJcblBhY2thZ2UucHJvdG90eXBlLnJlZ2lzdGVySG9va3MgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgcGtnID0gdGhpcztcclxuXHRmb3IgKHZhciBwcm9wIGluIHBrZykge1xyXG5cdFx0aWYgKHNraXBQcm9wcy5pbmRleE9mKHByb3ApID09PSAtMSAmJiB0eXBlb2YgcGtnW3Byb3BdID09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0UGx1Z2luTWFuYWdlci5yZWdpc3Rlckhvb2socHJvcCwgcGtnW3Byb3BdKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbi8vIENyZWF0ZSBpbnRlcmZhY2UgZm9yIHVzZXIgdG8gaW50ZXJhY3Qgd2l0aCBwYWNrYWdlLlxyXG5mdW5jdGlvbiBQYWNrYWdlSW50ZXJmYWNlKHBrZykge1xyXG5cclxuXHQvLyBNZXJnZSBhbnkgcHVibGljIGl0ZW1zIHNwZWNpZmllZCBieSB0aGUgcGFja2FnZSB3aXRoIHRoaXMgaW50ZXJmYWNlIGZvcm1hdFxyXG5cdHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwa2cucHVibGljLCB7XHJcblx0XHRuYW1lOiBmdW5jdGlvbigpIHsgcmV0dXJuIHBrZy5uYW1lIH0sXHJcblx0XHRwcmlvcml0eTogZnVuY3Rpb24oKSB7IHJldHVybiBwa2cucHJpb3JpdHkgfSxcclxuXHRcdGFjdGl2ZTogZnVuY3Rpb24oKSB7IHJldHVybiBwa2cuYWN0aXZlIH0sXHJcblxyXG5cdFx0aW5pdDogZnVuY3Rpb24oLi4uYXJncykge1xyXG5cdFx0XHRwa2cuaW5pdCguLi5hcmdzKTtcclxuXHRcdFx0cGtnLnJlZ2lzdGVySG9va3MoKTtcclxuXHRcdFx0cGtnLmFjdGl2ZSA9IHRydWU7XHJcblx0XHRcdHJldHVybiBPYmplY3QuYXNzaWduKHRoaXMsIHBrZy5wdWJsaWNJZkFjdGl2ZSk7XHJcblx0XHR9LFxyXG5cdFx0cmVxdWlyZTogZnVuY3Rpb24oLi4uYXJncykge1xyXG5cdFx0XHRpZiAocGtnLmFjdGl2ZSkgcGtnLnJlcXVpcmUoLi4uYXJncyk7XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHBrZy5pbml0KC4uLmFyZ3MpO1xyXG5cdFx0XHRcdHBrZy5yZWdpc3Rlckhvb2tzKCk7XHJcblx0XHRcdFx0T2JqZWN0LmFzc2lnbih0aGlzLCBwa2cucHVibGljSWZBY3RpdmUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHBrZy5hY3RpdmUgPSB0cnVlO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9LFxyXG5cdFx0c3RvcDogZnVuY3Rpb24oLi4uYXJncykge1xyXG5cdFx0XHRpZiAocGtnLmFjdGl2ZSkgcGtnLnN0b3AoLi4uYXJncyk7XHJcblx0XHRcdHBrZy5hY3RpdmUgPSBmYWxzZTtcclxuXHRcdH0sXHJcblx0XHRzZXR0aW5nczogZnVuY3Rpb24oLi4uYXJncykge1xyXG5cdFx0XHRyZXR1cm4gcGtnLnNldHRpbmdzKC4uLmFyZ3MpO1xyXG5cdFx0fVxyXG5cclxuXHR9LCBwa2cuYWN0aXZlID8gcGtnLnB1YmxpY0lmQWN0aXZlIDogbnVsbCk7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBMb2FkIGEgcGx1Z2luIHBhY2thZ2UgYnkgZm9sZGVyIHBhdGhcclxuICogQHBhcmFtIHNvdXJjZUZvbGRlclxyXG4gKi9cclxuUGx1Z2luTWFuYWdlci5wYWNrYWdlID0gZnVuY3Rpb24oc291cmNlLCBjb250ZXh0KSB7XHJcblx0aWYgKHBhY2thZ2VOYW1lcy5pbmNsdWRlcyhzb3VyY2UpKSB7XHJcblx0XHQvLyBBbHJlYWR5IGxvYWRlZCBtb2R1bGUsIGp1c3QgcmV0dXJuIGl0XHJcblx0XHRyZXR1cm4gUGFja2FnZUludGVyZmFjZShnZXRQYWNrYWdlQnlOYW1lKHNvdXJjZSkpXHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBuYW1lID0gcGF0aC5iYXNlbmFtZShzb3VyY2UpLFxyXG5cdFx0XHRtb2R1bGUgPSByZXF1aXJlKHBsdWdpbkRpcmVjdG9yeVBhdGggKyBzb3VyY2UgKyAnLmpzJylcclxuXHJcblx0XHQvLyBvYnRhaW4gcGFja2FnZSBpbmZvcm1hdGlvbnMgYW5kIGFwcGx5IHNvbWUgZGVmYXVsdCB2YWx1ZXNcclxuXHRcdHZhciBwa2cgPSBuZXcgUGFja2FnZShtb2R1bGUsIG5hbWUsIGNvbnRleHQpXHJcblx0XHRyZXR1cm4gUGFja2FnZUludGVyZmFjZShwa2cpXHJcblx0fVxyXG59XHJcblxyXG4vKlxyXG5cdFx0XHRsb2FkOiBmdW5jdGlvbihjYWxsYmFjayA9IGZ1bmN0aW9uKCkge30sIC4uLmluaXRBcmdzKSB7XHJcblx0XHRcdFx0dmFyIHNlbGYgPSBwbSxcclxuXHRcdFx0XHRcdGluaXRzID0gW10sXHJcblxyXG5cclxuXHRcdFx0XHRcdC8vIHJlZ2lzdGVyIGluaXQgJiBob29rc1xyXG5cdFx0XHRcdFx0Ly8gaG9va3MgYXJlIGFsbCBmdW5jdGlvbnMgd2hvIGFyZSBub3Qgc3BlY2lhbCBwcm9wZXJ0aWVzXHJcblx0XHRcdFx0XHQvLyBpZGVudGlmaWVkIGJ5IFwic2tpcFByb3BzXCIgbGlzdFxyXG5cclxuXHRcdFx0XHRcdGlmIChwa2cuaW5pdCkge1xyXG5cdFx0XHRcdFx0XHRpbml0cy5wdXNoKHBrZy5pbml0KTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRcdC8vIHJ1biBhbGwgcGFja2FnZS5pbml0KCkgbWV0aG9kIGluIHNlcmllcyEgLy9FRElUOiB3aWxsIG9ubHkgYmUgdGhlIG9uZVxyXG5cdFx0XHRcdGlmIChpbml0cy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdGFzeW5jLmVhY2hTZXJpZXMoaW5pdHMsIGZ1bmN0aW9uKGZuLCBkb25lKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgY29udGV4dCA9IG5ldyBBc3luY0N0eChkb25lKSxcclxuXHRcdFx0XHRcdFx0XHRyZXN1bHQgPSBmbi5hcHBseShjb250ZXh0LCBpbml0QXJncyk7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBzeW5jIGZhbHNlIHN0b3AgaW5pdGlhbGl6YXRpb24gY3ljbGUhXHJcblx0XHRcdFx0XHRcdGlmIChjb250ZXh0LnN5bmMpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAocmVzdWx0ID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2suY2FsbChzZWxmKTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0ZG9uZShyZXN1bHQpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0sIGNhbGxiYWNrLmJpbmQoc2VsZikpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHNlbGYpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHNlbGY7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cdH07XHJcbiovXHJcblxyXG4vKiogVE9ETzogdGhpcyBkb2Vzbid0IHdvcmsgcmlnaHQgbm93XHJcbiAqIExvYWQgYWxsIHBhY2thZ2VzIGZyb20gYSBnaXZlbiBmb2xkZXIgcGF0aFxyXG4gKiAoc3luY3Jvbm91cylcclxuICovXHJcblBsdWdpbk1hbmFnZXIucmVnaXN0ZXJNYW55ID0gZnVuY3Rpb24oc291cmNlRm9sZGVyLCBjb250ZXh0KSB7XHJcblx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuXHRpZiAoZnMuZXhpc3RzU3luYyhzb3VyY2VGb2xkZXIpKSB7XHJcblx0XHRmcy5yZWFkZGlyU3luYyhzb3VyY2VGb2xkZXIpLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG5cdFx0XHR2YXIgaXRlbVBhdGggPSBzb3VyY2VGb2xkZXIgKyAnLycgKyBpdGVtLFxyXG5cdFx0XHRcdGl0ZW1TdGF0ID0gZnMubHN0YXRTeW5jKGl0ZW1QYXRoKTtcclxuXHJcblx0XHRcdGlmIChpdGVtU3RhdC5pc0RpcmVjdG9yeSgpKSB7XHJcblx0XHRcdFx0c2VsZi5sb2FkUGFja2FnZShpdGVtUGF0aCwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBsdWdpbk1hbmFnZXJcclxuIiwiXHJcbmZ1bmN0aW9uIFBsdWdpbkNhbGxiYWNrRXJyb3IobWVzc2FnZSkge1xyXG5cdHRoaXMubmFtZSA9IFwiUGx1Z2luQ2FsbGJhY2tFcnJvclwiO1xyXG5cdHRoaXMubWVzc2FnZSA9IChtZXNzYWdlIHx8IFwiXCIpO1xyXG59XHJcblxyXG5cclxuUGx1Z2luQ2FsbGJhY2tFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcclxuUGx1Z2luQ2FsbGJhY2tFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbHVnaW5DYWxsYmFja0Vycm9yO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQbHVnaW5DYWxsYmFja0Vycm9yOyIsIlxyXG5mdW5jdGlvbiBQbHVnaW5OYW1lRXJyb3IobWVzc2FnZSkge1xyXG5cdHRoaXMubmFtZSA9IFwiUGx1Z2luTmFtZUVycm9yXCI7XHJcblx0dGhpcy5tZXNzYWdlID0gKG1lc3NhZ2UgfHwgXCJcIik7XHJcbn1cclxuXHJcblxyXG5QbHVnaW5OYW1lRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XHJcblBsdWdpbk5hbWVFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbHVnaW5OYW1lRXJyb3I7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBsdWdpbk5hbWVFcnJvcjsiLCIvKipcclxuICpcclxuICogQHR5cGUge3t9fVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIFdhdGVyZmFsbEN0eCgpIHtcclxuXHR0aGlzLnN0b3BwZWQgPSBmYWxzZTtcclxufVxyXG5cclxuV2F0ZXJmYWxsQ3R4LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5zdG9wcGVkID0gdHJ1ZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV2F0ZXJmYWxsQ3R4OyIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpc0Z1bmN0aW9uLCBpc09iamVjdCB9ID0gcmVxdWlyZShcIi4vaGVscGVyRnVuY3Rpb25zXCIpKFwiZ2VuZXJhbFwiKTtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZShcIi4vc3RhdGVcIik7XHJcblxyXG52YXIgeyBfUGxheWVyIH0gPSByZXF1aXJlKFwiLi9wbGF5ZXJcIik7XHJcblxyXG4vL0NsYXNzIFBsYXllckxpc3QgaXMgYSBsaXN0IG9mIHBsYXllcnMgd2hpY2ggaW5jbHVkZXMgc29tZSBleHRyYSBmdW5jdGlvbmFsaXR5LiBVc2VyUGxheWVyTGlzdCB0YWtlcyBhIHBsYXllckxpc3QgYW5kXHJcbi8vc2FuaXRpemVzIGl0IGZvciB0aGUgdXNlciAoaWUgcmV0dXJucyAuaW50ZXJmYWNlIGZvciBlYWNoIHBsYXllcikuXHJcblxyXG5mdW5jdGlvbiBQbGF5ZXJMaXN0KC4uLmFyZ3MpIHtcclxuXHRpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkgYXJncyA9IGFyZ3NbMF0uc2xpY2UoMCk7XHJcblx0aWYgKGFyZ3MgPT0gXCJhbGxcIikgcmV0dXJuIGdhbWVQb3B1bGF0aW9uKCk7XHJcblxyXG5cdC8vIFdlJ2xsIG5lZWQgdG8gcmV0YWluIHRoZSBvcmlnaW5hbCBhcmd1bWVudHMgaW4gb3JkZXIgdG8gY3JlYXRlIHRoZSBnZW5lcmF0b3JcclxuXHR2YXIgb3JpZ2luYWxBcmdzID0gW11cclxuXHJcblx0Ly8gTG9vcCBvdmVyIHRoZSBhcmd1bWVudHMsIHNhdmUgdGhlIG9yaWdpbmFscywgcGFyc2UgdGhlbSB0byBfcGxheWVyc1xyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRvcmlnaW5hbEFyZ3MucHVzaChhcmdzW2ldKTtcclxuXHRcdGlmIChpc0Z1bmN0aW9uKGFyZ3NbaV0uaWQpKSBhcmdzW2ldID0gcmVnaXN0cnkucGxheWVyc1thcmdzW2ldLmlkKCldO1xyXG5cdFx0ZWxzZSBpZiAodHlwZW9mIGFyZ3NbaV0gPT09ICdzdHJpbmcnKSBhcmdzW2ldID0gcmVnaXN0cnkucGxheWVyc1thcmdzW2ldXVxyXG5cdH1cclxuXHJcblx0T2JqZWN0LnNldFByb3RvdHlwZU9mKGFyZ3MsIFBsYXllckxpc3QucHJvdG90eXBlKTtcclxuXHJcblx0Ly8gcmV0dXJucyB0aGUgc2FtZSBwbGF5ZXJsaXN0LCBidXQgdXBkYXRlZCwgdXNpbmcgdGhlIG9yaWdpbmFsIGFyZ3MuXHJcblx0YXJncy5nZW5lcmF0b3IgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBuZXcgUGxheWVyTGlzdChvcmlnaW5hbEFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdHJldHVybiBhcmdzO1xyXG59XHJcblxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXJyYXkucHJvdG90eXBlKTtcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbGF5ZXJMaXN0O1xyXG5cclxuXHJcbi8vIEFzc2lnbiBhIHN0cmF0ZWd5IGVuIG1hc3NlXHJcblBsYXllckxpc3QucHJvdG90eXBlLmFzc2lnbiA9IGZ1bmN0aW9uKHN0cmF0ZWd5TmFtZSkge1xyXG5cdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHBsYXllci5hc3NpZ24oc3RyYXRlZ3lOYW1lKVxyXG5cdH0pXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcblxyXG4vL1JldHVybiBhIFBsYXllckxpc3QgbWludXMgdGhlIHNwZWNpZmllZCBwbGF5ZXJzLlxyXG4vL0FyZ3VtZW50IGNhbiBiZSBfcGxheWVyLCBpbnRlcmZhY2UsIG9yIGEgcGxheWVyJ3MgaWQuXHJcblBsYXllckxpc3QucHJvdG90eXBlLmV4Y2x1ZGUgPSBmdW5jdGlvbihwbGF5ZXJBcmcpIHtcclxuXHRpZiAoQXJyYXkuaXNBcnJheShwbGF5ZXJBcmcpKVxyXG5cdFx0cmV0dXJuIHBsYXllckFyZy5yZWR1Y2UoZnVuY3Rpb24ocnVubmluZywgaXRlbSkge1xyXG5cdFx0XHRyZXR1cm4gcnVubmluZy5leGNsdWRlKGl0ZW0pO1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdHJldHVybiBuZXcgUGxheWVyTGlzdChcclxuXHRcdHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRpZiAoXHJcblx0XHRcdFx0cGxheWVyQXJnID09PSBwbGF5ZXIgfHxcclxuXHRcdFx0XHRwbGF5ZXJBcmcgPT0gcGxheWVyLmludGVyZmFjZSB8fFxyXG5cdFx0XHRcdHBsYXllckFyZyA9PSBwbGF5ZXIuaWQgfHxcclxuXHRcdFx0XHQoaXNPYmplY3QocGxheWVyQXJnKSAmJiBwbGF5ZXJBcmcuaWQgPT0gcGxheWVyLmlkKVxyXG5cdFx0XHQpXHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRlbHNlIHJldHVybiB0cnVlO1xyXG5cdFx0fSlcclxuXHQpO1xyXG59O1xyXG5cclxuXHJcbi8vIFBsYWNlaG9sZGVyIGZvciBnZW5lcmF0b3IgbWV0aG9kLlxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5nZW5lcmF0b3IgPSBmdW5jdGlvbigpIHtcclxuXHQvLyBUaGlzIHdpbGwgZ2V0IHNoYWRvd2VkIHdoZW4gdGhlIGNvbnN0cnVjdG9yIGlzIGNhbGxlZCwgYnV0IGl0IG5lZWRzIHRvIGJlIGhlcmUgc28gdGhhdCB0aGVcclxuXHQvLyBVc2VyUGxheWVyTGlzdCBhbmQgSW5mb1BsYXllckxpc3QgY29uc3RydWN0b3JzIGNhbiBzZWUgaXQuXHJcbn1cclxuXHJcblxyXG4vL0NyZWF0ZSBhbiBJbmZvUGxheWVyTGlzdCBvdXQgb2YgdGhpcyBQbGF5ZXJMaXN0LiBVc2VmdWwgZm9yIGdldHRpbmcgc3VtbWFyeSB2aWV3LlxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBJbmZvUGxheWVyTGlzdCh0aGlzKTtcclxufTtcclxuXHJcblxyXG4vL1JldHVybiBhcnJheSBvZiBpZHMgb2YgZWFjaCBwbGF5ZXIgaW4gdGhlIGxpc3RcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuaWRzID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0cmV0dXJuIHBsYXllci5pZDtcclxuXHR9KTtcclxufTtcclxuXHJcblxyXG4vL0tpbGwgYWxsIHBsYXllcnMgaW4gdGhlIHBsYXllckxpc3RcclxuUGxheWVyTGlzdC5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHBsYXllci5raWxsKCk7XHJcblx0fSk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5cclxuLy9SZXR1cm5zIHRoZSBzaW5nbGUgcGxheWVyIHdpdGggdGhlIGhpZ2hlc3Qgc2NvcmVcclxuUGxheWVyTGlzdC5wcm90b3R5cGUubGVhZGVyID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIHBsYXllcnMgPSB0aGlzLnNsaWNlKCk7XHJcblxyXG5cdHBsYXllcnMuc29ydChmdW5jdGlvbihhLCBiKSB7XHJcblx0XHRyZXR1cm4gYi5zY29yZSAtIGEuc2NvcmU7XHJcblx0fSk7XHJcblxyXG5cdHBsYXllcnMgPSBwbGF5ZXJzLmZpbHRlcihmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHJldHVybiBwbGF5ZXIuc2NvcmUgPT0gcGxheWVyc1swXS5zY29yZVxyXG5cdH0pXHJcblxyXG5cclxuXHRyZXR1cm4gcGxheWVycy5sZW5ndGggPiAxID8gbmV3IFBsYXllckxpc3QocGxheWVycykgOiBwbGF5ZXJzWzBdO1xyXG59O1xyXG5cclxuXHJcblBsYXllckxpc3QucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRwbGF5ZXIuYXZhaWxhYmxlID0gdHJ1ZTtcclxuXHR9KTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG5cclxuLy9SZXR1cm4gYSBwbGF5ZXJMaXN0IHdpdGggb25seSB0aGUgcGxheWVycyB3aG8gYXJlIGF2YWlsYWJsZVxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5vbmx5QWxpdmUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFBsYXllckxpc3QoXHJcblx0XHR0aGlzLmZpbHRlcihmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0cmV0dXJuIHBsYXllci5hbGl2ZTtcclxuXHRcdH0pXHJcblx0KTtcclxufTtcclxuXHJcblxyXG4vL1JldHVybiBhIHBsYXllckxpc3Qgd2l0aCBvbmx5IHRoZSBwbGF5ZXJzIHdobyBhcmUgYXZhaWxhYmxlXHJcblBsYXllckxpc3QucHJvdG90eXBlLm9ubHlBdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFBsYXllckxpc3QoXHJcblx0XHR0aGlzLmZpbHRlcihmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0cmV0dXJuIHBsYXllci5hdmFpbGFibGU7XHJcblx0XHR9KVxyXG5cdCk7XHJcbn07XHJcblxyXG5cclxuLy9SZXR1cm5zIGFuIGFycmF5IG9mIHNjb3JlcyBvZiBlYWNoIHBsYXllciBpbiB0aGUgbGlzdFxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5zY29yZXMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0gW107XHJcblxyXG5cdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHNjb3Jlcy5wdXNoKHBsYXllci5zY29yZSk7IC8vVXNlIHRoZSBpbnRlcmZhY2UgZnVuY3Rpb24gdG8gYXZvaWQgdXNlcnMgcmUtYXNzaWduaW5nIHRoZSByZWZlcmVuY2VcclxuXHR9KTtcclxuXHRyZXR1cm4gc2NvcmVzO1xyXG59O1xyXG5cclxuXHJcbi8vIFJldHVybnMgYW4gb2JqZWN0IHdoZXJlIGVhY2gga2V5IGlzIGEgc3RyYXRlZ3kgYW5kIGVhY2ggdmFsdWUgaXMgYW4gYXJyYXkgb2YgdGhlIHNjb3JlcyBvZiBwbGF5ZXJzIHdpdGggdGhhdCBzdHJhdGVneS5cclxuLy8gVE9ETzogZmluaXNoIC50b3RhbCgpIG1ldGhvZCwgd2hpY2ggd2lsbCBzdW0gdGhlIGFycmF5cyAoZHVwbGljYXRpbmcgLnNjb3Jlc0J5U3RyYXRlZ3lUb3RhbHMpXHJcblBsYXllckxpc3QucHJvdG90eXBlLnNjb3Jlc0J5U3RyYXRlZ3kgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0ge307XHJcblx0dmFyIGxpc3QgPSB0aGlzO1xyXG5cclxuXHRsaXN0LnN0cmF0ZWdpZXMoKS5tYXAoZnVuY3Rpb24oc3RyYXRlZ3kpIHtcclxuXHRcdHNjb3Jlc1tzdHJhdGVneV0gPSBsaXN0LnVzaW5nU3RyYXRlZ3koc3RyYXRlZ3kpLnNjb3JlcygpO1xyXG5cdH0pO1xyXG5cclxuXHRzY29yZXMudG90YWwgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBzY29yZSA9IHt9O1xyXG5cdFx0dmFyIHNjb3JlcyA9IHRoaXM7XHJcblx0XHRPYmplY3Qua2V5cyhzY29yZXMpLmZvckVhY2goZnVuY3Rpb24oc3RyYXRlZ3kpIHtcclxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoc2NvcmVzW3N0cmF0ZWd5XSkpIHNjb3JlW3N0cmF0ZWd5XSA9IHNjb3Jlc1tzdHJhdGVneV0ucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdFx0XHRyZXR1cm4gYSArIGI7XHJcblx0XHRcdH0sIDApO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gc2NvcmU7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIHNjb3JlcztcclxufTtcclxuXHJcbi8vIFJldHVybnMgYW4gb2JqZWN0IHdoZXJlIGVhY2gga2V5IGlzIGEgc3RyYXRlZ3kgYW5kIGVhY2ggdmFsdWUgaXMgdGhlIHN1bSBvZiBzY29yZXMgb2YgYWxsIHBsYXllcnMgd2l0aCB0aGF0IHZhbHVlXHJcblBsYXllckxpc3QucHJvdG90eXBlLnNjb3Jlc0J5U3RyYXRlZ3lUb3RhbHMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0ge307XHJcblx0dmFyIGxpc3QgPSB0aGlzO1xyXG5cclxuXHRsaXN0LnN0cmF0ZWdpZXMoKS5tYXAoZnVuY3Rpb24oc3RyYXRlZ3kpIHtcclxuXHRcdHNjb3Jlc1tzdHJhdGVneV0gPSBsaXN0XHJcblx0XHRcdC51c2luZ1N0cmF0ZWd5KHN0cmF0ZWd5KVxyXG5cdFx0XHQuc2NvcmVzKClcclxuXHRcdFx0LnJlZHVjZShmdW5jdGlvbihhLCBiKSB7XHJcblx0XHRcdFx0cmV0dXJuIGEgKyBiO1xyXG5cdFx0XHR9LCAwKTtcclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIHNjb3JlcztcclxufTtcclxuXHJcbi8vUmV0dXJucyBhbiBvYmplY3Qgd2hlcmUgdGhlIGtleXMgYXJlIHRoZSBwbGF5ZXIgaWRzIGFuZCB0aGUgdmFsdWVzXHJcbi8vYXJlIHRoZSBwbGF5ZXJzJyBzY29yZVxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5zY29yZXNPYmplY3QgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0ge307XHJcblxyXG5cdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHNjb3Jlc1twbGF5ZXIuaWRdID0gcGxheWVyLnNjb3JlO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gc2NvcmVzO1xyXG59O1xyXG5cclxuLy9NZWFuIG9mIHRoZSBzY29yZXNcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuc2NvcmVzTWVhbiA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBzY29yZXMgPSB0aGlzLnNjb3JlcygpO1xyXG5cclxuXHR2YXIgbWVhbiA9XHJcblx0XHRzY29yZXMucmVkdWNlKGZ1bmN0aW9uKHN1bSwgdmFsdWUpIHtcclxuXHRcdFx0cmV0dXJuIHN1bSArIHZhbHVlO1xyXG5cdFx0fSwgMCkgLyBzY29yZXMubGVuZ3RoO1xyXG5cclxuXHRyZXR1cm4gbWVhbjtcclxufTtcclxuXHJcbi8vQXJyYXkgd2l0aCAyIGVudHJpZXMsIHRoZSBsb3dlc3QgYW5kIGhpZ2hlc3Qgc2NvcmVcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuc2NvcmVzUmFuZ2UgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0gdGhpcy5zY29yZXMoKTtcclxuXHJcblx0c2NvcmVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0cmV0dXJuIGEgLSBiO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gW3Njb3Jlc1swXSwgc2NvcmVzW3Njb3Jlcy5sZW5ndGggLSAxXV07XHJcbn07XHJcblxyXG4vL1RoZSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgdGhlIHNjb3Jlc1xyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5zY29yZXNTdGQgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0gdGhpcy5zY29yZXMoKTtcclxuXHR2YXIgbWVhbiA9IHRoaXMuc2NvcmVzTWVhbigpO1xyXG5cclxuXHR2YXIgdmFyaWFuY2UgPVxyXG5cdFx0c2NvcmVzLnJlZHVjZShmdW5jdGlvbihzdW0sIHZhbHVlKSB7XHJcblx0XHRcdHJldHVybiBzdW0gKyBNYXRoLnBvdyh2YWx1ZSAtIG1lYW4sIDIpO1xyXG5cdFx0fSwgMCkgLyBzY29yZXMubGVuZ3RoO1xyXG5cclxuXHR2YXIgc3RkID0gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcclxuXHJcblx0cmV0dXJuIHN0ZDtcclxufTtcclxuXHJcblxyXG4vL1JldHVybiBhbiBhcnJheSBvZiB0aGUgc3RyYXRlZ3kgb2YgZWFjaCBwbGF5ZXIgaW4gdGhlIGxpc3RcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuc3RyYXRlZ2llcyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHJldHVybiBwbGF5ZXIuc3RyYXRlZ3kgPyBwbGF5ZXIuc3RyYXRlZ3kuX2lkIDogXCJcIjtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vUmV0dXJuIGEgUGxheWVyTGlzdCB3aXRoIG9ubHkgcGxheWVycyB1c2luZyBhIGdpdmVuIHN0cmF0ZWd5XHJcblBsYXllckxpc3QucHJvdG90eXBlLnVzaW5nU3RyYXRlZ3kgPSBmdW5jdGlvbihzdHJhdGVneSkge1xyXG5cdHJldHVybiBuZXcgUGxheWVyTGlzdChcclxuXHRcdHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRpZiAoXHJcblx0XHRcdFx0cGxheWVyLnN0cmF0ZWd5ID09IHN0cmF0ZWd5IHx8XHJcblx0XHRcdFx0cGxheWVyLnN0cmF0ZWd5Ll9pZCA9PSBzdHJhdGVneSB8fFxyXG5cdFx0XHRcdChpc0Z1bmN0aW9uKHN0cmF0ZWd5KSAmJiBwbGF5ZXIuc3RyYXRlZ3kgaW5zdGFuY2VvZiBzdHJhdGVneSlcclxuXHRcdFx0KVxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRlbHNlIHJldHVybiBmYWxzZTtcclxuXHRcdH0pXHJcblx0KTtcclxufTtcclxuXHJcbi8qXHJcblxyXG5UT0RPIGZpZ3VyZSBvdXQgaG93IHRvIG1ha2UgdGhpcyB3b3JrXHJcblxyXG4vL1JldHVybnMgYW4gb2JqZWN0IHdoZXJlIHRoZSBrZXlzIGFyZSBzdHJhdGVneSBuYW1lcyBhbmQgdGhlIHZhbHVlcyBhcmUgYXJyYXlzIG9mIHBsYXllcnMuXHJcbi8vVGhpcyBuZWVkcyB0byBiZSBvdmVycmlkZGVuIG9uIHRoZSBVc2VyUGxheWVyTGlzdCBwcm90b3R5cGUsIGJlY2F1c2UgdGhlIG5vcm1hbCB3cmFwcGVyIGxvZ2ljXHJcbi8vZm9yIFVzZXJQbGF5ZXJMaXN0IGNhbm5vdCBzYW5pdGl6ZSB0aGlzLlxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5ieVN0cmF0ZWd5ID0gZnVuY3Rpb24oKXtcclxuXHR2YXIgbGlzdCA9IHRoaXM7XHJcblx0dmFyIGRhdGEgPSB7fTtcclxuXHJcblx0T2JqZWN0LmtleXMocmVnaXN0cnkuc3RyYXRlZ2llcykuZm9yRWFjaChmdW5jdGlvbihzdHJhdGVneSl7XHJcblx0XHRkYXRhW3N0cmF0ZWd5XSA9IGxpc3QudXNpbmdTdHJhdGVneShzdHJhdGVneSk7XHJcblx0fSk7XHJcblxyXG5cdHJldHVybiBkYXRhO1xyXG59O1xyXG4qL1xyXG5cclxuLy9SZXR1cm5zIGFuIG9iamVjdCB3aGVyZSB0aGUga2V5cyBhcmUgZWFjaCBzdHJhdGVneSBhbmQgdGhlIHZhbHVlc1xyXG4vL2FyZSB0aGUgbnVtYmVyIG9mIHBsYXllcnMgaW4gdGhlIGxpc3Qgd2hvIGFyZSB1c2luZyBpdC5cclxuUGxheWVyTGlzdC5wcm90b3R5cGUuc3RyYXRlZ3lEaXN0cmlidXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgY291bnRzID0ge307XHJcblxyXG5cdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHZhciBzID0gcGxheWVyLnN0cmF0ZWd5Ll9pZDtcclxuXHRcdGNvdW50c1tzXSA9IChjb3VudHNbc10gfHwgMCkgKyAxO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gY291bnRzO1xyXG59O1xyXG5cclxuXHJcblxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5yZXNldFNjb3JlcyA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHBsYXllci5zY29yZSA9IDA7XHJcblx0fSk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vL0FjY2VwdCBhIFBsYXllckxpc3QgYW5kIHJldHVybiBvbmUgc3VpdGFibGUgZm9yIHRoZSB1c2VyLCBvciBjcmVhdGUgYSBwbGF5ZXJsaXN0IGFuZCByZXR1cm4gb25lIHN1aXRhYmxlIGZvciB0aGUgdXNlclxyXG5mdW5jdGlvbiBVc2VyUGxheWVyTGlzdCguLi5wbGF5ZXJMaXN0KSB7XHJcblx0aWYgKEFycmF5LmlzQXJyYXkocGxheWVyTGlzdFswXSkpIHBsYXllckxpc3QgPSBwbGF5ZXJMaXN0WzBdO1xyXG5cclxuXHQvLyBJZiB3ZSd2ZSBnb3QgYSBwbGF5ZXJMaXN0LCByZXR1cm4gdGhlIGludGVyZmFjZSBvZiBlYWNoIHBsYXllclxyXG5cdGlmIChwbGF5ZXJMaXN0IGluc3RhbmNlb2YgUGxheWVyTGlzdCkge1xyXG5cdFx0dmFyIHVzZXJQbGF5ZXJMaXN0ID0gcGxheWVyTGlzdC5tYXAoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdHJldHVybiBwbGF5ZXIuaW50ZXJmYWNlO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cdC8vIElmIG5vdCwgZmlyc3QgY3JlYXRlIGEgcGxheWVyTGlzdCwgdGhlbiBjYWxsIHRoaXMgZnVuY3Rpb24gYWdhaW4gdG8gd3JhcCBpdC5cclxuXHRlbHNlIHJldHVybiBuZXcgVXNlclBsYXllckxpc3QobmV3IFBsYXllckxpc3QocGxheWVyTGlzdCkpO1xyXG5cclxuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YodXNlclBsYXllckxpc3QsIFVzZXJQbGF5ZXJMaXN0LnByb3RvdHlwZSk7XHJcblxyXG5cdC8vQXR0YWNoIG1ldGhvZHMgZnJvbSBQbGF5ZXJMaXN0LCB3cmFwcGVkIGluIGEgZnVuY3Rpb24uIElmIHRob3NlIG1ldGhvZHMgcmV0dXJuIGEgcGxheWVyTGlzdCxcclxuXHQvL3RoZW4gdGhlIGZ1bmN0aW9uIHdpbGwgY29udmVydCB0aGF0IHRvIGEgVXNlclBsYXllckxpc3QuXHJcblx0Zm9yICh2YXIgbWV0aG9kIGluIFBsYXllckxpc3QucHJvdG90eXBlKSB7XHJcblx0XHRpZiAoaXNGdW5jdGlvbihwbGF5ZXJMaXN0W21ldGhvZF0pKSB7XHJcblx0XHRcdGlmIChtZXRob2QgIT0gXCJjb25zdHJ1Y3RvclwiKVxyXG5cdFx0XHRcdHVzZXJQbGF5ZXJMaXN0W21ldGhvZF0gPSAoZnVuY3Rpb24obWV0aG9kKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdHZhciByZXN1bHQgPSBwbGF5ZXJMaXN0W21ldGhvZF0uYXBwbHkocGxheWVyTGlzdCwgYXJndW1lbnRzKTtcclxuXHRcdFx0XHRcdFx0aWYgKHJlc3VsdCBpbnN0YW5jZW9mIFBsYXllckxpc3QpIHJldHVybiBuZXcgVXNlclBsYXllckxpc3QocmVzdWx0KTtcclxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAocmVzdWx0IGluc3RhbmNlb2YgX1BsYXllcikgcmV0dXJuIHJlc3VsdC5pbnRlcmZhY2U7XHJcblx0XHRcdFx0XHRcdGVsc2UgcmV0dXJuIHJlc3VsdDtcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fSkobWV0aG9kKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB1c2VyUGxheWVyTGlzdDtcclxufVxyXG5cclxuVXNlclBsYXllckxpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQbGF5ZXJMaXN0LnByb3RvdHlwZSk7XHJcblVzZXJQbGF5ZXJMaXN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVzZXJQbGF5ZXJMaXN0O1xyXG5cclxuLy9BY2NlcHQgYSBQbGF5ZXJMaXN0IGFuZCByZXR1cm4gb25lIHN1aXRhYmxlIGZvciBhIHN0cmF0ZWd5IGluZm9ybWF0aW9uIHNldC5cclxuZnVuY3Rpb24gSW5mb1BsYXllckxpc3QocGxheWVyTGlzdCkge1xyXG5cdHZhciBpbmZvUGxheWVyTGlzdCA9IHBsYXllckxpc3QubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0cmV0dXJuIHBsYXllci5pbmZvQ2xlYW4oSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwbGF5ZXIpKSk7XHJcblx0fSk7XHJcblxyXG5cdE9iamVjdC5zZXRQcm90b3R5cGVPZihpbmZvUGxheWVyTGlzdCwgSW5mb1BsYXllckxpc3QucHJvdG90eXBlKTtcclxuXHJcblx0Ly9BdHRhY2ggc2VsZWN0ZWQgbWV0aG9kcyBmcm9tIFBsYXllckxpc3QsIHdyYXBwZWQgaW4gYSBmdW5jdGlvbi4gSWYgdGhvc2UgbWV0aG9kcyByZXR1cm4gYSBwbGF5ZXJMaXN0LFxyXG5cdC8vdGhlbiB0aGUgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IHRoYXQgdG8gYW4gSW5mb1BsYXllckxpc3QuXHJcblx0dmFyIG1ldGhvZHNUb0luY2x1ZGUgPSBbXHJcblx0XHRcIm9ubHlBbGl2ZVwiLFxyXG5cdFx0XCJvbmx5QXZhaWxhYmxlXCIsXHJcblx0XHRcImlkc1wiLFxyXG5cdFx0XCJleGNsdWRlXCIsXHJcblx0XHRcImdlbmVyYXRvclwiLFxyXG5cdFx0XCJzdHJhdGVnaWVzXCIsXHJcblx0XHRcInVzaW5nU3RyYXRlZ3lcIixcclxuXHRcdFwic3RyYXRlZ3lEaXN0cmlidXRpb25cIixcclxuXHRcdFwic2NvcmVzXCIsXHJcblx0XHRcInNjb3Jlc09iamVjdFwiLFxyXG5cdFx0XCJzY29yZXNNZWFuXCIsXHJcblx0XHRcInNjb3Jlc1JhbmdlXCIsXHJcblx0XHRcInNjb3Jlc1N0ZFwiLFxyXG5cdFx0XCJsZWFkZXJcIlxyXG5cdF07XHJcblxyXG5cdGZvciAodmFyIG1ldGhvZCBpbiBQbGF5ZXJMaXN0LnByb3RvdHlwZSkge1xyXG5cdFx0aWYgKGlzRnVuY3Rpb24ocGxheWVyTGlzdFttZXRob2RdKSkge1xyXG5cdFx0XHRpZiAobWV0aG9kc1RvSW5jbHVkZS5pbmRleE9mKG1ldGhvZCkgPiAtMSlcclxuXHRcdFx0XHRpbmZvUGxheWVyTGlzdFttZXRob2RdID0gKGZ1bmN0aW9uKG1ldGhvZCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gcGxheWVyTGlzdFttZXRob2RdLmFwcGx5KHBsYXllckxpc3QsIGFyZ3VtZW50cyk7XHJcblx0XHRcdFx0XHRcdGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQbGF5ZXJMaXN0KSByZXR1cm4gbmV3IEluZm9QbGF5ZXJMaXN0KHJlc3VsdCk7XHJcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIF9QbGF5ZXIpXHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC5pbmZvQ2xlYW4oSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXN1bHQpKSk7XHJcblx0XHRcdFx0XHRcdGVsc2UgcmV0dXJuIHJlc3VsdDtcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fSkobWV0aG9kKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBpbmZvUGxheWVyTGlzdDtcclxufVxyXG5cclxuSW5mb1BsYXllckxpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBcnJheS5wcm90b3R5cGUpO1xyXG5JbmZvUGxheWVyTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbmZvUGxheWVyTGlzdDtcclxuXHJcbi8vRXh0cmEgbWV0aG9kIHRvIHJldHVybiBhIHNpbmdsZSBwbGF5ZXIgZnJvbSBhbiBpbmZvUGxheWVyTGlzdFxyXG5JbmZvUGxheWVyTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocGxheWVySUQpIHtcclxuXHRyZXR1cm4gdGhpcy5maW5kKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0cmV0dXJuIHBsYXllci5pZCA9PSBwbGF5ZXJJRDtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vR2VuZXJhdGVzIGEgUGxheWVyTGlzdCBjb250YWluaW5nIGFsbCBwbGF5ZXJzLlxyXG52YXIgZ2FtZVBvcHVsYXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgcG9wdWxhdGlvbiA9IFtdO1xyXG5cclxuXHRmb3IgKHZhciBwbGF5ZXIgaW4gcmVnaXN0cnkucGxheWVycykge1xyXG5cdFx0cG9wdWxhdGlvbi5wdXNoKHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyXSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3IFBsYXllckxpc3QocG9wdWxhdGlvbik7XHJcbn07XHJcblxyXG4vL0RvZXMgdGhlIHNhbWUsIGJ1dCBhIFVzZXJQbGF5ZXJMaXN0XHJcbnZhciBQb3B1bGF0aW9uID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBVc2VyUGxheWVyTGlzdChnYW1lUG9wdWxhdGlvbigpKTtcclxufTtcclxuXHJcbi8vRG9lcyB0aGUgc2FtZSwgYnV0IGFuIEluZm9QbGF5ZXJMaXN0XHJcbnZhciBJbmZvUG9wdWxhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgSW5mb1BsYXllckxpc3QoZ2FtZVBvcHVsYXRpb24oKSk7XHJcbn07XHJcblxyXG4vL0Egc2hvcnQtaGFuZCB0byByZXR1cm4gdG90YWwgcG9wdWxhdGlvbiBzaXplIHdpdGhvdXQgY3JlYXRpbmcgYSBQbGF5ZXJMaXN0XHJcblBvcHVsYXRpb24uc2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBPYmplY3Qua2V5cyhyZWdpc3RyeS5wbGF5ZXJzKS5sZW5ndGg7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHRQbGF5ZXJMaXN0LFxyXG5cdFVzZXJQbGF5ZXJMaXN0LFxyXG5cdEluZm9QbGF5ZXJMaXN0LFxyXG5cdGdhbWVQb3B1bGF0aW9uLFxyXG5cdFBvcHVsYXRpb24sXHJcblx0SW5mb1BvcHVsYXRpb25cclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBFeHRlcm5hbCBkZXBlbmRlbmN5XHJcbnZhciBqc29uYXRhID0gcmVxdWlyZShcImpzb25hdGFcIik7XHJcblxyXG4vLyBHYW1lIHN0YXRlXHJcbnZhciB7IHJlZ2lzdHJ5LCBpZENvdW50ZXJzIH0gPSByZXF1aXJlKFwiLi9zdGF0ZVwiKVxyXG5yZWdpc3RyeS5fYWRkVHlwZV8oXCJxdWVyaWVzXCIpXHJcbmlkQ291bnRlcnMuX2FkZFR5cGVfKFwicXVlcnlcIilcclxuXHJcbi8vIFRoZSBjb2RlIHdoaWNoIGV2YWx1YXRlcyBhbGwgcXVlcmllcywgbm8gbWF0dGVyIHdoZXJlIHRoZXkgY29tZSBmcm9tLlxyXG5mdW5jdGlvbiBldmFsdWF0ZVF1ZXJ5KHF1ZXJ5U3RyaW5nLCB0YXJnZXQsIC4uLmFyZ3MpIHtcclxuXHQvLyBDaGVjayBmb3IgcHJlLXByb2dyYW1tZWQgcXVlcnksIGRlc2lnbmF0ZWQgYnkgJ0AnXHJcblx0aWYgKHF1ZXJ5U3RyaW5nWzBdID09IFwiQFwiICYmIHJlZ2lzdHJ5LnF1ZXJpZXNbcXVlcnlTdHJpbmddKSBxdWVyeVN0cmluZyA9IHJlZ2lzdHJ5LnF1ZXJpZXNbcXVlcnlTdHJpbmddLnF1ZXJ5XHJcblx0ZWxzZSBpZiAocXVlcnlTdHJpbmdbMF0gPT0gXCJAXCIpIHF1ZXJ5U3RyaW5nID0gcXVlcnlTdHJpbmcuc2xpY2UoMSlcclxuXHJcblx0cmV0dXJuIG5ldyBRdWVyeVJlc3VsdChxdWVyeVN0cmluZywganNvbmF0YShxdWVyeVN0cmluZykuZXZhbHVhdGUodGFyZ2V0LCAuLi5hcmdzKSkucGFjaygpO1xyXG59XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIFF1ZXJ5KHNob3J0Y3V0LCBxdWVyeSwgZGVzY3JpcHRpb24sIGZvcm1hdCA9IFwic2hvcnRjdXRcIikge1xyXG5cclxuXHQvLyBPbmx5IGluY2x1ZGUgcmVxdWVzdGVkIHByb3BlcnRpZXMsIHRvIGF2b2lkIHZpc3VhbCBjbHV0dGVyXHJcblx0aWYgKGZvcm1hdCA9PSBcImNvZGVcIiB8fCBmb3JtYXQgPT0gXCJhbGxcIikgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xyXG5cdGlmIChmb3JtYXQgPT0gXCJzaG9ydGN1dFwiIHx8IGZvcm1hdCA9PSBcImFsbFwiKSB7XHJcblx0XHR0aGlzLnNob3J0Y3V0ID0gc2hvcnRjdXRcclxuXHJcblx0XHRpZiAoZm9ybWF0ICE9PSBcImFsbFwiKSB7XHJcblx0XHRcdC8vIE5vcm1hbGx5IHdlJ2QgdXNlIHRoZSBwcm90b3R5cGUgbWV0aG9kIHRvIHNhdmUgbWVtb3J5LCBidXQgaW4gdGhpcyBjYXNlIGl0IHdvbid0IHdvcmssIHNvIGF0dGFjaCBhbm90aGVyXHJcblx0XHRcdHRoaXMuZXZhbHVhdGUgPSBmdW5jdGlvbih0YXJnZXQsIC4uLmFyZ3MpIHtcclxuXHRcdFx0XHRyZXR1cm4gZXZhbHVhdGVRdWVyeShxdWVyeSwgdGFyZ2V0LCAuLi5hcmdzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblx0dGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uXHJcbn1cclxuXHJcblF1ZXJ5LnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKHRhcmdldCwgLi4uYXJncykge1xyXG5cdHJldHVybiBldmFsdWF0ZVF1ZXJ5KHRoaXMucXVlcnksIHRhcmdldCwgLi4uYXJncylcclxufTtcclxuXHJcblxyXG5cclxuLy8gQSBjbGFzcyB0byBzaGFyZSByZXN1bHRzIHdpdGguIEEgc2ltcGxlIFF1ZXJ5UmVzdWx0IGhhcyBhIGByZXN1bHRgIGFuZFxyXG4vLyBhIGBxdWVyeVN0cmluZ2AgcHJvcGVydHksIGFuZCBhIGAucGFja2AgbWV0aG9kLiBDYWxsaW5nIGAucGFja2Agd2lsbFxyXG4vLyBjcmVhdGUgYSBuZXcgb2JqZWN0IHdob3NlIHZhbHVlIGlzIHRoZSBgcmVzdWx0YCBwcm9wZXJ0eSwgYnV0IHdob3NlXHJcbi8vcHJvdG90eXBlIGlzIHRoZSBvcmlnaW5hbCBvYmplY3QuIFRoaXMgZ2l2ZXMgYSBjbGVhbiByZXN1bHQsIHRoYXQgc3RpbGxcclxuLy8gaGFzIGEgYC5xdWVyeVN0cmluZ2AgcHJvcGVydHksIHRvIHZpZXcgdGhlIHN0cmluZyB0aGF0IGdlbmVyYXRlZCBpdC5cclxuZnVuY3Rpb24gUXVlcnlSZXN1bHQocXVlcnksIHJlc3VsdCkge1xyXG5cdC8vIENhbid0IGFkZCBwcm9wZXJ0aWVzIHRvIHVuZGVmaW5lZCwgdG8gY2hhbmdlIHRvIGEgc3RyaW5nXHJcblx0aWYgKHJlc3VsdCA9PSB1bmRlZmluZWQpIHJlc3VsdCA9IG51bGxcclxuXHJcblx0dGhpcy5xdWVyeSA9IHF1ZXJ5XHJcblx0dGhpcy5yZXN1bHQgPSByZXN1bHRcclxufVxyXG5RdWVyeVJlc3VsdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFycmF5LnByb3RvdHlwZSlcclxuUXVlcnlSZXN1bHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUXVlcnlSZXN1bHQ7XHJcblxyXG4vLyBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGlzIHRoZSByZXN1bHRzIG9mIHRoZSBxdWVyeSwgYnV0IHdob3NlXHJcbi8vIHByb3RvdHlwZSBjb250YWlucyAucXVlcnkgKHVubGVzcyB0aGUgcmVzdWx0IHdhcyBqdXN0IGEgc3RyaW5nKVxyXG5RdWVyeVJlc3VsdC5wcm90b3R5cGUucGFjayA9IGZ1bmN0aW9uKCkge1xyXG5cdC8vIElmIHJlc3VsdCBpcyBzdHJpbmcsXHJcblx0aWYgKHR5cGVvZiB0aGlzLnJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0dmFyIHBhY2tlZCA9IG5ldyBTdHJpbmcodGhpcy5yZXN1bHQpXHJcblx0XHRwYWNrZWQucXVlcnkgPSB0aGlzLnF1ZXJ5XHJcblx0XHRyZXR1cm4gcGFja2VkO1xyXG5cdH1cclxuXHQvLyBJZiBpdCdzIGFycmF5XHJcblx0ZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnJlc3VsdCkpIHtcclxuXHRcdHZhciBwYWNrZWQgPSBPYmplY3QuY3JlYXRlKHRoaXMpXHJcblx0XHRwYWNrZWQucHVzaCguLi50aGlzLnJlc3VsdClcclxuXHRcdHJldHVybiBwYWNrZWRcclxuXHR9XHJcblx0Ly9Ob3JtYWwgb2JqZWN0XHJcblx0ZWxzZSByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHRoaXMpLCB0aGlzLnJlc3VsdClcclxufVxyXG5cclxuXHJcbi8vIFVzZXIgb2JqZWN0IGZvciBkZWFsaW5nIHdpdGggdGhlc2UgdGhpbmdzLlxyXG5mdW5jdGlvbiBRdWVyaWVzKHF1ZXJ5U3RyaW5nLCB0YXJnZXQsIC4uLmFyZ3MpIHtcclxuXHQvLyBJZiBubyBxdWVyeSBzdHJpbmcsIGRpc3BsYXkgYWxsIGF2YWlsYWJsZSBzaG9ydGN1dHNcclxuXHRpZiAoIXF1ZXJ5U3RyaW5nKSB7XHJcblx0XHRyZXR1cm4gT2JqZWN0LmtleXMocmVnaXN0cnkucXVlcmllcykubWFwKGZ1bmN0aW9uKHF1ZXJ5KSB7XHJcblx0XHRcdHZhciBxID0gcmVnaXN0cnkucXVlcmllc1txdWVyeV1cclxuXHRcdFx0cmV0dXJuIG5ldyBRdWVyeShxdWVyeSwgcS5xdWVyeSwgcS5kZXNjcmlwdGlvbiwgXCJzaG9ydGN1dFwiKVxyXG5cdFx0fSlcclxuXHR9XHJcblx0Ly8gSWYgcXVlcnkgc3RyaW5nLCBlaXRoZXIgcnVuIHF1ZXJ5IG9yIHJldHVybiBxdWVyeVxyXG5cdGVsc2Uge1xyXG5cdFx0Ly8gSWYgbm8gdGFyZ2V0LCByZXR1cm4gcXVlcnlcclxuXHRcdGlmICghdGFyZ2V0KSB7XHJcblx0XHRcdHZhciBxID0gcmVnaXN0cnkucXVlcmllc1txdWVyeVN0cmluZ11cclxuXHRcdFx0aWYgKHEpIHJldHVybiBuZXcgUXVlcnkocXVlcnlTdHJpbmcsIHEucXVlcnksIHEuZGVzY3JpcHRpb24sIFwiY29kZVwiKVxyXG5cdFx0fVxyXG5cdFx0Ly8gSWYgeWVzIHRhcmdldCwgcnVuIHF1ZXJ5IG9uIHRhcmdldCBhbmQgcmV0dXJuIHJlc3VsdFxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHJldHVybiBldmFsdWF0ZVF1ZXJ5KHF1ZXJ5U3RyaW5nLCB0YXJnZXQsIC4uLmFyZ3MpXHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IFF1ZXJpZXMsIFF1ZXJ5LCBRdWVyeVJlc3VsdCwgZXZhbHVhdGVRdWVyeSB9XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XHJcblxyXG5sb2coXCJkZWJ1Z1wiLCBcInN0YXRlOiBDcmVhdGluZyBnYW1lIHN0YXRlIHZhcmlhYmxlcy5cIilcclxuXHJcblxyXG52YXIgcmVnaXN0cnkgPSB7fVxyXG5yZWdpc3RyeS5fYWRkVHlwZV8gPSBmdW5jdGlvbih0eXBlKXtcdFxyXG5cdHJlZ2lzdHJ5W3R5cGVdID0ge307XHJcblx0bG9nKFwic2lsbHlcIiwgXCJzdGF0ZTogYWRkaW5nIHJlZ2lzdHJ5IGVudHJ5OiBcIiwgdHlwZSlcclxufTtcclxuXHJcblxyXG52YXIgaWRDb3VudGVycyA9IHt9XHJcbmlkQ291bnRlcnMuX2FkZFR5cGVfID0gZnVuY3Rpb24odHlwZSl7XHJcblx0aWRDb3VudGVyc1t0eXBlXSA9IDBcclxuXHRsb2coXCJzaWxseVwiLCBcInN0YXRlOiBhZGRpbmcgY291bnRlciBlbnRyeTogXCIsIHR5cGUpXHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7cmVnaXN0cnksIGlkQ291bnRlcnN9OyIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuY29uc3QgbmFzaE5hbWUgPSBcIi4vY29yZVwiOyAvL0NoYW5nZSB0aGlzIHdoZW4gcHVibGlzaGVkLCBwcm9iYWJseSB0byAnbmFzaC1qcydcclxuXHJcbnZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcclxuXHJcbnZhciB7IHJlZ2lzdGVyU3RyYXRlZ3ksIHJlZ2lzdGVyU3RyYXRlZ3lPYmplY3QgfSA9IHJlcXVpcmUoJy4vc3RyYXRlZ3knKTtcclxuXHJcbi8vQ2hlY2sgdG8gc2VlIGlmIHBhcnNlZCBleHByZXNzaW9uIGlzIGNhbGwgdG8gcmVxdWlyZSBvciBldmFsXHJcbmZ1bmN0aW9uIGlzQmFubmVkQ2FsbChub2RlKSB7XHJcblx0cmV0dXJuIChub2RlLnR5cGUgPT09ICdDYWxsRXhwcmVzc2lvbicpICYmXHJcblx0XHQobm9kZS5jYWxsZWUudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKSAmJlxyXG5cdFx0KG5vZGUuY2FsbGVlLm9iamVjdC50eXBlID09PSAnSWRlbnRpZmllcicpICYmXHJcblx0XHQoKG5vZGUuY2FsbGVlLm9iamVjdC5uYW1lID09PSAncmVxdWlyZScpIHx8IChub2RlLmNhbGxlZS5vYmplY3QubmFtZSA9PT0gJ2V2YWwnKSk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiByZW1vdmVDYWxscyhzb3VyY2UpIHtcclxuXHRjb25zdCBlbnRyaWVzID0gW107XHJcblx0ZXNwcmltYS5wYXJzZVNjcmlwdChzb3VyY2UsIHt9LCBmdW5jdGlvbihub2RlLCBtZXRhKSB7XHJcblx0XHRpZiAoaXNCYW5uZWRDYWxsKG5vZGUpKSB7XHJcblx0XHRcdGVudHJpZXMucHVzaCh7XHJcblx0XHRcdFx0c3RhcnQ6IG1ldGEuc3RhcnQub2Zmc2V0LFxyXG5cdFx0XHRcdGVuZDogbWV0YS5lbmQub2Zmc2V0XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdGVudHJpZXMuc29ydCgoYSwgYikgPT4geyByZXR1cm4gYi5lbmQgLSBhLmVuZCB9KS5mb3JFYWNoKG4gPT4ge1xyXG5cdFx0c291cmNlID0gc291cmNlLnNsaWNlKDAsIG4uc3RhcnQpICsgXCIgbnVsbDsgXCIgKyBzb3VyY2Uuc2xpY2Uobi5lbmQpO1xyXG5cdH0pO1xyXG5cdHJldHVybiBzb3VyY2U7XHJcbn1cclxuXHJcblxyXG5cclxudmFyIGxvYWRTdHJhdGVneSA9IGZ1bmN0aW9uKGZpbGVwYXRoLCB0cnVzdGVkID0gZmFsc2UpIHtcclxuXHR2YXIgY29tcGlsZXIgPSByZXF1aXJlKCdleHByZXNzaW9uLXNhbmRib3gnKTtcclxuXHJcblx0dmFyIHNvdXJjZSA9IGZzLnJlYWRGaWxlU3luYyhmaWxlcGF0aCk7XHJcblxyXG5cdGlmICghdHJ1c3RlZCkge1xyXG5cdFx0dmFyIG9yaWdpbmFsU291cmNlID0gc291cmNlO1xyXG5cdFx0dmFyIHBhcnNlZFNvdXJjZSA9IHJlbW92ZUNhbGxzKHNvdXJjZSk7XHJcblxyXG5cdFx0aWYgKG9yaWdpbmFsU291cmNlICE9IHBhcnNlZFNvdXJjZSkgdGhyb3cgbmV3IEVycm9yKFwiU3RyYXRlZ3kgXCIgKyBmaWxlcGF0aCArIFwiIHVzZXMgcmVxdWlyZSBvciBldmFsLlwiKTtcclxuXHR9XHJcblxyXG5cdHNvdXJjZSA9IFwiXFxcInVzZSBzdHJpY3RcXFwiOyBcXG4gXCIgKyBzb3VyY2U7XHJcblx0Y29tcGlsZXIoc291cmNlKSh7IHJlZ2lzdGVyU3RyYXRlZ3ksIHJlZ2lzdGVyU3RyYXRlZ3lPYmplY3QgfSk7XHJcblxyXG59OyAvL1RPRE86IGNoYW5nZSB0aGlzIHNvIHRoYXQgc3RyYXRlZ2llcyBjYW4ndCByZXF1aXJlIGFueSBtb2R1bGVzLlxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBsb2FkU3RyYXRlZ3lGb2xkZXIocGF0aCwgdHJ1c3RlZCA9IGZhbHNlKSB7XHJcblx0dmFyIGZpbGVzID0gZnMucmVhZGRpclN5bmMocGF0aCk7XHJcblx0ZmlsZXMuZm9yRWFjaChmdW5jdGlvbihmaWxlKSB7XHJcblx0XHR2YXIgZmlsZVBhdGggPSBwYXRoICsgJy8nICsgZmlsZTtcclxuXHRcdGxvYWRTdHJhdGVneShmaWxlcGF0aCk7XHJcblx0fSk7XHJcbn07XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IGxvYWRTdHJhdGVneSwgbG9hZFN0cmF0ZWd5Rm9sZGVyIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XHJcblxyXG4vL0phdmFzY3JpcHQgY29kZSBwYXJzZXJcclxudmFyIGVzcHJpbWEgPSByZXF1aXJlKCdlc3ByaW1hJyk7XHJcblxyXG4vL0dhbWUgc3RhdGUgY29udHJvbGxlcnNcclxudmFyIHsgcmVnaXN0cnkgfSA9IHJlcXVpcmUoJy4vc3RhdGUnKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoJy4vaGVscGVyRnVuY3Rpb25zJykoXCJzdGF0ZVwiKTtcclxuXHJcblxyXG5cclxuLy9Vc2VyIGludGVyZmFjZSB0byBkZWNsYXJlIHN0cmF0ZWd5IHR5cGUuXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyU3RyYXRlZ3koc3RyYXRlZ3ksIG5hbWUsIGRlc2NyaXB0aW9uID0gXCJObyBkZXNjcmlwdGlvbiBnaXZlbi5cIiwgcGxheWVyTmFtZSA9IFwiXCIpIHtcclxuXHR2YXIgaWQgPSBpZEhhbmRsZXIobmFtZSwgXCJzdHJhdGVneVwiKTtcclxuXHJcblx0aWYgKGlkICE9PSBuYW1lKSB7XHJcblx0XHQvL1RoZXJlIHdhcyBhbHJlYWR5IGEgc3RyYXRlZ3kgcmVnaXN0ZXJlZCB3aXRoIHRoaXMgbmFtZS5cclxuXHRcdC8vQ2hlY2sgdG8gc2VlIGlmIGl0J3MgdGhlIHNhbWUgc3RyYXRlZ3kgb3Igbm90LlxyXG5cdFx0aWYgKCFyZWdpc3RyeS5zdHJhdGVnaWVzW2lkXSA9PT0gc3RyYXRlZ3kpIHtcclxuXHRcdFx0Ly9UaGV5J3JlIGRpZmZlcmVudCwgc28gd2UgaGF2ZSBhIG5hbWUgY29uZmxpY3QuXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlN0cmF0ZWd5IG5hbWUgY29uZmxpY3Qgd2l0aCBcIiArIG5hbWUpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIFRoZXkncmUgdGhlIHNhbWUsIGRvIG5vdGhpbmcuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gTm8gbmFtZSBjb25mbGljdCBhbmQgc3RyYXRlZ3kgbm90IGxvYWRlZCB5ZXQuIEFkZCB0byByZWdpc3RyeS5cclxuXHRsb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgc3RyYXRlZ3kgJ1wiICsgaWQgKyBcIidcIilcclxuXHRzdHJhdGVneS5wbGF5ZXJOYW1lID0gcGxheWVyTmFtZTtcclxuXHRzdHJhdGVneS5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xyXG5cdHJlZ2lzdHJ5LnN0cmF0ZWdpZXNbaWRdID0gc3RyYXRlZ3k7XHJcblx0cmV0dXJuIG5hbWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyU3RyYXRlZ3lPYmplY3Qoc3RyYXRlZ3lPYmplY3QpIHtcclxuXHQvLyBJZiBtdWx0aXBsZSBzdHJhdGVnaWVzLCBzcGxpdCBpbnRvIGluZGl2aWR1YWxzXHJcblx0aWYgKEFycmF5LmlzQXJyYXkoc3RyYXRlZ3lPYmplY3QpKSByZXR1cm4gc3RyYXRlZ3lPYmplY3QubWFwKHJlZ2lzdGVyU3RyYXRlZ3lPYmplY3QpXHJcblxyXG5cdHJldHVybiByZWdpc3RlclN0cmF0ZWd5KHN0cmF0ZWd5T2JqZWN0LnN0cmF0ZWd5LCBzdHJhdGVneU9iamVjdC5uYW1lLCBzdHJhdGVneU9iamVjdC5kZXNjcmlwdGlvbixcclxuXHRcdHN0cmF0ZWd5T2JqZWN0LnBsYXllck5hbWUpXHJcbn1cclxuXHJcbi8vU3RyaXAgb3V0IHJlcXVpcmVzIGFuZCBzdWNoXHJcbmZ1bmN0aW9uIHNhbml0aXplU3RyYXRlZ3koc3RyYXRlZ3kpIHtcclxuXHQvLyBjb25zb2xlLmxvZyh4KSBvciBjb25zb2xlWydlcnJvciddKHkpXHJcblx0ZnVuY3Rpb24gaXNSZXF1aXJlQ2FsbChub2RlKSB7XHJcblx0XHRyZXR1cm4gKG5vZGUudHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJykgJiZcclxuXHRcdFx0KG5vZGUuY2FsbGVlLnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykgJiZcclxuXHRcdFx0KG5vZGUuY2FsbGVlLm9iamVjdC50eXBlID09PSAnSWRlbnRpZmllcicpICYmXHJcblx0XHRcdChub2RlLmNhbGxlZS5vYmplY3QubmFtZSA9PT0gJ3JlcXVpcmUnKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlbW92ZUNhbGxzKHNvdXJjZSkge1xyXG5cdFx0Y29uc3QgZW50cmllcyA9IFtdO1xyXG5cdFx0ZXNwcmltYS5wYXJzZVNjcmlwdChzb3VyY2UsIHt9LCBmdW5jdGlvbihub2RlLCBtZXRhKSB7XHJcblx0XHRcdGlmIChpc1JlcXVpcmVDYWxsKG5vZGUpKSB7XHJcblx0XHRcdFx0ZW50cmllcy5wdXNoKHtcclxuXHRcdFx0XHRcdHN0YXJ0OiBtZXRhLnN0YXJ0Lm9mZnNldCxcclxuXHRcdFx0XHRcdGVuZDogbWV0YS5lbmQub2Zmc2V0XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0ZW50cmllcy5zb3J0KChhLCBiKSA9PiB7IHJldHVybiBiLmVuZCAtIGEuZW5kIH0pLmZvckVhY2gobiA9PiB7XHJcblx0XHRcdHNvdXJjZSA9IHNvdXJjZS5zbGljZSgwLCBuLnN0YXJ0KSArIHNvdXJjZS5zbGljZShuLmVuZCk7XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiBzb3VyY2U7XHJcblx0fVxyXG5cclxuXHRyZW1vdmVDYWxscyhzdHJhdGVneS50b1N0cmluZygpKTtcclxuXHJcbn1cclxuXHJcbi8vUmV0dXJucyB0byB0aGUgdXNlciBhbiBhcnJheSBvZiBhbGwgcmVnaXN0ZXJlZCBzdHJhdGVnaWVzLiBUT0RPOiBoYXZlIHRoaXMgbWlycm9yIFBsYXllckxpc3QsIHRvIHByb3ZpZGUgZnVuY3Rpb25hbGl0eSBsaWtlIG9ubHlBbGl2ZSBhbmQgc2NvcmVzT2JqZWN0LlxyXG5mdW5jdGlvbiBTdHJhdGVnaWVzKCkge1xyXG5cdHZhciBzdHJhdGVnaWVzID0gW107XHJcblx0Zm9yICh2YXIgc3RyYXRlZ3kgaW4gcmVnaXN0cnkuc3RyYXRlZ2llcykgc3RyYXRlZ2llcy5wdXNoKHN0cmF0ZWd5KTtcclxuXHRyZXR1cm4gc3RyYXRlZ2llcztcclxufTtcclxuXHJcbi8vIEZldGNoIHRoZSBkZXNjcmlwdGlvbnMgb2YgdGhlIHN0cmF0ZWdpZXMuXHJcblN0cmF0ZWdpZXMuZGVzY3JpcHRpb25zID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIHN0cmF0ZWdpZXMgPSB7fTtcclxuXHRmb3IgKHZhciBzdHJhdGVneSBpbiByZWdpc3RyeS5zdHJhdGVnaWVzKSBzdHJhdGVnaWVzW3N0cmF0ZWd5XSA9IHJlZ2lzdHJ5LnN0cmF0ZWdpZXNbc3RyYXRlZ3ldLmRlc2NyaXB0aW9uO1xyXG5cdHJldHVybiBzdHJhdGVnaWVzO1xyXG59XHJcblxyXG5cclxuLy8gQSBidWlsdC1pbiBkZWJ1Z2dpbmcgc3RyYXRlZ3kuIENhbGxpbmcgdGhpcyBmdW5jdGlvbiBsb2FkcyB0aGUgc3RyYXRlZ3kuXHJcbi8vIFRoZSBzdHJhdGVneSBqdXN0IGNhbGxlcyAnZGVidWdnZXInIHdoZW4gYXNrZWQgdG8gY2hvb3NlLlxyXG5TdHJhdGVnaWVzLmRlYnVnZ2VyID0gZnVuY3Rpb24oKSB7XHJcblx0cmVnaXN0ZXJTdHJhdGVneShmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuY2hvb3NlID0gZnVuY3Rpb24ob3B0aW9ucywgaW5mb3JtYXRpb24pIHtcclxuXHRcdFx0ZGVidWdnZXI7XHJcblx0XHR9XHJcblx0fSwgXCJkZWJ1Z2dlclwiKVxyXG5cdHJldHVybiBcImRlYnVnZ2VyXCJcclxufVxyXG5cclxuU3RyYXRlZ2llcy5sb2dnZXIgPSBmdW5jdGlvbigpIHtcclxuXHRyZWdpc3RlclN0cmF0ZWd5KGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5jaG9vc2UgPSBmdW5jdGlvbihvcHRpb25zLCBpbmZvcm1hdGlvbikge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIk9wdGlvbnM6IFwiLCBvcHRpb25zKTtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJJbmZvcm1hdGlvbjogXCIsIGluZm9ybWF0aW9uKVxyXG5cdFx0fVxyXG5cdH0sIFwibG9nZ2VyXCIpXHJcblx0cmV0dXJuIFwibG9nZ2VyXCJcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IHJlZ2lzdGVyU3RyYXRlZ3ksIHJlZ2lzdGVyU3RyYXRlZ3lPYmplY3QsIFN0cmF0ZWdpZXMgfTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAvW1xcdTAwMWJcXHUwMDliXVtbKCkjOz9dKig/OlswLTldezEsNH0oPzo7WzAtOV17MCw0fSkqKT9bMC05QS1QUlpjZi1ucXJ5PT48XS9nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNzZW1ibGVTdHlsZXMgKCkge1xuXHR2YXIgc3R5bGVzID0ge1xuXHRcdG1vZGlmaWVyczoge1xuXHRcdFx0cmVzZXQ6IFswLCAwXSxcblx0XHRcdGJvbGQ6IFsxLCAyMl0sIC8vIDIxIGlzbid0IHdpZGVseSBzdXBwb3J0ZWQgYW5kIDIyIGRvZXMgdGhlIHNhbWUgdGhpbmdcblx0XHRcdGRpbTogWzIsIDIyXSxcblx0XHRcdGl0YWxpYzogWzMsIDIzXSxcblx0XHRcdHVuZGVybGluZTogWzQsIDI0XSxcblx0XHRcdGludmVyc2U6IFs3LCAyN10sXG5cdFx0XHRoaWRkZW46IFs4LCAyOF0sXG5cdFx0XHRzdHJpa2V0aHJvdWdoOiBbOSwgMjldXG5cdFx0fSxcblx0XHRjb2xvcnM6IHtcblx0XHRcdGJsYWNrOiBbMzAsIDM5XSxcblx0XHRcdHJlZDogWzMxLCAzOV0sXG5cdFx0XHRncmVlbjogWzMyLCAzOV0sXG5cdFx0XHR5ZWxsb3c6IFszMywgMzldLFxuXHRcdFx0Ymx1ZTogWzM0LCAzOV0sXG5cdFx0XHRtYWdlbnRhOiBbMzUsIDM5XSxcblx0XHRcdGN5YW46IFszNiwgMzldLFxuXHRcdFx0d2hpdGU6IFszNywgMzldLFxuXHRcdFx0Z3JheTogWzkwLCAzOV1cblx0XHR9LFxuXHRcdGJnQ29sb3JzOiB7XG5cdFx0XHRiZ0JsYWNrOiBbNDAsIDQ5XSxcblx0XHRcdGJnUmVkOiBbNDEsIDQ5XSxcblx0XHRcdGJnR3JlZW46IFs0MiwgNDldLFxuXHRcdFx0YmdZZWxsb3c6IFs0MywgNDldLFxuXHRcdFx0YmdCbHVlOiBbNDQsIDQ5XSxcblx0XHRcdGJnTWFnZW50YTogWzQ1LCA0OV0sXG5cdFx0XHRiZ0N5YW46IFs0NiwgNDldLFxuXHRcdFx0YmdXaGl0ZTogWzQ3LCA0OV1cblx0XHR9XG5cdH07XG5cblx0Ly8gZml4IGh1bWFuc1xuXHRzdHlsZXMuY29sb3JzLmdyZXkgPSBzdHlsZXMuY29sb3JzLmdyYXk7XG5cblx0T2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChncm91cE5hbWUpIHtcblx0XHR2YXIgZ3JvdXAgPSBzdHlsZXNbZ3JvdXBOYW1lXTtcblxuXHRcdE9iamVjdC5rZXlzKGdyb3VwKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcblx0XHRcdHZhciBzdHlsZSA9IGdyb3VwW3N0eWxlTmFtZV07XG5cblx0XHRcdHN0eWxlc1tzdHlsZU5hbWVdID0gZ3JvdXBbc3R5bGVOYW1lXSA9IHtcblx0XHRcdFx0b3BlbjogJ1xcdTAwMWJbJyArIHN0eWxlWzBdICsgJ20nLFxuXHRcdFx0XHRjbG9zZTogJ1xcdTAwMWJbJyArIHN0eWxlWzFdICsgJ20nXG5cdFx0XHR9O1xuXHRcdH0pO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHN0eWxlcywgZ3JvdXBOYW1lLCB7XG5cdFx0XHR2YWx1ZTogZ3JvdXAsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZVxuXHRcdH0pO1xuXHR9KTtcblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnZXhwb3J0cycsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBhc3NlbWJsZVN0eWxlc1xufSk7XG4iLCIvKmdsb2JhbCBzZXRJbW1lZGlhdGU6IGZhbHNlLCBzZXRUaW1lb3V0OiBmYWxzZSwgY29uc29sZTogZmFsc2UgKi9cbihmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgYXN5bmMgPSB7fTtcblxuICAgIC8vIGdsb2JhbCBvbiB0aGUgc2VydmVyLCB3aW5kb3cgaW4gdGhlIGJyb3dzZXJcbiAgICB2YXIgcm9vdCwgcHJldmlvdXNfYXN5bmM7XG5cbiAgICByb290ID0gdGhpcztcbiAgICBpZiAocm9vdCAhPSBudWxsKSB7XG4gICAgICBwcmV2aW91c19hc3luYyA9IHJvb3QuYXN5bmM7XG4gICAgfVxuXG4gICAgYXN5bmMubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcm9vdC5hc3luYyA9IHByZXZpb3VzX2FzeW5jO1xuICAgICAgICByZXR1cm4gYXN5bmM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG9ubHlfb25jZShmbikge1xuICAgICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChjYWxsZWQpIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIHdhcyBhbHJlYWR5IGNhbGxlZC5cIik7XG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm4uYXBwbHkocm9vdCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vLy8gY3Jvc3MtYnJvd3NlciBjb21wYXRpYmxpdHkgZnVuY3Rpb25zIC8vLy9cblxuICAgIHZhciBfZWFjaCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yKSB7XG4gICAgICAgIGlmIChhcnIuZm9yRWFjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5mb3JFYWNoKGl0ZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaXRlcmF0b3IoYXJyW2ldLCBpLCBhcnIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBfbWFwID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IpIHtcbiAgICAgICAgaWYgKGFyci5tYXApIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIubWFwKGl0ZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBpLCBhKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goaXRlcmF0b3IoeCwgaSwgYSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcblxuICAgIHZhciBfcmVkdWNlID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIG1lbW8pIHtcbiAgICAgICAgaWYgKGFyci5yZWR1Y2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIucmVkdWNlKGl0ZXJhdG9yLCBtZW1vKTtcbiAgICAgICAgfVxuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBpLCBhKSB7XG4gICAgICAgICAgICBtZW1vID0gaXRlcmF0b3IobWVtbywgeCwgaSwgYSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuXG4gICAgdmFyIF9rZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH07XG5cbiAgICAvLy8vIGV4cG9ydGVkIGFzeW5jIG1vZHVsZSBmdW5jdGlvbnMgLy8vL1xuXG4gICAgLy8vLyBuZXh0VGljayBpbXBsZW1lbnRhdGlvbiB3aXRoIGJyb3dzZXItY29tcGF0aWJsZSBmYWxsYmFjayAvLy8vXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCAhKHByb2Nlc3MubmV4dFRpY2spKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIC8vIG5vdCBhIGRpcmVjdCBhbGlhcyBmb3IgSUUxMCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzeW5jLm5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgLy8gbm90IGEgZGlyZWN0IGFsaWFzIGZvciBJRTEwIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jLmVhY2ggPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgb25seV9vbmNlKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5mb3JFYWNoID0gYXN5bmMuZWFjaDtcblxuICAgIGFzeW5jLmVhY2hTZXJpZXMgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcbiAgICAgICAgdmFyIGl0ZXJhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihhcnJbY29tcGxldGVkXSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGl0ZXJhdGUoKTtcbiAgICB9O1xuICAgIGFzeW5jLmZvckVhY2hTZXJpZXMgPSBhc3luYy5lYWNoU2VyaWVzO1xuXG4gICAgYXN5bmMuZWFjaExpbWl0ID0gZnVuY3Rpb24gKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZm4gPSBfZWFjaExpbWl0KGxpbWl0KTtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgW2FyciwgaXRlcmF0b3IsIGNhbGxiYWNrXSk7XG4gICAgfTtcbiAgICBhc3luYy5mb3JFYWNoTGltaXQgPSBhc3luYy5lYWNoTGltaXQ7XG5cbiAgICB2YXIgX2VhY2hMaW1pdCA9IGZ1bmN0aW9uIChsaW1pdCkge1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICBpZiAoIWFyci5sZW5ndGggfHwgbGltaXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gICAgICAgICAgICB2YXIgc3RhcnRlZCA9IDA7XG4gICAgICAgICAgICB2YXIgcnVubmluZyA9IDA7XG5cbiAgICAgICAgICAgIChmdW5jdGlvbiByZXBsZW5pc2ggKCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocnVubmluZyA8IGxpbWl0ICYmIHN0YXJ0ZWQgPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvcihhcnJbc3RhcnRlZCAtIDFdLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9O1xuICAgIH07XG5cblxuICAgIHZhciBkb1BhcmFsbGVsID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW2FzeW5jLmVhY2hdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgZG9QYXJhbGxlbExpbWl0ID0gZnVuY3Rpb24obGltaXQsIGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW19lYWNoTGltaXQobGltaXQpXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIGRvU2VyaWVzID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW2FzeW5jLmVhY2hTZXJpZXNdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuXG4gICAgdmFyIF9hc3luY01hcCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAoZXJyLCB2KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t4LmluZGV4XSA9IHY7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLm1hcCA9IGRvUGFyYWxsZWwoX2FzeW5jTWFwKTtcbiAgICBhc3luYy5tYXBTZXJpZXMgPSBkb1NlcmllcyhfYXN5bmNNYXApO1xuICAgIGFzeW5jLm1hcExpbWl0ID0gZnVuY3Rpb24gKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX21hcExpbWl0KGxpbWl0KShhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIHZhciBfbWFwTGltaXQgPSBmdW5jdGlvbihsaW1pdCkge1xuICAgICAgICByZXR1cm4gZG9QYXJhbGxlbExpbWl0KGxpbWl0LCBfYXN5bmNNYXApO1xuICAgIH07XG5cbiAgICAvLyByZWR1Y2Ugb25seSBoYXMgYSBzZXJpZXMgdmVyc2lvbiwgYXMgZG9pbmcgcmVkdWNlIGluIHBhcmFsbGVsIHdvbid0XG4gICAgLy8gd29yayBpbiBtYW55IHNpdHVhdGlvbnMuXG4gICAgYXN5bmMucmVkdWNlID0gZnVuY3Rpb24gKGFyciwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKG1lbW8sIHgsIGZ1bmN0aW9uIChlcnIsIHYpIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gdjtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbWVtbyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gaW5qZWN0IGFsaWFzXG4gICAgYXN5bmMuaW5qZWN0ID0gYXN5bmMucmVkdWNlO1xuICAgIC8vIGZvbGRsIGFsaWFzXG4gICAgYXN5bmMuZm9sZGwgPSBhc3luYy5yZWR1Y2U7XG5cbiAgICBhc3luYy5yZWR1Y2VSaWdodCA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmV2ZXJzZWQgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9KS5yZXZlcnNlKCk7XG4gICAgICAgIGFzeW5jLnJlZHVjZShyZXZlcnNlZCwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8vIGZvbGRyIGFsaWFzXG4gICAgYXN5bmMuZm9sZHIgPSBhc3luYy5yZWR1Y2VSaWdodDtcblxuICAgIHZhciBfZmlsdGVyID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgYXJyID0gX21hcChhcnIsIGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpLCB2YWx1ZTogeH07XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKF9tYXAocmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICAgICAgfSksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuZmlsdGVyID0gZG9QYXJhbGxlbChfZmlsdGVyKTtcbiAgICBhc3luYy5maWx0ZXJTZXJpZXMgPSBkb1NlcmllcyhfZmlsdGVyKTtcbiAgICAvLyBzZWxlY3QgYWxpYXNcbiAgICBhc3luYy5zZWxlY3QgPSBhc3luYy5maWx0ZXI7XG4gICAgYXN5bmMuc2VsZWN0U2VyaWVzID0gYXN5bmMuZmlsdGVyU2VyaWVzO1xuXG4gICAgdmFyIF9yZWplY3QgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGksIHZhbHVlOiB4fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKF9tYXAocmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICAgICAgfSksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMucmVqZWN0ID0gZG9QYXJhbGxlbChfcmVqZWN0KTtcbiAgICBhc3luYy5yZWplY3RTZXJpZXMgPSBkb1NlcmllcyhfcmVqZWN0KTtcblxuICAgIHZhciBfZGV0ZWN0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2soeCk7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5kZXRlY3QgPSBkb1BhcmFsbGVsKF9kZXRlY3QpO1xuICAgIGFzeW5jLmRldGVjdFNlcmllcyA9IGRvU2VyaWVzKF9kZXRlY3QpO1xuXG4gICAgYXN5bmMuc29tZSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2goYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGFueSBhbGlhc1xuICAgIGFzeW5jLmFueSA9IGFzeW5jLnNvbWU7XG5cbiAgICBhc3luYy5ldmVyeSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2goYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBhbGwgYWxpYXNcbiAgICBhc3luYy5hbGwgPSBhc3luYy5ldmVyeTtcblxuICAgIGFzeW5jLnNvcnRCeSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBhc3luYy5tYXAoYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uIChlcnIsIGNyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwge3ZhbHVlOiB4LCBjcml0ZXJpYTogY3JpdGVyaWF9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYSwgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBfbWFwKHJlc3VsdHMuc29ydChmbiksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLmF1dG8gPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIHZhciBrZXlzID0gX2tleXModGFza3MpO1xuICAgICAgICBpZiAoIWtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdmFyIGFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChmbik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldID09PSBmbikge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGFza0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX2VhY2gobGlzdGVuZXJzLnNsaWNlKDApLCBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYWRkTGlzdGVuZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF9rZXlzKHJlc3VsdHMpLmxlbmd0aCA9PT0ga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBfZWFjaChrZXlzLCBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSAodGFza3Nba10gaW5zdGFuY2VvZiBGdW5jdGlvbikgPyBbdGFza3Nba11dOiB0YXNrc1trXTtcbiAgICAgICAgICAgIHZhciB0YXNrQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYWZlUmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBfZWFjaChfa2V5cyhyZXN1bHRzKSwgZnVuY3Rpb24ocmtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNbcmtleV0gPSByZXN1bHRzW3JrZXldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHNhZmVSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBzdWJzZXF1ZW50IGVycm9ycyBoaXR0aW5nIGNhbGxiYWNrIG11bHRpcGxlIHRpbWVzXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHRhc2tDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByZXF1aXJlcyA9IHRhc2suc2xpY2UoMCwgTWF0aC5hYnModGFzay5sZW5ndGggLSAxKSkgfHwgW107XG4gICAgICAgICAgICB2YXIgcmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWR1Y2UocmVxdWlyZXMsIGZ1bmN0aW9uIChhLCB4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoYSAmJiByZXN1bHRzLmhhc093blByb3BlcnR5KHgpKTtcbiAgICAgICAgICAgICAgICB9LCB0cnVlKSAmJiAhcmVzdWx0cy5oYXNPd25Qcm9wZXJ0eShrKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmVhZHkoKSkge1xuICAgICAgICAgICAgICAgIHRhc2tbdGFzay5sZW5ndGggLSAxXSh0YXNrQ2FsbGJhY2ssIHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVhZHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFza1t0YXNrLmxlbmd0aCAtIDFdKHRhc2tDYWxsYmFjaywgcmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLndhdGVyZmFsbCA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKHRhc2tzLmNvbnN0cnVjdG9yICE9PSBBcnJheSkge1xuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHdhdGVyZmFsbCBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucycpO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd3JhcEl0ZXJhdG9yID0gZnVuY3Rpb24gKGl0ZXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2god3JhcEl0ZXJhdG9yKG5leHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB3cmFwSXRlcmF0b3IoYXN5bmMuaXRlcmF0b3IodGFza3MpKSgpO1xuICAgIH07XG5cbiAgICB2YXIgX3BhcmFsbGVsID0gZnVuY3Rpb24oZWFjaGZuLCB0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKHRhc2tzLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgZWFjaGZuLm1hcCh0YXNrcywgZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgICAgICBmbihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBlcnIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgZWFjaGZuLmVhY2goX2tleXModGFza3MpLCBmdW5jdGlvbiAoaywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0YXNrc1trXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5wYXJhbGxlbCA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgX3BhcmFsbGVsKHsgbWFwOiBhc3luYy5tYXAsIGVhY2g6IGFzeW5jLmVhY2ggfSwgdGFza3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMucGFyYWxsZWxMaW1pdCA9IGZ1bmN0aW9uKHRhc2tzLCBsaW1pdCwgY2FsbGJhY2spIHtcbiAgICAgICAgX3BhcmFsbGVsKHsgbWFwOiBfbWFwTGltaXQobGltaXQpLCBlYWNoOiBfZWFjaExpbWl0KGxpbWl0KSB9LCB0YXNrcywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5zZXJpZXMgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICh0YXNrcy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgIGFzeW5jLm1hcFNlcmllcyh0YXNrcywgZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgICAgICBmbihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBlcnIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhfa2V5cyh0YXNrcyksIGZ1bmN0aW9uIChrLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRhc2tzW2tdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLml0ZXJhdG9yID0gZnVuY3Rpb24gKHRhc2tzKSB7XG4gICAgICAgIHZhciBtYWtlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzW2luZGV4XS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZm4ubmV4dCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZuLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpbmRleCA8IHRhc2tzLmxlbmd0aCAtIDEpID8gbWFrZUNhbGxiYWNrKGluZGV4ICsgMSk6IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbWFrZUNhbGxiYWNrKDApO1xuICAgIH07XG5cbiAgICBhc3luYy5hcHBseSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoXG4gICAgICAgICAgICAgICAgbnVsbCwgYXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfY29uY2F0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNiKSB7XG4gICAgICAgICAgICBmbih4LCBmdW5jdGlvbiAoZXJyLCB5KSB7XG4gICAgICAgICAgICAgICAgciA9IHIuY29uY2F0KHkgfHwgW10pO1xuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5jb25jYXQgPSBkb1BhcmFsbGVsKF9jb25jYXQpO1xuICAgIGFzeW5jLmNvbmNhdFNlcmllcyA9IGRvU2VyaWVzKF9jb25jYXQpO1xuXG4gICAgYXN5bmMud2hpbHN0ID0gZnVuY3Rpb24gKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGVzdCgpKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXN5bmMud2hpbHN0KHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuZG9XaGlsc3QgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXN0KCkpIHtcbiAgICAgICAgICAgICAgICBhc3luYy5kb1doaWxzdChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLnVudGlsID0gZnVuY3Rpb24gKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRlc3QoKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzeW5jLnVudGlsKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuZG9VbnRpbCA9IGZ1bmN0aW9uIChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0ZXN0KCkpIHtcbiAgICAgICAgICAgICAgICBhc3luYy5kb1VudGlsKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMucXVldWUgPSBmdW5jdGlvbiAod29ya2VyLCBjb25jdXJyZW5jeSkge1xuICAgICAgICBpZiAoY29uY3VycmVuY3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uY3VycmVuY3kgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF9pbnNlcnQocSwgZGF0YSwgcG9zLCBjYWxsYmFjaykge1xuICAgICAgICAgIGlmKGRhdGEuY29uc3RydWN0b3IgIT09IEFycmF5KSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgICAgfVxuICAgICAgICAgIF9lYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcbiAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbnVsbFxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICBxLnRhc2tzLnVuc2hpZnQoaXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcS50YXNrcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHEuc2F0dXJhdGVkICYmIHEudGFza3MubGVuZ3RoID09PSBjb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUocS5wcm9jZXNzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3b3JrZXJzID0gMDtcbiAgICAgICAgdmFyIHEgPSB7XG4gICAgICAgICAgICB0YXNrczogW10sXG4gICAgICAgICAgICBjb25jdXJyZW5jeTogY29uY3VycmVuY3ksXG4gICAgICAgICAgICBzYXR1cmF0ZWQ6IG51bGwsXG4gICAgICAgICAgICBlbXB0eTogbnVsbCxcbiAgICAgICAgICAgIGRyYWluOiBudWxsLFxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNoaWZ0OiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgX2luc2VydChxLCBkYXRhLCB0cnVlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh3b3JrZXJzIDwgcS5jb25jdXJyZW5jeSAmJiBxLnRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFzayA9IHEudGFza3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHEuZW1wdHkgJiYgcS50YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHEuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3b3JrZXJzICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VycyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhc2suY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLmNhbGxiYWNrLmFwcGx5KHRhc2ssIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocS5kcmFpbiAmJiBxLnRhc2tzLmxlbmd0aCArIHdvcmtlcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNiID0gb25seV9vbmNlKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXIodGFzay5kYXRhLCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxLnRhc2tzLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW5uaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBxO1xuICAgIH07XG5cbiAgICBhc3luYy5jYXJnbyA9IGZ1bmN0aW9uICh3b3JrZXIsIHBheWxvYWQpIHtcbiAgICAgICAgdmFyIHdvcmtpbmcgICAgID0gZmFsc2UsXG4gICAgICAgICAgICB0YXNrcyAgICAgICA9IFtdO1xuXG4gICAgICAgIHZhciBjYXJnbyA9IHtcbiAgICAgICAgICAgIHRhc2tzOiB0YXNrcyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICBzYXR1cmF0ZWQ6IG51bGwsXG4gICAgICAgICAgICBlbXB0eTogbnVsbCxcbiAgICAgICAgICAgIGRyYWluOiBudWxsLFxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYoZGF0YS5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2VhY2goZGF0YSwgZnVuY3Rpb24odGFzaykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRhc2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FyZ28uc2F0dXJhdGVkICYmIHRhc2tzLmxlbmd0aCA9PT0gcGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZ28uc2F0dXJhdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUoY2FyZ28ucHJvY2Vzcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICAgICAgICAgICAgICBpZiAod29ya2luZykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh0YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoY2FyZ28uZHJhaW4pIGNhcmdvLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdHMgPSB0eXBlb2YgcGF5bG9hZCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRhc2tzLnNwbGljZSgwLCBwYXlsb2FkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGFza3Muc3BsaWNlKDApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRzID0gX21hcCh0cywgZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2suZGF0YTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmKGNhcmdvLmVtcHR5KSBjYXJnby5lbXB0eSgpO1xuICAgICAgICAgICAgICAgIHdvcmtpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdvcmtlcihkcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JraW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIF9lYWNoKHRzLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhc2tzLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW5uaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYXJnbztcbiAgICB9O1xuXG4gICAgdmFyIF9jb25zb2xlX2ZuID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW2Z1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25zb2xlW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZWFjaChhcmdzLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVbbmFtZV0oeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBhc3luYy5sb2cgPSBfY29uc29sZV9mbignbG9nJyk7XG4gICAgYXN5bmMuZGlyID0gX2NvbnNvbGVfZm4oJ2RpcicpO1xuICAgIC8qYXN5bmMuaW5mbyA9IF9jb25zb2xlX2ZuKCdpbmZvJyk7XG4gICAgYXN5bmMud2FybiA9IF9jb25zb2xlX2ZuKCd3YXJuJyk7XG4gICAgYXN5bmMuZXJyb3IgPSBfY29uc29sZV9mbignZXJyb3InKTsqL1xuXG4gICAgYXN5bmMubWVtb2l6ZSA9IGZ1bmN0aW9uIChmbiwgaGFzaGVyKSB7XG4gICAgICAgIHZhciBtZW1vID0ge307XG4gICAgICAgIHZhciBxdWV1ZXMgPSB7fTtcbiAgICAgICAgaGFzaGVyID0gaGFzaGVyIHx8IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICBpZiAoa2V5IGluIG1lbW8pIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBtZW1vW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5IGluIHF1ZXVlcykge1xuICAgICAgICAgICAgICAgIHF1ZXVlc1trZXldLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVldWVzW2tleV0gPSBbY2FsbGJhY2tdO1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBxdWV1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcVtpXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbWVtb2l6ZWQubWVtbyA9IG1lbW87XG4gICAgICAgIG1lbW9pemVkLnVubWVtb2l6ZWQgPSBmbjtcbiAgICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH07XG5cbiAgICBhc3luYy51bm1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoZm4udW5tZW1vaXplZCB8fCBmbikuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGFzeW5jLnRpbWVzID0gZnVuY3Rpb24gKGNvdW50LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzeW5jLm1hcChjb3VudGVyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy50aW1lc1NlcmllcyA9IGZ1bmN0aW9uIChjb3VudCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjb3VudGVyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY291bnRlci5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3luYy5tYXBTZXJpZXMoY291bnRlciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuY29tcG9zZSA9IGZ1bmN0aW9uICgvKiBmdW5jdGlvbnMuLi4gKi8pIHtcbiAgICAgICAgdmFyIGZucyA9IEFycmF5LnByb3RvdHlwZS5yZXZlcnNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICBhc3luYy5yZWR1Y2UoZm5zLCBhcmdzLCBmdW5jdGlvbiAobmV3YXJncywgZm4sIGNiKSB7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgbmV3YXJncy5jb25jYXQoW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY2IoZXJyLCBuZXh0YXJncyk7XG4gICAgICAgICAgICAgICAgfV0pKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGF0LCBbZXJyXS5jb25jYXQocmVzdWx0cykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfYXBwbHlFYWNoID0gZnVuY3Rpb24gKGVhY2hmbiwgZm5zIC8qYXJncy4uLiovKSB7XG4gICAgICAgIHZhciBnbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gZWFjaGZuKGZucywgZnVuY3Rpb24gKGZuLCBjYikge1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MuY29uY2F0KFtjYl0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIGdvLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdvO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBhc3luYy5hcHBseUVhY2ggPSBkb1BhcmFsbGVsKF9hcHBseUVhY2gpO1xuICAgIGFzeW5jLmFwcGx5RWFjaFNlcmllcyA9IGRvU2VyaWVzKF9hcHBseUVhY2gpO1xuXG4gICAgYXN5bmMuZm9yZXZlciA9IGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgZnVuY3Rpb24gbmV4dChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZuKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICB9O1xuXG4gICAgLy8gQU1EIC8gUmVxdWlyZUpTXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBOb2RlLmpzXG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhc3luYztcbiAgICB9XG4gICAgLy8gaW5jbHVkZWQgZGlyZWN0bHkgdmlhIDxzY3JpcHQ+IHRhZ1xuICAgIGVsc2Uge1xuICAgICAgICByb290LmFzeW5jID0gYXN5bmM7XG4gICAgfVxuXG59KCkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGVzY2FwZVN0cmluZ1JlZ2V4cCA9IHJlcXVpcmUoJ2VzY2FwZS1zdHJpbmctcmVnZXhwJyk7XG52YXIgYW5zaVN0eWxlcyA9IHJlcXVpcmUoJ2Fuc2ktc3R5bGVzJyk7XG52YXIgc3RyaXBBbnNpID0gcmVxdWlyZSgnc3RyaXAtYW5zaScpO1xudmFyIGhhc0Fuc2kgPSByZXF1aXJlKCdoYXMtYW5zaScpO1xudmFyIHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xudmFyIGRlZmluZVByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgaXNTaW1wbGVXaW5kb3dzVGVybSA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgJiYgIS9eeHRlcm0vaS50ZXN0KHByb2Nlc3MuZW52LlRFUk0pO1xuXG5mdW5jdGlvbiBDaGFsayhvcHRpb25zKSB7XG5cdC8vIGRldGVjdCBtb2RlIGlmIG5vdCBzZXQgbWFudWFsbHlcblx0dGhpcy5lbmFibGVkID0gIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmFibGVkID09PSB1bmRlZmluZWQgPyBzdXBwb3J0c0NvbG9yIDogb3B0aW9ucy5lbmFibGVkO1xufVxuXG4vLyB1c2UgYnJpZ2h0IGJsdWUgb24gV2luZG93cyBhcyB0aGUgbm9ybWFsIGJsdWUgY29sb3IgaXMgaWxsZWdpYmxlXG5pZiAoaXNTaW1wbGVXaW5kb3dzVGVybSkge1xuXHRhbnNpU3R5bGVzLmJsdWUub3BlbiA9ICdcXHUwMDFiWzk0bSc7XG59XG5cbnZhciBzdHlsZXMgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgcmV0ID0ge307XG5cblx0T2JqZWN0LmtleXMoYW5zaVN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0YW5zaVN0eWxlc1trZXldLmNsb3NlUmUgPSBuZXcgUmVnRXhwKGVzY2FwZVN0cmluZ1JlZ2V4cChhbnNpU3R5bGVzW2tleV0uY2xvc2UpLCAnZycpO1xuXG5cdFx0cmV0W2tleV0gPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGJ1aWxkLmNhbGwodGhpcywgdGhpcy5fc3R5bGVzLmNvbmNhdChrZXkpKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcblxuXHRyZXR1cm4gcmV0O1xufSkoKTtcblxudmFyIHByb3RvID0gZGVmaW5lUHJvcHMoZnVuY3Rpb24gY2hhbGsoKSB7fSwgc3R5bGVzKTtcblxuZnVuY3Rpb24gYnVpbGQoX3N0eWxlcykge1xuXHR2YXIgYnVpbGRlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gYXBwbHlTdHlsZS5hcHBseShidWlsZGVyLCBhcmd1bWVudHMpO1xuXHR9O1xuXG5cdGJ1aWxkZXIuX3N0eWxlcyA9IF9zdHlsZXM7XG5cdGJ1aWxkZXIuZW5hYmxlZCA9IHRoaXMuZW5hYmxlZDtcblx0Ly8gX19wcm90b19fIGlzIHVzZWQgYmVjYXVzZSB3ZSBtdXN0IHJldHVybiBhIGZ1bmN0aW9uLCBidXQgdGhlcmUgaXNcblx0Ly8gbm8gd2F5IHRvIGNyZWF0ZSBhIGZ1bmN0aW9uIHdpdGggYSBkaWZmZXJlbnQgcHJvdG90eXBlLlxuXHQvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXHRidWlsZGVyLl9fcHJvdG9fXyA9IHByb3RvO1xuXG5cdHJldHVybiBidWlsZGVyO1xufVxuXG5mdW5jdGlvbiBhcHBseVN0eWxlKCkge1xuXHQvLyBzdXBwb3J0IHZhcmFncywgYnV0IHNpbXBseSBjYXN0IHRvIHN0cmluZyBpbiBjYXNlIHRoZXJlJ3Mgb25seSBvbmUgYXJnXG5cdHZhciBhcmdzID0gYXJndW1lbnRzO1xuXHR2YXIgYXJnc0xlbiA9IGFyZ3MubGVuZ3RoO1xuXHR2YXIgc3RyID0gYXJnc0xlbiAhPT0gMCAmJiBTdHJpbmcoYXJndW1lbnRzWzBdKTtcblxuXHRpZiAoYXJnc0xlbiA+IDEpIHtcblx0XHQvLyBkb24ndCBzbGljZSBgYXJndW1lbnRzYCwgaXQgcHJldmVudHMgdjggb3B0aW1pemF0aW9uc1xuXHRcdGZvciAodmFyIGEgPSAxOyBhIDwgYXJnc0xlbjsgYSsrKSB7XG5cdFx0XHRzdHIgKz0gJyAnICsgYXJnc1thXTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIXRoaXMuZW5hYmxlZCB8fCAhc3RyKSB7XG5cdFx0cmV0dXJuIHN0cjtcblx0fVxuXG5cdHZhciBuZXN0ZWRTdHlsZXMgPSB0aGlzLl9zdHlsZXM7XG5cdHZhciBpID0gbmVzdGVkU3R5bGVzLmxlbmd0aDtcblxuXHQvLyBUdXJucyBvdXQgdGhhdCBvbiBXaW5kb3dzIGRpbW1lZCBncmF5IHRleHQgYmVjb21lcyBpbnZpc2libGUgaW4gY21kLmV4ZSxcblx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFsay9jaGFsay9pc3N1ZXMvNThcblx0Ly8gSWYgd2UncmUgb24gV2luZG93cyBhbmQgd2UncmUgZGVhbGluZyB3aXRoIGEgZ3JheSBjb2xvciwgdGVtcG9yYXJpbHkgbWFrZSAnZGltJyBhIG5vb3AuXG5cdHZhciBvcmlnaW5hbERpbSA9IGFuc2lTdHlsZXMuZGltLm9wZW47XG5cdGlmIChpc1NpbXBsZVdpbmRvd3NUZXJtICYmIChuZXN0ZWRTdHlsZXMuaW5kZXhPZignZ3JheScpICE9PSAtMSB8fCBuZXN0ZWRTdHlsZXMuaW5kZXhPZignZ3JleScpICE9PSAtMSkpIHtcblx0XHRhbnNpU3R5bGVzLmRpbS5vcGVuID0gJyc7XG5cdH1cblxuXHR3aGlsZSAoaS0tKSB7XG5cdFx0dmFyIGNvZGUgPSBhbnNpU3R5bGVzW25lc3RlZFN0eWxlc1tpXV07XG5cblx0XHQvLyBSZXBsYWNlIGFueSBpbnN0YW5jZXMgYWxyZWFkeSBwcmVzZW50IHdpdGggYSByZS1vcGVuaW5nIGNvZGVcblx0XHQvLyBvdGhlcndpc2Ugb25seSB0aGUgcGFydCBvZiB0aGUgc3RyaW5nIHVudGlsIHNhaWQgY2xvc2luZyBjb2RlXG5cdFx0Ly8gd2lsbCBiZSBjb2xvcmVkLCBhbmQgdGhlIHJlc3Qgd2lsbCBzaW1wbHkgYmUgJ3BsYWluJy5cblx0XHRzdHIgPSBjb2RlLm9wZW4gKyBzdHIucmVwbGFjZShjb2RlLmNsb3NlUmUsIGNvZGUub3BlbikgKyBjb2RlLmNsb3NlO1xuXHR9XG5cblx0Ly8gUmVzZXQgdGhlIG9yaWdpbmFsICdkaW0nIGlmIHdlIGNoYW5nZWQgaXQgdG8gd29yayBhcm91bmQgdGhlIFdpbmRvd3MgZGltbWVkIGdyYXkgaXNzdWUuXG5cdGFuc2lTdHlsZXMuZGltLm9wZW4gPSBvcmlnaW5hbERpbTtcblxuXHRyZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiBpbml0KCkge1xuXHR2YXIgcmV0ID0ge307XG5cblx0T2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0W25hbWVdID0ge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBidWlsZC5jYWxsKHRoaXMsIFtuYW1lXSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG5cblx0cmV0dXJuIHJldDtcbn1cblxuZGVmaW5lUHJvcHMoQ2hhbGsucHJvdG90eXBlLCBpbml0KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBDaGFsaygpO1xubW9kdWxlLmV4cG9ydHMuc3R5bGVzID0gYW5zaVN0eWxlcztcbm1vZHVsZS5leHBvcnRzLmhhc0NvbG9yID0gaGFzQW5zaTtcbm1vZHVsZS5leHBvcnRzLnN0cmlwQ29sb3IgPSBzdHJpcEFuc2k7XG5tb2R1bGUuZXhwb3J0cy5zdXBwb3J0c0NvbG9yID0gc3VwcG9ydHNDb2xvcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhcmd2ID0gcHJvY2Vzcy5hcmd2O1xuXG52YXIgdGVybWluYXRvciA9IGFyZ3YuaW5kZXhPZignLS0nKTtcbnZhciBoYXNGbGFnID0gZnVuY3Rpb24gKGZsYWcpIHtcblx0ZmxhZyA9ICctLScgKyBmbGFnO1xuXHR2YXIgcG9zID0gYXJndi5pbmRleE9mKGZsYWcpO1xuXHRyZXR1cm4gcG9zICE9PSAtMSAmJiAodGVybWluYXRvciAhPT0gLTEgPyBwb3MgPCB0ZXJtaW5hdG9yIDogdHJ1ZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG5cdGlmICgnRk9SQ0VfQ09MT1InIGluIHByb2Nlc3MuZW52KSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoaGFzRmxhZygnbm8tY29sb3InKSB8fFxuXHRcdGhhc0ZsYWcoJ25vLWNvbG9ycycpIHx8XG5cdFx0aGFzRmxhZygnY29sb3I9ZmFsc2UnKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcicpIHx8XG5cdFx0aGFzRmxhZygnY29sb3JzJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj10cnVlJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj1hbHdheXMnKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKHByb2Nlc3Muc3Rkb3V0ICYmICFwcm9jZXNzLnN0ZG91dC5pc1RUWSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoJ0NPTE9SVEVSTScgaW4gcHJvY2Vzcy5lbnYpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmIChwcm9jZXNzLmVudi5URVJNID09PSAnZHVtYicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoL15zY3JlZW58Xnh0ZXJtfF52dDEwMHxjb2xvcnxhbnNpfGN5Z3dpbnxsaW51eC9pLnRlc3QocHJvY2Vzcy5lbnYuVEVSTSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn0pKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXRjaE9wZXJhdG9yc1JlID0gL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0aWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcblx0fVxuXG5cdHJldHVybiBzdHIucmVwbGFjZShtYXRjaE9wZXJhdG9yc1JlLCAnXFxcXCQmJyk7XG59O1xuIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJlc3ByaW1hXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImVzcHJpbWFcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG5cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHQvKlxyXG5cdCAgQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycywgaHR0cHM6Ly9qcy5mb3VuZGF0aW9uL1xyXG5cclxuXHQgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxyXG5cdCAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcblxyXG5cdCAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XHJcblx0ICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG5cdCAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XHJcblx0ICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxyXG5cdCAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcblxyXG5cdCAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcclxuXHQgIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcclxuXHQgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXHJcblx0ICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXHJcblx0ICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xyXG5cdCAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xyXG5cdCAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXHJcblx0ICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxyXG5cdCAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXHJcblx0ICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG5cdCovXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBjb21tZW50X2hhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblx0dmFyIGpzeF9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblx0dmFyIHBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuXHR2YXIgdG9rZW5pemVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcclxuXHRmdW5jdGlvbiBwYXJzZShjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xyXG5cdCAgICB2YXIgY29tbWVudEhhbmRsZXIgPSBudWxsO1xyXG5cdCAgICB2YXIgcHJveHlEZWxlZ2F0ZSA9IGZ1bmN0aW9uIChub2RlLCBtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgaWYgKGRlbGVnYXRlKSB7XHJcblx0ICAgICAgICAgICAgZGVsZWdhdGUobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNvbW1lbnRIYW5kbGVyKSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudEhhbmRsZXIudmlzaXQobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICB2YXIgcGFyc2VyRGVsZWdhdGUgPSAodHlwZW9mIGRlbGVnYXRlID09PSAnZnVuY3Rpb24nKSA/IHByb3h5RGVsZWdhdGUgOiBudWxsO1xyXG5cdCAgICB2YXIgY29sbGVjdENvbW1lbnQgPSBmYWxzZTtcclxuXHQgICAgaWYgKG9wdGlvbnMpIHtcclxuXHQgICAgICAgIGNvbGxlY3RDb21tZW50ID0gKHR5cGVvZiBvcHRpb25zLmNvbW1lbnQgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLmNvbW1lbnQpO1xyXG5cdCAgICAgICAgdmFyIGF0dGFjaENvbW1lbnQgPSAodHlwZW9mIG9wdGlvbnMuYXR0YWNoQ29tbWVudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMuYXR0YWNoQ29tbWVudCk7XHJcblx0ICAgICAgICBpZiAoY29sbGVjdENvbW1lbnQgfHwgYXR0YWNoQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRIYW5kbGVyID0gbmV3IGNvbW1lbnRfaGFuZGxlcl8xLkNvbW1lbnRIYW5kbGVyKCk7XHJcblx0ICAgICAgICAgICAgY29tbWVudEhhbmRsZXIuYXR0YWNoID0gYXR0YWNoQ29tbWVudDtcclxuXHQgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIHBhcnNlckRlbGVnYXRlID0gcHJveHlEZWxlZ2F0ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICB2YXIgaXNNb2R1bGUgPSBmYWxzZTtcclxuXHQgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuc291cmNlVHlwZSA9PT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgIGlzTW9kdWxlID0gKG9wdGlvbnMuc291cmNlVHlwZSA9PT0gJ21vZHVsZScpO1xyXG5cdCAgICB9XHJcblx0ICAgIHZhciBwYXJzZXI7XHJcblx0ICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLmpzeCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMuanN4KSB7XHJcblx0ICAgICAgICBwYXJzZXIgPSBuZXcganN4X3BhcnNlcl8xLkpTWFBhcnNlcihjb2RlLCBvcHRpb25zLCBwYXJzZXJEZWxlZ2F0ZSk7XHJcblx0ICAgIH1cclxuXHQgICAgZWxzZSB7XHJcblx0ICAgICAgICBwYXJzZXIgPSBuZXcgcGFyc2VyXzEuUGFyc2VyKGNvZGUsIG9wdGlvbnMsIHBhcnNlckRlbGVnYXRlKTtcclxuXHQgICAgfVxyXG5cdCAgICB2YXIgcHJvZ3JhbSA9IGlzTW9kdWxlID8gcGFyc2VyLnBhcnNlTW9kdWxlKCkgOiBwYXJzZXIucGFyc2VTY3JpcHQoKTtcclxuXHQgICAgdmFyIGFzdCA9IHByb2dyYW07XHJcblx0ICAgIGlmIChjb2xsZWN0Q29tbWVudCAmJiBjb21tZW50SGFuZGxlcikge1xyXG5cdCAgICAgICAgYXN0LmNvbW1lbnRzID0gY29tbWVudEhhbmRsZXIuY29tbWVudHM7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHBhcnNlci5jb25maWcudG9rZW5zKSB7XHJcblx0ICAgICAgICBhc3QudG9rZW5zID0gcGFyc2VyLnRva2VucztcclxuXHQgICAgfVxyXG5cdCAgICBpZiAocGFyc2VyLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgYXN0LmVycm9ycyA9IHBhcnNlci5lcnJvckhhbmRsZXIuZXJyb3JzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBhc3Q7XHJcblx0fVxyXG5cdGV4cG9ydHMucGFyc2UgPSBwYXJzZTtcclxuXHRmdW5jdGlvbiBwYXJzZU1vZHVsZShjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xyXG5cdCAgICB2YXIgcGFyc2luZ09wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdCAgICBwYXJzaW5nT3B0aW9ucy5zb3VyY2VUeXBlID0gJ21vZHVsZSc7XHJcblx0ICAgIHJldHVybiBwYXJzZShjb2RlLCBwYXJzaW5nT3B0aW9ucywgZGVsZWdhdGUpO1xyXG5cdH1cclxuXHRleHBvcnRzLnBhcnNlTW9kdWxlID0gcGFyc2VNb2R1bGU7XHJcblx0ZnVuY3Rpb24gcGFyc2VTY3JpcHQoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcclxuXHQgICAgdmFyIHBhcnNpbmdPcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQgICAgcGFyc2luZ09wdGlvbnMuc291cmNlVHlwZSA9ICdzY3JpcHQnO1xyXG5cdCAgICByZXR1cm4gcGFyc2UoY29kZSwgcGFyc2luZ09wdGlvbnMsIGRlbGVnYXRlKTtcclxuXHR9XHJcblx0ZXhwb3J0cy5wYXJzZVNjcmlwdCA9IHBhcnNlU2NyaXB0O1xyXG5cdGZ1bmN0aW9uIHRva2VuaXplKGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XHJcblx0ICAgIHZhciB0b2tlbml6ZXIgPSBuZXcgdG9rZW5pemVyXzEuVG9rZW5pemVyKGNvZGUsIG9wdGlvbnMpO1xyXG5cdCAgICB2YXIgdG9rZW5zO1xyXG5cdCAgICB0b2tlbnMgPSBbXTtcclxuXHQgICAgdHJ5IHtcclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5pemVyLmdldE5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGlmICghdG9rZW4pIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IGRlbGVnYXRlKHRva2VuKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICAgIGNhdGNoIChlKSB7XHJcblx0ICAgICAgICB0b2tlbml6ZXIuZXJyb3JIYW5kbGVyLnRvbGVyYXRlKGUpO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmICh0b2tlbml6ZXIuZXJyb3JIYW5kbGVyLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICB0b2tlbnMuZXJyb3JzID0gdG9rZW5pemVyLmVycm9ycygpO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiB0b2tlbnM7XHJcblx0fVxyXG5cdGV4cG9ydHMudG9rZW5pemUgPSB0b2tlbml6ZTtcclxuXHR2YXIgc3ludGF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cdGV4cG9ydHMuU3ludGF4ID0gc3ludGF4XzEuU3ludGF4O1xyXG5cdC8vIFN5bmMgd2l0aCAqLmpzb24gbWFuaWZlc3RzLlxyXG5cdGV4cG9ydHMudmVyc2lvbiA9ICc0LjAuMCc7XHJcblxuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBzeW50YXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblx0dmFyIENvbW1lbnRIYW5kbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ29tbWVudEhhbmRsZXIoKSB7XHJcblx0ICAgICAgICB0aGlzLmF0dGFjaCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5jb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5sZWFkaW5nID0gW107XHJcblx0ICAgICAgICB0aGlzLnRyYWlsaW5nID0gW107XHJcblx0ICAgIH1cclxuXHQgICAgQ29tbWVudEhhbmRsZXIucHJvdG90eXBlLmluc2VydElubmVyQ29tbWVudHMgPSBmdW5jdGlvbiAobm9kZSwgbWV0YWRhdGEpIHtcclxuXHQgICAgICAgIC8vICBpbm5uZXJDb21tZW50cyBmb3IgcHJvcGVydGllcyBlbXB0eSBibG9ja1xyXG5cdCAgICAgICAgLy8gIGBmdW5jdGlvbiBhKCkgey8qKiBjb21tZW50cyAqKlxcL31gXHJcblx0ICAgICAgICBpZiAobm9kZS50eXBlID09PSBzeW50YXhfMS5TeW50YXguQmxvY2tTdGF0ZW1lbnQgJiYgbm9kZS5ib2R5Lmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgIHZhciBpbm5lckNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVhZGluZy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmxlYWRpbmdbaV07XHJcblx0ICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YS5lbmQub2Zmc2V0ID49IGVudHJ5LnN0YXJ0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbm5lckNvbW1lbnRzLnVuc2hpZnQoZW50cnkuY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmxlYWRpbmcuc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFpbGluZy5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGlubmVyQ29tbWVudHMubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgIG5vZGUuaW5uZXJDb21tZW50cyA9IGlubmVyQ29tbWVudHM7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUuZmluZFRyYWlsaW5nQ29tbWVudHMgPSBmdW5jdGlvbiAobWV0YWRhdGEpIHtcclxuXHQgICAgICAgIHZhciB0cmFpbGluZ0NvbW1lbnRzID0gW107XHJcblx0ICAgICAgICBpZiAodGhpcy50cmFpbGluZy5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJhaWxpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGVudHJ5XzEgPSB0aGlzLnRyYWlsaW5nW2ldO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoZW50cnlfMS5zdGFydCA+PSBtZXRhZGF0YS5lbmQub2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLnVuc2hpZnQoZW50cnlfMS5jb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLnRyYWlsaW5nLmxlbmd0aCA9IDA7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRyYWlsaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XHJcblx0ICAgICAgICBpZiAoZW50cnkgJiYgZW50cnkubm9kZS50cmFpbGluZ0NvbW1lbnRzKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGZpcnN0Q29tbWVudCA9IGVudHJ5Lm5vZGUudHJhaWxpbmdDb21tZW50c1swXTtcclxuXHQgICAgICAgICAgICBpZiAoZmlyc3RDb21tZW50ICYmIGZpcnN0Q29tbWVudC5yYW5nZVswXSA+PSBtZXRhZGF0YS5lbmQub2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMgPSBlbnRyeS5ub2RlLnRyYWlsaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSBlbnRyeS5ub2RlLnRyYWlsaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRyYWlsaW5nQ29tbWVudHM7XHJcblx0ICAgIH07XHJcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS5maW5kTGVhZGluZ0NvbW1lbnRzID0gZnVuY3Rpb24gKG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICB2YXIgbGVhZGluZ0NvbW1lbnRzID0gW107XHJcblx0ICAgICAgICB2YXIgdGFyZ2V0O1xyXG5cdCAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcclxuXHQgICAgICAgICAgICBpZiAoZW50cnkgJiYgZW50cnkuc3RhcnQgPj0gbWV0YWRhdGEuc3RhcnQub2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRhcmdldCA9IGVudHJ5Lm5vZGU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNvdW50ID0gdGFyZ2V0LmxlYWRpbmdDb21tZW50cyA/IHRhcmdldC5sZWFkaW5nQ29tbWVudHMubGVuZ3RoIDogMDtcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gY291bnQgLSAxOyBpID49IDA7IC0taSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHRhcmdldC5sZWFkaW5nQ29tbWVudHNbaV07XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjb21tZW50LnJhbmdlWzFdIDw9IG1ldGFkYXRhLnN0YXJ0Lm9mZnNldCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzLnVuc2hpZnQoY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0YXJnZXQubGVhZGluZ0NvbW1lbnRzLnNwbGljZShpLCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAodGFyZ2V0LmxlYWRpbmdDb21tZW50cyAmJiB0YXJnZXQubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0LmxlYWRpbmdDb21tZW50cztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGxlYWRpbmdDb21tZW50cztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmxlYWRpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuXHQgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmxlYWRpbmdbaV07XHJcblx0ICAgICAgICAgICAgaWYgKGVudHJ5LnN0YXJ0IDw9IG1ldGFkYXRhLnN0YXJ0Lm9mZnNldCkge1xyXG5cdCAgICAgICAgICAgICAgICBsZWFkaW5nQ29tbWVudHMudW5zaGlmdChlbnRyeS5jb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5sZWFkaW5nLnNwbGljZShpLCAxKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gbGVhZGluZ0NvbW1lbnRzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUudmlzaXROb2RlID0gZnVuY3Rpb24gKG5vZGUsIG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICBpZiAobm9kZS50eXBlID09PSBzeW50YXhfMS5TeW50YXguUHJvZ3JhbSAmJiBub2RlLmJvZHkubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuaW5zZXJ0SW5uZXJDb21tZW50cyhub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB2YXIgdHJhaWxpbmdDb21tZW50cyA9IHRoaXMuZmluZFRyYWlsaW5nQ29tbWVudHMobWV0YWRhdGEpO1xyXG5cdCAgICAgICAgdmFyIGxlYWRpbmdDb21tZW50cyA9IHRoaXMuZmluZExlYWRpbmdDb21tZW50cyhtZXRhZGF0YSk7XHJcblx0ICAgICAgICBpZiAobGVhZGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IGxlYWRpbmdDb21tZW50cztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0cmFpbGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICBub2RlLnRyYWlsaW5nQ29tbWVudHMgPSB0cmFpbGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcclxuXHQgICAgICAgICAgICBub2RlOiBub2RlLFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBtZXRhZGF0YS5zdGFydC5vZmZzZXRcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICB9O1xyXG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKG5vZGUsIG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICB2YXIgdHlwZSA9IChub2RlLnR5cGVbMF0gPT09ICdMJykgPyAnTGluZScgOiAnQmxvY2snO1xyXG5cdCAgICAgICAgdmFyIGNvbW1lbnQgPSB7XHJcblx0ICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuXHQgICAgICAgICAgICB2YWx1ZTogbm9kZS52YWx1ZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIGlmIChub2RlLnJhbmdlKSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudC5yYW5nZSA9IG5vZGUucmFuZ2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAobm9kZS5sb2MpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50LmxvYyA9IG5vZGUubG9jO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuYXR0YWNoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG5cdCAgICAgICAgICAgICAgICBjb21tZW50OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5vZGUudmFsdWUsXHJcblx0ICAgICAgICAgICAgICAgICAgICByYW5nZTogW21ldGFkYXRhLnN0YXJ0Lm9mZnNldCwgbWV0YWRhdGEuZW5kLm9mZnNldF1cclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IG1ldGFkYXRhLnN0YXJ0Lm9mZnNldFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgaWYgKG5vZGUubG9jKSB7XHJcblx0ICAgICAgICAgICAgICAgIGVudHJ5LmNvbW1lbnQubG9jID0gbm9kZS5sb2M7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIG5vZGUudHlwZSA9IHR5cGU7XHJcblx0ICAgICAgICAgICAgdGhpcy5sZWFkaW5nLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgICAgIHRoaXMudHJhaWxpbmcucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uIChub2RlLCBtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0xpbmVDb21tZW50Jykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmlzaXRDb21tZW50KG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0Jsb2NrQ29tbWVudCcpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnZpc2l0Q29tbWVudChub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLmF0dGFjaCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmlzaXROb2RlKG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIENvbW1lbnRIYW5kbGVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Db21tZW50SGFuZGxlciA9IENvbW1lbnRIYW5kbGVyO1xyXG5cblxuLyoqKi8gfSxcbi8qIDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHRleHBvcnRzLlN5bnRheCA9IHtcclxuXHQgICAgQXNzaWdubWVudEV4cHJlc3Npb246ICdBc3NpZ25tZW50RXhwcmVzc2lvbicsXHJcblx0ICAgIEFzc2lnbm1lbnRQYXR0ZXJuOiAnQXNzaWdubWVudFBhdHRlcm4nLFxyXG5cdCAgICBBcnJheUV4cHJlc3Npb246ICdBcnJheUV4cHJlc3Npb24nLFxyXG5cdCAgICBBcnJheVBhdHRlcm46ICdBcnJheVBhdHRlcm4nLFxyXG5cdCAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJyxcclxuXHQgICAgQXdhaXRFeHByZXNzaW9uOiAnQXdhaXRFeHByZXNzaW9uJyxcclxuXHQgICAgQmxvY2tTdGF0ZW1lbnQ6ICdCbG9ja1N0YXRlbWVudCcsXHJcblx0ICAgIEJpbmFyeUV4cHJlc3Npb246ICdCaW5hcnlFeHByZXNzaW9uJyxcclxuXHQgICAgQnJlYWtTdGF0ZW1lbnQ6ICdCcmVha1N0YXRlbWVudCcsXHJcblx0ICAgIENhbGxFeHByZXNzaW9uOiAnQ2FsbEV4cHJlc3Npb24nLFxyXG5cdCAgICBDYXRjaENsYXVzZTogJ0NhdGNoQ2xhdXNlJyxcclxuXHQgICAgQ2xhc3NCb2R5OiAnQ2xhc3NCb2R5JyxcclxuXHQgICAgQ2xhc3NEZWNsYXJhdGlvbjogJ0NsYXNzRGVjbGFyYXRpb24nLFxyXG5cdCAgICBDbGFzc0V4cHJlc3Npb246ICdDbGFzc0V4cHJlc3Npb24nLFxyXG5cdCAgICBDb25kaXRpb25hbEV4cHJlc3Npb246ICdDb25kaXRpb25hbEV4cHJlc3Npb24nLFxyXG5cdCAgICBDb250aW51ZVN0YXRlbWVudDogJ0NvbnRpbnVlU3RhdGVtZW50JyxcclxuXHQgICAgRG9XaGlsZVN0YXRlbWVudDogJ0RvV2hpbGVTdGF0ZW1lbnQnLFxyXG5cdCAgICBEZWJ1Z2dlclN0YXRlbWVudDogJ0RlYnVnZ2VyU3RhdGVtZW50JyxcclxuXHQgICAgRW1wdHlTdGF0ZW1lbnQ6ICdFbXB0eVN0YXRlbWVudCcsXHJcblx0ICAgIEV4cG9ydEFsbERlY2xhcmF0aW9uOiAnRXhwb3J0QWxsRGVjbGFyYXRpb24nLFxyXG5cdCAgICBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb246ICdFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24nLFxyXG5cdCAgICBFeHBvcnROYW1lZERlY2xhcmF0aW9uOiAnRXhwb3J0TmFtZWREZWNsYXJhdGlvbicsXHJcblx0ICAgIEV4cG9ydFNwZWNpZmllcjogJ0V4cG9ydFNwZWNpZmllcicsXHJcblx0ICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcclxuXHQgICAgRm9yU3RhdGVtZW50OiAnRm9yU3RhdGVtZW50JyxcclxuXHQgICAgRm9yT2ZTdGF0ZW1lbnQ6ICdGb3JPZlN0YXRlbWVudCcsXHJcblx0ICAgIEZvckluU3RhdGVtZW50OiAnRm9ySW5TdGF0ZW1lbnQnLFxyXG5cdCAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiAnRnVuY3Rpb25EZWNsYXJhdGlvbicsXHJcblx0ICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogJ0Z1bmN0aW9uRXhwcmVzc2lvbicsXHJcblx0ICAgIElkZW50aWZpZXI6ICdJZGVudGlmaWVyJyxcclxuXHQgICAgSWZTdGF0ZW1lbnQ6ICdJZlN0YXRlbWVudCcsXHJcblx0ICAgIEltcG9ydERlY2xhcmF0aW9uOiAnSW1wb3J0RGVjbGFyYXRpb24nLFxyXG5cdCAgICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyOiAnSW1wb3J0RGVmYXVsdFNwZWNpZmllcicsXHJcblx0ICAgIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjogJ0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllcicsXHJcblx0ICAgIEltcG9ydFNwZWNpZmllcjogJ0ltcG9ydFNwZWNpZmllcicsXHJcblx0ICAgIExpdGVyYWw6ICdMaXRlcmFsJyxcclxuXHQgICAgTGFiZWxlZFN0YXRlbWVudDogJ0xhYmVsZWRTdGF0ZW1lbnQnLFxyXG5cdCAgICBMb2dpY2FsRXhwcmVzc2lvbjogJ0xvZ2ljYWxFeHByZXNzaW9uJyxcclxuXHQgICAgTWVtYmVyRXhwcmVzc2lvbjogJ01lbWJlckV4cHJlc3Npb24nLFxyXG5cdCAgICBNZXRhUHJvcGVydHk6ICdNZXRhUHJvcGVydHknLFxyXG5cdCAgICBNZXRob2REZWZpbml0aW9uOiAnTWV0aG9kRGVmaW5pdGlvbicsXHJcblx0ICAgIE5ld0V4cHJlc3Npb246ICdOZXdFeHByZXNzaW9uJyxcclxuXHQgICAgT2JqZWN0RXhwcmVzc2lvbjogJ09iamVjdEV4cHJlc3Npb24nLFxyXG5cdCAgICBPYmplY3RQYXR0ZXJuOiAnT2JqZWN0UGF0dGVybicsXHJcblx0ICAgIFByb2dyYW06ICdQcm9ncmFtJyxcclxuXHQgICAgUHJvcGVydHk6ICdQcm9wZXJ0eScsXHJcblx0ICAgIFJlc3RFbGVtZW50OiAnUmVzdEVsZW1lbnQnLFxyXG5cdCAgICBSZXR1cm5TdGF0ZW1lbnQ6ICdSZXR1cm5TdGF0ZW1lbnQnLFxyXG5cdCAgICBTZXF1ZW5jZUV4cHJlc3Npb246ICdTZXF1ZW5jZUV4cHJlc3Npb24nLFxyXG5cdCAgICBTcHJlYWRFbGVtZW50OiAnU3ByZWFkRWxlbWVudCcsXHJcblx0ICAgIFN1cGVyOiAnU3VwZXInLFxyXG5cdCAgICBTd2l0Y2hDYXNlOiAnU3dpdGNoQ2FzZScsXHJcblx0ICAgIFN3aXRjaFN0YXRlbWVudDogJ1N3aXRjaFN0YXRlbWVudCcsXHJcblx0ICAgIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjogJ1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbicsXHJcblx0ICAgIFRlbXBsYXRlRWxlbWVudDogJ1RlbXBsYXRlRWxlbWVudCcsXHJcblx0ICAgIFRlbXBsYXRlTGl0ZXJhbDogJ1RlbXBsYXRlTGl0ZXJhbCcsXHJcblx0ICAgIFRoaXNFeHByZXNzaW9uOiAnVGhpc0V4cHJlc3Npb24nLFxyXG5cdCAgICBUaHJvd1N0YXRlbWVudDogJ1Rocm93U3RhdGVtZW50JyxcclxuXHQgICAgVHJ5U3RhdGVtZW50OiAnVHJ5U3RhdGVtZW50JyxcclxuXHQgICAgVW5hcnlFeHByZXNzaW9uOiAnVW5hcnlFeHByZXNzaW9uJyxcclxuXHQgICAgVXBkYXRlRXhwcmVzc2lvbjogJ1VwZGF0ZUV4cHJlc3Npb24nLFxyXG5cdCAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiAnVmFyaWFibGVEZWNsYXJhdGlvbicsXHJcblx0ICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogJ1ZhcmlhYmxlRGVjbGFyYXRvcicsXHJcblx0ICAgIFdoaWxlU3RhdGVtZW50OiAnV2hpbGVTdGF0ZW1lbnQnLFxyXG5cdCAgICBXaXRoU3RhdGVtZW50OiAnV2l0aFN0YXRlbWVudCcsXHJcblx0ICAgIFlpZWxkRXhwcmVzc2lvbjogJ1lpZWxkRXhwcmVzc2lvbidcclxuXHR9O1xyXG5cblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHR2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcblx0ICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcblx0ICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcblx0ICAgIH07XHJcblx0fSkoKTtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIGNoYXJhY3Rlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHR2YXIgSlNYTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblx0dmFyIGpzeF9zeW50YXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblx0dmFyIE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG5cdHZhciBwYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcblx0dmFyIHRva2VuXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxuXHR2YXIgeGh0bWxfZW50aXRpZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG5cdHRva2VuXzEuVG9rZW5OYW1lWzEwMCAvKiBJZGVudGlmaWVyICovXSA9ICdKU1hJZGVudGlmaWVyJztcclxuXHR0b2tlbl8xLlRva2VuTmFtZVsxMDEgLyogVGV4dCAqL10gPSAnSlNYVGV4dCc7XHJcblx0Ly8gRnVsbHkgcXVhbGlmaWVkIGVsZW1lbnQgbmFtZSwgZS5nLiA8c3ZnOnBhdGg+IHJldHVybnMgXCJzdmc6cGF0aFwiXHJcblx0ZnVuY3Rpb24gZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUoZWxlbWVudE5hbWUpIHtcclxuXHQgICAgdmFyIHF1YWxpZmllZE5hbWU7XHJcblx0ICAgIHN3aXRjaCAoZWxlbWVudE5hbWUudHlwZSkge1xyXG5cdCAgICAgICAgY2FzZSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWElkZW50aWZpZXI6XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0gZWxlbWVudE5hbWU7XHJcblx0ICAgICAgICAgICAgcXVhbGlmaWVkTmFtZSA9IGlkLm5hbWU7XHJcblx0ICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICBjYXNlIGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYTmFtZXNwYWNlZE5hbWU6XHJcblx0ICAgICAgICAgICAgdmFyIG5zID0gZWxlbWVudE5hbWU7XHJcblx0ICAgICAgICAgICAgcXVhbGlmaWVkTmFtZSA9IGdldFF1YWxpZmllZEVsZW1lbnROYW1lKG5zLm5hbWVzcGFjZSkgKyAnOicgK1xyXG5cdCAgICAgICAgICAgICAgICBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShucy5uYW1lKTtcclxuXHQgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIGNhc2UganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hNZW1iZXJFeHByZXNzaW9uOlxyXG5cdCAgICAgICAgICAgIHZhciBleHByID0gZWxlbWVudE5hbWU7XHJcblx0ICAgICAgICAgICAgcXVhbGlmaWVkTmFtZSA9IGdldFF1YWxpZmllZEVsZW1lbnROYW1lKGV4cHIub2JqZWN0KSArICcuJyArXHJcblx0ICAgICAgICAgICAgICAgIGdldFF1YWxpZmllZEVsZW1lbnROYW1lKGV4cHIucHJvcGVydHkpO1xyXG5cdCAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIHF1YWxpZmllZE5hbWU7XHJcblx0fVxyXG5cdHZhciBKU1hQYXJzZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG5cdCAgICBfX2V4dGVuZHMoSlNYUGFyc2VyLCBfc3VwZXIpO1xyXG5cdCAgICBmdW5jdGlvbiBKU1hQYXJzZXIoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcclxuXHQgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkgfHwgdGhpcztcclxuXHQgICAgfVxyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5tYXRjaCgnPCcpID8gdGhpcy5wYXJzZUpTWFJvb3QoKSA6IF9zdXBlci5wcm90b3R5cGUucGFyc2VQcmltYXJ5RXhwcmVzc2lvbi5jYWxsKHRoaXMpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnN0YXJ0SlNYID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgLy8gVW53aW5kIHRoZSBzY2FubmVyIGJlZm9yZSB0aGUgbG9va2FoZWFkIHRva2VuLlxyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLmluZGV4ID0gdGhpcy5zdGFydE1hcmtlci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyID0gdGhpcy5zdGFydE1hcmtlci5saW5lO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLmxpbmVTdGFydCA9IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXggLSB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtbjtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5maW5pc2hKU1ggPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAvLyBQcmltZSB0aGUgbmV4dCBsb29rYWhlYWQuXHJcblx0ICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnJlZW50ZXJKU1ggPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0SlNYKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnfScpO1xyXG5cdCAgICAgICAgLy8gUG9wIHRoZSBjbG9zaW5nICd9JyBhZGRlZCBmcm9tIHRoZSBsb29rYWhlYWQuXHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9rZW5zKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucG9wKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuY3JlYXRlSlNYTm9kZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuY29sbGVjdENvbW1lbnRzKCk7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiB0aGlzLnNjYW5uZXIuaW5kZXgsXHJcblx0ICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmNyZWF0ZUpTWENoaWxkTm9kZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IHRoaXMuc2Nhbm5lci5pbmRleCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBjb2x1bW46IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnRcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuc2NhblhIVE1MRW50aXR5ID0gZnVuY3Rpb24gKHF1b3RlKSB7XHJcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gJyYnO1xyXG5cdCAgICAgICAgdmFyIHZhbGlkID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciB0ZXJtaW5hdGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgbnVtZXJpYyA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGhleCA9IGZhbHNlO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLnNjYW5uZXIuZW9mKCkgJiYgdmFsaWQgJiYgIXRlcm1pbmF0ZWQpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleF07XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGVybWluYXRlZCA9IChjaCA9PT0gJzsnKTtcclxuXHQgICAgICAgICAgICByZXN1bHQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgaWYgKCF0ZXJtaW5hdGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAocmVzdWx0Lmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGUuZy4gJyYjMTIzOydcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBudW1lcmljID0gKGNoID09PSAnIycpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW1lcmljKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGUuZy4gJyYjeDQxOydcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gKGNoID09PSAneCcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IGhleCB8fCBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyaWMgPSBudW1lcmljICYmICFoZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHZhbGlkICYmICEobnVtZXJpYyAmJiAhY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHZhbGlkICYmICEoaGV4ICYmICFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNIZXhEaWdpdChjaC5jaGFyQ29kZUF0KDApKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodmFsaWQgJiYgdGVybWluYXRlZCAmJiByZXN1bHQubGVuZ3RoID4gMikge1xyXG5cdCAgICAgICAgICAgIC8vIGUuZy4gJyYjeDQxOycgYmVjb21lcyBqdXN0ICcjeDQxJ1xyXG5cdCAgICAgICAgICAgIHZhciBzdHIgPSByZXN1bHQuc3Vic3RyKDEsIHJlc3VsdC5sZW5ndGggLSAyKTtcclxuXHQgICAgICAgICAgICBpZiAobnVtZXJpYyAmJiBzdHIubGVuZ3RoID4gMSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDEwKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGhleCAmJiBzdHIubGVuZ3RoID4gMikge1xyXG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KCcwJyArIHN0ci5zdWJzdHIoMSksIDE2KSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKCFudW1lcmljICYmICFoZXggJiYgeGh0bWxfZW50aXRpZXNfMS5YSFRNTEVudGl0aWVzW3N0cl0pIHtcclxuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0geGh0bWxfZW50aXRpZXNfMS5YSFRNTEVudGl0aWVzW3N0cl07XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gU2NhbiB0aGUgbmV4dCBKU1ggdG9rZW4uIFRoaXMgcmVwbGFjZXMgU2Nhbm5lciNsZXggd2hlbiBpbiBKU1ggbW9kZS5cclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5sZXhKU1ggPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY3AgPSB0aGlzLnNjYW5uZXIuc291cmNlLmNoYXJDb2RlQXQodGhpcy5zY2FubmVyLmluZGV4KTtcclxuXHQgICAgICAgIC8vIDwgPiAvIDogPSB7IH1cclxuXHQgICAgICAgIGlmIChjcCA9PT0gNjAgfHwgY3AgPT09IDYyIHx8IGNwID09PSA0NyB8fCBjcCA9PT0gNTggfHwgY3AgPT09IDYxIHx8IGNwID09PSAxMjMgfHwgY3AgPT09IDEyNSkge1xyXG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IDcgLyogUHVuY3R1YXRvciAqLyxcclxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLnNjYW5uZXIubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5zY2FubmVyLmluZGV4IC0gMSxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB0aGlzLnNjYW5uZXIuaW5kZXhcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gXCIgJ1xyXG5cdCAgICAgICAgaWYgKGNwID09PSAzNCB8fCBjcCA9PT0gMzkpIHtcclxuXHQgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdmFyIHF1b3RlID0gdGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgdmFyIHN0ciA9ICcnO1xyXG5cdCAgICAgICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IHF1b3RlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJyYnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdGhpcy5zY2FuWEhUTUxFbnRpdHkocXVvdGUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IDggLyogU3RyaW5nTGl0ZXJhbCAqLyxcclxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHN0cixcclxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5zY2FubmVyLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuc2Nhbm5lci5pbmRleFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyAuLi4gb3IgLlxyXG5cdCAgICAgICAgaWYgKGNwID09PSA0Nikge1xyXG5cdCAgICAgICAgICAgIHZhciBuMSA9IHRoaXMuc2Nhbm5lci5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLnNjYW5uZXIuaW5kZXggKyAxKTtcclxuXHQgICAgICAgICAgICB2YXIgbjIgPSB0aGlzLnNjYW5uZXIuc291cmNlLmNoYXJDb2RlQXQodGhpcy5zY2FubmVyLmluZGV4ICsgMik7XHJcblx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gKG4xID09PSA0NiAmJiBuMiA9PT0gNDYpID8gJy4uLicgOiAnLic7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5pbmRleCArPSB2YWx1ZS5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogNyAvKiBQdW5jdHVhdG9yICovLFxyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB0aGlzLnNjYW5uZXIuaW5kZXhcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gYFxyXG5cdCAgICAgICAgaWYgKGNwID09PSA5Nikge1xyXG5cdCAgICAgICAgICAgIC8vIE9ubHkgcGxhY2Vob2xkZXIsIHNpbmNlIGl0IHdpbGwgYmUgcmVzY2FubmVkIGFzIGEgcmVhbCBhc3NpZ25tZW50IGV4cHJlc3Npb24uXHJcblx0ICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogMTAgLyogVGVtcGxhdGUgKi8sXHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiAnJyxcclxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5zY2FubmVyLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc2Nhbm5lci5pbmRleCxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB0aGlzLnNjYW5uZXIuaW5kZXhcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gSWRlbnRpZmVyIGNhbiBub3QgY29udGFpbiBiYWNrc2xhc2ggKGNoYXIgY29kZSA5MikuXHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KGNwKSAmJiAoY3AgIT09IDkyKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNjYW5uZXIuc291cmNlLmNoYXJDb2RlQXQodGhpcy5zY2FubmVyLmluZGV4KTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJQYXJ0KGNoKSAmJiAoY2ggIT09IDkyKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDQ1KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBIeXBoZW4gKGNoYXIgY29kZSA0NSkgY2FuIGJlIHBhcnQgb2YgYW4gaWRlbnRpZmllci5cclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5zY2FubmVyLnNvdXJjZS5zbGljZShzdGFydCwgdGhpcy5zY2FubmVyLmluZGV4KTtcclxuXHQgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiAxMDAgLyogSWRlbnRpZmllciAqLyxcclxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IGlkLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLnNjYW5uZXIubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLnNjYW5uZXIubGV4KCk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUubmV4dEpTWFRva2VuID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5jb2xsZWN0Q29tbWVudHMoKTtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubGV4SlNYKCk7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9rZW5zKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0aGlzLmNvbnZlcnRUb2tlbih0b2tlbikpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRva2VuO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLm5leHRKU1hUZXh0ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIHRleHQgPSAnJztcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJ3snIHx8IGNoID09PSAnPCcpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHRleHQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgdGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXhdID09PSAnXFxuJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLmxpbmVTdGFydCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB7XHJcblx0ICAgICAgICAgICAgdHlwZTogMTAxIC8qIFRleHQgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHRleHQsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLnNjYW5uZXIubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuc2Nhbm5lci5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIGlmICgodGV4dC5sZW5ndGggPiAwKSAmJiB0aGlzLmNvbmZpZy50b2tlbnMpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHRoaXMuY29udmVydFRva2VuKHRva2VuKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdG9rZW47XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGVla0pTWFRva2VuID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zY2FubmVyLnNhdmVTdGF0ZSgpO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLnNjYW5Db21tZW50cygpO1xyXG5cdCAgICAgICAgdmFyIG5leHQgPSB0aGlzLmxleEpTWCgpO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLnJlc3RvcmVTdGF0ZShzdGF0ZSk7XHJcblx0ICAgICAgICByZXR1cm4gbmV4dDtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gRXhwZWN0IHRoZSBuZXh0IEpTWCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXHJcblx0ICAgIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmV4cGVjdEpTWCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0SlNYVG9rZW4oKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSA3IC8qIFB1bmN0dWF0b3IgKi8gfHwgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IEpTWCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5tYXRjaEpTWCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgICAgICAgdmFyIG5leHQgPSB0aGlzLnBlZWtKU1hUb2tlbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIG5leHQudHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIG5leHQudmFsdWUgPT09IHZhbHVlO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRKU1hUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IDEwMCAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hJZGVudGlmaWVyKHRva2VuLnZhbHVlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hFbGVtZW50TmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZWxlbWVudE5hbWUgPSB0aGlzLnBhcnNlSlNYSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hKU1goJzonKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBlbGVtZW50TmFtZTtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnOicpO1xyXG5cdCAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0aGlzLnBhcnNlSlNYSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIGVsZW1lbnROYW1lID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hOYW1lc3BhY2VkTmFtZShuYW1lc3BhY2UsIG5hbWVfMSkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEpTWCgnLicpKSB7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKHRoaXMubWF0Y2hKU1goJy4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0gZWxlbWVudE5hbWU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCcuJyk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2VKU1hJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnROYW1lID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hNZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHkpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZWxlbWVudE5hbWU7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lO1xyXG5cdCAgICAgICAgdmFyIGlkZW50aWZpZXIgPSB0aGlzLnBhcnNlSlNYSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hKU1goJzonKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBpZGVudGlmaWVyO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc6Jyk7XHJcblx0ICAgICAgICAgICAgdmFyIG5hbWVfMiA9IHRoaXMucGFyc2VKU1hJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYTmFtZXNwYWNlZE5hbWUobmFtZXNwYWNlLCBuYW1lXzIpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSBpZGVudGlmaWVyO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWU7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hTdHJpbmdMaXRlcmFsQXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dEpTWFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gOCAvKiBTdHJpbmdMaXRlcmFsICovKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5MaXRlcmFsKHRva2VuLnZhbHVlLCByYXcpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEV4cHJlc3Npb25BdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJ3snKTtcclxuXHQgICAgICAgIHRoaXMuZmluaXNoSlNYKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKCdKU1ggYXR0cmlidXRlcyBtdXN0IG9ubHkgYmUgYXNzaWduZWQgYSBub24tZW1wdHkgZXhwcmVzc2lvbicpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHRoaXMucmVlbnRlckpTWCgpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYRXhwcmVzc2lvbkNvbnRhaW5lcihleHByZXNzaW9uKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hBdHRyaWJ1dGVWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLm1hdGNoSlNYKCd7JykgPyB0aGlzLnBhcnNlSlNYRXhwcmVzc2lvbkF0dHJpYnV0ZSgpIDpcclxuXHQgICAgICAgICAgICB0aGlzLm1hdGNoSlNYKCc8JykgPyB0aGlzLnBhcnNlSlNYRWxlbWVudCgpIDogdGhpcy5wYXJzZUpTWFN0cmluZ0xpdGVyYWxBdHRyaWJ1dGUoKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWE5hbWVWYWx1ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VKU1hBdHRyaWJ1dGVOYW1lKCk7XHJcblx0ICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hKU1goJz0nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc9Jyk7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlSlNYQXR0cmlidXRlVmFsdWUoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYU3ByZWFkQXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCd7Jyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnLi4uJyk7XHJcblx0ICAgICAgICB0aGlzLmZpbmlzaEpTWCgpO1xyXG5cdCAgICAgICAgdmFyIGFyZ3VtZW50ID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB0aGlzLnJlZW50ZXJKU1goKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWFNwcmVhZEF0dHJpYnV0ZShhcmd1bWVudCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gW107XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2hKU1goJy8nKSAmJiAhdGhpcy5tYXRjaEpTWCgnPicpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMubWF0Y2hKU1goJ3snKSA/IHRoaXMucGFyc2VKU1hTcHJlYWRBdHRyaWJ1dGUoKSA6XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMucGFyc2VKU1hOYW1lVmFsdWVBdHRyaWJ1dGUoKTtcclxuXHQgICAgICAgICAgICBhdHRyaWJ1dGVzLnB1c2goYXR0cmlidXRlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYT3BlbmluZ0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJzwnKTtcclxuXHQgICAgICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZUpTWEVsZW1lbnROYW1lKCk7XHJcblx0ICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMucGFyc2VKU1hBdHRyaWJ1dGVzKCk7XHJcblx0ICAgICAgICB2YXIgc2VsZkNsb3NpbmcgPSB0aGlzLm1hdGNoSlNYKCcvJyk7XHJcblx0ICAgICAgICBpZiAoc2VsZkNsb3NpbmcpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnLycpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJz4nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWE9wZW5pbmdFbGVtZW50KG5hbWUsIHNlbGZDbG9zaW5nLCBhdHRyaWJ1dGVzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hCb3VuZGFyeUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJzwnKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoSlNYKCcvJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnLycpO1xyXG5cdCAgICAgICAgICAgIHZhciBuYW1lXzMgPSB0aGlzLnBhcnNlSlNYRWxlbWVudE5hbWUoKTtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPicpO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWENsb3NpbmdFbGVtZW50KG5hbWVfMykpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlSlNYRWxlbWVudE5hbWUoKTtcclxuXHQgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5wYXJzZUpTWEF0dHJpYnV0ZXMoKTtcclxuXHQgICAgICAgIHZhciBzZWxmQ2xvc2luZyA9IHRoaXMubWF0Y2hKU1goJy8nKTtcclxuXHQgICAgICAgIGlmIChzZWxmQ2xvc2luZykge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCcvJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPicpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYT3BlbmluZ0VsZW1lbnQobmFtZSwgc2VsZkNsb3NpbmcsIGF0dHJpYnV0ZXMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEVtcHR5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hDaGlsZE5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuY29sbGVjdENvbW1lbnRzKCk7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hFbXB0eUV4cHJlc3Npb24oKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hFeHByZXNzaW9uQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCd7Jyk7XHJcblx0ICAgICAgICB2YXIgZXhwcmVzc2lvbjtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoSlNYKCd9JykpIHtcclxuXHQgICAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5wYXJzZUpTWEVtcHR5RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCd9Jyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmZpbmlzaEpTWCgpO1xyXG5cdCAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICB0aGlzLnJlZW50ZXJKU1goKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWEV4cHJlc3Npb25Db250YWluZXIoZXhwcmVzc2lvbikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWENoaWxkTm9kZSgpO1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dEpTWFRleHQoKTtcclxuXHQgICAgICAgICAgICBpZiAodG9rZW4uc3RhcnQgPCB0b2tlbi5lbmQpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWFRleHQodG9rZW4udmFsdWUsIHJhdykpO1xyXG5cdCAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4XSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLnBhcnNlSlNYRXhwcmVzc2lvbkNvbnRhaW5lcigpO1xyXG5cdCAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNvbnRhaW5lcik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VDb21wbGV4SlNYRWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xyXG5cdCAgICAgICAgdmFyIHN0YWNrID0gW107XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGVsLmNoaWxkcmVuID0gZWwuY2hpbGRyZW4uY29uY2F0KHRoaXMucGFyc2VKU1hDaGlsZHJlbigpKTtcclxuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYQ2hpbGROb2RlKCk7XHJcblx0ICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlSlNYQm91bmRhcnlFbGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hPcGVuaW5nRWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgb3BlbmluZyA9IGVsZW1lbnQ7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChvcGVuaW5nLnNlbGZDbG9zaW5nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWEVsZW1lbnQob3BlbmluZywgW10sIG51bGwpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVsLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChlbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbCA9IHsgbm9kZTogbm9kZSwgb3BlbmluZzogb3BlbmluZywgY2xvc2luZzogbnVsbCwgY2hpbGRyZW46IFtdIH07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hDbG9zaW5nRWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICBlbC5jbG9zaW5nID0gZWxlbWVudDtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG9wZW5fMSA9IGdldFF1YWxpZmllZEVsZW1lbnROYW1lKGVsLm9wZW5pbmcubmFtZSk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjbG9zZV8xID0gZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUoZWwuY2xvc2luZy5uYW1lKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKG9wZW5fMSAhPT0gY2xvc2VfMSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKCdFeHBlY3RlZCBjb3JyZXNwb25kaW5nIEpTWCBjbG9zaW5nIHRhZyBmb3IgJTAnLCBvcGVuXzEpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmZpbmFsaXplKGVsLm5vZGUsIG5ldyBKU1hOb2RlLkpTWEVsZW1lbnQoZWwub3BlbmluZywgZWwuY2hpbGRyZW4sIGVsLmNsb3NpbmcpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVsID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZWw7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHZhciBvcGVuaW5nID0gdGhpcy5wYXJzZUpTWE9wZW5pbmdFbGVtZW50KCk7XHJcblx0ICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcclxuXHQgICAgICAgIHZhciBjbG9zaW5nID0gbnVsbDtcclxuXHQgICAgICAgIGlmICghb3BlbmluZy5zZWxmQ2xvc2luZykge1xyXG5cdCAgICAgICAgICAgIHZhciBlbCA9IHRoaXMucGFyc2VDb21wbGV4SlNYRWxlbWVudCh7IG5vZGU6IG5vZGUsIG9wZW5pbmc6IG9wZW5pbmcsIGNsb3Npbmc6IGNsb3NpbmcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcclxuXHQgICAgICAgICAgICBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xyXG5cdCAgICAgICAgICAgIGNsb3NpbmcgPSBlbC5jbG9zaW5nO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYRWxlbWVudChvcGVuaW5nLCBjaGlsZHJlbiwgY2xvc2luZykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYUm9vdCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIC8vIFBvcCB0aGUgb3BlbmluZyAnPCcgYWRkZWQgZnJvbSB0aGUgbG9va2FoZWFkLlxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRva2Vucykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnBvcCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5zdGFydEpTWCgpO1xyXG5cdCAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlSlNYRWxlbWVudCgpO1xyXG5cdCAgICAgICAgdGhpcy5maW5pc2hKU1goKTtcclxuXHQgICAgICAgIHJldHVybiBlbGVtZW50O1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmlzU3RhcnRPZkV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5pc1N0YXJ0T2ZFeHByZXNzaW9uLmNhbGwodGhpcykgfHwgdGhpcy5tYXRjaCgnPCcpO1xyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gSlNYUGFyc2VyO1xyXG5cdH0ocGFyc2VyXzEuUGFyc2VyKSk7XHJcblx0ZXhwb3J0cy5KU1hQYXJzZXIgPSBKU1hQYXJzZXI7XHJcblxuXG4vKioqLyB9LFxuLyogNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdC8vIFNlZSBhbHNvIHRvb2xzL2dlbmVyYXRlLXVuaWNvZGUtcmVnZXguanMuXHJcblx0dmFyIFJlZ2V4ID0ge1xyXG5cdCAgICAvLyBVbmljb2RlIHY4LjAuMCBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDpcclxuXHQgICAgTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6IC9bXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjRcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBBRjlcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5Qi1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QURcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERDQwLVxcdURENzRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNEFcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMFxcdURFMTAtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNFxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MDRbXFx1REMwMy1cXHVEQzM3XFx1REM4My1cXHVEQ0FGXFx1RENEMC1cXHVEQ0U4XFx1REQwMy1cXHVERDI2XFx1REQ1MC1cXHVERDcyXFx1REQ3NlxcdUREODMtXFx1RERCMlxcdUREQzEtXFx1RERDNFxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTJCXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVERVxcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNEXFx1REY1MFxcdURGNUQtXFx1REY2MV18XFx1RDgwNVtcXHVEQzgwLVxcdURDQUZcXHVEQ0M0XFx1RENDNVxcdURDQzdcXHVERDgwLVxcdUREQUVcXHVEREQ4LVxcdUREREJcXHVERTAwLVxcdURFMkZcXHVERTQ0XFx1REU4MC1cXHVERUFBXFx1REYwMC1cXHVERjE5XXxcXHVEODA2W1xcdURDQTAtXFx1RENERlxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RVxcdURDODAtXFx1REQ0M118W1xcdUQ4MENcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFRDAtXFx1REVFRFxcdURGMDAtXFx1REYyRlxcdURGNDAtXFx1REY0M1xcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwXFx1REY5My1cXHVERjlGXXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OV18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNF18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdLyxcclxuXHQgICAgLy8gVW5pY29kZSB2OC4wLjAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDpcclxuXHQgICAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDogL1tcXHhBQVxceEI1XFx4QjdcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzAwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4My1cXHUwNDg3XFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MTAtXFx1MDYxQVxcdTA2MjAtXFx1MDY2OVxcdTA2NkUtXFx1MDZEM1xcdTA2RDUtXFx1MDZEQ1xcdTA2REYtXFx1MDZFOFxcdTA2RUEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwLVxcdTA3NEFcXHUwNzRELVxcdTA3QjFcXHUwN0MwLVxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODJEXFx1MDg0MC1cXHUwODVCXFx1MDhBMC1cXHUwOEI0XFx1MDhFMy1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZGXFx1MDk3MS1cXHUwOTgzXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCQy1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0VcXHUwOUQ3XFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTNcXHUwOUU2LVxcdTA5RjFcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJDLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFFNi1cXHUwQUVGXFx1MEFGOVxcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNDLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjcxXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEMFxcdTBCRDdcXHUwQkU2LVxcdTBCRUZcXHUwQzAwLVxcdTBDMDNcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNELVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNTgtXFx1MEM1QVxcdTBDNjAtXFx1MEM2M1xcdTBDNjYtXFx1MEM2RlxcdTBDODEtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkMtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1N1xcdTBENUYtXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERFNi1cXHUwREVGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUQtXFx1MTM1RlxcdTEzNjktXFx1MTM3MVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0QzXFx1MTdEN1xcdTE3RENcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOURBXFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFBQjAtXFx1MUFCRFxcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUJGM1xcdTFDMDAtXFx1MUMzN1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNGNlxcdTFDRjhcXHUxQ0Y5XFx1MUQwMC1cXHUxREY1XFx1MURGQy1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwMENcXHUyMDBEXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEN0YtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJERTAtXFx1MkRGRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyRlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOTktXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2N0YtXFx1QTZGMVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRFxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgyN1xcdUE4NDAtXFx1QTg3M1xcdUE4ODAtXFx1QThDNFxcdUE4RDAtXFx1QThEOVxcdUE4RTAtXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwMC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUZFXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QS1cXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY2XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURERkRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERUUwXFx1REYwMC1cXHVERjFGXFx1REYzMC1cXHVERjRBXFx1REY1MC1cXHVERjdBXFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQTAtXFx1RENBOVxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDAtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNlxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MDRbXFx1REMwMC1cXHVEQzQ2XFx1REM2Ni1cXHVEQzZGXFx1REM3Ri1cXHVEQ0JBXFx1RENEMC1cXHVEQ0U4XFx1RENGMC1cXHVEQ0Y5XFx1REQwMC1cXHVERDM0XFx1REQzNi1cXHVERDNGXFx1REQ1MC1cXHVERDczXFx1REQ3NlxcdUREODAtXFx1RERDNFxcdUREQ0EtXFx1RERDQ1xcdURERDAtXFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMzdcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERUVBXFx1REVGMC1cXHVERUY5XFx1REYwMC1cXHVERjAzXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0MtXFx1REY0NFxcdURGNDdcXHVERjQ4XFx1REY0Qi1cXHVERjREXFx1REY1MFxcdURGNTdcXHVERjVELVxcdURGNjNcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MDVbXFx1REM4MC1cXHVEQ0M1XFx1RENDN1xcdURDRDAtXFx1RENEOVxcdUREODAtXFx1RERCNVxcdUREQjgtXFx1RERDMFxcdURERDgtXFx1RERERFxcdURFMDAtXFx1REU0MFxcdURFNDRcXHVERTUwLVxcdURFNTlcXHVERTgwLVxcdURFQjdcXHVERUMwLVxcdURFQzlcXHVERjAwLVxcdURGMTlcXHVERjFELVxcdURGMkJcXHVERjMwLVxcdURGMzldfFxcdUQ4MDZbXFx1RENBMC1cXHVEQ0U5XFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REU2MC1cXHVERTY5XFx1REVEMC1cXHVERUVEXFx1REVGMC1cXHVERUY0XFx1REYwMC1cXHVERjM2XFx1REY0MC1cXHVERjQzXFx1REY1MC1cXHVERjU5XFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTAtXFx1REY3RVxcdURGOEYtXFx1REY5Rl18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTlcXHVEQzlEXFx1REM5RV18XFx1RDgzNFtcXHVERDY1LVxcdURENjlcXHVERDZELVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQlxcdURGQ0UtXFx1REZGRl18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRcXHVEQ0QwLVxcdURDRDZdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXXxcXHVEQjQwW1xcdUREMDAtXFx1RERFRl0vXHJcblx0fTtcclxuXHRleHBvcnRzLkNoYXJhY3RlciA9IHtcclxuXHQgICAgLyogdHNsaW50OmRpc2FibGU6bm8tYml0d2lzZSAqL1xyXG5cdCAgICBmcm9tQ29kZVBvaW50OiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPCAweDEwMDAwKSA/IFN0cmluZy5mcm9tQ2hhckNvZGUoY3ApIDpcclxuXHQgICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCArICgoY3AgLSAweDEwMDAwKSA+PiAxMCkpICtcclxuXHQgICAgICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgweERDMDAgKyAoKGNwIC0gMHgxMDAwMCkgJiAxMDIzKSk7XHJcblx0ICAgIH0sXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXdoaXRlLXNwYWNlXHJcblx0ICAgIGlzV2hpdGVTcGFjZTogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID09PSAweDIwKSB8fCAoY3AgPT09IDB4MDkpIHx8IChjcCA9PT0gMHgwQikgfHwgKGNwID09PSAweDBDKSB8fCAoY3AgPT09IDB4QTApIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4MTY4MCAmJiBbMHgxNjgwLCAweDIwMDAsIDB4MjAwMSwgMHgyMDAyLCAweDIwMDMsIDB4MjAwNCwgMHgyMDA1LCAweDIwMDYsIDB4MjAwNywgMHgyMDA4LCAweDIwMDksIDB4MjAwQSwgMHgyMDJGLCAweDIwNUYsIDB4MzAwMCwgMHhGRUZGXS5pbmRleE9mKGNwKSA+PSAwKTtcclxuXHQgICAgfSxcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGluZS10ZXJtaW5hdG9yc1xyXG5cdCAgICBpc0xpbmVUZXJtaW5hdG9yOiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPT09IDB4MEEpIHx8IChjcCA9PT0gMHgwRCkgfHwgKGNwID09PSAweDIwMjgpIHx8IChjcCA9PT0gMHgyMDI5KTtcclxuXHQgICAgfSxcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbmFtZXMtYW5kLWtleXdvcmRzXHJcblx0ICAgIGlzSWRlbnRpZmllclN0YXJ0OiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPT09IDB4MjQpIHx8IChjcCA9PT0gMHg1RikgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHg0MSAmJiBjcCA8PSAweDVBKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDYxICYmIGNwIDw9IDB4N0EpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID09PSAweDVDKSB8fFxyXG5cdCAgICAgICAgICAgICgoY3AgPj0gMHg4MCkgJiYgUmVnZXguTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQudGVzdChleHBvcnRzLkNoYXJhY3Rlci5mcm9tQ29kZVBvaW50KGNwKSkpO1xyXG5cdCAgICB9LFxyXG5cdCAgICBpc0lkZW50aWZpZXJQYXJ0OiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPT09IDB4MjQpIHx8IChjcCA9PT0gMHg1RikgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHg0MSAmJiBjcCA8PSAweDVBKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDYxICYmIGNwIDw9IDB4N0EpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4MzAgJiYgY3AgPD0gMHgzOSkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPT09IDB4NUMpIHx8XHJcblx0ICAgICAgICAgICAgKChjcCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJQYXJ0LnRlc3QoZXhwb3J0cy5DaGFyYWN0ZXIuZnJvbUNvZGVQb2ludChjcCkpKTtcclxuXHQgICAgfSxcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGl0ZXJhbHMtbnVtZXJpYy1saXRlcmFsc1xyXG5cdCAgICBpc0RlY2ltYWxEaWdpdDogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID49IDB4MzAgJiYgY3AgPD0gMHgzOSk7IC8vIDAuLjlcclxuXHQgICAgfSxcclxuXHQgICAgaXNIZXhEaWdpdDogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID49IDB4MzAgJiYgY3AgPD0gMHgzOSkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHg0MSAmJiBjcCA8PSAweDQ2KSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDYxICYmIGNwIDw9IDB4NjYpOyAvLyBhLi5mXHJcblx0ICAgIH0sXHJcblx0ICAgIGlzT2N0YWxEaWdpdDogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID49IDB4MzAgJiYgY3AgPD0gMHgzNyk7IC8vIDAuLjdcclxuXHQgICAgfVxyXG5cdH07XHJcblxuXG4vKioqLyB9LFxuLyogNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBqc3hfc3ludGF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdC8qIHRzbGludDpkaXNhYmxlOm1heC1jbGFzc2VzLXBlci1maWxlICovXHJcblx0dmFyIEpTWENsb3NpbmdFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYQ2xvc2luZ0VsZW1lbnQobmFtZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hDbG9zaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWENsb3NpbmdFbGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hDbG9zaW5nRWxlbWVudCA9IEpTWENsb3NpbmdFbGVtZW50O1xyXG5cdHZhciBKU1hFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYRWxlbWVudChvcGVuaW5nRWxlbWVudCwgY2hpbGRyZW4sIGNsb3NpbmdFbGVtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWEVsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLm9wZW5pbmdFbGVtZW50ID0gb3BlbmluZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcblx0ICAgICAgICB0aGlzLmNsb3NpbmdFbGVtZW50ID0gY2xvc2luZ0VsZW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWEVsZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWEVsZW1lbnQgPSBKU1hFbGVtZW50O1xyXG5cdHZhciBKU1hFbXB0eUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hFbXB0eUV4cHJlc3Npb24oKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWEVtcHR5RXhwcmVzc2lvbjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYRW1wdHlFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hFbXB0eUV4cHJlc3Npb24gPSBKU1hFbXB0eUV4cHJlc3Npb247XHJcblx0dmFyIEpTWEV4cHJlc3Npb25Db250YWluZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hFeHByZXNzaW9uQ29udGFpbmVyKGV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYRXhwcmVzc2lvbkNvbnRhaW5lcjtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWEV4cHJlc3Npb25Db250YWluZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWEV4cHJlc3Npb25Db250YWluZXIgPSBKU1hFeHByZXNzaW9uQ29udGFpbmVyO1xyXG5cdHZhciBKU1hJZGVudGlmaWVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYSWRlbnRpZmllcihuYW1lKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWElkZW50aWZpZXI7XHJcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hJZGVudGlmaWVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hJZGVudGlmaWVyID0gSlNYSWRlbnRpZmllcjtcclxuXHR2YXIgSlNYTWVtYmVyRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWE1lbWJlckV4cHJlc3Npb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hNZW1iZXJFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblx0ICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWE1lbWJlckV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWE1lbWJlckV4cHJlc3Npb24gPSBKU1hNZW1iZXJFeHByZXNzaW9uO1xyXG5cdHZhciBKU1hBdHRyaWJ1dGUgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYQXR0cmlidXRlO1xyXG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYQXR0cmlidXRlO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hBdHRyaWJ1dGUgPSBKU1hBdHRyaWJ1dGU7XHJcblx0dmFyIEpTWE5hbWVzcGFjZWROYW1lID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYTmFtZXNwYWNlZE5hbWUobmFtZXNwYWNlLCBuYW1lKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWE5hbWVzcGFjZWROYW1lO1xyXG5cdCAgICAgICAgdGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XHJcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hOYW1lc3BhY2VkTmFtZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYTmFtZXNwYWNlZE5hbWUgPSBKU1hOYW1lc3BhY2VkTmFtZTtcclxuXHR2YXIgSlNYT3BlbmluZ0VsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hPcGVuaW5nRWxlbWVudChuYW1lLCBzZWxmQ2xvc2luZywgYXR0cmlidXRlcykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hPcGVuaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblx0ICAgICAgICB0aGlzLnNlbGZDbG9zaW5nID0gc2VsZkNsb3Npbmc7XHJcblx0ICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hPcGVuaW5nRWxlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYT3BlbmluZ0VsZW1lbnQgPSBKU1hPcGVuaW5nRWxlbWVudDtcclxuXHR2YXIgSlNYU3ByZWFkQXR0cmlidXRlID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYU3ByZWFkQXR0cmlidXRlKGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWFNwcmVhZEF0dHJpYnV0ZTtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYU3ByZWFkQXR0cmlidXRlO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hTcHJlYWRBdHRyaWJ1dGUgPSBKU1hTcHJlYWRBdHRyaWJ1dGU7XHJcblx0dmFyIEpTWFRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hUZXh0KHZhbHVlLCByYXcpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYVGV4dDtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgICAgIHRoaXMucmF3ID0gcmF3O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hUZXh0O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hUZXh0ID0gSlNYVGV4dDtcclxuXG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0ZXhwb3J0cy5KU1hTeW50YXggPSB7XHJcblx0ICAgIEpTWEF0dHJpYnV0ZTogJ0pTWEF0dHJpYnV0ZScsXHJcblx0ICAgIEpTWENsb3NpbmdFbGVtZW50OiAnSlNYQ2xvc2luZ0VsZW1lbnQnLFxyXG5cdCAgICBKU1hFbGVtZW50OiAnSlNYRWxlbWVudCcsXHJcblx0ICAgIEpTWEVtcHR5RXhwcmVzc2lvbjogJ0pTWEVtcHR5RXhwcmVzc2lvbicsXHJcblx0ICAgIEpTWEV4cHJlc3Npb25Db250YWluZXI6ICdKU1hFeHByZXNzaW9uQ29udGFpbmVyJyxcclxuXHQgICAgSlNYSWRlbnRpZmllcjogJ0pTWElkZW50aWZpZXInLFxyXG5cdCAgICBKU1hNZW1iZXJFeHByZXNzaW9uOiAnSlNYTWVtYmVyRXhwcmVzc2lvbicsXHJcblx0ICAgIEpTWE5hbWVzcGFjZWROYW1lOiAnSlNYTmFtZXNwYWNlZE5hbWUnLFxyXG5cdCAgICBKU1hPcGVuaW5nRWxlbWVudDogJ0pTWE9wZW5pbmdFbGVtZW50JyxcclxuXHQgICAgSlNYU3ByZWFkQXR0cmlidXRlOiAnSlNYU3ByZWFkQXR0cmlidXRlJyxcclxuXHQgICAgSlNYVGV4dDogJ0pTWFRleHQnXHJcblx0fTtcclxuXG5cbi8qKiovIH0sXG4vKiA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIHN5bnRheF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHQvKiB0c2xpbnQ6ZGlzYWJsZTptYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xyXG5cdHZhciBBcnJheUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBcnJheUV4cHJlc3Npb24oZWxlbWVudHMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5BcnJheUV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFycmF5RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXJyYXlFeHByZXNzaW9uID0gQXJyYXlFeHByZXNzaW9uO1xyXG5cdHZhciBBcnJheVBhdHRlcm4gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBcnJheVBhdHRlcm4oZWxlbWVudHMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5BcnJheVBhdHRlcm47XHJcblx0ICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFycmF5UGF0dGVybjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXJyYXlQYXR0ZXJuID0gQXJyYXlQYXR0ZXJuO1xyXG5cdHZhciBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFycm93RnVuY3Rpb25FeHByZXNzaW9uKHBhcmFtcywgYm9keSwgZXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IG51bGw7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuYXN5bmMgPSBmYWxzZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0dmFyIEFzc2lnbm1lbnRFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXNzaWdubWVudEV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudEV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBc3NpZ25tZW50RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXNzaWdubWVudEV4cHJlc3Npb24gPSBBc3NpZ25tZW50RXhwcmVzc2lvbjtcclxuXHR2YXIgQXNzaWdubWVudFBhdHRlcm4gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBc3NpZ25tZW50UGF0dGVybihsZWZ0LCByaWdodCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuO1xyXG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuXHQgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXNzaWdubWVudFBhdHRlcm47XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFzc2lnbm1lbnRQYXR0ZXJuID0gQXNzaWdubWVudFBhdHRlcm47XHJcblx0dmFyIEFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBc3luY0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKHBhcmFtcywgYm9keSwgZXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IG51bGw7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuYXN5bmMgPSB0cnVlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBc3luY0Fycm93RnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Bc3luY0Fycm93RnVuY3Rpb25FeHByZXNzaW9uID0gQXN5bmNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR2YXIgQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uKGlkLCBwYXJhbXMsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5hc3luYyA9IHRydWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uID0gQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uO1xyXG5cdHZhciBBc3luY0Z1bmN0aW9uRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFzeW5jRnVuY3Rpb25FeHByZXNzaW9uKGlkLCBwYXJhbXMsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5GdW5jdGlvbkV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmFzeW5jID0gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXN5bmNGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFzeW5jRnVuY3Rpb25FeHByZXNzaW9uID0gQXN5bmNGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0dmFyIEF3YWl0RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEF3YWl0RXhwcmVzc2lvbihhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkF3YWl0RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXdhaXRFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Bd2FpdEV4cHJlc3Npb24gPSBBd2FpdEV4cHJlc3Npb247XHJcblx0dmFyIEJpbmFyeUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBCaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xyXG5cdCAgICAgICAgdmFyIGxvZ2ljYWwgPSAob3BlcmF0b3IgPT09ICd8fCcgfHwgb3BlcmF0b3IgPT09ICcmJicpO1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gbG9naWNhbCA/IHN5bnRheF8xLlN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbiA6IHN5bnRheF8xLlN5bnRheC5CaW5hcnlFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuXHQgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQmluYXJ5RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQmluYXJ5RXhwcmVzc2lvbiA9IEJpbmFyeUV4cHJlc3Npb247XHJcblx0dmFyIEJsb2NrU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQmxvY2tTdGF0ZW1lbnQoYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkJsb2NrU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQmxvY2tTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkJsb2NrU3RhdGVtZW50ID0gQmxvY2tTdGF0ZW1lbnQ7XHJcblx0dmFyIEJyZWFrU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQnJlYWtTdGF0ZW1lbnQobGFiZWwpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5CcmVha1N0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQnJlYWtTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkJyZWFrU3RhdGVtZW50ID0gQnJlYWtTdGF0ZW1lbnQ7XHJcblx0dmFyIENhbGxFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ2FsbEV4cHJlc3Npb24oY2FsbGVlLCBhcmdzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ2FsbEV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmNhbGxlZSA9IGNhbGxlZTtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnRzID0gYXJncztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ2FsbEV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNhbGxFeHByZXNzaW9uID0gQ2FsbEV4cHJlc3Npb247XHJcblx0dmFyIENhdGNoQ2xhdXNlID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ2F0Y2hDbGF1c2UocGFyYW0sIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5DYXRjaENsYXVzZTtcclxuXHQgICAgICAgIHRoaXMucGFyYW0gPSBwYXJhbTtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENhdGNoQ2xhdXNlO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5DYXRjaENsYXVzZSA9IENhdGNoQ2xhdXNlO1xyXG5cdHZhciBDbGFzc0JvZHkgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDbGFzc0JvZHkoYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNsYXNzQm9keTtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENsYXNzQm9keTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ2xhc3NCb2R5ID0gQ2xhc3NCb2R5O1xyXG5cdHZhciBDbGFzc0RlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ2xhc3NEZWNsYXJhdGlvbihpZCwgc3VwZXJDbGFzcywgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNsYXNzRGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLnN1cGVyQ2xhc3MgPSBzdXBlckNsYXNzO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ2xhc3NEZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ2xhc3NEZWNsYXJhdGlvbiA9IENsYXNzRGVjbGFyYXRpb247XHJcblx0dmFyIENsYXNzRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENsYXNzRXhwcmVzc2lvbihpZCwgc3VwZXJDbGFzcywgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNsYXNzRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMuc3VwZXJDbGFzcyA9IHN1cGVyQ2xhc3M7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDbGFzc0V4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNsYXNzRXhwcmVzc2lvbiA9IENsYXNzRXhwcmVzc2lvbjtcclxuXHR2YXIgQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5jb21wdXRlZCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHQgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Db21wdXRlZE1lbWJlckV4cHJlc3Npb24gPSBDb21wdXRlZE1lbWJlckV4cHJlc3Npb247XHJcblx0dmFyIENvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENvbmRpdGlvbmFsRXhwcmVzc2lvbih0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Db25kaXRpb25hbEV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xyXG5cdCAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcclxuXHQgICAgICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDb25kaXRpb25hbEV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IENvbmRpdGlvbmFsRXhwcmVzc2lvbjtcclxuXHR2YXIgQ29udGludWVTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDb250aW51ZVN0YXRlbWVudChsYWJlbCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNvbnRpbnVlU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDb250aW51ZVN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ29udGludWVTdGF0ZW1lbnQgPSBDb250aW51ZVN0YXRlbWVudDtcclxuXHR2YXIgRGVidWdnZXJTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBEZWJ1Z2dlclN0YXRlbWVudCgpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5EZWJ1Z2dlclN0YXRlbWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRGVidWdnZXJTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkRlYnVnZ2VyU3RhdGVtZW50ID0gRGVidWdnZXJTdGF0ZW1lbnQ7XHJcblx0dmFyIERpcmVjdGl2ZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIERpcmVjdGl2ZShleHByZXNzaW9uLCBkaXJlY3RpdmUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuZGlyZWN0aXZlID0gZGlyZWN0aXZlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBEaXJlY3RpdmU7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkRpcmVjdGl2ZSA9IERpcmVjdGl2ZTtcclxuXHR2YXIgRG9XaGlsZVN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIERvV2hpbGVTdGF0ZW1lbnQoYm9keSwgdGVzdCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkRvV2hpbGVTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRG9XaGlsZVN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRG9XaGlsZVN0YXRlbWVudCA9IERvV2hpbGVTdGF0ZW1lbnQ7XHJcblx0dmFyIEVtcHR5U3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRW1wdHlTdGF0ZW1lbnQoKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRW1wdHlTdGF0ZW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEVtcHR5U3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FbXB0eVN0YXRlbWVudCA9IEVtcHR5U3RhdGVtZW50O1xyXG5cdHZhciBFeHBvcnRBbGxEZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEV4cG9ydEFsbERlY2xhcmF0aW9uKHNvdXJjZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cG9ydEFsbERlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEV4cG9ydEFsbERlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FeHBvcnRBbGxEZWNsYXJhdGlvbiA9IEV4cG9ydEFsbERlY2xhcmF0aW9uO1xyXG5cdHZhciBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb247XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uID0gRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uO1xyXG5cdHZhciBFeHBvcnROYW1lZERlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRXhwb3J0TmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwgc3BlY2lmaWVycywgc291cmNlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRXhwb3J0TmFtZWREZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuc3BlY2lmaWVycyA9IHNwZWNpZmllcnM7XHJcblx0ICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRXhwb3J0TmFtZWREZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRXhwb3J0TmFtZWREZWNsYXJhdGlvbiA9IEV4cG9ydE5hbWVkRGVjbGFyYXRpb247XHJcblx0dmFyIEV4cG9ydFNwZWNpZmllciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEV4cG9ydFNwZWNpZmllcihsb2NhbCwgZXhwb3J0ZWQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FeHBvcnRTcGVjaWZpZXI7XHJcblx0ICAgICAgICB0aGlzLmV4cG9ydGVkID0gZXhwb3J0ZWQ7XHJcblx0ICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEV4cG9ydFNwZWNpZmllcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRXhwb3J0U3BlY2lmaWVyID0gRXhwb3J0U3BlY2lmaWVyO1xyXG5cdHZhciBFeHByZXNzaW9uU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRXhwcmVzc2lvblN0YXRlbWVudChleHByZXNzaW9uKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRXhwcmVzc2lvblN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEV4cHJlc3Npb25TdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkV4cHJlc3Npb25TdGF0ZW1lbnQgPSBFeHByZXNzaW9uU3RhdGVtZW50O1xyXG5cdHZhciBGb3JJblN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEZvckluU3RhdGVtZW50KGxlZnQsIHJpZ2h0LCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRm9ySW5TdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZWFjaCA9IGZhbHNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBGb3JJblN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRm9ySW5TdGF0ZW1lbnQgPSBGb3JJblN0YXRlbWVudDtcclxuXHR2YXIgRm9yT2ZTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBGb3JPZlN0YXRlbWVudChsZWZ0LCByaWdodCwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZvck9mU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuXHQgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEZvck9mU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Gb3JPZlN0YXRlbWVudCA9IEZvck9mU3RhdGVtZW50O1xyXG5cdHZhciBGb3JTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBGb3JTdGF0ZW1lbnQoaW5pdCwgdGVzdCwgdXBkYXRlLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRm9yU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5pbml0ID0gaW5pdDtcclxuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XHJcblx0ICAgICAgICB0aGlzLnVwZGF0ZSA9IHVwZGF0ZTtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEZvclN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRm9yU3RhdGVtZW50ID0gRm9yU3RhdGVtZW50O1xyXG5cdHZhciBGdW5jdGlvbkRlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRnVuY3Rpb25EZWNsYXJhdGlvbihpZCwgcGFyYW1zLCBib2R5LCBnZW5lcmF0b3IpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuYXN5bmMgPSBmYWxzZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRnVuY3Rpb25EZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRnVuY3Rpb25EZWNsYXJhdGlvbiA9IEZ1bmN0aW9uRGVjbGFyYXRpb247XHJcblx0dmFyIEZ1bmN0aW9uRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEZ1bmN0aW9uRXhwcmVzc2lvbihpZCwgcGFyYW1zLCBib2R5LCBnZW5lcmF0b3IpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5GdW5jdGlvbkV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGdlbmVyYXRvcjtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5hc3luYyA9IGZhbHNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkZ1bmN0aW9uRXhwcmVzc2lvbiA9IEZ1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR2YXIgSWRlbnRpZmllciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIElkZW50aWZpZXIobmFtZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXI7XHJcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBJZGVudGlmaWVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5JZGVudGlmaWVyID0gSWRlbnRpZmllcjtcclxuXHR2YXIgSWZTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBJZlN0YXRlbWVudCh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JZlN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xyXG5cdCAgICAgICAgdGhpcy5hbHRlcm5hdGUgPSBhbHRlcm5hdGU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIElmU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5JZlN0YXRlbWVudCA9IElmU3RhdGVtZW50O1xyXG5cdHZhciBJbXBvcnREZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEltcG9ydERlY2xhcmF0aW9uKHNwZWNpZmllcnMsIHNvdXJjZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkltcG9ydERlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5zcGVjaWZpZXJzID0gc3BlY2lmaWVycztcclxuXHQgICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBJbXBvcnREZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSW1wb3J0RGVjbGFyYXRpb24gPSBJbXBvcnREZWNsYXJhdGlvbjtcclxuXHR2YXIgSW1wb3J0RGVmYXVsdFNwZWNpZmllciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEltcG9ydERlZmF1bHRTcGVjaWZpZXIobG9jYWwpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JbXBvcnREZWZhdWx0U3BlY2lmaWVyO1xyXG5cdCAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBJbXBvcnREZWZhdWx0U3BlY2lmaWVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5JbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gSW1wb3J0RGVmYXVsdFNwZWNpZmllcjtcclxuXHR2YXIgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKGxvY2FsKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xyXG5cdCAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcclxuXHR2YXIgSW1wb3J0U3BlY2lmaWVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSW1wb3J0U3BlY2lmaWVyKGxvY2FsLCBpbXBvcnRlZCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkltcG9ydFNwZWNpZmllcjtcclxuXHQgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcclxuXHQgICAgICAgIHRoaXMuaW1wb3J0ZWQgPSBpbXBvcnRlZDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSW1wb3J0U3BlY2lmaWVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5JbXBvcnRTcGVjaWZpZXIgPSBJbXBvcnRTcGVjaWZpZXI7XHJcblx0dmFyIExhYmVsZWRTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBMYWJlbGVkU3RhdGVtZW50KGxhYmVsLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTGFiZWxlZFN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIExhYmVsZWRTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkxhYmVsZWRTdGF0ZW1lbnQgPSBMYWJlbGVkU3RhdGVtZW50O1xyXG5cdHZhciBMaXRlcmFsID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gTGl0ZXJhbCh2YWx1ZSwgcmF3KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTGl0ZXJhbDtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgICAgIHRoaXMucmF3ID0gcmF3O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBMaXRlcmFsO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5MaXRlcmFsID0gTGl0ZXJhbDtcclxuXHR2YXIgTWV0YVByb3BlcnR5ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gTWV0YVByb3BlcnR5KG1ldGEsIHByb3BlcnR5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTWV0YVByb3BlcnR5O1xyXG5cdCAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcclxuXHQgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gTWV0YVByb3BlcnR5O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5NZXRhUHJvcGVydHkgPSBNZXRhUHJvcGVydHk7XHJcblx0dmFyIE1ldGhvZERlZmluaXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBNZXRob2REZWZpbml0aW9uKGtleSwgY29tcHV0ZWQsIHZhbHVlLCBraW5kLCBpc1N0YXRpYykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk1ldGhvZERlZmluaXRpb247XHJcblx0ICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuXHQgICAgICAgIHRoaXMuY29tcHV0ZWQgPSBjb21wdXRlZDtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XHJcblx0ICAgICAgICB0aGlzLnN0YXRpYyA9IGlzU3RhdGljO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBNZXRob2REZWZpbml0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5NZXRob2REZWZpbml0aW9uID0gTWV0aG9kRGVmaW5pdGlvbjtcclxuXHR2YXIgTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gTW9kdWxlKGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Qcm9ncmFtO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuc291cmNlVHlwZSA9ICdtb2R1bGUnO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBNb2R1bGU7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLk1vZHVsZSA9IE1vZHVsZTtcclxuXHR2YXIgTmV3RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIE5ld0V4cHJlc3Npb24oY2FsbGVlLCBhcmdzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTmV3RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuY2FsbGVlID0gY2FsbGVlO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudHMgPSBhcmdzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBOZXdFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5OZXdFeHByZXNzaW9uID0gTmV3RXhwcmVzc2lvbjtcclxuXHR2YXIgT2JqZWN0RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIE9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk9iamVjdEV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBPYmplY3RFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5PYmplY3RFeHByZXNzaW9uID0gT2JqZWN0RXhwcmVzc2lvbjtcclxuXHR2YXIgT2JqZWN0UGF0dGVybiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIE9iamVjdFBhdHRlcm4ocHJvcGVydGllcykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk9iamVjdFBhdHRlcm47XHJcblx0ICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBPYmplY3RQYXR0ZXJuO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5PYmplY3RQYXR0ZXJuID0gT2JqZWN0UGF0dGVybjtcclxuXHR2YXIgUHJvcGVydHkgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBQcm9wZXJ0eShraW5kLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgbWV0aG9kLCBzaG9ydGhhbmQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Qcm9wZXJ0eTtcclxuXHQgICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG5cdCAgICAgICAgdGhpcy5jb21wdXRlZCA9IGNvbXB1dGVkO1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgdGhpcy5raW5kID0ga2luZDtcclxuXHQgICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xyXG5cdCAgICAgICAgdGhpcy5zaG9ydGhhbmQgPSBzaG9ydGhhbmQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFByb3BlcnR5O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Qcm9wZXJ0eSA9IFByb3BlcnR5O1xyXG5cdHZhciBSZWdleExpdGVyYWwgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBSZWdleExpdGVyYWwodmFsdWUsIHJhdywgcGF0dGVybiwgZmxhZ3MpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5MaXRlcmFsO1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgdGhpcy5yYXcgPSByYXc7XHJcblx0ICAgICAgICB0aGlzLnJlZ2V4ID0geyBwYXR0ZXJuOiBwYXR0ZXJuLCBmbGFnczogZmxhZ3MgfTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gUmVnZXhMaXRlcmFsO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5SZWdleExpdGVyYWwgPSBSZWdleExpdGVyYWw7XHJcblx0dmFyIFJlc3RFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gUmVzdEVsZW1lbnQoYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5SZXN0RWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gUmVzdEVsZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlJlc3RFbGVtZW50ID0gUmVzdEVsZW1lbnQ7XHJcblx0dmFyIFJldHVyblN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFJldHVyblN0YXRlbWVudChhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlJldHVyblN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gUmV0dXJuU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5SZXR1cm5TdGF0ZW1lbnQgPSBSZXR1cm5TdGF0ZW1lbnQ7XHJcblx0dmFyIFNjcmlwdCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFNjcmlwdChib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguUHJvZ3JhbTtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLnNvdXJjZVR5cGUgPSAnc2NyaXB0JztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU2NyaXB0O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5TY3JpcHQgPSBTY3JpcHQ7XHJcblx0dmFyIFNlcXVlbmNlRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlNlcXVlbmNlRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU2VxdWVuY2VFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5TZXF1ZW5jZUV4cHJlc3Npb24gPSBTZXF1ZW5jZUV4cHJlc3Npb247XHJcblx0dmFyIFNwcmVhZEVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTcHJlYWRFbGVtZW50KGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguU3ByZWFkRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU3ByZWFkRWxlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU3ByZWFkRWxlbWVudCA9IFNwcmVhZEVsZW1lbnQ7XHJcblx0dmFyIFN0YXRpY01lbWJlckV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTdGF0aWNNZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5jb21wdXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblx0ICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFN0YXRpY01lbWJlckV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlN0YXRpY01lbWJlckV4cHJlc3Npb24gPSBTdGF0aWNNZW1iZXJFeHByZXNzaW9uO1xyXG5cdHZhciBTdXBlciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFN1cGVyKCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlN1cGVyO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTdXBlcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU3VwZXIgPSBTdXBlcjtcclxuXHR2YXIgU3dpdGNoQ2FzZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFN3aXRjaENhc2UodGVzdCwgY29uc2VxdWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlN3aXRjaENhc2U7XHJcblx0ICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xyXG5cdCAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU3dpdGNoQ2FzZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU3dpdGNoQ2FzZSA9IFN3aXRjaENhc2U7XHJcblx0dmFyIFN3aXRjaFN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFN3aXRjaFN0YXRlbWVudChkaXNjcmltaW5hbnQsIGNhc2VzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguU3dpdGNoU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5kaXNjcmltaW5hbnQgPSBkaXNjcmltaW5hbnQ7XHJcblx0ICAgICAgICB0aGlzLmNhc2VzID0gY2FzZXM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFN3aXRjaFN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU3dpdGNoU3RhdGVtZW50ID0gU3dpdGNoU3RhdGVtZW50O1xyXG5cdHZhciBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24odGFnLCBxdWFzaSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMudGFnID0gdGFnO1xyXG5cdCAgICAgICAgdGhpcy5xdWFzaSA9IHF1YXNpO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiA9IFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjtcclxuXHR2YXIgVGVtcGxhdGVFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVGVtcGxhdGVFbGVtZW50KHZhbHVlLCB0YWlsKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVGVtcGxhdGVFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgdGhpcy50YWlsID0gdGFpbDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVGVtcGxhdGVFbGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5UZW1wbGF0ZUVsZW1lbnQgPSBUZW1wbGF0ZUVsZW1lbnQ7XHJcblx0dmFyIFRlbXBsYXRlTGl0ZXJhbCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRlbXBsYXRlTGl0ZXJhbChxdWFzaXMsIGV4cHJlc3Npb25zKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVGVtcGxhdGVMaXRlcmFsO1xyXG5cdCAgICAgICAgdGhpcy5xdWFzaXMgPSBxdWFzaXM7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFRlbXBsYXRlTGl0ZXJhbDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsID0gVGVtcGxhdGVMaXRlcmFsO1xyXG5cdHZhciBUaGlzRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRoaXNFeHByZXNzaW9uKCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlRoaXNFeHByZXNzaW9uO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBUaGlzRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVGhpc0V4cHJlc3Npb24gPSBUaGlzRXhwcmVzc2lvbjtcclxuXHR2YXIgVGhyb3dTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUaHJvd1N0YXRlbWVudChhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlRocm93U3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBUaHJvd1N0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVGhyb3dTdGF0ZW1lbnQgPSBUaHJvd1N0YXRlbWVudDtcclxuXHR2YXIgVHJ5U3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVHJ5U3RhdGVtZW50KGJsb2NrLCBoYW5kbGVyLCBmaW5hbGl6ZXIpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5UcnlTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2s7XHJcblx0ICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cdCAgICAgICAgdGhpcy5maW5hbGl6ZXIgPSBmaW5hbGl6ZXI7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFRyeVN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVHJ5U3RhdGVtZW50ID0gVHJ5U3RhdGVtZW50O1xyXG5cdHZhciBVbmFyeUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBVbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVW5hcnlFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICAgICAgdGhpcy5wcmVmaXggPSB0cnVlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBVbmFyeUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlVuYXJ5RXhwcmVzc2lvbiA9IFVuYXJ5RXhwcmVzc2lvbjtcclxuXHR2YXIgVXBkYXRlRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFVwZGF0ZUV4cHJlc3Npb24ob3BlcmF0b3IsIGFyZ3VtZW50LCBwcmVmaXgpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5VcGRhdGVFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFVwZGF0ZUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlVwZGF0ZUV4cHJlc3Npb24gPSBVcGRhdGVFeHByZXNzaW9uO1xyXG5cdHZhciBWYXJpYWJsZURlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5kZWNsYXJhdGlvbnMgPSBkZWNsYXJhdGlvbnM7XHJcblx0ICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBWYXJpYWJsZURlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5WYXJpYWJsZURlY2xhcmF0aW9uID0gVmFyaWFibGVEZWNsYXJhdGlvbjtcclxuXHR2YXIgVmFyaWFibGVEZWNsYXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVmFyaWFibGVEZWNsYXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5pbml0ID0gaW5pdDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVmFyaWFibGVEZWNsYXJhdG9yO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5WYXJpYWJsZURlY2xhcmF0b3IgPSBWYXJpYWJsZURlY2xhcmF0b3I7XHJcblx0dmFyIFdoaWxlU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gV2hpbGVTdGF0ZW1lbnQodGVzdCwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LldoaWxlU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFdoaWxlU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5XaGlsZVN0YXRlbWVudCA9IFdoaWxlU3RhdGVtZW50O1xyXG5cdHZhciBXaXRoU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gV2l0aFN0YXRlbWVudChvYmplY3QsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5XaXRoU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBXaXRoU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5XaXRoU3RhdGVtZW50ID0gV2l0aFN0YXRlbWVudDtcclxuXHR2YXIgWWllbGRFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gWWllbGRFeHByZXNzaW9uKGFyZ3VtZW50LCBkZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LllpZWxkRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gWWllbGRFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5ZaWVsZEV4cHJlc3Npb24gPSBZaWVsZEV4cHJlc3Npb247XHJcblxuXG4vKioqLyB9LFxuLyogOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBhc3NlcnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcblx0dmFyIGVycm9yX2hhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5cdHZhciBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcblx0dmFyIE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG5cdHZhciBzY2FubmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxuXHR2YXIgc3ludGF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cdHZhciB0b2tlbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcblx0dmFyIEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIgPSAnQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcic7XHJcblx0dmFyIFBhcnNlciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFBhcnNlcihjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuXHQgICAgICAgIHRoaXMuY29uZmlnID0ge1xyXG5cdCAgICAgICAgICAgIHJhbmdlOiAodHlwZW9mIG9wdGlvbnMucmFuZ2UgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5yYW5nZSxcclxuXHQgICAgICAgICAgICBsb2M6ICh0eXBlb2Ygb3B0aW9ucy5sb2MgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5sb2MsXHJcblx0ICAgICAgICAgICAgc291cmNlOiBudWxsLFxyXG5cdCAgICAgICAgICAgIHRva2VuczogKHR5cGVvZiBvcHRpb25zLnRva2VucyA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnRva2VucyxcclxuXHQgICAgICAgICAgICBjb21tZW50OiAodHlwZW9mIG9wdGlvbnMuY29tbWVudCA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLmNvbW1lbnQsXHJcblx0ICAgICAgICAgICAgdG9sZXJhbnQ6ICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnRvbGVyYW50XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvYyAmJiBvcHRpb25zLnNvdXJjZSAmJiBvcHRpb25zLnNvdXJjZSAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29uZmlnLnNvdXJjZSA9IFN0cmluZyhvcHRpb25zLnNvdXJjZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlciA9IG5ldyBlcnJvcl9oYW5kbGVyXzEuRXJyb3JIYW5kbGVyKCk7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlci50b2xlcmFudCA9IHRoaXMuY29uZmlnLnRvbGVyYW50O1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyID0gbmV3IHNjYW5uZXJfMS5TY2FubmVyKGNvZGUsIHRoaXMuZXJyb3JIYW5kbGVyKTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci50cmFja0NvbW1lbnQgPSB0aGlzLmNvbmZpZy5jb21tZW50O1xyXG5cdCAgICAgICAgdGhpcy5vcGVyYXRvclByZWNlZGVuY2UgPSB7XHJcblx0ICAgICAgICAgICAgJyknOiAwLFxyXG5cdCAgICAgICAgICAgICc7JzogMCxcclxuXHQgICAgICAgICAgICAnLCc6IDAsXHJcblx0ICAgICAgICAgICAgJz0nOiAwLFxyXG5cdCAgICAgICAgICAgICddJzogMCxcclxuXHQgICAgICAgICAgICAnfHwnOiAxLFxyXG5cdCAgICAgICAgICAgICcmJic6IDIsXHJcblx0ICAgICAgICAgICAgJ3wnOiAzLFxyXG5cdCAgICAgICAgICAgICdeJzogNCxcclxuXHQgICAgICAgICAgICAnJic6IDUsXHJcblx0ICAgICAgICAgICAgJz09JzogNixcclxuXHQgICAgICAgICAgICAnIT0nOiA2LFxyXG5cdCAgICAgICAgICAgICc9PT0nOiA2LFxyXG5cdCAgICAgICAgICAgICchPT0nOiA2LFxyXG5cdCAgICAgICAgICAgICc8JzogNyxcclxuXHQgICAgICAgICAgICAnPic6IDcsXHJcblx0ICAgICAgICAgICAgJzw9JzogNyxcclxuXHQgICAgICAgICAgICAnPj0nOiA3LFxyXG5cdCAgICAgICAgICAgICc8PCc6IDgsXHJcblx0ICAgICAgICAgICAgJz4+JzogOCxcclxuXHQgICAgICAgICAgICAnPj4+JzogOCxcclxuXHQgICAgICAgICAgICAnKyc6IDksXHJcblx0ICAgICAgICAgICAgJy0nOiA5LFxyXG5cdCAgICAgICAgICAgICcqJzogMTEsXHJcblx0ICAgICAgICAgICAgJy8nOiAxMSxcclxuXHQgICAgICAgICAgICAnJSc6IDExXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgdGhpcy5sb29rYWhlYWQgPSB7XHJcblx0ICAgICAgICAgICAgdHlwZTogMiAvKiBFT0YgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6ICcnLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogMCxcclxuXHQgICAgICAgICAgICBzdGFydDogMCxcclxuXHQgICAgICAgICAgICBlbmQ6IDBcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICB0aGlzLmhhc0xpbmVUZXJtaW5hdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQgPSB7XHJcblx0ICAgICAgICAgICAgaXNNb2R1bGU6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGF3YWl0OiBmYWxzZSxcclxuXHQgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIGFsbG93U3RyaWN0RGlyZWN0aXZlOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIGFsbG93WWllbGQ6IHRydWUsXHJcblx0ICAgICAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yOiBudWxsLFxyXG5cdCAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldDogZmFsc2UsXHJcblx0ICAgICAgICAgICAgaXNCaW5kaW5nRWxlbWVudDogZmFsc2UsXHJcblx0ICAgICAgICAgICAgaW5GdW5jdGlvbkJvZHk6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGluSXRlcmF0aW9uOiBmYWxzZSxcclxuXHQgICAgICAgICAgICBpblN3aXRjaDogZmFsc2UsXHJcblx0ICAgICAgICAgICAgbGFiZWxTZXQ6IHt9LFxyXG5cdCAgICAgICAgICAgIHN0cmljdDogZmFsc2VcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlciA9IHtcclxuXHQgICAgICAgICAgICBpbmRleDogMCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBjb2x1bW46IDBcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIgPSB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IDAsXHJcblx0ICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiAwXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlciA9IHtcclxuXHQgICAgICAgICAgICBpbmRleDogdGhpcy5zY2FubmVyLmluZGV4LFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfVxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnRocm93RXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZUZvcm1hdCkge1xyXG5cdCAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xyXG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuXHQgICAgICAgICAgICB2YWx1ZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblx0ICAgICAgICB2YXIgbXNnID0gbWVzc2FnZUZvcm1hdC5yZXBsYWNlKC8lKFxcZCkvZywgZnVuY3Rpb24gKHdob2xlLCBpZHgpIHtcclxuXHQgICAgICAgICAgICBhc3NlcnRfMS5hc3NlcnQoaWR4IDwgYXJncy5sZW5ndGgsICdNZXNzYWdlIHJlZmVyZW5jZSBtdXN0IGJlIGluIHJhbmdlJyk7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGFyZ3NbaWR4XTtcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5sYXN0TWFya2VyLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxhc3RNYXJrZXIubGluZTtcclxuXHQgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmxhc3RNYXJrZXIuY29sdW1uICsgMTtcclxuXHQgICAgICAgIHRocm93IHRoaXMuZXJyb3JIYW5kbGVyLmNyZWF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2x1bW4sIG1zZyk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUudG9sZXJhdGVFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlRm9ybWF0KSB7XHJcblx0ICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG5cdCAgICAgICAgICAgIHZhbHVlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHQgICAgICAgIHZhciBtc2cgPSBtZXNzYWdlRm9ybWF0LnJlcGxhY2UoLyUoXFxkKS9nLCBmdW5jdGlvbiAod2hvbGUsIGlkeCkge1xyXG5cdCAgICAgICAgICAgIGFzc2VydF8xLmFzc2VydChpZHggPCBhcmdzLmxlbmd0aCwgJ01lc3NhZ2UgcmVmZXJlbmNlIG11c3QgYmUgaW4gcmFuZ2UnKTtcclxuXHQgICAgICAgICAgICByZXR1cm4gYXJnc1tpZHhdO1xyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxhc3RNYXJrZXIuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgbGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubGFzdE1hcmtlci5jb2x1bW4gKyAxO1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIudG9sZXJhdGVFcnJvcihpbmRleCwgbGluZSwgY29sdW1uLCBtc2cpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBUaHJvdyBhbiBleGNlcHRpb24gYmVjYXVzZSBvZiB0aGUgdG9rZW4uXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUudW5leHBlY3RlZFRva2VuRXJyb3IgPSBmdW5jdGlvbiAodG9rZW4sIG1lc3NhZ2UpIHtcclxuXHQgICAgICAgIHZhciBtc2cgPSBtZXNzYWdlIHx8IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlO1xyXG5cdCAgICAgICAgaWYgKHRva2VuKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCFtZXNzYWdlKSB7XHJcblx0ICAgICAgICAgICAgICAgIG1zZyA9ICh0b2tlbi50eXBlID09PSAyIC8qIEVPRiAqLykgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRFT1MgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRJZGVudGlmaWVyIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gNiAvKiBOdW1lcmljTGl0ZXJhbCAqLykgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWROdW1iZXIgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gOCAvKiBTdHJpbmdMaXRlcmFsICovKSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFN0cmluZyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gMTAgLyogVGVtcGxhdGUgKi8pID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVGVtcGxhdGUgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gNCAvKiBLZXl3b3JkICovKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzRnV0dXJlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFJlc2VydmVkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdG9rZW4udmFsdWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9ICdJTExFR0FMJztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKCclMCcsIHZhbHVlKTtcclxuXHQgICAgICAgIGlmICh0b2tlbiAmJiB0eXBlb2YgdG9rZW4ubGluZU51bWJlciA9PT0gJ251bWJlcicpIHtcclxuXHQgICAgICAgICAgICB2YXIgaW5kZXggPSB0b2tlbi5zdGFydDtcclxuXHQgICAgICAgICAgICB2YXIgbGluZSA9IHRva2VuLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgdmFyIGxhc3RNYXJrZXJMaW5lU3RhcnQgPSB0aGlzLmxhc3RNYXJrZXIuaW5kZXggLSB0aGlzLmxhc3RNYXJrZXIuY29sdW1uO1xyXG5cdCAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0b2tlbi5zdGFydCAtIGxhc3RNYXJrZXJMaW5lU3RhcnQgKyAxO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9ySGFuZGxlci5jcmVhdGVFcnJvcihpbmRleCwgbGluZSwgY29sdW1uLCBtc2cpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5sYXN0TWFya2VyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHZhciBsaW5lID0gdGhpcy5sYXN0TWFya2VyLmxpbmU7XHJcblx0ICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubGFzdE1hcmtlci5jb2x1bW4gKyAxO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9ySGFuZGxlci5jcmVhdGVFcnJvcihpbmRleCwgbGluZSwgY29sdW1uLCBtc2cpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnRocm93VW5leHBlY3RlZFRva2VuID0gZnVuY3Rpb24gKHRva2VuLCBtZXNzYWdlKSB7XHJcblx0ICAgICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWRUb2tlbkVycm9yKHRva2VuLCBtZXNzYWdlKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbiwgbWVzc2FnZSkge1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIudG9sZXJhdGUodGhpcy51bmV4cGVjdGVkVG9rZW5FcnJvcih0b2tlbiwgbWVzc2FnZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmNvbGxlY3RDb21tZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICghdGhpcy5jb25maWcuY29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhciBjb21tZW50cyA9IHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcclxuXHQgICAgICAgICAgICBpZiAoY29tbWVudHMubGVuZ3RoID4gMCAmJiB0aGlzLmRlbGVnYXRlKSB7XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWVudHMubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlID0gY29tbWVudHNbaV07XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcclxuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZS5tdWx0aUxpbmUgPyAnQmxvY2tDb21tZW50JyA6ICdMaW5lQ29tbWVudCcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc2Nhbm5lci5zb3VyY2Uuc2xpY2UoZS5zbGljZVswXSwgZS5zbGljZVsxXSlcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcucmFuZ2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJhbmdlID0gZS5yYW5nZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5sb2MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmxvYyA9IGUubG9jO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGUubG9jLnN0YXJ0LmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogZS5sb2Muc3RhcnQuY29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGUucmFuZ2VbMF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVuZDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBlLmxvYy5lbmQubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBlLmxvYy5lbmQuY29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGUucmFuZ2VbMV1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZShub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIEZyb20gaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gdG8gYW4gZXh0ZXJuYWwgc3RydWN0dXJlXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuZ2V0VG9rZW5SYXcgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLnNjYW5uZXIuc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmNvbnZlcnRUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgdmFyIHQgPSB7XHJcblx0ICAgICAgICAgICAgdHlwZTogdG9rZW5fMS5Ub2tlbk5hbWVbdG9rZW4udHlwZV0sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnJhbmdlKSB7XHJcblx0ICAgICAgICAgICAgdC5yYW5nZSA9IFt0b2tlbi5zdGFydCwgdG9rZW4uZW5kXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy5sb2MpIHtcclxuXHQgICAgICAgICAgICB0LmxvYyA9IHtcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMuc3RhcnRNYXJrZXIubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zdGFydE1hcmtlci5jb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA5IC8qIFJlZ3VsYXJFeHByZXNzaW9uICovKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSB0b2tlbi5wYXR0ZXJuO1xyXG5cdCAgICAgICAgICAgIHZhciBmbGFncyA9IHRva2VuLmZsYWdzO1xyXG5cdCAgICAgICAgICAgIHQucmVnZXggPSB7IHBhdHRlcm46IHBhdHRlcm4sIGZsYWdzOiBmbGFncyB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubmV4dFRva2VuID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICB0aGlzLmNvbGxlY3RDb21tZW50cygpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pbmRleCAhPT0gdGhpcy5zdGFydE1hcmtlci5pbmRleCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdGhpcy5zdGFydE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgdGhpcy5zdGFydE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5leHQgPSB0aGlzLnNjYW5uZXIubGV4KCk7XHJcblx0ICAgICAgICB0aGlzLmhhc0xpbmVUZXJtaW5hdG9yID0gKHRva2VuLmxpbmVOdW1iZXIgIT09IG5leHQubGluZU51bWJlcik7XHJcblx0ICAgICAgICBpZiAobmV4dCAmJiB0aGlzLmNvbnRleHQuc3RyaWN0ICYmIG5leHQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQobmV4dC52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgbmV4dC50eXBlID0gNCAvKiBLZXl3b3JkICovO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMubG9va2FoZWFkID0gbmV4dDtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy50b2tlbnMgJiYgbmV4dC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2godGhpcy5jb252ZXJ0VG9rZW4obmV4dCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRva2VuO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm5leHRSZWdleFRva2VuID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5jb2xsZWN0Q29tbWVudHMoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMuc2Nhbm5lci5zY2FuUmVnRXhwKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9rZW5zKSB7XHJcblx0ICAgICAgICAgICAgLy8gUG9wIHRoZSBwcmV2aW91cyB0b2tlbiwgJy8nIG9yICcvPSdcclxuXHQgICAgICAgICAgICAvLyBUaGlzIGlzIGFkZGVkIGZyb20gdGhlIGxvb2thaGVhZCB0b2tlbi5cclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wb3AoKTtcclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHRoaXMuY29udmVydFRva2VuKHRva2VuKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBQcmltZSB0aGUgbmV4dCBsb29rYWhlYWQuXHJcblx0ICAgICAgICB0aGlzLmxvb2thaGVhZCA9IHRva2VuO1xyXG5cdCAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHJldHVybiB0b2tlbjtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVOb2RlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBpbmRleDogdGhpcy5zdGFydE1hcmtlci5pbmRleCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0aGlzLnN0YXJ0TWFya2VyLmxpbmUsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtblxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5zdGFydE5vZGUgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IHRva2VuLnN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRva2VuLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiB0b2tlbi5zdGFydCAtIHRva2VuLmxpbmVTdGFydFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uIChtYXJrZXIsIG5vZGUpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy5yYW5nZSkge1xyXG5cdCAgICAgICAgICAgIG5vZGUucmFuZ2UgPSBbbWFya2VyLmluZGV4LCB0aGlzLmxhc3RNYXJrZXIuaW5kZXhdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvYykge1xyXG5cdCAgICAgICAgICAgIG5vZGUubG9jID0ge1xyXG5cdCAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogbWFya2VyLmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IG1hcmtlci5jb2x1bW4sXHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIGVuZDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5sYXN0TWFya2VyLmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMubGFzdE1hcmtlci5jb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnNvdXJjZSkge1xyXG5cdCAgICAgICAgICAgICAgICBub2RlLmxvYy5zb3VyY2UgPSB0aGlzLmNvbmZpZy5zb3VyY2U7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUpIHtcclxuXHQgICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiBtYXJrZXIubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogbWFya2VyLmNvbHVtbixcclxuXHQgICAgICAgICAgICAgICAgICAgIG9mZnNldDogbWFya2VyLmluZGV4XHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIGVuZDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5sYXN0TWFya2VyLmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMubGFzdE1hcmtlci5jb2x1bW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMubGFzdE1hcmtlci5pbmRleFxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICB0aGlzLmRlbGVnYXRlKG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBub2RlO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxyXG5cdCAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5leHBlY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gNyAvKiBQdW5jdHVhdG9yICovIHx8IHRva2VuLnZhbHVlICE9PSB2YWx1ZSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBRdWlldGx5IGV4cGVjdCBhIGNvbW1hIHdoZW4gaW4gdG9sZXJhbnQgbW9kZSwgb3RoZXJ3aXNlIGRlbGVnYXRlcyB0byBleHBlY3QoKS5cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5leHBlY3RDb21tYVNlcGFyYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgdG9rZW4udmFsdWUgPT09ICcsJykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgdG9rZW4udmFsdWUgPT09ICc7Jykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBrZXl3b3JkLlxyXG5cdCAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5leHBlY3RLZXl3b3JkID0gZnVuY3Rpb24gKGtleXdvcmQpIHtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gNCAvKiBLZXl3b3JkICovIHx8IHRva2VuLnZhbHVlICE9PSBrZXl3b3JkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5sb29rYWhlYWQudHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSB2YWx1ZTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleXdvcmRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5tYXRjaEtleXdvcmQgPSBmdW5jdGlvbiAoa2V5d29yZCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyAmJiB0aGlzLmxvb2thaGVhZC52YWx1ZSA9PT0ga2V5d29yZDtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGNvbnRleHR1YWwga2V5d29yZFxyXG5cdCAgICAvLyAod2hlcmUgYW4gaWRlbnRpZmllciBpcyBzb21ldGltZXMgYSBrZXl3b3JkIGRlcGVuZGluZyBvbiB0aGUgY29udGV4dClcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5tYXRjaENvbnRleHR1YWxLZXl3b3JkID0gZnVuY3Rpb24gKGtleXdvcmQpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgdGhpcy5sb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIGlzIGFuIGFzc2lnbm1lbnQgb3BlcmF0b3JcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5tYXRjaEFzc2lnbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSA3IC8qIFB1bmN0dWF0b3IgKi8pIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgb3AgPSB0aGlzLmxvb2thaGVhZC52YWx1ZTtcclxuXHQgICAgICAgIHJldHVybiBvcCA9PT0gJz0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICcqPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJyoqPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJy89JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnJT0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICcrPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJy09JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnPDw9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnPj49JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnPj4+PScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJyY9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnXj0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICd8PSc7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIENvdmVyIGdyYW1tYXIgc3VwcG9ydC5cclxuXHQgICAgLy9cclxuXHQgICAgLy8gV2hlbiBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24gcG9zaXRpb24gc3RhcnRzIHdpdGggYW4gbGVmdCBwYXJlbnRoZXNpcywgdGhlIGRldGVybWluYXRpb24gb2YgdGhlIHR5cGVcclxuXHQgICAgLy8gb2YgdGhlIHN5bnRheCBpcyB0byBiZSBkZWZlcnJlZCBhcmJpdHJhcmlseSBsb25nIHVudGlsIHRoZSBlbmQgb2YgdGhlIHBhcmVudGhlc2VzIHBhaXIgKHBsdXMgYSBsb29rYWhlYWQpXHJcblx0ICAgIC8vIG9yIHRoZSBmaXJzdCBjb21tYS4gVGhpcyBzaXR1YXRpb24gYWxzbyBkZWZlcnMgdGhlIGRldGVybWluYXRpb24gb2YgYWxsIHRoZSBleHByZXNzaW9ucyBuZXN0ZWQgaW4gdGhlIHBhaXIuXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIFRoZXJlIGFyZSB0aHJlZSBwcm9kdWN0aW9ucyB0aGF0IGNhbiBiZSBwYXJzZWQgaW4gYSBwYXJlbnRoZXNlcyBwYWlyIHRoYXQgbmVlZHMgdG8gYmUgZGV0ZXJtaW5lZFxyXG5cdCAgICAvLyBhZnRlciB0aGUgb3V0ZXJtb3N0IHBhaXIgaXMgY2xvc2VkLiBUaGV5IGFyZTpcclxuXHQgICAgLy9cclxuXHQgICAgLy8gICAxLiBBc3NpZ25tZW50RXhwcmVzc2lvblxyXG5cdCAgICAvLyAgIDIuIEJpbmRpbmdFbGVtZW50c1xyXG5cdCAgICAvLyAgIDMuIEFzc2lnbm1lbnRUYXJnZXRzXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIEluIG9yZGVyIHRvIGF2b2lkIGV4cG9uZW50aWFsIGJhY2t0cmFja2luZywgd2UgdXNlIHR3byBmbGFncyB0byBkZW5vdGUgaWYgdGhlIHByb2R1Y3Rpb24gY2FuIGJlXHJcblx0ICAgIC8vIGJpbmRpbmcgZWxlbWVudCBvciBhc3NpZ25tZW50IHRhcmdldC5cclxuXHQgICAgLy9cclxuXHQgICAgLy8gVGhlIHRocmVlIHByb2R1Y3Rpb25zIGhhdmUgdGhlIHJlbGF0aW9uc2hpcDpcclxuXHQgICAgLy9cclxuXHQgICAgLy8gICBCaW5kaW5nRWxlbWVudHMg4oqGIEFzc2lnbm1lbnRUYXJnZXRzIOKKhiBBc3NpZ25tZW50RXhwcmVzc2lvblxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyB3aXRoIGEgc2luZ2xlIGV4Y2VwdGlvbiB0aGF0IENvdmVySW5pdGlhbGl6ZWROYW1lIHdoZW4gdXNlZCBkaXJlY3RseSBpbiBhbiBFeHByZXNzaW9uLCBnZW5lcmF0ZXNcclxuXHQgICAgLy8gYW4gZWFybHkgZXJyb3IuIFRoZXJlZm9yZSwgd2UgbmVlZCB0aGUgdGhpcmQgc3RhdGUsIGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciwgdG8gdHJhY2sgdGhlXHJcblx0ICAgIC8vIGZpcnN0IHVzYWdlIG9mIENvdmVySW5pdGlhbGl6ZWROYW1lIGFuZCByZXBvcnQgaXQgd2hlbiB3ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHBhcmVudGhlc2VzIHBhaXIuXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIGlzb2xhdGVDb3ZlckdyYW1tYXIgZnVuY3Rpb24gcnVucyB0aGUgZ2l2ZW4gcGFyc2VyIGZ1bmN0aW9uIHdpdGggYSBuZXcgY292ZXIgZ3JhbW1hciBjb250ZXh0LCBhbmQgaXQgZG9lcyBub3RcclxuXHQgICAgLy8gZWZmZWN0IHRoZSBjdXJyZW50IGZsYWdzLiBUaGlzIG1lYW5zIHRoZSBwcm9kdWN0aW9uIHRoZSBwYXJzZXIgcGFyc2VzIGlzIG9ubHkgdXNlZCBhcyBhbiBleHByZXNzaW9uLiBUaGVyZWZvcmVcclxuXHQgICAgLy8gdGhlIENvdmVySW5pdGlhbGl6ZWROYW1lIGNoZWNrIGlzIGNvbmR1Y3RlZC5cclxuXHQgICAgLy9cclxuXHQgICAgLy8gaW5oZXJpdENvdmVyR3JhbW1hciBmdW5jdGlvbiBydW5zIHRoZSBnaXZlbiBwYXJzZSBmdW5jdGlvbiB3aXRoIGEgbmV3IGNvdmVyIGdyYW1tYXIgY29udGV4dCwgYW5kIGl0IHByb3BhZ2F0ZXNcclxuXHQgICAgLy8gdGhlIGZsYWdzIG91dHNpZGUgb2YgdGhlIHBhcnNlci4gVGhpcyBtZWFucyB0aGUgcHJvZHVjdGlvbiB0aGUgcGFyc2VyIHBhcnNlcyBpcyB1c2VkIGFzIGEgcGFydCBvZiBhIHBvdGVudGlhbFxyXG5cdCAgICAvLyBwYXR0ZXJuLiBUaGUgQ292ZXJJbml0aWFsaXplZE5hbWUgY2hlY2sgaXMgZGVmZXJyZWQuXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuaXNvbGF0ZUNvdmVyR3JhbW1hciA9IGZ1bmN0aW9uIChwYXJzZUZ1bmN0aW9uKSB7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJc0JpbmRpbmdFbGVtZW50ID0gdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJc0Fzc2lnbm1lbnRUYXJnZXQgPSB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcjtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VGdW5jdGlvbi5jYWxsKHRoaXMpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBwcmV2aW91c0lzQmluZGluZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gcHJldmlvdXNJc0Fzc2lnbm1lbnRUYXJnZXQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gcHJldmlvdXNGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I7XHJcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmluaGVyaXRDb3ZlckdyYW1tYXIgPSBmdW5jdGlvbiAocGFyc2VGdW5jdGlvbikge1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSXNCaW5kaW5nRWxlbWVudCA9IHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSXNBc3NpZ25tZW50VGFyZ2V0ID0gdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0ZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlRnVuY3Rpb24uY2FsbCh0aGlzKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgJiYgcHJldmlvdXNJc0JpbmRpbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgJiYgcHJldmlvdXNJc0Fzc2lnbm1lbnRUYXJnZXQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gcHJldmlvdXNGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgfHwgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcjtcclxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuY29uc3VtZVNlbWljb2xvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCc7JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8gJiYgIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5sYXN0TWFya2VyLmluZGV4ID0gdGhpcy5zdGFydE1hcmtlci5pbmRleDtcclxuXHQgICAgICAgICAgICB0aGlzLmxhc3RNYXJrZXIubGluZSA9IHRoaXMuc3RhcnRNYXJrZXIubGluZTtcclxuXHQgICAgICAgICAgICB0aGlzLmxhc3RNYXJrZXIuY29sdW1uID0gdGhpcy5zdGFydE1hcmtlci5jb2x1bW47XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByaW1hcnktZXhwcmVzc2lvblxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICB2YXIgdG9rZW4sIHJhdztcclxuXHQgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgMyAvKiBJZGVudGlmaWVyICovOlxyXG5cdCAgICAgICAgICAgICAgICBpZiAoKHRoaXMuY29udGV4dC5pc01vZHVsZSB8fCB0aGlzLmNvbnRleHQuYXdhaXQpICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSAnYXdhaXQnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5tYXRjaEFzeW5jRnVuY3Rpb24oKSA/IHRoaXMucGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKSA6IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0aGlzLm5leHRUb2tlbigpLnZhbHVlKSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNiAvKiBOdW1lcmljTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDggLyogU3RyaW5nTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgdGhpcy5sb29rYWhlYWQub2N0YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQsIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkxpdGVyYWwodG9rZW4udmFsdWUsIHJhdykpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDEgLyogQm9vbGVhbkxpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTGl0ZXJhbCh0b2tlbi52YWx1ZSA9PT0gJ3RydWUnLCByYXcpKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA1IC8qIE51bGxMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkxpdGVyYWwobnVsbCwgcmF3KSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgMTAgLyogVGVtcGxhdGUgKi86XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlVGVtcGxhdGVMaXRlcmFsKCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNyAvKiBQdW5jdHVhdG9yICovOlxyXG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICcoJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUdyb3VwRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdbJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBcnJheUluaXRpYWxpemVyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3snOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZU9iamVjdEluaXRpYWxpemVyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnLz0nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5pbmRleCA9IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLm5leHRSZWdleFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuUmVnZXhMaXRlcmFsKHRva2VuLnJlZ2V4LCByYXcsIHRva2VuLnBhdHRlcm4sIHRva2VuLmZsYWdzKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNCAvKiBLZXl3b3JkICovOlxyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5zdHJpY3QgJiYgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ3lpZWxkJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLm1hdGNoS2V5d29yZCgnbGV0JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIodGhpcy5uZXh0VG9rZW4oKS52YWx1ZSkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZnVuY3Rpb24nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlRnVuY3Rpb25FeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoS2V5d29yZCgndGhpcycpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UaGlzRXhwcmVzc2lvbigpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdjbGFzcycpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VDbGFzc0V4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LWluaXRpYWxpemVyXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTcHJlYWRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcuLi4nKTtcclxuXHQgICAgICAgIHZhciBhcmcgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlNwcmVhZEVsZW1lbnQoYXJnKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBcnJheUluaXRpYWxpemVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ1snKTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnXScpKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG51bGwpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcuLi4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VTcHJlYWRFbGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnXScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnXScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ10nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFycmF5RXhwcmVzc2lvbihlbGVtZW50cykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QtaW5pdGlhbGl6ZXJcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByb3BlcnR5TWV0aG9kID0gZnVuY3Rpb24gKHBhcmFtcykge1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZSA9IHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IHBhcmFtcy5zaW1wbGU7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBwYXJhbXMuZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihwYXJhbXMuZmlyc3RSZXN0cmljdGVkLCBwYXJhbXMubWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBwYXJhbXMuc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHBhcmFtcy5zdHJpY3RlZCwgcGFyYW1zLm1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgIHJldHVybiBib2R5O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJvcGVydHlNZXRob2RGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoKTtcclxuXHQgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2QocGFyYW1zKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRnVuY3Rpb25FeHByZXNzaW9uKG51bGwsIHBhcmFtcy5wYXJhbXMsIG1ldGhvZCwgaXNHZW5lcmF0b3IpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByb3BlcnR5TWV0aG9kQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBd2FpdCA9IHRoaXMuY29udGV4dC5hd2FpdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKCk7XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kKHBhcmFtcyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IHByZXZpb3VzQXdhaXQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Bc3luY0Z1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBwYXJhbXMucGFyYW1zLCBtZXRob2QpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9iamVjdFByb3BlcnR5S2V5ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB2YXIga2V5O1xyXG5cdCAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSA4IC8qIFN0cmluZ0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA2IC8qIE51bWVyaWNMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiB0b2tlbi5vY3RhbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHZhciByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5MaXRlcmFsKHRva2VuLnZhbHVlLCByYXcpKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAzIC8qIElkZW50aWZpZXIgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSAxIC8qIEJvb2xlYW5MaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNSAvKiBOdWxsTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDQgLyogS2V5d29yZCAqLzpcclxuXHQgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKHRva2VuLnZhbHVlKSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNyAvKiBQdW5jdHVhdG9yICovOlxyXG5cdCAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdbJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnXScpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAga2V5ID0gdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ga2V5O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmlzUHJvcGVydHlLZXkgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG5cdCAgICAgICAgcmV0dXJuIChrZXkudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIgJiYga2V5Lm5hbWUgPT09IHZhbHVlKSB8fFxyXG5cdCAgICAgICAgICAgIChrZXkudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkxpdGVyYWwgJiYga2V5LnZhbHVlID09PSB2YWx1ZSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VPYmplY3RQcm9wZXJ0eSA9IGZ1bmN0aW9uIChoYXNQcm90bykge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIGtpbmQ7XHJcblx0ICAgICAgICB2YXIga2V5ID0gbnVsbDtcclxuXHQgICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgY29tcHV0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBtZXRob2QgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBzaG9ydGhhbmQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBpc0FzeW5jID0gZmFsc2U7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0gdG9rZW4udmFsdWU7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBpc0FzeW5jID0gIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IgJiYgKGlkID09PSAnYXN5bmMnKSAmJlxyXG5cdCAgICAgICAgICAgICAgICAhdGhpcy5tYXRjaCgnOicpICYmICF0aGlzLm1hdGNoKCcoJykgJiYgIXRoaXMubWF0Y2goJyonKTtcclxuXHQgICAgICAgICAgICBrZXkgPSBpc0FzeW5jID8gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCkgOiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIoaWQpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJyonKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBsb29rYWhlYWRQcm9wZXJ0eUtleSA9IHRoaXMucXVhbGlmaWVkUHJvcGVydHlOYW1lKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgIWlzQXN5bmMgJiYgdG9rZW4udmFsdWUgPT09ICdnZXQnICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XHJcblx0ICAgICAgICAgICAga2luZCA9ICdnZXQnO1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlR2V0dGVyTWV0aG9kKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgIWlzQXN5bmMgJiYgdG9rZW4udmFsdWUgPT09ICdzZXQnICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XHJcblx0ICAgICAgICAgICAga2luZCA9ICdzZXQnO1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZVNldHRlck1ldGhvZCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIHRva2VuLnZhbHVlID09PSAnKicgJiYgbG9va2FoZWFkUHJvcGVydHlLZXkpIHtcclxuXHQgICAgICAgICAgICBraW5kID0gJ2luaXQnO1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZUdlbmVyYXRvck1ldGhvZCgpO1xyXG5cdCAgICAgICAgICAgIG1ldGhvZCA9IHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBpZiAoIWtleSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAga2luZCA9ICdpbml0JztcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnOicpICYmICFpc0FzeW5jKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghY29tcHV0ZWQgJiYgdGhpcy5pc1Byb3BlcnR5S2V5KGtleSwgJ19fcHJvdG9fXycpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaGFzUHJvdG8udmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5EdXBsaWNhdGVQcm90b1Byb3BlcnR5KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGhhc1Byb3RvLnZhbHVlID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcoJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBpc0FzeW5jID8gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kQXN5bmNGdW5jdGlvbigpIDogdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgbWV0aG9kID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBpZCA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0b2tlbi52YWx1ZSkpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2hvcnRoYW5kID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbml0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXNzaWdubWVudFBhdHRlcm4oaWQsIGluaXQpKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHNob3J0aGFuZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGlkO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlByb3BlcnR5KGtpbmQsIGtleSwgY29tcHV0ZWQsIHZhbHVlLCBtZXRob2QsIHNob3J0aGFuZCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlT2JqZWN0SW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gW107XHJcblx0ICAgICAgICB2YXIgaGFzUHJvdG8gPSB7IHZhbHVlOiBmYWxzZSB9O1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2godGhpcy5wYXJzZU9iamVjdFByb3BlcnR5KGhhc1Byb3RvKSk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDb21tYVNlcGFyYXRvcigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5PYmplY3RFeHByZXNzaW9uKHByb3BlcnRpZXMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbHNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRlbXBsYXRlSGVhZCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydCh0aGlzLmxvb2thaGVhZC5oZWFkLCAnVGVtcGxhdGUgbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSB0ZW1wbGF0ZSBoZWFkJyk7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHZhciByYXcgPSB0b2tlbi52YWx1ZTtcclxuXHQgICAgICAgIHZhciBjb29rZWQgPSB0b2tlbi5jb29rZWQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UZW1wbGF0ZUVsZW1lbnQoeyByYXc6IHJhdywgY29va2VkOiBjb29rZWQgfSwgdG9rZW4udGFpbCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGVtcGxhdGVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDEwIC8qIFRlbXBsYXRlICovKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB2YXIgcmF3ID0gdG9rZW4udmFsdWU7XHJcblx0ICAgICAgICB2YXIgY29va2VkID0gdG9rZW4uY29va2VkO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGVtcGxhdGVFbGVtZW50KHsgcmF3OiByYXcsIGNvb2tlZDogY29va2VkIH0sIHRva2VuLnRhaWwpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRlbXBsYXRlTGl0ZXJhbCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcclxuXHQgICAgICAgIHZhciBxdWFzaXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBxdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZUhlYWQoKTtcclxuXHQgICAgICAgIHF1YXNpcy5wdXNoKHF1YXNpKTtcclxuXHQgICAgICAgIHdoaWxlICghcXVhc2kudGFpbCkge1xyXG5cdCAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSk7XHJcblx0ICAgICAgICAgICAgcXVhc2kgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgcXVhc2lzLnB1c2gocXVhc2kpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGVtcGxhdGVMaXRlcmFsKHF1YXNpcywgZXhwcmVzc2lvbnMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ3JvdXBpbmctb3BlcmF0b3JcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4gPSBmdW5jdGlvbiAoZXhwcikge1xyXG5cdCAgICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyOlxyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4Lk1lbWJlckV4cHJlc3Npb246XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguUmVzdEVsZW1lbnQ6XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudFBhdHRlcm46XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LlNwcmVhZEVsZW1lbnQ6XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIudHlwZSA9IHN5bnRheF8xLlN5bnRheC5SZXN0RWxlbWVudDtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5hcmd1bWVudCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LkFycmF5RXhwcmVzc2lvbjpcclxuXHQgICAgICAgICAgICAgICAgZXhwci50eXBlID0gc3ludGF4XzEuU3ludGF4LkFycmF5UGF0dGVybjtcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZXhwci5lbGVtZW50c1tpXSAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIuZWxlbWVudHNbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4Lk9iamVjdEV4cHJlc3Npb246XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIudHlwZSA9IHN5bnRheF8xLlN5bnRheC5PYmplY3RQYXR0ZXJuO1xyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHIucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5wcm9wZXJ0aWVzW2ldLnZhbHVlKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjpcclxuXHQgICAgICAgICAgICAgICAgZXhwci50eXBlID0gc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuO1xyXG5cdCAgICAgICAgICAgICAgICBkZWxldGUgZXhwci5vcGVyYXRvcjtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5sZWZ0KTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgLy8gQWxsb3cgb3RoZXIgbm9kZSB0eXBlIGZvciB0b2xlcmFudCBwYXJzaW5nLlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUdyb3VwRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnPT4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnPT4nKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgcGFyYW1zOiBbXSxcclxuXHQgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcuLi4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZVJlc3RFbGVtZW50KHBhcmFtcyk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnPT4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0+Jyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtleHByXSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGFycm93ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHJlc3Npb25zW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdyA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBleHByZXNzaW9ucyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcuLi4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VSZXN0RWxlbWVudChwYXJhbXMpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCc9PicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnPT4nKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByZXNzaW9uc1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3cgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogZXhwcmVzc2lvbnMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyb3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnJvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5TZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoIWFycm93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0+JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllciAmJiBleHByLm5hbWUgPT09ICd5aWVsZCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3cgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogW2V4cHJdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJyb3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LlNlcXVlbmNlRXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByLmV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5leHByZXNzaW9uc1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVycyA9IChleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb24gPyBleHByLmV4cHJlc3Npb25zIDogW2V4cHJdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtZXRlcnMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxlZnQtaGFuZC1zaWRlLWV4cHJlc3Npb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBcmd1bWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLm1hdGNoKCcuLi4nKSA/IHRoaXMucGFyc2VTcHJlYWRFbGVtZW50KCkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgIGFyZ3MucHVzaChleHByKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDb21tYVNlcGFyYXRvcigpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICByZXR1cm4gYXJncztcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5pc0lkZW50aWZpZXJOYW1lID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICByZXR1cm4gdG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovIHx8XHJcblx0ICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gNCAvKiBLZXl3b3JkICovIHx8XHJcblx0ICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gMSAvKiBCb29sZWFuTGl0ZXJhbCAqLyB8fFxyXG5cdCAgICAgICAgICAgIHRva2VuLnR5cGUgPT09IDUgLyogTnVsbExpdGVyYWwgKi87XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJZGVudGlmaWVyTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLmlzSWRlbnRpZmllck5hbWUodG9rZW4pKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKHRva2VuLnZhbHVlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VOZXdFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KGlkLm5hbWUgPT09ICduZXcnLCAnTmV3IGV4cHJlc3Npb24gbXVzdCBzdGFydCB3aXRoIGBuZXdgJyk7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcuJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5ICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSAndGFyZ2V0Jykge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IG5ldyBOb2RlLk1ldGFQcm9wZXJ0eShpZCwgcHJvcGVydHkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNhbGxlZSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLm1hdGNoKCcoJykgPyB0aGlzLnBhcnNlQXJndW1lbnRzKCkgOiBbXTtcclxuXHQgICAgICAgICAgICBleHByID0gbmV3IE5vZGUuTmV3RXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgZXhwcik7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBc3luY0FyZ3VtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGFyZyA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XHJcblx0ICAgICAgICByZXR1cm4gYXJnO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXN5bmNBcmd1bWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLm1hdGNoKCcuLi4nKSA/IHRoaXMucGFyc2VTcHJlYWRFbGVtZW50KCkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3luY0FyZ3VtZW50KTtcclxuXHQgICAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHIpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENvbW1hU2VwYXJhdG9yKCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgIHJldHVybiBhcmdzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgbWF5YmVBc3luYyA9IHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXN5bmMnKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93SW4gPSB0aGlzLmNvbnRleHQuYWxsb3dJbjtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdzdXBlcicpICYmIHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSkge1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKGV4cHIsIG5ldyBOb2RlLlN1cGVyKCkpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKCcpICYmICF0aGlzLm1hdGNoKCcuJykgJiYgIXRoaXMubWF0Y2goJ1snKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMubWF0Y2hLZXl3b3JkKCduZXcnKSA/IHRoaXMucGFyc2VOZXdFeHByZXNzaW9uIDogdGhpcy5wYXJzZVByaW1hcnlFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJy4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJy4nKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5TdGF0aWNNZW1iZXJFeHByZXNzaW9uKGV4cHIsIHByb3BlcnR5KSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJygnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgYXN5bmNBcnJvdyA9IG1heWJlQXN5bmMgJiYgKHN0YXJ0VG9rZW4ubGluZU51bWJlciA9PT0gdGhpcy5sb29rYWhlYWQubGluZU51bWJlcik7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhc3luY0Fycm93ID8gdGhpcy5wYXJzZUFzeW5jQXJndW1lbnRzKCkgOiB0aGlzLnBhcnNlQXJndW1lbnRzKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5DYWxsRXhwcmVzc2lvbihleHByLCBhcmdzKSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChhc3luY0Fycm93ICYmIHRoaXMubWF0Y2goJz0+JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGFyZ3NbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogYXJncyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCdbJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCdbJyk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCddJyk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5Db21wdXRlZE1lbWJlckV4cHJlc3Npb24oZXhwciwgcHJvcGVydHkpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMTAgLyogVGVtcGxhdGUgKi8gJiYgdGhpcy5sb29rYWhlYWQuaGVhZCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcXVhc2kgPSB0aGlzLnBhcnNlVGVtcGxhdGVMaXRlcmFsKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oZXhwciwgcXVhc2kpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTdXBlciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3N1cGVyJyk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ1snKSAmJiAhdGhpcy5tYXRjaCgnLicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5TdXBlcigpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQodGhpcy5jb250ZXh0LmFsbG93SW4sICdjYWxsZWUgb2YgbmV3IGV4cHJlc3Npb24gYWx3YXlzIGFsbG93IGluIGtleXdvcmQuJyk7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIHZhciBleHByID0gKHRoaXMubWF0Y2hLZXl3b3JkKCdzdXBlcicpICYmIHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSkgPyB0aGlzLnBhcnNlU3VwZXIoKSA6XHJcblx0ICAgICAgICAgICAgdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMubWF0Y2hLZXl3b3JkKCduZXcnKSA/IHRoaXMucGFyc2VOZXdFeHByZXNzaW9uIDogdGhpcy5wYXJzZVByaW1hcnlFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ1snKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJ1snKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJ10nKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uKGV4cHIsIHByb3BlcnR5KSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJy4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJy4nKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlN0YXRpY01lbWJlckV4cHJlc3Npb24oZXhwciwgcHJvcGVydHkpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMTAgLyogVGVtcGxhdGUgKi8gJiYgdGhpcy5sb29rYWhlYWQuaGVhZCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcXVhc2kgPSB0aGlzLnBhcnNlVGVtcGxhdGVMaXRlcmFsKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihleHByLCBxdWFzaSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXVwZGF0ZS1leHByZXNzaW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVXBkYXRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcrKycpIHx8IHRoaXMubWF0Y2goJy0tJykpIHtcclxuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pO1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlVW5hcnlFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyICYmIHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKGV4cHIubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0TEhTUHJlZml4KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB2YXIgcHJlZml4ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5VcGRhdGVFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByLCBwcmVmaXgpKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5oYXNMaW5lVGVybWluYXRvciAmJiB0aGlzLmxvb2thaGVhZC50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJysrJykgfHwgdGhpcy5tYXRjaCgnLS0nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllciAmJiB0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChleHByLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0TEhTUG9zdGZpeCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm5leHRUb2tlbigpLnZhbHVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLlVwZGF0ZUV4cHJlc3Npb24ob3BlcmF0b3IsIGV4cHIsIHByZWZpeCkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXVuYXJ5LW9wZXJhdG9yc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXdhaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB2YXIgYXJndW1lbnQgPSB0aGlzLnBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Bd2FpdEV4cHJlc3Npb24oYXJndW1lbnQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVuYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJysnKSB8fCB0aGlzLm1hdGNoKCctJykgfHwgdGhpcy5tYXRjaCgnficpIHx8IHRoaXMubWF0Y2goJyEnKSB8fFxyXG5cdCAgICAgICAgICAgIHRoaXMubWF0Y2hLZXl3b3JkKCdkZWxldGUnKSB8fCB0aGlzLm1hdGNoS2V5d29yZCgndm9pZCcpIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCd0eXBlb2YnKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUodGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlVW5hcnlFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5VbmFyeUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBleHByLm9wZXJhdG9yID09PSAnZGVsZXRlJyAmJiBleHByLmFyZ3VtZW50LnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdERlbGV0ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZXh0LmF3YWl0ICYmIHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXdhaXQnKSkge1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlQXdhaXRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZVVwZGF0ZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRXhwb25lbnRpYXRpb25FeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VVbmFyeUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgaWYgKGV4cHIudHlwZSAhPT0gc3ludGF4XzEuU3ludGF4LlVuYXJ5RXhwcmVzc2lvbiAmJiB0aGlzLm1hdGNoKCcqKicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB2YXIgbGVmdCA9IGV4cHI7XHJcblx0ICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHBvbmVudGlhdGlvbkV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5CaW5hcnlFeHByZXNzaW9uKCcqKicsIGxlZnQsIHJpZ2h0KSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZXhwLW9wZXJhdG9yXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW11bHRpcGxpY2F0aXZlLW9wZXJhdG9yc1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hZGRpdGl2ZS1vcGVyYXRvcnNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYml0d2lzZS1zaGlmdC1vcGVyYXRvcnNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVsYXRpb25hbC1vcGVyYXRvcnNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZXF1YWxpdHktb3BlcmF0b3JzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWJpbmFyeS1iaXR3aXNlLW9wZXJhdG9yc1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1iaW5hcnktbG9naWNhbC1vcGVyYXRvcnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5iaW5hcnlQcmVjZWRlbmNlID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICB2YXIgb3AgPSB0b2tlbi52YWx1ZTtcclxuXHQgICAgICAgIHZhciBwcmVjZWRlbmNlO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLykge1xyXG5cdCAgICAgICAgICAgIHByZWNlZGVuY2UgPSB0aGlzLm9wZXJhdG9yUHJlY2VkZW5jZVtvcF0gfHwgMDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLykge1xyXG5cdCAgICAgICAgICAgIHByZWNlZGVuY2UgPSAob3AgPT09ICdpbnN0YW5jZW9mJyB8fCAodGhpcy5jb250ZXh0LmFsbG93SW4gJiYgb3AgPT09ICdpbicpKSA/IDcgOiAwO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgcHJlY2VkZW5jZSA9IDA7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gcHJlY2VkZW5jZTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJpbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUV4cG9uZW50aWF0aW9uRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBwcmVjID0gdGhpcy5iaW5hcnlQcmVjZWRlbmNlKHRva2VuKTtcclxuXHQgICAgICAgIGlmIChwcmVjID4gMCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdmFyIG1hcmtlcnMgPSBbc3RhcnRUb2tlbiwgdGhpcy5sb29rYWhlYWRdO1xyXG5cdCAgICAgICAgICAgIHZhciBsZWZ0ID0gZXhwcjtcclxuXHQgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUV4cG9uZW50aWF0aW9uRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YWNrID0gW2xlZnQsIHRva2VuLnZhbHVlLCByaWdodF07XHJcblx0ICAgICAgICAgICAgdmFyIHByZWNlZGVuY2VzID0gW3ByZWNdO1xyXG5cdCAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHByZWMgPSB0aGlzLmJpbmFyeVByZWNlZGVuY2UodGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAocHJlYyA8PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAvLyBSZWR1Y2U6IG1ha2UgYSBiaW5hcnkgZXhwcmVzc2lvbiBmcm9tIHRoZSB0aHJlZSB0b3Btb3N0IGVudHJpZXMuXHJcblx0ICAgICAgICAgICAgICAgIHdoaWxlICgoc3RhY2subGVuZ3RoID4gMikgJiYgKHByZWMgPD0gcHJlY2VkZW5jZXNbcHJlY2VkZW5jZXMubGVuZ3RoIC0gMV0pKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gc3RhY2sucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlcy5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzdGFjay5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIG1hcmtlcnMucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKG1hcmtlcnNbbWFya2Vycy5sZW5ndGggLSAxXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpKSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgLy8gU2hpZnQuXHJcblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5uZXh0VG9rZW4oKS52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgICAgIHByZWNlZGVuY2VzLnB1c2gocHJlYyk7XHJcblx0ICAgICAgICAgICAgICAgIG1hcmtlcnMucHVzaCh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHBvbmVudGlhdGlvbkV4cHJlc3Npb24pKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgLy8gRmluYWwgcmVkdWNlIHRvIGNsZWFuLXVwIHRoZSBzdGFjay5cclxuXHQgICAgICAgICAgICB2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHN0YWNrW2ldO1xyXG5cdCAgICAgICAgICAgIG1hcmtlcnMucG9wKCk7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKGkgPiAxKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUobWFya2Vycy5wb3AoKSk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHN0YWNrW2kgLSAxXTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgc3RhY2tbaSAtIDJdLCBleHByKSk7XHJcblx0ICAgICAgICAgICAgICAgIGkgLT0gMjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY29uZGl0aW9uYWwtb3BlcmF0b3JcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQmluYXJ5RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnPycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIHZhciBjb25zZXF1ZW50ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJzonKTtcclxuXHQgICAgICAgICAgICB2YXIgYWx0ZXJuYXRlID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLkNvbmRpdGlvbmFsRXhwcmVzc2lvbihleHByLCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hc3NpZ25tZW50LW9wZXJhdG9yc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmNoZWNrUGF0dGVyblBhcmFtID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmFtKSB7XHJcblx0ICAgICAgICBzd2l0Y2ggKHBhcmFtLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyOlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGFyYW0ob3B0aW9ucywgcGFyYW0sIHBhcmFtLm5hbWUpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5SZXN0RWxlbWVudDpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbS5hcmd1bWVudCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuOlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLmxlZnQpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5BcnJheVBhdHRlcm46XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW0uZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbS5lbGVtZW50c1tpXSAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0uZWxlbWVudHNbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4Lk9iamVjdFBhdHRlcm46XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW0ucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbS5wcm9wZXJ0aWVzW2ldLnZhbHVlKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIG9wdGlvbnMuc2ltcGxlID0gb3B0aW9ucy5zaW1wbGUgJiYgKHBhcmFtIGluc3RhbmNlb2YgTm9kZS5JZGVudGlmaWVyKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5yZWludGVycHJldEFzQ292ZXJGb3JtYWxzTGlzdCA9IGZ1bmN0aW9uIChleHByKSB7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gW2V4cHJdO1xyXG5cdCAgICAgICAgdmFyIG9wdGlvbnM7XHJcblx0ICAgICAgICB2YXIgYXN5bmNBcnJvdyA9IGZhbHNlO1xyXG5cdCAgICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyOlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXI6XHJcblx0ICAgICAgICAgICAgICAgIHBhcmFtcyA9IGV4cHIucGFyYW1zO1xyXG5cdCAgICAgICAgICAgICAgICBhc3luY0Fycm93ID0gZXhwci5hc3luYztcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBvcHRpb25zID0ge1xyXG5cdCAgICAgICAgICAgIHNpbXBsZTogdHJ1ZSxcclxuXHQgICAgICAgICAgICBwYXJhbVNldDoge31cclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1tpXTtcclxuXHQgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChwYXJhbS5yaWdodC50eXBlID09PSBzeW50YXhfMS5TeW50YXguWWllbGRFeHByZXNzaW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW0ucmlnaHQuYXJndW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHBhcmFtLnJpZ2h0LnR5cGUgPSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHBhcmFtLnJpZ2h0Lm5hbWUgPSAneWllbGQnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtLnJpZ2h0LmFyZ3VtZW50O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtLnJpZ2h0LmRlbGVnYXRlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGFzeW5jQXJyb3cgJiYgcGFyYW0udHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIgJiYgcGFyYW0ubmFtZSA9PT0gJ2F3YWl0Jykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbSk7XHJcblx0ICAgICAgICAgICAgcGFyYW1zW2ldID0gcGFyYW07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCB8fCAhdGhpcy5jb250ZXh0LmFsbG93WWllbGQpIHtcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSBwYXJhbXNbaV07XHJcblx0ICAgICAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBzeW50YXhfMS5TeW50YXguWWllbGRFeHByZXNzaW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChvcHRpb25zLm1lc3NhZ2UgPT09IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5jb250ZXh0LnN0cmljdCA/IG9wdGlvbnMuc3RyaWN0ZWQgOiBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZDtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBvcHRpb25zLm1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBzaW1wbGU6IG9wdGlvbnMuc2ltcGxlLFxyXG5cdCAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxyXG5cdCAgICAgICAgICAgIHN0cmljdGVkOiBvcHRpb25zLnN0cmljdGVkLFxyXG5cdCAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZDogb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQsXHJcblx0ICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucy5tZXNzYWdlXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmFsbG93WWllbGQgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ3lpZWxkJykpIHtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZVlpZWxkRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSBzdGFydFRva2VuO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiAodG9rZW4ubGluZU51bWJlciA9PT0gdGhpcy5sb29rYWhlYWQubGluZU51bWJlcikgJiYgdG9rZW4udmFsdWUgPT09ICdhc3luYycpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyB8fCB0aGlzLm1hdGNoS2V5d29yZCgneWllbGQnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IHRoaXMucGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oYXJnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFthcmddLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChleHByLnR5cGUgPT09IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIgfHwgdGhpcy5tYXRjaCgnPT4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJvdy1mdW5jdGlvbi1kZWZpbml0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBpc0FzeW5jID0gZXhwci5hc3luYztcclxuXHQgICAgICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnJlaW50ZXJwcmV0QXNDb3ZlckZvcm1hbHNMaXN0KGV4cHIpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAobGlzdCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0ID0gdGhpcy5jb250ZXh0LnN0cmljdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlID0gdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gbGlzdC5zaW1wbGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBd2FpdCA9IHRoaXMuY29udGV4dC5hd2FpdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IGlzQXN5bmM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0+Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYm9keSA9IHZvaWQgMDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCd7JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBib2R5LnR5cGUgIT09IHN5bnRheF8xLlN5bnRheC5CbG9ja1N0YXRlbWVudDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGxpc3QuZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihsaXN0LmZpcnN0UmVzdHJpY3RlZCwgbGlzdC5tZXNzYWdlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGxpc3Quc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGxpc3Quc3RyaWN0ZWQsIGxpc3QubWVzc2FnZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0gaXNBc3luYyA/IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXN5bmNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihsaXN0LnBhcmFtcywgYm9keSwgZXhwcmVzc2lvbikpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFycm93RnVuY3Rpb25FeHByZXNzaW9uKGxpc3QucGFyYW1zLCBib2R5LCBleHByZXNzaW9uKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBwcmV2aW91c0F3YWl0O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEFzc2lnbigpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBleHByO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdExIU0Fzc2lnbm1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZC5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdG9rZW4udmFsdWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5Bc3NpZ25tZW50RXhwcmVzc2lvbihvcGVyYXRvciwgZXhwciwgcmlnaHQpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNvbW1hLW9wZXJhdG9yXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XHJcblx0ICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChleHByKTtcclxuXHQgICAgICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuU2VxdWVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb25zKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYmxvY2tcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0YXRlbWVudExpc3RJdGVtID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSB0cnVlO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLykge1xyXG5cdCAgICAgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnZXhwb3J0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzTW9kdWxlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCwgbWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsRXhwb3J0RGVjbGFyYXRpb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUV4cG9ydERlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnaW1wb3J0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzTW9kdWxlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCwgbWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsSW1wb3J0RGVjbGFyYXRpb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUltcG9ydERlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnY29uc3QnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUxleGljYWxEZWNsYXJhdGlvbih7IGluRm9yOiBmYWxzZSB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VDbGFzc0RlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnbGV0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMuaXNMZXhpY2FsRGVjbGFyYXRpb24oKSA/IHRoaXMucGFyc2VMZXhpY2FsRGVjbGFyYXRpb24oeyBpbkZvcjogZmFsc2UgfSkgOiB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBzdGF0ZW1lbnQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VCbG9jayA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgdmFyIGJsb2NrID0gW107XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGJsb2NrLnB1c2godGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkJsb2NrU3RhdGVtZW50KGJsb2NrKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxldC1hbmQtY29uc3QtZGVjbGFyYXRpb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VMZXhpY2FsQmluZGluZyA9IGZ1bmN0aW9uIChraW5kLCBvcHRpb25zKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZVBhdHRlcm4ocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGlkLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKGlkLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFZhck5hbWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgIGlmIChraW5kID09PSAnY29uc3QnKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoS2V5d29yZCgnaW4nKSAmJiAhdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdvZicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5EZWNsYXJhdGlvbk1pc3NpbmdJbml0aWFsaXplciwgJ2NvbnN0Jyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICgoIW9wdGlvbnMuaW5Gb3IgJiYgaWQudHlwZSAhPT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpIHx8IHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc9Jyk7XHJcblx0ICAgICAgICAgICAgaW5pdCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VCaW5kaW5nTGlzdCA9IGZ1bmN0aW9uIChraW5kLCBvcHRpb25zKSB7XHJcblx0ICAgICAgICB2YXIgbGlzdCA9IFt0aGlzLnBhcnNlTGV4aWNhbEJpbmRpbmcoa2luZCwgb3B0aW9ucyldO1xyXG5cdCAgICAgICAgd2hpbGUgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgbGlzdC5wdXNoKHRoaXMucGFyc2VMZXhpY2FsQmluZGluZyhraW5kLCBvcHRpb25zKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gbGlzdDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5pc0xleGljYWxEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc2Nhbm5lci5zYXZlU3RhdGUoKTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcclxuXHQgICAgICAgIHZhciBuZXh0ID0gdGhpcy5zY2FubmVyLmxleCgpO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLnJlc3RvcmVTdGF0ZShzdGF0ZSk7XHJcblx0ICAgICAgICByZXR1cm4gKG5leHQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB8fFxyXG5cdCAgICAgICAgICAgIChuZXh0LnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiBuZXh0LnZhbHVlID09PSAnWycpIHx8XHJcblx0ICAgICAgICAgICAgKG5leHQudHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIG5leHQudmFsdWUgPT09ICd7JykgfHxcclxuXHQgICAgICAgICAgICAobmV4dC50eXBlID09PSA0IC8qIEtleXdvcmQgKi8gJiYgbmV4dC52YWx1ZSA9PT0gJ2xldCcpIHx8XHJcblx0ICAgICAgICAgICAgKG5leHQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovICYmIG5leHQudmFsdWUgPT09ICd5aWVsZCcpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTGV4aWNhbERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIga2luZCA9IHRoaXMubmV4dFRva2VuKCkudmFsdWU7XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQoa2luZCA9PT0gJ2xldCcgfHwga2luZCA9PT0gJ2NvbnN0JywgJ0xleGljYWwgZGVjbGFyYXRpb24gbXVzdCBiZSBlaXRoZXIgbGV0IG9yIGNvbnN0Jyk7XHJcblx0ICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KGtpbmQsIG9wdGlvbnMpO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1kZXN0cnVjdHVyaW5nLWJpbmRpbmctcGF0dGVybnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJpbmRpbmdSZXN0RWxlbWVudCA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnLi4uJyk7XHJcblx0ICAgICAgICB2YXIgYXJnID0gdGhpcy5wYXJzZVBhdHRlcm4ocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlJlc3RFbGVtZW50KGFyZykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXJyYXlQYXR0ZXJuID0gZnVuY3Rpb24gKHBhcmFtcywga2luZCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCdbJyk7XHJcblx0ICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnXScpKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG51bGwpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJy4uLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHRoaXMucGFyc2VCaW5kaW5nUmVzdEVsZW1lbnQocGFyYW1zLCBraW5kKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2godGhpcy5wYXJzZVBhdHRlcm5XaXRoRGVmYXVsdChwYXJhbXMsIGtpbmQpKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ10nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCddJyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5BcnJheVBhdHRlcm4oZWxlbWVudHMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByb3BlcnR5UGF0dGVybiA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgY29tcHV0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBzaG9ydGhhbmQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBtZXRob2QgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBrZXk7XHJcblx0ICAgICAgICB2YXIgdmFsdWU7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGtleVRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIHZhciBpbml0ID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKGtleVRva2VuLnZhbHVlKSk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChrZXlUb2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIHNob3J0aGFuZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShrZXlUb2tlbiksIG5ldyBOb2RlLkFzc2lnbm1lbnRQYXR0ZXJuKGluaXQsIGV4cHIpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMubWF0Y2goJzonKSkge1xyXG5cdCAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChrZXlUb2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIHNob3J0aGFuZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gaW5pdDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc6Jyk7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZVBhdHRlcm5XaXRoRGVmYXVsdChwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc6Jyk7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlUGF0dGVybldpdGhEZWZhdWx0KHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Qcm9wZXJ0eSgnaW5pdCcsIGtleSwgY29tcHV0ZWQsIHZhbHVlLCBtZXRob2QsIHNob3J0aGFuZCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlT2JqZWN0UGF0dGVybiA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcHJvcGVydGllcyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHRoaXMucGFyc2VQcm9wZXJ0eVBhdHRlcm4ocGFyYW1zLCBraW5kKSk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuT2JqZWN0UGF0dGVybihwcm9wZXJ0aWVzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQYXR0ZXJuID0gZnVuY3Rpb24gKHBhcmFtcywga2luZCkge1xyXG5cdCAgICAgICAgdmFyIHBhdHRlcm47XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnWycpKSB7XHJcblx0ICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMucGFyc2VBcnJheVBhdHRlcm4ocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJ3snKSkge1xyXG5cdCAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLnBhcnNlT2JqZWN0UGF0dGVybihwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdsZXQnKSAmJiAoa2luZCA9PT0gJ2NvbnN0JyB8fCBraW5kID09PSAnbGV0JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCwgbWVzc2FnZXNfMS5NZXNzYWdlcy5MZXRJbkxleGljYWxCaW5kaW5nKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgcGFyYW1zLnB1c2godGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKGtpbmQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHBhdHRlcm47XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQgPSBmdW5jdGlvbiAocGFyYW1zLCBraW5kKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIHBhdHRlcm4gPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQXNzaWdubWVudFBhdHRlcm4ocGF0dGVybiwgcmlnaHQpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBwYXR0ZXJuO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy12YXJpYWJsZS1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZhcmlhYmxlSWRlbnRpZmllciA9IGZ1bmN0aW9uIChraW5kKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8gJiYgdG9rZW4udmFsdWUgPT09ICd5aWVsZCcpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlICE9PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiB0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8gJiYgdGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgfHwgdG9rZW4udmFsdWUgIT09ICdsZXQnIHx8IGtpbmQgIT09ICd2YXInKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKCh0aGlzLmNvbnRleHQuaXNNb2R1bGUgfHwgdGhpcy5jb250ZXh0LmF3YWl0KSAmJiB0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgdG9rZW4udmFsdWUgPT09ICdhd2FpdCcpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIodG9rZW4udmFsdWUpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VQYXR0ZXJuKHBhcmFtcywgJ3ZhcicpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgaWQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQoaWQubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0VmFyTmFtZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgaW5pdCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoaWQudHlwZSAhPT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIgJiYgIW9wdGlvbnMuaW5Gb3IpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnPScpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0ICAgICAgICB2YXIgb3B0ID0geyBpbkZvcjogb3B0aW9ucy5pbkZvciB9O1xyXG5cdCAgICAgICAgdmFyIGxpc3QgPSBbXTtcclxuXHQgICAgICAgIGxpc3QucHVzaCh0aGlzLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbihvcHQpKTtcclxuXHQgICAgICAgIHdoaWxlICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGxpc3QucHVzaCh0aGlzLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbihvcHQpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBsaXN0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVmFyaWFibGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd2YXInKTtcclxuXHQgICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSB0aGlzLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoeyBpbkZvcjogZmFsc2UgfSk7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCAndmFyJykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lbXB0eS1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUVtcHR5U3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCc7Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FbXB0eVN0YXRlbWVudCgpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZXhwcmVzc2lvbi1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaWYtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJZkNsYXVzZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMubWF0Y2hLZXl3b3JkKCdmdW5jdGlvbicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUlmU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBjb25zZXF1ZW50O1xyXG5cdCAgICAgICAgdmFyIGFsdGVybmF0ZSA9IG51bGw7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2lmJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIHRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykgJiYgdGhpcy5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIGNvbnNlcXVlbnQgPSB0aGlzLmZpbmFsaXplKHRoaXMuY3JlYXRlTm9kZSgpLCBuZXcgTm9kZS5FbXB0eVN0YXRlbWVudCgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgY29uc2VxdWVudCA9IHRoaXMucGFyc2VJZkNsYXVzZSgpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZWxzZScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGFsdGVybmF0ZSA9IHRoaXMucGFyc2VJZkNsYXVzZSgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklmU3RhdGVtZW50KHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1kby13aGlsZS1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZURvV2hpbGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdkbycpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSW5JdGVyYXRpb24gPSB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSBwcmV2aW91c0luSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd3aGlsZScpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciB0ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpICYmIHRoaXMuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJzsnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkRvV2hpbGVTdGF0ZW1lbnQoYm9keSwgdGVzdCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy13aGlsZS1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVdoaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd3aGlsZScpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciB0ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpICYmIHRoaXMuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5maW5hbGl6ZSh0aGlzLmNyZWF0ZU5vZGUoKSwgbmV3IE5vZGUuRW1wdHlTdGF0ZW1lbnQoKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgIHZhciBwcmV2aW91c0luSXRlcmF0aW9uID0gdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHRydWU7XHJcblx0ICAgICAgICAgICAgYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSBwcmV2aW91c0luSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuV2hpbGVTdGF0ZW1lbnQodGVzdCwgYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mb3Itc3RhdGVtZW50XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWZvci1pbi1hbmQtZm9yLW9mLXN0YXRlbWVudHNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZvclN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgIHZhciB0ZXN0ID0gbnVsbDtcclxuXHQgICAgICAgIHZhciB1cGRhdGUgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGZvckluID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBsZWZ0LCByaWdodDtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2ZvcicpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCc7JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCd2YXInKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93SW4gPSB0aGlzLmNvbnRleHQuYWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCh7IGluRm9yOiB0cnVlIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ2luJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkZWNsID0gZGVjbGFyYXRpb25zWzBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRlY2wuaW5pdCAmJiAoZGVjbC5pZC50eXBlID09PSBzeW50YXhfMS5TeW50YXguQXJyYXlQYXR0ZXJuIHx8IGRlY2wuaWQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4Lk9iamVjdFBhdHRlcm4gfHwgdGhpcy5jb250ZXh0LnN0cmljdCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5Gb3JJbk9mTG9vcEluaXRpYWxpemVyLCAnZm9yLWluJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywgJ3ZhcicpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgZGVjbGFyYXRpb25zWzBdLmluaXQgPT09IG51bGwgJiYgdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdvZicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywgJ3ZhcicpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZvckluID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywgJ3ZhcicpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc7Jyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2NvbnN0JykgfHwgdGhpcy5tYXRjaEtleXdvcmQoJ2xldCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGtpbmQgPSB0aGlzLm5leHRUb2tlbigpLnZhbHVlO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5zdHJpY3QgJiYgdGhpcy5sb29rYWhlYWQudmFsdWUgPT09ICdpbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLklkZW50aWZpZXIoa2luZCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdChraW5kLCB7IGluRm9yOiB0cnVlIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiBkZWNsYXJhdGlvbnNbMF0uaW5pdCA9PT0gbnVsbCAmJiB0aGlzLm1hdGNoS2V5d29yZCgnaW4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIGRlY2xhcmF0aW9uc1swXS5pbml0ID09PSBudWxsICYmIHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnb2YnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvckluID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgaW5pdFN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dJbiA9IHRoaXMuY29udGV4dC5hbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2luJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCB8fCBpbml0LnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRMSFNJbkZvckluKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihpbml0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdvZicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgfHwgaW5pdC50eXBlID09PSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkTEhTSW5Gb3JMb29wKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihpbml0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9ySW4gPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdFNlcSA9IFtpbml0XTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRTZXEucHVzaCh0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKGluaXRTdGFydFRva2VuKSwgbmV3IE5vZGUuU2VxdWVuY2VFeHByZXNzaW9uKGluaXRTZXEpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc7Jyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCc7JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc7Jyk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdXBkYXRlID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgYm9keTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpICYmIHRoaXMuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5maW5hbGl6ZSh0aGlzLmNyZWF0ZU5vZGUoKSwgbmV3IE5vZGUuRW1wdHlTdGF0ZW1lbnQoKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgIHZhciBwcmV2aW91c0luSXRlcmF0aW9uID0gdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHRydWU7XHJcblx0ICAgICAgICAgICAgYm9keSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlU3RhdGVtZW50KTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSBwcmV2aW91c0luSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpID9cclxuXHQgICAgICAgICAgICB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZvclN0YXRlbWVudChpbml0LCB0ZXN0LCB1cGRhdGUsIGJvZHkpKSA6XHJcblx0ICAgICAgICAgICAgZm9ySW4gPyB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZvckluU3RhdGVtZW50KGxlZnQsIHJpZ2h0LCBib2R5KSkgOlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZvck9mU3RhdGVtZW50KGxlZnQsIHJpZ2h0LCBib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNvbnRpbnVlLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ29udGludWVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdjb250aW51ZScpO1xyXG5cdCAgICAgICAgdmFyIGxhYmVsID0gbnVsbDtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcclxuXHQgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgbGFiZWwgPSBpZDtcclxuXHQgICAgICAgICAgICB2YXIga2V5ID0gJyQnICsgaWQubmFtZTtcclxuXHQgICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNvbnRleHQubGFiZWxTZXQsIGtleSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5rbm93bkxhYmVsLCBpZC5uYW1lKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIGlmIChsYWJlbCA9PT0gbnVsbCAmJiAhdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNvbnRpbnVlU3RhdGVtZW50KGxhYmVsKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWJyZWFrLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQnJlYWtTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdicmVhaycpO1xyXG5cdCAgICAgICAgdmFyIGxhYmVsID0gbnVsbDtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcclxuXHQgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgdmFyIGtleSA9ICckJyArIGlkLm5hbWU7XHJcblx0ICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb250ZXh0LmxhYmVsU2V0LCBrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlVua25vd25MYWJlbCwgaWQubmFtZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGxhYmVsID0gaWQ7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIGlmIChsYWJlbCA9PT0gbnVsbCAmJiAhdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uICYmICF0aGlzLmNvbnRleHQuaW5Td2l0Y2gpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsQnJlYWspO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQnJlYWtTdGF0ZW1lbnQobGFiZWwpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmV0dXJuLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUmV0dXJuU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsUmV0dXJuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3JldHVybicpO1xyXG5cdCAgICAgICAgdmFyIGhhc0FyZ3VtZW50ID0gIXRoaXMubWF0Y2goJzsnKSAmJiAhdGhpcy5tYXRjaCgnfScpICYmXHJcblx0ICAgICAgICAgICAgIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IgJiYgdGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi87XHJcblx0ICAgICAgICB2YXIgYXJndW1lbnQgPSBoYXNBcmd1bWVudCA/IHRoaXMucGFyc2VFeHByZXNzaW9uKCkgOiBudWxsO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5SZXR1cm5TdGF0ZW1lbnQoYXJndW1lbnQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtd2l0aC1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVdpdGhTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdE1vZGVXaXRoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgYm9keTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnd2l0aCcpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciBvYmplY3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykgJiYgdGhpcy5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIGJvZHkgPSB0aGlzLmZpbmFsaXplKHRoaXMuY3JlYXRlTm9kZSgpLCBuZXcgTm9kZS5FbXB0eVN0YXRlbWVudCgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLldpdGhTdGF0ZW1lbnQob2JqZWN0LCBib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN3aXRjaC1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN3aXRjaENhc2UgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRlc3Q7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdGVzdCA9IG51bGw7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2Nhc2UnKTtcclxuXHQgICAgICAgICAgICB0ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCc6Jyk7XHJcblx0ICAgICAgICB2YXIgY29uc2VxdWVudCA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnfScpIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykgfHwgdGhpcy5tYXRjaEtleXdvcmQoJ2Nhc2UnKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgY29uc2VxdWVudC5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlN3aXRjaENhc2UodGVzdCwgY29uc2VxdWVudCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3dpdGNoU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnc3dpdGNoJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIGRpc2NyaW1pbmFudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSW5Td2l0Y2ggPSB0aGlzLmNvbnRleHQuaW5Td2l0Y2g7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5Td2l0Y2ggPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIGNhc2VzID0gW107XHJcblx0ICAgICAgICB2YXIgZGVmYXVsdEZvdW5kID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB2YXIgY2xhdXNlID0gdGhpcy5wYXJzZVN3aXRjaENhc2UoKTtcclxuXHQgICAgICAgICAgICBpZiAoY2xhdXNlLnRlc3QgPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRGb3VuZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0Rm91bmQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBjYXNlcy5wdXNoKGNsYXVzZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluU3dpdGNoID0gcHJldmlvdXNJblN3aXRjaDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlN3aXRjaFN0YXRlbWVudChkaXNjcmltaW5hbnQsIGNhc2VzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxhYmVsbGVkLXN0YXRlbWVudHNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxhYmVsbGVkU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHZhciBzdGF0ZW1lbnQ7XHJcblx0ICAgICAgICBpZiAoKGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpICYmIHRoaXMubWF0Y2goJzonKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0gZXhwcjtcclxuXHQgICAgICAgICAgICB2YXIga2V5ID0gJyQnICsgaWQubmFtZTtcclxuXHQgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29udGV4dC5sYWJlbFNldCwga2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5SZWRlY2xhcmF0aW9uLCAnTGFiZWwnLCBpZC5uYW1lKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmxhYmVsU2V0W2tleV0gPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIHZhciBib2R5ID0gdm9pZCAwO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnY2xhc3MnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMucGFyc2VDbGFzc0RlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdmdW5jdGlvbicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVjbGFyYXRpb24uZ2VuZXJhdG9yKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLkdlbmVyYXRvckluTGVnYWN5Q29udGV4dCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYm9keSA9IGRlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29udGV4dC5sYWJlbFNldFtrZXldO1xyXG5cdCAgICAgICAgICAgIHN0YXRlbWVudCA9IG5ldyBOb2RlLkxhYmVsZWRTdGF0ZW1lbnQoaWQsIGJvZHkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICAgICAgc3RhdGVtZW50ID0gbmV3IE5vZGUuRXhwcmVzc2lvblN0YXRlbWVudChleHByKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIHN0YXRlbWVudCk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRocm93LXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGhyb3dTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd0aHJvdycpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5OZXdsaW5lQWZ0ZXJUaHJvdyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UaHJvd1N0YXRlbWVudChhcmd1bWVudCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10cnktc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDYXRjaENsYXVzZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2NhdGNoJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtID0gdGhpcy5wYXJzZVBhdHRlcm4ocGFyYW1zKTtcclxuXHQgICAgICAgIHZhciBwYXJhbU1hcCA9IHt9O1xyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICB2YXIga2V5ID0gJyQnICsgcGFyYW1zW2ldLnZhbHVlO1xyXG5cdCAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1NYXAsIGtleSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuRHVwbGljYXRlQmluZGluZywgcGFyYW1zW2ldLnZhbHVlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgcGFyYW1NYXBba2V5XSA9IHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBwYXJhbS50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChwYXJhbS5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RDYXRjaFZhcmlhYmxlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlQmxvY2soKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNhdGNoQ2xhdXNlKHBhcmFtLCBib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGaW5hbGx5Q2xhdXNlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdmaW5hbGx5Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJsb2NrKCk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VUcnlTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd0cnknKTtcclxuXHQgICAgICAgIHZhciBibG9jayA9IHRoaXMucGFyc2VCbG9jaygpO1xyXG5cdCAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLm1hdGNoS2V5d29yZCgnY2F0Y2gnKSA/IHRoaXMucGFyc2VDYXRjaENsYXVzZSgpIDogbnVsbDtcclxuXHQgICAgICAgIHZhciBmaW5hbGl6ZXIgPSB0aGlzLm1hdGNoS2V5d29yZCgnZmluYWxseScpID8gdGhpcy5wYXJzZUZpbmFsbHlDbGF1c2UoKSA6IG51bGw7XHJcblx0ICAgICAgICBpZiAoIWhhbmRsZXIgJiYgIWZpbmFsaXplcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLk5vQ2F0Y2hPckZpbmFsbHkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVHJ5U3RhdGVtZW50KGJsb2NrLCBoYW5kbGVyLCBmaW5hbGl6ZXIpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGVidWdnZXItc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VEZWJ1Z2dlclN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2RlYnVnZ2VyJyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkRlYnVnZ2VyU3RhdGVtZW50KCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXN0YXRlbWVudHMtYW5kLWRlY2xhcmF0aW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXRlbWVudDtcclxuXHQgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgMSAvKiBCb29sZWFuTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDUgLyogTnVsbExpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA2IC8qIE51bWVyaWNMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgOCAvKiBTdHJpbmdMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgMTAgLyogVGVtcGxhdGUgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA5IC8qIFJlZ3VsYXJFeHByZXNzaW9uICovOlxyXG5cdCAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDcgLyogUHVuY3R1YXRvciAqLzpcclxuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5sb29rYWhlYWQudmFsdWU7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlQmxvY2soKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gJygnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSAnOycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VFbXB0eVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDMgLyogSWRlbnRpZmllciAqLzpcclxuXHQgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5tYXRjaEFzeW5jRnVuY3Rpb24oKSA/IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCkgOiB0aGlzLnBhcnNlTGFiZWxsZWRTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA0IC8qIEtleXdvcmQgKi86XHJcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JyZWFrJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlQnJlYWtTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbnRpbnVlJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlQ29udGludWVTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RlYnVnZ2VyJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RvJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRG9XaGlsZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9yJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRm9yU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2lmJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlSWZTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JldHVybic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVJldHVyblN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3dpdGNoJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlU3dpdGNoU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd0aHJvdyc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVRocm93U3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd0cnknOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VUcnlTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Zhcic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVZhcmlhYmxlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd3aGlsZSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVdoaWxlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd3aXRoJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlV2l0aFN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHN0YXRlbWVudDtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZnVuY3Rpb24tZGVmaW5pdGlvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZURpcmVjdGl2ZVByb2xvZ3VlcygpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzTGFiZWxTZXQgPSB0aGlzLmNvbnRleHQubGFiZWxTZXQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJbkl0ZXJhdGlvbiA9IHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0luU3dpdGNoID0gdGhpcy5jb250ZXh0LmluU3dpdGNoO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSW5GdW5jdGlvbkJvZHkgPSB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQubGFiZWxTZXQgPSB7fTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluU3dpdGNoID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkgPSB0cnVlO1xyXG5cdCAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgYm9keS5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQubGFiZWxTZXQgPSBwcmV2aW91c0xhYmVsU2V0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gcHJldmlvdXNJbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pblN3aXRjaCA9IHByZXZpb3VzSW5Td2l0Y2g7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkgPSBwcmV2aW91c0luRnVuY3Rpb25Cb2R5O1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQmxvY2tTdGF0ZW1lbnQoYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnZhbGlkYXRlUGFyYW0gPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyYW0sIG5hbWUpIHtcclxuXHQgICAgICAgIHZhciBrZXkgPSAnJCcgKyBuYW1lO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQobmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3RlZCA9IHBhcmFtO1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFBhcmFtTmFtZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLnBhcmFtU2V0LCBrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RyaWN0ZWQgPSBwYXJhbTtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoIW9wdGlvbnMuZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKG5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkID0gcGFyYW07XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UGFyYW1OYW1lO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKG5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkID0gcGFyYW07XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy5wYXJhbVNldCwga2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLnN0cmljdGVkID0gcGFyYW07XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRpb25zLnBhcmFtU2V0LCBrZXksIHsgdmFsdWU6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBvcHRpb25zLnBhcmFtU2V0W2tleV0gPSB0cnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUmVzdEVsZW1lbnQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJy4uLicpO1xyXG5cdCAgICAgICAgdmFyIGFyZyA9IHRoaXMucGFyc2VQYXR0ZXJuKHBhcmFtcyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuRGVmYXVsdFJlc3RQYXJhbWV0ZXIpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5QYXJhbWV0ZXJBZnRlclJlc3RQYXJhbWV0ZXIpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuUmVzdEVsZW1lbnQoYXJnKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGb3JtYWxQYXJhbWV0ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtID0gdGhpcy5tYXRjaCgnLi4uJykgPyB0aGlzLnBhcnNlUmVzdEVsZW1lbnQocGFyYW1zKSA6IHRoaXMucGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQocGFyYW1zKTtcclxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVBhcmFtKG9wdGlvbnMsIHBhcmFtc1tpXSwgcGFyYW1zW2ldLnZhbHVlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIG9wdGlvbnMuc2ltcGxlID0gb3B0aW9ucy5zaW1wbGUgJiYgKHBhcmFtIGluc3RhbmNlb2YgTm9kZS5JZGVudGlmaWVyKTtcclxuXHQgICAgICAgIG9wdGlvbnMucGFyYW1zLnB1c2gocGFyYW0pO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRm9ybWFsUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChmaXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgIHZhciBvcHRpb25zO1xyXG5cdCAgICAgICAgb3B0aW9ucyA9IHtcclxuXHQgICAgICAgICAgICBzaW1wbGU6IHRydWUsXHJcblx0ICAgICAgICAgICAgcGFyYW1zOiBbXSxcclxuXHQgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQ6IGZpcnN0UmVzdHJpY3RlZFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgIG9wdGlvbnMucGFyYW1TZXQgPSB7fTtcclxuXHQgICAgICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcihvcHRpb25zKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBzaW1wbGU6IG9wdGlvbnMuc2ltcGxlLFxyXG5cdCAgICAgICAgICAgIHBhcmFtczogb3B0aW9ucy5wYXJhbXMsXHJcblx0ICAgICAgICAgICAgc3RyaWN0ZWQ6IG9wdGlvbnMuc3RyaWN0ZWQsXHJcblx0ICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCxcclxuXHQgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2VcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubWF0Y2hBc3luY0Z1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG1hdGNoID0gdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhc3luYycpO1xyXG5cdCAgICAgICAgaWYgKG1hdGNoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zY2FubmVyLnNhdmVTdGF0ZSgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcclxuXHQgICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuc2Nhbm5lci5sZXgoKTtcclxuXHQgICAgICAgICAgICB0aGlzLnNjYW5uZXIucmVzdG9yZVN0YXRlKHN0YXRlKTtcclxuXHQgICAgICAgICAgICBtYXRjaCA9IChzdGF0ZS5saW5lTnVtYmVyID09PSBuZXh0LmxpbmVOdW1iZXIpICYmIChuZXh0LnR5cGUgPT09IDQgLyogS2V5d29yZCAqLykgJiYgKG5leHQudmFsdWUgPT09ICdmdW5jdGlvbicpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChpZGVudGlmaWVySXNPcHRpb25hbCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpc0FzeW5jID0gdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhc3luYycpO1xyXG5cdCAgICAgICAgaWYgKGlzQXN5bmMpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdmdW5jdGlvbicpO1xyXG5cdCAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gaXNBc3luYyA/IGZhbHNlIDogdGhpcy5tYXRjaCgnKicpO1xyXG5cdCAgICAgICAgaWYgKGlzR2VuZXJhdG9yKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBtZXNzYWdlO1xyXG5cdCAgICAgICAgdmFyIGlkID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBmaXJzdFJlc3RyaWN0ZWQgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKCFpZGVudGlmaWVySXNPcHRpb25hbCB8fCAhdGhpcy5tYXRjaCgnKCcpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgaWQgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XHJcblx0ICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0F3YWl0ID0gdGhpcy5jb250ZXh0LmF3YWl0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gaXNBc3luYztcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gIWlzR2VuZXJhdG9yO1xyXG5cdCAgICAgICAgdmFyIGZvcm1hbFBhcmFtZXRlcnMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycyhmaXJzdFJlc3RyaWN0ZWQpO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zO1xyXG5cdCAgICAgICAgdmFyIHN0cmljdGVkID0gZm9ybWFsUGFyYW1ldGVycy5zdHJpY3RlZDtcclxuXHQgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IGZvcm1hbFBhcmFtZXRlcnMuZmlyc3RSZXN0cmljdGVkO1xyXG5cdCAgICAgICAgaWYgKGZvcm1hbFBhcmFtZXRlcnMubWVzc2FnZSkge1xyXG5cdCAgICAgICAgICAgIG1lc3NhZ2UgPSBmb3JtYWxQYXJhbWV0ZXJzLm1lc3NhZ2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QgPSB0aGlzLmNvbnRleHQuc3RyaWN0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmUgPSB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBmb3JtYWxQYXJhbWV0ZXJzLnNpbXBsZTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihzdHJpY3RlZCwgbWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gcHJldmlvdXNBbGxvd0F3YWl0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICByZXR1cm4gaXNBc3luYyA/IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uKGlkLCBwYXJhbXMsIGJvZHkpKSA6XHJcblx0ICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5GdW5jdGlvbkRlY2xhcmF0aW9uKGlkLCBwYXJhbXMsIGJvZHksIGlzR2VuZXJhdG9yKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGdW5jdGlvbkV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGlzQXN5bmMgPSB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzeW5jJyk7XHJcblx0ICAgICAgICBpZiAoaXNBc3luYykge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2Z1bmN0aW9uJyk7XHJcblx0ICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSBpc0FzeW5jID8gZmFsc2UgOiB0aGlzLm1hdGNoKCcqJyk7XHJcblx0ICAgICAgICBpZiAoaXNHZW5lcmF0b3IpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG1lc3NhZ2U7XHJcblx0ICAgICAgICB2YXIgaWQgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGZpcnN0UmVzdHJpY3RlZDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93QXdhaXQgPSB0aGlzLmNvbnRleHQuYXdhaXQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBpc0FzeW5jO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSAhaXNHZW5lcmF0b3I7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJygnKSkge1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIGlkID0gKCF0aGlzLmNvbnRleHQuc3RyaWN0ICYmICFpc0dlbmVyYXRvciAmJiB0aGlzLm1hdGNoS2V5d29yZCgneWllbGQnKSkgPyB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKSA6IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBmb3JtYWxQYXJhbWV0ZXJzID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoZmlyc3RSZXN0cmljdGVkKTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtcztcclxuXHQgICAgICAgIHZhciBzdHJpY3RlZCA9IGZvcm1hbFBhcmFtZXRlcnMuc3RyaWN0ZWQ7XHJcblx0ICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSBmb3JtYWxQYXJhbWV0ZXJzLmZpcnN0UmVzdHJpY3RlZDtcclxuXHQgICAgICAgIGlmIChmb3JtYWxQYXJhbWV0ZXJzLm1lc3NhZ2UpIHtcclxuXHQgICAgICAgICAgICBtZXNzYWdlID0gZm9ybWFsUGFyYW1ldGVycy5tZXNzYWdlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0ID0gdGhpcy5jb250ZXh0LnN0cmljdDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlID0gdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gZm9ybWFsUGFyYW1ldGVycy5zaW1wbGU7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBmaXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oc3RyaWN0ZWQsIG1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IHByZXZpb3VzQWxsb3dBd2FpdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgcmV0dXJuIGlzQXN5bmMgPyB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFzeW5jRnVuY3Rpb25FeHByZXNzaW9uKGlkLCBwYXJhbXMsIGJvZHkpKSA6XHJcblx0ICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5GdW5jdGlvbkV4cHJlc3Npb24oaWQsIHBhcmFtcywgYm9keSwgaXNHZW5lcmF0b3IpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGlyZWN0aXZlLXByb2xvZ3Vlcy1hbmQtdGhlLXVzZS1zdHJpY3QtZGlyZWN0aXZlXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VEaXJlY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB2YXIgZGlyZWN0aXZlID0gKGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkxpdGVyYWwpID8gdGhpcy5nZXRUb2tlblJhdyh0b2tlbikuc2xpY2UoMSwgLTEpIDogbnVsbDtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgZGlyZWN0aXZlID8gbmV3IE5vZGUuRGlyZWN0aXZlKGV4cHIsIGRpcmVjdGl2ZSkgOiBuZXcgTm9kZS5FeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZURpcmVjdGl2ZVByb2xvZ3VlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBmaXJzdFJlc3RyaWN0ZWQgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IDggLyogU3RyaW5nTGl0ZXJhbCAqLykge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXRlbWVudCA9IHRoaXMucGFyc2VEaXJlY3RpdmUoKTtcclxuXHQgICAgICAgICAgICBib2R5LnB1c2goc3RhdGVtZW50KTtcclxuXHQgICAgICAgICAgICB2YXIgZGlyZWN0aXZlID0gc3RhdGVtZW50LmRpcmVjdGl2ZTtcclxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGRpcmVjdGl2ZSAhPT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChkaXJlY3RpdmUgPT09ICd1c2Ugc3RyaWN0Jykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsTGFuZ3VhZ2VNb2RlRGlyZWN0aXZlKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCFmaXJzdFJlc3RyaWN0ZWQgJiYgdG9rZW4ub2N0YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGJvZHk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW1ldGhvZC1kZWZpbml0aW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnF1YWxpZmllZFByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAzIC8qIElkZW50aWZpZXIgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA4IC8qIFN0cmluZ0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSAxIC8qIEJvb2xlYW5MaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNSAvKiBOdWxsTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDYgLyogTnVtZXJpY0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA0IC8qIEtleXdvcmQgKi86XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNyAvKiBQdW5jdHVhdG9yICovOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4udmFsdWUgPT09ICdbJztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUdldHRlck1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgZm9ybWFsUGFyYW1ldGVycyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKCk7XHJcblx0ICAgICAgICBpZiAoZm9ybWFsUGFyYW1ldGVycy5wYXJhbXMubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkJhZEdldHRlckFyaXR5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2QoZm9ybWFsUGFyYW1ldGVycyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtcywgbWV0aG9kLCBpc0dlbmVyYXRvcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU2V0dGVyTWV0aG9kID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBmb3JtYWxQYXJhbWV0ZXJzID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoKTtcclxuXHQgICAgICAgIGlmIChmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtcy5sZW5ndGggIT09IDEpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5CYWRTZXR0ZXJBcml0eSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmIChmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtc1swXSBpbnN0YW5jZW9mIE5vZGUuUmVzdEVsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5CYWRTZXR0ZXJSZXN0UGFyYW1ldGVyKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2QoZm9ybWFsUGFyYW1ldGVycyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtcywgbWV0aG9kLCBpc0dlbmVyYXRvcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlR2VuZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kKHBhcmFtcyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBwYXJhbXMucGFyYW1zLCBtZXRob2QsIGlzR2VuZXJhdG9yKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdlbmVyYXRvci1mdW5jdGlvbi1kZWZpbml0aW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmlzU3RhcnRPZkV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5sb29rYWhlYWQudmFsdWU7XHJcblx0ICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIDcgLyogUHVuY3R1YXRvciAqLzpcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQgPSAodmFsdWUgPT09ICdbJykgfHwgKHZhbHVlID09PSAnKCcpIHx8ICh2YWx1ZSA9PT0gJ3snKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAnKycpIHx8ICh2YWx1ZSA9PT0gJy0nKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAnIScpIHx8ICh2YWx1ZSA9PT0gJ34nKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAnKysnKSB8fCAodmFsdWUgPT09ICctLScpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICcvJykgfHwgKHZhbHVlID09PSAnLz0nKTsgLy8gcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWxcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA0IC8qIEtleXdvcmQgKi86XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0ID0gKHZhbHVlID09PSAnY2xhc3MnKSB8fCAodmFsdWUgPT09ICdkZWxldGUnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAnZnVuY3Rpb24nKSB8fCAodmFsdWUgPT09ICdsZXQnKSB8fCAodmFsdWUgPT09ICduZXcnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAnc3VwZXInKSB8fCAodmFsdWUgPT09ICd0aGlzJykgfHwgKHZhbHVlID09PSAndHlwZW9mJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJ3ZvaWQnKSB8fCAodmFsdWUgPT09ICd5aWVsZCcpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBzdGFydDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVlpZWxkRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3lpZWxkJyk7XHJcblx0ICAgICAgICB2YXIgYXJndW1lbnQgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGRlbGVnYXRlID0gZmFsc2U7XHJcblx0ICAgICAgICBpZiAoIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcclxuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICBkZWxlZ2F0ZSA9IHRoaXMubWF0Y2goJyonKTtcclxuXHQgICAgICAgICAgICBpZiAoZGVsZWdhdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgYXJndW1lbnQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc1N0YXJ0T2ZFeHByZXNzaW9uKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgYXJndW1lbnQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5ZaWVsZEV4cHJlc3Npb24oYXJndW1lbnQsIGRlbGVnYXRlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNsYXNzLWRlZmluaXRpb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0VsZW1lbnQgPSBmdW5jdGlvbiAoaGFzQ29uc3RydWN0b3IpIHtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBraW5kID0gJyc7XHJcblx0ICAgICAgICB2YXIga2V5ID0gbnVsbDtcclxuXHQgICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgY29tcHV0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBtZXRob2QgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBpc1N0YXRpYyA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGlzQXN5bmMgPSBmYWxzZTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcqJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0ga2V5O1xyXG5cdCAgICAgICAgICAgIGlmIChpZC5uYW1lID09PSAnc3RhdGljJyAmJiAodGhpcy5xdWFsaWZpZWRQcm9wZXJ0eU5hbWUodGhpcy5sb29rYWhlYWQpIHx8IHRoaXMubWF0Y2goJyonKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICAgICAgaXNTdGF0aWMgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyonKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICgodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSAmJiAhdGhpcy5oYXNMaW5lVGVybWluYXRvciAmJiAodG9rZW4udmFsdWUgPT09ICdhc3luYycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwdW5jdHVhdG9yID0gdGhpcy5sb29rYWhlYWQudmFsdWU7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChwdW5jdHVhdG9yICE9PSAnOicgJiYgcHVuY3R1YXRvciAhPT0gJygnICYmIHB1bmN0dWF0b3IgIT09ICcqJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaXNBc3luYyA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnZ2V0JyB8fCB0b2tlbi52YWx1ZSA9PT0gJ3NldCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnY29uc3RydWN0b3InKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuQ29uc3RydWN0b3JJc0FzeW5jKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbG9va2FoZWFkUHJvcGVydHlLZXkgPSB0aGlzLnF1YWxpZmllZFByb3BlcnR5TmFtZSh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnZ2V0JyAmJiBsb29rYWhlYWRQcm9wZXJ0eUtleSkge1xyXG5cdCAgICAgICAgICAgICAgICBraW5kID0gJ2dldCc7XHJcblx0ICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlR2V0dGVyTWV0aG9kKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnc2V0JyAmJiBsb29rYWhlYWRQcm9wZXJ0eUtleSkge1xyXG5cdCAgICAgICAgICAgICAgICBraW5kID0gJ3NldCc7XHJcblx0ICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlU2V0dGVyTWV0aG9kKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIHRva2VuLnZhbHVlID09PSAnKicgJiYgbG9va2FoZWFkUHJvcGVydHlLZXkpIHtcclxuXHQgICAgICAgICAgICBraW5kID0gJ2luaXQnO1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZUdlbmVyYXRvck1ldGhvZCgpO1xyXG5cdCAgICAgICAgICAgIG1ldGhvZCA9IHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIWtpbmQgJiYga2V5ICYmIHRoaXMubWF0Y2goJygnKSkge1xyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnaW5pdCc7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSBpc0FzeW5jID8gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kQXN5bmNGdW5jdGlvbigpIDogdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24oKTtcclxuXHQgICAgICAgICAgICBtZXRob2QgPSB0cnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCFraW5kKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoa2luZCA9PT0gJ2luaXQnKSB7XHJcblx0ICAgICAgICAgICAga2luZCA9ICdtZXRob2QnO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCFjb21wdXRlZCkge1xyXG5cdCAgICAgICAgICAgIGlmIChpc1N0YXRpYyAmJiB0aGlzLmlzUHJvcGVydHlLZXkoa2V5LCAncHJvdG90eXBlJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdGF0aWNQcm90b3R5cGUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoIWlzU3RhdGljICYmIHRoaXMuaXNQcm9wZXJ0eUtleShrZXksICdjb25zdHJ1Y3RvcicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChraW5kICE9PSAnbWV0aG9kJyB8fCAhbWV0aG9kIHx8ICh2YWx1ZSAmJiB2YWx1ZS5nZW5lcmF0b3IpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLkNvbnN0cnVjdG9yU3BlY2lhbE1ldGhvZCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGhhc0NvbnN0cnVjdG9yLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLkR1cGxpY2F0ZUNvbnN0cnVjdG9yKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGhhc0NvbnN0cnVjdG9yLnZhbHVlID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBraW5kID0gJ2NvbnN0cnVjdG9yJztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5NZXRob2REZWZpbml0aW9uKGtleSwgY29tcHV0ZWQsIHZhbHVlLCBraW5kLCBpc1N0YXRpYykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NFbGVtZW50TGlzdCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBib2R5ID0gW107XHJcblx0ICAgICAgICB2YXIgaGFzQ29uc3RydWN0b3IgPSB7IHZhbHVlOiBmYWxzZSB9O1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJzsnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYm9keS5wdXNoKHRoaXMucGFyc2VDbGFzc0VsZW1lbnQoaGFzQ29uc3RydWN0b3IpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgcmV0dXJuIGJvZHk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0JvZHkgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGVsZW1lbnRMaXN0ID0gdGhpcy5wYXJzZUNsYXNzRWxlbWVudExpc3QoKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNsYXNzQm9keShlbGVtZW50TGlzdCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChpZGVudGlmaWVySXNPcHRpb25hbCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnY2xhc3MnKTtcclxuXHQgICAgICAgIHZhciBpZCA9IChpZGVudGlmaWVySXNPcHRpb25hbCAmJiAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMyAvKiBJZGVudGlmaWVyICovKSkgPyBudWxsIDogdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgdmFyIHN1cGVyQ2xhc3MgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdleHRlbmRzJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHN1cGVyQ2xhc3MgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGNsYXNzQm9keSA9IHRoaXMucGFyc2VDbGFzc0JvZHkoKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNsYXNzRGVjbGFyYXRpb24oaWQsIHN1cGVyQ2xhc3MsIGNsYXNzQm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnY2xhc3MnKTtcclxuXHQgICAgICAgIHZhciBpZCA9ICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pID8gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpIDogbnVsbDtcclxuXHQgICAgICAgIHZhciBzdXBlckNsYXNzID0gbnVsbDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZXh0ZW5kcycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBzdXBlckNsYXNzID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBjbGFzc0JvZHkgPSB0aGlzLnBhcnNlQ2xhc3NCb2R5KCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5DbGFzc0V4cHJlc3Npb24oaWQsIHN1cGVyQ2xhc3MsIGNsYXNzQm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zY3JpcHRzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW1vZHVsZXNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU1vZHVsZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzTW9kdWxlID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VEaXJlY3RpdmVQcm9sb2d1ZXMoKTtcclxuXHQgICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgIGJvZHkucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Nb2R1bGUoYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU2NyaXB0ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZURpcmVjdGl2ZVByb2xvZ3VlcygpO1xyXG5cdCAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgYm9keS5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlNjcmlwdChib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWltcG9ydHNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU1vZHVsZVNwZWNpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gOCAvKiBTdHJpbmdMaXRlcmFsICovKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZE1vZHVsZVNwZWNpZmllcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdmFyIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTGl0ZXJhbCh0b2tlbi52YWx1ZSwgcmF3KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGltcG9ydCB7PGZvbyBhcyBiYXI+fSAuLi47XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJbXBvcnRTcGVjaWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGltcG9ydGVkO1xyXG5cdCAgICAgICAgdmFyIGxvY2FsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIGltcG9ydGVkID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIGxvY2FsID0gaW1wb3J0ZWQ7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXMnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBsb2NhbCA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBpbXBvcnRlZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgICAgIGxvY2FsID0gaW1wb3J0ZWQ7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXMnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBsb2NhbCA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSW1wb3J0U3BlY2lmaWVyKGxvY2FsLCBpbXBvcnRlZCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyB7Zm9vLCBiYXIgYXMgYmFzfVxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTmFtZWRJbXBvcnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHZhciBzcGVjaWZpZXJzID0gW107XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyKCkpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHJldHVybiBzcGVjaWZpZXJzO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBpbXBvcnQgPGZvbz4gLi4uO1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSW1wb3J0RGVmYXVsdFNwZWNpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgbG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkltcG9ydERlZmF1bHRTcGVjaWZpZXIobG9jYWwpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaW1wb3J0IDwqIGFzIGZvbz4gLi4uO1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcqJyk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXMnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLk5vQXNBZnRlckltcG9ydE5hbWVzcGFjZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdmFyIGxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIobG9jYWwpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUltcG9ydERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxJbXBvcnREZWNsYXJhdGlvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdpbXBvcnQnKTtcclxuXHQgICAgICAgIHZhciBzcmM7XHJcblx0ICAgICAgICB2YXIgc3BlY2lmaWVycyA9IFtdO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDggLyogU3RyaW5nTGl0ZXJhbCAqLykge1xyXG5cdCAgICAgICAgICAgIC8vIGltcG9ydCAnZm9vJztcclxuXHQgICAgICAgICAgICBzcmMgPSB0aGlzLnBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgneycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGltcG9ydCB7YmFyfVxyXG5cdCAgICAgICAgICAgICAgICBzcGVjaWZpZXJzID0gc3BlY2lmaWVycy5jb25jYXQodGhpcy5wYXJzZU5hbWVkSW1wb3J0cygpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnKicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGltcG9ydCAqIGFzIGZvb1xyXG5cdCAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2godGhpcy5wYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllcigpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0lkZW50aWZpZXJOYW1lKHRoaXMubG9va2FoZWFkKSAmJiAhdGhpcy5tYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBpbXBvcnQgZm9vXHJcblx0ICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh0aGlzLnBhcnNlSW1wb3J0RGVmYXVsdFNwZWNpZmllcigpKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcqJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbXBvcnQgZm9vLCAqIGFzIGZvb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh0aGlzLnBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgneycpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1wb3J0IGZvbywge2Jhcn1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZXJzID0gc3BlY2lmaWVycy5jb25jYXQodGhpcy5wYXJzZU5hbWVkSW1wb3J0cygpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnZnJvbScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5sb29rYWhlYWQudmFsdWUgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiA6IG1lc3NhZ2VzXzEuTWVzc2FnZXMuTWlzc2luZ0Zyb21DbGF1c2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCB0aGlzLmxvb2thaGVhZC52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgc3JjID0gdGhpcy5wYXJzZU1vZHVsZVNwZWNpZmllcigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JbXBvcnREZWNsYXJhdGlvbihzcGVjaWZpZXJzLCBzcmMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZXhwb3J0c1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRXhwb3J0U3BlY2lmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBsb2NhbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgdmFyIGV4cG9ydGVkID0gbG9jYWw7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBleHBvcnRlZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0U3BlY2lmaWVyKGxvY2FsLCBleHBvcnRlZCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRXhwb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbEV4cG9ydERlY2xhcmF0aW9uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2V4cG9ydCcpO1xyXG5cdCAgICAgICAgdmFyIGV4cG9ydERlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykpIHtcclxuXHQgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCAuLi5cclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZnVuY3Rpb24nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb28gKCkge31cclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge31cclxuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24odHJ1ZSk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2NsYXNzJykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgY2xhc3MgZm9vIHt9XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VDbGFzc0RlY2xhcmF0aW9uKHRydWUpO1xyXG5cdCAgICAgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXN5bmMnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBmICgpIHt9XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uICgpIHt9XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGFzeW5jIHggPT4geFxyXG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLm1hdGNoQXN5bmNGdW5jdGlvbigpID8gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24odHJ1ZSkgOiB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihkZWNsYXJhdGlvbikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnZnJvbScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sIHRoaXMubG9va2FoZWFkLnZhbHVlKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCB7fTtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgW107XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0ICgxICsgMik7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMubWF0Y2goJ3snKSA/IHRoaXMucGFyc2VPYmplY3RJbml0aWFsaXplcigpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2goJ1snKSA/IHRoaXMucGFyc2VBcnJheUluaXRpYWxpemVyKCkgOiB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcqJykpIHtcclxuXHQgICAgICAgICAgICAvLyBleHBvcnQgKiBmcm9tICdmb28nO1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMubG9va2FoZWFkLnZhbHVlID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4gOiBtZXNzYWdlc18xLk1lc3NhZ2VzLk1pc3NpbmdGcm9tQ2xhdXNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgdGhpcy5sb29rYWhlYWQudmFsdWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHZhciBzcmMgPSB0aGlzLnBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydEFsbERlY2xhcmF0aW9uKHNyYykpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovKSB7XHJcblx0ICAgICAgICAgICAgLy8gZXhwb3J0IHZhciBmID0gMTtcclxuXHQgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB2b2lkIDA7XHJcblx0ICAgICAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC52YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdsZXQnOlxyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdjb25zdCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VMZXhpY2FsRGVjbGFyYXRpb24oeyBpbkZvcjogZmFsc2UgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAndmFyJzpcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnY2xhc3MnOlxyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydE5hbWVkRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIFtdLCBudWxsKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoQXN5bmNGdW5jdGlvbigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0TmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwgW10sIG51bGwpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhciBzcGVjaWZpZXJzID0gW107XHJcblx0ICAgICAgICAgICAgdmFyIHNvdXJjZSA9IG51bGw7XHJcblx0ICAgICAgICAgICAgdmFyIGlzRXhwb3J0RnJvbUlkZW50aWZpZXIgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlzRXhwb3J0RnJvbUlkZW50aWZpZXIgPSBpc0V4cG9ydEZyb21JZGVudGlmaWVyIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCdkZWZhdWx0Jyk7XHJcblx0ICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVyKCkpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQge2RlZmF1bHR9IGZyb20gJ2Zvbyc7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCB7Zm9vfSBmcm9tICdmb28nO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBzb3VyY2UgPSB0aGlzLnBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChpc0V4cG9ydEZyb21JZGVudGlmaWVyKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCB7ZGVmYXVsdH07IC8vIG1pc3NpbmcgZnJvbUNsYXVzZVxyXG5cdCAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMubG9va2FoZWFkLnZhbHVlID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4gOiBtZXNzYWdlc18xLk1lc3NhZ2VzLk1pc3NpbmdGcm9tQ2xhdXNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgdGhpcy5sb29rYWhlYWQudmFsdWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IHtmb299O1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydE5hbWVkRGVjbGFyYXRpb24obnVsbCwgc3BlY2lmaWVycywgc291cmNlKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwb3J0RGVjbGFyYXRpb247XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBQYXJzZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcclxuXG5cbi8qKiovIH0sXG4vKiA5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHQvLyBFbnN1cmUgdGhlIGNvbmRpdGlvbiBpcyB0cnVlLCBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3IuXHJcblx0Ly8gVGhpcyBpcyBvbmx5IHRvIGhhdmUgYSBiZXR0ZXIgY29udHJhY3Qgc2VtYW50aWMsIGkuZS4gYW5vdGhlciBzYWZldHkgbmV0XHJcblx0Ly8gdG8gY2F0Y2ggYSBsb2dpYyBlcnJvci4gVGhlIGNvbmRpdGlvbiBzaGFsbCBiZSBmdWxmaWxsZWQgaW4gbm9ybWFsIGNhc2UuXHJcblx0Ly8gRG8gTk9UIHVzZSB0aGlzIHRvIGVuZm9yY2UgYSBjZXJ0YWluIGNvbmRpdGlvbiBvbiBhbnkgdXNlciBpbnB1dC5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0ZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xyXG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuXHQgICAgaWYgKCFjb25kaXRpb24pIHtcclxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignQVNTRVJUOiAnICsgbWVzc2FnZSk7XHJcblx0ICAgIH1cclxuXHR9XHJcblx0ZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XHJcblxuXG4vKioqLyB9LFxuLyogMTAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdC8qIHRzbGludDpkaXNhYmxlOm1heC1jbGFzc2VzLXBlci1maWxlICovXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBFcnJvckhhbmRsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFcnJvckhhbmRsZXIoKSB7XHJcblx0ICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy50b2xlcmFudCA9IGZhbHNlO1xyXG5cdCAgICB9XHJcblx0ICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUucmVjb3JkRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goZXJyb3IpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLnRvbGVyYXRlID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMucmVjb3JkRXJyb3IoZXJyb3IpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUuY29uc3RydWN0RXJyb3IgPSBmdW5jdGlvbiAobXNnLCBjb2x1bW4pIHtcclxuXHQgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihtc2cpO1xyXG5cdCAgICAgICAgdHJ5IHtcclxuXHQgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGNhdGNoIChiYXNlKSB7XHJcblx0ICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuXHQgICAgICAgICAgICBpZiAoT2JqZWN0LmNyZWF0ZSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcclxuXHQgICAgICAgICAgICAgICAgZXJyb3IgPSBPYmplY3QuY3JlYXRlKGJhc2UpO1xyXG5cdCAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3IsICdjb2x1bW4nLCB7IHZhbHVlOiBjb2x1bW4gfSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgICAgICAgIHJldHVybiBlcnJvcjtcclxuXHQgICAgfTtcclxuXHQgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVFcnJvciA9IGZ1bmN0aW9uIChpbmRleCwgbGluZSwgY29sLCBkZXNjcmlwdGlvbikge1xyXG5cdCAgICAgICAgdmFyIG1zZyA9ICdMaW5lICcgKyBsaW5lICsgJzogJyArIGRlc2NyaXB0aW9uO1xyXG5cdCAgICAgICAgdmFyIGVycm9yID0gdGhpcy5jb25zdHJ1Y3RFcnJvcihtc2csIGNvbCk7XHJcblx0ICAgICAgICBlcnJvci5pbmRleCA9IGluZGV4O1xyXG5cdCAgICAgICAgZXJyb3IubGluZU51bWJlciA9IGxpbmU7XHJcblx0ICAgICAgICBlcnJvci5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xyXG5cdCAgICAgICAgcmV0dXJuIGVycm9yO1xyXG5cdCAgICB9O1xyXG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLnRocm93RXJyb3IgPSBmdW5jdGlvbiAoaW5kZXgsIGxpbmUsIGNvbCwgZGVzY3JpcHRpb24pIHtcclxuXHQgICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IoaW5kZXgsIGxpbmUsIGNvbCwgZGVzY3JpcHRpb24pO1xyXG5cdCAgICB9O1xyXG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLnRvbGVyYXRlRXJyb3IgPSBmdW5jdGlvbiAoaW5kZXgsIGxpbmUsIGNvbCwgZGVzY3JpcHRpb24pIHtcclxuXHQgICAgICAgIHZhciBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoaW5kZXgsIGxpbmUsIGNvbCwgZGVzY3JpcHRpb24pO1xyXG5cdCAgICAgICAgaWYgKHRoaXMudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnJlY29yZEVycm9yKGVycm9yKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gRXJyb3JIYW5kbGVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FcnJvckhhbmRsZXIgPSBFcnJvckhhbmRsZXI7XHJcblxuXG4vKioqLyB9LFxuLyogMTEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHQvLyBFcnJvciBtZXNzYWdlcyBzaG91bGQgYmUgaWRlbnRpY2FsIHRvIFY4LlxyXG5cdGV4cG9ydHMuTWVzc2FnZXMgPSB7XHJcblx0ICAgIEJhZEdldHRlckFyaXR5OiAnR2V0dGVyIG11c3Qgbm90IGhhdmUgYW55IGZvcm1hbCBwYXJhbWV0ZXJzJyxcclxuXHQgICAgQmFkU2V0dGVyQXJpdHk6ICdTZXR0ZXIgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGZvcm1hbCBwYXJhbWV0ZXInLFxyXG5cdCAgICBCYWRTZXR0ZXJSZXN0UGFyYW1ldGVyOiAnU2V0dGVyIGZ1bmN0aW9uIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgcmVzdCBwYXJhbWV0ZXInLFxyXG5cdCAgICBDb25zdHJ1Y3RvcklzQXN5bmM6ICdDbGFzcyBjb25zdHJ1Y3RvciBtYXkgbm90IGJlIGFuIGFzeW5jIG1ldGhvZCcsXHJcblx0ICAgIENvbnN0cnVjdG9yU3BlY2lhbE1ldGhvZDogJ0NsYXNzIGNvbnN0cnVjdG9yIG1heSBub3QgYmUgYW4gYWNjZXNzb3InLFxyXG5cdCAgICBEZWNsYXJhdGlvbk1pc3NpbmdJbml0aWFsaXplcjogJ01pc3NpbmcgaW5pdGlhbGl6ZXIgaW4gJTAgZGVjbGFyYXRpb24nLFxyXG5cdCAgICBEZWZhdWx0UmVzdFBhcmFtZXRlcjogJ1VuZXhwZWN0ZWQgdG9rZW4gPScsXHJcblx0ICAgIER1cGxpY2F0ZUJpbmRpbmc6ICdEdXBsaWNhdGUgYmluZGluZyAlMCcsXHJcblx0ICAgIER1cGxpY2F0ZUNvbnN0cnVjdG9yOiAnQSBjbGFzcyBtYXkgb25seSBoYXZlIG9uZSBjb25zdHJ1Y3RvcicsXHJcblx0ICAgIER1cGxpY2F0ZVByb3RvUHJvcGVydHk6ICdEdXBsaWNhdGUgX19wcm90b19fIGZpZWxkcyBhcmUgbm90IGFsbG93ZWQgaW4gb2JqZWN0IGxpdGVyYWxzJyxcclxuXHQgICAgRm9ySW5PZkxvb3BJbml0aWFsaXplcjogJyUwIGxvb3AgdmFyaWFibGUgZGVjbGFyYXRpb24gbWF5IG5vdCBoYXZlIGFuIGluaXRpYWxpemVyJyxcclxuXHQgICAgR2VuZXJhdG9ySW5MZWdhY3lDb250ZXh0OiAnR2VuZXJhdG9yIGRlY2xhcmF0aW9ucyBhcmUgbm90IGFsbG93ZWQgaW4gbGVnYWN5IGNvbnRleHRzJyxcclxuXHQgICAgSWxsZWdhbEJyZWFrOiAnSWxsZWdhbCBicmVhayBzdGF0ZW1lbnQnLFxyXG5cdCAgICBJbGxlZ2FsQ29udGludWU6ICdJbGxlZ2FsIGNvbnRpbnVlIHN0YXRlbWVudCcsXHJcblx0ICAgIElsbGVnYWxFeHBvcnREZWNsYXJhdGlvbjogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxyXG5cdCAgICBJbGxlZ2FsSW1wb3J0RGVjbGFyYXRpb246ICdVbmV4cGVjdGVkIHRva2VuJyxcclxuXHQgICAgSWxsZWdhbExhbmd1YWdlTW9kZURpcmVjdGl2ZTogJ0lsbGVnYWwgXFwndXNlIHN0cmljdFxcJyBkaXJlY3RpdmUgaW4gZnVuY3Rpb24gd2l0aCBub24tc2ltcGxlIHBhcmFtZXRlciBsaXN0JyxcclxuXHQgICAgSWxsZWdhbFJldHVybjogJ0lsbGVnYWwgcmV0dXJuIHN0YXRlbWVudCcsXHJcblx0ICAgIEludmFsaWRFc2NhcGVkUmVzZXJ2ZWRXb3JkOiAnS2V5d29yZCBtdXN0IG5vdCBjb250YWluIGVzY2FwZWQgY2hhcmFjdGVycycsXHJcblx0ICAgIEludmFsaWRIZXhFc2NhcGVTZXF1ZW5jZTogJ0ludmFsaWQgaGV4YWRlY2ltYWwgZXNjYXBlIHNlcXVlbmNlJyxcclxuXHQgICAgSW52YWxpZExIU0luQXNzaWdubWVudDogJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gYXNzaWdubWVudCcsXHJcblx0ICAgIEludmFsaWRMSFNJbkZvckluOiAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3ItaW4nLFxyXG5cdCAgICBJbnZhbGlkTEhTSW5Gb3JMb29wOiAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3ItbG9vcCcsXHJcblx0ICAgIEludmFsaWRNb2R1bGVTcGVjaWZpZXI6ICdVbmV4cGVjdGVkIHRva2VuJyxcclxuXHQgICAgSW52YWxpZFJlZ0V4cDogJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uJyxcclxuXHQgICAgTGV0SW5MZXhpY2FsQmluZGluZzogJ2xldCBpcyBkaXNhbGxvd2VkIGFzIGEgbGV4aWNhbGx5IGJvdW5kIG5hbWUnLFxyXG5cdCAgICBNaXNzaW5nRnJvbUNsYXVzZTogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxyXG5cdCAgICBNdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2g6ICdNb3JlIHRoYW4gb25lIGRlZmF1bHQgY2xhdXNlIGluIHN3aXRjaCBzdGF0ZW1lbnQnLFxyXG5cdCAgICBOZXdsaW5lQWZ0ZXJUaHJvdzogJ0lsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvdycsXHJcblx0ICAgIE5vQXNBZnRlckltcG9ydE5hbWVzcGFjZTogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxyXG5cdCAgICBOb0NhdGNoT3JGaW5hbGx5OiAnTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGFmdGVyIHRyeScsXHJcblx0ICAgIFBhcmFtZXRlckFmdGVyUmVzdFBhcmFtZXRlcjogJ1Jlc3QgcGFyYW1ldGVyIG11c3QgYmUgbGFzdCBmb3JtYWwgcGFyYW1ldGVyJyxcclxuXHQgICAgUmVkZWNsYXJhdGlvbjogJyUwIFxcJyUxXFwnIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWQnLFxyXG5cdCAgICBTdGF0aWNQcm90b3R5cGU6ICdDbGFzc2VzIG1heSBub3QgaGF2ZSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgcHJvdG90eXBlJyxcclxuXHQgICAgU3RyaWN0Q2F0Y2hWYXJpYWJsZTogJ0NhdGNoIHZhcmlhYmxlIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3REZWxldGU6ICdEZWxldGUgb2YgYW4gdW5xdWFsaWZpZWQgaWRlbnRpZmllciBpbiBzdHJpY3QgbW9kZS4nLFxyXG5cdCAgICBTdHJpY3RGdW5jdGlvbjogJ0luIHN0cmljdCBtb2RlIGNvZGUsIGZ1bmN0aW9ucyBjYW4gb25seSBiZSBkZWNsYXJlZCBhdCB0b3AgbGV2ZWwgb3IgaW5zaWRlIGEgYmxvY2snLFxyXG5cdCAgICBTdHJpY3RGdW5jdGlvbk5hbWU6ICdGdW5jdGlvbiBuYW1lIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3RMSFNBc3NpZ25tZW50OiAnQXNzaWdubWVudCB0byBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdExIU1Bvc3RmaXg6ICdQb3N0Zml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3RMSFNQcmVmaXg6ICdQcmVmaXggaW5jcmVtZW50L2RlY3JlbWVudCBtYXkgbm90IGhhdmUgZXZhbCBvciBhcmd1bWVudHMgb3BlcmFuZCBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdE1vZGVXaXRoOiAnU3RyaWN0IG1vZGUgY29kZSBtYXkgbm90IGluY2x1ZGUgYSB3aXRoIHN0YXRlbWVudCcsXHJcblx0ICAgIFN0cmljdE9jdGFsTGl0ZXJhbDogJ09jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZS4nLFxyXG5cdCAgICBTdHJpY3RQYXJhbUR1cGU6ICdTdHJpY3QgbW9kZSBmdW5jdGlvbiBtYXkgbm90IGhhdmUgZHVwbGljYXRlIHBhcmFtZXRlciBuYW1lcycsXHJcblx0ICAgIFN0cmljdFBhcmFtTmFtZTogJ1BhcmFtZXRlciBuYW1lIGV2YWwgb3IgYXJndW1lbnRzIGlzIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0UmVzZXJ2ZWRXb3JkOiAnVXNlIG9mIGZ1dHVyZSByZXNlcnZlZCB3b3JkIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0VmFyTmFtZTogJ1ZhcmlhYmxlIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFRlbXBsYXRlT2N0YWxMaXRlcmFsOiAnT2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHRlbXBsYXRlIHN0cmluZ3MuJyxcclxuXHQgICAgVW5leHBlY3RlZEVPUzogJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0JyxcclxuXHQgICAgVW5leHBlY3RlZElkZW50aWZpZXI6ICdVbmV4cGVjdGVkIGlkZW50aWZpZXInLFxyXG5cdCAgICBVbmV4cGVjdGVkTnVtYmVyOiAnVW5leHBlY3RlZCBudW1iZXInLFxyXG5cdCAgICBVbmV4cGVjdGVkUmVzZXJ2ZWQ6ICdVbmV4cGVjdGVkIHJlc2VydmVkIHdvcmQnLFxyXG5cdCAgICBVbmV4cGVjdGVkU3RyaW5nOiAnVW5leHBlY3RlZCBzdHJpbmcnLFxyXG5cdCAgICBVbmV4cGVjdGVkVGVtcGxhdGU6ICdVbmV4cGVjdGVkIHF1YXNpICUwJyxcclxuXHQgICAgVW5leHBlY3RlZFRva2VuOiAnVW5leHBlY3RlZCB0b2tlbiAlMCcsXHJcblx0ICAgIFVuZXhwZWN0ZWRUb2tlbklsbGVnYWw6ICdVbmV4cGVjdGVkIHRva2VuIElMTEVHQUwnLFxyXG5cdCAgICBVbmtub3duTGFiZWw6ICdVbmRlZmluZWQgbGFiZWwgXFwnJTBcXCcnLFxyXG5cdCAgICBVbnRlcm1pbmF0ZWRSZWdFeHA6ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogbWlzc2luZyAvJ1xyXG5cdH07XHJcblxuXG4vKioqLyB9LFxuLyogMTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgYXNzZXJ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG5cdHZhciBjaGFyYWN0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblx0dmFyIG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxuXHRmdW5jdGlvbiBoZXhWYWx1ZShjaCkge1xyXG5cdCAgICByZXR1cm4gJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIG9jdGFsVmFsdWUoY2gpIHtcclxuXHQgICAgcmV0dXJuICcwMTIzNDU2NycuaW5kZXhPZihjaCk7XHJcblx0fVxyXG5cdHZhciBTY2FubmVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU2Nhbm5lcihjb2RlLCBoYW5kbGVyKSB7XHJcblx0ICAgICAgICB0aGlzLnNvdXJjZSA9IGNvZGU7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlciA9IGhhbmRsZXI7XHJcblx0ICAgICAgICB0aGlzLnRyYWNrQ29tbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5sZW5ndGggPSBjb2RlLmxlbmd0aDtcclxuXHQgICAgICAgIHRoaXMuaW5kZXggPSAwO1xyXG5cdCAgICAgICAgdGhpcy5saW5lTnVtYmVyID0gKGNvZGUubGVuZ3RoID4gMCkgPyAxIDogMDtcclxuXHQgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gMDtcclxuXHQgICAgICAgIHRoaXMuY3VybHlTdGFjayA9IFtdO1xyXG5cdCAgICB9XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNhdmVTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnRcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnJlc3RvcmVTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xyXG5cdCAgICAgICAgdGhpcy5pbmRleCA9IHN0YXRlLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5saW5lTnVtYmVyID0gc3RhdGUubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5lb2YgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5pbmRleCA+PSB0aGlzLmxlbmd0aDtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUudGhyb3dVbmV4cGVjdGVkVG9rZW4gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG5cdCAgICAgICAgaWYgKG1lc3NhZ2UgPT09IHZvaWQgMCkgeyBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW5JbGxlZ2FsOyB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5lcnJvckhhbmRsZXIudGhyb3dFcnJvcih0aGlzLmluZGV4LCB0aGlzLmxpbmVOdW1iZXIsIHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydCArIDEsIG1lc3NhZ2UpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcblx0ICAgICAgICBpZiAobWVzc2FnZSA9PT0gdm9pZCAwKSB7IG1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbklsbGVnYWw7IH1cclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLnRvbGVyYXRlRXJyb3IodGhpcy5pbmRleCwgdGhpcy5saW5lTnVtYmVyLCB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnQgKyAxLCBtZXNzYWdlKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY29tbWVudHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2tpcFNpbmdsZUxpbmVDb21tZW50ID0gZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdCAgICAgICAgdmFyIGNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICB2YXIgc3RhcnQsIGxvYztcclxuXHQgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICAgICAgc3RhcnQgPSB0aGlzLmluZGV4IC0gb2Zmc2V0O1xyXG5cdCAgICAgICAgICAgIGxvYyA9IHtcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0IC0gb2Zmc2V0XHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIGVuZDoge31cclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0IC0gMVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aUxpbmU6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlOiBbc3RhcnQgKyBvZmZzZXQsIHRoaXMuaW5kZXggLSAxXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCB0aGlzLmluZGV4IC0gMV0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiBsb2NcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDEzICYmIHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkgPT09IDEwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1lbnRzO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIGxvYy5lbmQgPSB7XHJcblx0ICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnRcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcclxuXHQgICAgICAgICAgICAgICAgbXVsdGlMaW5lOiBmYWxzZSxcclxuXHQgICAgICAgICAgICAgICAgc2xpY2U6IFtzdGFydCArIG9mZnNldCwgdGhpcy5pbmRleF0sXHJcblx0ICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIHRoaXMuaW5kZXhdLFxyXG5cdCAgICAgICAgICAgICAgICBsb2M6IGxvY1xyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgY29tbWVudHMucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gY29tbWVudHM7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNraXBNdWx0aUxpbmVDb21tZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICB2YXIgc3RhcnQsIGxvYztcclxuXHQgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICAgICAgc3RhcnQgPSB0aGlzLmluZGV4IC0gMjtcclxuXHQgICAgICAgICAgICBsb2MgPSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydCAtIDJcclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB7fVxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaCkpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAweDBEICYmIHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpID09PSAweDBBKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gMHgyQSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBCbG9jayBjb21tZW50IGVuZHMgd2l0aCAnKi8nLlxyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSkgPT09IDB4MkYpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMjtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlMaW5lOiB0cnVlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGljZTogW3N0YXJ0ICsgMiwgdGhpcy5pbmRleCAtIDJdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCB0aGlzLmluZGV4XSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiBsb2NcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1lbnRzO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBSYW4gb2ZmIHRoZSBlbmQgb2YgdGhlIGZpbGUgLSB0aGUgd2hvbGUgdGhpbmcgaXMgYSBjb21tZW50XHJcblx0ICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICBsb2MuZW5kID0ge1xyXG5cdCAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICB2YXIgZW50cnkgPSB7XHJcblx0ICAgICAgICAgICAgICAgIG11bHRpTGluZTogdHJ1ZSxcclxuXHQgICAgICAgICAgICAgICAgc2xpY2U6IFtzdGFydCArIDIsIHRoaXMuaW5kZXhdLFxyXG5cdCAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCB0aGlzLmluZGV4XSxcclxuXHQgICAgICAgICAgICAgICAgbG9jOiBsb2NcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIGNvbW1lbnRzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuQ29tbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY29tbWVudHM7XHJcblx0ICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gKHRoaXMuaW5kZXggPT09IDApO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzV2hpdGVTcGFjZShjaCkpIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaCkpIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MEQgJiYgdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSA9PT0gMHgwQSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4MkYpIHtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAxKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAweDJGKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDI7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMuc2tpcFNpbmdsZUxpbmVDb21tZW50KDIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5jb25jYXQoY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4MkEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gdGhpcy5za2lwTXVsdGlMaW5lQ29tbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5jb25jYXQoY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChzdGFydCAmJiBjaCA9PT0gMHgyRCkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBVKzAwM0UgaXMgJz4nXHJcblx0ICAgICAgICAgICAgICAgIGlmICgodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSkgPT09IDB4MkQpICYmICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAyKSA9PT0gMHgzRSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vICctLT4nIGlzIGEgc2luZ2xlLWxpbmUgY29tbWVudFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLnNraXBTaW5nbGVMaW5lQ29tbWVudCgzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID0gY29tbWVudHMuY29uY2F0KGNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4M0MpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlLnNsaWNlKHRoaXMuaW5kZXggKyAxLCB0aGlzLmluZGV4ICsgNCkgPT09ICchLS0nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDQ7IC8vIGA8IS0tYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLnNraXBTaW5nbGVMaW5lQ29tbWVudCg0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID0gY29tbWVudHMuY29uY2F0KGNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBjb21tZW50cztcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZnV0dXJlLXJlc2VydmVkLXdvcmRzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmlzRnV0dXJlUmVzZXJ2ZWRXb3JkID0gZnVuY3Rpb24gKGlkKSB7XHJcblx0ICAgICAgICBzd2l0Y2ggKGlkKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAnZW51bSc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnZXhwb3J0JzpcclxuXHQgICAgICAgICAgICBjYXNlICdpbXBvcnQnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3N1cGVyJzpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQgPSBmdW5jdGlvbiAoaWQpIHtcclxuXHQgICAgICAgIHN3aXRjaCAoaWQpIHtcclxuXHQgICAgICAgICAgICBjYXNlICdpbXBsZW1lbnRzJzpcclxuXHQgICAgICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3BhY2thZ2UnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3ByaXZhdGUnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3Byb3RlY3RlZCc6XHJcblx0ICAgICAgICAgICAgY2FzZSAncHVibGljJzpcclxuXHQgICAgICAgICAgICBjYXNlICdzdGF0aWMnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3lpZWxkJzpcclxuXHQgICAgICAgICAgICBjYXNlICdsZXQnOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmlzUmVzdHJpY3RlZFdvcmQgPSBmdW5jdGlvbiAoaWQpIHtcclxuXHQgICAgICAgIHJldHVybiBpZCA9PT0gJ2V2YWwnIHx8IGlkID09PSAnYXJndW1lbnRzJztcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMta2V5d29yZHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuaXNLZXl3b3JkID0gZnVuY3Rpb24gKGlkKSB7XHJcblx0ICAgICAgICBzd2l0Y2ggKGlkLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgMjpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2lmJykgfHwgKGlkID09PSAnaW4nKSB8fCAoaWQgPT09ICdkbycpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgMzpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3ZhcicpIHx8IChpZCA9PT0gJ2ZvcicpIHx8IChpZCA9PT0gJ25ldycpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAoaWQgPT09ICd0cnknKSB8fCAoaWQgPT09ICdsZXQnKTtcclxuXHQgICAgICAgICAgICBjYXNlIDQ6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd0aGlzJykgfHwgKGlkID09PSAnZWxzZScpIHx8IChpZCA9PT0gJ2Nhc2UnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKGlkID09PSAndm9pZCcpIHx8IChpZCA9PT0gJ3dpdGgnKSB8fCAoaWQgPT09ICdlbnVtJyk7XHJcblx0ICAgICAgICAgICAgY2FzZSA1OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAnd2hpbGUnKSB8fCAoaWQgPT09ICdicmVhaycpIHx8IChpZCA9PT0gJ2NhdGNoJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgIChpZCA9PT0gJ3Rocm93JykgfHwgKGlkID09PSAnY29uc3QnKSB8fCAoaWQgPT09ICd5aWVsZCcpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAoaWQgPT09ICdjbGFzcycpIHx8IChpZCA9PT0gJ3N1cGVyJyk7XHJcblx0ICAgICAgICAgICAgY2FzZSA2OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAncmV0dXJuJykgfHwgKGlkID09PSAndHlwZW9mJykgfHwgKGlkID09PSAnZGVsZXRlJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgIChpZCA9PT0gJ3N3aXRjaCcpIHx8IChpZCA9PT0gJ2V4cG9ydCcpIHx8IChpZCA9PT0gJ2ltcG9ydCcpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNzpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2RlZmF1bHQnKSB8fCAoaWQgPT09ICdmaW5hbGx5JykgfHwgKGlkID09PSAnZXh0ZW5kcycpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgODpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2Z1bmN0aW9uJykgfHwgKGlkID09PSAnY29udGludWUnKSB8fCAoaWQgPT09ICdkZWJ1Z2dlcicpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgMTA6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpbnN0YW5jZW9mJyk7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5jb2RlUG9pbnRBdCA9IGZ1bmN0aW9uIChpKSB7XHJcblx0ICAgICAgICB2YXIgY3AgPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KGkpO1xyXG5cdCAgICAgICAgaWYgKGNwID49IDB4RDgwMCAmJiBjcCA8PSAweERCRkYpIHtcclxuXHQgICAgICAgICAgICB2YXIgc2Vjb25kID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdChpICsgMSk7XHJcblx0ICAgICAgICAgICAgaWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSBjcDtcclxuXHQgICAgICAgICAgICAgICAgY3AgPSAoZmlyc3QgLSAweEQ4MDApICogMHg0MDAgKyBzZWNvbmQgLSAweERDMDAgKyAweDEwMDAwO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBjcDtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbkhleEVzY2FwZSA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuXHQgICAgICAgIHZhciBsZW4gPSAocHJlZml4ID09PSAndScpID8gNCA6IDI7XHJcblx0ICAgICAgICB2YXIgY29kZSA9IDA7XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmVvZigpICYmIGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0hleERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogMTYgKyBoZXhWYWx1ZSh0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgdmFyIGNvZGUgPSAwO1xyXG5cdCAgICAgICAgLy8gQXQgbGVhc3QsIG9uZSBoZXggZGlnaXQgaXMgcmVxdWlyZWQuXHJcblx0ICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0hleERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBjb2RlID0gY29kZSAqIDE2ICsgaGV4VmFsdWUoY2gpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNvZGUgPiAweDEwRkZGRiB8fCBjaCAhPT0gJ30nKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5mcm9tQ29kZVBvaW50KGNvZGUpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5nZXRJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleCsrO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09IDB4NUMpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gQmxhY2tzbGFzaCAoVSswMDVDKSBtYXJrcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHN0YXJ0O1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wbGV4SWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA+PSAweEQ4MDAgJiYgY2ggPCAweERGRkYpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBoYW5kbGUgc3Vycm9nYXRlIHBhaXJzLlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gc3RhcnQ7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbXBsZXhJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyUGFydChjaCkpIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnNsaWNlKHN0YXJ0LCB0aGlzLmluZGV4KTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuZ2V0Q29tcGxleElkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY3AgPSB0aGlzLmNvZGVQb2ludEF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgdmFyIGlkID0gY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmZyb21Db2RlUG9pbnQoY3ApO1xyXG5cdCAgICAgICAgdGhpcy5pbmRleCArPSBpZC5sZW5ndGg7XHJcblx0ICAgICAgICAvLyAnXFx1JyAoVSswMDVDLCBVKzAwNzUpIGRlbm90ZXMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXHJcblx0ICAgICAgICB2YXIgY2g7XHJcblx0ICAgICAgICBpZiAoY3AgPT09IDB4NUMpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSAhPT0gMHg3NSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNjYW5IZXhFc2NhcGUoJ3UnKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSBudWxsIHx8IGNoID09PSAnXFxcXCcgfHwgIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlkID0gY2g7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBjcCA9IHRoaXMuY29kZVBvaW50QXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyUGFydChjcCkpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGNoID0gY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmZyb21Db2RlUG9pbnQoY3ApO1xyXG5cdCAgICAgICAgICAgIGlkICs9IGNoO1xyXG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gY2gubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgIC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cclxuXHQgICAgICAgICAgICBpZiAoY3AgPT09IDB4NUMpIHtcclxuXHQgICAgICAgICAgICAgICAgaWQgPSBpZC5zdWJzdHIoMCwgaWQubGVuZ3RoIC0gMSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpICE9PSAweDc1KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc2NhbkhleEVzY2FwZSgndScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSBudWxsIHx8IGNoID09PSAnXFxcXCcgfHwgIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlkICs9IGNoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBpZDtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUub2N0YWxUb0RlY2ltYWwgPSBmdW5jdGlvbiAoY2gpIHtcclxuXHQgICAgICAgIC8vIFxcMCBpcyBub3Qgb2N0YWwgZXNjYXBlIHNlcXVlbmNlXHJcblx0ICAgICAgICB2YXIgb2N0YWwgPSAoY2ggIT09ICcwJyk7XHJcblx0ICAgICAgICB2YXIgY29kZSA9IG9jdGFsVmFsdWUoY2gpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLmVvZigpICYmIGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICBvY3RhbCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgb2N0YWxWYWx1ZSh0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdKTtcclxuXHQgICAgICAgICAgICAvLyAzIGRpZ2l0cyBhcmUgb25seSBhbGxvd2VkIHdoZW4gc3RyaW5nIHN0YXJ0c1xyXG5cdCAgICAgICAgICAgIC8vIHdpdGggMCwgMSwgMiwgM1xyXG5cdCAgICAgICAgICAgIGlmICgnMDEyMycuaW5kZXhPZihjaCkgPj0gMCAmJiAhdGhpcy5lb2YoKSAmJiBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArIG9jdGFsVmFsdWUodGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBjb2RlOiBjb2RlLFxyXG5cdCAgICAgICAgICAgIG9jdGFsOiBvY3RhbFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbmFtZXMtYW5kLWtleXdvcmRzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5JZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHR5cGU7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgLy8gQmFja3NsYXNoIChVKzAwNUMpIHN0YXJ0cyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cclxuXHQgICAgICAgIHZhciBpZCA9ICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gMHg1QykgPyB0aGlzLmdldENvbXBsZXhJZGVudGlmaWVyKCkgOiB0aGlzLmdldElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgIC8vIFRoZXJlIGlzIG5vIGtleXdvcmQgb3IgbGl0ZXJhbCB3aXRoIG9ubHkgb25lIGNoYXJhY3Rlci5cclxuXHQgICAgICAgIC8vIFRodXMsIGl0IG11c3QgYmUgYW4gaWRlbnRpZmllci5cclxuXHQgICAgICAgIGlmIChpZC5sZW5ndGggPT09IDEpIHtcclxuXHQgICAgICAgICAgICB0eXBlID0gMyAvKiBJZGVudGlmaWVyICovO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5pc0tleXdvcmQoaWQpKSB7XHJcblx0ICAgICAgICAgICAgdHlwZSA9IDQgLyogS2V5d29yZCAqLztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKGlkID09PSAnbnVsbCcpIHtcclxuXHQgICAgICAgICAgICB0eXBlID0gNSAvKiBOdWxsTGl0ZXJhbCAqLztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKGlkID09PSAndHJ1ZScgfHwgaWQgPT09ICdmYWxzZScpIHtcclxuXHQgICAgICAgICAgICB0eXBlID0gMSAvKiBCb29sZWFuTGl0ZXJhbCAqLztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHR5cGUgPSAzIC8qIElkZW50aWZpZXIgKi87XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodHlwZSAhPT0gMyAvKiBJZGVudGlmaWVyICovICYmIChzdGFydCArIGlkLmxlbmd0aCAhPT0gdGhpcy5pbmRleCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgcmVzdG9yZSA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdGhpcy5pbmRleCA9IHN0YXJ0O1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkRXNjYXBlZFJlc2VydmVkV29yZCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5pbmRleCA9IHJlc3RvcmU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcblx0ICAgICAgICAgICAgdmFsdWU6IGlkLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXB1bmN0dWF0b3JzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5QdW5jdHVhdG9yID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgIC8vIENoZWNrIGZvciBtb3N0IGNvbW1vbiBzaW5nbGUtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxyXG5cdCAgICAgICAgdmFyIHN0ciA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgc3dpdGNoIChzdHIpIHtcclxuXHQgICAgICAgICAgICBjYXNlICcoJzpcclxuXHQgICAgICAgICAgICBjYXNlICd7JzpcclxuXHQgICAgICAgICAgICAgICAgaWYgKHN0ciA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cmx5U3RhY2sucHVzaCgneycpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAnLic6XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAnLicgJiYgdGhpcy5zb3VyY2VbdGhpcy5pbmRleCArIDFdID09PSAnLicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNwcmVhZCBvcGVyYXRvcjogLi4uXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLi4uJztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlICd9JzpcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmN1cmx5U3RhY2sucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgJyknOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJzsnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJywnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ1snOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ10nOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJzonOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJz8nOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ34nOlxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIC8vIDQtY2hhcmFjdGVyIHB1bmN0dWF0b3IuXHJcblx0ICAgICAgICAgICAgICAgIHN0ciA9IHRoaXMuc291cmNlLnN1YnN0cih0aGlzLmluZGV4LCA0KTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHN0ciA9PT0gJz4+Pj0nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyAzLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cclxuXHQgICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHIoMCwgMyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RyID09PSAnPT09JyB8fCBzdHIgPT09ICchPT0nIHx8IHN0ciA9PT0gJz4+PicgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICc8PD0nIHx8IHN0ciA9PT0gJz4+PScgfHwgc3RyID09PSAnKio9Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDItY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHIoMCwgMik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ciA9PT0gJyYmJyB8fCBzdHIgPT09ICd8fCcgfHwgc3RyID09PSAnPT0nIHx8IHN0ciA9PT0gJyE9JyB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICcrPScgfHwgc3RyID09PSAnLT0nIHx8IHN0ciA9PT0gJyo9JyB8fCBzdHIgPT09ICcvPScgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnKysnIHx8IHN0ciA9PT0gJy0tJyB8fCBzdHIgPT09ICc8PCcgfHwgc3RyID09PSAnPj4nIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJyY9JyB8fCBzdHIgPT09ICd8PScgfHwgc3RyID09PSAnXj0nIHx8IHN0ciA9PT0gJyU9JyB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICc8PScgfHwgc3RyID09PSAnPj0nIHx8IHN0ciA9PT0gJz0+JyB8fCBzdHIgPT09ICcqKicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJzw+PSErLSolJnxeLycuaW5kZXhPZihzdHIpID49IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IHN0YXJ0KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA3IC8qIFB1bmN0dWF0b3IgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHN0cixcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1saXRlcmFscy1udW1lcmljLWxpdGVyYWxzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5IZXhMaXRlcmFsID0gZnVuY3Rpb24gKHN0YXJ0KSB7XHJcblx0ICAgICAgICB2YXIgbnVtID0gJyc7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0hleERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChudW0ubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogNiAvKiBOdW1lcmljTGl0ZXJhbCAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQoJzB4JyArIG51bSwgMTYpLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5CaW5hcnlMaXRlcmFsID0gZnVuY3Rpb24gKHN0YXJ0KSB7XHJcblx0ICAgICAgICB2YXIgbnVtID0gJyc7XHJcblx0ICAgICAgICB2YXIgY2g7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCAhPT0gJzAnICYmIGNoICE9PSAnMScpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKG51bS5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICAvLyBvbmx5IDBiIG9yIDBCXHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydChjaCkgfHwgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KGNoKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA2IC8qIE51bWVyaWNMaXRlcmFsICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW0sIDIpLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5PY3RhbExpdGVyYWwgPSBmdW5jdGlvbiAocHJlZml4LCBzdGFydCkge1xyXG5cdCAgICAgICAgdmFyIG51bSA9ICcnO1xyXG5cdCAgICAgICAgdmFyIG9jdGFsID0gZmFsc2U7XHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdChwcmVmaXguY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICBvY3RhbCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgbnVtID0gJzAnICsgdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIW9jdGFsICYmIG51bS5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICAvLyBvbmx5IDBvIG9yIDBPXHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSB8fCBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDYgLyogTnVtZXJpY0xpdGVyYWwgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHBhcnNlSW50KG51bSwgOCksXHJcblx0ICAgICAgICAgICAgb2N0YWw6IG9jdGFsLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmlzSW1wbGljaXRPY3RhbExpdGVyYWwgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAvLyBJbXBsaWNpdCBvY3RhbCwgdW5sZXNzIHRoZXJlIGlzIGEgbm9uLW9jdGFsIGRpZ2l0LlxyXG5cdCAgICAgICAgLy8gKEFubmV4IEIuMS4xIG9uIE51bWVyaWMgTGl0ZXJhbHMpXHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5pbmRleCArIDE7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2VbaV07XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAnOCcgfHwgY2ggPT09ICc5Jykge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbk51bWVyaWNMaXRlcmFsID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3N0YXJ0XTtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkgfHwgKGNoID09PSAnLicpLCAnTnVtZXJpYyBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIGRlY2ltYWwgZGlnaXQgb3IgYSBkZWNpbWFsIHBvaW50Jyk7XHJcblx0ICAgICAgICB2YXIgbnVtID0gJyc7XHJcblx0ICAgICAgICBpZiAoY2ggIT09ICcuJykge1xyXG5cdCAgICAgICAgICAgIG51bSA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgICAgICAvLyBIZXggbnVtYmVyIHN0YXJ0cyB3aXRoICcweCcuXHJcblx0ICAgICAgICAgICAgLy8gT2N0YWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJy5cclxuXHQgICAgICAgICAgICAvLyBPY3RhbCBudW1iZXIgaW4gRVM2IHN0YXJ0cyB3aXRoICcwbycuXHJcblx0ICAgICAgICAgICAgLy8gQmluYXJ5IG51bWJlciBpbiBFUzYgc3RhcnRzIHdpdGggJzBiJy5cclxuXHQgICAgICAgICAgICBpZiAobnVtID09PSAnMCcpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAneCcgfHwgY2ggPT09ICdYJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkhleExpdGVyYWwoc3RhcnQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ2InIHx8IGNoID09PSAnQicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5CaW5hcnlMaXRlcmFsKHN0YXJ0KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdvJyB8fCBjaCA9PT0gJ08nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuT2N0YWxMaXRlcmFsKGNoLCBzdGFydCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoICYmIGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW1wbGljaXRPY3RhbExpdGVyYWwoKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5PY3RhbExpdGVyYWwoY2gsIHN0YXJ0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB3aGlsZSAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNoID09PSAnLicpIHtcclxuXHQgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICB3aGlsZSAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xyXG5cdCAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAnKycgfHwgY2ggPT09ICctJykge1xyXG5cdCAgICAgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDYgLyogTnVtZXJpY0xpdGVyYWwgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQobnVtKSxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1saXRlcmFscy1zdHJpbmctbGl0ZXJhbHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblN0cmluZ0xpdGVyYWwgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIHF1b3RlID0gdGhpcy5zb3VyY2Vbc3RhcnRdO1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KChxdW90ZSA9PT0gJ1xcJycgfHwgcXVvdGUgPT09ICdcIicpLCAnU3RyaW5nIGxpdGVyYWwgbXVzdCBzdGFydHMgd2l0aCBhIHF1b3RlJyk7XHJcblx0ICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgb2N0YWwgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBzdHIgPSAnJztcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBxdW90ZSA9ICcnO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgICAgIGlmICghY2ggfHwgIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdGhpcy5zY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuZXNjYXBlZF8xID0gdGhpcy5zY2FuSGV4RXNjYXBlKGNoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmVzY2FwZWRfMSA9PT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSB1bmVzY2FwZWRfMTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd4JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuZXNjYXBlZCA9IHRoaXMuc2NhbkhleEVzY2FwZShjaCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmVzY2FwZWQgPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkSGV4RXNjYXBlU2VxdWVuY2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSB1bmVzY2FwZWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcbic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xccic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcdCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcYic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcZic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xceDBCJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnOCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnOSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggJiYgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9jdFRvRGVjID0gdGhpcy5vY3RhbFRvRGVjaW1hbChjaCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvY3RhbCA9IG9jdFRvRGVjLm9jdGFsIHx8IG9jdGFsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUob2N0VG9EZWMuY29kZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgdGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICdcXG4nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChxdW90ZSAhPT0gJycpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmluZGV4ID0gc3RhcnQ7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA4IC8qIFN0cmluZ0xpdGVyYWwgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHN0cixcclxuXHQgICAgICAgICAgICBvY3RhbDogb2N0YWwsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNvb2tlZCA9ICcnO1xyXG5cdCAgICAgICAgdmFyIHRlcm1pbmF0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgaGVhZCA9ICh0aGlzLnNvdXJjZVtzdGFydF0gPT09ICdgJyk7XHJcblx0ICAgICAgICB2YXIgdGFpbCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHJhd09mZnNldCA9IDI7XHJcblx0ICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJ2AnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJhd09mZnNldCA9IDE7XHJcblx0ICAgICAgICAgICAgICAgIHRhaWwgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnJCcpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VybHlTdGFjay5wdXNoKCckeycpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGVybWluYXRlZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxuJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxyJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFx0JztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gdGhpcy5zY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3RvcmUgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuZXNjYXBlZF8yID0gdGhpcy5zY2FuSGV4RXNjYXBlKGNoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmVzY2FwZWRfMiAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSB1bmVzY2FwZWRfMjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSByZXN0b3JlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd4JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuZXNjYXBlZCA9IHRoaXMuc2NhbkhleEVzY2FwZShjaCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmVzY2FwZWQgPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkSGV4RXNjYXBlU2VxdWVuY2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSB1bmVzY2FwZWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcYic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcZic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcdic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJzAnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbDogXFwwMSBcXDAyIGFuZCBzbyBvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5UZW1wbGF0ZU9jdGFsTGl0ZXJhbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcMCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbDogXFwxIFxcMlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLlRlbXBsYXRlT2N0YWxMaXRlcmFsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ1xcbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgdGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICdcXG4nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcbic7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCF0ZXJtaW5hdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCFoZWFkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5jdXJseVN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiAxMCAvKiBUZW1wbGF0ZSAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogdGhpcy5zb3VyY2Uuc2xpY2Uoc3RhcnQgKyAxLCB0aGlzLmluZGV4IC0gcmF3T2Zmc2V0KSxcclxuXHQgICAgICAgICAgICBjb29rZWQ6IGNvb2tlZCxcclxuXHQgICAgICAgICAgICBoZWFkOiBoZWFkLFxyXG5cdCAgICAgICAgICAgIHRhaWw6IHRhaWwsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGl0ZXJhbHMtcmVndWxhci1leHByZXNzaW9uLWxpdGVyYWxzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnRlc3RSZWdFeHAgPSBmdW5jdGlvbiAocGF0dGVybiwgZmxhZ3MpIHtcclxuXHQgICAgICAgIC8vIFRoZSBCTVAgY2hhcmFjdGVyIHRvIHVzZSBhcyBhIHJlcGxhY2VtZW50IGZvciBhc3RyYWwgc3ltYm9scyB3aGVuXHJcblx0ICAgICAgICAvLyB0cmFuc2xhdGluZyBhbiBFUzYgXCJ1XCItZmxhZ2dlZCBwYXR0ZXJuIHRvIGFuIEVTNS1jb21wYXRpYmxlXHJcblx0ICAgICAgICAvLyBhcHByb3hpbWF0aW9uLlxyXG5cdCAgICAgICAgLy8gTm90ZTogcmVwbGFjaW5nIHdpdGggJ1xcdUZGRkYnIGVuYWJsZXMgZmFsc2UgcG9zaXRpdmVzIGluIHVubGlrZWx5XHJcblx0ICAgICAgICAvLyBzY2VuYXJpb3MuIEZvciBleGFtcGxlLCBgW1xcdXsxMDQ0Zn0tXFx1ezEwNDQwfV1gIGlzIGFuIGludmFsaWRcclxuXHQgICAgICAgIC8vIHBhdHRlcm4gdGhhdCB3b3VsZCBub3QgYmUgZGV0ZWN0ZWQgYnkgdGhpcyBzdWJzdGl0dXRpb24uXHJcblx0ICAgICAgICB2YXIgYXN0cmFsU3Vic3RpdHV0ZSA9ICdcXHVGRkZGJztcclxuXHQgICAgICAgIHZhciB0bXAgPSBwYXR0ZXJuO1xyXG5cdCAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cdCAgICAgICAgaWYgKGZsYWdzLmluZGV4T2YoJ3UnKSA+PSAwKSB7XHJcblx0ICAgICAgICAgICAgdG1wID0gdG1wXHJcblx0ICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcdVxceyhbMC05YS1mQS1GXSspXFx9fFxcXFx1KFthLWZBLUYwLTldezR9KS9nLCBmdW5jdGlvbiAoJDAsICQxLCAkMikge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gcGFyc2VJbnQoJDEgfHwgJDIsIDE2KTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4MTBGRkZGKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzZWxmLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweEZGRkYpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFzdHJhbFN1YnN0aXR1dGU7XHJcblx0ICAgICAgICAgICAgfSlcclxuXHQgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZywgYXN0cmFsU3Vic3RpdHV0ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBGaXJzdCwgZGV0ZWN0IGludmFsaWQgcmVndWxhciBleHByZXNzaW9ucy5cclxuXHQgICAgICAgIHRyeSB7XHJcblx0ICAgICAgICAgICAgUmVnRXhwKHRtcCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBjYXRjaCAoZSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkUmVnRXhwKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFJldHVybiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QgZm9yIHRoaXMgcGF0dGVybi1mbGFnIHBhaXIsIG9yXHJcblx0ICAgICAgICAvLyBgbnVsbGAgaW4gY2FzZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IHN1cHBvcnQgdGhlIGZsYWdzIGl0XHJcblx0ICAgICAgICAvLyB1c2VzLlxyXG5cdCAgICAgICAgdHJ5IHtcclxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBjYXRjaCAoZXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblJlZ0V4cEJvZHkgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydChjaCA9PT0gJy8nLCAnUmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgc2xhc2gnKTtcclxuXHQgICAgICAgIHZhciBzdHIgPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgdmFyIGNsYXNzTWFya2VyID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgdGVybWluYXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxpdGVyYWxzLXJlZ3VsYXItZXhwcmVzc2lvbi1saXRlcmFsc1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNsYXNzTWFya2VyKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjbGFzc01hcmtlciA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcvJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGVybWluYXRlZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjbGFzc01hcmtlciA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIEV4Y2x1ZGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2guXHJcblx0ICAgICAgICByZXR1cm4gc3RyLnN1YnN0cigxLCBzdHIubGVuZ3RoIC0gMik7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5SZWdFeHBGbGFncyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdHIgPSAnJztcclxuXHQgICAgICAgIHZhciBmbGFncyA9ICcnO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyUGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnICYmICF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdG9yZSA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2hhciA9IHRoaXMuc2NhbkhleEVzY2FwZSgndScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXIgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmbGFncyArPSBjaGFyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoc3RyICs9ICdcXFxcdSc7IHJlc3RvcmUgPCB0aGlzLmluZGV4OyArK3Jlc3RvcmUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHRoaXMuc291cmNlW3Jlc3RvcmVdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSByZXN0b3JlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICs9ICd1JztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFx1JztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGZsYWdzICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGZsYWdzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuUmVnRXhwID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgIHZhciBwYXR0ZXJuID0gdGhpcy5zY2FuUmVnRXhwQm9keSgpO1xyXG5cdCAgICAgICAgdmFyIGZsYWdzID0gdGhpcy5zY2FuUmVnRXhwRmxhZ3MoKTtcclxuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudGVzdFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDkgLyogUmVndWxhckV4cHJlc3Npb24gKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6ICcnLFxyXG5cdCAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4sXHJcblx0ICAgICAgICAgICAgZmxhZ3M6IGZsYWdzLFxyXG5cdCAgICAgICAgICAgIHJlZ2V4OiB2YWx1ZSxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5sZXggPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IDIgLyogRU9GICovLFxyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogJycsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuaW5kZXgsXHJcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgY3AgPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydChjcCkpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gVmVyeSBjb21tb246ICggYW5kICkgYW5kIDtcclxuXHQgICAgICAgIGlmIChjcCA9PT0gMHgyOCB8fCBjcCA9PT0gMHgyOSB8fCBjcCA9PT0gMHgzQikge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5QdW5jdHVhdG9yKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBTdHJpbmcgbGl0ZXJhbCBzdGFydHMgd2l0aCBzaW5nbGUgcXVvdGUgKFUrMDAyNykgb3IgZG91YmxlIHF1b3RlIChVKzAwMjIpLlxyXG5cdCAgICAgICAgaWYgKGNwID09PSAweDI3IHx8IGNwID09PSAweDIyKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblN0cmluZ0xpdGVyYWwoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIERvdCAoLikgVSswMDJFIGNhbiBhbHNvIHN0YXJ0IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLCBoZW5jZSB0aGUgbmVlZFxyXG5cdCAgICAgICAgLy8gdG8gY2hlY2sgdGhlIG5leHQgY2hhcmFjdGVyLlxyXG5cdCAgICAgICAgaWYgKGNwID09PSAweDJFKSB7XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAxKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk51bWVyaWNMaXRlcmFsKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5QdW5jdHVhdG9yKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KGNwKSkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5OdW1lcmljTGl0ZXJhbCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gVGVtcGxhdGUgbGl0ZXJhbHMgc3RhcnQgd2l0aCBgIChVKzAwNjApIGZvciB0ZW1wbGF0ZSBoZWFkXHJcblx0ICAgICAgICAvLyBvciB9IChVKzAwN0QpIGZvciB0ZW1wbGF0ZSBtaWRkbGUgb3IgdGVtcGxhdGUgdGFpbC5cclxuXHQgICAgICAgIGlmIChjcCA9PT0gMHg2MCB8fCAoY3AgPT09IDB4N0QgJiYgdGhpcy5jdXJseVN0YWNrW3RoaXMuY3VybHlTdGFjay5sZW5ndGggLSAxXSA9PT0gJyR7JykpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuVGVtcGxhdGUoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFBvc3NpYmxlIGlkZW50aWZpZXIgc3RhcnQgaW4gYSBzdXJyb2dhdGUgcGFpci5cclxuXHQgICAgICAgIGlmIChjcCA+PSAweEQ4MDAgJiYgY3AgPCAweERGRkYpIHtcclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KHRoaXMuY29kZVBvaW50QXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5JZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2NhblB1bmN0dWF0b3IoKTtcclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIFNjYW5uZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlNjYW5uZXIgPSBTY2FubmVyO1xyXG5cblxuLyoqKi8gfSxcbi8qIDEzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWUgPSB7fTtcclxuXHRleHBvcnRzLlRva2VuTmFtZVsxIC8qIEJvb2xlYW5MaXRlcmFsICovXSA9ICdCb29sZWFuJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVsyIC8qIEVPRiAqL10gPSAnPGVuZD4nO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzMgLyogSWRlbnRpZmllciAqL10gPSAnSWRlbnRpZmllcic7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbNCAvKiBLZXl3b3JkICovXSA9ICdLZXl3b3JkJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVs1IC8qIE51bGxMaXRlcmFsICovXSA9ICdOdWxsJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVs2IC8qIE51bWVyaWNMaXRlcmFsICovXSA9ICdOdW1lcmljJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVs3IC8qIFB1bmN0dWF0b3IgKi9dID0gJ1B1bmN0dWF0b3InO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzggLyogU3RyaW5nTGl0ZXJhbCAqL10gPSAnU3RyaW5nJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVs5IC8qIFJlZ3VsYXJFeHByZXNzaW9uICovXSA9ICdSZWd1bGFyRXhwcmVzc2lvbic7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbMTAgLyogVGVtcGxhdGUgKi9dID0gJ1RlbXBsYXRlJztcclxuXG5cbi8qKiovIH0sXG4vKiAxNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0Ly8gR2VuZXJhdGVkIGJ5IGdlbmVyYXRlLXhodG1sLWVudGl0aWVzLmpzLiBETyBOT1QgTU9ESUZZIVxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHRleHBvcnRzLlhIVE1MRW50aXRpZXMgPSB7XHJcblx0ICAgIHF1b3Q6ICdcXHUwMDIyJyxcclxuXHQgICAgYW1wOiAnXFx1MDAyNicsXHJcblx0ICAgIGFwb3M6ICdcXHUwMDI3JyxcclxuXHQgICAgZ3Q6ICdcXHUwMDNFJyxcclxuXHQgICAgbmJzcDogJ1xcdTAwQTAnLFxyXG5cdCAgICBpZXhjbDogJ1xcdTAwQTEnLFxyXG5cdCAgICBjZW50OiAnXFx1MDBBMicsXHJcblx0ICAgIHBvdW5kOiAnXFx1MDBBMycsXHJcblx0ICAgIGN1cnJlbjogJ1xcdTAwQTQnLFxyXG5cdCAgICB5ZW46ICdcXHUwMEE1JyxcclxuXHQgICAgYnJ2YmFyOiAnXFx1MDBBNicsXHJcblx0ICAgIHNlY3Q6ICdcXHUwMEE3JyxcclxuXHQgICAgdW1sOiAnXFx1MDBBOCcsXHJcblx0ICAgIGNvcHk6ICdcXHUwMEE5JyxcclxuXHQgICAgb3JkZjogJ1xcdTAwQUEnLFxyXG5cdCAgICBsYXF1bzogJ1xcdTAwQUInLFxyXG5cdCAgICBub3Q6ICdcXHUwMEFDJyxcclxuXHQgICAgc2h5OiAnXFx1MDBBRCcsXHJcblx0ICAgIHJlZzogJ1xcdTAwQUUnLFxyXG5cdCAgICBtYWNyOiAnXFx1MDBBRicsXHJcblx0ICAgIGRlZzogJ1xcdTAwQjAnLFxyXG5cdCAgICBwbHVzbW46ICdcXHUwMEIxJyxcclxuXHQgICAgc3VwMjogJ1xcdTAwQjInLFxyXG5cdCAgICBzdXAzOiAnXFx1MDBCMycsXHJcblx0ICAgIGFjdXRlOiAnXFx1MDBCNCcsXHJcblx0ICAgIG1pY3JvOiAnXFx1MDBCNScsXHJcblx0ICAgIHBhcmE6ICdcXHUwMEI2JyxcclxuXHQgICAgbWlkZG90OiAnXFx1MDBCNycsXHJcblx0ICAgIGNlZGlsOiAnXFx1MDBCOCcsXHJcblx0ICAgIHN1cDE6ICdcXHUwMEI5JyxcclxuXHQgICAgb3JkbTogJ1xcdTAwQkEnLFxyXG5cdCAgICByYXF1bzogJ1xcdTAwQkInLFxyXG5cdCAgICBmcmFjMTQ6ICdcXHUwMEJDJyxcclxuXHQgICAgZnJhYzEyOiAnXFx1MDBCRCcsXHJcblx0ICAgIGZyYWMzNDogJ1xcdTAwQkUnLFxyXG5cdCAgICBpcXVlc3Q6ICdcXHUwMEJGJyxcclxuXHQgICAgQWdyYXZlOiAnXFx1MDBDMCcsXHJcblx0ICAgIEFhY3V0ZTogJ1xcdTAwQzEnLFxyXG5cdCAgICBBY2lyYzogJ1xcdTAwQzInLFxyXG5cdCAgICBBdGlsZGU6ICdcXHUwMEMzJyxcclxuXHQgICAgQXVtbDogJ1xcdTAwQzQnLFxyXG5cdCAgICBBcmluZzogJ1xcdTAwQzUnLFxyXG5cdCAgICBBRWxpZzogJ1xcdTAwQzYnLFxyXG5cdCAgICBDY2VkaWw6ICdcXHUwMEM3JyxcclxuXHQgICAgRWdyYXZlOiAnXFx1MDBDOCcsXHJcblx0ICAgIEVhY3V0ZTogJ1xcdTAwQzknLFxyXG5cdCAgICBFY2lyYzogJ1xcdTAwQ0EnLFxyXG5cdCAgICBFdW1sOiAnXFx1MDBDQicsXHJcblx0ICAgIElncmF2ZTogJ1xcdTAwQ0MnLFxyXG5cdCAgICBJYWN1dGU6ICdcXHUwMENEJyxcclxuXHQgICAgSWNpcmM6ICdcXHUwMENFJyxcclxuXHQgICAgSXVtbDogJ1xcdTAwQ0YnLFxyXG5cdCAgICBFVEg6ICdcXHUwMEQwJyxcclxuXHQgICAgTnRpbGRlOiAnXFx1MDBEMScsXHJcblx0ICAgIE9ncmF2ZTogJ1xcdTAwRDInLFxyXG5cdCAgICBPYWN1dGU6ICdcXHUwMEQzJyxcclxuXHQgICAgT2NpcmM6ICdcXHUwMEQ0JyxcclxuXHQgICAgT3RpbGRlOiAnXFx1MDBENScsXHJcblx0ICAgIE91bWw6ICdcXHUwMEQ2JyxcclxuXHQgICAgdGltZXM6ICdcXHUwMEQ3JyxcclxuXHQgICAgT3NsYXNoOiAnXFx1MDBEOCcsXHJcblx0ICAgIFVncmF2ZTogJ1xcdTAwRDknLFxyXG5cdCAgICBVYWN1dGU6ICdcXHUwMERBJyxcclxuXHQgICAgVWNpcmM6ICdcXHUwMERCJyxcclxuXHQgICAgVXVtbDogJ1xcdTAwREMnLFxyXG5cdCAgICBZYWN1dGU6ICdcXHUwMEREJyxcclxuXHQgICAgVEhPUk46ICdcXHUwMERFJyxcclxuXHQgICAgc3psaWc6ICdcXHUwMERGJyxcclxuXHQgICAgYWdyYXZlOiAnXFx1MDBFMCcsXHJcblx0ICAgIGFhY3V0ZTogJ1xcdTAwRTEnLFxyXG5cdCAgICBhY2lyYzogJ1xcdTAwRTInLFxyXG5cdCAgICBhdGlsZGU6ICdcXHUwMEUzJyxcclxuXHQgICAgYXVtbDogJ1xcdTAwRTQnLFxyXG5cdCAgICBhcmluZzogJ1xcdTAwRTUnLFxyXG5cdCAgICBhZWxpZzogJ1xcdTAwRTYnLFxyXG5cdCAgICBjY2VkaWw6ICdcXHUwMEU3JyxcclxuXHQgICAgZWdyYXZlOiAnXFx1MDBFOCcsXHJcblx0ICAgIGVhY3V0ZTogJ1xcdTAwRTknLFxyXG5cdCAgICBlY2lyYzogJ1xcdTAwRUEnLFxyXG5cdCAgICBldW1sOiAnXFx1MDBFQicsXHJcblx0ICAgIGlncmF2ZTogJ1xcdTAwRUMnLFxyXG5cdCAgICBpYWN1dGU6ICdcXHUwMEVEJyxcclxuXHQgICAgaWNpcmM6ICdcXHUwMEVFJyxcclxuXHQgICAgaXVtbDogJ1xcdTAwRUYnLFxyXG5cdCAgICBldGg6ICdcXHUwMEYwJyxcclxuXHQgICAgbnRpbGRlOiAnXFx1MDBGMScsXHJcblx0ICAgIG9ncmF2ZTogJ1xcdTAwRjInLFxyXG5cdCAgICBvYWN1dGU6ICdcXHUwMEYzJyxcclxuXHQgICAgb2NpcmM6ICdcXHUwMEY0JyxcclxuXHQgICAgb3RpbGRlOiAnXFx1MDBGNScsXHJcblx0ICAgIG91bWw6ICdcXHUwMEY2JyxcclxuXHQgICAgZGl2aWRlOiAnXFx1MDBGNycsXHJcblx0ICAgIG9zbGFzaDogJ1xcdTAwRjgnLFxyXG5cdCAgICB1Z3JhdmU6ICdcXHUwMEY5JyxcclxuXHQgICAgdWFjdXRlOiAnXFx1MDBGQScsXHJcblx0ICAgIHVjaXJjOiAnXFx1MDBGQicsXHJcblx0ICAgIHV1bWw6ICdcXHUwMEZDJyxcclxuXHQgICAgeWFjdXRlOiAnXFx1MDBGRCcsXHJcblx0ICAgIHRob3JuOiAnXFx1MDBGRScsXHJcblx0ICAgIHl1bWw6ICdcXHUwMEZGJyxcclxuXHQgICAgT0VsaWc6ICdcXHUwMTUyJyxcclxuXHQgICAgb2VsaWc6ICdcXHUwMTUzJyxcclxuXHQgICAgU2Nhcm9uOiAnXFx1MDE2MCcsXHJcblx0ICAgIHNjYXJvbjogJ1xcdTAxNjEnLFxyXG5cdCAgICBZdW1sOiAnXFx1MDE3OCcsXHJcblx0ICAgIGZub2Y6ICdcXHUwMTkyJyxcclxuXHQgICAgY2lyYzogJ1xcdTAyQzYnLFxyXG5cdCAgICB0aWxkZTogJ1xcdTAyREMnLFxyXG5cdCAgICBBbHBoYTogJ1xcdTAzOTEnLFxyXG5cdCAgICBCZXRhOiAnXFx1MDM5MicsXHJcblx0ICAgIEdhbW1hOiAnXFx1MDM5MycsXHJcblx0ICAgIERlbHRhOiAnXFx1MDM5NCcsXHJcblx0ICAgIEVwc2lsb246ICdcXHUwMzk1JyxcclxuXHQgICAgWmV0YTogJ1xcdTAzOTYnLFxyXG5cdCAgICBFdGE6ICdcXHUwMzk3JyxcclxuXHQgICAgVGhldGE6ICdcXHUwMzk4JyxcclxuXHQgICAgSW90YTogJ1xcdTAzOTknLFxyXG5cdCAgICBLYXBwYTogJ1xcdTAzOUEnLFxyXG5cdCAgICBMYW1iZGE6ICdcXHUwMzlCJyxcclxuXHQgICAgTXU6ICdcXHUwMzlDJyxcclxuXHQgICAgTnU6ICdcXHUwMzlEJyxcclxuXHQgICAgWGk6ICdcXHUwMzlFJyxcclxuXHQgICAgT21pY3JvbjogJ1xcdTAzOUYnLFxyXG5cdCAgICBQaTogJ1xcdTAzQTAnLFxyXG5cdCAgICBSaG86ICdcXHUwM0ExJyxcclxuXHQgICAgU2lnbWE6ICdcXHUwM0EzJyxcclxuXHQgICAgVGF1OiAnXFx1MDNBNCcsXHJcblx0ICAgIFVwc2lsb246ICdcXHUwM0E1JyxcclxuXHQgICAgUGhpOiAnXFx1MDNBNicsXHJcblx0ICAgIENoaTogJ1xcdTAzQTcnLFxyXG5cdCAgICBQc2k6ICdcXHUwM0E4JyxcclxuXHQgICAgT21lZ2E6ICdcXHUwM0E5JyxcclxuXHQgICAgYWxwaGE6ICdcXHUwM0IxJyxcclxuXHQgICAgYmV0YTogJ1xcdTAzQjInLFxyXG5cdCAgICBnYW1tYTogJ1xcdTAzQjMnLFxyXG5cdCAgICBkZWx0YTogJ1xcdTAzQjQnLFxyXG5cdCAgICBlcHNpbG9uOiAnXFx1MDNCNScsXHJcblx0ICAgIHpldGE6ICdcXHUwM0I2JyxcclxuXHQgICAgZXRhOiAnXFx1MDNCNycsXHJcblx0ICAgIHRoZXRhOiAnXFx1MDNCOCcsXHJcblx0ICAgIGlvdGE6ICdcXHUwM0I5JyxcclxuXHQgICAga2FwcGE6ICdcXHUwM0JBJyxcclxuXHQgICAgbGFtYmRhOiAnXFx1MDNCQicsXHJcblx0ICAgIG11OiAnXFx1MDNCQycsXHJcblx0ICAgIG51OiAnXFx1MDNCRCcsXHJcblx0ICAgIHhpOiAnXFx1MDNCRScsXHJcblx0ICAgIG9taWNyb246ICdcXHUwM0JGJyxcclxuXHQgICAgcGk6ICdcXHUwM0MwJyxcclxuXHQgICAgcmhvOiAnXFx1MDNDMScsXHJcblx0ICAgIHNpZ21hZjogJ1xcdTAzQzInLFxyXG5cdCAgICBzaWdtYTogJ1xcdTAzQzMnLFxyXG5cdCAgICB0YXU6ICdcXHUwM0M0JyxcclxuXHQgICAgdXBzaWxvbjogJ1xcdTAzQzUnLFxyXG5cdCAgICBwaGk6ICdcXHUwM0M2JyxcclxuXHQgICAgY2hpOiAnXFx1MDNDNycsXHJcblx0ICAgIHBzaTogJ1xcdTAzQzgnLFxyXG5cdCAgICBvbWVnYTogJ1xcdTAzQzknLFxyXG5cdCAgICB0aGV0YXN5bTogJ1xcdTAzRDEnLFxyXG5cdCAgICB1cHNpaDogJ1xcdTAzRDInLFxyXG5cdCAgICBwaXY6ICdcXHUwM0Q2JyxcclxuXHQgICAgZW5zcDogJ1xcdTIwMDInLFxyXG5cdCAgICBlbXNwOiAnXFx1MjAwMycsXHJcblx0ICAgIHRoaW5zcDogJ1xcdTIwMDknLFxyXG5cdCAgICB6d25qOiAnXFx1MjAwQycsXHJcblx0ICAgIHp3ajogJ1xcdTIwMEQnLFxyXG5cdCAgICBscm06ICdcXHUyMDBFJyxcclxuXHQgICAgcmxtOiAnXFx1MjAwRicsXHJcblx0ICAgIG5kYXNoOiAnXFx1MjAxMycsXHJcblx0ICAgIG1kYXNoOiAnXFx1MjAxNCcsXHJcblx0ICAgIGxzcXVvOiAnXFx1MjAxOCcsXHJcblx0ICAgIHJzcXVvOiAnXFx1MjAxOScsXHJcblx0ICAgIHNicXVvOiAnXFx1MjAxQScsXHJcblx0ICAgIGxkcXVvOiAnXFx1MjAxQycsXHJcblx0ICAgIHJkcXVvOiAnXFx1MjAxRCcsXHJcblx0ICAgIGJkcXVvOiAnXFx1MjAxRScsXHJcblx0ICAgIGRhZ2dlcjogJ1xcdTIwMjAnLFxyXG5cdCAgICBEYWdnZXI6ICdcXHUyMDIxJyxcclxuXHQgICAgYnVsbDogJ1xcdTIwMjInLFxyXG5cdCAgICBoZWxsaXA6ICdcXHUyMDI2JyxcclxuXHQgICAgcGVybWlsOiAnXFx1MjAzMCcsXHJcblx0ICAgIHByaW1lOiAnXFx1MjAzMicsXHJcblx0ICAgIFByaW1lOiAnXFx1MjAzMycsXHJcblx0ICAgIGxzYXF1bzogJ1xcdTIwMzknLFxyXG5cdCAgICByc2FxdW86ICdcXHUyMDNBJyxcclxuXHQgICAgb2xpbmU6ICdcXHUyMDNFJyxcclxuXHQgICAgZnJhc2w6ICdcXHUyMDQ0JyxcclxuXHQgICAgZXVybzogJ1xcdTIwQUMnLFxyXG5cdCAgICBpbWFnZTogJ1xcdTIxMTEnLFxyXG5cdCAgICB3ZWllcnA6ICdcXHUyMTE4JyxcclxuXHQgICAgcmVhbDogJ1xcdTIxMUMnLFxyXG5cdCAgICB0cmFkZTogJ1xcdTIxMjInLFxyXG5cdCAgICBhbGVmc3ltOiAnXFx1MjEzNScsXHJcblx0ICAgIGxhcnI6ICdcXHUyMTkwJyxcclxuXHQgICAgdWFycjogJ1xcdTIxOTEnLFxyXG5cdCAgICByYXJyOiAnXFx1MjE5MicsXHJcblx0ICAgIGRhcnI6ICdcXHUyMTkzJyxcclxuXHQgICAgaGFycjogJ1xcdTIxOTQnLFxyXG5cdCAgICBjcmFycjogJ1xcdTIxQjUnLFxyXG5cdCAgICBsQXJyOiAnXFx1MjFEMCcsXHJcblx0ICAgIHVBcnI6ICdcXHUyMUQxJyxcclxuXHQgICAgckFycjogJ1xcdTIxRDInLFxyXG5cdCAgICBkQXJyOiAnXFx1MjFEMycsXHJcblx0ICAgIGhBcnI6ICdcXHUyMUQ0JyxcclxuXHQgICAgZm9yYWxsOiAnXFx1MjIwMCcsXHJcblx0ICAgIHBhcnQ6ICdcXHUyMjAyJyxcclxuXHQgICAgZXhpc3Q6ICdcXHUyMjAzJyxcclxuXHQgICAgZW1wdHk6ICdcXHUyMjA1JyxcclxuXHQgICAgbmFibGE6ICdcXHUyMjA3JyxcclxuXHQgICAgaXNpbjogJ1xcdTIyMDgnLFxyXG5cdCAgICBub3RpbjogJ1xcdTIyMDknLFxyXG5cdCAgICBuaTogJ1xcdTIyMEInLFxyXG5cdCAgICBwcm9kOiAnXFx1MjIwRicsXHJcblx0ICAgIHN1bTogJ1xcdTIyMTEnLFxyXG5cdCAgICBtaW51czogJ1xcdTIyMTInLFxyXG5cdCAgICBsb3dhc3Q6ICdcXHUyMjE3JyxcclxuXHQgICAgcmFkaWM6ICdcXHUyMjFBJyxcclxuXHQgICAgcHJvcDogJ1xcdTIyMUQnLFxyXG5cdCAgICBpbmZpbjogJ1xcdTIyMUUnLFxyXG5cdCAgICBhbmc6ICdcXHUyMjIwJyxcclxuXHQgICAgYW5kOiAnXFx1MjIyNycsXHJcblx0ICAgIG9yOiAnXFx1MjIyOCcsXHJcblx0ICAgIGNhcDogJ1xcdTIyMjknLFxyXG5cdCAgICBjdXA6ICdcXHUyMjJBJyxcclxuXHQgICAgaW50OiAnXFx1MjIyQicsXHJcblx0ICAgIHRoZXJlNDogJ1xcdTIyMzQnLFxyXG5cdCAgICBzaW06ICdcXHUyMjNDJyxcclxuXHQgICAgY29uZzogJ1xcdTIyNDUnLFxyXG5cdCAgICBhc3ltcDogJ1xcdTIyNDgnLFxyXG5cdCAgICBuZTogJ1xcdTIyNjAnLFxyXG5cdCAgICBlcXVpdjogJ1xcdTIyNjEnLFxyXG5cdCAgICBsZTogJ1xcdTIyNjQnLFxyXG5cdCAgICBnZTogJ1xcdTIyNjUnLFxyXG5cdCAgICBzdWI6ICdcXHUyMjgyJyxcclxuXHQgICAgc3VwOiAnXFx1MjI4MycsXHJcblx0ICAgIG5zdWI6ICdcXHUyMjg0JyxcclxuXHQgICAgc3ViZTogJ1xcdTIyODYnLFxyXG5cdCAgICBzdXBlOiAnXFx1MjI4NycsXHJcblx0ICAgIG9wbHVzOiAnXFx1MjI5NScsXHJcblx0ICAgIG90aW1lczogJ1xcdTIyOTcnLFxyXG5cdCAgICBwZXJwOiAnXFx1MjJBNScsXHJcblx0ICAgIHNkb3Q6ICdcXHUyMkM1JyxcclxuXHQgICAgbGNlaWw6ICdcXHUyMzA4JyxcclxuXHQgICAgcmNlaWw6ICdcXHUyMzA5JyxcclxuXHQgICAgbGZsb29yOiAnXFx1MjMwQScsXHJcblx0ICAgIHJmbG9vcjogJ1xcdTIzMEInLFxyXG5cdCAgICBsb3o6ICdcXHUyNUNBJyxcclxuXHQgICAgc3BhZGVzOiAnXFx1MjY2MCcsXHJcblx0ICAgIGNsdWJzOiAnXFx1MjY2MycsXHJcblx0ICAgIGhlYXJ0czogJ1xcdTI2NjUnLFxyXG5cdCAgICBkaWFtczogJ1xcdTI2NjYnLFxyXG5cdCAgICBsYW5nOiAnXFx1MjdFOCcsXHJcblx0ICAgIHJhbmc6ICdcXHUyN0U5J1xyXG5cdH07XHJcblxuXG4vKioqLyB9LFxuLyogMTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgZXJyb3JfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcblx0dmFyIHNjYW5uZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG5cdHZhciB0b2tlbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcblx0dmFyIFJlYWRlciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFJlYWRlcigpIHtcclxuXHQgICAgICAgIHRoaXMudmFsdWVzID0gW107XHJcblx0ICAgICAgICB0aGlzLmN1cmx5ID0gdGhpcy5wYXJlbiA9IC0xO1xyXG5cdCAgICB9XHJcblx0ICAgIC8vIEEgZnVuY3Rpb24gZm9sbG93aW5nIG9uZSBvZiB0aG9zZSB0b2tlbnMgaXMgYW4gZXhwcmVzc2lvbi5cclxuXHQgICAgUmVhZGVyLnByb3RvdHlwZS5iZWZvcmVGdW5jdGlvbkV4cHJlc3Npb24gPSBmdW5jdGlvbiAodCkge1xyXG5cdCAgICAgICAgcmV0dXJuIFsnKCcsICd7JywgJ1snLCAnaW4nLCAndHlwZW9mJywgJ2luc3RhbmNlb2YnLCAnbmV3JyxcclxuXHQgICAgICAgICAgICAncmV0dXJuJywgJ2Nhc2UnLCAnZGVsZXRlJywgJ3Rocm93JywgJ3ZvaWQnLFxyXG5cdCAgICAgICAgICAgIC8vIGFzc2lnbm1lbnQgb3BlcmF0b3JzXHJcblx0ICAgICAgICAgICAgJz0nLCAnKz0nLCAnLT0nLCAnKj0nLCAnKio9JywgJy89JywgJyU9JywgJzw8PScsICc+Pj0nLCAnPj4+PScsXHJcblx0ICAgICAgICAgICAgJyY9JywgJ3w9JywgJ149JywgJywnLFxyXG5cdCAgICAgICAgICAgIC8vIGJpbmFyeS91bmFyeSBvcGVyYXRvcnNcclxuXHQgICAgICAgICAgICAnKycsICctJywgJyonLCAnKionLCAnLycsICclJywgJysrJywgJy0tJywgJzw8JywgJz4+JywgJz4+PicsICcmJyxcclxuXHQgICAgICAgICAgICAnfCcsICdeJywgJyEnLCAnficsICcmJicsICd8fCcsICc/JywgJzonLCAnPT09JywgJz09JywgJz49JyxcclxuXHQgICAgICAgICAgICAnPD0nLCAnPCcsICc+JywgJyE9JywgJyE9PSddLmluZGV4T2YodCkgPj0gMDtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gRGV0ZXJtaW5lIGlmIGZvcndhcmQgc2xhc2ggKC8pIGlzIGFuIG9wZXJhdG9yIG9yIHBhcnQgb2YgYSByZWd1bGFyIGV4cHJlc3Npb25cclxuXHQgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc3dlZXQuanMvd2lraS9kZXNpZ25cclxuXHQgICAgUmVhZGVyLnByb3RvdHlwZS5pc1JlZ2V4U3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLnZhbHVlc1t0aGlzLnZhbHVlcy5sZW5ndGggLSAxXTtcclxuXHQgICAgICAgIHZhciByZWdleCA9IChwcmV2aW91cyAhPT0gbnVsbCk7XHJcblx0ICAgICAgICBzd2l0Y2ggKHByZXZpb3VzKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAndGhpcyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnXSc6XHJcblx0ICAgICAgICAgICAgICAgIHJlZ2V4ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgJyknOlxyXG5cdCAgICAgICAgICAgICAgICB2YXIga2V5d29yZCA9IHRoaXMudmFsdWVzW3RoaXMucGFyZW4gLSAxXTtcclxuXHQgICAgICAgICAgICAgICAgcmVnZXggPSAoa2V5d29yZCA9PT0gJ2lmJyB8fCBrZXl3b3JkID09PSAnd2hpbGUnIHx8IGtleXdvcmQgPT09ICdmb3InIHx8IGtleXdvcmQgPT09ICd3aXRoJyk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgJ30nOlxyXG5cdCAgICAgICAgICAgICAgICAvLyBEaXZpZGluZyBhIGZ1bmN0aW9uIGJ5IGFueXRoaW5nIG1ha2VzIGxpdHRsZSBzZW5zZSxcclxuXHQgICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgdG8gY2hlY2sgZm9yIHRoYXQuXHJcblx0ICAgICAgICAgICAgICAgIHJlZ2V4ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlc1t0aGlzLmN1cmx5IC0gM10gPT09ICdmdW5jdGlvbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEFub255bW91cyBmdW5jdGlvbiwgZS5nLiBmdW5jdGlvbigpe30gLzQyXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2sgPSB0aGlzLnZhbHVlc1t0aGlzLmN1cmx5IC0gNF07XHJcblx0ICAgICAgICAgICAgICAgICAgICByZWdleCA9IGNoZWNrID8gIXRoaXMuYmVmb3JlRnVuY3Rpb25FeHByZXNzaW9uKGNoZWNrKSA6IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudmFsdWVzW3RoaXMuY3VybHkgLSA0XSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gTmFtZWQgZnVuY3Rpb24sIGUuZy4gZnVuY3Rpb24gZigpe30gLzQyL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoZWNrID0gdGhpcy52YWx1ZXNbdGhpcy5jdXJseSAtIDVdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmVnZXggPSBjaGVjayA/ICF0aGlzLmJlZm9yZUZ1bmN0aW9uRXhwcmVzc2lvbihjaGVjaykgOiB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHJlZ2V4O1xyXG5cdCAgICB9O1xyXG5cdCAgICBSZWFkZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gfHwgdG9rZW4udHlwZSA9PT0gNCAvKiBLZXl3b3JkICovKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jdXJseSA9IHRoaXMudmFsdWVzLmxlbmd0aDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICcoJykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnBhcmVuID0gdGhpcy52YWx1ZXMubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHRva2VuLnZhbHVlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmFsdWVzLnB1c2gobnVsbCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBSZWFkZXI7XHJcblx0fSgpKTtcclxuXHR2YXIgVG9rZW5pemVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVG9rZW5pemVyKGNvZGUsIGNvbmZpZykge1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBuZXcgZXJyb3JfaGFuZGxlcl8xLkVycm9ySGFuZGxlcigpO1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIudG9sZXJhbnQgPSBjb25maWcgPyAodHlwZW9mIGNvbmZpZy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIGNvbmZpZy50b2xlcmFudCkgOiBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lciA9IG5ldyBzY2FubmVyXzEuU2Nhbm5lcihjb2RlLCB0aGlzLmVycm9ySGFuZGxlcik7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIudHJhY2tDb21tZW50ID0gY29uZmlnID8gKHR5cGVvZiBjb25maWcuY29tbWVudCA9PT0gJ2Jvb2xlYW4nICYmIGNvbmZpZy5jb21tZW50KSA6IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy50cmFja1JhbmdlID0gY29uZmlnID8gKHR5cGVvZiBjb25maWcucmFuZ2UgPT09ICdib29sZWFuJyAmJiBjb25maWcucmFuZ2UpIDogZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLnRyYWNrTG9jID0gY29uZmlnID8gKHR5cGVvZiBjb25maWcubG9jID09PSAnYm9vbGVhbicgJiYgY29uZmlnLmxvYykgOiBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuYnVmZmVyID0gW107XHJcblx0ICAgICAgICB0aGlzLnJlYWRlciA9IG5ldyBSZWFkZXIoKTtcclxuXHQgICAgfVxyXG5cdCAgICBUb2tlbml6ZXIucHJvdG90eXBlLmVycm9ycyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmVycm9ySGFuZGxlci5lcnJvcnM7XHJcblx0ICAgIH07XHJcblx0ICAgIFRva2VuaXplci5wcm90b3R5cGUuZ2V0TmV4dFRva2VuID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgIHZhciBjb21tZW50cyA9IHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1lbnRzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGNvbW1lbnRzW2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5zY2FubmVyLnNvdXJjZS5zbGljZShlLnNsaWNlWzBdLCBlLnNsaWNlWzFdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGUubXVsdGlMaW5lID8gJ0Jsb2NrQ29tbWVudCcgOiAnTGluZUNvbW1lbnQnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrUmFuZ2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50LnJhbmdlID0gZS5yYW5nZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrTG9jKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudC5sb2MgPSBlLmxvYztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2goY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLnNjYW5uZXIuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGxvYyA9IHZvaWQgMDtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tMb2MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxvYyA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHt9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHZhciBzdGFydFJlZ2V4ID0gKHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4XSA9PT0gJy8nKSAmJiB0aGlzLnJlYWRlci5pc1JlZ2V4U3RhcnQoKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHRva2VuID0gc3RhcnRSZWdleCA/IHRoaXMuc2Nhbm5lci5zY2FuUmVnRXhwKCkgOiB0aGlzLnNjYW5uZXIubGV4KCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVhZGVyLnB1c2godG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b2tlbl8xLlRva2VuTmFtZVt0b2tlbi50eXBlXSxcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNjYW5uZXIuc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpXHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrUmFuZ2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVudHJ5LnJhbmdlID0gW3Rva2VuLnN0YXJ0LCB0b2tlbi5lbmRdO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrTG9jKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsb2MuZW5kID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVudHJ5LmxvYyA9IGxvYztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gOSAvKiBSZWd1bGFyRXhwcmVzc2lvbiAqLykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSB0b2tlbi5wYXR0ZXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZsYWdzID0gdG9rZW4uZmxhZ3M7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbnRyeS5yZWdleCA9IHsgcGF0dGVybjogcGF0dGVybiwgZmxhZ3M6IGZsYWdzIH07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNoaWZ0KCk7XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBUb2tlbml6ZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRva2VuaXplciA9IFRva2VuaXplcjtcclxuXG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjsiLCIndXNlIHN0cmljdCdcbnZhciByZWFkb25seVByb3hpZXMgPSBuZXcgV2Vha01hcFxudmFyIGN1cnJlbnRTYW5kYm94ID0gdW5kZWZpbmVkXG52YXIgR0xPQkFMID0gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKClcbnZhciB1bnNjb3BhYmxlc1N5bWJvbCA9IFN5bWJvbC51bnNjb3BhYmxlc1xudmFyIEZ1bmN0aW9uQ29uc3RydWN0b3IgPSAwLi5jb25zdHJ1Y3Rvci5jb25zdHJ1Y3RvclxuXG5mdW5jdGlvbiBjb21waWxlRXhwcmVzc2lvbihzcmMpIHtcblx0aWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYSBzdHJpbmcuJylcblx0fVxuXHRcblx0bmV3IEZ1bmN0aW9uQ29uc3RydWN0b3IoJ1widXNlIHN0cmljdFwiOyByZXR1cm4gJyArIHNyYykgLy8gVGVzdHMgZm9yIHN5bnRheCBlcnJvcnMgd2l0aG91dCBydW5uaW5nIHRoZSBjb2RlXG5cdHZhciBjb2RlID0gbmV3IEZ1bmN0aW9uQ29uc3RydWN0b3IoJ3NhbmRib3gnLCAnd2l0aCAoc2FuZGJveCkge3JldHVybiAoZnVuY3Rpb24gKCkge1widXNlIHN0cmljdFwiOyByZXR1cm4gJyArIHNyYyArICd9KS5jYWxsKHRoaXMpfScpXG5cdFxuXHRyZXR1cm4gZnVuY3Rpb24gKHNhbmRib3gpIHtcblx0XHRpZiAoIWlzT2JqZWN0KHNhbmRib3gpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3Qgb3IgZnVuY3Rpb24uJylcblx0XHR9XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgcnVuIHNhbmRib3hlZCBjb2RlIGluc2lkZSBhbiBhbHJlYWR5LXJ1bm5pbmcgc2FuZGJveC4nKVxuXHRcdH1cblx0XHR2YXIgc2FuZGJveFByb3h5ID0gZ2V0UHJveHkoc2FuZGJveClcblx0XHR2YXIgcmVzdWx0LCBlcnJvclxuXHRcdFxuXHRcdGN1cnJlbnRTYW5kYm94ID0gc2FuZGJveFxuXHRcdHRyeSB7XG5cdFx0XHRyZXN1bHQgPSBjb2RlLmNhbGwoc2FuZGJveFByb3h5LCBzYW5kYm94UHJveHkpXG5cdFx0XHRjdXJyZW50U2FuZGJveCA9IHVuZGVmaW5lZFxuXHRcdH0gY2F0Y2ggKGV4KSB7XG5cdFx0XHRjdXJyZW50U2FuZGJveCA9IHVuZGVmaW5lZFxuXHRcdFx0aWYgKGV4IGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdFx0ZXJyb3IgPSBuZXcgZXguY29uc3RydWN0b3IoJycgKyBleC5tZXNzYWdlKVxuXHRcdFx0XHRlcnJvci5zdGFjayA9ICcnICsgZXguc3RhY2tcblx0XHRcdFx0dGhyb3cgZXJyb3Jcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcihTdHJpbmcoZXgpKVxuXHRcdH1cblx0XHRpZiAoaXNPYmplY3QocmVzdWx0KSkge1xuXHRcdFx0dGhyb3cgVHlwZUVycm9yKCdTYW5kYm94ZXMgYXJlIG9ubHkgYWxsb3dlZCB0byByZXR1cm4gcHJpbWl0aXZlIHZhbHVlcy4nKVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0XG5cdH1cbn1cbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZUV4cHJlc3Npb25cblxudmFyIHRyYXBzID0ge1xuXHRnZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdGlmIChrZXkgPT09IHVuc2NvcGFibGVzU3ltYm9sICYmIHRhcmdldCA9PT0gY3VycmVudFNhbmRib3gpIHtcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZFxuXHRcdFx0fVxuXHRcdFx0aWYgKCFub3RQcml2YXRlKGtleSkpIHtcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZFxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGdldFByb3h5T3JQcmltaXRpdmUoUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSlcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcilcblx0fSxcblx0c2V0OiBmdW5jdGlvbiAodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbm5vdCBzZXQgcHJvcGVydGllcyBvbiBhIHNhbmRib3hlZCBvYmplY3QuJylcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpXG5cdH0sXG5cdGhhczogZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHRpZiAodGFyZ2V0ID09PSBjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFub3RQcml2YXRlKGtleSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZ2V0UHJveHlPclByaW1pdGl2ZShSZWZsZWN0Lmhhcyh0YXJnZXQsIGtleSkpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIGtleSlcblx0fSxcblx0Z2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdHJldHVybiBnZXRQcm94eU9yUHJpbWl0aXZlKFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSlcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KVxuXHR9LFxuXHRzZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gKHRhcmdldCwgcHJvdG8pIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBjYW5ub3Qgc2V0IHRoZSBwcm90b3R5cGUgb2YgYSBzYW5kYm94ZWQgb2JqZWN0LicpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0LnNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pXG5cdH0sXG5cdGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0cmV0dXJuIGdldFByb3h5T3JQcmltaXRpdmUoUmVmbGVjdC5pc0V4dGVuc2libGUodGFyZ2V0KSlcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3QuaXNFeHRlbnNpYmxlKHRhcmdldClcblx0fSxcblx0cHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBjYW5ub3QgY2hhbmdlIHRoZSBleHRlbnNpYmlsaXR5IG9mIGEgc2FuZGJveGVkIG9iamVjdC4nKVxuXHRcdH1cblx0XHRyZXR1cm4gUmVmbGVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpXG5cdH0sXG5cdGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHRpZiAoa2V5ID09PSBTeW1ib2wudW5zY29wYWJsZXMgJiYgdGFyZ2V0ID09PSBjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0XHRpZiAoIW5vdFByaXZhdGUoa2V5KSkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZ2V0UHJveHlPclByaW1pdGl2ZShSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSlcblx0fSxcblx0ZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbm5vdCBkZWZpbmUgcHJvcGVydGllcyBvbiBhIHNhbmRib3hlZCBvYmplY3QuJylcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpXG5cdH0sXG5cdGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBjYW5ub3QgZGVsZXRlIHByb3BlcnRpZXMgb24gYSBzYW5kYm94ZWQgb2JqZWN0LicpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KVxuXHR9LFxuXHRvd25LZXlzOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHRyZXR1cm4gZ2V0UHJveHlPclByaW1pdGl2ZShSZWZsZWN0Lm93bktleXModGFyZ2V0KS5maWx0ZXIobm90UHJpdmF0ZSkpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxuXHR9LFxuXHRhcHBseTogZnVuY3Rpb24gKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0aWYgKHRhcmdldCA9PT0gRnVuY3Rpb25Db25zdHJ1Y3RvciB8fCB0YXJnZXQgPT09IEZ1bmN0aW9uQ29uc3RydWN0b3JQcm94eSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgY2Fubm90IHVzZSB0aGUgRnVuY3Rpb24gY29uc3RydWN0b3IgaW4gYSBzYW5kYm94ZWQgY29udGV4dC4nKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGdldFByb3h5T3JQcmltaXRpdmUoUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpKVxuXHRcdH1cblx0XHRyZXR1cm4gUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpXG5cdH0sXG5cdGNvbnN0cnVjdDogZnVuY3Rpb24gKHRhcmdldCwgYXJndW1lbnRzTGlzdCwgbmV3VGFyZ2V0KSB7XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHRpZiAodGFyZ2V0ID09PSBGdW5jdGlvbkNvbnN0cnVjdG9yIHx8IHRhcmdldCA9PT0gRnVuY3Rpb25Db25zdHJ1Y3RvclByb3h5KSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBjYW5ub3QgdXNlIHRoZSBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpbiBhIHNhbmRib3hlZCBjb250ZXh0LicpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZ2V0UHJveHlPclByaW1pdGl2ZShSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QsIG5ld1RhcmdldCkpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QsIG5ld1RhcmdldClcblx0fVxufVxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8ICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKVxufVxuXG5mdW5jdGlvbiBnZXRQcm94eU9yUHJpbWl0aXZlKHZhbHVlKSB7XG5cdGlmIChpc09iamVjdCh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gc2FmZU9iamVjdHMuaW5kZXhPZih2YWx1ZSkgPj0gMCA/IHZhbHVlIDogZ2V0UHJveHkodmFsdWUpXG5cdH1cblx0cmV0dXJuIHZhbHVlXG59XG5cbmZ1bmN0aW9uIGdldFByb3h5KG9iamVjdCwgaGlkZU9yaWdpbmFsKSB7XG5cdGlmIChvYmplY3QgPT09IEdMT0JBTCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBnbG9iYWwgb2JqZWN0IGlzIGZvcmJpZGRlbiBmcm9tIGVudGVyaW5nIGEgc2FuZGJveGVkIGNvbnRleHQuJylcblx0fVxuXHRpZiAob2JqZWN0ID09PSBldmFsRnVuY3Rpb24pIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgZXZhbCBmdW5jdGlvbiBpcyBmb3JiaWRkZW4gZnJvbSBlbnRlcmluZyBhIHNhbmRib3hlZCBjb250ZXh0LicpXG5cdH1cblx0dmFyIHByb3h5ID0gcmVhZG9ubHlQcm94aWVzLmdldChvYmplY3QpXG5cdGlmICh0eXBlb2YgcHJveHkgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cHJveHkgPSBuZXcgUHJveHkob2JqZWN0LCB0cmFwcylcblx0XHRyZWFkb25seVByb3hpZXMuc2V0KGhpZGVPcmlnaW5hbCA/IHByb3h5IDogb2JqZWN0LCBwcm94eSlcblx0fVxuXHRyZXR1cm4gcHJveHlcbn1cblxuZnVuY3Rpb24gbm90UHJpdmF0ZShrZXkpIHtcblx0cmV0dXJuIHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8IGtleVswXSAhPT0gJ18nXG59XG5cbi8vIEZyZWV6ZSBhbmQgcHJveHkgYW55dGhpbmcgdGhhdCBpcyBhY2Nlc3NpYmxlIHRocm91Z2ggSmF2YVNjcmlwdCBzeW50YXggYWxvbmVcbi8vIFRoaXMgc2hvdWxkIGluY2x1ZGUgYW55IHZhbHVlIHRoYXQgeW91IGNhbiBnZXQgZnJvbSBKYXZhU2NyaXB0IHN5bnRheCBpdHNlbGYuXG4vLyBGb3IgZXhhbXBsZTpcbi8vICAgICBcIm15IHN0cmluZ1wiLmZvb2JhclxuLy8gICAgIHRyeSB7dGhyb3cgMX0gY2F0Y2ggKGVycikge2Vyci5mb29iYXJ9XG4vLyBTeW1ib2xzIGFyZSBpbmNsdWRlZCBoZXJlIGJlY2F1c2UgdGhleSBhcmUgbm90IHByb3RlY3RlZCBieSBvdXIgcHJveHlpbmdcbi8vIGJlY2F1c2UgdGhleSBhcmUgcHJpbWl0aXZlcy5cbnZhciBzYWZlT2JqZWN0cyA9IHJlcXVpcmUoJy4vbGliL21ha2Utc2FmZScpKFtcblx0Qm9vbGVhbi5wcm90b3R5cGUsXG5cdE51bWJlci5wcm90b3R5cGUsXG5cdFN0cmluZy5wcm90b3R5cGUsXG5cdFN5bWJvbC5wcm90b3R5cGUsXG5cdEZ1bmN0aW9uLnByb3RvdHlwZSxcblx0T2JqZWN0LnByb3RvdHlwZSxcblx0QXJyYXkucHJvdG90eXBlLFxuXHRSZWdFeHAucHJvdG90eXBlLFxuXHRFcnJvci5wcm90b3R5cGUsXG5cdEV2YWxFcnJvci5wcm90b3R5cGUsXG5cdFJhbmdlRXJyb3IucHJvdG90eXBlLFxuXHRSZWZlcmVuY2VFcnJvci5wcm90b3R5cGUsXG5cdFN5bnRheEVycm9yLnByb3RvdHlwZSxcblx0VHlwZUVycm9yLnByb3RvdHlwZSxcblx0VVJJRXJyb3IucHJvdG90eXBlLFxuXHRQcm9taXNlLnByb3RvdHlwZSxcblx0T2JqZWN0LmdldFByb3RvdHlwZU9mKGZ1bmN0aW9uKigpe30pLFxuXHRPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnVuY3Rpb24qKCl7fSgpKVxuXSwgaXNPYmplY3QsIGdldFByb3h5LCBHTE9CQUwpXG5cbnZhciBldmFsRnVuY3Rpb24gPSBHTE9CQUwuZXZhbFxudmFyIEZ1bmN0aW9uQ29uc3RydWN0b3JQcm94eSA9IDAuLmNvbnN0cnVjdG9yLmNvbnN0cnVjdG9yXG5cbm1vZHVsZS5leHBvcnRzLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cdHJldHVybiBhID09PSBiIHx8IChyZWFkb25seVByb3hpZXMuZ2V0KGEpIHx8IGEpID09PSAocmVhZG9ubHlQcm94aWVzLmdldChiKSB8fCBiKVxufVxuXG5cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1bnNhZmVPYmplY3RzLCBpc09iamVjdCwgZ2V0UHJveHksIEdMT0JBTCkge1xuXHR2YXIgcHJveGllcyA9IFtdXG5cdHZhciBzYWZlT2JqZWN0cyA9IFtdXG5cdHZhciByZXR1cm5zU2FmZVZhbHVlcyA9IFtcblx0XHRGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXVxuXHRdXG5cdHZhciBnbG9iYWxLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoR0xPQkFMKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09ICdyb290JyAmJiBrZXkgIT09ICdHTE9CQUwnICYmIGtleSAhPT0gJ2dsb2JhbCcgJiYga2V5ICE9PSAnd2luZG93JyAmJiBrZXkgIT09ICdzZWxmJ30pXG5cdHZhciBnbG9iYWxWYWx1ZXMgPSBnbG9iYWxLZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIHRoaXNba2V5XX0sIEdMT0JBTClcblx0XG5cdHdoaWxlICh1bnNhZmVPYmplY3RzLmxlbmd0aCkge1xuXHRcdG1ha2VTYWZlKHVuc2FmZU9iamVjdHMuc2hpZnQoKSlcblx0fVxuXHRcblx0ZnVuY3Rpb24gbWFrZVNhZmUob2JqZWN0KSB7XG5cdFx0aWYgKGlzU2FmZShvYmplY3QpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0XG5cdFx0dmFyIHJlYWNoYWJsZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdClcblx0XHRcdC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpKVxuXHRcdFxuXHRcdGlmIChvYmplY3QgPT09IEZ1bmN0aW9uLnByb3RvdHlwZSkge1xuXHRcdFx0cmVhY2hhYmxlID0gcmVhY2hhYmxlLmZpbHRlcihpZ25vcmVkS2V5cylcblx0XHR9XG5cdFx0XG5cdFx0cmVhY2hhYmxlLmZvckVhY2gocmVwbGFjZVdpdGhQcm94eSwgb2JqZWN0KVxuXHRcdE9iamVjdC5mcmVlemUob2JqZWN0KVxuXHRcdHNhZmVPYmplY3RzLnB1c2gob2JqZWN0KVxuXHRcdFxuXHRcdHVuc2FmZU9iamVjdHMucHVzaChPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KSlcblx0fVxuXHRcblx0ZnVuY3Rpb24gaWdub3JlZEtleXMoa2V5KSB7XG5cdFx0cmV0dXJuIGtleSAhPT0gJ2NhbGxlcicgJiYga2V5ICE9PSAnYXJndW1lbnRzJ1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBpc1NhZmUodmFsdWUpIHtcblx0XHRyZXR1cm4gIWlzT2JqZWN0KHZhbHVlKSB8fCBwcm94aWVzLmluZGV4T2YodmFsdWUpID49IDAgfHwgc2FmZU9iamVjdHMuaW5kZXhPZih2YWx1ZSkgPj0gMFxuXHR9XG5cdFxuXHRmdW5jdGlvbiByZXBsYWNlV2l0aFByb3h5KGtleSkge1xuXHRcdHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBrZXkpXG5cdFx0aWYgKCEoJ3ZhbHVlJyBpbiBkKSkge1xuXHRcdFx0aWYgKGtleSA9PT0gJ19fcHJvdG9fXycgJiYgaXNTYWZlKHRoaXNba2V5XSkpIHtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRpZiAoIWQuY29uZmlndXJhYmxlKSB7XG5cdFx0XHRcdGQuZ2V0ICYmIHVuc2FmZU9iamVjdHMucHVzaChkLmdldClcblx0XHRcdFx0ZC5zZXQgJiYgdW5zYWZlT2JqZWN0cy5wdXNoKGQuc2V0KVxuXHRcdFx0XHQvLyBUaGlzIGdldHRlci9zZXR0ZXIgY291bGQgcG90ZW50aWFsbHkgcmV0dXJuIGEgbm9uLXByb3hpZWQgb2JqZWN0XG5cdFx0XHRcdGNvbnNvbGUud2FybignUG90ZW50aWFsbHkgdnVsbmVyYWJsZSBnZXR0ZXIvc2V0dGVyIGF0ICVzIGluICVzJywga2V5LCB0aGlzKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdHZhciBnZXR0ZXIgPSBkLmdldCAmJiBnZXRQcm94eShkLmdldCwgdHJ1ZSlcblx0XHRcdHZhciBzZXR0ZXIgPSBkLnNldCAmJiBnZXRQcm94eShkLnNldCwgdHJ1ZSlcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcblx0XHRcdFx0Z2V0OiBnZXR0ZXIsXG5cdFx0XHRcdHNldDogc2V0dGVyLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiBkLmVudW1lcmFibGUsXG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2Vcblx0XHRcdH0pXG5cdFx0XHRnZXR0ZXIgJiYgcHJveGllcy5wdXNoKGdldHRlcilcblx0XHRcdHNldHRlciAmJiBwcm94aWVzLnB1c2goc2V0dGVyKVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdFxuXHRcdHZhciB2YWx1ZSA9IHRoaXNba2V5XVxuXHRcdGlmIChpc1NhZmUodmFsdWUpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0XG5cdFx0aWYgKGQud3JpdGFibGUpIHtcblx0XHRcdHZhciBwcm94eSA9IGdldFByb3h5KHZhbHVlLCB0cnVlKVxuXHRcdFx0cHJveGllcy5wdXNoKHRoaXNba2V5XSA9IHByb3h5KVxuXHRcdFx0cmVwbGFjZUluR2xvYmFsKHZhbHVlLCBwcm94eSlcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHRpZiAoZC5jb25maWd1cmFibGUpIHtcblx0XHRcdHZhciBwcm94eSA9IGdldFByb3h5KHZhbHVlLCB0cnVlKVxuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuXHRcdFx0XHR2YWx1ZTogcHJveHksXG5cdFx0XHRcdHdyaXRhYmxlOiBmYWxzZSxcblx0XHRcdFx0ZW51bWVyYWJsZTogZC5lbnVtZXJhYmxlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlXG5cdFx0XHR9KVxuXHRcdFx0cmVwbGFjZUluR2xvYmFsKHZhbHVlLCBwcm94eSlcblx0XHRcdHByb3hpZXMucHVzaChwcm94eSlcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHR1bnNhZmVPYmplY3RzLnB1c2godmFsdWUpXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiByZXR1cm5zU2FmZVZhbHVlcy5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcblx0XHRcdC8vIFRoaXMgZnVuY3Rpb24gY291bGQgcG90ZW50aWFsbHkgcmV0dXJuIGEgbm9uLXByb3hpZWQgb2JqZWN0XG5cdFx0XHRjb25zb2xlLndhcm4oJ1BvdGVudGlhbGx5IHZ1bG5lcmFibGUgZnVuY3Rpb24gYXQgJXMgaW4gJXMnLCBrZXksIHRoaXMpXG5cdFx0fVxuXHR9XG5cdFxuXHRmdW5jdGlvbiByZXBsYWNlSW5HbG9iYWwodmFsdWUsIHByb3h5KSB7XG5cdFx0dmFyIGluZGV4ID0gZ2xvYmFsVmFsdWVzLmluZGV4T2YodmFsdWUpXG5cdFx0aWYgKGluZGV4ID49IDApIHtcblx0XHRcdHZhciBrZXkgPSBnbG9iYWxLZXlzW2luZGV4XVxuXHRcdFx0dmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEdMT0JBTCwga2V5KVxuXHRcdFx0aWYgKGQud3JpdGFibGUpIHtcblx0XHRcdFx0R0xPQkFMW2tleV0gPSBwcm94eVxuXHRcdFx0fSBlbHNlIGlmIChkLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoR0xPQkFMLCBrZXksIHtcblx0XHRcdFx0XHR2YWx1ZTogcHJveHksXG5cdFx0XHRcdFx0d3JpdGFibGU6IGZhbHNlLFxuXHRcdFx0XHRcdGVudW1lcmFibGU6IGQuZW51bWVyYWJsZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlXG5cdFx0XHRcdH0pXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1dhcyBub3QgYWJsZSB0byByZXBsYWNlICVzIGluIGdsb2JhbCBvYmplY3QnLCBrZXkpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRyZXR1cm4gc2FmZU9iamVjdHNcbn1cbiIsInZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcblx0aWYgKCFvYmogfHwgdG9TdHJpbmcuY2FsbChvYmopICE9PSAnW29iamVjdCBPYmplY3RdJyB8fCBvYmoubm9kZVR5cGUgfHwgb2JqLnNldEludGVydmFsKVxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR2YXIgaGFzX293bl9jb25zdHJ1Y3RvciA9IGhhc093bi5jYWxsKG9iaiwgJ2NvbnN0cnVjdG9yJyk7XG5cdHZhciBoYXNfaXNfcHJvcGVydHlfb2ZfbWV0aG9kID0gaGFzT3duLmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ2lzUHJvdG90eXBlT2YnKTtcblx0Ly8gTm90IG93biBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBtdXN0IGJlIE9iamVjdFxuXHRpZiAob2JqLmNvbnN0cnVjdG9yICYmICFoYXNfb3duX2NvbnN0cnVjdG9yICYmICFoYXNfaXNfcHJvcGVydHlfb2ZfbWV0aG9kKVxuXHRcdHJldHVybiBmYWxzZTtcblxuXHQvLyBPd24gcHJvcGVydGllcyBhcmUgZW51bWVyYXRlZCBmaXJzdGx5LCBzbyB0byBzcGVlZCB1cCxcblx0Ly8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd24uXG5cdHZhciBrZXk7XG5cdGZvciAoIGtleSBpbiBvYmogKSB7fVxuXG5cdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCB8fCBoYXNPd24uY2FsbCggb2JqLCBrZXkgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXh0ZW5kKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdCAgICB0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXG5cdCAgICBpID0gMSxcblx0ICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdCAgICBkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuXHRcdC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHRpID0gMjtcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHRhcmdldCAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAob3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdKSAhPSBudWxsICkge1xuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGNvcHkpKSApICkge1xuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgQXJyYXkuaXNBcnJheShzcmMpID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBleHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYW5zaVJlZ2V4ID0gcmVxdWlyZSgnYW5zaS1yZWdleCcpO1xudmFyIHJlID0gbmV3IFJlZ0V4cChhbnNpUmVnZXgoKS5zb3VyY2UpOyAvLyByZW1vdmUgdGhlIGBnYCBmbGFnXG5tb2R1bGUuZXhwb3J0cyA9IHJlLnRlc3QuYmluZChyZSk7XG4iLCIvKipcbiAqIMKpIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAxNyBBbGwgUmlnaHRzIFJlc2VydmVkXG4gKiAgIFByb2plY3QgbmFtZTogSlNPTmF0YVxuICogICBUaGlzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLCBzZWUgTElDRU5TRVxuICovXG5cbi8qKlxuICogQG1vZHVsZSBKU09OYXRhXG4gKiBAZGVzY3JpcHRpb24gSlNPTiBxdWVyeSBhbmQgdHJhbnNmb3JtYXRpb24gbGFuZ3VhZ2VcbiAqL1xuXG4vKipcbiAqIGpzb25hdGFcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAqIEByZXR1cm5zIHt7ZXZhbHVhdGU6IGV2YWx1YXRlLCBhc3NpZ246IGFzc2lnbn19IEV2YWx1YXRlZCBleHByZXNzaW9uXG4gKi9cbnZhciBqc29uYXRhID0gKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBvcGVyYXRvcnMgPSB7XG4gICAgICAgICcuJzogNzUsXG4gICAgICAgICdbJzogODAsXG4gICAgICAgICddJzogMCxcbiAgICAgICAgJ3snOiA3MCxcbiAgICAgICAgJ30nOiAwLFxuICAgICAgICAnKCc6IDgwLFxuICAgICAgICAnKSc6IDAsXG4gICAgICAgICcsJzogMCxcbiAgICAgICAgJ0AnOiA3NSxcbiAgICAgICAgJyMnOiA3MCxcbiAgICAgICAgJzsnOiA4MCxcbiAgICAgICAgJzonOiA4MCxcbiAgICAgICAgJz8nOiAyMCxcbiAgICAgICAgJysnOiA1MCxcbiAgICAgICAgJy0nOiA1MCxcbiAgICAgICAgJyonOiA2MCxcbiAgICAgICAgJy8nOiA2MCxcbiAgICAgICAgJyUnOiA2MCxcbiAgICAgICAgJ3wnOiAyMCxcbiAgICAgICAgJz0nOiA0MCxcbiAgICAgICAgJzwnOiA0MCxcbiAgICAgICAgJz4nOiA0MCxcbiAgICAgICAgJ14nOiA0MCxcbiAgICAgICAgJyoqJzogNjAsXG4gICAgICAgICcuLic6IDIwLFxuICAgICAgICAnOj0nOiAxMCxcbiAgICAgICAgJyE9JzogNDAsXG4gICAgICAgICc8PSc6IDQwLFxuICAgICAgICAnPj0nOiA0MCxcbiAgICAgICAgJ34+JzogNDAsXG4gICAgICAgICdhbmQnOiAzMCxcbiAgICAgICAgJ29yJzogMjUsXG4gICAgICAgICdpbic6IDQwLFxuICAgICAgICAnJic6IDUwLFxuICAgICAgICAnISc6IDAsICAgLy8gbm90IGFuIG9wZXJhdG9yLCBidXQgbmVlZGVkIGFzIGEgc3RvcCBjaGFyYWN0ZXIgZm9yIG5hbWUgdG9rZW5zXG4gICAgICAgICd+JzogMCAgIC8vIG5vdCBhbiBvcGVyYXRvciwgYnV0IG5lZWRlZCBhcyBhIHN0b3AgY2hhcmFjdGVyIGZvciBuYW1lIHRva2Vuc1xuICAgIH07XG5cbiAgICB2YXIgZXNjYXBlcyA9IHsgIC8vIEpTT04gc3RyaW5nIGVzY2FwZSBzZXF1ZW5jZXMgLSBzZWUganNvbi5vcmdcbiAgICAgICAgJ1wiJzogJ1wiJyxcbiAgICAgICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgICAgICcvJzogJy8nLFxuICAgICAgICAnYic6ICdcXGInLFxuICAgICAgICAnZic6ICdcXGYnLFxuICAgICAgICAnbic6ICdcXG4nLFxuICAgICAgICAncic6ICdcXHInLFxuICAgICAgICAndCc6ICdcXHQnXG4gICAgfTtcblxuICAgIC8vIFRva2VuaXplciAobGV4ZXIpIC0gaW52b2tlZCBieSB0aGUgcGFyc2VyIHRvIHJldHVybiBvbmUgdG9rZW4gYXQgYSB0aW1lXG4gICAgdmFyIHRva2VuaXplciA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgICB2YXIgY3JlYXRlID0gZnVuY3Rpb24gKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0ge3R5cGU6IHR5cGUsIHZhbHVlOiB2YWx1ZSwgcG9zaXRpb246IHBvc2l0aW9ufTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHNjYW5SZWdleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gdGhlIHByZWZpeCAnLycgd2lsbCBoYXZlIGJlZW4gcHJldmlvdXNseSBzY2FubmVkLiBGaW5kIHRoZSBlbmQgb2YgdGhlIHJlZ2V4LlxuICAgICAgICAgICAgLy8gc2VhcmNoIGZvciBjbG9zaW5nICcvJyBpZ25vcmluZyBhbnkgdGhhdCBhcmUgZXNjYXBlZCwgb3Igd2l0aGluIGJyYWNrZXRzXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBwb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IDA7XG4gICAgICAgICAgICB2YXIgcGF0dGVybjtcbiAgICAgICAgICAgIHZhciBmbGFncztcbiAgICAgICAgICAgIHdoaWxlKHBvc2l0aW9uIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGFyID0gcGF0aC5jaGFyQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRDaGFyID09PSAnLycgJiYgcGF0aC5jaGFyQXQocG9zaXRpb24gLSAxKSAhPT0gJ1xcXFwnICYmIGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuZCBvZiByZWdleCBmb3VuZFxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gcGF0aC5zdWJzdHJpbmcoc3RhcnQsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYocGF0dGVybiA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMzAxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFyID0gcGF0aC5jaGFyQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAvLyBmbGFnc1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZShjdXJyZW50Q2hhciA9PT0gJ2knIHx8IGN1cnJlbnRDaGFyID09PSAnbScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhciA9IHBhdGguY2hhckF0KHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmbGFncyA9IHBhdGguc3Vic3RyaW5nKHN0YXJ0LCBwb3NpdGlvbikgKyAnZyc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoKGN1cnJlbnRDaGFyID09PSAnKCcgfHwgY3VycmVudENoYXIgPT09ICdbJyB8fCBjdXJyZW50Q2hhciA9PT0gJ3snKSAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiAtIDEpICE9PSAnXFxcXCcgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKChjdXJyZW50Q2hhciA9PT0gJyknIHx8IGN1cnJlbnRDaGFyID09PSAnXScgfHwgY3VycmVudENoYXIgPT09ICd9JykgJiYgcGF0aC5jaGFyQXQocG9zaXRpb24gLSAxKSAhPT0gJ1xcXFwnICkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgY29kZTogXCJTMDMwMlwiLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBsZW5ndGgpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGFyID0gcGF0aC5jaGFyQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgLy8gc2tpcCB3aGl0ZXNwYWNlXG4gICAgICAgICAgICB3aGlsZSAocG9zaXRpb24gPCBsZW5ndGggJiYgJyBcXHRcXG5cXHJcXHYnLmluZGV4T2YoY3VycmVudENoYXIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFyID0gcGF0aC5jaGFyQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCBmb3IgcmVnZXhcbiAgICAgICAgICAgIGlmIChwcmVmaXggIT09IHRydWUgJiYgY3VycmVudENoYXIgPT09ICcvJykge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgncmVnZXgnLCBzY2FuUmVnZXgoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYW5kbGUgZG91YmxlLWNoYXIgb3BlcmF0b3JzXG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICcuJyAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiArIDEpID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUtZG90IC4uIHJhbmdlIG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdvcGVyYXRvcicsICcuLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnOicgJiYgcGF0aC5jaGFyQXQocG9zaXRpb24gKyAxKSA9PT0gJz0nKSB7XG4gICAgICAgICAgICAgICAgLy8gOj0gYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgnb3BlcmF0b3InLCAnOj0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJyEnICYmIHBhdGguY2hhckF0KHBvc2l0aW9uICsgMSkgPT09ICc9Jykge1xuICAgICAgICAgICAgICAgIC8vICE9XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdvcGVyYXRvcicsICchPScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnPicgJiYgcGF0aC5jaGFyQXQocG9zaXRpb24gKyAxKSA9PT0gJz0nKSB7XG4gICAgICAgICAgICAgICAgLy8gPj1cbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ29wZXJhdG9yJywgJz49Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICc8JyAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiArIDEpID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICAvLyA8PVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgnb3BlcmF0b3InLCAnPD0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJyonICYmIHBhdGguY2hhckF0KHBvc2l0aW9uICsgMSkgPT09ICcqJykge1xuICAgICAgICAgICAgICAgIC8vICoqICBkZXNjZW5kYW50IHdpbGRjYXJkXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdvcGVyYXRvcicsICcqKicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnficgJiYgcGF0aC5jaGFyQXQocG9zaXRpb24gKyAxKSA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgLy8gfj4gIGNoYWluIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdvcGVyYXRvcicsICd+PicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCBmb3Igc2luZ2xlIGNoYXIgb3BlcmF0b3JzXG4gICAgICAgICAgICBpZiAob3BlcmF0b3JzLmhhc093blByb3BlcnR5KGN1cnJlbnRDaGFyKSkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgnb3BlcmF0b3InLCBjdXJyZW50Q2hhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IGZvciBzdHJpbmcgbGl0ZXJhbHNcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJ1wiJyB8fCBjdXJyZW50Q2hhciA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcXVvdGVUeXBlID0gY3VycmVudENoYXI7XG4gICAgICAgICAgICAgICAgLy8gZG91YmxlIHF1b3RlZCBzdHJpbmcgbGl0ZXJhbCAtIGZpbmQgZW5kIG9mIHN0cmluZ1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgdmFyIHFzdHIgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhciA9IHBhdGguY2hhckF0KHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnXFxcXCcpIHsgLy8gZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYXIgPSBwYXRoLmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXNjYXBlcy5oYXNPd25Qcm9wZXJ0eShjdXJyZW50Q2hhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxc3RyICs9IGVzY2FwZXNbY3VycmVudENoYXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Q2hhciA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXFx1IHNob3VsZCBiZSBmb2xsb3dlZCBieSA0IGhleCBkaWdpdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2N0ZXRzID0gcGF0aC5zdWJzdHIocG9zaXRpb24gKyAxLCA0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoL15bMC05YS1mQS1GXSskLy50ZXN0KG9jdGV0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGVwb2ludCA9IHBhcnNlSW50KG9jdGV0cywgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZXBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMTA0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWxsZWdhbCBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAxMDNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IGN1cnJlbnRDaGFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDaGFyID09PSBxdW90ZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdzdHJpbmcnLCBxc3RyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFzdHIgKz0gY3VycmVudENoYXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMTAxXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCBmb3IgbnVtYmVyc1xuICAgICAgICAgICAgdmFyIG51bXJlZ2V4ID0gL14tPygwfChbMS05XVswLTldKikpKFxcLlswLTldKyk/KFtFZV1bLStdP1swLTldKyk/LztcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IG51bXJlZ2V4LmV4ZWMocGF0aC5zdWJzdHJpbmcocG9zaXRpb24pKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBudW0gPSBwYXJzZUZsb2F0KG1hdGNoWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKG51bSkgJiYgaXNGaW5pdGUobnVtKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ251bWJlcicsIG51bSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDEwMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogbWF0Y2hbMF1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IGZvciBxdW90ZWQgbmFtZXMgKGJhY2t0aWNrcylcbiAgICAgICAgICAgIHZhciBuYW1lO1xuICAgICAgICAgICAgaWYoY3VycmVudENoYXIgPT09ICdgJykge1xuICAgICAgICAgICAgICAgIC8vIHNjYW4gZm9yIGNsb3NpbmcgcXVvdGVcbiAgICAgICAgICAgICAgICBwb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBwYXRoLmluZGV4T2YoJ2AnLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYoZW5kICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gcGF0aC5zdWJzdHJpbmcocG9zaXRpb24sIGVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gZW5kICsgMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgnbmFtZScsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAxMDVcIixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IGZvciBuYW1lc1xuICAgICAgICAgICAgdmFyIGkgPSBwb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciBjaDtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBjaCA9IHBhdGguY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBsZW5ndGggfHwgJyBcXHRcXG5cXHJcXHYnLmluZGV4T2YoY2gpID4gLTEgfHwgb3BlcmF0b3JzLmhhc093blByb3BlcnR5KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aC5jaGFyQXQocG9zaXRpb24pID09PSAnJCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhcmlhYmxlIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHBhdGguc3Vic3RyaW5nKHBvc2l0aW9uICsgMSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCd2YXJpYWJsZScsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHBhdGguc3Vic3RyaW5nKHBvc2l0aW9uLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ29yJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpbic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYW5kJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgnb3BlcmF0b3InLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0cnVlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgndmFsdWUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmYWxzZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ3ZhbHVlJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCd2YWx1ZScsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gbGVuZ3RoICYmIG5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGl0ZXNwYWNlIGF0IGVuZCBvZiBpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgnbmFtZScsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgZnVuY3Rpb24gc2lnbmF0dXJlIGRlZmluaXRpb24gYW5kIHJldHVybnMgYSB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZSAtIHRoZSBzaWduYXR1cmUgYmV0d2VlbiB0aGUgPGFuZ2xlIGJyYWNrZXRzPlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gdmFsaWRhdGlvbiBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgICAgICAvLyBjcmVhdGUgYSBSZWdleCB0aGF0IHJlcHJlc2VudHMgdGhpcyBzaWduYXR1cmUgYW5kIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgd2hlbiBpbnZva2VkLFxuICAgICAgICAvLyByZXR1cm5zIHRoZSB2YWxpZGF0ZWQgKHBvc3NpYmx5IGZpeGVkLXVwKSBhcmd1bWVudHMsIG9yIHRocm93cyBhIHZhbGlkYXRpb24gZXJyb3JcbiAgICAgICAgLy8gc3RlcCB0aHJvdWdoIHRoZSBzaWduYXR1cmUsIG9uZSBzeW1ib2wgYXQgYSB0aW1lXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IDE7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgdmFyIHBhcmFtID0ge307XG4gICAgICAgIHZhciBwcmV2UGFyYW0gPSBwYXJhbTtcbiAgICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgc2lnbmF0dXJlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHN5bWJvbCA9IHNpZ25hdHVyZS5jaGFyQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgaWYoc3ltYm9sID09PSAnOicpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGZpZ3VyZSBvdXQgd2hhdCB0byBkbyB3aXRoIHRoZSByZXR1cm4gdHlwZVxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBpdCBmb3Igbm93XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIHByZXZQYXJhbSA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIHBhcmFtID0ge307XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZmluZENsb3NpbmdCcmFja2V0ID0gZnVuY3Rpb24oc3RyLCBzdGFydCwgb3BlblN5bWJvbCwgY2xvc2VTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgY2xvc2luZyBzeW1ib2wgKGUuZy4gYnJhY2tldCkgaW4gYSBzdHJpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGJhbGFuY2VzIHRoZSBvcGVuaW5nIHN5bWJvbCBhdCBwb3NpdGlvbiBzdGFydFxuICAgICAgICAgICAgICAgIHZhciBkZXB0aCA9IDE7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUocG9zaXRpb24gPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN0ci5jaGFyQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wgPT09IGNsb3NlU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSBkb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIG91dCBvZiB3aGlsZSBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihzeW1ib2wgPT09IG9wZW5TeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc3dpdGNoIChzeW1ib2wpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzJzogLy8gc3RyaW5nXG4gICAgICAgICAgICAgICAgY2FzZSAnbic6IC8vIG51bWJlclxuICAgICAgICAgICAgICAgIGNhc2UgJ2InOiAvLyBib29sZWFuXG4gICAgICAgICAgICAgICAgY2FzZSAnbCc6IC8vIG5vdCBzbyBzdXJlIGFib3V0IGV4cGVjdGluZyBudWxsP1xuICAgICAgICAgICAgICAgIGNhc2UgJ28nOiAvLyBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0ucmVnZXggPSAnWycgKyBzeW1ib2wgKyAnbV0nO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbS50eXBlID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2EnOiAvLyBhcnJheVxuICAgICAgICAgICAgICAgICAgICAvLyAgbm9ybWFsbHkgdHJlYXQgYW55IHZhbHVlIGFzIHNpbmdsZXRvbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICBwYXJhbS5yZWdleCA9ICdbYXNuYmxmb21dJztcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0udHlwZSA9IHN5bWJvbDtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0uYXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOiAvLyBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICBwYXJhbS5yZWdleCA9ICdmJztcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0udHlwZSA9IHN5bWJvbDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdqJzogLy8gYW55IEpTT04gdHlwZVxuICAgICAgICAgICAgICAgICAgICBwYXJhbS5yZWdleCA9ICdbYXNuYmxvbV0nO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbS50eXBlID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3gnOiAvLyBhbnkgdHlwZVxuICAgICAgICAgICAgICAgICAgICBwYXJhbS5yZWdleCA9ICdbYXNuYmxmb21dJztcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0udHlwZSA9IHN5bWJvbDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICctJzogLy8gdXNlIGNvbnRleHQgaWYgcGFyYW0gbm90IHN1cHBsaWVkXG4gICAgICAgICAgICAgICAgICAgIHByZXZQYXJhbS5jb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcHJldlBhcmFtLmNvbnRleHRSZWdleCA9IG5ldyBSZWdFeHAocHJldlBhcmFtLnJlZ2V4KTsgLy8gcHJlLWNvbXBpbGVkIHRvIHRlc3QgdGhlIGNvbnRleHQgdHlwZSBhdCBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgIHByZXZQYXJhbS5yZWdleCArPSAnPyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJz8nOiAvLyBvcHRpb25hbCBwYXJhbVxuICAgICAgICAgICAgICAgIGNhc2UgJysnOiAvLyBvbmUgb3IgbW9yZVxuICAgICAgICAgICAgICAgICAgICBwcmV2UGFyYW0ucmVnZXggKz0gc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICcoJzogLy8gY2hvaWNlIG9mIHR5cGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBmb3J3YXJkIGZvciBtYXRjaGluZyAnKSdcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZFBhcmVuID0gZmluZENsb3NpbmdCcmFja2V0KHNpZ25hdHVyZSwgcG9zaXRpb24sICcoJywgJyknKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNob2ljZSA9IHNpZ25hdHVyZS5zdWJzdHJpbmcocG9zaXRpb24gKyAxLCBlbmRQYXJlbik7XG4gICAgICAgICAgICAgICAgICAgIGlmKGNob2ljZS5pbmRleE9mKCc8JykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBwYXJhbWV0ZXJpemVkIHR5cGVzLCBzaW1wbGUgcmVnZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtLnJlZ2V4ID0gJ1snICsgY2hvaWNlICsgJ21dJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gaGFyZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDQwMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaG9pY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJhbS50eXBlID0gJygnICsgY2hvaWNlICsgJyknO1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGVuZFBhcmVuO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJzwnOiAvLyB0eXBlIHBhcmFtZXRlciAtIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gJ2EnIGFuZCAnZidcbiAgICAgICAgICAgICAgICAgICAgaWYocHJldlBhcmFtLnR5cGUgPT09ICdhJyB8fCBwcmV2UGFyYW0udHlwZSA9PT0gJ2YnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWFyY2ggZm9yd2FyZCBmb3IgbWF0Y2hpbmcgJz4nXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kUG9zID0gZmluZENsb3NpbmdCcmFja2V0KHNpZ25hdHVyZSwgcG9zaXRpb24sICc8JywgJz4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZQYXJhbS5zdWJ0eXBlID0gc2lnbmF0dXJlLnN1YnN0cmluZyhwb3NpdGlvbiArIDEsIGVuZFBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGVuZFBvcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwNDAxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHByZXZQYXJhbS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NpdGlvbisrO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWdleFN0ciA9ICdeJyArXG4gICAgICAgICAgcGFyYW1zLm1hcChmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICAgICAgICByZXR1cm4gJygnICsgcGFyYW0ucmVnZXggKyAnKSc7XG4gICAgICAgICAgfSkuam9pbignJykgK1xuICAgICAgICAgICckJztcbiAgICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleFN0cik7XG4gICAgICAgIHZhciBnZXRTeW1ib2wgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHN5bWJvbDtcbiAgICAgICAgICAgIGlmKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gJ2YnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9ICdzJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gJ24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gJ2InO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSAnbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gJ2EnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSAnbyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFueSB2YWx1ZSBjYW4gYmUgdW5kZWZpbmVkLCBidXQgc2hvdWxkIGJlIGFsbG93ZWQgdG8gbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9ICdtJzsgLy8gbSBmb3IgbWlzc2luZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHRocm93VmFsaWRhdGlvbkVycm9yID0gZnVuY3Rpb24oYmFkQXJncywgYmFkU2lnKSB7XG4gICAgICAgICAgICAvLyB0byBmaWd1cmUgb3V0IHdoZXJlIHRoaXMgd2VudCB3cm9uZyB3ZSBuZWVkIGFwcGx5IGVhY2ggY29tcG9uZW50IG9mIHRoZVxuICAgICAgICAgICAgLy8gcmVnZXggdG8gZWFjaCBhcmd1bWVudCB1bnRpbCB3ZSBnZXQgdG8gdGhlIG9uZSB0aGF0IGZhaWxzIHRvIG1hdGNoXG4gICAgICAgICAgICB2YXIgcGFydGlhbFBhdHRlcm4gPSAnXic7XG4gICAgICAgICAgICB2YXIgZ29vZFRvID0gMDtcbiAgICAgICAgICAgIGZvcih2YXIgaW5kZXggPSAwOyBpbmRleCA8IHBhcmFtcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsUGF0dGVybiArPSBwYXJhbXNbaW5kZXhdLnJlZ2V4O1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGJhZFNpZy5tYXRjaChwYXJ0aWFsUGF0dGVybik7XG4gICAgICAgICAgICAgICAgaWYobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFpbGVkIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJUMDQxMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYmFkQXJnc1tnb29kVG9dLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGdvb2RUbyArIDFcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ29vZFRvID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgaXQgZ290IHRoaXMgZmFyLCBpdCdzIHByb2JhYmx5IGJlY2F1c2Ugb2YgZXh0cmFuZW91cyBhcmd1bWVudHMgKHdlXG4gICAgICAgICAgICAvLyBoYXZlbid0IGFkZGVkIHRoZSB0cmFpbGluZyAnJCcgaW4gdGhlIHJlZ2V4IHlldC5cbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlQwNDEwXCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IGJhZEFyZ3NbZ29vZFRvXSxcbiAgICAgICAgICAgICAgICBpbmRleDogZ29vZFRvICsgMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVmaW5pdGlvbjogc2lnbmF0dXJlLFxuICAgICAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VwcGxpZWRTaWcgPSAnJztcbiAgICAgICAgICAgICAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBsaWVkU2lnICs9IGdldFN5bWJvbChhcmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBpc1ZhbGlkID0gcmVnZXguZXhlYyhzdXBwbGllZFNpZyk7XG4gICAgICAgICAgICAgICAgaWYoaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdGVkQXJncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZm9yRWFjaChmdW5jdGlvbihwYXJhbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBhcmdzW2FyZ0luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGlzVmFsaWRbaW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG1hdGNoID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbS5jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1YnN0aXR1dGUgY29udGV4dCB2YWx1ZSBmb3IgbWlzc2luZyBhcmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgY2hlY2sgdGhhdCB0aGUgY29udGV4dCB2YWx1ZSBpcyB0aGUgcmlnaHQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dFR5cGUgPSBnZXRTeW1ib2woY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRlc3QgY29udGV4dFR5cGUgYWdhaW5zdCB0aGUgcmVnZXggZm9yIHRoaXMgYXJnICh3aXRob3V0IHRoZSB0cmFpbGluZyA/KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihwYXJhbS5jb250ZXh0UmVnZXgudGVzdChjb250ZXh0VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlZEFyZ3MucHVzaChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRleHQgdmFsdWUgbm90IGNvbXBhdGlibGUgd2l0aCB0aGlzIGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJUMDQxMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBhcmdJbmRleCArIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZWRBcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heSBoYXZlIG1hdGNoZWQgbXVsdGlwbGUgYXJncyAoaWYgdGhlIHJlZ2V4IGVuZHMgd2l0aCBhICcrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwbGl0IGludG8gc2luZ2xlIHRva2Vuc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uKHNpbmdsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2luZ2xlID09PSAnbScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtaXNzaW5nICh1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmdzW2FyZ0luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXlPSyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgdGhlcmUgdHlwZSBpbmZvcm1hdGlvbiBvbiB0aGUgY29udGVudHMgb2YgdGhlIGFycmF5P1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW0uc3VidHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpbmdsZSAhPT0gJ2EnICYmIG1hdGNoICE9PSBwYXJhbS5zdWJ0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheU9LID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2luZ2xlID09PSAnYScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtVHlwZSA9IGdldFN5bWJvbChhcmdbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtVHlwZSAhPT0gcGFyYW0uc3VidHlwZS5jaGFyQXQoMCkpIHsgLy8gVE9ETyByZWN1cnNlIGZ1cnRoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlPSyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBldmVyeSBpdGVtIGluIHRoZSBhcnJheSBpcyB0aGlzIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpZmZlcmVudEl0ZW1zID0gYXJnLmZpbHRlcihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGdldFN5bWJvbCh2YWwpICE9PSBpdGVtVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheU9LID0gKGRpZmZlcmVudEl0ZW1zLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJyYXlPSykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQwNDEyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhcmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogYXJnSW5kZXggKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogcGFyYW0uc3VidHlwZSAvLyBUT0RPIHRyYW5zbGF0ZSBzeW1ib2wgdG8gdHlwZSBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmdW5jdGlvbiBleHBlY3RzIGFuIGFycmF5LiBJZiBpdCdzIG5vdCBvbmUsIG1ha2UgaXQgc29cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2luZ2xlICE9PSAnYScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gW2FyZ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVkQXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVkQXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVkQXJncztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3dWYWxpZGF0aW9uRXJyb3IoYXJncywgc3VwcGxpZWRTaWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIFRoaXMgcGFyc2VyIGltcGxlbWVudHMgdGhlICdUb3AgZG93biBvcGVyYXRvciBwcmVjZWRlbmNlJyBhbGdvcml0aG0gZGV2ZWxvcGVkIGJ5IFZhdWdoYW4gUiBQcmF0dDsgaHR0cDovL2RsLmFjbS5vcmcvY2l0YXRpb24uY2ZtP2lkPTUxMjkzMS5cbiAgICAvLyBhbmQgYnVpbGRzIG9uIHRoZSBKYXZhc2NyaXB0IGZyYW1ld29yayBkZXNjcmliZWQgYnkgRG91Z2xhcyBDcm9ja2ZvcmQgYXQgaHR0cDovL2phdmFzY3JpcHQuY3JvY2tmb3JkLmNvbS90ZG9wL3Rkb3AuaHRtbFxuICAgIC8vIGFuZCBpbiAnQmVhdXRpZnVsIENvZGUnLCBlZGl0ZWQgYnkgQW5keSBPcmFtIGFuZCBHcmVnIFdpbHNvbiwgQ29weXJpZ2h0IDIwMDcgTydSZWlsbHkgTWVkaWEsIEluYy4gNzk4LTAtNTk2LTUxMDA0LTZcblxuICAgIHZhciBwYXJzZXIgPSBmdW5jdGlvbiAoc291cmNlLCByZWNvdmVyKSB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICB2YXIgbGV4ZXI7XG5cbiAgICAgICAgdmFyIHN5bWJvbF90YWJsZSA9IHt9O1xuICAgICAgICB2YXIgZXJyb3JzID0gW107XG5cbiAgICAgICAgdmFyIHJlbWFpbmluZ1Rva2VucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IFtdO1xuICAgICAgICAgICAgaWYobm9kZS5pZCAhPT0gJyhlbmQpJykge1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZy5wdXNoKHt0eXBlOiBub2RlLnR5cGUsIHZhbHVlOiBub2RlLnZhbHVlLCBwb3NpdGlvbjogbm9kZS5wb3NpdGlvbn0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG54dCA9IGxleGVyKCk7XG4gICAgICAgICAgICB3aGlsZShueHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZW1haW5pbmcucHVzaChueHQpO1xuICAgICAgICAgICAgICAgIG54dCA9IGxleGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVtYWluaW5nO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBiYXNlX3N5bWJvbCA9IHtcbiAgICAgICAgICAgIG51ZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIGVycm9yIC0gc3ltYm9sIGhhcyBiZWVuIGludm9rZWQgYXMgYSB1bmFyeSBvcGVyYXRvclxuICAgICAgICAgICAgICAgIHZhciBlcnIgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6ICdTMDIxMScsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5wb3NpdGlvblxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZihyZWNvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyci5yZW1haW5pbmcgPSByZW1haW5pbmdUb2tlbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyLnR5cGUgPSAnZXJyb3InO1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVyci5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHN5bWJvbCA9IGZ1bmN0aW9uIChpZCwgYnApIHtcbiAgICAgICAgICAgIHZhciBzID0gc3ltYm9sX3RhYmxlW2lkXTtcbiAgICAgICAgICAgIGJwID0gYnAgfHwgMDtcbiAgICAgICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJwID49IHMubGJwKSB7XG4gICAgICAgICAgICAgICAgICAgIHMubGJwID0gYnA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzID0gT2JqZWN0LmNyZWF0ZShiYXNlX3N5bWJvbCk7XG4gICAgICAgICAgICAgICAgcy5pZCA9IHMudmFsdWUgPSBpZDtcbiAgICAgICAgICAgICAgICBzLmxicCA9IGJwO1xuICAgICAgICAgICAgICAgIHN5bWJvbF90YWJsZVtpZF0gPSBzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGhhbmRsZUVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpZihyZWNvdmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gdG9rZW5pemUgdGhlIHJlc3Qgb2YgdGhlIGJ1ZmZlciBhbmQgYWRkIGl0IHRvIGFuIGVycm9yIHRva2VuXG4gICAgICAgICAgICAgICAgZXJyLnJlbWFpbmluZyA9IHJlbWFpbmluZ1Rva2VucygpO1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgdmFyIHN5bWJvbCA9IHN5bWJvbF90YWJsZVtcIihlcnJvcilcIl07XG4gICAgICAgICAgICAgICAgbm9kZSA9IE9iamVjdC5jcmVhdGUoc3ltYm9sKTtcbiAgICAgICAgICAgICAgICBub2RlLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IFwiKGVycm9yKVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnIuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYWR2YW5jZSA9IGZ1bmN0aW9uIChpZCwgaW5maXgpIHtcbiAgICAgICAgICAgIGlmIChpZCAmJiBub2RlLmlkICE9PSBpZCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlO1xuICAgICAgICAgICAgICAgIGlmKG5vZGUuaWQgPT09ICcoZW5kKScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5leHBlY3RlZCBlbmQgb2YgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBcIlMwMjAzXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IFwiUzAyMDJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG5vZGUucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiBub2RlLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5leHRfdG9rZW4gPSBsZXhlcihpbmZpeCk7XG4gICAgICAgICAgICBpZiAobmV4dF90b2tlbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBzeW1ib2xfdGFibGVbXCIoZW5kKVwiXTtcbiAgICAgICAgICAgICAgICBub2RlLnBvc2l0aW9uID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5leHRfdG9rZW4udmFsdWU7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IG5leHRfdG9rZW4udHlwZTtcbiAgICAgICAgICAgIHZhciBzeW1ib2w7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICAgICAgICBjYXNlICd2YXJpYWJsZSc6XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbF90YWJsZVtcIihuYW1lKVwiXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnb3BlcmF0b3InOlxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2xfdGFibGVbdmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDIwNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBuZXh0X3Rva2VuLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwibGl0ZXJhbFwiO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2xfdGFibGVbXCIobGl0ZXJhbClcIl07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JlZ2V4JzpcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwicmVnZXhcIjtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gc3ltYm9sX3RhYmxlW1wiKHJlZ2V4KVwiXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMjA1XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBuZXh0X3Rva2VuLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gT2JqZWN0LmNyZWF0ZShzeW1ib2wpO1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgbm9kZS50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIG5vZGUucG9zaXRpb24gPSBuZXh0X3Rva2VuLnBvc2l0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHJhdHQncyBhbGdvcml0aG1cbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBmdW5jdGlvbiAocmJwKSB7XG4gICAgICAgICAgICB2YXIgbGVmdDtcbiAgICAgICAgICAgIHZhciB0ID0gbm9kZTtcbiAgICAgICAgICAgIGFkdmFuY2UobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICBsZWZ0ID0gdC5udWQoKTtcbiAgICAgICAgICAgIHdoaWxlIChyYnAgPCBub2RlLmxicCkge1xuICAgICAgICAgICAgICAgIHQgPSBub2RlO1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gdC5sZWQobGVmdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdGVybWluYWwgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgdmFyIHMgPSBzeW1ib2woaWQsIDApO1xuICAgICAgICAgICAgcy5udWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbWF0Y2ggaW5maXggb3BlcmF0b3JzXG4gICAgICAgIC8vIDxleHByZXNzaW9uPiA8b3BlcmF0b3I+IDxleHByZXNzaW9uPlxuICAgICAgICAvLyBsZWZ0IGFzc29jaWF0aXZlXG4gICAgICAgIHZhciBpbmZpeCA9IGZ1bmN0aW9uIChpZCwgYnAsIGxlZCkge1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdQb3dlciA9IGJwIHx8IG9wZXJhdG9yc1tpZF07XG4gICAgICAgICAgICB2YXIgcyA9IHN5bWJvbChpZCwgYmluZGluZ1Bvd2VyKTtcbiAgICAgICAgICAgIHMubGVkID0gbGVkIHx8IGZ1bmN0aW9uIChsZWZ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saHMgPSBsZWZ0O1xuICAgICAgICAgICAgICAgIHRoaXMucmhzID0gZXhwcmVzc2lvbihiaW5kaW5nUG93ZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiYmluYXJ5XCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbWF0Y2ggaW5maXggb3BlcmF0b3JzXG4gICAgICAgIC8vIDxleHByZXNzaW9uPiA8b3BlcmF0b3I+IDxleHByZXNzaW9uPlxuICAgICAgICAvLyByaWdodCBhc3NvY2lhdGl2ZVxuICAgICAgICB2YXIgaW5maXhyID0gZnVuY3Rpb24gKGlkLCBicCwgbGVkKSB7XG4gICAgICAgICAgICB2YXIgYmluZGluZ1Bvd2VyID0gYnAgfHwgb3BlcmF0b3JzW2lkXTtcbiAgICAgICAgICAgIHZhciBzID0gc3ltYm9sKGlkLCBiaW5kaW5nUG93ZXIpO1xuICAgICAgICAgICAgcy5sZWQgPSBsZWQgfHwgZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxocyA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yaHMgPSBleHByZXNzaW9uKGJpbmRpbmdQb3dlciAtIDEpOyAvLyBzdWJ0cmFjdCAxIGZyb20gYmluZGluZ1Bvd2VyIGZvciByaWdodCBhc3NvY2lhdGl2ZSBvcGVyYXRvcnNcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcImJpbmFyeVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG1hdGNoIHByZWZpeCBvcGVyYXRvcnNcbiAgICAgICAgLy8gPG9wZXJhdG9yPiA8ZXhwcmVzc2lvbj5cbiAgICAgICAgdmFyIHByZWZpeCA9IGZ1bmN0aW9uIChpZCwgbnVkKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHN5bWJvbChpZCk7XG4gICAgICAgICAgICBzLm51ZCA9IG51ZCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbig3MCk7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJ1bmFyeVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRlcm1pbmFsKFwiKGVuZClcIik7XG4gICAgICAgIHRlcm1pbmFsKFwiKG5hbWUpXCIpO1xuICAgICAgICB0ZXJtaW5hbChcIihsaXRlcmFsKVwiKTtcbiAgICAgICAgdGVybWluYWwoXCIocmVnZXgpXCIpO1xuICAgICAgICBzeW1ib2woXCI6XCIpO1xuICAgICAgICBzeW1ib2woXCI7XCIpO1xuICAgICAgICBzeW1ib2woXCIsXCIpO1xuICAgICAgICBzeW1ib2woXCIpXCIpO1xuICAgICAgICBzeW1ib2woXCJdXCIpO1xuICAgICAgICBzeW1ib2woXCJ9XCIpO1xuICAgICAgICBzeW1ib2woXCIuLlwiKTsgLy8gcmFuZ2Ugb3BlcmF0b3JcbiAgICAgICAgaW5maXgoXCIuXCIpOyAvLyBmaWVsZCByZWZlcmVuY2VcbiAgICAgICAgaW5maXgoXCIrXCIpOyAvLyBudW1lcmljIGFkZGl0aW9uXG4gICAgICAgIGluZml4KFwiLVwiKTsgLy8gbnVtZXJpYyBzdWJ0cmFjdGlvblxuICAgICAgICBpbmZpeChcIipcIik7IC8vIG51bWVyaWMgbXVsdGlwbGljYXRpb25cbiAgICAgICAgaW5maXgoXCIvXCIpOyAvLyBudW1lcmljIGRpdmlzaW9uXG4gICAgICAgIGluZml4KFwiJVwiKTsgLy8gbnVtZXJpYyBtb2R1bHVzXG4gICAgICAgIGluZml4KFwiPVwiKTsgLy8gZXF1YWxpdHlcbiAgICAgICAgaW5maXgoXCI8XCIpOyAvLyBsZXNzIHRoYW5cbiAgICAgICAgaW5maXgoXCI+XCIpOyAvLyBncmVhdGVyIHRoYW5cbiAgICAgICAgaW5maXgoXCIhPVwiKTsgLy8gbm90IGVxdWFsIHRvXG4gICAgICAgIGluZml4KFwiPD1cIik7IC8vIGxlc3MgdGhhbiBvciBlcXVhbFxuICAgICAgICBpbmZpeChcIj49XCIpOyAvLyBncmVhdGVyIHRoYW4gb3IgZXF1YWxcbiAgICAgICAgaW5maXgoXCImXCIpOyAvLyBzdHJpbmcgY29uY2F0ZW5hdGlvblxuICAgICAgICBpbmZpeChcImFuZFwiKTsgLy8gQm9vbGVhbiBBTkRcbiAgICAgICAgaW5maXgoXCJvclwiKTsgLy8gQm9vbGVhbiBPUlxuICAgICAgICBpbmZpeChcImluXCIpOyAvLyBpcyBtZW1iZXIgb2YgYXJyYXlcbiAgICAgICAgdGVybWluYWwoXCJhbmRcIik7IC8vIHRoZSAna2V5d29yZHMnIGNhbiBhbHNvIGJlIHVzZWQgYXMgdGVybWluYWxzIChmaWVsZCBuYW1lcylcbiAgICAgICAgdGVybWluYWwoXCJvclwiKTsgLy9cbiAgICAgICAgdGVybWluYWwoXCJpblwiKTsgLy9cbiAgICAgICAgaW5maXhyKFwiOj1cIik7IC8vIGJpbmQgdmFyaWFibGVcbiAgICAgICAgcHJlZml4KFwiLVwiKTsgLy8gdW5hcnkgbnVtZXJpYyBuZWdhdGlvblxuICAgICAgICBpbmZpeChcIn4+XCIpOyAvLyBmdW5jdGlvbiBhcHBsaWNhdGlvblxuXG4gICAgICAgIGluZml4cihcIihlcnJvcilcIiwgMTAsIGZ1bmN0aW9uKGxlZnQpIHtcbiAgICAgICAgICAgIHRoaXMubGhzID0gbGVmdDtcblxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IG5vZGUuZXJyb3I7XG4gICAgICAgICAgICB0aGlzLnJlbWFpbmluZyA9IHJlbWFpbmluZ1Rva2VucygpO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ2Vycm9yJztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBmaWVsZCB3aWxkY2FyZCAoc2luZ2xlIGxldmVsKVxuICAgICAgICBwcmVmaXgoJyonLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBcIndpbGRjYXJkXCI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZGVzY2VuZGFudCB3aWxkY2FyZCAobXVsdGktbGV2ZWwpXG4gICAgICAgIHByZWZpeCgnKionLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBcImRlc2NlbmRhbnRcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBmdW5jdGlvbiBpbnZvY2F0aW9uXG4gICAgICAgIGluZml4KFwiKFwiLCBvcGVyYXRvcnNbJygnXSwgZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgICAgIC8vIGxlZnQgaXMgaXMgd2hhdCB3ZSBhcmUgdHJ5aW5nIHRvIGludm9rZVxuICAgICAgICAgICAgdGhpcy5wcm9jZWR1cmUgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnRzID0gW107XG4gICAgICAgICAgICBpZiAobm9kZS5pZCAhPT0gJyknKSB7XG4gICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnb3BlcmF0b3InICYmIG5vZGUuaWQgPT09ICc/Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFydGlhbCBmdW5jdGlvbiBhcHBsaWNhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ3BhcnRpYWwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmd1bWVudHMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoJz8nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJndW1lbnRzLnB1c2goZXhwcmVzc2lvbigwKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgIT09ICcsJykgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoJywnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZHZhbmNlKFwiKVwiLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiBpcyAnZnVuY3Rpb24nIG9yIM67LCB0aGVuIHRoaXMgaXMgZnVuY3Rpb24gZGVmaW5pdGlvbiAobGFtYmRhIGZ1bmN0aW9uKVxuICAgICAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ25hbWUnICYmIChsZWZ0LnZhbHVlID09PSAnZnVuY3Rpb24nIHx8IGxlZnQudmFsdWUgPT09ICdcXHUwM0JCJykpIHtcbiAgICAgICAgICAgICAgICAvLyBhbGwgb2YgdGhlIGFyZ3MgbXVzdCBiZSBWQVJJQUJMRSB0b2tlbnNcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmcudHlwZSAhPT0gJ3ZhcmlhYmxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDIwOFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBhcmcucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IGFyZy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5kZXggKyAxXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdsYW1iZGEnO1xuICAgICAgICAgICAgICAgIC8vIGlzIHRoZSBuZXh0IHRva2VuIGEgJzwnIC0gaWYgc28sIHBhcnNlIHRoZSBmdW5jdGlvbiBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICBpZihub2RlLmlkID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ1BvcyA9IG5vZGUucG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXB0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWcgPSAnPCc7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGRlcHRoID4gMCAmJiBub2RlLmlkICE9PSAneycgJiYgbm9kZS5pZCAhPT0gJyhlbmQpJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvayA9IGFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRvay5pZCA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZih0b2suaWQgPT09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWcgKz0gdG9rLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoJz4nKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2lnbmF0dXJlID0gcGFyc2VTaWduYXR1cmUoc2lnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2VydCB0aGUgcG9zaXRpb24gaW50byB0aGlzIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIucG9zaXRpb24gPSBzaWdQb3MgKyBlcnIub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCBlcnIgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBwYXJzZSB0aGUgZnVuY3Rpb24gYm9keVxuICAgICAgICAgICAgICAgIGFkdmFuY2UoJ3snKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkgPSBleHByZXNzaW9uKDApO1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoJ30nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBwYXJlbnRoZXNpcyAtIGJsb2NrIGV4cHJlc3Npb25cbiAgICAgICAgcHJlZml4KFwiKFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChub2RlLmlkICE9PSBcIilcIikge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbigwKSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgIT09IFwiO1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZHZhbmNlKFwiO1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoXCIpXCIsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhcnJheSBjb25zdHJ1Y3RvclxuICAgICAgICBwcmVmaXgoXCJbXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICBpZiAobm9kZS5pZCAhPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT09IFwiLi5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmFuZ2Ugb3BlcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHt0eXBlOiBcImJpbmFyeVwiLCB2YWx1ZTogXCIuLlwiLCBwb3NpdGlvbjogbm9kZS5wb3NpdGlvbiwgbGhzOiBpdGVtfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoXCIuLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnJocyA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gcmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCAhPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoXCIsXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoXCJdXCIsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGE7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBcInVuYXJ5XCI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZmlsdGVyIC0gcHJlZGljYXRlIG9yIGFycmF5IGluZGV4XG4gICAgICAgIGluZml4KFwiW1wiLCBvcGVyYXRvcnNbJ1snXSwgZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgICAgIGlmKG5vZGUuaWQgPT09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgcHJlZGljYXRlIG1lYW5zIG1haW50YWluIHNpbmdsZXRvbiBhcnJheXMgaW4gdGhlIG91dHB1dFxuICAgICAgICAgICAgICAgIHZhciBzdGVwID0gbGVmdDtcbiAgICAgICAgICAgICAgICB3aGlsZShzdGVwICYmIHN0ZXAudHlwZSA9PT0gJ2JpbmFyeScgJiYgc3RlcC52YWx1ZSA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXAgPSBzdGVwLmxocztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RlcC5rZWVwQXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoXCJdXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxocyA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yaHMgPSBleHByZXNzaW9uKG9wZXJhdG9yc1snXSddKTtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAnYmluYXJ5JztcbiAgICAgICAgICAgICAgICBhZHZhbmNlKFwiXVwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gb3JkZXItYnlcbiAgICAgICAgaW5maXgoXCJeXCIsIG9wZXJhdG9yc1snXiddLCBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICAgICAgYWR2YW5jZShcIihcIik7XG4gICAgICAgICAgICB2YXIgdGVybXMgPSBbXTtcbiAgICAgICAgICAgIGZvcig7Oykge1xuICAgICAgICAgICAgICAgIHZhciB0ZXJtID0ge1xuICAgICAgICAgICAgICAgICAgICBkZXNjZW5kaW5nOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT09IFwiPFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFzY2VuZGluZyBzb3J0XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoXCI8XCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5pZCA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVzY2VuZGluZyBzb3J0XG4gICAgICAgICAgICAgICAgICAgIHRlcm0uZGVzY2VuZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoXCI+XCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdW5zcGVjaWZpZWQgLSBkZWZhdWx0IHRvIGFzY2VuZGluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZXJtLmV4cHJlc3Npb24gPSBleHByZXNzaW9uKDApO1xuICAgICAgICAgICAgICAgIHRlcm1zLnB1c2godGVybSk7XG4gICAgICAgICAgICAgICAgaWYobm9kZS5pZCAhPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkdmFuY2UoXCIsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShcIilcIik7XG4gICAgICAgICAgICB0aGlzLmxocyA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJocyA9IHRlcm1zO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ2JpbmFyeSc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG9iamVjdFBhcnNlciA9IGZ1bmN0aW9uIChsZWZ0KSB7XG4gICAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgaWYgKG5vZGUuaWQgIT09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoXCI6XCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChbbiwgdl0pOyAvLyBob2xkcyBhbiBhcnJheSBvZiBuYW1lL3ZhbHVlIGV4cHJlc3Npb24gcGFpcnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgIT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKFwiLFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZHZhbmNlKFwifVwiLCB0cnVlKTtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIC8vIE5VRCAtIHVuYXJ5IHByZWZpeCBmb3JtXG4gICAgICAgICAgICAgICAgdGhpcy5saHMgPSBhO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwidW5hcnlcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTEVEIC0gYmluYXJ5IGluZml4IGZvcm1cbiAgICAgICAgICAgICAgICB0aGlzLmxocyA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yaHMgPSBhO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdiaW5hcnknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdG9yXG4gICAgICAgIHByZWZpeChcIntcIiwgb2JqZWN0UGFyc2VyKTtcblxuICAgICAgICAvLyBvYmplY3QgZ3JvdXBpbmdcbiAgICAgICAgaW5maXgoXCJ7XCIsIG9wZXJhdG9yc1sneyddLCBvYmplY3RQYXJzZXIpO1xuXG4gICAgICAgIC8vIGlmL3RoZW4vZWxzZSB0ZXJuYXJ5IG9wZXJhdG9yID86XG4gICAgICAgIGluZml4KFwiP1wiLCBvcGVyYXRvcnNbJz8nXSwgZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9ICdjb25kaXRpb24nO1xuICAgICAgICAgICAgdGhpcy5jb25kaXRpb24gPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy50aGVuID0gZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgIGlmIChub2RlLmlkID09PSAnOicpIHtcbiAgICAgICAgICAgICAgICAvLyBlbHNlIGNvbmRpdGlvblxuICAgICAgICAgICAgICAgIGFkdmFuY2UoXCI6XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZWxzZSA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gb2JqZWN0IHRyYW5zZm9ybWVyXG4gICAgICAgIHByZWZpeChcInxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ3RyYW5zZm9ybSc7XG4gICAgICAgICAgICB0aGlzLnBhdHRlcm4gPSBleHByZXNzaW9uKDApO1xuICAgICAgICAgICAgYWR2YW5jZSgnfCcpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUgPSBleHByZXNzaW9uKDApO1xuICAgICAgICAgICAgaWYobm9kZS5pZCA9PT0gJywnKSB7XG4gICAgICAgICAgICAgICAgYWR2YW5jZSgnLCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlID0gZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoJ3wnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB0YWlsIGNhbGwgb3B0aW1pemF0aW9uXG4gICAgICAgIC8vIHRoaXMgaXMgaW52b2tlZCBieSB0aGUgcG9zdCBwYXJzZXIgdG8gYW5hbHlzZSBsYW1iZGEgZnVuY3Rpb25zIHRvIHNlZVxuICAgICAgICAvLyBpZiB0aGV5IG1ha2UgYSB0YWlsIGNhbGwuICBJZiBzbywgaXQgaXMgcmVwbGFjZWQgYnkgYSB0aHVuayB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIGludm9rZWQgYnkgdGhlIHRyYW1wb2xpbmUgbG9vcCBkdXJpbmcgZnVuY3Rpb24gYXBwbGljYXRpb24uXG4gICAgICAgIC8vIFRoaXMgZW5hYmxlcyB0YWlsLXJlY3Vyc2l2ZSBmdW5jdGlvbnMgdG8gYmUgd3JpdHRlbiB3aXRob3V0IGdyb3dpbmcgdGhlIHN0YWNrXG4gICAgICAgIHZhciB0YWlsX2NhbGxfb3B0aW1pemUgPSBmdW5jdGlvbihleHByKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgaWYoZXhwci50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRodW5rID0ge3R5cGU6ICdsYW1iZGEnLCB0aHVuazogdHJ1ZSwgYXJndW1lbnRzOiBbXSwgcG9zaXRpb246IGV4cHIucG9zaXRpb259O1xuICAgICAgICAgICAgICAgIHRodW5rLmJvZHkgPSBleHByO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRodW5rO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGV4cHIudHlwZSA9PT0gJ2NvbmRpdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBhbmFseXNlIGJvdGggYnJhbmNoZXNcbiAgICAgICAgICAgICAgICBleHByLnRoZW4gPSB0YWlsX2NhbGxfb3B0aW1pemUoZXhwci50aGVuKTtcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgZXhwci5lbHNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBleHByLmVsc2UgPSB0YWlsX2NhbGxfb3B0aW1pemUoZXhwci5lbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXhwcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZihleHByLnR5cGUgPT09ICdibG9jaycpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHRoZSBsYXN0IGV4cHJlc3Npb24gaW4gdGhlIGJsb2NrXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGV4cHIuZXhwcmVzc2lvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwci5leHByZXNzaW9uc1tsZW5ndGggLSAxXSA9IHRhaWxfY2FsbF9vcHRpbWl6ZShleHByLmV4cHJlc3Npb25zW2xlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXhwcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXhwcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcG9zdC1wYXJzZSBzdGFnZVxuICAgICAgICAvLyB0aGUgcHVycG9zZSBvZiB0aGlzIGlzIGZsYXR0ZW4gdGhlIHBhcnRzIG9mIHRoZSBBU1QgcmVwcmVzZW50aW5nIGxvY2F0aW9uIHBhdGhzLFxuICAgICAgICAvLyBjb252ZXJ0aW5nIHRoZW0gdG8gYXJyYXlzIG9mIHN0ZXBzIHdoaWNoIGluIHR1cm4gbWF5IGNvbnRhaW4gYXJyYXlzIG9mIHByZWRpY2F0ZXMuXG4gICAgICAgIC8vIGZvbGxvd2luZyB0aGlzLCBub2RlcyBjb250YWluaW5nICcuJyBhbmQgJ1snIHNob3VsZCBiZSBlbGltaW5hdGVkIGZyb20gdGhlIEFTVC5cbiAgICAgICAgdmFyIGFzdF9vcHRpbWl6ZSA9IGZ1bmN0aW9uIChleHByKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cHIudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsc3RlcCA9IGFzdF9vcHRpbWl6ZShleHByLmxocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6ICdwYXRoJywgc3RlcHM6IFtdfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobHN0ZXAudHlwZSA9PT0gJ3BhdGgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlc3VsdC5zdGVwcywgbHN0ZXAuc3RlcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGVwcyA9IFtsc3RlcF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN0ID0gYXN0X29wdGltaXplKGV4cHIucmhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN0LnR5cGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3QucHJvY2VkdXJlLnR5cGUgPT09ICdwYXRoJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdC5wcm9jZWR1cmUuc3RlcHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0LnByb2NlZHVyZS5zdGVwc1swXS50eXBlID09PSAnbmFtZScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGVwc1tyZXN1bHQuc3RlcHMubGVuZ3RoLTFdLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBmdW5jdGlvbiBpbiBjaGFpbiBvZiBmdW5jdGlvbnMgLSB3aWxsIG92ZXJyaWRlIGEgdGhlbmFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0ZXBzW3Jlc3VsdC5zdGVwcy5sZW5ndGgtMV0ubmV4dEZ1bmN0aW9uID0gcmVzdC5wcm9jZWR1cmUuc3RlcHNbMF0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3QudHlwZSAhPT0gJ3BhdGgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3QgPSB7dHlwZTogJ3BhdGgnLCBzdGVwczogW3Jlc3RdfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocmVzdWx0LnN0ZXBzLCByZXN0LnN0ZXBzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbnkgc3RlcHMgd2l0aGluIGEgcGF0aCB0aGF0IGFyZSBsaXRlcmFscywgc2hvdWxkIGJlIGNoYW5nZWQgdG8gJ25hbWUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0ZXBzLmZpbHRlcihmdW5jdGlvbihzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGVwLnR5cGUgPT09ICdsaXRlcmFsJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGxpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXQudHlwZSA9ICduYW1lJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbnkgc3RlcCB0aGF0IHNpZ25hbHMga2VlcGluZyBhIHNpbmdsZXRvbiBhcnJheSwgc2hvdWxkIGJlIGZsYWdnZWQgb24gdGhlIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQuc3RlcHMuZmlsdGVyKGZ1bmN0aW9uKHN0ZXApIHsgcmV0dXJuIHN0ZXAua2VlcEFycmF5ID09PSB0cnVlO30pLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmtlZXBTaW5nbGV0b25BcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGZpcnN0IHN0ZXAgaXMgYSBwYXRoIGNvbnN0cnVjdG9yLCBmbGFnIGl0IGZvciBzcGVjaWFsIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0LnN0ZXBzWzBdLnR5cGUgPT09ICd1bmFyeScgJiYgcmVzdWx0LnN0ZXBzWzBdLnZhbHVlID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0ZXBzWzBdLmNvbnNhcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJlZGljYXRlZCBzdGVwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTEhTIGlzIGEgc3RlcCBvciBhIHByZWRpY2F0ZWQgc3RlcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJIUyBpcyB0aGUgcHJlZGljYXRlIGV4cHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhc3Rfb3B0aW1pemUoZXhwci5saHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGVwID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdC50eXBlID09PSAncGF0aCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcCA9IHJlc3VsdC5zdGVwc1tyZXN1bHQuc3RlcHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RlcC5ncm91cCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDIwOVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0ZXAucHJlZGljYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwLnByZWRpY2F0ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwLnByZWRpY2F0ZS5wdXNoKGFzdF9vcHRpbWl6ZShleHByLnJocykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ3JvdXAtYnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMSFMgaXMgYSBzdGVwIG9yIGEgcHJlZGljYXRlZCBzdGVwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUkhTIGlzIHRoZSBvYmplY3QgY29uc3RydWN0b3IgZXhwclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFzdF9vcHRpbWl6ZShleHByLmxocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQuZ3JvdXAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAyMTBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdG9yIC0gcHJvY2VzcyBlYWNoIHBhaXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZ3JvdXAgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxoczogZXhwci5yaHMubWFwKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2FzdF9vcHRpbWl6ZShwYWlyWzBdKSwgYXN0X29wdGltaXplKHBhaXJbMV0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yZGVyLWJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTEhTIGlzIHRoZSBhcnJheSB0byBiZSBvcmRlcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUkhTIGRlZmluZXMgdGhlIHRlcm1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6ICdzb3J0JywgdmFsdWU6IGV4cHIudmFsdWUsIHBvc2l0aW9uOiBleHByLnBvc2l0aW9ufTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubGhzID0gYXN0X29wdGltaXplKGV4cHIubGhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmhzID0gZXhwci5yaHMubWFwKGZ1bmN0aW9uICh0ZXJtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY2VuZGluZzogdGVybXMuZGVzY2VuZGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGFzdF9vcHRpbWl6ZSh0ZXJtcy5leHByZXNzaW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnOj0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt0eXBlOiAnYmluZCcsIHZhbHVlOiBleHByLnZhbHVlLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmxocyA9IGFzdF9vcHRpbWl6ZShleHByLmxocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJocyA9IGFzdF9vcHRpbWl6ZShleHByLnJocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd+Pic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6ICdhcHBseScsIHZhbHVlOiBleHByLnZhbHVlLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmxocyA9IGFzdF9vcHRpbWl6ZShleHByLmxocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJocyA9IGFzdF9vcHRpbWl6ZShleHByLnJocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt0eXBlOiBleHByLnR5cGUsIHZhbHVlOiBleHByLnZhbHVlLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmxocyA9IGFzdF9vcHRpbWl6ZShleHByLmxocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJocyA9IGFzdF9vcHRpbWl6ZShleHByLnJocyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndW5hcnknOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogZXhwci50eXBlLCB2YWx1ZTogZXhwci52YWx1ZSwgcG9zaXRpb246IGV4cHIucG9zaXRpb259O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwci52YWx1ZSA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSBjb25zdHJ1Y3RvciAtIHByb2Nlc3MgZWFjaCBpdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXhwcmVzc2lvbnMgPSBleHByLmV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhc3Rfb3B0aW1pemUoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHByLnZhbHVlID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3RvciAtIHByb2Nlc3MgZWFjaCBwYWlyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubGhzID0gZXhwci5saHMubWFwKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthc3Rfb3B0aW1pemUocGFpclswXSksIGFzdF9vcHRpbWl6ZShwYWlyWzFdKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBvdGhlciB1bmFyeSBleHByZXNzaW9ucyAtIGp1c3QgcHJvY2VzcyB0aGUgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmV4cHJlc3Npb24gPSBhc3Rfb3B0aW1pemUoZXhwci5leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHVuYXJ5IG1pbnVzIG9uIGEgbnVtYmVyLCB0aGVuIHByZS1wcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwci52YWx1ZSA9PT0gJy0nICYmIHJlc3VsdC5leHByZXNzaW9uLnR5cGUgPT09ICdsaXRlcmFsJyAmJiBpc051bWVyaWMocmVzdWx0LmV4cHJlc3Npb24udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gLXJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgY2FzZSAncGFydGlhbCc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt0eXBlOiBleHByLnR5cGUsIG5hbWU6IGV4cHIubmFtZSwgdmFsdWU6IGV4cHIudmFsdWUsIHBvc2l0aW9uOiBleHByLnBvc2l0aW9ufTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFyZ3VtZW50cyA9IGV4cHIuYXJndW1lbnRzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXN0X29wdGltaXplKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHJvY2VkdXJlID0gYXN0X29wdGltaXplKGV4cHIucHJvY2VkdXJlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGFtYmRhJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6IGV4cHIudHlwZSwgYXJndW1lbnRzOiBleHByLmFyZ3VtZW50cywgc2lnbmF0dXJlOiBleHByLnNpZ25hdHVyZSwgcG9zaXRpb246IGV4cHIucG9zaXRpb259O1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keSA9IGFzdF9vcHRpbWl6ZShleHByLmJvZHkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYm9keSA9IHRhaWxfY2FsbF9vcHRpbWl6ZShib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29uZGl0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6IGV4cHIudHlwZSwgcG9zaXRpb246IGV4cHIucG9zaXRpb259O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY29uZGl0aW9uID0gYXN0X29wdGltaXplKGV4cHIuY29uZGl0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnRoZW4gPSBhc3Rfb3B0aW1pemUoZXhwci50aGVuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByLmVsc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZWxzZSA9IGFzdF9vcHRpbWl6ZShleHByLmVsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RyYW5zZm9ybSc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt0eXBlOiBleHByLnR5cGUsIHBvc2l0aW9uOiBleHByLnBvc2l0aW9ufTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBhdHRlcm4gPSBhc3Rfb3B0aW1pemUoZXhwci5wYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnVwZGF0ZSA9IGFzdF9vcHRpbWl6ZShleHByLnVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBleHByLmRlbGV0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kZWxldGUgPSBhc3Rfb3B0aW1pemUoZXhwci5kZWxldGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2NrJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6IGV4cHIudHlwZSwgcG9zaXRpb246IGV4cHIucG9zaXRpb259O1xuICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSBvZiBleHByZXNzaW9ucyAtIHByb2Nlc3MgZWFjaCBvbmVcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmV4cHJlc3Npb25zID0gZXhwci5leHByZXNzaW9ucy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhc3Rfb3B0aW1pemUoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHNjYW4gdGhlIGFycmF5IG9mIGV4cHJlc3Npb25zIHRvIHNlZSBpZiBhbnkgb2YgdGhlbSBhc3NpZ24gdmFyaWFibGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHNvLCBuZWVkIHRvIG1hcmsgdGhlIGJsb2NrIGFzIG9uZSB0aGF0IG5lZWRzIHRvIGNyZWF0ZSBhIG5ldyBmcmFtZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6ICdwYXRoJywgc3RlcHM6IFtleHByXX07XG4gICAgICAgICAgICAgICAgICAgIGlmKGV4cHIua2VlcEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQua2VlcFNpbmdsZXRvbkFycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdsaXRlcmFsJzpcbiAgICAgICAgICAgICAgICBjYXNlICd3aWxkY2FyZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGVzY2VuZGFudCc6XG4gICAgICAgICAgICAgICAgY2FzZSAndmFyaWFibGUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlZ2V4JzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZXhwcjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnb3BlcmF0b3InOlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdG9rZW5zICdhbmQnIGFuZCAnb3InIG1pZ2h0IGhhdmUgYmVlbiB1c2VkIGFzIGEgbmFtZSByYXRoZXIgdGhhbiBhbiBvcGVyYXRvclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwci52YWx1ZSA9PT0gJ2FuZCcgfHwgZXhwci52YWx1ZSA9PT0gJ29yJyB8fCBleHByLnZhbHVlID09PSAnaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByLnR5cGUgPSAnbmFtZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhc3Rfb3B0aW1pemUoZXhwcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqLyBpZiAoZXhwci52YWx1ZSA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJ0aWFsIGFwcGxpY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBleHByO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAyMDFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogZXhwci52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV4cHI7XG4gICAgICAgICAgICAgICAgICAgIGlmKGV4cHIubGhzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhc3Rfb3B0aW1pemUoZXhwci5saHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2RlID0gXCJTMDIwNlwiO1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwci5pZCA9PT0gJyhlbmQpJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IFwiUzAyMDdcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IGV4cHIudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYocmVjb3Zlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogJ2Vycm9yJywgZXJyb3I6IGVycn07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG5vdyBpbnZva2UgdGhlIHRva2VuaXplciBhbmQgdGhlIHBhcnNlciBhbmQgcmV0dXJuIHRoZSBzeW50YXggdHJlZVxuICAgICAgICBsZXhlciA9IHRva2VuaXplcihzb3VyY2UpO1xuICAgICAgICBhZHZhbmNlKCk7XG4gICAgICAgIC8vIHBhcnNlIHRoZSB0b2tlbnNcbiAgICAgICAgdmFyIGV4cHIgPSBleHByZXNzaW9uKDApO1xuICAgICAgICBpZiAobm9kZS5pZCAhPT0gJyhlbmQpJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMjAxXCIsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IG5vZGUucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgdG9rZW46IG5vZGUudmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGV4cHIgPSBhc3Rfb3B0aW1pemUoZXhwcik7XG5cbiAgICAgICAgaWYoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGV4cHIuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfTtcblxuICAgIC8vIFN0YXJ0IG9mIEV2YWx1YXRvciBjb2RlXG5cbiAgICB2YXIgc3RhdGljRnJhbWUgPSBjcmVhdGVGcmFtZShudWxsKTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHZhbHVlIGlzIGEgZmluaXRlIG51bWJlclxuICAgICAqIEBwYXJhbSB7ZmxvYXR9IG4gLSBudW1iZXIgdG8gZXZhbHVhdGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBuIGlzIGEgZmluaXRlIG51bWJlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtZXJpYyhuKSB7XG4gICAgICAgIHZhciBpc051bSA9IGZhbHNlO1xuICAgICAgICBpZih0eXBlb2YgbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhciBudW0gPSBwYXJzZUZsb2F0KG4pO1xuICAgICAgICAgICAgaXNOdW0gPSAhaXNOYU4obnVtKTtcbiAgICAgICAgICAgIGlmIChpc051bSAmJiAhaXNGaW5pdGUobnVtKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJEMTAwMVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2tcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc051bTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFyZyBpcyBhbiBhcnJheSBvZiBzdHJpbmdzXG4gICAgICogQHBhcmFtIHsqfSBhcmcgLSB0aGUgaXRlbSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYXJnIGlzIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5T2ZTdHJpbmdzKGFyZykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gKGFyZy5maWx0ZXIoZnVuY3Rpb24oaXRlbSl7cmV0dXJuIHR5cGVvZiBpdGVtICE9PSAnc3RyaW5nJzt9KS5sZW5ndGggPT09IDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBhcmcgaXMgYW4gYXJyYXkgb2YgbnVtYmVyc1xuICAgICAqIEBwYXJhbSB7Kn0gYXJnIC0gdGhlIGl0ZW0gdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGFyZyBpcyBhbiBhcnJheSBvZiBudW1iZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheU9mTnVtYmVycyhhcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBpZihBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChhcmcuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pe3JldHVybiAhaXNOdW1lcmljKGl0ZW0pO30pLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBQb2x5ZmlsbFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgTnVtYmVyLmlzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICAgIGlzRmluaXRlKHZhbHVlKSAmJlxuICAgICAgICAgIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgZXhwcmVzc2lvbiBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIHZhciBlbnRyeUNhbGxiYWNrID0gZW52aXJvbm1lbnQubG9va3VwKCdfX2V2YWx1YXRlX2VudHJ5Jyk7XG4gICAgICAgIGlmKGVudHJ5Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIGVudHJ5Q2FsbGJhY2soZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdwYXRoJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlUGF0aChleHByLnN0ZXBzLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVNlcXVlbmNlKHJlc3VsdCwgZXhwci5rZWVwU2luZ2xldG9uQXJyYXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlQmluYXJ5KGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd1bmFyeSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZVVuYXJ5KGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZU5hbWUoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xpdGVyYWwnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlTGl0ZXJhbChleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2lsZGNhcmQnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlV2lsZGNhcmQoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Rlc2NlbmRhbnQnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlRGVzY2VuZGFudHMoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbmRpdGlvbic6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZUNvbmRpdGlvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2snOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVCbG9jayhleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmluZCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZUJpbmRFeHByZXNzaW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZWdleCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVSZWdleChleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVGdW5jdGlvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndmFyaWFibGUnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlVmFyaWFibGUoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xhbWJkYSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVMYW1iZGEoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3BhcnRpYWwnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVQYXJ0aWFsQXBwbGljYXRpb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FwcGx5JzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlQXBwbHlFeHByZXNzaW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzb3J0JzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlU29ydEV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RyYW5zZm9ybSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVUcmFuc2Zvcm1FeHByZXNzaW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZihlbnZpcm9ubWVudC5sb29rdXAoJ19fanNvbmF0YV9hc3luYycpICYmXG4gICAgICAgICAgKHR5cGVvZiByZXN1bHQgPT09ICd1bmRlZmluZWQnIHx8IHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0LnRoZW4gIT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZihlbnZpcm9ubWVudC5sb29rdXAoJ19fanNvbmF0YV9hc3luYycpICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJiBleHByLm5leHRGdW5jdGlvbiAmJiB0eXBlb2YgcmVzdWx0W2V4cHIubmV4dEZ1bmN0aW9uXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gYWx0aG91Z2ggdGhpcyBpcyBhICd0aGVuYWJsZScsIGl0IGlzIGNoYWluaW5nIGEgZGlmZmVyZW50IGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyBzbyBkb24ndCB5aWVsZCBzaW5jZSB5aWVsZGluZyB3aWxsIHRyaWdnZXIgdGhlIC50aGVuKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHJlc3VsdDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKGV4cHIuaGFzT3duUHJvcGVydHkoJ3ByZWRpY2F0ZScpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGFwcGx5UHJlZGljYXRlcyhleHByLnByZWRpY2F0ZSwgcmVzdWx0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICByZXN1bHQgPSBub3JtYWxpemVTZXF1ZW5jZShyZXN1bHQpO1xuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cHIuaGFzT3duUHJvcGVydHkoJ2dyb3VwJykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVHcm91cEV4cHJlc3Npb24oZXhwci5ncm91cCwgcmVzdWx0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhpdENhbGxiYWNrID0gZW52aXJvbm1lbnQubG9va3VwKCdfX2V2YWx1YXRlX2V4aXQnKTtcbiAgICAgICAgaWYoZXhpdENhbGxiYWNrKSB7XG4gICAgICAgICAgICBleGl0Q2FsbGJhY2soZXhwciwgaW5wdXQsIGVudmlyb25tZW50LCByZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBwYXRoIGV4cHJlc3Npb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBldmFsdWF0ZVBhdGgoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciBpbnB1dFNlcXVlbmNlO1xuICAgICAgICAvLyBleHByIGlzIGFuIGFycmF5IG9mIHN0ZXBzXG4gICAgICAgIC8vIGlmIHRoZSBmaXJzdCBzdGVwIGlzIGEgdmFyaWFibGUgcmVmZXJlbmNlICgkLi4uKSwgaW5jbHVkaW5nIHJvb3QgcmVmZXJlbmNlICgkJCksXG4gICAgICAgIC8vICAgdGhlbiB0aGUgcGF0aCBpcyBhYnNvbHV0ZSByYXRoZXIgdGhhbiByZWxhdGl2ZVxuICAgICAgICBpZiAoZXhwclswXS50eXBlID09PSAndmFyaWFibGUnKSB7XG4gICAgICAgICAgICBpbnB1dFNlcXVlbmNlID0gW2lucHV0XTsgLy8gZHVtbXkgc2luZ2xldG9uIHNlcXVlbmNlIGZvciBmaXJzdCAoYWJzb2x1dGUpIHN0ZXBcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgaW5wdXRTZXF1ZW5jZSA9IGlucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgaW5wdXQgaXMgbm90IGFuIGFycmF5LCBtYWtlIGl0IHNvXG4gICAgICAgICAgICBpbnB1dFNlcXVlbmNlID0gW2lucHV0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHRTZXF1ZW5jZTtcblxuICAgICAgICAvLyBldmFsdWF0ZSBlYWNoIHN0ZXAgaW4gdHVyblxuICAgICAgICBmb3IodmFyIGlpID0gMDsgaWkgPCBleHByLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSBleHByW2lpXTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIGZpcnN0IHN0ZXAgaXMgYW4gZXhwbGljaXQgYXJyYXkgY29uc3RydWN0b3IsIHRoZW4ganVzdCBldmFsdWF0ZSB0aGF0IChpLmUuIGRvbid0IGl0ZXJhdGUgb3ZlciBhIGNvbnRleHQgYXJyYXkpXG4gICAgICAgICAgICBpZihpaSA9PT0gMCAmJiBzdGVwLmNvbnNhcnJheSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFNlcXVlbmNlID0geWllbGQgKiBldmFsdWF0ZShzdGVwLCBpbnB1dFNlcXVlbmNlLCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFNlcXVlbmNlID0geWllbGQgKiBldmFsdWF0ZVN0ZXAoc3RlcCwgaW5wdXRTZXF1ZW5jZSwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0eXBlb2YgcmVzdWx0U2VxdWVuY2UgPT09ICd1bmRlZmluZWQnIHx8IHJlc3VsdFNlcXVlbmNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRTZXF1ZW5jZSA9IHJlc3VsdFNlcXVlbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFNlcXVlbmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBhIEpTT05hdGEgc2VxdWVuY2UgLSBzaW5nbGV0b24gYXJyYXlzIGJlY29tZSBhdG9taWMgdmFsdWVzXG4gICAgICogQHBhcmFtIHtBcnJheX0gc2VxdWVuY2UgLSBpbnB1dCBzZXF1ZW5jZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0ga2VlcFNpbmdsZXRvbiAtIGtlZXAgc2luZ2xldG9uIHNlcXVlbmNlcyBhcyBhcnJheXNcbiAgICAgKiBAcmV0dXJucyB7Kn0gbm9ybWFsaXplZCBzZXF1ZW5jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVNlcXVlbmNlKHNlcXVlbmNlLCBrZWVwU2luZ2xldG9uKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmKHR5cGVvZiBzZXF1ZW5jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmKCFBcnJheS5pc0FycmF5KHNlcXVlbmNlKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc2VxdWVuY2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VxdWVuY2UubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZihrZWVwU2luZ2xldG9uKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VxdWVuY2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNlcXVlbmNlWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNlcXVlbmNlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNlcXVlbmNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgYSBzdGVwIHdpdGhpbiBhIHBhdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlU3RlcChleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG5cbiAgICAgICAgZm9yKHZhciBpaSA9IDA7IGlpIDwgaW5wdXQubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0geWllbGQgKiBldmFsdWF0ZShleHByLCBpbnB1dFtpaV0sIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgIGlmICghKEFycmF5LmlzQXJyYXkocmVzKSAmJiAoZXhwci52YWx1ZSAhPT0gJ1snICkpICYmICFleHByLmNvbnNhcnJheSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IFtyZXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaXMgcmVzIGFuIGFycmF5IC0gaWYgc28sIGZsYXR0ZW4gaXQgaW50byB0aGUgcGFyZW50IGFycmF5XG4gICAgICAgICAgICByZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5uZXJSZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlubmVyUmVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbm5lclJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBwcmVkaWNhdGVzIHRvIGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJlZGljYXRlcyAtIFByZWRpY2F0ZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGFwcGx5IHByZWRpY2F0ZXMgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IFJlc3VsdCBhZnRlciBhcHBseWluZyBwcmVkaWNhdGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGFwcGx5UHJlZGljYXRlcyhwcmVkaWNhdGVzLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIGlucHV0U2VxdWVuY2UgPSBpbnB1dDtcbiAgICAgICAgLy8gbGhzIHBvdGVudGlhbGx5IGhvbGRzIGFuIGFycmF5XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gaXRlcmF0ZSBvdmVyIHRoZSBhcnJheSwgYW5kIG9ubHkga2VlcCB0aGUgaXRlbXMgdGhhdCBhcmVcbiAgICAgICAgLy8gdHJ1dGh5IHdoZW4gYXBwbGllZCB0byB0aGUgcHJlZGljYXRlLlxuICAgICAgICAvLyBpZiB0aGUgcHJlZGljYXRlIGV2YWx1YXRlcyB0byBhbiBpbnRlZ2VyLCB0aGVuIHNlbGVjdCB0aGF0IGluZGV4XG5cbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yKHZhciBpaSA9IDA7IGlpIDwgcHJlZGljYXRlcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgIHZhciBwcmVkaWNhdGUgPSBwcmVkaWNhdGVzW2lpXTtcbiAgICAgICAgICAgIC8vIGlmIGl0J3Mgbm90IGFuIGFycmF5LCB0dXJuIGl0IGludG8gb25lXG4gICAgICAgICAgICAvLyBzaW5jZSBpbiBYUGF0aCA+PSAyLjAgYW4gaXRlbSBpcyBlcXVpdmFsZW50IHRvIGEgc2luZ2xldG9uIHNlcXVlbmNlIG9mIHRoYXQgaXRlbVxuICAgICAgICAgICAgLy8gaWYgaW5wdXQgaXMgbm90IGFuIGFycmF5LCBtYWtlIGl0IHNvXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXRTZXF1ZW5jZSkpIHtcbiAgICAgICAgICAgICAgICBpbnB1dFNlcXVlbmNlID0gW2lucHV0U2VxdWVuY2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZS50eXBlID09PSAnbGl0ZXJhbCcgJiYgaXNOdW1lcmljKHByZWRpY2F0ZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwcmVkaWNhdGUudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByb3VuZCBpdCBkb3duXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcihpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY291bnQgaW4gZnJvbSBlbmQgb2YgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpbnB1dFNlcXVlbmNlLmxlbmd0aCArIGluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzID0gaW5wdXRTZXF1ZW5jZVtpbmRleF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSB5aWVsZCAqIGV2YWx1YXRlRmlsdGVyKHByZWRpY2F0ZSwgaW5wdXRTZXF1ZW5jZSwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRTZXF1ZW5jZSA9IHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgZmlsdGVyIHByZWRpY2F0ZSB0byBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByZWRpY2F0ZSAtIGZpbHRlciBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBhcHBseSBwcmVkaWNhdGVzIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXN1bHQgYWZ0ZXIgYXBwbHlpbmcgcHJlZGljYXRlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBldmFsdWF0ZUZpbHRlcihwcmVkaWNhdGUsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IodmFyIGluZGV4ID0gMDsgaW5kZXggPCBpbnB1dC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gaW5wdXRbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIHJlcyA9IHlpZWxkICogZXZhbHVhdGUocHJlZGljYXRlLCBpdGVtLCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICBpZiAoaXNOdW1lcmljKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBbcmVzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGlzQXJyYXlPZk51bWJlcnMocmVzKSkge1xuICAgICAgICAgICAgICAgIHJlcy5mb3JFYWNoKGZ1bmN0aW9uKGlyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGlyZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByb3VuZCBpdCBkb3duXG4gICAgICAgICAgICAgICAgICAgICAgICBpcmVzID0gTWF0aC5mbG9vcihpcmVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXJlcyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvdW50IGluIGZyb20gZW5kIG9mIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICBpcmVzID0gaW5wdXQubGVuZ3RoICsgaXJlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXJlcyA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmdW5jdGlvbkJvb2xlYW4ocmVzKSkgeyAvLyB0cnV0aHlcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgYmluYXJ5IGV4cHJlc3Npb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICogZXZhbHVhdGVCaW5hcnkoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBsaHMgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIubGhzLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICB2YXIgcmhzID0geWllbGQgKiBldmFsdWF0ZShleHByLnJocywgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgdmFyIG9wID0gZXhwci52YWx1ZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZU51bWVyaWNFeHByZXNzaW9uKGxocywgcmhzLCBvcCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZUNvbXBhcmlzb25FeHByZXNzaW9uKGxocywgcmhzLCBvcCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZVN0cmluZ0NvbmNhdChsaHMsIHJocyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FuZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnb3InOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZUJvb2xlYW5FeHByZXNzaW9uKGxocywgcmhzLCBvcCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJy4uJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVSYW5nZUV4cHJlc3Npb24obGhzLCByaHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdpbic6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlSW5jbHVkZXNFeHByZXNzaW9uKGxocywgcmhzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICBlcnIucG9zaXRpb24gPSBleHByLnBvc2l0aW9uO1xuICAgICAgICAgICAgZXJyLnRva2VuID0gb3A7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSB1bmFyeSBleHByZXNzaW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVVbmFyeShleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBzd2l0Y2ggKGV4cHIudmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5leHByZXNzaW9uLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChpc051bWVyaWMocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAtcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiRDEwMDJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogZXhwci52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICAvLyBhcnJheSBjb25zdHJ1Y3RvciAtIGV2YWx1YXRlIGVhY2ggaXRlbVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaWkgPSAwOyBpaSA8IGV4cHIuZXhwcmVzc2lvbnMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZXhwci5leHByZXNzaW9uc1tpaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHlpZWxkICogZXZhbHVhdGUoaXRlbSwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0udmFsdWUgPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuY3Rpb25BcHBlbmQocmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0b3IgLSBhcHBseSBncm91cGluZ1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVHcm91cEV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgbmFtZSBvYmplY3QgYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlTmFtZShleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgLy8gbG9va3VwIHRoZSAnbmFtZScgaXRlbSBpbiB0aGUgaW5wdXRcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvcih2YXIgaWkgPSAwOyBpaSA8IGlucHV0Lmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSAgZXZhbHVhdGVOYW1lKGV4cHIsIGlucHV0W2lpXSwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChyZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCAhPT0gbnVsbCAmJiB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpbnB1dFtleHByLnZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBub3JtYWxpemVTZXF1ZW5jZShyZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGxpdGVyYWwgYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmFsdWF0ZUxpdGVyYWwoZXhwcikge1xuICAgICAgICByZXR1cm4gZXhwci52YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSB3aWxkY2FyZCBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlV2lsZGNhcmQoZXhwciwgaW5wdXQpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgaWYgKGlucHV0ICE9PSBudWxsICYmIHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGlucHV0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZmxhdHRlbih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBmdW5jdGlvbkFwcGVuZChyZXN1bHRzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVNlcXVlbmNlKHJlc3VsdHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmbGF0dGVuZWQgYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmcgLSB0aGUgYXJyYXkgdG8gYmUgZmxhdHRlblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZsYXR0ZW5lZCAtIGNhcnJpZXMgdGhlIGZsYXR0ZW5lZCBhcnJheSAtIGlmIG5vdCBkZWZpbmVkLCB3aWxsIGluaXRpYWxpemUgdG8gW11cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IC0gdGhlIGZsYXR0ZW5lZCBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJnLCBmbGF0dGVuZWQpIHtcbiAgICAgICAgaWYodHlwZW9mIGZsYXR0ZW5lZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGZsYXR0ZW5lZCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgYXJnLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBmbGF0dGVuKGl0ZW0sIGZsYXR0ZW5lZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZsYXR0ZW5lZC5wdXNoKGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBkZXNjZW5kYW50cyBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlRGVzY2VuZGFudHMoZXhwciwgaW5wdXQpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHJlc3VsdFNlcXVlbmNlID0gW107XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyB0cmF2ZXJzZSBhbGwgZGVzY2VuZGFudHMgb2YgdGhpcyBvYmplY3QvYXJyYXlcbiAgICAgICAgICAgIHJlY3Vyc2VEZXNjZW5kYW50cyhpbnB1dCwgcmVzdWx0U2VxdWVuY2UpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdFNlcXVlbmNlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFNlcXVlbmNlWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRTZXF1ZW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2UgdGhyb3VnaCBkZXNjZW5kYW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0cyAtIFJlc3VsdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWN1cnNlRGVzY2VuZGFudHMoaW5wdXQsIHJlc3VsdHMpIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiAvLyogaW4gWFBhdGhcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGlucHV0LmZvckVhY2goZnVuY3Rpb24gKG1lbWJlcikge1xuICAgICAgICAgICAgICAgIHJlY3Vyc2VEZXNjZW5kYW50cyhtZW1iZXIsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQgIT09IG51bGwgJiYgdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoaW5wdXQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJlY3Vyc2VEZXNjZW5kYW50cyhpbnB1dFtrZXldLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgbnVtZXJpYyBleHByZXNzaW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsaHMgLSBMSFMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmhzIC0gUkhTIHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wIC0gb3Bjb2RlXG4gICAgICogQHJldHVybnMgeyp9IFJlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlTnVtZXJpY0V4cHJlc3Npb24obGhzLCByaHMsIG9wKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiByaHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBpZiBlaXRoZXIgc2lkZSBpcyB1bmRlZmluZWQsIHRoZSByZXN1bHQgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bWVyaWMobGhzKSkge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMDFcIixcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGhzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNOdW1lcmljKHJocykpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlQyMDAyXCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJoc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyArIHJocztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyAtIHJocztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyAqIHJocztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyAvIHJocztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyAlIHJocztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGNvbXBhcmlzb24gZXhwcmVzc2lvbiBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGhzIC0gTEhTIHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJocyAtIFJIUyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcCAtIG9wY29kZVxuICAgICAqIEByZXR1cm5zIHsqfSBSZXN1bHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmFsdWF0ZUNvbXBhcmlzb25FeHByZXNzaW9uKGxocywgcmhzLCBvcCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIHR5cGUgY2hlY2tzXG4gICAgICAgIHZhciBsdHlwZSA9IHR5cGVvZiBsaHM7XG4gICAgICAgIHZhciBydHlwZSA9IHR5cGVvZiByaHM7XG5cbiAgICAgICAgaWYgKGx0eXBlID09PSAndW5kZWZpbmVkJyB8fCBydHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIGlmIGVpdGhlciBzaWRlIGlzIHVuZGVmaW5lZCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBpZiBhYSBvciBiYiBhcmUgbm90IHN0cmluZyBvciBudW1lcmljIHZhbHVlcywgdGhlbiB0aHJvdyBhbiBlcnJvclxuICAgICAgICAgICAgaWYgKCEobHR5cGUgPT09ICdzdHJpbmcnIHx8IGx0eXBlID09PSAnbnVtYmVyJykgfHwgIShydHlwZSA9PT0gJ3N0cmluZycgfHwgcnR5cGUgPT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJUMjAxMFwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEobHR5cGUgPT09ICdzdHJpbmcnIHx8IGx0eXBlID09PSAnbnVtYmVyJykgPyBsaHMgOiByaHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2lmIGFhIGFuZCBiYiBhcmUgbm90IG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgICAgICAgIGlmIChsdHlwZSAhPT0gcnR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMDlcIixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBsaHMsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlMjogcmhzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgICAgICBjYXNlICc9JzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsaHMgPT09IHJocztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAobGhzICE9PSByaHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsaHMgPCByaHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsaHMgPD0gcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsaHMgPiByaHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsaHMgPj0gcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5jbHVzaW9uIG9wZXJhdG9yIC0gaW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsaHMgLSBMSFMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmhzIC0gUkhTIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSBpZiBsaHMgaXMgYSBtZW1iZXIgb2YgcmhzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVJbmNsdWRlc0V4cHJlc3Npb24obGhzLCByaHMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgcmhzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gaWYgZWl0aGVyIHNpZGUgaXMgdW5kZWZpbmVkLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZighQXJyYXkuaXNBcnJheShyaHMpKSB7XG4gICAgICAgICAgICByaHMgPSBbcmhzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCByaHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmKHJoc1tpXSA9PT0gbGhzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgYm9vbGVhbiBleHByZXNzaW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsaHMgLSBMSFMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmhzIC0gUkhTIHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wIC0gb3Bjb2RlXG4gICAgICogQHJldHVybnMgeyp9IFJlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlQm9vbGVhbkV4cHJlc3Npb24obGhzLCByaHMsIG9wKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICAgICAgY2FzZSAnYW5kJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jdGlvbkJvb2xlYW4obGhzKSAmJiBmdW5jdGlvbkJvb2xlYW4ocmhzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ29yJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jdGlvbkJvb2xlYW4obGhzKSB8fCBmdW5jdGlvbkJvb2xlYW4ocmhzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHN0cmluZyBjb25jYXRlbmF0aW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsaHMgLSBMSFMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmhzIC0gUkhTIHZhbHVlXG4gICAgICogQHJldHVybnMge3N0cmluZ3wqfSBDb25jYXRlbmF0ZWQgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVTdHJpbmdDb25jYXQobGhzLCByaHMpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICB2YXIgbHN0ciA9ICcnO1xuICAgICAgICB2YXIgcnN0ciA9ICcnO1xuICAgICAgICBpZiAodHlwZW9mIGxocyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxzdHIgPSBmdW5jdGlvblN0cmluZyhsaHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmhzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcnN0ciA9IGZ1bmN0aW9uU3RyaW5nKHJocyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBsc3RyLmNvbmNhdChyc3RyKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBncm91cCBleHByZXNzaW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7e319IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlR3JvdXBFeHByZXNzaW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHZhciBncm91cHMgPSB7fTtcbiAgICAgICAgLy8gZ3JvdXAgdGhlIGlucHV0IHNlcXVlbmNlIGJ5ICdrZXknIGV4cHJlc3Npb25cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgaW5wdXQgPSBbaW5wdXRdO1xuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgaXRlbUluZGV4ID0gMDsgaXRlbUluZGV4IDwgaW5wdXQubGVuZ3RoOyBpdGVtSW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpbnB1dFtpdGVtSW5kZXhdO1xuICAgICAgICAgICAgZm9yKHZhciBwYWlySW5kZXggPSAwOyBwYWlySW5kZXggPCBleHByLmxocy5sZW5ndGg7IHBhaXJJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhaXIgPSBleHByLmxoc1twYWlySW5kZXhdO1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSB5aWVsZCAqIGV2YWx1YXRlKHBhaXJbMF0sIGl0ZW0sIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICAvLyBrZXkgaGFzIHRvIGJlIGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQxMDAzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGtleVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB7ZGF0YTogaXRlbSwgZXhwcjogcGFpclsxXX07XG4gICAgICAgICAgICAgICAgaWYgKGdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgdmFsdWUgYWxyZWFkeSBleGlzdHMgaW4gdGhpcyBzbG90XG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBpdCBhcyBhbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICBncm91cHNba2V5XS5kYXRhID0gZnVuY3Rpb25BcHBlbmQoZ3JvdXBzW2tleV0uZGF0YSwgaXRlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzW2tleV0gPSBlbnRyeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpdGVyYXRlIG92ZXIgdGhlIGdyb3VwcyB0byBldmFsdWF0ZSB0aGUgJ3ZhbHVlJyBleHByZXNzaW9uXG4gICAgICAgIGZvciAoa2V5IGluIGdyb3Vwcykge1xuICAgICAgICAgICAgZW50cnkgPSBncm91cHNba2V5XTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHlpZWxkICogZXZhbHVhdGUoZW50cnkuZXhwciwgZW50cnkuZGF0YSwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgaWYodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHJhbmdlIGV4cHJlc3Npb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxocyAtIExIUyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByaHMgLSBSSFMgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJlc3VsdGFudCBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlUmFuZ2VFeHByZXNzaW9uKGxocywgcmhzKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiByaHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBpZiBlaXRoZXIgc2lkZSBpcyB1bmRlZmluZWQsIHRoZSByZXN1bHQgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxocyA+IHJocykge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGxocyBpcyBncmVhdGVyIHRoYW4gdGhlIHJocywgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihsaHMpKSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgY29kZTogXCJUMjAwM1wiLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBsaHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHJocykpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlQyMDA0XCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJoc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShyaHMgLSBsaHMgKyAxKTtcbiAgICAgICAgZm9yICh2YXIgaXRlbSA9IGxocywgaW5kZXggPSAwOyBpdGVtIDw9IHJoczsgaXRlbSsrLCBpbmRleCsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGJpbmQgZXhwcmVzc2lvbiBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlQmluZEV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIC8vIFRoZSBSSFMgaXMgdGhlIGV4cHJlc3Npb24gdG8gZXZhbHVhdGVcbiAgICAgICAgLy8gVGhlIExIUyBpcyB0aGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgdG8gYmluZCB0byAtIHNob3VsZCBiZSBhIFZBUklBQkxFIHRva2VuXG4gICAgICAgIHZhciB2YWx1ZSA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5yaHMsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgIGlmIChleHByLmxocy50eXBlICE9PSAndmFyaWFibGUnKSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgY29kZTogXCJEMjAwNVwiLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHRva2VuOiBleHByLnZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBleHByLmxocy50eXBlID09PSAncGF0aCcgPyBleHByLmxocy5zdGVwc1swXS52YWx1ZSA6IGV4cHIubGhzLnZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVudmlyb25tZW50LmJpbmQoZXhwci5saHMudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGNvbmRpdGlvbiBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlQ29uZGl0aW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgY29uZGl0aW9uID0geWllbGQgKiBldmFsdWF0ZShleHByLmNvbmRpdGlvbiwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgaWYgKGZ1bmN0aW9uQm9vbGVhbihjb25kaXRpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIudGhlbiwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwci5lbHNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZShleHByLmVsc2UsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBibG9jayBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlQmxvY2soZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBmcmFtZSB0byBsaW1pdCB0aGUgc2NvcGUgb2YgdmFyaWFibGUgYXNzaWdubWVudHNcbiAgICAgICAgLy8gVE9ETywgb25seSBkbyB0aGlzIGlmIHRoZSBwb3N0LXBhcnNlIHN0YWdlIGhhcyBmbGFnZ2VkIHRoaXMgYXMgcmVxdWlyZWRcbiAgICAgICAgdmFyIGZyYW1lID0gY3JlYXRlRnJhbWUoZW52aXJvbm1lbnQpO1xuICAgICAgICAvLyBpbnZva2UgZWFjaCBleHByZXNzaW9uIGluIHR1cm5cbiAgICAgICAgLy8gb25seSByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBvbmVcbiAgICAgICAgZm9yKHZhciBpaSA9IDA7IGlpIDwgZXhwci5leHByZXNzaW9ucy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5leHByZXNzaW9uc1tpaV0sIGlucHV0LCBmcmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgYSByZWdleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gZXhwcmVzc2lvbiBjb250YWluaW5nIHJlZ2V4XG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBIaWdoZXIgb3JkZXIgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHByZXBhcmVkIHJlZ2V4XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVSZWdleChleHByKSB7XG4gICAgICAgIGV4cHIudmFsdWUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIGNsb3N1cmUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHZhciByZSA9IGV4cHIudmFsdWU7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gcmUuZXhlYyhzdHIpO1xuICAgICAgICAgICAgaWYobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoOiBtYXRjaFswXSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG1hdGNoLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBncm91cHM6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZihtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBtYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmdyb3Vwcy5wdXNoKG1hdGNoW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZihyZS5sYXN0SW5kZXggPj0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gY2xvc3VyZShzdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobmV4dCAmJiBuZXh0Lm1hdGNoID09PSAnJyAmJiByZS5sYXN0SW5kZXggPT09IGV4cHIudmFsdWUubGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hlcyB6ZXJvIGxlbmd0aCBzdHJpbmc7IHRoaXMgd2lsbCBuZXZlciBwcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJEMTAwNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBleHByLnZhbHVlLnNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbG9zdXJlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHZhcmlhYmxlIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmFsdWF0ZVZhcmlhYmxlKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICAvLyBsb29rdXAgdGhlIHZhcmlhYmxlIHZhbHVlIGluIHRoZSBlbnZpcm9ubWVudFxuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAvLyBpZiB0aGUgdmFyaWFibGUgbmFtZSBpcyBlbXB0eSBzdHJpbmcsIHRoZW4gaXQgcmVmZXJzIHRvIGNvbnRleHQgdmFsdWVcbiAgICAgICAgaWYgKGV4cHIudmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGVudmlyb25tZW50Lmxvb2t1cChleHByLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNvcnQgLyBvcmRlci1ieSBvcGVyYXRvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gQVNUIGZvciBvcGVyYXRvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IE9yZGVyZWQgc2VxdWVuY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVTb3J0RXhwcmVzc2lvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyBldmFsdWF0ZSB0aGUgbGhzLCB0aGVuIHNvcnQgdGhlIHJlc3VsdHMgaW4gb3JkZXIgYWNjb3JkaW5nIHRvIHJocyBleHByZXNzaW9uXG4gICAgICAgIHZhciBsaHMgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIubGhzLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuXG4gICAgICAgIC8vIHNvcnQgdGhlIGxocyBhcnJheVxuICAgICAgICAvLyB1c2UgY29tcGFyYXRvciBmdW5jdGlvblxuICAgICAgICB2YXIgY29tcGFyYXRvciA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIC8vIGV4cHIucmhzIGlzIGFuIGFycmF5IG9mIG9yZGVyLWJ5IGluIHByaW9yaXR5IG9yZGVyXG4gICAgICAgICAgICB2YXIgY29tcCA9IDA7XG4gICAgICAgICAgICBmb3IodmFyIGluZGV4ID0gMDsgY29tcCA9PT0gMCAmJiBpbmRleCA8IGV4cHIucmhzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHZhciB0ZXJtID0gZXhwci5yaHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIC8vZXZhbHVhdGUgdGhlIHJocyBleHByZXNzaW9uIGluIHRoZSBjb250ZXh0IG9mIGFcbiAgICAgICAgICAgICAgICB2YXIgYWEgPSBkcml2ZUdlbmVyYXRvcih0ZXJtLmV4cHJlc3Npb24sIGEsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICAvL2V2YWx1YXRlIHRoZSByaHMgZXhwcmVzc2lvbiBpbiB0aGUgY29udGV4dCBvZiBiXG4gICAgICAgICAgICAgICAgdmFyIGJiID0gZHJpdmVHZW5lcmF0b3IodGVybS5leHByZXNzaW9uLCBiLCBlbnZpcm9ubWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyB0eXBlIGNoZWNrc1xuICAgICAgICAgICAgICAgIHZhciBhdHlwZSA9IHR5cGVvZiBhYTtcbiAgICAgICAgICAgICAgICB2YXIgYnR5cGUgPSB0eXBlb2YgYmI7XG4gICAgICAgICAgICAgICAgLy8gdW5kZWZpbmVkIHNob3VsZCBiZSBsYXN0IGluIHNvcnQgb3JkZXJcbiAgICAgICAgICAgICAgICBpZihhdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3dhcCB0aGVtLCB1bmxlc3MgYnR5cGUgaXMgYWxzbyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgY29tcCA9IChidHlwZSA9PT0gJ3VuZGVmaW5lZCcpID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihidHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBhYSBvciBiYiBhcmUgbm90IHN0cmluZyBvciBudW1lcmljIHZhbHVlcywgdGhlbiB0aHJvdyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIGlmKCEoYXR5cGUgPT09ICdzdHJpbmcnIHx8IGF0eXBlID09PSAnbnVtYmVyJykgfHwgIShidHlwZSA9PT0gJ3N0cmluZycgfHwgYnR5cGUgPT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQyMDA4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEoYXR5cGUgPT09ICdzdHJpbmcnIHx8IGF0eXBlID09PSAnbnVtYmVyJykgPyBhYSA6IGJiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9pZiBhYSBhbmQgYmIgYXJlIG5vdCBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAgICAgICAgICAgaWYoYXR5cGUgIT09IGJ0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMDdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYWEsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTI6IGJiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGFhID09PSBiYikge1xuICAgICAgICAgICAgICAgICAgICAvLyBib3RoIHRoZSBzYW1lIC0gbW92ZSBvbiB0byBuZXh0IHRlcm1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhYSA8IGJiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXAgPSAtMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21wID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYodGVybS5kZXNjZW5kaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXAgPSAtY29tcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvbmx5IHN3YXAgYSAmIGIgaWYgY29tcCBlcXVhbHMgMVxuICAgICAgICAgICAgcmV0dXJuIGNvbXAgPT09IDE7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVzdWx0ID0gZnVuY3Rpb25Tb3J0KGxocywgY29tcGFyYXRvcik7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgYSB0cmFuc2Zvcm1lciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gQVNUIGZvciBvcGVyYXRvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IHRyYW5mb3JtZXIgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmFsdWF0ZVRyYW5zZm9ybUV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIGZ1bmN0aW9uIHRvIGltcGxlbWVudCB0aGUgdHJhbnNmb3JtIGRlZmluaXRpb25cbiAgICAgICAgdmFyIHRyYW5zZm9ybWVyID0gZnVuY3Rpb24qKG9iaikgeyAvLyBzaWduYXR1cmUgPChvYSk6bz5cbiAgICAgICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgY29weSBvZiBvYmogd2l0aCBjaGFuZ2VzIHNwZWNpZmllZCBieSB0aGUgcGF0dGVybi9vcGVyYXRpb25cbiAgICAgICAgICAgIHZhciBjbG9uZUZ1bmN0aW9uID0gZW52aXJvbm1lbnQubG9va3VwKCdjbG9uZScpO1xuICAgICAgICAgICAgaWYoIWlzRnVuY3Rpb24oY2xvbmVGdW5jdGlvbikpIHtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyB0eXBlIGVycm9yXG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQyMDEzXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0geWllbGQgKiBhcHBseShjbG9uZUZ1bmN0aW9uLCBbb2JqXSwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIucGF0dGVybiwgcmVzdWx0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICBpZih0eXBlb2YgbWF0Y2hlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBpZighQXJyYXkuaXNBcnJheShtYXRjaGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gW21hdGNoZXNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IodmFyIGlpID0gMDsgaWkgPCBtYXRjaGVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBtYXRjaGVzW2lpXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZhbHVhdGUgdGhlIHVwZGF0ZSB2YWx1ZSBmb3IgZWFjaCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlID0geWllbGQgKiBldmFsdWF0ZShleHByLnVwZGF0ZSwgbWF0Y2gsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIG11c3QgYmUgYW4gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVUeXBlID0gdHlwZW9mIHVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYodXBkYXRlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHVwZGF0ZVR5cGUgIT09ICdvYmplY3QnIHx8IHVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRocm93IHR5cGUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMTFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnVwZGF0ZS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVwZGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSB0aGUgdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHByb3AgaW4gdXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbcHJvcF0gPSB1cGRhdGVbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUsIGlmIHNwZWNpZmllZCwgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzIChvciBzaW5nbGUgc3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgZXhwci5kZWxldGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsZXRpb25zID0geWllbGQgKiBldmFsdWF0ZShleHByLmRlbGV0ZSwgbWF0Y2gsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBkZWxldGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGRlbGV0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGVsZXRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGlvbnMgPSBbZGVsZXRpb25zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5T2ZTdHJpbmdzKGRlbGV0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgdHlwZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQyMDEyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLmRlbGV0ZS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgamogPSAwOyBqaiA8IGRlbGV0aW9ucy5sZW5ndGg7IGpqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1hdGNoW2RlbGV0aW9uc1tqal1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZGVmaW5lRnVuY3Rpb24odHJhbnNmb3JtZXIsICc8KG9hKTpvPicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGFuIGV4cHJlc3Npb24gYnkgZHJpdmluZyB0aGUgZ2VuZXJhdG9yIHRvIGNvbXBsZXRpb25cbiAgICAgKiBVc2VkIHdoZW4gaXQncyBub3QgcG9zc2libGUgdG8geWllbGRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEFTVFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IHJlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyaXZlR2VuZXJhdG9yKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgZ2VuID0gZXZhbHVhdGUoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgLy8gcmV0dXJucyBhIGdlbmVyYXRvciAtIHNvIGl0ZXJhdGUgb3ZlciBpdFxuICAgICAgICB2YXIgY29tcCA9IGdlbi5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghY29tcC5kb25lKSB7XG4gICAgICAgICAgICBjb21wID0gZ2VuLm5leHQoY29tcC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXAudmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGNoYWluID0gZHJpdmVHZW5lcmF0b3IocGFyc2VyKCdmdW5jdGlvbigkZiwgJGcpIHsgZnVuY3Rpb24oJHgpeyAkZygkZigkeCkpIH0gfScpLCBudWxsLCBzdGF0aWNGcmFtZSk7XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgZnVuY3Rpb24gb24gdGhlIFJIUyB1c2luZyB0aGUgc2VxdWVuY2Ugb24gdGhlIExIUyBhcyB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlQXBwbHlFeHByZXNzaW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG5cbiAgICAgICAgaWYoZXhwci5yaHMudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIGZ1bmN0aW9uIF9pbnZvY2F0aW9uXzsgaW52b2tlIGl0IHdpdGggbGhzIGV4cHJlc3Npb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICAgICAgICBleHByLnJocy5hcmd1bWVudHMudW5zaGlmdChleHByLmxocyk7XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlRnVuY3Rpb24oZXhwci5yaHMsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICBleHByLnJocy5hcmd1bWVudHMuc2hpZnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsaHMgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIubGhzLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIucmhzLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuXG4gICAgICAgICAgICBpZighaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJUMjAwNlwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoaXNGdW5jdGlvbihsaHMpKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBmdW5jdGlvbiBjaGFpbmluZyAoZnVuYzEgfj4gZnVuYzIpXG4gICAgICAgICAgICAgICAgLy8gzrsoJGYsICRnKSB7IM67KCR4KXsgJGcoJGYoJHgpKSB9IH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGFwcGx5KGNoYWluLCBbbGhzLCBmdW5jXSwgZW52aXJvbm1lbnQsIG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGFwcGx5KGZ1bmMsIFtsaHNdLCBlbnZpcm9ubWVudCwgbnVsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnIC0gZXhwcmVzc2lvbiB0byB0ZXN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSBpZiBpdCBpcyBhIGZ1bmN0aW9uIChsYW1iZGEgb3IgYnVpbHQtaW4pXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuICgoYXJnICYmIChhcmcuX2pzb25hdGFfZnVuY3Rpb24gPT09IHRydWUgfHwgYXJnLl9qc29uYXRhX2xhbWJkYSA9PT0gdHJ1ZSkpIHx8IHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RzIHdoZXRoZXIgYXJnIGlzIGEgbGFtYmRhIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSBhcmcgLSB0aGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUgaWYgaXQgaXMgYSBsYW1iZGEgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xhbWJkYShhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZyAmJiBhcmcuX2pzb25hdGFfbGFtYmRhID09PSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmcgLSBleHByZXNzaW9uIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIGl0IGlzIGEgZ2VuZXJhdG9yIGkuZS4gdGhlIHJlc3VsdCBmcm9tIGNhbGxpbmcgYVxuICAgICAqIGdlbmVyYXRvciBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzR2VuZXJhdG9yKGFyZykge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIGFyZyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgU3ltYm9sLml0ZXJhdG9yIGluIGFyZyAmJlxuICAgICAgICAgICAgdHlwZW9mIGFyZ1tTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAnbmV4dCcgaW4gYXJnICYmXG4gICAgICAgICAgICB0eXBlb2YgYXJnLm5leHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBmdW5jdGlvbiBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFthcHBseXRvXSAtIExIUyBvZiB+PiBvcGVyYXRvclxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBldmFsdWF0ZUZ1bmN0aW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgcHJvY2VkdXJlXG4gICAgICAgIC8vIGNhbid0IGFzc3VtZSB0aGF0IGV4cHIucHJvY2VkdXJlIGlzIGEgbGFtYmRhIHR5cGUgZGlyZWN0bHlcbiAgICAgICAgLy8gY291bGQgYmUgYW4gZXhwcmVzc2lvbiB0aGF0IGV2YWx1YXRlcyB0byBhIGZ1bmN0aW9uIChlLmcuIHZhcmlhYmxlIHJlZmVyZW5jZSwgcGFyZW5zIGV4cHIgZXRjLlxuICAgICAgICAvLyBldmFsdWF0ZSBpdCBnZW5lcmljYWxseSBmaXJzdCwgdGhlbiBjaGVjayB0aGF0IGl0IGlzIGEgZnVuY3Rpb24uICBUaHJvdyBlcnJvciBpZiBub3QuXG4gICAgICAgIHZhciBwcm9jID0geWllbGQgKiBldmFsdWF0ZShleHByLnByb2NlZHVyZSwgaW5wdXQsIGVudmlyb25tZW50KTtcblxuICAgICAgICBpZiAodHlwZW9mIHByb2MgPT09ICd1bmRlZmluZWQnICYmIGV4cHIucHJvY2VkdXJlLnR5cGUgPT09ICdwYXRoJyAmJiBlbnZpcm9ubWVudC5sb29rdXAoZXhwci5wcm9jZWR1cmUuc3RlcHNbMF0udmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBoZWxwIHRoZSB1c2VyIG91dCBoZXJlIGlmIHRoZXkgc2ltcGx5IGZvcmdvdCB0aGUgbGVhZGluZyAkXG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgY29kZTogXCJUMTAwNVwiLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHRva2VuOiBleHByLnByb2NlZHVyZS5zdGVwc1swXS52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBldmFsdWF0ZWRBcmdzID0gW107XG4gICAgICAgIC8vIGVhZ2VyIGV2YWx1YXRpb24gLSBldmFsdWF0ZSB0aGUgYXJndW1lbnRzXG4gICAgICAgIGZvciAodmFyIGpqID0gMDsgamogPCBleHByLmFyZ3VtZW50cy5sZW5ndGg7IGpqKyspIHtcbiAgICAgICAgICAgIC8vIG9ubHkgZXZhbHVhdGUgJ2VhZ2VyJyBhcmd1bWVudHMgYXQgdGhpcyBzdGFnZTsgd3JhcCB0aGUgJ2xhenknIG9uZXMgaW4gYSBjbG9zdXJlXG4gICAgICAgICAgICBldmFsdWF0ZWRBcmdzLnB1c2goeWllbGQqIGV2YWx1YXRlKGV4cHIuYXJndW1lbnRzW2pqXSwgaW5wdXQsIGVudmlyb25tZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXBwbHkgdGhlIHByb2NlZHVyZVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gaWYoaW5wdXQgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgIC8vICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5wdXQsICdfX2Vudl9fJywge1xuICAgICAgICAgICAgLy8gICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIC8vICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgLy8gICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHJldHVybiBlbnZpcm9ubWVudDtcbiAgICAgICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAgICAgLy8gICAgIH0pO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBhcHBseShwcm9jLCBldmFsdWF0ZWRBcmdzLCBpbnB1dCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gYWRkIHRoZSBwb3NpdGlvbiBmaWVsZCB0byB0aGUgZXJyb3JcbiAgICAgICAgICAgIGVyci5wb3NpdGlvbiA9IGV4cHIucG9zaXRpb247XG4gICAgICAgICAgICAvLyBhbmQgdGhlIGZ1bmN0aW9uIGlkZW50aWZpZXJcbiAgICAgICAgICAgIGVyci50b2tlbiA9IGV4cHIucHJvY2VkdXJlLnR5cGUgPT09ICdwYXRoJyA/IGV4cHIucHJvY2VkdXJlLnN0ZXBzWzBdLnZhbHVlIDogZXhwci5wcm9jZWR1cmUudmFsdWU7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBwcm9jZWR1cmUgb3IgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvYyAtIFByb2NlZHVyZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBBcmd1bWVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VsZiAtIFNlbGZcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0IG9mIHByb2NlZHVyZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBhcHBseShwcm9jLCBhcmdzLCBzZWxmKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9IHlpZWxkICogYXBwbHlJbm5lcihwcm9jLCBhcmdzLCBzZWxmKTtcbiAgICAgICAgd2hpbGUoaXNMYW1iZGEocmVzdWx0KSAmJiByZXN1bHQudGh1bmsgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIHRyYW1wb2xpbmUgbG9vcCAtIHRoaXMgZ2V0cyBpbnZva2VkIGFzIGEgcmVzdWx0IG9mIHRhaWwtY2FsbCBvcHRpbWl6YXRpb25cbiAgICAgICAgICAgIC8vIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBhIHRhaWwtY2FsbCB0aHVua1xuICAgICAgICAgICAgLy8gdW5wYWNrIGl0LCBldmFsdWF0ZSBpdHMgYXJndW1lbnRzLCBhbmQgYXBwbHkgdGhlIHRhaWwgY2FsbFxuICAgICAgICAgICAgdmFyIG5leHQgPSB5aWVsZCAqIGV2YWx1YXRlKHJlc3VsdC5ib2R5LnByb2NlZHVyZSwgcmVzdWx0LmlucHV0LCByZXN1bHQuZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgdmFyIGV2YWx1YXRlZEFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvcih2YXIgaWkgPSAwOyBpaSA8IHJlc3VsdC5ib2R5LmFyZ3VtZW50cy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgICAgICBldmFsdWF0ZWRBcmdzLnB1c2goeWllbGQgKiBldmFsdWF0ZShyZXN1bHQuYm9keS5hcmd1bWVudHNbaWldLCByZXN1bHQuaW5wdXQsIHJlc3VsdC5lbnZpcm9ubWVudCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGFwcGx5SW5uZXIobmV4dCwgZXZhbHVhdGVkQXJncywgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBwcm9jZWR1cmUgb3IgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvYyAtIFByb2NlZHVyZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBBcmd1bWVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VsZiAtIFNlbGZcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0IG9mIHByb2NlZHVyZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBhcHBseUlubmVyKHByb2MsIGFyZ3MsIHNlbGYpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHZhbGlkYXRlZEFyZ3MgPSBhcmdzO1xuICAgICAgICBpZihwcm9jKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZWRBcmdzID0gdmFsaWRhdGVBcmd1bWVudHMocHJvYy5zaWduYXR1cmUsIGFyZ3MsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xhbWJkYShwcm9jKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBhcHBseVByb2NlZHVyZShwcm9jLCB2YWxpZGF0ZWRBcmdzKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jICYmIHByb2MuX2pzb25hdGFfZnVuY3Rpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHByb2MuaW1wbGVtZW50YXRpb24uYXBwbHkoc2VsZiwgdmFsaWRhdGVkQXJncyk7XG4gICAgICAgICAgICAvLyBgcHJvYy5pbXBsZW1lbnRhdGlvbmAgbWlnaHQgYmUgYSBnZW5lcmF0b3IgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIGFuZCBgcmVzdWx0YCBtaWdodCBiZSBhIGdlbmVyYXRvciAtIGlmIHNvLCB5aWVsZFxuICAgICAgICAgICAgaWYoaXNHZW5lcmF0b3IocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICpyZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHByb2MuYXBwbHkoc2VsZiwgdmFsaWRhdGVkQXJncyk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYoaXNHZW5lcmF0b3IocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICpyZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgY29kZTogXCJUMTAwNlwiLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgbGFtYmRhIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7e2xhbWJkYTogYm9vbGVhbiwgaW5wdXQ6ICosIGVudmlyb25tZW50OiAqLCBhcmd1bWVudHM6ICosIGJvZHk6ICp9fSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlTGFtYmRhKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICAvLyBtYWtlIGEgZnVuY3Rpb24gKGNsb3N1cmUpXG4gICAgICAgIHZhciBwcm9jZWR1cmUgPSB7XG4gICAgICAgICAgICBfanNvbmF0YV9sYW1iZGE6IHRydWUsXG4gICAgICAgICAgICBpbnB1dDogaW5wdXQsXG4gICAgICAgICAgICBlbnZpcm9ubWVudDogZW52aXJvbm1lbnQsXG4gICAgICAgICAgICBhcmd1bWVudHM6IGV4cHIuYXJndW1lbnRzLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBleHByLnNpZ25hdHVyZSxcbiAgICAgICAgICAgIGJvZHk6IGV4cHIuYm9keVxuICAgICAgICB9O1xuICAgICAgICBpZihleHByLnRodW5rID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwcm9jZWR1cmUudGh1bmsgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9jZWR1cmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgcGFydGlhbCBhcHBsaWNhdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVQYXJ0aWFsQXBwbGljYXRpb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIC8vIHBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uXG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIC8vIGV2YWx1YXRlIHRoZSBhcmd1bWVudHNcbiAgICAgICAgdmFyIGV2YWx1YXRlZEFyZ3MgPSBbXTtcbiAgICAgICAgZm9yKHZhciBpaSA9IDA7IGlpIDwgZXhwci5hcmd1bWVudHMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICB2YXIgYXJnID0gZXhwci5hcmd1bWVudHNbaWldO1xuICAgICAgICAgICAgaWYgKGFyZy50eXBlID09PSAnb3BlcmF0b3InICYmIGFyZy52YWx1ZSA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgICAgZXZhbHVhdGVkQXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2YWx1YXRlZEFyZ3MucHVzaCh5aWVsZCAqIGV2YWx1YXRlKGFyZywgaW5wdXQsIGVudmlyb25tZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9va3VwIHRoZSBwcm9jZWR1cmVcbiAgICAgICAgdmFyIHByb2MgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIucHJvY2VkdXJlLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICBpZiAodHlwZW9mIHByb2MgPT09ICd1bmRlZmluZWQnICYmIGV4cHIucHJvY2VkdXJlLnR5cGUgPT09ICdwYXRoJyAmJiBlbnZpcm9ubWVudC5sb29rdXAoZXhwci5wcm9jZWR1cmUuc3RlcHNbMF0udmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBoZWxwIHRoZSB1c2VyIG91dCBoZXJlIGlmIHRoZXkgc2ltcGx5IGZvcmdvdCB0aGUgbGVhZGluZyAkXG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgY29kZTogXCJUMTAwN1wiLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHRva2VuOiBleHByLnByb2NlZHVyZS5zdGVwc1swXS52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMYW1iZGEocHJvYykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcnRpYWxBcHBseVByb2NlZHVyZShwcm9jLCBldmFsdWF0ZWRBcmdzKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jICYmIHByb2MuX2pzb25hdGFfZnVuY3Rpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcnRpYWxBcHBseU5hdGl2ZUZ1bmN0aW9uKHByb2MuaW1wbGVtZW50YXRpb24sIGV2YWx1YXRlZEFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJ0aWFsQXBwbHlOYXRpdmVGdW5jdGlvbihwcm9jLCBldmFsdWF0ZWRBcmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlQxMDA4XCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgdG9rZW46IGV4cHIucHJvY2VkdXJlLnR5cGUgPT09ICdwYXRoJyA/IGV4cHIucHJvY2VkdXJlLnN0ZXBzWzBdLnZhbHVlIDogZXhwci5wcm9jZWR1cmUudmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgYXJndW1lbnRzIGFnYWluc3QgdGhlIHNpZ25hdHVyZSB2YWxpZGF0b3IgKGlmIGl0IGV4aXN0cylcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzaWduYXR1cmUgLSB2YWxpZGF0b3IgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIC0gZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICogQHBhcmFtIHsqfSBjb250ZXh0IC0gY29udGV4dCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gLSB2YWxpZGF0ZWQgYXJndW1lbnRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVBcmd1bWVudHMoc2lnbmF0dXJlLCBhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgIGlmKHR5cGVvZiBzaWduYXR1cmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHRvIHZhbGlkYXRlXG4gICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsaWRhdGVkQXJncyA9IHNpZ25hdHVyZS52YWxpZGF0ZShhcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEFyZ3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgcHJvY2VkdXJlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb2MgLSBQcm9jZWR1cmVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIC0gQXJndW1lbnRzXG4gICAgICogQHJldHVybnMgeyp9IFJlc3VsdCBvZiBwcm9jZWR1cmVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogYXBwbHlQcm9jZWR1cmUocHJvYywgYXJncykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgZW52ID0gY3JlYXRlRnJhbWUocHJvYy5lbnZpcm9ubWVudCk7XG4gICAgICAgIHByb2MuYXJndW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtLCBpbmRleCkge1xuICAgICAgICAgICAgZW52LmJpbmQocGFyYW0udmFsdWUsIGFyZ3NbaW5kZXhdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvYy5ib2R5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgbGFtYmRhIHRoYXQgd3JhcHMgYSBuYXRpdmUgZnVuY3Rpb24gLSBnZW5lcmF0ZWQgYnkgcGFydGlhbGx5IGV2YWx1YXRpbmcgYSBuYXRpdmVcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogYXBwbHlOYXRpdmVGdW5jdGlvbihwcm9jLmJvZHksIGVudik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlKHByb2MuYm9keSwgcHJvYy5pbnB1dCwgZW52KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnRpYWxseSBhcHBseSBwcm9jZWR1cmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvYyAtIFByb2NlZHVyZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBBcmd1bWVudHNcbiAgICAgKiBAcmV0dXJucyB7e2xhbWJkYTogYm9vbGVhbiwgaW5wdXQ6ICosIGVudmlyb25tZW50OiB7YmluZCwgbG9va3VwfSwgYXJndW1lbnRzOiBBcnJheSwgYm9keTogKn19IFJlc3VsdCBvZiBwYXJ0aWFsbHkgYXBwbGllZCBwcm9jZWR1cmVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJ0aWFsQXBwbHlQcm9jZWR1cmUocHJvYywgYXJncykge1xuICAgICAgICAvLyBjcmVhdGUgYSBjbG9zdXJlLCBiaW5kIHRoZSBzdXBwbGllZCBwYXJhbWV0ZXJzIGFuZCByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSByZW1haW5pbmcgKD8pIHBhcmFtZXRlcnNcbiAgICAgICAgdmFyIGVudiA9IGNyZWF0ZUZyYW1lKHByb2MuZW52aXJvbm1lbnQpO1xuICAgICAgICB2YXIgdW5ib3VuZEFyZ3MgPSBbXTtcbiAgICAgICAgcHJvYy5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgYXJnID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoYXJnICYmIGFyZy50eXBlID09PSAnb3BlcmF0b3InICYmIGFyZy52YWx1ZSA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgICAgdW5ib3VuZEFyZ3MucHVzaChwYXJhbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVudi5iaW5kKHBhcmFtLnZhbHVlLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHByb2NlZHVyZSA9IHtcbiAgICAgICAgICAgIF9qc29uYXRhX2xhbWJkYTogdHJ1ZSxcbiAgICAgICAgICAgIGlucHV0OiBwcm9jLmlucHV0LFxuICAgICAgICAgICAgZW52aXJvbm1lbnQ6IGVudixcbiAgICAgICAgICAgIGFyZ3VtZW50czogdW5ib3VuZEFyZ3MsXG4gICAgICAgICAgICBib2R5OiBwcm9jLmJvZHlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHByb2NlZHVyZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJ0aWFsbHkgYXBwbHkgbmF0aXZlIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmF0aXZlIC0gTmF0aXZlIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHt7bGFtYmRhOiBib29sZWFuLCBpbnB1dDogKiwgZW52aXJvbm1lbnQ6IHtiaW5kLCBsb29rdXB9LCBhcmd1bWVudHM6IEFycmF5LCBib2R5OiAqfX0gUmVzdWx0IG9mIHBhcnRpYWxseSBhcHBseWluZyBuYXRpdmUgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJ0aWFsQXBwbHlOYXRpdmVGdW5jdGlvbihuYXRpdmUsIGFyZ3MpIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgbGFtYmRhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYW5kIGludm9rZXMgdGhlIG5hdGl2ZSBmdW5jdGlvblxuICAgICAgICAvLyBnZXQgdGhlIGxpc3Qgb2YgZGVjbGFyZWQgYXJndW1lbnRzIGZyb20gdGhlIG5hdGl2ZSBmdW5jdGlvblxuICAgICAgICAvLyB0aGlzIGhhcyB0byBiZSBwaWNrZWQgb3V0IGZyb20gdGhlIHRvU3RyaW5nKCkgdmFsdWVcbiAgICAgICAgdmFyIHNpZ0FyZ3MgPSBnZXROYXRpdmVGdW5jdGlvbkFyZ3VtZW50cyhuYXRpdmUpO1xuICAgICAgICBzaWdBcmdzID0gc2lnQXJncy5tYXAoZnVuY3Rpb24gKHNpZ0FyZykge1xuICAgICAgICAgICAgcmV0dXJuICckJyArIHNpZ0FyZy50cmltKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYm9keSA9ICdmdW5jdGlvbignICsgc2lnQXJncy5qb2luKCcsICcpICsgJyl7IF8gfSc7XG5cbiAgICAgICAgdmFyIGJvZHlBU1QgPSBwYXJzZXIoYm9keSk7XG4gICAgICAgIGJvZHlBU1QuYm9keSA9IG5hdGl2ZTtcblxuICAgICAgICB2YXIgcGFydGlhbCA9IHBhcnRpYWxBcHBseVByb2NlZHVyZShib2R5QVNULCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHBhcnRpYWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgbmF0aXZlIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb2MgLSBQcm9jZWR1cmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0IG9mIGFwcGx5aW5nIG5hdGl2ZSBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBhcHBseU5hdGl2ZUZ1bmN0aW9uKHByb2MsIGVudikge1xuICAgICAgICB2YXIgc2lnQXJncyA9IGdldE5hdGl2ZUZ1bmN0aW9uQXJndW1lbnRzKHByb2MpO1xuICAgICAgICAvLyBnZW5lcmF0ZSB0aGUgYXJyYXkgb2YgYXJndW1lbnRzIGZvciBpbnZva2luZyB0aGUgZnVuY3Rpb24gLSBsb29rIHRoZW0gdXAgaW4gdGhlIGVudmlyb25tZW50XG4gICAgICAgIHZhciBhcmdzID0gc2lnQXJncy5tYXAoZnVuY3Rpb24gKHNpZ0FyZykge1xuICAgICAgICAgICAgcmV0dXJuIGVudi5sb29rdXAoc2lnQXJnLnRyaW0oKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBwcm9jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICBpZihpc0dlbmVyYXRvcihyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBuYXRpdmUgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uXG4gICAgICogQHJldHVybnMgeyp8QXJyYXl9IE5hdGl2ZSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXROYXRpdmVGdW5jdGlvbkFyZ3VtZW50cyhmdW5jKSB7XG4gICAgICAgIHZhciBzaWduYXR1cmUgPSBmdW5jLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBzaWdQYXJlbnMgPSAvXFwoKFteKV0qKVxcKS8uZXhlYyhzaWduYXR1cmUpWzFdOyAvLyB0aGUgY29udGVudHMgb2YgdGhlIHBhcmVuc1xuICAgICAgICB2YXIgc2lnQXJncyA9IHNpZ1BhcmVucy5zcGxpdCgnLCcpO1xuICAgICAgICByZXR1cm4gc2lnQXJncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgLSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbiBpbiBKYXZhc2NyaXB0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZSAtIEpTT05hdGEgZnVuY3Rpb24gc2lnbmF0dXJlIGRlZmluaXRpb25cbiAgICAgKiBAcmV0dXJucyB7e2ltcGxlbWVudGF0aW9uOiAqLCBzaWduYXR1cmU6ICp9fSBmdW5jdGlvbiBkZWZpbml0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmaW5lRnVuY3Rpb24oZnVuYywgc2lnbmF0dXJlKSB7XG4gICAgICAgIHZhciBkZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgX2pzb25hdGFfZnVuY3Rpb246IHRydWUsXG4gICAgICAgICAgICBpbXBsZW1lbnRhdGlvbjogZnVuY1xuICAgICAgICB9O1xuICAgICAgICBpZih0eXBlb2Ygc2lnbmF0dXJlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZGVmaW5pdGlvbi5zaWduYXR1cmUgPSBwYXJzZVNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN1bSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIC0gQXJndW1lbnRzXG4gICAgICogQHJldHVybnMge251bWJlcn0gVG90YWwgdmFsdWUgb2YgYXJndW1lbnRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25TdW0oYXJncykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmdzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbihudW0pe3RvdGFsICs9IG51bTt9KTtcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvdW50IGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgLSBBcmd1bWVudHNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Db3VudChhcmdzKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZ3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcmdzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXggZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE1heCBlbGVtZW50IGluIHRoZSBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uTWF4KGFyZ3MpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJncyA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWluIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgLSBBcmd1bWVudHNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBNaW4gZWxlbWVudCBpbiB0aGUgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbk1pbihhcmdzKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZ3MgPT09ICd1bmRlZmluZWQnIHx8IGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF2ZXJhZ2UgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEF2ZXJhZ2UgZWxlbWVudCBpbiB0aGUgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkF2ZXJhZ2UoYXJncykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmdzID09PSAndW5kZWZpbmVkJyB8fCBhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbihudW0pe3RvdGFsICs9IG51bTt9KTtcbiAgICAgICAgcmV0dXJuIHRvdGFsL2FyZ3MubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0aW5naWZ5IGFyZ3VtZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmcgLSBBcmd1bWVudHNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBTdHJpbmcgZnJvbSBhcmd1bWVudHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblN0cmluZyhhcmcpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHI7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBhbHJlYWR5IGEgc3RyaW5nXG4gICAgICAgICAgICBzdHIgPSBhcmc7XG4gICAgICAgIH0gZWxzZSBpZihpc0Z1bmN0aW9uKGFyZykpIHtcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9ucyAoYnVpbHQtaW4gYW5kIGxhbWJkYSBjb252ZXJ0IHRvIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgc3RyID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicgJiYgIWlzRmluaXRlKGFyZykpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMDAxXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGFyZyxcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBzdHIgPSBKU09OLnN0cmluZ2lmeShhcmcsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsICE9PSBudWxsICYmIHZhbC50b1ByZWNpc2lvbiAmJiBpc051bWVyaWModmFsKSkgPyBOdW1iZXIodmFsLnRvUHJlY2lzaW9uKDEzKSkgOlxuICAgICAgICAgICAgICAgICAgICAodmFsICYmIGlzRnVuY3Rpb24odmFsKSkgPyAnJyA6IHZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBzdWJzdHJpbmcgYmFzZWQgb24gY2hhcmFjdGVyIG51bWJlciBhbmQgbGVuZ3RoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFN0cmluZyB0byBldmFsdWF0ZVxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gc3RhcnQgLSBDaGFyYWN0ZXIgbnVtYmVyIHRvIHN0YXJ0IHN1YnN0cmluZ1xuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gW2xlbmd0aF0gLSBOdW1iZXIgb2YgY2hhcmFjdGVycyBpbiBzdWJzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCp9IFN1YnN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU3Vic3RyaW5nKHN0ciwgc3RhcnQsIGxlbmd0aCkge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHN1YnN0cmluZyB1cCB1bnRpbCBhIGNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBTdHJpbmcgdG8gZXZhbHVhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2hhcnMgLSBDaGFyYWN0ZXIgdG8gZGVmaW5lIHN1YnN0cmluZyBib3VuZGFyeVxuICAgICAqIEByZXR1cm5zIHsqfSBTdWJzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblN1YnN0cmluZ0JlZm9yZShzdHIsIGNoYXJzKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9zID0gc3RyLmluZGV4T2YoY2hhcnMpO1xuICAgICAgICBpZiAocG9zID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIHBvcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHN1YnN0cmluZyBhZnRlciBhIGNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBTdHJpbmcgdG8gZXZhbHVhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2hhcnMgLSBDaGFyYWN0ZXIgdG8gZGVmaW5lIHN1YnN0cmluZyBib3VuZGFyeVxuICAgICAqIEByZXR1cm5zIHsqfSBTdWJzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblN1YnN0cmluZ0FmdGVyKHN0ciwgY2hhcnMpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3MgPSBzdHIuaW5kZXhPZihjaGFycyk7XG4gICAgICAgIGlmIChwb3MgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIocG9zICsgY2hhcnMubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb3dlcmNhc2UgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gU3RyaW5nIHRvIGV2YWx1YXRlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gTG93ZXJjYXNlIHN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uTG93ZXJjYXNlKHN0cikge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwcGVyY2FzZSBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBTdHJpbmcgdG8gZXZhbHVhdGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBVcHBlcmNhc2Ugc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25VcHBlcmNhc2Uoc3RyKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbGVuZ3RoIG9mIGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25MZW5ndGgoc3RyKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgYW5kIHRyaW0gd2hpdGVzcGFjZSB3aXRoaW4gYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gc3RyaW5nIHRvIGJlIHRyaW1tZWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRyaW1tZWQgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25UcmltKHN0cikge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIHdoaXRlc3BhY2VcbiAgICAgICAgdmFyIHJlc3VsdCA9IHN0ci5yZXBsYWNlKC9bIFxcdFxcblxccl0rL2dtLCAnICcpO1xuICAgICAgICBpZihyZXN1bHQuY2hhckF0KDApID09PSAnICcpIHtcbiAgICAgICAgICAgIC8vIHN0cmlwIGxlYWRpbmcgc3BhY2VcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYocmVzdWx0LmNoYXJBdChyZXN1bHQubGVuZ3RoIC0gMSkgPT09ICcgJykge1xuICAgICAgICAgICAgLy8gc3RyaXAgdHJhaWxpbmcgc3BhY2VcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHJpbmcoMCwgcmVzdWx0Lmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFkIGEgc3RyaW5nIHRvIGEgbWluaW11bSB3aWR0aCBieSBhZGRpbmcgY2hhcmFjdGVycyB0byB0aGUgc3RhcnQgb3IgZW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIHN0cmluZyB0byBiZSBwYWRkZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgbWluaW11bSB3aWR0aDsgK3ZlIHBhZHMgdG8gdGhlIHJpZ2h0LCAtdmUgcGFkcyB0byB0aGUgbGVmdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcl0gLSB0aGUgcGFkIGNoYXJhY3RlcihzKTsgZGVmYXVsdHMgdG8gJyAnXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSBwYWRkZWQgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25QYWQoc3RyLCB3aWR0aCwgY2hhcikge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodHlwZW9mIGNoYXIgPT09ICd1bmRlZmluZWQnIHx8IGNoYXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjaGFyID0gJyAnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHBhZExlbmd0aCA9IE1hdGguYWJzKHdpZHRoKSAtIHN0ci5sZW5ndGg7XG4gICAgICAgIGlmKHBhZExlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gKG5ldyBBcnJheShwYWRMZW5ndGggKyAxKSkuam9pbihjaGFyKTtcbiAgICAgICAgICAgIGlmKGNoYXIubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHBhZGRpbmcgPSBwYWRkaW5nLnN1YnN0cmluZygwLCBwYWRMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYod2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc3RyICsgcGFkZGluZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFkZGluZyArIHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN0cjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoZSBzdHIgY29udGFpbnMgdGhlIHRva2VuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHN0cmluZyB0byB0ZXN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRva2VuIC0gc3Vic3RyaW5nIG9yIHJlZ2V4IHRvIGZpbmRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSB0cnVlIGlmIHN0ciBjb250YWlucyB0b2tlblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uQ29udGFpbnMoc3RyLCB0b2tlbikge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBpZih0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAoc3RyLmluZGV4T2YodG9rZW4pICE9PSAtMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHRva2VuKHN0cik7XG4gICAgICAgICAgICByZXN1bHQgPSAodHlwZW9mIG1hdGNoZXMgIT09ICd1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWF0Y2ggYSBzdHJpbmcgd2l0aCBhIHJlZ2V4IHJldHVybmluZyBhbiBhcnJheSBvZiBvYmplY3QgY29udGFpbmluZyBkZXRhaWxzIG9mIGVhY2ggbWF0Y2hcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2V4IC0gdGhlIHJlZ2V4IGFwcGxpZWQgdG8gdGhlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gW2xpbWl0XSAtIG1heCBudW1iZXIgb2YgbWF0Y2hlcyB0byByZXR1cm5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBvZiBtYXRjaCBvYmplY3RzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25NYXRjaChzdHIsIHJlZ2V4LCBsaW1pdCkge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGltaXQsIGlmIHNwZWNpZmllZCwgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXJcbiAgICAgICAgaWYobGltaXQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxpbWl0LFxuICAgICAgICAgICAgICAgIGNvZGU6ICdEMzA0MCcsXG4gICAgICAgICAgICAgICAgaW5kZXg6IDNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYodHlwZW9mIGxpbWl0ID09PSAndW5kZWZpbmVkJyB8fCBsaW1pdCA+IDApIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHJlZ2V4KHN0cik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1hdGNoZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHR5cGVvZiBtYXRjaGVzICE9PSAndW5kZWZpbmVkJyAmJiAodHlwZW9mIGxpbWl0ID09PSAndW5kZWZpbmVkJyB8fCBjb3VudCA8IGxpbWl0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaDogbWF0Y2hlcy5tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBtYXRjaGVzLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzOiBtYXRjaGVzLmdyb3Vwc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IG1hdGNoZXMubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWF0Y2ggYSBzdHJpbmcgd2l0aCBhIHJlZ2V4IHJldHVybmluZyBhbiBhcnJheSBvZiBvYmplY3QgY29udGFpbmluZyBkZXRhaWxzIG9mIGVhY2ggbWF0Y2hcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4gLSB0aGUgc3Vic3RyaW5nL3JlZ2V4IGFwcGxpZWQgdG8gdGhlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXBsYWNlbWVudCAtIHRleHQgdG8gcmVwbGFjZSB0aGUgbWF0Y2hlZCBzdWJzdHJpbmdzXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBbbGltaXRdIC0gbWF4IG51bWJlciBvZiBtYXRjaGVzIHRvIHJldHVyblxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IG9mIG1hdGNoIG9iamVjdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZnVuY3Rpb25SZXBsYWNlKHN0ciwgcGF0dGVybiwgcmVwbGFjZW1lbnQsIGxpbWl0KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYXR0ZXJuIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgaWYocGF0dGVybiA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMDEwXCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgaW5kZXg6IDJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsaW1pdCwgaWYgc3BlY2lmaWVkLCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlclxuICAgICAgICBpZihsaW1pdCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMDExXCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxpbWl0LFxuICAgICAgICAgICAgICAgIGluZGV4OiA0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcGxhY2VyO1xuICAgICAgICBpZih0eXBlb2YgcmVwbGFjZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXBsYWNlciA9IGZ1bmN0aW9uIChyZWdleE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnN0aXR1dGUgPSAnJztcbiAgICAgICAgICAgICAgICAvLyBzY2FuIGZvcndhcmQsIGNvcHlpbmcgdGhlIHJlcGxhY2VtZW50IHRleHQgaW50byB0aGUgc3Vic3RpdHV0ZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAvLyBhbmQgcmVwbGFjZSBhbnkgb2NjdXJyZW5jZSBvZiAkbiB3aXRoIHRoZSB2YWx1ZXMgbWF0Y2hlZCBieSB0aGUgcmVnZXhcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHJlcGxhY2VtZW50LmluZGV4T2YoJyQnLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4ICE9PSAtMSAmJiBwb3NpdGlvbiA8IHJlcGxhY2VtZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRlICs9IHJlcGxhY2VtZW50LnN1YnN0cmluZyhwb3NpdGlvbiwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbGxhclZhbCA9IHJlcGxhY2VtZW50LmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2xsYXJWYWwgPT09ICckJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGl0ZXJhbCAkXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRlICs9ICckJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZG9sbGFyVmFsID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGUgKz0gcmVnZXhNYXRjaC5tYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4RGlnaXRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVnZXhNYXRjaC5ncm91cHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gc3ViLW1hdGNoZXM7IGFueSAkIGZvbGxvd2VkIGJ5IGEgZGlnaXQgd2lsbCBiZSByZXBsYWNlZCBieSBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhEaWdpdHMgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXggbnVtYmVyIG9mIGRpZ2l0cyB0byBwYXJzZSBmb2xsb3dpbmcgdGhlICRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhEaWdpdHMgPSBNYXRoLmZsb29yKE1hdGgubG9nKHJlZ2V4TWF0Y2guZ3JvdXBzLmxlbmd0aCkgKiBNYXRoLkxPRzEwRSkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBwYXJzZUludChyZXBsYWNlbWVudC5zdWJzdHJpbmcocG9zaXRpb24sIHBvc2l0aW9uICsgbWF4RGlnaXRzKSwgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobWF4RGlnaXRzID4gMSAmJiBpbmRleCA+IHJlZ2V4TWF0Y2guZ3JvdXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcGFyc2VJbnQocmVwbGFjZW1lbnQuc3Vic3RyaW5nKHBvc2l0aW9uLCBwb3NpdGlvbiArIG1heERpZ2l0cyAtIDEpLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlZ2V4TWF0Y2guZ3JvdXBzLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJtYXRjaCA9IHJlZ2V4TWF0Y2guZ3JvdXBzW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3VibWF0Y2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRlICs9IHN1Ym1hdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IGluZGV4LnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgYSBjYXB0dXJlIGdyb3VwLCB0cmVhdCB0aGUgJCBhcyBsaXRlcmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0ZSArPSAnJCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXBsYWNlbWVudC5pbmRleE9mKCckJywgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRlICs9IHJlcGxhY2VtZW50LnN1YnN0cmluZyhwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVwbGFjZXIgPSByZXBsYWNlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gMDtcblxuICAgICAgICBpZih0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnIHx8IGxpbWl0ID4gMCkge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHN0ci5pbmRleE9mKHBhdHRlcm4sIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICB3aGlsZShpbmRleCAhPT0gLTEgJiYgKHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcgfHwgY291bnQgPCBsaW1pdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5zdWJzdHJpbmcocG9zaXRpb24sIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGluZGV4ICsgcGF0dGVybi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gc3RyLmluZGV4T2YocGF0dGVybiwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyLnN1YnN0cmluZyhwb3NpdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gcGF0dGVybihzdHIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWF0Y2hlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHR5cGVvZiBtYXRjaGVzICE9PSAndW5kZWZpbmVkJyAmJiAodHlwZW9mIGxpbWl0ID09PSAndW5kZWZpbmVkJyB8fCBjb3VudCA8IGxpbWl0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5zdWJzdHJpbmcocG9zaXRpb24sIG1hdGNoZXMuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VkV2l0aCA9IHlpZWxkICogYXBwbHkocmVwbGFjZXIsIFttYXRjaGVzXSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayByZXBsYWNlZFdpdGggaXMgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiByZXBsYWNlZFdpdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHJlcGxhY2VkV2l0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGEgc3RyaW5nIC0gdGhyb3cgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiRDMwMTJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXBsYWNlZFdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBtYXRjaGVzLnN0YXJ0ICsgbWF0Y2hlcy5tYXRjaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IG1hdGNoZXMubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuc3Vic3RyaW5nKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzdHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3RyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCYXNlNjQgZW5jb2RlIGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IEJhc2UgNjQgZW5jb2Rpbmcgb2YgdGhlIGJpbmFyeSBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25CYXNlNjRlbmNvZGUoc3RyKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGJ0b2EgaW4gYSBicm93c2VyLCBvciBCdWZmZXIgaW4gTm9kZS5qc1xuXG4gICAgICAgIHZhciBidG9hID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gd2luZG93LmJ0b2EgOlxuICAgICAgICAgICAgZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGx5IGRvaW5nIGBuZXcgQnVmZmVyYCBhdCB0aGlzIHBvaW50IGNhdXNlcyBCcm93c2VyaWZ5IHRvIHB1bGxcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgZW50aXJlIEJ1ZmZlciBicm93c2VyIGxpYnJhcnksIHdoaWNoIGlzIGxhcmdlIGFuZCB1bm5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAgICAvLyBVc2luZyBgZ2xvYmFsLkJ1ZmZlcmAgZGVmZWF0cyB0aGlzLlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZ2xvYmFsLkJ1ZmZlcihzdHIsICdiaW5hcnknKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYnRvYShzdHIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJhc2U2NCBkZWNvZGUgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nXG4gICAgICogQHJldHVybnMge1N0cmluZ30gQmFzZSA2NCBlbmNvZGluZyBvZiB0aGUgYmluYXJ5IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkJhc2U2NGRlY29kZShzdHIpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgYnRvYSBpbiBhIGJyb3dzZXIsIG9yIEJ1ZmZlciBpbiBOb2RlLmpzXG4gICAgICAgIHZhciBhdG9iID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gd2luZG93LmF0b2IgOlxuICAgICAgICAgICAgZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGx5IGRvaW5nIGBuZXcgQnVmZmVyYCBhdCB0aGlzIHBvaW50IGNhdXNlcyBCcm93c2VyaWZ5IHRvIHB1bGxcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgZW50aXJlIEJ1ZmZlciBicm93c2VyIGxpYnJhcnksIHdoaWNoIGlzIGxhcmdlIGFuZCB1bm5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAgICAvLyBVc2luZyBgZ2xvYmFsLkJ1ZmZlcmAgZGVmZWF0cyB0aGlzLlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZ2xvYmFsLkJ1ZmZlcihzdHIsICdiYXNlNjQnKS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXRvYihzdHIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwbGl0IGEgc3RyaW5nIGludG8gYW4gYXJyYXkgb2Ygc3Vic3RyaW5nc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VwYXJhdG9yIC0gdGhlIHRva2VuIG9yIHJlZ2V4IHRoYXQgc3BsaXRzIHRoZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IFtsaW1pdF0gLSBtYXggbnVtYmVyIG9mIHN1YnN0cmluZ3NcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBvZiBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblNwbGl0KHN0ciwgc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGltaXQsIGlmIHNwZWNpZmllZCwgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXJcbiAgICAgICAgaWYobGltaXQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgY29kZTogXCJEMzAyMFwiLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBsaW1pdCxcbiAgICAgICAgICAgICAgICBpbmRleDogM1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZih0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnIHx8IGxpbWl0ID4gMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXBhcmF0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc3RyLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gc2VwYXJhdG9yKHN0cik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtYXRjaGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHlwZW9mIG1hdGNoZXMgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnIHx8IGNvdW50IDwgbGltaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdHIuc3Vic3RyaW5nKHN0YXJ0LCBtYXRjaGVzLnN0YXJ0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG1hdGNoZXMuZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IG1hdGNoZXMubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnIHx8IGNvdW50IDwgbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0ci5zdWJzdHJpbmcoc3RhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtzdHJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSm9pbiBhbiBhcnJheSBvZiBzdHJpbmdzXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3RycyAtIGFycmF5IG9mIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VwYXJhdG9yXSAtIHRoZSB0b2tlbiB0aGF0IHNwbGl0cyB0aGUgc3RyaW5nXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGNvbmNhdGVuYXRlZCBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkpvaW4oc3Rycywgc2VwYXJhdG9yKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0cnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgc2VwYXJhdG9yIGlzIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHQgdG8gZW1wdHkgc3RyaW5nXG4gICAgICAgIGlmKHR5cGVvZiBzZXBhcmF0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cnMuam9pbihzZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdHMgYSBudW1iZXIgaW50byBhIGRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIHVzaW5nIFhQYXRoIDMuMSBGJk8gZm46Zm9ybWF0LW51bWJlciBzcGVjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gbnVtYmVyIHRvIGZvcm1hdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwaWN0dXJlIC0gcGljdHVyZSBzdHJpbmcgZGVmaW5pdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBvdmVycmlkZSBsb2NhbGUgZGVmYXVsdHNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgZm9ybWF0dGVkIHN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uRm9ybWF0TnVtYmVyKHZhbHVlLCBwaWN0dXJlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIFwiZGVjaW1hbC1zZXBhcmF0b3JcIjogXCIuXCIsXG4gICAgICAgICAgICBcImdyb3VwaW5nLXNlcGFyYXRvclwiOiBcIixcIixcbiAgICAgICAgICAgIFwiZXhwb25lbnQtc2VwYXJhdG9yXCI6IFwiZVwiLFxuICAgICAgICAgICAgXCJpbmZpbml0eVwiOiBcIkluZmluaXR5XCIsXG4gICAgICAgICAgICBcIm1pbnVzLXNpZ25cIjogXCItXCIsXG4gICAgICAgICAgICBcIk5hTlwiOiBcIk5hTlwiLFxuICAgICAgICAgICAgXCJwZXJjZW50XCI6IFwiJVwiLFxuICAgICAgICAgICAgXCJwZXItbWlsbGVcIjogXCJcXHUyMDMwXCIsXG4gICAgICAgICAgICBcInplcm8tZGlnaXRcIjogXCIwXCIsXG4gICAgICAgICAgICBcImRpZ2l0XCI6IFwiI1wiLFxuICAgICAgICAgICAgXCJwYXR0ZXJuLXNlcGFyYXRvclwiOiBcIjtcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGlmIGBvcHRpb25zYCBpcyBzcGVjaWZpZWQsIHRoZW4gaXRzIGVudHJpZXMgb3ZlcnJpZGUgZGVmYXVsdHNcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBkZWZhdWx0cztcbiAgICAgICAgaWYodHlwZW9mIG9wdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWNpbWFsRGlnaXRGYW1pbHkgPSBbXTtcbiAgICAgICAgdmFyIHplcm9DaGFyQ29kZSA9IHByb3BlcnRpZXNbJ3plcm8tZGlnaXQnXS5jaGFyQ29kZUF0KDApO1xuICAgICAgICBmb3IodmFyIGlpID0gemVyb0NoYXJDb2RlOyBpaSA8IHplcm9DaGFyQ29kZSArIDEwOyBpaSsrKSB7XG4gICAgICAgICAgICBkZWNpbWFsRGlnaXRGYW1pbHkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGlpKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWN0aXZlQ2hhcnMgPSBkZWNpbWFsRGlnaXRGYW1pbHkuY29uY2F0KFtwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddLCBwcm9wZXJ0aWVzWydleHBvbmVudC1zZXBhcmF0b3InXSwgcHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10sIHByb3BlcnRpZXMuZGlnaXQsIHByb3BlcnRpZXNbJ3BhdHRlcm4tc2VwYXJhdG9yJ11dKTtcblxuICAgICAgICB2YXIgc3ViUGljdHVyZXMgPSBwaWN0dXJlLnNwbGl0KHByb3BlcnRpZXNbJ3BhdHRlcm4tc2VwYXJhdG9yJ10pO1xuXG4gICAgICAgIGlmKHN1YlBpY3R1cmVzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiAnRDMwODAnLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNwbGl0UGFydHMgPSBmdW5jdGlvbihzdWJwaWN0dXJlKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjaDtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGlpID0gMDsgaWkgPCBzdWJwaWN0dXJlLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICAgICAgICBjaCA9IHN1YnBpY3R1cmUuY2hhckF0KGlpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoYWN0aXZlQ2hhcnMuaW5kZXhPZihjaCkgIT09IC0xICYmIGNoICE9PSBwcm9wZXJ0aWVzWydleHBvbmVudC1zZXBhcmF0b3InXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnBpY3R1cmUuc3Vic3RyaW5nKDAsIGlpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjaDtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGlpID0gc3VicGljdHVyZS5sZW5ndGggLSAxOyBpaSA+PSAwOyBpaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gc3VicGljdHVyZS5jaGFyQXQoaWkpO1xuICAgICAgICAgICAgICAgICAgICBpZihhY3RpdmVDaGFycy5pbmRleE9mKGNoKSAhPT0gLTEgJiYgY2ggIT09IHByb3BlcnRpZXNbJ2V4cG9uZW50LXNlcGFyYXRvciddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VicGljdHVyZS5zdWJzdHJpbmcoaWkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB2YXIgYWN0aXZlUGFydCA9IHN1YnBpY3R1cmUuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgsIHN1YnBpY3R1cmUubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgbWFudGlzc2FQYXJ0LCBleHBvbmVudFBhcnQsIGludGVnZXJQYXJ0LCBmcmFjdGlvbmFsUGFydDtcbiAgICAgICAgICAgIHZhciBleHBvbmVudFBvc2l0aW9uID0gc3VicGljdHVyZS5pbmRleE9mKHByb3BlcnRpZXNbJ2V4cG9uZW50LXNlcGFyYXRvciddLCBwcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmKGV4cG9uZW50UG9zaXRpb24gPT09IC0xIHx8IGV4cG9uZW50UG9zaXRpb24gPiBzdWJwaWN0dXJlLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBtYW50aXNzYVBhcnQgPSBhY3RpdmVQYXJ0O1xuICAgICAgICAgICAgICAgIGV4cG9uZW50UGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFudGlzc2FQYXJ0ID0gYWN0aXZlUGFydC5zdWJzdHJpbmcoMCwgZXhwb25lbnRQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgZXhwb25lbnRQYXJ0ID0gYWN0aXZlUGFydC5zdWJzdHJpbmcoZXhwb25lbnRQb3NpdGlvbiArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRlY2ltYWxQb3NpdGlvbiA9IG1hbnRpc3NhUGFydC5pbmRleE9mKHByb3BlcnRpZXNbJ2RlY2ltYWwtc2VwYXJhdG9yJ10pO1xuICAgICAgICAgICAgaWYoZGVjaW1hbFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGludGVnZXJQYXJ0ID0gbWFudGlzc2FQYXJ0O1xuICAgICAgICAgICAgICAgIGZyYWN0aW9uYWxQYXJ0ID0gc3VmZml4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnRlZ2VyUGFydCA9IG1hbnRpc3NhUGFydC5zdWJzdHJpbmcoMCwgZGVjaW1hbFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBmcmFjdGlvbmFsUGFydCA9IG1hbnRpc3NhUGFydC5zdWJzdHJpbmcoZGVjaW1hbFBvc2l0aW9uICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgICAgICAgIHN1ZmZpeDogc3VmZml4LFxuICAgICAgICAgICAgICAgIGFjdGl2ZVBhcnQ6IGFjdGl2ZVBhcnQsXG4gICAgICAgICAgICAgICAgbWFudGlzc2FQYXJ0OiBtYW50aXNzYVBhcnQsXG4gICAgICAgICAgICAgICAgZXhwb25lbnRQYXJ0OiBleHBvbmVudFBhcnQsXG4gICAgICAgICAgICAgICAgaW50ZWdlclBhcnQ6IGludGVnZXJQYXJ0LFxuICAgICAgICAgICAgICAgIGZyYWN0aW9uYWxQYXJ0OiBmcmFjdGlvbmFsUGFydCxcbiAgICAgICAgICAgICAgICBzdWJwaWN0dXJlOiBzdWJwaWN0dXJlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHZhbGlkYXRlIHRoZSBwaWN0dXJlIHN0cmluZywgRiZPIDQuNy4zXG4gICAgICAgIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgICAgICB2YXIgaWk7XG4gICAgICAgICAgICB2YXIgc3VicGljdHVyZSA9IHBhcnRzLnN1YnBpY3R1cmU7XG4gICAgICAgICAgICB2YXIgZGVjaW1hbFBvcyA9IHN1YnBpY3R1cmUuaW5kZXhPZihwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddKTtcbiAgICAgICAgICAgIGlmKGRlY2ltYWxQb3MgIT09IHN1YnBpY3R1cmUubGFzdEluZGV4T2YocHJvcGVydGllc1snZGVjaW1hbC1zZXBhcmF0b3InXSkpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA4MSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllcy5wZXJjZW50KSAhPT0gc3VicGljdHVyZS5sYXN0SW5kZXhPZihwcm9wZXJ0aWVzLnBlcmNlbnQpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAnRDMwODInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoc3VicGljdHVyZS5pbmRleE9mKHByb3BlcnRpZXNbJ3Blci1taWxsZSddKSAhPT0gc3VicGljdHVyZS5sYXN0SW5kZXhPZihwcm9wZXJ0aWVzWydwZXItbWlsbGUnXSkpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA4Myc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllcy5wZXJjZW50KSAhPT0gLTEgJiYgc3VicGljdHVyZS5pbmRleE9mKHByb3BlcnRpZXNbJ3Blci1taWxsZSddKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA4NCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvcihpaSA9IDA7IGlpIDwgcGFydHMubWFudGlzc2FQYXJ0Lmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaCA9IHBhcnRzLm1hbnRpc3NhUGFydC5jaGFyQXQoaWkpO1xuICAgICAgICAgICAgICAgIGlmKGRlY2ltYWxEaWdpdEZhbWlseS5pbmRleE9mKGNoKSAhPT0gLTEgfHwgY2ggPT09IHByb3BlcnRpZXMuZGlnaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZighdmFsaWQpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA4NSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hhclR5cGVzID0gcGFydHMuYWN0aXZlUGFydC5zcGxpdCgnJykubWFwKGZ1bmN0aW9uKGNoYXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0aXZlQ2hhcnMuaW5kZXhPZihjaGFyKSA9PT0gLTEgPyAncCcgOiAnYSc7XG4gICAgICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgICAgIGlmKGNoYXJUeXBlcy5pbmRleE9mKCdwJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAnRDMwODYnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGVjaW1hbFBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZihzdWJwaWN0dXJlLmNoYXJBdChkZWNpbWFsUG9zIC0gMSkgPT09IHByb3BlcnRpZXNbJ2dyb3VwaW5nLXNlcGFyYXRvciddIHx8IHN1YnBpY3R1cmUuY2hhckF0KGRlY2ltYWxQb3MgKyAxKSA9PT0gcHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSAnRDMwODcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZihwYXJ0cy5pbnRlZ2VyUGFydC5jaGFyQXQocGFydHMuaW50ZWdlclBhcnQubGVuZ3RoIC0gMSkgPT09IHByb3BlcnRpZXNbJ2dyb3VwaW5nLXNlcGFyYXRvciddKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAnRDMwODgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoc3VicGljdHVyZS5pbmRleE9mKHByb3BlcnRpZXNbJ2dyb3VwaW5nLXNlcGFyYXRvciddICsgcHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gJ0QzMDg5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvcHRpb25hbERpZ2l0UG9zID0gcGFydHMuaW50ZWdlclBhcnQuaW5kZXhPZihwcm9wZXJ0aWVzLmRpZ2l0KTtcbiAgICAgICAgICAgIGlmKG9wdGlvbmFsRGlnaXRQb3MgIT09IC0xICYmIHBhcnRzLmludGVnZXJQYXJ0LnN1YnN0cmluZygwLCBvcHRpb25hbERpZ2l0UG9zKS5zcGxpdCgnJykuZmlsdGVyKGZ1bmN0aW9uKGNoYXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjaW1hbERpZ2l0RmFtaWx5LmluZGV4T2YoY2hhcikgPiAtMTtcbiAgICAgICAgICAgIH0pLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA5MCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25hbERpZ2l0UG9zID0gcGFydHMuZnJhY3Rpb25hbFBhcnQubGFzdEluZGV4T2YocHJvcGVydGllcy5kaWdpdCk7XG4gICAgICAgICAgICBpZihvcHRpb25hbERpZ2l0UG9zICE9PSAtMSAmJiBwYXJ0cy5mcmFjdGlvbmFsUGFydC5zdWJzdHJpbmcob3B0aW9uYWxEaWdpdFBvcykuc3BsaXQoJycpLmZpbHRlcihmdW5jdGlvbihjaGFyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY2ltYWxEaWdpdEZhbWlseS5pbmRleE9mKGNoYXIpID4gLTE7XG4gICAgICAgICAgICB9KS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAnRDMwOTEnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGV4cG9uZW50RXhpc3RzID0gKHR5cGVvZiBwYXJ0cy5leHBvbmVudFBhcnQgPT09ICdzdHJpbmcnKTtcbiAgICAgICAgICAgIGlmKGV4cG9uZW50RXhpc3RzICYmIHBhcnRzLmV4cG9uZW50UGFydC5sZW5ndGggPiAwICYmIChzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllcy5wZXJjZW50KSAhPT0gLTEgfHwgc3VicGljdHVyZS5pbmRleE9mKHByb3BlcnRpZXNbJ3Blci1taWxsZSddKSAhPT0gLTEpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAnRDMwOTInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZXhwb25lbnRFeGlzdHMgJiYgKHBhcnRzLmV4cG9uZW50UGFydC5sZW5ndGggPT09IDAgfHwgcGFydHMuZXhwb25lbnRQYXJ0LnNwbGl0KCcnKS5maWx0ZXIoZnVuY3Rpb24oY2hhcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNpbWFsRGlnaXRGYW1pbHkuaW5kZXhPZihjaGFyKSA9PT0gLTE7XG4gICAgICAgICAgICB9KS5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gJ0QzMDkzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2tcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFuYWx5c2UgdGhlIHBpY3R1cmUgc3RyaW5nLCBGJk8gNC43LjRcbiAgICAgICAgdmFyIGFuYWx5c2UgPSBmdW5jdGlvbihwYXJ0cykge1xuICAgICAgICAgICAgdmFyIGdldEdyb3VwaW5nUG9zaXRpb25zID0gZnVuY3Rpb24ocGFydCwgdG9MZWZ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBncm91cGluZ1Bvc2l0aW9uID0gcGFydC5pbmRleE9mKHByb3BlcnRpZXNbJ2dyb3VwaW5nLXNlcGFyYXRvciddKTtcbiAgICAgICAgICAgICAgICB3aGlsZShncm91cGluZ1Bvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhcnNUb1RoZVJpZ2h0ID0gKHRvTGVmdCA/IHBhcnQuc3Vic3RyaW5nKDAsIGdyb3VwaW5nUG9zaXRpb24pIDogcGFydC5zdWJzdHJpbmcoZ3JvdXBpbmdQb3NpdGlvbikpLnNwbGl0KCcnKS5maWx0ZXIoZnVuY3Rpb24oY2hhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY2ltYWxEaWdpdEZhbWlseS5pbmRleE9mKGNoYXIpICE9PSAtMSB8fCBjaGFyID09PSBwcm9wZXJ0aWVzLmRpZ2l0O1xuICAgICAgICAgICAgICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKGNoYXJzVG9UaGVSaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwaW5nUG9zaXRpb24gPSBwYXJ0cy5pbnRlZ2VyUGFydC5pbmRleE9mKHByb3BlcnRpZXNbJ2dyb3VwaW5nLXNlcGFyYXRvciddLCBncm91cGluZ1Bvc2l0aW9uICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbnM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGludGVnZXJQYXJ0R3JvdXBpbmdQb3NpdGlvbnMgPSBnZXRHcm91cGluZ1Bvc2l0aW9ucyhwYXJ0cy5pbnRlZ2VyUGFydCk7XG4gICAgICAgICAgICB2YXIgcmVndWxhciA9IGZ1bmN0aW9uKGluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBhcmUgdGhlIGdyb3VwaW5nIHBvc2l0aW9ucyByZWd1bGFyPyBpLmUuIHNhbWUgaW50ZXJ2YWwgYmV0d2VlbiBlYWNoIG9mIHRoZW1cbiAgICAgICAgICAgICAgICBpZihpbmRleGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGdjZCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGIgPT09IDAgPyBhIDogZ2NkKGIsIGEgJSBiKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIGdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yIG9mIGFsbCB0aGUgcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IGluZGV4ZXMucmVkdWNlKGdjZCk7XG4gICAgICAgICAgICAgICAgLy8gaXMgZXZlcnkgcG9zaXRpb24gc2VwYXJhdGVkIGJ5IHRoaXMgZGl2aXNvcj8gSWYgc28sIGl0J3MgcmVndWxhclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaW5kZXggPSAxOyBpbmRleCA8PSBpbmRleGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBpZihpbmRleGVzLmluZGV4T2YoaW5kZXggKiBmYWN0b3IpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhY3RvcjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciByZWd1bGFyR3JvdXBpbmcgPSByZWd1bGFyKGludGVnZXJQYXJ0R3JvdXBpbmdQb3NpdGlvbnMpO1xuICAgICAgICAgICAgdmFyIGZyYWN0aW9uYWxQYXJ0R3JvdXBpbmdQb3NpdGlvbnMgPSBnZXRHcm91cGluZ1Bvc2l0aW9ucyhwYXJ0cy5mcmFjdGlvbmFsUGFydCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciBtaW5pbXVtSW50ZWdlclBhcnRTaXplID0gcGFydHMuaW50ZWdlclBhcnQuc3BsaXQoJycpLmZpbHRlcihmdW5jdGlvbihjaGFyKSB7IHJldHVybiBkZWNpbWFsRGlnaXRGYW1pbHkuaW5kZXhPZihjaGFyKSAhPT0gLTE7IH0pLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBzY2FsaW5nRmFjdG9yID0gbWluaW11bUludGVnZXJQYXJ0U2l6ZTtcblxuICAgICAgICAgICAgdmFyIGZyYWN0aW9uYWxQYXJ0QXJyYXkgPSBwYXJ0cy5mcmFjdGlvbmFsUGFydC5zcGxpdCgnJyk7XG4gICAgICAgICAgICB2YXIgbWluaW11bUZhY3Rpb25hbFBhcnRTaXplID0gZnJhY3Rpb25hbFBhcnRBcnJheS5maWx0ZXIoZnVuY3Rpb24oY2hhcikgeyByZXR1cm4gZGVjaW1hbERpZ2l0RmFtaWx5LmluZGV4T2YoY2hhcikgIT09IC0xOyB9KS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgbWF4aW11bUZhY3Rpb25hbFBhcnRTaXplID0gZnJhY3Rpb25hbFBhcnRBcnJheS5maWx0ZXIoZnVuY3Rpb24oY2hhcikgeyByZXR1cm4gZGVjaW1hbERpZ2l0RmFtaWx5LmluZGV4T2YoY2hhcikgIT09IC0xIHx8IGNoYXIgPT09IHByb3BlcnRpZXMuZGlnaXQ7IH0pLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBleHBvbmVudFByZXNlbnQgPSB0eXBlb2YgcGFydHMuZXhwb25lbnRQYXJ0ID09PSAnc3RyaW5nJztcbiAgICAgICAgICAgIGlmKG1pbmltdW1JbnRlZ2VyUGFydFNpemUgPT09IDAgJiYgbWF4aW11bUZhY3Rpb25hbFBhcnRTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYoZXhwb25lbnRQcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW1GYWN0aW9uYWxQYXJ0U2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIG1heGltdW1GYWN0aW9uYWxQYXJ0U2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bUludGVnZXJQYXJ0U2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZXhwb25lbnRQcmVzZW50ICYmIG1pbmltdW1JbnRlZ2VyUGFydFNpemUgPT09IDAgJiYgcGFydHMuaW50ZWdlclBhcnQuaW5kZXhPZihwcm9wZXJ0aWVzLmRpZ2l0KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBtaW5pbXVtSW50ZWdlclBhcnRTaXplID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKG1pbmltdW1JbnRlZ2VyUGFydFNpemUgPT09IDAgJiYgbWluaW11bUZhY3Rpb25hbFBhcnRTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWluaW11bUZhY3Rpb25hbFBhcnRTaXplID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtaW5pbXVtRXhwb25lbnRTaXplID0gMDtcbiAgICAgICAgICAgIGlmKGV4cG9uZW50UHJlc2VudCkge1xuICAgICAgICAgICAgICAgIG1pbmltdW1FeHBvbmVudFNpemUgPSBwYXJ0cy5leHBvbmVudFBhcnQuc3BsaXQoJycpLmZpbHRlcihmdW5jdGlvbihjaGFyKSB7IHJldHVybiBkZWNpbWFsRGlnaXRGYW1pbHkuaW5kZXhPZihjaGFyKSAhPT0gLTE7IH0pLmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbnRlZ2VyUGFydEdyb3VwaW5nUG9zaXRpb25zOiBpbnRlZ2VyUGFydEdyb3VwaW5nUG9zaXRpb25zLFxuICAgICAgICAgICAgICAgIHJlZ3VsYXJHcm91cGluZzogcmVndWxhckdyb3VwaW5nLFxuICAgICAgICAgICAgICAgIG1pbmltdW1JbnRlZ2VyUGFydFNpemU6IG1pbmltdW1JbnRlZ2VyUGFydFNpemUsXG4gICAgICAgICAgICAgICAgc2NhbGluZ0ZhY3Rvcjogc2NhbGluZ0ZhY3RvcixcbiAgICAgICAgICAgICAgICBwcmVmaXg6IHBhcnRzLnByZWZpeCxcbiAgICAgICAgICAgICAgICBmcmFjdGlvbmFsUGFydEdyb3VwaW5nUG9zaXRpb25zOiBmcmFjdGlvbmFsUGFydEdyb3VwaW5nUG9zaXRpb25zLFxuICAgICAgICAgICAgICAgIG1pbmltdW1GYWN0aW9uYWxQYXJ0U2l6ZTogbWluaW11bUZhY3Rpb25hbFBhcnRTaXplLFxuICAgICAgICAgICAgICAgIG1heGltdW1GYWN0aW9uYWxQYXJ0U2l6ZTogbWF4aW11bUZhY3Rpb25hbFBhcnRTaXplLFxuICAgICAgICAgICAgICAgIG1pbmltdW1FeHBvbmVudFNpemU6IG1pbmltdW1FeHBvbmVudFNpemUsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBwYXJ0cy5zdWZmaXgsXG4gICAgICAgICAgICAgICAgcGljdHVyZTogcGFydHMuc3VicGljdHVyZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcGFydHMgPSBzdWJQaWN0dXJlcy5tYXAoc3BsaXRQYXJ0cyk7XG4gICAgICAgIHBhcnRzLmZvckVhY2godmFsaWRhdGUpO1xuXG4gICAgICAgIHZhciB2YXJpYWJsZXMgPSBwYXJ0cy5tYXAoYW5hbHlzZSk7XG5cbiAgICAgICAgaWYodmFyaWFibGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFyaWFibGVzLnB1c2goSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YXJpYWJsZXNbMF0pKSk7XG4gICAgICAgICAgICB2YXJpYWJsZXNbMV0ucHJlZml4ID0gcHJvcGVydGllc1snbWludXMtc2lnbiddICsgdmFyaWFibGVzWzFdLnByZWZpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE8gY2FjaGUgdGhlIHJlc3VsdCBvZiB0aGUgYW5hbHlzaXNcblxuICAgICAgICAvLyBmb3JtYXQgdGhlIG51bWJlclxuICAgICAgICAvLyBidWxsZXQgMTogVE9ETzogTmFOIC0gbm90IHN1cmUgd2UnZCBldmVyIGdldCB0aGlzIGluIEpTT05cbiAgICAgICAgdmFyIHBpYztcbiAgICAgICAgLy8gYnVsbGV0IDI6XG4gICAgICAgIGlmKHZhbHVlID49IDApIHtcbiAgICAgICAgICAgIHBpYyA9IHZhcmlhYmxlc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBpYyA9IHZhcmlhYmxlc1sxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWRqdXN0ZWROdW1iZXI7XG4gICAgICAgIC8vIGJ1bGxldCAzOlxuICAgICAgICBpZihwaWMucGljdHVyZS5pbmRleE9mKHByb3BlcnRpZXMucGVyY2VudCkgIT09IC0xKSB7XG4gICAgICAgICAgICBhZGp1c3RlZE51bWJlciA9IHZhbHVlICogMTAwO1xuICAgICAgICB9IGVsc2UgaWYocGljLnBpY3R1cmUuaW5kZXhPZihwcm9wZXJ0aWVzWydwZXItbWlsbGUnXSkgIT09IC0xKSB7XG4gICAgICAgICAgICBhZGp1c3RlZE51bWJlciA9IHZhbHVlICogMTAwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkanVzdGVkTnVtYmVyID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnVsbGV0IDQ6XG4gICAgICAgIC8vIFRPRE86IGluZmluaXR5IC0gbm90IHN1cmUgd2UnZCBldmVyIGdldCB0aGlzIGluIEpTT05cbiAgICAgICAgLy8gYnVsbGV0IDU6XG4gICAgICAgIHZhciBtYW50aXNzYSwgZXhwb25lbnQ7XG4gICAgICAgIGlmKHBpYy5taW5pbXVtRXhwb25lbnRTaXplID09PSAwKSB7XG4gICAgICAgICAgICBtYW50aXNzYSA9IGFkanVzdGVkTnVtYmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbWFudGlzc2EgKiAxMF5leHBvbmVudCA9IGFkanVzdGVkTnVtYmVyXG4gICAgICAgICAgICB2YXIgbWF4TWFudGlzc2EgPSBNYXRoLnBvdygxMCwgcGljLnNjYWxpbmdGYWN0b3IpO1xuICAgICAgICAgICAgdmFyIG1pbk1hbnRpc3NhID0gTWF0aC5wb3coMTAsIHBpYy5zY2FsaW5nRmFjdG9yIC0gMSk7XG4gICAgICAgICAgICBtYW50aXNzYSA9IGFkanVzdGVkTnVtYmVyO1xuICAgICAgICAgICAgZXhwb25lbnQgPSAwO1xuICAgICAgICAgICAgd2hpbGUobWFudGlzc2EgPCBtaW5NYW50aXNzYSkge1xuICAgICAgICAgICAgICAgIG1hbnRpc3NhICo9IDEwO1xuICAgICAgICAgICAgICAgIGV4cG9uZW50IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZShtYW50aXNzYSA+IG1heE1hbnRpc3NhKSB7XG4gICAgICAgICAgICAgICAgbWFudGlzc2EgLz0gMTA7XG4gICAgICAgICAgICAgICAgZXhwb25lbnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBidWxsZXQgNjpcbiAgICAgICAgdmFyIHJvdW5kZWROdW1iZXIgPSBmdW5jdGlvblJvdW5kKG1hbnRpc3NhLCBwaWMubWF4aW11bUZhY3Rpb25hbFBhcnRTaXplKTtcbiAgICAgICAgLy8gYnVsbGV0IDc6XG4gICAgICAgIHZhciBtYWtlU3RyaW5nID0gZnVuY3Rpb24odmFsdWUsIGRwKSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gTWF0aC5hYnModmFsdWUpLnRvRml4ZWQoZHApO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNbJ3plcm8tZGlnaXQnXSAhPT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24gKGRpZ2l0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGRpZ2l0ID49ICcwJyAmJiBkaWdpdCA8PSc5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY2ltYWxEaWdpdEZhbWlseVtkaWdpdC5jaGFyQ29kZUF0KDApIC0gNDhdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZ2l0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuam9pbignJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSBtYWtlU3RyaW5nKHJvdW5kZWROdW1iZXIsIHBpYy5tYXhpbXVtRmFjdGlvbmFsUGFydFNpemUpO1xuICAgICAgICB2YXIgZGVjaW1hbFBvcyA9IHN0cmluZ1ZhbHVlLmluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYoZGVjaW1hbFBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gc3RyaW5nVmFsdWUgKyBwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZS5yZXBsYWNlKCcuJywgcHJvcGVydGllc1snZGVjaW1hbC1zZXBhcmF0b3InXSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUoc3RyaW5nVmFsdWUuY2hhckF0KDApID09PSBwcm9wZXJ0aWVzWyd6ZXJvLWRpZ2l0J10pIHtcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gc3RyaW5nVmFsdWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlKHN0cmluZ1ZhbHVlLmNoYXJBdChzdHJpbmdWYWx1ZS5sZW5ndGggLSAxKSA9PT0gcHJvcGVydGllc1snemVyby1kaWdpdCddKSB7XG4gICAgICAgICAgICBzdHJpbmdWYWx1ZSA9IHN0cmluZ1ZhbHVlLnN1YnN0cmluZygwLCBzdHJpbmdWYWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBidWxsZXRzIDggJiA5OlxuICAgICAgICBkZWNpbWFsUG9zID0gc3RyaW5nVmFsdWUuaW5kZXhPZihwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddKTtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBwaWMubWluaW11bUludGVnZXJQYXJ0U2l6ZSAtIGRlY2ltYWxQb3M7XG4gICAgICAgIHZhciBwYWRSaWdodCA9IHBpYy5taW5pbXVtRmFjdGlvbmFsUGFydFNpemUgLSAoc3RyaW5nVmFsdWUubGVuZ3RoIC0gZGVjaW1hbFBvcyAtIDEpO1xuICAgICAgICBzdHJpbmdWYWx1ZSA9IChwYWRMZWZ0ID4gMCA/IG5ldyBBcnJheShwYWRMZWZ0ICsgMSkuam9pbignMCcpIDogJycpICsgc3RyaW5nVmFsdWU7XG4gICAgICAgIHN0cmluZ1ZhbHVlID0gc3RyaW5nVmFsdWUgKyAocGFkUmlnaHQgPiAwID8gbmV3IEFycmF5KHBhZFJpZ2h0ICsgMSkuam9pbignMCcpIDogJycpO1xuICAgICAgICBkZWNpbWFsUG9zID0gc3RyaW5nVmFsdWUuaW5kZXhPZihwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddKTtcbiAgICAgICAgLy8gYnVsbGV0IDEwOlxuICAgICAgICBpZihwaWMucmVndWxhckdyb3VwaW5nID4gMCkge1xuICAgICAgICAgICAgdmFyIGdyb3VwQ291bnQgPSBNYXRoLmZsb29yKChkZWNpbWFsUG9zIC0gMSkgLyBwaWMucmVndWxhckdyb3VwaW5nKTtcbiAgICAgICAgICAgIGZvcih2YXIgZ3JvdXAgPSAxOyBncm91cCA8PSBncm91cENvdW50OyBncm91cCsrKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSBbc3RyaW5nVmFsdWUuc2xpY2UoMCwgZGVjaW1hbFBvcyAtIGdyb3VwICogcGljLnJlZ3VsYXJHcm91cGluZyksIHByb3BlcnRpZXNbJ2dyb3VwaW5nLXNlcGFyYXRvciddLCBzdHJpbmdWYWx1ZS5zbGljZShkZWNpbWFsUG9zIC0gZ3JvdXAgKiBwaWMucmVndWxhckdyb3VwaW5nKV0uam9pbignJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwaWMuaW50ZWdlclBhcnRHcm91cGluZ1Bvc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmdWYWx1ZSA9IFtzdHJpbmdWYWx1ZS5zbGljZSgwLCBkZWNpbWFsUG9zIC0gcG9zKSwgcHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10sIHN0cmluZ1ZhbHVlLnNsaWNlKGRlY2ltYWxQb3MgLSBwb3MpXS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICBkZWNpbWFsUG9zKys7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBidWxsZXQgMTE6XG4gICAgICAgIGRlY2ltYWxQb3MgPSBzdHJpbmdWYWx1ZS5pbmRleE9mKHByb3BlcnRpZXNbJ2RlY2ltYWwtc2VwYXJhdG9yJ10pO1xuICAgICAgICBwaWMuZnJhY3Rpb25hbFBhcnRHcm91cGluZ1Bvc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHBvcykge1xuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSBbc3RyaW5nVmFsdWUuc2xpY2UoMCwgcG9zICsgZGVjaW1hbFBvcyArIDEpLCBwcm9wZXJ0aWVzWydncm91cGluZy1zZXBhcmF0b3InXSwgc3RyaW5nVmFsdWUuc2xpY2UocG9zICsgZGVjaW1hbFBvcyArIDEpXS5qb2luKCcnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGJ1bGxldCAxMjpcbiAgICAgICAgZGVjaW1hbFBvcyA9IHN0cmluZ1ZhbHVlLmluZGV4T2YocHJvcGVydGllc1snZGVjaW1hbC1zZXBhcmF0b3InXSk7XG4gICAgICAgIGlmKHBpYy5waWN0dXJlLmluZGV4T2YocHJvcGVydGllc1snZGVjaW1hbC1zZXBhcmF0b3InXSkgPT09IC0xIHx8IGRlY2ltYWxQb3MgPT09IHN0cmluZ1ZhbHVlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gc3RyaW5nVmFsdWUuc3Vic3RyaW5nKDAsIHN0cmluZ1ZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ1bGxldCAxMzpcbiAgICAgICAgaWYodHlwZW9mIGV4cG9uZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdmFyIHN0cmluZ0V4cG9uZW50ID0gbWFrZVN0cmluZyhleHBvbmVudCwgMCk7XG4gICAgICAgICAgICBwYWRMZWZ0ID0gcGljLm1pbmltdW1FeHBvbmVudFNpemUgLSBzdHJpbmdFeHBvbmVudC5sZW5ndGg7XG4gICAgICAgICAgICBpZihwYWRMZWZ0ID4gMCkge1xuICAgICAgICAgICAgICAgIHN0cmluZ0V4cG9uZW50ID0gbmV3IEFycmF5KHBhZExlZnQgKyAxKS5qb2luKCcwJykgKyBzdHJpbmdFeHBvbmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gc3RyaW5nVmFsdWUgKyBwcm9wZXJ0aWVzWydleHBvbmVudC1zZXBhcmF0b3InXSArIChleHBvbmVudCA8IDAgPyBwcm9wZXJ0aWVzWydtaW51cy1zaWduJ10gOiAnJykgKyBzdHJpbmdFeHBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBidWxsZXQgMTQ6XG4gICAgICAgIHN0cmluZ1ZhbHVlID0gcGljLnByZWZpeCArIHN0cmluZ1ZhbHVlICsgcGljLnN1ZmZpeDtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgbnVtYmVyIHRvIGEgc3RyaW5nIHVzaW5nIGEgc3BlY2lmaWVkIG51bWJlciBiYXNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gdGhlIG51bWJlciB0byBjb252ZXJ0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpeF0gLSB0aGUgbnVtYmVyIGJhc2U7IG11c3QgYmUgYmV0d2VlbiAyIGFuZCAzNi4gRGVmYXVsdHMgdG8gMTBcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBjb252ZXJ0ZWQgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Gb3JtYXRCYXNlKHZhbHVlLCByYWRpeCkge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IGZ1bmN0aW9uUm91bmQodmFsdWUpO1xuXG4gICAgICAgIGlmKHR5cGVvZiByYWRpeCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJhZGl4ID0gMTA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYWRpeCA9IGZ1bmN0aW9uUm91bmQocmFkaXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocmFkaXggPCAyIHx8IHJhZGl4ID4gMzYpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiAnRDMxMDAnLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByYWRpeFxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKHJhZGl4KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3QgYXJndW1lbnQgdG8gbnVtYmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZyAtIEFyZ3VtZW50XG4gICAgICogQHJldHVybnMge051bWJlcn0gbnVtZXJpYyB2YWx1ZSBvZiBhcmd1bWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uTnVtYmVyKGFyZykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGFscmVhZHkgYSBudW1iZXJcbiAgICAgICAgICAgIHJlc3VsdCA9IGFyZztcbiAgICAgICAgfSBlbHNlIGlmKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnICYmIC9eLT8oMHwoWzEtOV1bMC05XSopKShcXC5bMC05XSspPyhbRWVdWy0rXT9bMC05XSspPyQvLnRlc3QoYXJnKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChhcmcpKSAmJiBpc0Zpbml0ZShhcmcpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJzZUZsb2F0KGFyZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgY29kZTogXCJEMzAzMFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhcmcsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgaW5kZXg6IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBYnNvbHV0ZSB2YWx1ZSBvZiBhIG51bWJlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmcgLSBBcmd1bWVudFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IGFic29sdXRlIHZhbHVlIG9mIGFyZ3VtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25BYnMoYXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IE1hdGguYWJzKGFyZyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUm91bmRzIGEgbnVtYmVyIGRvd24gdG8gaW50ZWdlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmcgLSBBcmd1bWVudFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHJvdW5kZWQgaW50ZWdlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uRmxvb3IoYXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IE1hdGguZmxvb3IoYXJnKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3VuZHMgYSBudW1iZXIgdXAgdG8gaW50ZWdlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmcgLSBBcmd1bWVudFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHJvdW5kZWQgaW50ZWdlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uQ2VpbChhcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gTWF0aC5jZWlsKGFyZyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUm91bmQgdG8gaGFsZiBldmVuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZyAtIEFyZ3VtZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByZWNpc2lvbiAtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHJvdW5kZWQgaW50ZWdlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uUm91bmQoYXJnLCBwcmVjaXNpb24pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAvLyBzaGlmdCB0aGUgZGVjaW1hbCBwbGFjZSAtIHRoaXMgbmVlZHMgdG8gYmUgZG9uZSBpbiBhIHN0cmluZyBzaW5jZSBtdWx0aXBseWluZ1xuICAgICAgICAgICAgLy8gYnkgYSBwb3dlciBvZiB0ZW4gY2FuIGludHJvZHVjZSBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24gZXJyb3JzIHdoaWNoIG1lc3MgdXBcbiAgICAgICAgICAgIC8vIHRoaXMgcm91bmRpbmcgYWxnb3JpdGhtIC0gU2VlICdEZWNpbWFsIHJvdW5kaW5nJyBpblxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9yb3VuZFxuICAgICAgICAgICAgLy8gU2hpZnRcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFyZy50b1N0cmluZygpLnNwbGl0KCdlJyk7XG4gICAgICAgICAgICBhcmcgPSArKHZhbHVlWzBdICsgJ2UnICsgKHZhbHVlWzFdID8gKCt2YWx1ZVsxXSArIHByZWNpc2lvbikgOiBwcmVjaXNpb24pKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcm91bmQgdXAgdG8gbmVhcmVzdCBpbnRcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5yb3VuZChhcmcpO1xuICAgICAgICB2YXIgZGlmZiA9IHJlc3VsdCAtIGFyZztcbiAgICAgICAgaWYoTWF0aC5hYnMoZGlmZikgPT09IDAuNSAmJiBNYXRoLmFicyhyZXN1bHQgJSAyKSA9PT0gMSkge1xuICAgICAgICAgICAgLy8gcm91bmRlZCB0aGUgd3Jvbmcgd2F5IC0gYWRqdXN0IHRvIG5lYXJlc3QgZXZlbiBudW1iZXJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYocHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAvLyBTaGlmdCBiYWNrXG4gICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdC50b1N0cmluZygpLnNwbGl0KCdlJyk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgcmVzdWx0ID0gKyh2YWx1ZVswXSArICdlJyArICh2YWx1ZVsxXSA/ICgrdmFsdWVbMV0gLSBwcmVjaXNpb24pIDogLXByZWNpc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIGlmKE9iamVjdC5pcyhyZXN1bHQsIC0wKSkgeyAvLyBFU0xpbnQgcnVsZSAnbm8tY29tcGFyZS1uZWctemVybycgc3VnZ2VzdHMgdGhpcyB3YXlcbiAgICAgICAgICAgIC8vIEpTT04gZG9lc24ndCBkbyAtMFxuICAgICAgICAgICAgcmVzdWx0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNxdWFyZSByb290IG9mIG51bWJlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmcgLSBBcmd1bWVudFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZSByb290XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25TcXJ0KGFyZykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihhcmcgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgY29kZTogXCJEMzA2MFwiLFxuICAgICAgICAgICAgICAgIGluZGV4OiAxLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhcmdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBNYXRoLnNxcnQoYXJnKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJhaXNlcyBudW1iZXIgdG8gdGhlIHBvd2VyIG9mIHRoZSBzZWNvbmQgbnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZyAtIHRoZSBiYXNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGV4cCAtIHRoZSBleHBvbmVudFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHJvdW5kZWQgaW50ZWdlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uUG93ZXIoYXJnLCBleHApIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gTWF0aC5wb3coYXJnLCBleHApO1xuXG4gICAgICAgIGlmKCFpc0Zpbml0ZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgY29kZTogXCJEMzA2MVwiLFxuICAgICAgICAgICAgICAgIGluZGV4OiAxLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhcmcsXG4gICAgICAgICAgICAgICAgZXhwOiBleHBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByYW5kb20gbnVtYmVyIDAgPD0gbiA8IDFcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSByYW5kb20gbnVtYmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25SYW5kb20oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGFuIGlucHV0IGFuZCByZXR1cm4gYSBib29sZWFuXG4gICAgICogQHBhcmFtIHsqfSBhcmcgLSBBcmd1bWVudHNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gQm9vbGVhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uQm9vbGVhbihhcmcpIHtcbiAgICAgICAgLy8gY2FzdCBhcmcgdG8gaXRzIGVmZmVjdGl2ZSBib29sZWFuIHZhbHVlXG4gICAgICAgIC8vIGJvb2xlYW46IHVuY2hhbmdlZFxuICAgICAgICAvLyBzdHJpbmc6IHplcm8tbGVuZ3RoIC0+IGZhbHNlOyBvdGhlcndpc2UgLT4gdHJ1ZVxuICAgICAgICAvLyBudW1iZXI6IDAgLT4gZmFsc2U7IG90aGVyd2lzZSAtPiB0cnVlXG4gICAgICAgIC8vIG51bGwgLT4gZmFsc2VcbiAgICAgICAgLy8gYXJyYXk6IGVtcHR5IC0+IGZhbHNlOyBsZW5ndGggPiAxIC0+IHRydWVcbiAgICAgICAgLy8gb2JqZWN0OiBlbXB0eSAtPiBmYWxzZTsgbm9uLWVtcHR5IC0+IHRydWVcbiAgICAgICAgLy8gZnVuY3Rpb24gLT4gZmFsc2VcblxuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICBpZiAoYXJnLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uQm9vbGVhbihhcmdbMF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciB0cnVlcyA9IGFyZy5maWx0ZXIoZnVuY3Rpb24odmFsKSB7cmV0dXJuIGZ1bmN0aW9uQm9vbGVhbih2YWwpO30pO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWVzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1lcmljKGFyZykpIHtcbiAgICAgICAgICAgIGlmIChhcmcgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFyZyAhPT0gbnVsbCAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGFyZykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBpdCdzIG5vdCBhIGxhbWJkYSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGlmICghKGlzTGFtYmRhKGFyZykgfHwgYXJnLl9qc29uYXRhX2Z1bmN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgJiYgYXJnID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgQm9vbGVhbiBOT1Qgb2YgdGhlIGFyZ1xuICAgICAqIEBwYXJhbSB7Kn0gYXJnIC0gYXJndW1lbnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBOT1QgYXJnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Ob3QoYXJnKSB7XG4gICAgICAgIHJldHVybiAhZnVuY3Rpb25Cb29sZWFuKGFyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbWFwIGZyb20gYW4gYXJyYXkgb2YgYXJndW1lbnRzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2Fycl0gLSBhcnJheSB0byBtYXAgb3ZlclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgLSBmdW5jdGlvbiB0byBhcHBseVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gTWFwIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24qIGZ1bmN0aW9uTWFwKGFyciwgZnVuYykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcnIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAvLyBkbyB0aGUgbWFwIC0gaXRlcmF0ZSBvdmVyIHRoZSBhcnJheXMsIGFuZCBpbnZva2UgZnVuY1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZ1bmNfYXJncyA9IFthcnJbaV1dOyAvLyB0aGUgZmlyc3QgYXJnICh2YWx1ZSkgaXMgcmVxdWlyZWRcbiAgICAgICAgICAgIC8vIHRoZSBvdGhlciB0d28gYXJlIG9wdGlvbmFsIC0gb25seSBzdXBwbHkgaXQgaWYgdGhlIGZ1bmN0aW9uIGNhbiB0YWtlIGl0XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicgPyBmdW5jLmxlbmd0aCA6XG4gICAgICAgICAgICAgICAgZnVuYy5fanNvbmF0YV9mdW5jdGlvbiA9PT0gdHJ1ZSA/IGZ1bmMuaW1wbGVtZW50YXRpb24ubGVuZ3RoIDogZnVuYy5hcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgaWYobGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICBmdW5jX2FyZ3MucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICAgICAgZnVuY19hcmdzLnB1c2goYXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGludm9rZSBmdW5jXG4gICAgICAgICAgICB2YXIgcmVzID0geWllbGQgKiBhcHBseShmdW5jLCBmdW5jX2FyZ3MsIG51bGwpO1xuICAgICAgICAgICAgaWYodHlwZW9mIHJlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGdlbmVyYXRvciBmdW5jdGlvbiBkb2VzIG5vdCBoYXZlIGEgeWllbGQoKSwgcHJlc3VtYWJseSB0byBtYWtlIGl0XG4gICAgLy8gY29uc2lzdGVudCB3aXRoIG90aGVyIHNpbWlsYXIgZnVuY3Rpb25zLlxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG1hcCBmcm9tIGFuIGFycmF5IG9mIGFyZ3VtZW50c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJdIC0gYXJyYXkgdG8gZmlsdGVyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIHByZWRpY2F0ZSBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gTWFwIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24qIGZ1bmN0aW9uRmlsdGVyKGFyciwgZnVuYykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUteWllbGRcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICB2YXIgcHJlZGljYXRlID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBpdCA9IGFwcGx5KGZ1bmMsIFt2YWx1ZSwgaW5kZXgsIGFycmF5XSwgbnVsbCk7XG4gICAgICAgICAgICAvLyByZXR1cm5zIGEgZ2VuZXJhdG9yIC0gc28gaXRlcmF0ZSBvdmVyIGl0XG4gICAgICAgICAgICB2YXIgcmVzID0gaXQubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKCFyZXMuZG9uZSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IGl0Lm5leHQocmVzLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMudmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gYXJyW2ldO1xuICAgICAgICAgICAgaWYoZnVuY3Rpb25Cb29sZWFuKHByZWRpY2F0ZShlbnRyeSwgaSwgYXJyKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZvbHZlcyAoemlwcykgZWFjaCB2YWx1ZSBmcm9tIGEgc2V0IG9mIGFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXSAtIGFycmF5cyB0byB6aXBcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFppcHBlZCBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uWmlwKCkge1xuICAgICAgICAvLyB0aGlzIGNhbiB0YWtlIGEgdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgLy8gbGVuZ3RoIG9mIHRoZSBzaG9ydGVzdCBhcnJheVxuICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgYXJncy5tYXAoZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9KSk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHR1cGxlID0gYXJncy5tYXAoKGFyZykgPT4ge3JldHVybiBhcmdbaV07fSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0dXBsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb2xkIGxlZnQgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzZXF1ZW5jZSAtIFNlcXVlbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGluaXQgLSBJbml0aWFsIHZhbHVlXG4gICAgICogQHJldHVybnMgeyp9IFJlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBmdW5jdGlvbkZvbGRMZWZ0KHNlcXVlbmNlLCBmdW5jLCBpbml0KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHNlcXVlbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgaWYgKCEoZnVuYy5sZW5ndGggPT09IDIgfHwgKGZ1bmMuX2pzb25hdGFfZnVuY3Rpb24gPT09IHRydWUgJiYgZnVuYy5pbXBsZW1lbnRhdGlvbi5sZW5ndGggPT09IDIpIHx8IGZ1bmMuYXJndW1lbnRzLmxlbmd0aCA9PT0gMikpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMDUwXCIsXG4gICAgICAgICAgICAgICAgaW5kZXg6IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIGlmICh0eXBlb2YgaW5pdCA9PT0gJ3VuZGVmaW5lZCcgJiYgc2VxdWVuY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc2VxdWVuY2VbMF07XG4gICAgICAgICAgICBpbmRleCA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpbml0O1xuICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgc2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGFwcGx5KGZ1bmMsIFtyZXN1bHQsIHNlcXVlbmNlW2luZGV4XV0sIG51bGwpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGtleXMgZm9yIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmcgLSBPYmplY3RcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGtleXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbktleXMoYXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZihBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgIC8vIG1lcmdlIHRoZSBrZXlzIG9mIGFsbCBvZiB0aGUgaXRlbXMgaW4gdGhlIGFycmF5XG4gICAgICAgICAgICB2YXIgbWVyZ2UgPSB7fTtcbiAgICAgICAgICAgIGFyZy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IGZ1bmN0aW9uS2V5cyhpdGVtKTtcbiAgICAgICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uS2V5cyhtZXJnZSk7XG4gICAgICAgIH0gZWxzZSBpZihhcmcgIT09IG51bGwgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgIShpc0xhbWJkYShhcmcpKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gT2JqZWN0LmtleXMoYXJnKTtcbiAgICAgICAgICAgIGlmKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdmFsdWUgZnJvbSBhbiBvYmplY3QgZm9yIGEgZ2l2ZW4ga2V5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIE9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBLZXkgaW4gb2JqZWN0XG4gICAgICogQHJldHVybnMgeyp9IFZhbHVlIG9mIGtleSBpbiBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkxvb2t1cChvYmplY3QsIGtleSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZXZhbHVhdGVOYW1lKHt2YWx1ZToga2V5fSwgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgc2Vjb25kIGFyZ3VtZW50IHRvIGZpcnN0XG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGFyZzEgLSBGaXJzdCBhcmd1bWVudFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBhcmcyIC0gU2Vjb25kIGFyZ3VtZW50XG4gICAgICogQHJldHVybnMgeyp9IEFwcGVuZGVkIGFyZ3VtZW50c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uQXBwZW5kKGFyZzEsIGFyZzIpIHtcbiAgICAgICAgLy8gZGlzcmVnYXJkIHVuZGVmaW5lZCBhcmdzXG4gICAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmcyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmcxO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGVpdGhlciBhcmd1bWVudCBpcyBub3QgYW4gYXJyYXksIG1ha2UgaXQgc29cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICBhcmcxID0gW2FyZzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmcyKSkge1xuICAgICAgICAgICAgYXJnMiA9IFthcmcyXTtcbiAgICAgICAgfVxuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhcmcxLCBhcmcyKTtcbiAgICAgICAgcmV0dXJuIGFyZzE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgYXJndW1lbnQgaXMgdW5kZWZpbmVkXG4gICAgICogQHBhcmFtIHsqfSBhcmcgLSBhcmd1bWVudFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBGYWxzZSBpZiBhcmd1bWVudCB1bmRlZmluZWQsIG90aGVyd2lzZSB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25FeGlzdHMoYXJnKXtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhbiBvYmplY3QgaW50byBhbiBhcnJheSBvZiBvYmplY3Qgd2l0aCBvbmUgcHJvcGVydHkgZWFjaFxuICAgICAqIEBwYXJhbSB7Kn0gYXJnIC0gdGhlIG9iamVjdCB0byBzcGxpdFxuICAgICAqIEByZXR1cm5zIHsqfSAtIHRoZSBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU3ByZWFkKGFyZykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICAvLyBzcHJlYWQgYWxsIG9mIHRoZSBpdGVtcyBpbiB0aGUgYXJyYXlcbiAgICAgICAgICAgIGFyZy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jdGlvbkFwcGVuZChyZXN1bHQsIGZ1bmN0aW9uU3ByZWFkKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYoYXJnICE9PSBudWxsICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmICFpc0xhbWJkYShhcmcpKSB7XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBhcmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSBhcmdba2V5XTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXJnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIGFuIGFycmF5IG9mIG9iamVjdHMgaW50byBhIHNpbmdsZSBvYmplY3QuICBEdXBsaWNhdGUgcHJvcGVydGllcyBhcmVcbiAgICAgKiBvdmVycmlkZGVuIGJ5IGVudHJpZXMgbGF0ZXIgaW4gdGhlIGFycmF5XG4gICAgICogQHBhcmFtIHsqfSBhcmcgLSB0aGUgb2JqZWN0cyB0byBtZXJnZVxuICAgICAqIEByZXR1cm5zIHsqfSAtIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbk1lcmdlKGFyZykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIGFyZy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgZm9yKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIG9yZGVyIG9mIGl0ZW1zIGluIGFuIGFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyIC0gdGhlIGFycmF5IHRvIHJldmVyc2VcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IC0gdGhlIHJldmVyc2VkIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25SZXZlcnNlKGFycikge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcnIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYXJyLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbbGVuZ3RoIC0gaSAtIDFdID0gYXJyW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIC0gdGhlIGlucHV0IG9iamVjdCB0byBpdGVyYXRlIG92ZXJcbiAgICAgKiBAcGFyYW0geyp9IGZ1bmMgLSB0aGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBrZXkvdmFsdWUgcGFpclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gLSB0aGUgcmVzdWx0YW50IGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24qIGZ1bmN0aW9uRWFjaChvYmosIGZ1bmMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZvcih2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgdmFyIGZ1bmNfYXJncyA9IFtvYmpba2V5XSwga2V5XTtcbiAgICAgICAgICAgIC8vIGludm9rZSBmdW5jXG4gICAgICAgICAgICByZXN1bHQucHVzaCh5aWVsZCAqIGFwcGx5KGZ1bmMsIGZ1bmNfYXJncywgbnVsbCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIHRoZSBtZXJnZSBzb3J0IChzdGFibGUpIHdpdGggb3B0aW9uYWwgY29tcGFyYXRvciBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyIC0gdGhlIGFycmF5IHRvIHNvcnRcbiAgICAgKiBAcGFyYW0geyp9IGNvbXBhcmF0b3IgLSBjb21wYXJhdG9yIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge0FycmF5fSAtIHNvcnRlZCBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU29ydChhcnIsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGFyci5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb21wO1xuICAgICAgICBpZih0eXBlb2YgY29tcGFyYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIGluamVjdCBhIGRlZmF1bHQgY29tcGFyYXRvciAtIG9ubHkgd29ya3MgZm9yIG51bWVyaWMgb3Igc3RyaW5nIGFycmF5c1xuICAgICAgICAgICAgaWYgKCFpc0FycmF5T2ZOdW1iZXJzKGFycikgJiYgIWlzQXJyYXlPZlN0cmluZ3MoYXJyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiRDMwNzBcIixcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IDFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb21wID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSA+IGI7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYodHlwZW9mIGNvbXBhcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGZvciBpbnRlcm5hbCB1c2FnZSBvZiBmdW5jdGlvblNvcnQgKGkuZS4gb3JkZXItYnkgc3ludGF4KVxuICAgICAgICAgICAgY29tcCA9IGNvbXBhcmF0b3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXQgPSBhcHBseShjb21wYXJhdG9yLCBbYSwgYl0sIG51bGwpO1xuICAgICAgICAgICAgICAgIC8vIHJldHVybnMgYSBnZW5lcmF0b3IgLSBzbyBpdGVyYXRlIG92ZXIgaXRcbiAgICAgICAgICAgICAgICB2YXIgY29tcCA9IGl0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWNvbXAuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wID0gaXQubmV4dChjb21wLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAudmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1lcmdlID0gZnVuY3Rpb24obCwgcikge1xuICAgICAgICAgICAgdmFyIG1lcmdlX2l0ZXIgPSBmdW5jdGlvbihyZXN1bHQsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmlnaHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlc3VsdCwgbGVmdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21wKGxlZnRbMF0sIHJpZ2h0WzBdKSkgeyAvLyBpbnZva2UgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQgcmV0dXJucyB0cnVlIC0gc3dhcCBsZWZ0IGFuZCByaWdodFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChyaWdodFswXSk7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlX2l0ZXIocmVzdWx0LCBsZWZ0LCByaWdodC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGtlZXAgdGhlIHNhbWUgb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGVmdFswXSk7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlX2l0ZXIocmVzdWx0LCBsZWZ0LnNsaWNlKDEpLCByaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBtZXJnZWQgPSBbXTtcbiAgICAgICAgICAgIG1lcmdlX2l0ZXIobWVyZ2VkLCBsLCByKTtcbiAgICAgICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHNvcnQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgICAgICAgICAgaWYoYXJyYXkubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKGFycmF5Lmxlbmd0aCAvIDIpO1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gYXJyYXkuc2xpY2UoMCwgbWlkZGxlKTtcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBhcnJheS5zbGljZShtaWRkbGUpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBzb3J0KGxlZnQpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gc29ydChyaWdodCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gc29ydChhcnIpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmFuZG9tbHkgc2h1ZmZsZXMgdGhlIGNvbnRlbnRzIG9mIGFuIGFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyIC0gdGhlIGlucHV0IGFycmF5XG4gICAgICogQHJldHVybnMge0FycmF5fSB0aGUgc2h1ZmZsZWQgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblNodWZmbGUoYXJyKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihhcnIubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaHVmZmxlIHVzaW5nIHRoZSAnaW5zaWRlLW91dCcgdmFyaWFudCBvZiB0aGUgRmlzaGVyLVlhdGVzIGFsZ29yaXRobVxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpOyAvLyByYW5kb20gaW50ZWdlciBzdWNoIHRoYXQgMCDiiaQgaiDiiaQgaVxuICAgICAgICAgICAgaWYoaSAhPT0gaikge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHJlc3VsdFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtqXSA9IGFycltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhIHByZWRpY2F0ZSBmdW5jdGlvbiB0byBlYWNoIGtleS92YWx1ZSBwYWlyIGluIGFuIG9iamVjdCwgYW5kIHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmdcbiAgICAgKiBvbmx5IHRoZSBrZXkvdmFsdWUgcGFpcnMgdGhhdCBwYXNzZWQgdGhlIHByZWRpY2F0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFyZyAtIHRoZSBvYmplY3QgdG8gYmUgc2lmdGVkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGZ1bmMgLSB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uIChsYW1iZGEgb3IgbmF0aXZlKVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IC0gc2lmdGVkIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU2lmdChhcmcsIGZ1bmMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIHZhciBwcmVkaWNhdGUgPSBmdW5jdGlvbiAodmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgaXQgPSBhcHBseShmdW5jLCBbdmFsdWUsIGtleSwgb2JqZWN0XSwgbnVsbCk7XG4gICAgICAgICAgICAvLyByZXR1cm5zIGEgZ2VuZXJhdG9yIC0gc28gaXRlcmF0ZSBvdmVyIGl0XG4gICAgICAgICAgICB2YXIgcmVzID0gaXQubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKCFyZXMuZG9uZSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IGl0Lm5leHQocmVzLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMudmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yKHZhciBpdGVtIGluIGFyZykge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gYXJnW2l0ZW1dO1xuICAgICAgICAgICAgaWYoZnVuY3Rpb25Cb29sZWFuKHByZWRpY2F0ZShlbnRyeSwgaXRlbSwgYXJnKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaXRlbV0gPSBlbnRyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVtcHR5IG9iamVjdHMgc2hvdWxkIGJlIGNoYW5nZWQgdG8gdW5kZWZpbmVkXG4gICAgICAgIGlmKE9iamVjdC5rZXlzKHJlc3VsdCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBhbiBJU08gODYwMSBmb3JtYXR0ZWQgdGltZXN0YW1wXG4gICAgdmFyIGlzbzg2MDFyZWdleCA9IG5ldyBSZWdFeHAoJ15cXFxcZHs0fS1bMDFdXFxcXGQtWzAtM11cXFxcZFRbMC0yXVxcXFxkOlswLTVdXFxcXGQ6WzAtNV1cXFxcZFxcXFwuXFxcXGQrKFsrLV1bMC0yXVxcXFxkOlswLTVdXFxcXGR8WikkJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBJU08gODYwMSB0aW1lc3RhbXAgdG8gbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRpbWVzdGFtcCAtIHRoZSBJU08gODYwMSB0aW1lc3RhbXAgdG8gYmUgY29udmVydGVkXG4gICAgICogQHJldHVybnMge051bWJlcn0gLSBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGVwb2NoXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Ub01pbGxpcyh0aW1lc3RhbXApIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgdGltZXN0YW1wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFpc284NjAxcmVnZXgudGVzdCh0aW1lc3RhbXApKSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgY29kZTogXCJEMzExMFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aW1lc3RhbXBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRGF0ZS5wYXJzZSh0aW1lc3RhbXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2ggdG8gYW4gSVNPIDg2MDEgdGltZXN0YW1wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbGxpcyAtIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2ggdG8gYmUgY29udmVydGVkXG4gICAgICogQHJldHVybnMge1N0cmluZ30gLSBhbiBJU08gODYwMSBmb3JtYXR0ZWQgdGltZXN0YW1wXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Gcm9tTWlsbGlzKG1pbGxpcykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBtaWxsaXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1pbGxpcykudG9JU09TdHJpbmcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9uZXMgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZyAtIG9iamVjdCB0byBjbG9uZSAoZGVlcCBjb3B5KVxuICAgICAqIEByZXR1cm5zIHsqfSAtIHRoZSBjbG9uZWQgb2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25DbG9uZShhcmcpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGZ1bmN0aW9uU3RyaW5nKGFyZykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBmcmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbmNsb3NpbmdFbnZpcm9ubWVudCAtIEVuY2xvc2luZyBlbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHt7YmluZDogYmluZCwgbG9va3VwOiBsb29rdXB9fSBDcmVhdGVkIGZyYW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRnJhbWUoZW5jbG9zaW5nRW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIGJpbmRpbmdzID0ge307XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiaW5kOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvb2t1cDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYoYmluZGluZ3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBiaW5kaW5nc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVuY2xvc2luZ0Vudmlyb25tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZW5jbG9zaW5nRW52aXJvbm1lbnQubG9va3VwKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRnVuY3Rpb24gcmVnaXN0cmF0aW9uXG4gICAgc3RhdGljRnJhbWUuYmluZCgnc3VtJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TdW0sICc8YTxuPjpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdjb3VudCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQ291bnQsICc8YTpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdtYXgnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbk1heCwgJzxhPG4+Om4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ21pbicsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uTWluLCAnPGE8bj46bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnYXZlcmFnZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQXZlcmFnZSwgJzxhPG4+Om4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3N0cmluZycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uU3RyaW5nLCAnPHgtOnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3N1YnN0cmluZycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uU3Vic3RyaW5nLCAnPHMtbm4/OnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3N1YnN0cmluZ0JlZm9yZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uU3Vic3RyaW5nQmVmb3JlLCAnPHMtczpzPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdzdWJzdHJpbmdBZnRlcicsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uU3Vic3RyaW5nQWZ0ZXIsICc8cy1zOnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2xvd2VyY2FzZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uTG93ZXJjYXNlLCAnPHMtOnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3VwcGVyY2FzZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uVXBwZXJjYXNlLCAnPHMtOnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2xlbmd0aCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uTGVuZ3RoLCAnPHMtOm4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3RyaW0nLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblRyaW0sICc8cy06cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgncGFkJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25QYWQsICc8cy1ucz86cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnbWF0Y2gnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbk1hdGNoLCAnPHMtZjxzOm8+bj86YTxvPj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnY29udGFpbnMnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkNvbnRhaW5zLCAnPHMtKHNmKTpiPicpKTsgLy8gVE9ETyA8cy0oc2Y8czpvPik6Yj5cbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdyZXBsYWNlJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25SZXBsYWNlLCAnPHMtKHNmKShzZiluPzpzPicpKTsgLy8gVE9ETyA8cy0oc2Y8czpvPikoc2Y8bzpzPiluPzpzPlxuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3NwbGl0JywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TcGxpdCwgJzxzLShzZiluPzphPHM+PicpKTsgLy8gVE9ETyA8cy0oc2Y8czpvPiluPzphPHM+PlxuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2pvaW4nLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkpvaW4sICc8YTxzPnM/OnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2Zvcm1hdE51bWJlcicsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uRm9ybWF0TnVtYmVyLCAnPG4tc28/OnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2Zvcm1hdEJhc2UnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkZvcm1hdEJhc2UsICc8bi1uPzpzPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdudW1iZXInLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbk51bWJlciwgJzwobnMpLTpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdmbG9vcicsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uRmxvb3IsICc8bi06bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnY2VpbCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQ2VpbCwgJzxuLTpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdyb3VuZCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uUm91bmQsICc8bi1uPzpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdhYnMnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkFicywgJzxuLTpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdzcXJ0JywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TcXJ0LCAnPG4tOm4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3Bvd2VyJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Qb3dlciwgJzxuLW46bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgncmFuZG9tJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25SYW5kb20sICc8Om4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2Jvb2xlYW4nLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkJvb2xlYW4sICc8eC06Yj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnbm90JywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Ob3QsICc8eC06Yj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnbWFwJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25NYXAsICc8YWY+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3ppcCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uWmlwLCAnPGErPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdmaWx0ZXInLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkZpbHRlciwgJzxhZj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgncmVkdWNlJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Gb2xkTGVmdCwgJzxhZmo/Omo+JykpOyAvLyBUT0RPIDxmPGpqOmo+YTxqPmo/Omo+XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc2lmdCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uU2lmdCwgJzxvLWY/Om8+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2tleXMnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbktleXMsICc8eC06YTxzPj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnbG9va3VwJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Mb29rdXAsICc8eC1zOng+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2FwcGVuZCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQXBwZW5kLCAnPHh4OmE+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2V4aXN0cycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uRXhpc3RzLCAnPHg6Yj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc3ByZWFkJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TcHJlYWQsICc8eC06YTxvPj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnbWVyZ2UnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbk1lcmdlLCAnPGE8bz46bz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgncmV2ZXJzZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uUmV2ZXJzZSwgJzxhOmE+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2VhY2gnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkVhY2gsICc8by1mOmE+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3NvcnQnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblNvcnQsICc8YWY/OmE+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3NodWZmbGUnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblNodWZmbGUsICc8YTphPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdiYXNlNjRlbmNvZGUnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkJhc2U2NGVuY29kZSwgJzxzLTpzPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdiYXNlNjRkZWNvZGUnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkJhc2U2NGRlY29kZSwgJzxzLTpzPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCd0b01pbGxpcycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uVG9NaWxsaXMsICc8cy06bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnZnJvbU1pbGxpcycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uRnJvbU1pbGxpcywgJzxuLTpzPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdjbG9uZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQ2xvbmUsICc8KG9hKS06bz4nKSk7XG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2Rlc1xuICAgICAqXG4gICAgICovXG4gICAgdmFyIGVycm9yQ29kZXMgPSB7XG4gICAgICAgIFwiUzAxMDFcIjogXCJTdHJpbmcgbGl0ZXJhbCBtdXN0IGJlIHRlcm1pbmF0ZWQgYnkgYSBtYXRjaGluZyBxdW90ZVwiLFxuICAgICAgICBcIlMwMTAyXCI6IFwiTnVtYmVyIG91dCBvZiByYW5nZToge3t0b2tlbn19XCIsXG4gICAgICAgIFwiUzAxMDNcIjogXCJVbnN1cHBvcnRlZCBlc2NhcGUgc2VxdWVuY2U6IFxcXFx7e3Rva2VufX1cIixcbiAgICAgICAgXCJTMDEwNFwiOiBcIlRoZSBlc2NhcGUgc2VxdWVuY2UgXFxcXHUgbXVzdCBiZSBmb2xsb3dlZCBieSA0IGhleCBkaWdpdHNcIixcbiAgICAgICAgXCJTMDEwNVwiOiBcIlF1b3RlZCBwcm9wZXJ0eSBuYW1lIG11c3QgYmUgdGVybWluYXRlZCB3aXRoIGEgYmFja3F1b3RlIChgKVwiLFxuICAgICAgICBcIlMwMjAxXCI6IFwiU3ludGF4IGVycm9yOiB7e3Rva2VufX1cIixcbiAgICAgICAgXCJTMDIwMlwiOiBcIkV4cGVjdGVkIHt7dmFsdWV9fSwgZ290IHt7dG9rZW59fVwiLFxuICAgICAgICBcIlMwMjAzXCI6IFwiRXhwZWN0ZWQge3t2YWx1ZX19IGJlZm9yZSBlbmQgb2YgZXhwcmVzc2lvblwiLFxuICAgICAgICBcIlMwMjA0XCI6IFwiVW5rbm93biBvcGVyYXRvcjoge3t0b2tlbn19XCIsXG4gICAgICAgIFwiUzAyMDVcIjogXCJVbmV4cGVjdGVkIHRva2VuOiB7e3Rva2VufX1cIixcbiAgICAgICAgXCJTMDIwNlwiOiBcIlVua25vd24gZXhwcmVzc2lvbiB0eXBlOiB7e3Rva2VufX1cIixcbiAgICAgICAgXCJTMDIwN1wiOiBcIlVuZXhwZWN0ZWQgZW5kIG9mIGV4cHJlc3Npb25cIixcbiAgICAgICAgXCJTMDIwOFwiOiBcIlBhcmFtZXRlciB7e3ZhbHVlfX0gb2YgZnVuY3Rpb24gZGVmaW5pdGlvbiBtdXN0IGJlIGEgdmFyaWFibGUgbmFtZSAoc3RhcnQgd2l0aCAkKVwiLFxuICAgICAgICBcIlMwMjA5XCI6IFwiQSBwcmVkaWNhdGUgY2Fubm90IGZvbGxvdyBhIGdyb3VwaW5nIGV4cHJlc3Npb24gaW4gYSBzdGVwXCIsXG4gICAgICAgIFwiUzAyMTBcIjogXCJFYWNoIHN0ZXAgY2FuIG9ubHkgaGF2ZSBvbmUgZ3JvdXBpbmcgZXhwcmVzc2lvblwiLFxuICAgICAgICBcIlMwMjExXCI6IFwiVGhlIHN5bWJvbCB7e3Rva2VufX0gY2Fubm90IGJlIHVzZWQgYXMgYSB1bmFyeSBvcGVyYXRvclwiLFxuICAgICAgICBcIlMwMzAxXCI6IFwiRW1wdHkgcmVndWxhciBleHByZXNzaW9ucyBhcmUgbm90IGFsbG93ZWRcIixcbiAgICAgICAgXCJTMDMwMlwiOiBcIk5vIHRlcm1pbmF0aW5nIC8gaW4gcmVndWxhciBleHByZXNzaW9uXCIsXG4gICAgICAgIFwiUzA0MDJcIjogXCJDaG9pY2UgZ3JvdXBzIGNvbnRhaW5pbmcgcGFyYW1ldGVyaXplZCB0eXBlcyBhcmUgbm90IHN1cHBvcnRlZFwiLFxuICAgICAgICBcIlMwNDAxXCI6IFwiVHlwZSBwYXJhbWV0ZXJzIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gZnVuY3Rpb25zIGFuZCBhcnJheXNcIixcbiAgICAgICAgXCJTMDUwMFwiOiBcIkF0dGVtcHRlZCB0byBldmFsdWF0ZSBhbiBleHByZXNzaW9uIGNvbnRhaW5pbmcgc3ludGF4IGVycm9yKHMpXCIsXG4gICAgICAgIFwiVDA0MTBcIjogXCJBcmd1bWVudCB7e2luZGV4fX0gb2YgZnVuY3Rpb24ge3t0b2tlbn19IGRvZXMgbm90IG1hdGNoIGZ1bmN0aW9uIHNpZ25hdHVyZVwiLFxuICAgICAgICBcIlQwNDExXCI6IFwiQ29udGV4dCB2YWx1ZSBpcyBub3QgYSBjb21wYXRpYmxlIHR5cGUgd2l0aCBhcmd1bWVudCB7e2luZGV4fX0gb2YgZnVuY3Rpb24ge3t0b2tlbn19XCIsXG4gICAgICAgIFwiVDA0MTJcIjogXCJBcmd1bWVudCB7e2luZGV4fX0gb2YgZnVuY3Rpb24ge3t0b2tlbn19IG11c3QgYmUgYW4gYXJyYXkgb2Yge3t0eXBlfX1cIixcbiAgICAgICAgXCJEMTAwMVwiOiBcIk51bWJlciBvdXQgb2YgcmFuZ2U6IHt7dmFsdWV9fVwiLFxuICAgICAgICBcIkQxMDAyXCI6IFwiQ2Fubm90IG5lZ2F0ZSBhIG5vbi1udW1lcmljIHZhbHVlOiB7e3ZhbHVlfX1cIixcbiAgICAgICAgXCJUMTAwM1wiOiBcIktleSBpbiBvYmplY3Qgc3RydWN0dXJlIG11c3QgZXZhbHVhdGUgdG8gYSBzdHJpbmc7IGdvdDoge3t2YWx1ZX19XCIsXG4gICAgICAgIFwiRDEwMDRcIjogXCJSZWd1bGFyIGV4cHJlc3Npb24gbWF0Y2hlcyB6ZXJvIGxlbmd0aCBzdHJpbmdcIixcbiAgICAgICAgXCJUMTAwNVwiOiBcIkF0dGVtcHRlZCB0byBpbnZva2UgYSBub24tZnVuY3Rpb24uIERpZCB5b3UgbWVhbiAke3t7dG9rZW59fX0/XCIsXG4gICAgICAgIFwiVDEwMDZcIjogXCJBdHRlbXB0ZWQgdG8gaW52b2tlIGEgbm9uLWZ1bmN0aW9uXCIsXG4gICAgICAgIFwiVDEwMDdcIjogXCJBdHRlbXB0ZWQgdG8gcGFydGlhbGx5IGFwcGx5IGEgbm9uLWZ1bmN0aW9uLiBEaWQgeW91IG1lYW4gJHt7e3Rva2VufX19P1wiLFxuICAgICAgICBcIlQxMDA4XCI6IFwiQXR0ZW1wdGVkIHRvIHBhcnRpYWxseSBhcHBseSBhIG5vbi1mdW5jdGlvblwiLFxuICAgICAgICBcIlQyMDAxXCI6IFwiVGhlIGxlZnQgc2lkZSBvZiB0aGUge3t0b2tlbn19IG9wZXJhdG9yIG11c3QgZXZhbHVhdGUgdG8gYSBudW1iZXJcIixcbiAgICAgICAgXCJUMjAwMlwiOiBcIlRoZSByaWdodCBzaWRlIG9mIHRoZSB7e3Rva2VufX0gb3BlcmF0b3IgbXVzdCBldmFsdWF0ZSB0byBhIG51bWJlclwiLFxuICAgICAgICBcIlQyMDAzXCI6IFwiVGhlIGxlZnQgc2lkZSBvZiB0aGUgcmFuZ2Ugb3BlcmF0b3IgKC4uKSBtdXN0IGV2YWx1YXRlIHRvIGFuIGludGVnZXJcIixcbiAgICAgICAgXCJUMjAwNFwiOiBcIlRoZSByaWdodCBzaWRlIG9mIHRoZSByYW5nZSBvcGVyYXRvciAoLi4pIG11c3QgZXZhbHVhdGUgdG8gYW4gaW50ZWdlclwiLFxuICAgICAgICBcIkQyMDA1XCI6IFwiVGhlIGxlZnQgc2lkZSBvZiA6PSBtdXN0IGJlIGEgdmFyaWFibGUgbmFtZSAoc3RhcnQgd2l0aCAkKVwiLFxuICAgICAgICBcIlQyMDA2XCI6IFwiVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGZ1bmN0aW9uIGFwcGxpY2F0aW9uIG9wZXJhdG9yIH4+IG11c3QgYmUgYSBmdW5jdGlvblwiLFxuICAgICAgICBcIlQyMDA3XCI6IFwiVHlwZSBtaXNtYXRjaCB3aGVuIGNvbXBhcmluZyB2YWx1ZXMge3t2YWx1ZX19IGFuZCB7e3ZhbHVlMn19IGluIG9yZGVyLWJ5IGNsYXVzZVwiLFxuICAgICAgICBcIlQyMDA4XCI6IFwiVGhlIGV4cHJlc3Npb25zIHdpdGhpbiBhbiBvcmRlci1ieSBjbGF1c2UgbXVzdCBldmFsdWF0ZSB0byBudW1lcmljIG9yIHN0cmluZyB2YWx1ZXNcIixcbiAgICAgICAgXCJUMjAwOVwiOiBcIlRoZSB2YWx1ZXMge3t2YWx1ZX19IGFuZCB7e3ZhbHVlMn19IGVpdGhlciBzaWRlIG9mIG9wZXJhdG9yIHt7dG9rZW59fSBtdXN0IGJlIG9mIHRoZSBzYW1lIGRhdGEgdHlwZVwiLFxuICAgICAgICBcIlQyMDEwXCI6IFwiVGhlIGV4cHJlc3Npb25zIGVpdGhlciBzaWRlIG9mIG9wZXJhdG9yIHt7dG9rZW59fSBtdXN0IGV2YWx1YXRlIHRvIG51bWVyaWMgb3Igc3RyaW5nIHZhbHVlc1wiLFxuICAgICAgICBcIlQyMDExXCI6IFwiVGhlIGluc2VydC91cGRhdGUgY2xhdXNlIG9mIHRoZSB0cmFuc2Zvcm0gZXhwcmVzc2lvbiBtdXN0IGV2YWx1YXRlIHRvIGFuIG9iamVjdDoge3t2YWx1ZX19XCIsXG4gICAgICAgIFwiVDIwMTJcIjogXCJUaGUgZGVsZXRlIGNsYXVzZSBvZiB0aGUgdHJhbnNmb3JtIGV4cHJlc3Npb24gbXVzdCBldmFsdWF0ZSB0byBhIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzOiB7e3ZhbHVlfX1cIixcbiAgICAgICAgXCJUMjAxM1wiOiBcIlRoZSB0cmFuc2Zvcm0gZXhwcmVzc2lvbiBjbG9uZXMgdGhlIGlucHV0IG9iamVjdCB1c2luZyB0aGUgJGNsb25lKCkgZnVuY3Rpb24uICBUaGlzIGhhcyBiZWVuIG92ZXJyaWRkZW4gaW4gdGhlIGN1cnJlbnQgc2NvcGUgYnkgYSBub24tZnVuY3Rpb24uXCIsXG4gICAgICAgIFwiRDMwMDFcIjogXCJBdHRlbXB0aW5nIHRvIGludm9rZSBzdHJpbmcgZnVuY3Rpb24gb24gSW5maW5pdHkgb3IgTmFOXCIsXG4gICAgICAgIFwiRDMwMTBcIjogXCJTZWNvbmQgYXJndW1lbnQgb2YgcmVwbGFjZSBmdW5jdGlvbiBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nXCIsXG4gICAgICAgIFwiRDMwMTFcIjogXCJGb3VydGggYXJndW1lbnQgb2YgcmVwbGFjZSBmdW5jdGlvbiBtdXN0IGV2YWx1YXRlIHRvIGEgcG9zaXRpdmUgbnVtYmVyXCIsXG4gICAgICAgIFwiRDMwMTJcIjogXCJBdHRlbXB0ZWQgdG8gcmVwbGFjZSBhIG1hdGNoZWQgc3RyaW5nIHdpdGggYSBub24tc3RyaW5nIHZhbHVlXCIsXG4gICAgICAgIFwiRDMwMjBcIjogXCJUaGlyZCBhcmd1bWVudCBvZiBzcGxpdCBmdW5jdGlvbiBtdXN0IGV2YWx1YXRlIHRvIGEgcG9zaXRpdmUgbnVtYmVyXCIsXG4gICAgICAgIFwiRDMwMzBcIjogXCJVbmFibGUgdG8gY2FzdCB2YWx1ZSB0byBhIG51bWJlcjoge3t2YWx1ZX19XCIsXG4gICAgICAgIFwiRDMwNDBcIjogXCJUaGlyZCBhcmd1bWVudCBvZiBtYXRjaCBmdW5jdGlvbiBtdXN0IGV2YWx1YXRlIHRvIGEgcG9zaXRpdmUgbnVtYmVyXCIsXG4gICAgICAgIFwiRDMwNTBcIjogXCJGaXJzdCBhcmd1bWVudCBvZiByZWR1Y2UgZnVuY3Rpb24gbXVzdCBiZSBhIGZ1bmN0aW9uIHdpdGggdHdvIGFyZ3VtZW50c1wiLFxuICAgICAgICBcIkQzMDYwXCI6IFwiVGhlIHNxcnQgZnVuY3Rpb24gY2Fubm90IGJlIGFwcGxpZWQgdG8gYSBuZWdhdGl2ZSBudW1iZXI6IHt7dmFsdWV9fVwiLFxuICAgICAgICBcIkQzMDYxXCI6IFwiVGhlIHBvd2VyIGZ1bmN0aW9uIGhhcyByZXN1bHRlZCBpbiBhIHZhbHVlIHRoYXQgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzIGEgSlNPTiBudW1iZXI6IGJhc2U9e3t2YWx1ZX19LCBleHBvbmVudD17e2V4cH19XCIsXG4gICAgICAgIFwiRDMwNzBcIjogXCJUaGUgc2luZ2xlIGFyZ3VtZW50IGZvcm0gb2YgdGhlIHNvcnQgZnVuY3Rpb24gY2FuIG9ubHkgYmUgYXBwbGllZCB0byBhbiBhcnJheSBvZiBzdHJpbmdzIG9yIGFuIGFycmF5IG9mIG51bWJlcnMuICBVc2UgdGhlIHNlY29uZCBhcmd1bWVudCB0byBzcGVjaWZ5IGEgY29tcGFyaXNvbiBmdW5jdGlvblwiLFxuICAgICAgICBcIkQzMDgwXCI6IFwiVGhlIHBpY3R1cmUgc3RyaW5nIG11c3Qgb25seSBjb250YWluIGEgbWF4aW11bSBvZiB0d28gc3ViLXBpY3R1cmVzXCIsXG4gICAgICAgIFwiRDMwODFcIjogXCJUaGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBtb3JlIHRoYW4gb25lIGluc3RhbmNlIG9mIHRoZSAnZGVjaW1hbC1zZXBhcmF0b3InIGNoYXJhY3RlclwiLFxuICAgICAgICBcIkQzMDgyXCI6IFwiVGhlIHN1Yi1waWN0dXJlIG11c3Qgbm90IGNvbnRhaW4gbW9yZSB0aGFuIG9uZSBpbnN0YW5jZSBvZiB0aGUgJ3BlcmNlbnQnIGNoYXJhY3RlclwiLFxuICAgICAgICBcIkQzMDgzXCI6IFwiVGhlIHN1Yi1waWN0dXJlIG11c3Qgbm90IGNvbnRhaW4gbW9yZSB0aGFuIG9uZSBpbnN0YW5jZSBvZiB0aGUgJ3Blci1taWxsZScgY2hhcmFjdGVyXCIsXG4gICAgICAgIFwiRDMwODRcIjogXCJUaGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBib3RoIGEgJ3BlcmNlbnQnIGFuZCBhICdwZXItbWlsbGUnIGNoYXJhY3RlclwiLFxuICAgICAgICBcIkQzMDg1XCI6IFwiVGhlIG1hbnRpc3NhIHBhcnQgb2YgYSBzdWItcGljdHVyZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlciB0aGF0IGlzIGVpdGhlciBhbiAnb3B0aW9uYWwgZGlnaXQgY2hhcmFjdGVyJyBvciBhIG1lbWJlciBvZiB0aGUgJ2RlY2ltYWwgZGlnaXQgZmFtaWx5J1wiLFxuICAgICAgICBcIkQzMDg2XCI6IFwiVGhlIHN1Yi1waWN0dXJlIG11c3Qgbm90IGNvbnRhaW4gYSBwYXNzaXZlIGNoYXJhY3RlciB0aGF0IGlzIHByZWNlZGVkIGJ5IGFuIGFjdGl2ZSBjaGFyYWN0ZXIgYW5kIHRoYXQgaXMgZm9sbG93ZWQgYnkgYW5vdGhlciBhY3RpdmUgY2hhcmFjdGVyXCIsXG4gICAgICAgIFwiRDMwODdcIjogXCJUaGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBhICdncm91cGluZy1zZXBhcmF0b3InIGNoYXJhY3RlciB0aGF0IGFwcGVhcnMgYWRqYWNlbnQgdG8gYSAnZGVjaW1hbC1zZXBhcmF0b3InIGNoYXJhY3RlclwiLFxuICAgICAgICBcIkQzMDg4XCI6IFwiVGhlIHN1Yi1waWN0dXJlIG11c3Qgbm90IGNvbnRhaW4gYSAnZ3JvdXBpbmctc2VwYXJhdG9yJyBhdCB0aGUgZW5kIG9mIHRoZSBpbnRlZ2VyIHBhcnRcIixcbiAgICAgICAgXCJEMzA4OVwiOiBcIlRoZSBzdWItcGljdHVyZSBtdXN0IG5vdCBjb250YWluIHR3byBhZGphY2VudCBpbnN0YW5jZXMgb2YgdGhlICdncm91cGluZy1zZXBhcmF0b3InIGNoYXJhY3RlclwiLFxuICAgICAgICBcIkQzMDkwXCI6IFwiVGhlIGludGVnZXIgcGFydCBvZiB0aGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBhIG1lbWJlciBvZiB0aGUgJ2RlY2ltYWwgZGlnaXQgZmFtaWx5JyB0aGF0IGlzIGZvbGxvd2VkIGJ5IGFuIGluc3RhbmNlIG9mIHRoZSAnb3B0aW9uYWwgZGlnaXQgY2hhcmFjdGVyJ1wiLFxuICAgICAgICBcIkQzMDkxXCI6IFwiVGhlIGZyYWN0aW9uYWwgcGFydCBvZiB0aGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBhbiBpbnN0YW5jZSBvZiB0aGUgJ29wdGlvbmFsIGRpZ2l0IGNoYXJhY3RlcicgdGhhdCBpcyBmb2xsb3dlZCBieSBhIG1lbWJlciBvZiB0aGUgJ2RlY2ltYWwgZGlnaXQgZmFtaWx5J1wiLFxuICAgICAgICBcIkQzMDkyXCI6IFwiQSBzdWItcGljdHVyZSB0aGF0IGNvbnRhaW5zIGEgJ3BlcmNlbnQnIG9yICdwZXItbWlsbGUnIGNoYXJhY3RlciBtdXN0IG5vdCBjb250YWluIGEgY2hhcmFjdGVyIHRyZWF0ZWQgYXMgYW4gJ2V4cG9uZW50LXNlcGFyYXRvcidcIixcbiAgICAgICAgXCJEMzA5M1wiOiBcIlRoZSBleHBvbmVudCBwYXJ0IG9mIHRoZSBzdWItcGljdHVyZSBtdXN0IGNvbXByaXNlIG9ubHkgb2Ygb25lIG9yIG1vcmUgY2hhcmFjdGVycyB0aGF0IGFyZSBtZW1iZXJzIG9mIHRoZSAnZGVjaW1hbCBkaWdpdCBmYW1pbHknXCIsXG4gICAgICAgIFwiRDMxMDBcIjogXCJUaGUgcmFkaXggb2YgdGhlIGZvcm1hdEJhc2UgZnVuY3Rpb24gbXVzdCBiZSBiZXR3ZWVuIDIgYW5kIDM2LiAgSXQgd2FzIGdpdmVuIHt7dmFsdWV9fVwiLFxuICAgICAgICBcIkQzMTEwXCI6IFwiVGhlIGFyZ3VtZW50IG9mIHRoZSB0b01pbGxpcyBmdW5jdGlvbiBtdXN0IGJlIGFuIElTTyA4NjAxIGZvcm1hdHRlZCB0aW1lc3RhbXAuIEdpdmVuIHt7dmFsdWV9fVwiXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGxvb2t1cCBhIG1lc3NhZ2UgdGVtcGxhdGUgZnJvbSB0aGUgY2F0YWxvZyBhbmQgc3Vic3RpdHV0ZSB0aGUgaW5zZXJ0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlcnIgLSBlcnJvciBjb2RlIHRvIGxvb2t1cFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb29rdXBNZXNzYWdlKGVycikge1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICdVbmtub3duIGVycm9yJztcbiAgICAgICAgaWYodHlwZW9mIGVyci5tZXNzYWdlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IGVycm9yQ29kZXNbZXJyLmNvZGVdO1xuICAgICAgICBpZih0eXBlb2YgdGVtcGxhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgYW55IGhhbmRsZWJhcnMsIHJlcGxhY2UgdGhlbSB3aXRoIHRoZSBmaWVsZCByZWZlcmVuY2VzXG4gICAgICAgICAgICAvLyB0cmlwbGUgYnJhY2VzIC0gcmVwbGFjZSB3aXRoIHZhbHVlXG4gICAgICAgICAgICAvLyBkb3VibGUgYnJhY2VzIC0gcmVwbGFjZSB3aXRoIGpzb24gc3RyaW5naWZpZWQgdmFsdWVcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9cXHtcXHtcXHsoW159XSspfX19L2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJbYXJndW1lbnRzWzFdXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZSgvXFx7XFx7KFtefV0rKX19L2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShlcnJbYXJndW1lbnRzWzFdXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBKU09OYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMgLSByZWNvdmVyOiBhdHRlbXB0IHRvIHJlY292ZXIgb24gcGFyc2UgZXJyb3JcbiAgICAgKiBAcmV0dXJucyB7e2V2YWx1YXRlOiBldmFsdWF0ZSwgYXNzaWduOiBhc3NpZ259fSBFdmFsdWF0ZWQgZXhwcmVzc2lvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGpzb25hdGEoZXhwciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgYXN0O1xuICAgICAgICB2YXIgZXJyb3JzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXN0ID0gcGFyc2VyKGV4cHIsIG9wdGlvbnMgJiYgb3B0aW9ucy5yZWNvdmVyKTtcbiAgICAgICAgICAgIGVycm9ycyA9IGFzdC5lcnJvcnM7XG4gICAgICAgICAgICBkZWxldGUgYXN0LmVycm9ycztcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIC8vIGluc2VydCBlcnJvciBtZXNzYWdlIGludG8gc3RydWN0dXJlXG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9IGxvb2t1cE1lc3NhZ2UoZXJyKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW52aXJvbm1lbnQgPSBjcmVhdGVGcmFtZShzdGF0aWNGcmFtZSk7XG5cbiAgICAgICAgdmFyIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7IC8vIHdpbGwgYmUgb3ZlcnJpZGRlbiBvbiBlYWNoIGNhbGwgdG8gZXZhbHV0ZSgpXG4gICAgICAgIGVudmlyb25tZW50LmJpbmQoJ25vdycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVzdGFtcC50b0pTT04oKTtcbiAgICAgICAgfSwgJzw6cz4nKSk7XG4gICAgICAgIGVudmlyb25tZW50LmJpbmQoJ21pbGxpcycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVzdGFtcC5nZXRUaW1lKCk7XG4gICAgICAgIH0sICc8Om4+JykpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gKGlucHV0LCBiaW5kaW5ncywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBpZiB0aGUgZXhwcmVzc2lvbiBjb21waWxlZCB3aXRoIHN5bnRheCBlcnJvcnNcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgZXJyb3JzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogJ1MwNTAwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAwXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gbG9va3VwTWVzc2FnZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiaW5kaW5ncyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4ZWNfZW52O1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdmFyaWFibGUgYmluZGluZ3MgaGF2ZSBiZWVuIHBhc3NlZCBpbiAtIGNyZWF0ZSBhIGZyYW1lIHRvIGhvbGQgdGhlc2VcbiAgICAgICAgICAgICAgICAgICAgZXhlY19lbnYgPSBjcmVhdGVGcmFtZShlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHYgaW4gYmluZGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNfZW52LmJpbmQodiwgYmluZGluZ3Nbdl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXhlY19lbnYgPSBlbnZpcm9ubWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcHV0IHRoZSBpbnB1dCBkb2N1bWVudCBpbnRvIHRoZSBlbnZpcm9ubWVudCBhcyB0aGUgcm9vdCBvYmplY3RcbiAgICAgICAgICAgICAgICBleGVjX2Vudi5iaW5kKCckJywgaW5wdXQpO1xuXG4gICAgICAgICAgICAgICAgLy8gY2FwdHVyZSB0aGUgdGltZXN0YW1wIGFuZCBwdXQgaXQgaW4gdGhlIGV4ZWN1dGlvbiBlbnZpcm9ubWVudFxuICAgICAgICAgICAgICAgIC8vIHRoZSAkbm93KCkgYW5kICRtaWxsaXMoKSBmdW5jdGlvbnMgd2lsbCByZXR1cm4gdGhpcyB2YWx1ZSAtIHdoZW5ldmVyIGl0IGlzIGNhbGxlZFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0LCBpdDtcbiAgICAgICAgICAgICAgICAvLyBpZiBhIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHN1cHBsaWVkLCB0aGVuIGRyaXZlIHRoZSBnZW5lcmF0b3IgaW4gYSBwcm9taXNlIGNoYWluXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4ZWNfZW52LmJpbmQoJ19fanNvbmF0YV9hc3luYycsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGhlbkhhbmRsZXIgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl0Lm5leHQocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlLnRoZW4odGhlbkhhbmRsZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGxvb2t1cE1lc3NhZ2UoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpdCA9IGV2YWx1YXRlKGFzdCwgaW5wdXQsIGV4ZWNfZW52KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gaXQubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUudGhlbih0aGVuSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gY2FsbGJhY2sgZnVuY3Rpb24gLSBkcml2ZSB0aGUgZ2VuZXJhdG9yIHRvIGNvbXBsZXRpb24gc3luY2hyb25vdXNseVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQgPSBldmFsdWF0ZShhc3QsIGlucHV0LCBleGVjX2Vudik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBpdC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gaXQubmV4dChyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlcnQgZXJyb3IgbWVzc2FnZSBpbnRvIHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBsb29rdXBNZXNzYWdlKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXNzaWduOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBlbnZpcm9ubWVudC5iaW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWdpc3RlckZ1bmN0aW9uOiBmdW5jdGlvbihuYW1lLCBpbXBsZW1lbnRhdGlvbiwgc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmMgPSBkZWZpbmVGdW5jdGlvbihpbXBsZW1lbnRhdGlvbiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICBlbnZpcm9ubWVudC5iaW5kKG5hbWUsIGZ1bmMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAganNvbmF0YS5wYXJzZXIgPSBwYXJzZXI7IC8vIFRPRE8gcmVtb3ZlIHRoaXMgaW4gYSBmdXR1cmUgcmVsZWFzZSAtIHVzZSBhc3QoKSBpbnN0ZWFkXG5cbiAgICByZXR1cm4ganNvbmF0YTtcblxufSkoKTtcblxuLy8gbm9kZS5qcyBvbmx5IC0gZXhwb3J0IHRoZSBqc29uYXRhIGFuZCBwYXJzZXIgZnVuY3Rpb25zXG4vLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZVxuaWYodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGpzb25hdGE7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBsb2dsZXZlbCA9IHJlcXVpcmUoJ2xvZ2xldmVsJyk7XG52YXIgY2hhbGsgPSByZXF1aXJlKCdjaGFsaycpO1xuXG52YXIgbG9nZ2VycyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldExvZ2dlcjtcblxuZnVuY3Rpb24gZ2V0TG9nZ2VyKCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBfcmVmJGxldmVsID0gX3JlZi5sZXZlbCxcbiAgICAgIGxldmVsID0gX3JlZiRsZXZlbCA9PT0gdW5kZWZpbmVkID8gZ2V0RGVmYXVsdExldmVsKCkgOiBfcmVmJGxldmVsLFxuICAgICAgX3JlZiRwcmVmaXggPSBfcmVmLnByZWZpeCxcbiAgICAgIHByZWZpeCA9IF9yZWYkcHJlZml4ID09PSB1bmRlZmluZWQgPyAnJyA6IF9yZWYkcHJlZml4O1xuXG4gIGlmIChsb2dnZXJzW3ByZWZpeF0pIHtcbiAgICByZXR1cm4gbG9nZ2Vyc1twcmVmaXhdO1xuICB9XG4gIHZhciBjb2xvcmVkUHJlZml4ID0gcHJlZml4ID8gYCR7Y2hhbGsuZGltKHByZWZpeCl9IGAgOiAnJztcbiAgdmFyIGxldmVsUHJlZml4ID0ge1xuICAgIFRSQUNFOiBjaGFsay5kaW0oJ1tUUkFDRV0nKSxcbiAgICBERUJVRzogY2hhbGsuY3lhbignW0RFQlVHXScpLFxuICAgIElORk86IGNoYWxrLmJsdWUoJ1tJTkZPXScpLFxuICAgIFdBUk46IGNoYWxrLnllbGxvdygnW1dBUk5dJyksXG4gICAgRVJST1I6IGNoYWxrLnJlZCgnW0VSUk9SXScpXG4gIH07XG5cbiAgdmFyIGxvZ2dlciA9IGxvZ2xldmVsLmdldExvZ2dlcihgJHtwcmVmaXh9LWxvZ2dlcmApO1xuXG4gIC8vIHRoaXMgaXMgdGhlIHBsdWdpbiBcImFwaVwiXG4gIHZhciBvcmlnaW5hbEZhY3RvcnkgPSBsb2dnZXIubWV0aG9kRmFjdG9yeTtcbiAgbG9nZ2VyLm1ldGhvZEZhY3RvcnkgPSBtZXRob2RGYWN0b3J5O1xuXG4gIHZhciBvcmlnaW5hbFNldExldmVsID0gbG9nZ2VyLnNldExldmVsO1xuICBsb2dnZXIuc2V0TGV2ZWwgPSBzZXRMZXZlbDtcbiAgbG9nZ2VyLnNldExldmVsKGxldmVsKTtcbiAgbG9nZ2Vyc1twcmVmaXhdID0gbG9nZ2VyO1xuICByZXR1cm4gbG9nZ2VyO1xuXG4gIGZ1bmN0aW9uIG1ldGhvZEZhY3RvcnkoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZhY3RvcnlBcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBmYWN0b3J5QXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgbG9nTGV2ZWwgPSBmYWN0b3J5QXJnc1swXTtcblxuICAgIHZhciByYXdNZXRob2QgPSBvcmlnaW5hbEZhY3RvcnkuYXBwbHkodW5kZWZpbmVkLCBmYWN0b3J5QXJncyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhd01ldGhvZC5hcHBseSh1bmRlZmluZWQsIFtgJHtjb2xvcmVkUHJlZml4fSR7bGV2ZWxQcmVmaXhbbG9nTGV2ZWwudG9VcHBlckNhc2UoKV19OmBdLmNvbmNhdChhcmdzKSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldExldmVsKGxldmVsVG9TZXRUbykge1xuICAgIHZhciBwZXJzaXN0ID0gZmFsc2U7IC8vIHVzZXMgYnJvd3NlciBsb2NhbFN0b3JhZ2VcbiAgICByZXR1cm4gb3JpZ2luYWxTZXRMZXZlbC5jYWxsKGxvZ2dlciwgbGV2ZWxUb1NldFRvLCBwZXJzaXN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0TGV2ZWwoKSB7XG4gIHZhciBsb2dMZXZlbCA9IHByb2Nlc3MuZW52LkxPR19MRVZFTDtcblxuICBpZiAobG9nTGV2ZWwgPT09ICd1bmRlZmluZWQnIHx8ICFsb2dMZXZlbCkge1xuICAgIHJldHVybiAnd2Fybic7XG4gIH1cbiAgcmV0dXJuIGxvZ0xldmVsO1xufSIsIi8qXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuKi9cbihmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplXG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcblxuICAgIHZhciBsb2dNZXRob2RzID0gW1xuICAgICAgICBcInRyYWNlXCIsXG4gICAgICAgIFwiZGVidWdcIixcbiAgICAgICAgXCJpbmZvXCIsXG4gICAgICAgIFwid2FyblwiLFxuICAgICAgICBcImVycm9yXCJcbiAgICBdO1xuXG4gICAgLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNlxuICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnZcbiAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXNcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/XG4gICAgICAgICAgICAgICAgbm9vcCA6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xuICAgIH1cblxuICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XG4gICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGRlZmF1bHRMZXZlbCwgZmFjdG9yeSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGN1cnJlbnRMZXZlbDtcbiAgICAgIHZhciBzdG9yYWdlS2V5ID0gXCJsb2dsZXZlbFwiO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXG4gICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjb29raWUuaW5kZXhPZihcbiAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIik7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXRMZXZlbChpbml0aWFsTGV2ZWwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqXG4gICAgICogVG9wLWxldmVsIEFQSVxuICAgICAqXG4gICAgICovXG5cbiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXG4gICAgICAgICAgICBuYW1lLCBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCksIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pKTtcbiIsInZhciBwZXJmb3JtYW5jZSA9IGdsb2JhbC5wZXJmb3JtYW5jZSB8fCB7fTtcblxudmFyIHByZXNlbnQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgbmFtZXMgPSBbJ25vdycsICd3ZWJraXROb3cnLCAnbXNOb3cnLCAnbW96Tm93JywgJ29Ob3cnXTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCkge1xuICAgIHZhciBuYW1lID0gbmFtZXMuc2hpZnQoKTtcbiAgICBpZiAobmFtZSBpbiBwZXJmb3JtYW5jZSkge1xuICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlW25hbWVdLmJpbmQocGVyZm9ybWFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkYXRlTm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH07XG4gIHZhciBuYXZpZ2F0aW9uU3RhcnQgPSAocGVyZm9ybWFuY2UudGltaW5nIHx8IHt9KS5uYXZpZ2F0aW9uU3RhcnQgfHwgZGF0ZU5vdygpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkYXRlTm93KCkgLSBuYXZpZ2F0aW9uU3RhcnQ7XG4gIH07XG59KCkpO1xuXG5wcmVzZW50LnBlcmZvcm1hbmNlTm93ID0gcGVyZm9ybWFuY2Uubm93O1xucHJlc2VudC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICBwZXJmb3JtYW5jZS5ub3cgPSBwcmVzZW50LnBlcmZvcm1hbmNlTm93O1xufTtcbnByZXNlbnQuY29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHBlcmZvcm1hbmNlLm5vdyA9IHByZXNlbnQ7XG59O1xucHJlc2VudC5jb25mbGljdCgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByZXNlbnQ7XG4iLCIvLyBFeHBvcnQgLi9saWIvcmFuZGdlblxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9yYW5kZ2VuXCIpO1xuIiwiLypqc2xpbnQgaW5kZW50OiAyLCBwbHVzcGx1czogdHJ1ZSwgc2xvcHB5OiB0cnVlICovXG4vLyBHZW5lcmF0ZSB1bmlmb3JtbHkgZGlzdHJpYnV0ZWQgcmFuZG9tIG51bWJlcnNcbi8vIEdpdmVzIGEgcmFuZG9tIG51bWJlciBvbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4KS5cbi8vIElmIGRpc2NyZXRlIGlzIHRydWUsIHRoZSBudW1iZXIgd2lsbCBiZSBhbiBpbnRlZ2VyLlxuZnVuY3Rpb24gcnVuaWYobWluLCBtYXgsIGRpc2NyZXRlKSB7XG4gIGlmIChtaW4gPT09IHVuZGVmaW5lZCkge1xuICAgIG1pbiA9IDA7XG4gIH1cbiAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWF4ID0gMTtcbiAgfVxuICBpZiAoZGlzY3JldGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGRpc2NyZXRlID0gZmFsc2U7XG4gIH1cbiAgaWYgKGRpc2NyZXRlKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IocnVuaWYobWluLCBtYXgsIGZhbHNlKSk7XG4gIH1cbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcbn1cblxuLy8gR2VuZXJhdGUgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIG51Ym1lcnNcbi8vIEFsZ29yaXRobSBhZGFwdGVkIGZyb206XG4vLyBodHRwOi8vYy1mYXEuY29tL2xpYi9nYXVzc2lhbi5odG1sXG5mdW5jdGlvbiBybm9ybShtZWFuLCBzdGRldikge1xuICB2YXIgdTEsIHUyLCB2MSwgdjIsIHM7XG4gIGlmIChtZWFuID09PSB1bmRlZmluZWQpIHtcbiAgICBtZWFuID0gMC4wO1xuICB9XG4gIGlmIChzdGRldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RkZXYgPSAxLjA7XG4gIH1cbiAgaWYgKHJub3JtLnYyID09PSBudWxsKSB7XG4gICAgZG8ge1xuICAgICAgdTEgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgdTIgPSBNYXRoLnJhbmRvbSgpO1xuXG4gICAgICB2MSA9IDIgKiB1MSAtIDE7XG4gICAgICB2MiA9IDIgKiB1MiAtIDE7XG4gICAgICBzID0gdjEgKiB2MSArIHYyICogdjI7XG4gICAgfSB3aGlsZSAocyA9PT0gMCB8fCBzID49IDEpO1xuXG4gICAgcm5vcm0udjIgPSB2MiAqIE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHMpIC8gcyk7XG4gICAgcmV0dXJuIHN0ZGV2ICogdjEgKiBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhzKSAvIHMpICsgbWVhbjtcbiAgfVxuXG4gIHYyID0gcm5vcm0udjI7XG4gIHJub3JtLnYyID0gbnVsbDtcbiAgcmV0dXJuIHN0ZGV2ICogdjIgKyBtZWFuO1xufVxuXG5ybm9ybS52MiA9IG51bGw7XG5cbi8vIEdlbmVyYXRlIENoaS1zcXVhcmUgZGlzdHJpYnV0ZWQgcmFuZG9tIG51bWJlcnNcbmZ1bmN0aW9uIHJjaGlzcShkZWdyZWVzT2ZGcmVlZG9tKSB7XG4gIGlmIChkZWdyZWVzT2ZGcmVlZG9tID09PSB1bmRlZmluZWQpIHtcbiAgICBkZWdyZWVzT2ZGcmVlZG9tID0gMTtcbiAgfVxuICB2YXIgaSwgeiwgc3VtID0gMC4wO1xuICBmb3IgKGkgPSAwOyBpIDwgZGVncmVlc09mRnJlZWRvbTsgaSsrKSB7XG4gICAgeiA9IHJub3JtKCk7XG4gICAgc3VtICs9IHogKiB6O1xuICB9XG5cbiAgcmV0dXJuIHN1bTtcbn1cblxuLy8gR2VuZXJhdGUgUG9pc3NvbiBkaXN0cmlidXRlZCByYW5kb20gbnVtYmVyc1xuZnVuY3Rpb24gcnBvaXNzb24obGFtYmRhKSB7XG4gIGlmIChsYW1iZGEgPT09IHVuZGVmaW5lZCkge1xuICAgIGxhbWJkYSA9IDE7XG4gIH1cbiAgdmFyIGwgPSBNYXRoLmV4cCgtbGFtYmRhKSxcbiAgICBrID0gMCxcbiAgICBwID0gMS4wO1xuICBkbyB7XG4gICAgaysrO1xuICAgIHAgKj0gTWF0aC5yYW5kb20oKTtcbiAgfSB3aGlsZSAocCA+IGwpO1xuXG4gIHJldHVybiBrIC0gMTtcbn1cblxuLy8gR2VuZXJhdGUgQ2F1Y2h5IGRpc3RyaWJ1dGVkIHJhbmRvbSBudW1iZXJzXG5mdW5jdGlvbiByY2F1Y2h5KGxvYywgc2NhbGUpIHtcbiAgaWYgKGxvYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbG9jID0gMC4wO1xuICB9XG4gIGlmIChzY2FsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc2NhbGUgPSAxLjA7XG4gIH1cbiAgdmFyIG4yLCBuMSA9IHJub3JtKCk7XG4gIGRvIHtcbiAgICBuMiA9IHJub3JtKCk7XG4gIH0gd2hpbGUgKG4yID09PSAwLjApO1xuXG4gIHJldHVybiBsb2MgKyBzY2FsZSAqIG4xIC8gbjI7XG59XG5cbi8vIEJlcm5vdWxsaSBkaXN0cmlidXRpb246IGdpdmVzIDEgd2l0aCBwcm9iYWJpbGl0eSBwXG5mdW5jdGlvbiByYmVybm91bGxpKHApIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkgPCBwID8gMSA6IDA7XG59XG5cbi8vIFZlY3Rvcml6ZSBhIHJhbmRvbSBnZW5lcmF0b3JcbmZ1bmN0aW9uIHZlY3Rvcml6ZShnZW5lcmF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbiwgcmVzdWx0LCBpLCBhcmdzO1xuICAgIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICBuID0gYXJncy5zaGlmdCgpO1xuICAgIHJlc3VsdCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRvci5hcHBseSh0aGlzLCBhcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8vIEdlbmVyYXRlIGEgaGlzdG9ncmFtIGZyb20gYSBsaXN0IG9mIG51bWJlcnNcbmZ1bmN0aW9uIGhpc3RvZ3JhbShkYXRhLCBiaW5Db3VudCkge1xuICBiaW5Db3VudCA9IGJpbkNvdW50IHx8IDEwO1xuXG4gIHZhciBiaW5zLCBpLCBzY2FsZWQsXG4gICAgbWF4ID0gTWF0aC5tYXguYXBwbHkodGhpcywgZGF0YSksXG4gICAgbWluID0gTWF0aC5taW4uYXBwbHkodGhpcywgZGF0YSk7XG5cbiAgLy8gZWRnZSBjYXNlOiBtYXggPT0gbWluXG4gIGlmIChtYXggPT09IG1pbikge1xuICAgIHJldHVybiBbZGF0YS5sZW5ndGhdO1xuICB9XG5cbiAgYmlucyA9IFtdO1xuXG4gIC8vIHplcm8gZWFjaCBiaW5cbiAgZm9yIChpID0gMDsgaSA8IGJpbkNvdW50OyBpKyspIHtcbiAgICBiaW5zLnB1c2goMCk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIC8vIHNjYWxlIGl0IHRvIGJlIGJldHdlZW4gMCBhbmQgMVxuICAgIHNjYWxlZCA9IChkYXRhW2ldIC0gbWluKSAvIChtYXggLSBtaW4pO1xuXG4gICAgLy8gc2NhbGUgaXQgdXAgdG8gdGhlIGhpc3RvZ3JhbSBzaXplXG4gICAgc2NhbGVkICo9IGJpbkNvdW50O1xuXG4gICAgLy8gZHJvcCBpdCBpbiBhIGJpblxuICAgIHNjYWxlZCA9IE1hdGguZmxvb3Ioc2NhbGVkKTtcblxuICAgIC8vIGVkZ2UgY2FzZTogdGhlIG1heFxuICAgIGlmIChzY2FsZWQgPT09IGJpbkNvdW50KSB7IHNjYWxlZC0tOyB9XG5cbiAgICBiaW5zW3NjYWxlZF0rKztcbiAgfVxuXG4gIHJldHVybiBiaW5zO1xufVxuXG4vKipcbiAqIEdldCBhIHJhbmRvbSBlbGVtZW50IGZyb20gYSBsaXN0XG4gKi9cbmZ1bmN0aW9uIHJsaXN0KGxpc3QpIHtcbiAgcmV0dXJuIGxpc3RbcnVuaWYoMCwgbGlzdC5sZW5ndGgsIHRydWUpXTtcbn1cblxuZXhwb3J0cy5ydW5pZiA9IHJ1bmlmO1xuZXhwb3J0cy5ybm9ybSA9IHJub3JtO1xuZXhwb3J0cy5yY2hpc3EgPSByY2hpc3E7XG5leHBvcnRzLnJwb2lzc29uID0gcnBvaXNzb247XG5leHBvcnRzLnJjYXVjaHkgPSByY2F1Y2h5O1xuZXhwb3J0cy5yYmVybm91bGxpID0gcmJlcm5vdWxsaTtcbmV4cG9ydHMucmxpc3QgPSBybGlzdDtcblxuZXhwb3J0cy5ydnVuaWYgPSB2ZWN0b3JpemUocnVuaWYpO1xuZXhwb3J0cy5ydm5vcm0gPSB2ZWN0b3JpemUocm5vcm0pO1xuZXhwb3J0cy5ydmNoaXNxID0gdmVjdG9yaXplKHJjaGlzcSk7XG5leHBvcnRzLnJ2cG9pc3NvbiA9IHZlY3Rvcml6ZShycG9pc3Nvbik7XG5leHBvcnRzLnJ2Y2F1Y2h5ID0gdmVjdG9yaXplKHJjYXVjaHkpO1xuZXhwb3J0cy5ydmJlcm5vdWxsaSA9IHZlY3Rvcml6ZShyYmVybm91bGxpKTtcbmV4cG9ydHMucnZsaXN0ID0gdmVjdG9yaXplKHJsaXN0KTtcblxuZXhwb3J0cy5oaXN0b2dyYW0gPSBoaXN0b2dyYW07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYW5zaVJlZ2V4ID0gcmVxdWlyZSgnYW5zaS1yZWdleCcpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuXHRyZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBzdHIucmVwbGFjZShhbnNpUmVnZXgsICcnKSA6IHN0cjtcbn07XG4iLCIvKiBqc2hpbnQgbm9kZTogdHJ1ZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBtYWtlQXJyYXlGcm9tKG9iaikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KG9iaik7XG59XG52YXJcbiAgUEVORElORyA9IFwicGVuZGluZ1wiLFxuICBSRVNPTFZFRCA9IFwicmVzb2x2ZWRcIixcbiAgUkVKRUNURUQgPSBcInJlamVjdGVkXCI7XG5cbmZ1bmN0aW9uIFN5bmNocm9ub3VzUHJvbWlzZShoYW5kbGVyKSB7XG4gIHRoaXMuc3RhdHVzID0gUEVORElORztcbiAgdGhpcy5fY29udGludWF0aW9ucyA9IFtdO1xuICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgaWYgKGhhbmRsZXIpIHtcbiAgICBoYW5kbGVyLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgdGhpcy5fY29udGludWVXaXRoLmJpbmQodGhpcyksXG4gICAgICB0aGlzLl9mYWlsV2l0aC5iaW5kKHRoaXMpXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsb29rc0xpa2VBUHJvbWlzZShvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgKG9iai50aGVuKSA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG5TeW5jaHJvbm91c1Byb21pc2UucHJvdG90eXBlID0ge1xuICB0aGVuOiBmdW5jdGlvbiAobmV4dEZuLCBjYXRjaEZuKSB7XG4gICAgdmFyIG5leHQgPSBTeW5jaHJvbm91c1Byb21pc2UudW5yZXNvbHZlZCgpLl9zZXRQYXJlbnQodGhpcyk7XG4gICAgaWYgKHRoaXMuX2lzUmVqZWN0ZWQoKSkge1xuICAgICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgICB0aGlzLl9jb250aW51YXRpb25zLnB1c2goe1xuICAgICAgICAgIHByb21pc2U6IG5leHQsXG4gICAgICAgICAgbmV4dEZuOiBuZXh0Rm4sXG4gICAgICAgICAgY2F0Y2hGbjogY2F0Y2hGblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9XG4gICAgICBpZiAoY2F0Y2hGbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBjYXRjaFJlc3VsdCA9IGNhdGNoRm4odGhpcy5fZXJyb3IpO1xuICAgICAgICAgIGlmIChsb29rc0xpa2VBUHJvbWlzZShjYXRjaFJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYWluUHJvbWlzZURhdGEoY2F0Y2hSZXN1bHQsIG5leHQpO1xuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZShjYXRjaFJlc3VsdCkuX3NldFBhcmVudCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlamVjdChlKS5fc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlamVjdCh0aGlzLl9lcnJvcikuX3NldFBhcmVudCh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5fY29udGludWF0aW9ucy5wdXNoKHtcbiAgICAgIHByb21pc2U6IG5leHQsXG4gICAgICBuZXh0Rm46IG5leHRGbixcbiAgICAgIGNhdGNoRm46IGNhdGNoRm5cbiAgICB9KTtcbiAgICB0aGlzLl9ydW5SZXNvbHV0aW9ucygpO1xuICAgIHJldHVybiBuZXh0O1xuICB9LFxuICBjYXRjaDogZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSB7XG4gICAgICByZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUodGhpcy5fZGF0YSkuX3NldFBhcmVudCh0aGlzKTtcbiAgICB9XG4gICAgdmFyIG5leHQgPSBTeW5jaHJvbm91c1Byb21pc2UudW5yZXNvbHZlZCgpLl9zZXRQYXJlbnQodGhpcyk7XG4gICAgdGhpcy5fY29udGludWF0aW9ucy5wdXNoKHtcbiAgICAgIHByb21pc2U6IG5leHQsXG4gICAgICBjYXRjaEZuOiBoYW5kbGVyXG4gICAgfSk7XG4gICAgdGhpcy5fcnVuUmVqZWN0aW9ucygpO1xuICAgIHJldHVybiBuZXh0O1xuICB9LFxuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmaXJzdFBhdXNlZCA9IHRoaXMuX2ZpbmRGaXJzdFBhdXNlZCgpO1xuICAgIGlmIChmaXJzdFBhdXNlZCkge1xuICAgICAgZmlyc3RQYXVzZWQuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgZmlyc3RQYXVzZWQuX3J1blJlc29sdXRpb25zKCk7XG4gICAgICBmaXJzdFBhdXNlZC5fcnVuUmVqZWN0aW9ucygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgX2ZpbmRBbmNlc3RyeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250aW51YXRpb25zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjdXIpIHtcbiAgICAgIGlmIChjdXIucHJvbWlzZSkge1xuICAgICAgICB2YXIgbm9kZSA9IHtcbiAgICAgICAgICBwcm9taXNlOiBjdXIucHJvbWlzZSxcbiAgICAgICAgICBjaGlsZHJlbjogY3VyLnByb21pc2UuX2ZpbmRBbmNlc3RyeSgpXG4gICAgICAgIH07XG4gICAgICAgIGFjYy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gIH0sXG4gIF9zZXRQYXJlbnQ6IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXJlbnQgYWxyZWFkeSBzZXRcIik7XG4gICAgfVxuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgX2NvbnRpbnVlV2l0aDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgZmlyc3RQZW5kaW5nID0gdGhpcy5fZmluZEZpcnN0UGVuZGluZygpO1xuICAgIGlmIChmaXJzdFBlbmRpbmcpIHtcbiAgICAgIGZpcnN0UGVuZGluZy5fZGF0YSA9IGRhdGE7XG4gICAgICBmaXJzdFBlbmRpbmcuX3NldFJlc29sdmVkKCk7XG4gICAgfVxuICB9LFxuICBfZmluZEZpcnN0UGVuZGluZzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9maW5kRmlyc3RBbmNlc3RvcihmdW5jdGlvbiAodGVzdCkge1xuICAgICAgcmV0dXJuIHRlc3QuX2lzUGVuZGluZyAmJiB0ZXN0Ll9pc1BlbmRpbmcoKTtcbiAgICB9KTtcbiAgfSxcbiAgX2ZpbmRGaXJzdFBhdXNlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9maW5kRmlyc3RBbmNlc3RvcihmdW5jdGlvbiAodGVzdCkge1xuICAgICAgcmV0dXJuIHRlc3QuX3BhdXNlZDtcbiAgICB9KTtcbiAgfSxcbiAgX2ZpbmRGaXJzdEFuY2VzdG9yOiBmdW5jdGlvbiAobWF0Y2hpbmcpIHtcbiAgICB2YXIgdGVzdCA9IHRoaXM7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB3aGlsZSAodGVzdCkge1xuICAgICAgaWYgKG1hdGNoaW5nKHRlc3QpKSB7XG4gICAgICAgIHJlc3VsdCA9IHRlc3Q7XG4gICAgICB9XG4gICAgICB0ZXN0ID0gdGVzdC5fcGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBfZmFpbFdpdGg6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHZhciBmaXJzdFJlamVjdGVkID0gdGhpcy5fZmluZEZpcnN0UGVuZGluZygpO1xuICAgIGlmIChmaXJzdFJlamVjdGVkKSB7XG4gICAgICBmaXJzdFJlamVjdGVkLl9lcnJvciA9IGVycm9yO1xuICAgICAgZmlyc3RSZWplY3RlZC5fc2V0UmVqZWN0ZWQoKTtcbiAgICB9XG4gIH0sXG4gIF90YWtlQ29udGludWF0aW9uczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250aW51YXRpb25zLnNwbGljZSgwLCB0aGlzLl9jb250aW51YXRpb25zLmxlbmd0aCk7XG4gIH0sXG4gIF9ydW5SZWplY3Rpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3BhdXNlZCB8fCAhdGhpcy5faXNSZWplY3RlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhclxuICAgICAgZXJyb3IgPSB0aGlzLl9lcnJvcixcbiAgICAgIGNvbnRpbnVhdGlvbnMgPSB0aGlzLl90YWtlQ29udGludWF0aW9ucygpLFxuICAgICAgc2VsZiA9IHRoaXM7XG4gICAgY29udGludWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb250KSB7XG4gICAgICBpZiAoY29udC5jYXRjaEZuKSB7XG4gICAgICAgIHZhciBjYXRjaFJlc3VsdCA9IGNvbnQuY2F0Y2hGbihlcnJvcik7XG4gICAgICAgIHNlbGYuX2hhbmRsZVVzZXJGdW5jdGlvblJlc3VsdChjYXRjaFJlc3VsdCwgY29udC5wcm9taXNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnQucHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBfcnVuUmVzb2x1dGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcGF1c2VkIHx8ICF0aGlzLl9pc1Jlc29sdmVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvbnRpbnVhdGlvbnMgPSB0aGlzLl90YWtlQ29udGludWF0aW9ucygpO1xuICAgIGlmIChsb29rc0xpa2VBUHJvbWlzZSh0aGlzLl9kYXRhKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZVdoZW5SZXNvbHZlZERhdGFJc1Byb21pc2UodGhpcy5fZGF0YSk7XG4gICAgfVxuICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgY29udGludWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb250KSB7XG4gICAgICBpZiAoY29udC5uZXh0Rm4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY29udC5uZXh0Rm4oZGF0YSk7XG4gICAgICAgICAgc2VsZi5faGFuZGxlVXNlckZ1bmN0aW9uUmVzdWx0KHJlc3VsdCwgY29udC5wcm9taXNlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHNlbGYuX2hhbmRsZVJlc29sdXRpb25FcnJvcihlLCBjb250KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250LnByb21pc2UpIHtcbiAgICAgICAgY29udC5wcm9taXNlLnJlc29sdmUoZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIF9oYW5kbGVSZXNvbHV0aW9uRXJyb3I6IGZ1bmN0aW9uIChlLCBjb250aW51YXRpb24pIHtcbiAgICB0aGlzLl9zZXRSZWplY3RlZCgpO1xuICAgIGlmIChjb250aW51YXRpb24uY2F0Y2hGbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udGludWF0aW9uLmNhdGNoRm4oZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIGUgPSBlMjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRpbnVhdGlvbi5wcm9taXNlKSB7XG4gICAgICBjb250aW51YXRpb24ucHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxuICB9LFxuICBfaGFuZGxlV2hlblJlc29sdmVkRGF0YUlzUHJvbWlzZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGRhdGEudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICBzZWxmLl9kYXRhID0gcmVzdWx0O1xuICAgICAgc2VsZi5fcnVuUmVzb2x1dGlvbnMoKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHNlbGYuX2Vycm9yID0gZXJyb3I7XG4gICAgICBzZWxmLl9zZXRSZWplY3RlZCgpO1xuICAgICAgc2VsZi5fcnVuUmVqZWN0aW9ucygpO1xuICAgIH0pO1xuICB9LFxuICBfaGFuZGxlVXNlckZ1bmN0aW9uUmVzdWx0OiBmdW5jdGlvbiAoZGF0YSwgbmV4dFN5bmNocm9ub3VzUHJvbWlzZSkge1xuICAgIGlmIChsb29rc0xpa2VBUHJvbWlzZShkYXRhKSkge1xuICAgICAgdGhpcy5fY2hhaW5Qcm9taXNlRGF0YShkYXRhLCBuZXh0U3luY2hyb25vdXNQcm9taXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKGRhdGEpO1xuICAgIH1cbiAgfSxcbiAgX2NoYWluUHJvbWlzZURhdGE6IGZ1bmN0aW9uIChwcm9taXNlRGF0YSwgbmV4dFN5bmNocm9ub3VzUHJvbWlzZSkge1xuICAgIHByb21pc2VEYXRhLnRoZW4oZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIG5leHRTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZShuZXdEYXRhKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAobmV3RXJyb3IpIHtcbiAgICAgIG5leHRTeW5jaHJvbm91c1Byb21pc2UucmVqZWN0KG5ld0Vycm9yKTtcbiAgICB9KTtcbiAgfSxcbiAgX3NldFJlc29sdmVkOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBSRVNPTFZFRDtcbiAgICBpZiAoIXRoaXMuX3BhdXNlZCkge1xuICAgICAgdGhpcy5fcnVuUmVzb2x1dGlvbnMoKTtcbiAgICB9XG4gIH0sXG4gIF9zZXRSZWplY3RlZDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3RhdHVzID0gUkVKRUNURUQ7XG4gICAgaWYgKCF0aGlzLl9wYXVzZWQpIHtcbiAgICAgIHRoaXMuX3J1blJlamVjdGlvbnMoKTtcbiAgICB9XG4gIH0sXG4gIF9pc1BlbmRpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IFBFTkRJTkc7XG4gIH0sXG4gIF9pc1Jlc29sdmVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSBSRVNPTFZFRDtcbiAgfSxcbiAgX2lzUmVqZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IFJFSkVDVEVEO1xuICB9XG59O1xuXG5TeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgcmV0dXJuIG5ldyBTeW5jaHJvbm91c1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmIChsb29rc0xpa2VBUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICByZXN1bHQudGhlbihmdW5jdGlvbiAobmV3UmVzdWx0KSB7XG4gICAgICAgIHJlc29sdmUobmV3UmVzdWx0KTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9XG4gIH0pO1xufTtcblxuU3luY2hyb25vdXNQcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgcmV0dXJuIG5ldyBTeW5jaHJvbm91c1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlamVjdChyZXN1bHQpO1xuICB9KTtcbn07XG5cblN5bmNocm9ub3VzUHJvbWlzZS51bnJlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFN5bmNocm9ub3VzUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgfSk7XG59O1xuXG5TeW5jaHJvbm91c1Byb21pc2UuYWxsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJncyA9IG1ha2VBcnJheUZyb20oYXJndW1lbnRzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICBhcmdzID0gYXJnc1swXTtcbiAgfVxuICBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgfVxuICByZXR1cm4gbmV3IFN5bmNocm9ub3VzUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyXG4gICAgICBhbGxEYXRhID0gW10sXG4gICAgICBudW1SZXNvbHZlZCA9IDAsXG4gICAgICBkb1Jlc29sdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChudW1SZXNvbHZlZCA9PT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICByZXNvbHZlKGFsbERhdGEpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVqZWN0ZWQgPSBmYWxzZSxcbiAgICAgIGRvUmVqZWN0ID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH07XG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcsIGlkeCkge1xuICAgICAgU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoYXJnKS50aGVuKGZ1bmN0aW9uICh0aGlzUmVzdWx0KSB7XG4gICAgICAgIGFsbERhdGFbaWR4XSA9IHRoaXNSZXN1bHQ7XG4gICAgICAgIG51bVJlc29sdmVkICs9IDE7XG4gICAgICAgIGRvUmVzb2x2ZSgpO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBkb1JlamVjdChlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuaWYgKFByb21pc2UgPT09IFN5bmNocm9ub3VzUHJvbWlzZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgdXNlIFN5bmNocm9ub3VzUHJvbWlzZS5pbnN0YWxsR2xvYmFsbHkoKSB0byBpbnN0YWxsIGdsb2JhbGx5XCIpO1xufVxudmFyIFJlYWxQcm9taXNlID0gUHJvbWlzZTtcblN5bmNocm9ub3VzUHJvbWlzZS5pbnN0YWxsR2xvYmFsbHkgPSBmdW5jdGlvbihfX2F3YWl0ZXIpIHtcbiAgaWYgKFByb21pc2UgPT09IFN5bmNocm9ub3VzUHJvbWlzZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXI7XG4gIH0gXG4gIHZhciByZXN1bHQgPSBwYXRjaEF3YWl0ZXJJZlJlcXVpcmVkKF9fYXdhaXRlcik7XG4gIFByb21pc2UgPSBTeW5jaHJvbm91c1Byb21pc2U7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5TeW5jaHJvbm91c1Byb21pc2UudW5pbnN0YWxsR2xvYmFsbHkgPSBmdW5jdGlvbigpIHtcbiAgaWYgKFByb21pc2UgPT09IFN5bmNocm9ub3VzUHJvbWlzZSkge1xuICAgIFByb21pc2UgPSBSZWFsUHJvbWlzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcGF0Y2hBd2FpdGVySWZSZXF1aXJlZChfX2F3YWl0ZXIpIHtcbiAgaWYgKHR5cGVvZihfX2F3YWl0ZXIpID09PSBcInVuZGVmaW5lZFwiIHx8IF9fYXdhaXRlci5fX3BhdGNoZWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyO1xuICB9XG4gIHZhciBvcmlnaW5hbEF3YWl0ZXIgPSBfX2F3YWl0ZXI7XG4gIF9fYXdhaXRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBQcm9taXNlID0gUmVhbFByb21pc2U7XG4gICAgb3JpZ2luYWxBd2FpdGVyLmFwcGx5KHRoaXMsIG1ha2VBcnJheUZyb20oYXJndW1lbnRzKSk7XG4gIH07XG4gIF9fYXdhaXRlci5fX3BhdGNoZWQgPSB0cnVlO1xuICByZXR1cm4gX19hd2FpdGVyO1xufVxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFN5bmNocm9ub3VzUHJvbWlzZTogU3luY2hyb25vdXNQcm9taXNlXG59OyIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gUGx1Z2luIHRvIGFkZCAncHJvcGVydHknIChhcyBpbiBwZXJzb25hbCBwcm9wZXJ0eSkgcHJvcGVydHkgdG8gUGxheWVycyB3aGVuIHRoZXkgYXJlIGluaXRpYWxpemVkLiBNZWFudCB0byBiZSB1c2VkIGZvclxyXG4vLyBzaW11bGF0aW9ucyBpbnZvbHZpbmcgcGVyc29uYWwgcG9zZXNzaW9ucywgZm9yIGluc3RhbmNlIGVjb25vbWljIHNpbXVsYXRpb25zLlxyXG5cclxuLy8gTmFzaEpTIGVuZ2luZSBjb21wb25lbnRzXHJcbnZhciBFbmdpbmUgPSByZXF1aXJlKFwiLi4vbGliL2VuZ2luZVwiKVxyXG5cclxuLy8gR2FtZSBzdGF0ZVxyXG52YXIgeyByZWdpc3RyeSwgZ2FtZVBvcHVsYXRpb24gfSA9IEVuZ2luZS5CYWNrZW5kLlN0YXRlO1xyXG5cclxuLy8gTGV0J3MgYWRkIHNvbWUgUGxheWVyTGlzdCBmdW5jdGlvbmFsaXR5XHJcbnZhciB7IFBsYXllckxpc3QgfSA9IEVuZ2luZS5CYWNrZW5kLkNsYXNzZXM7XHJcblxyXG5cclxudmFyIEJhbGFuY2VTaGVldCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHQvLyBWYXJpYWJsZXMgdG8gc3RvcmUgc2V0dGluZ3MsIGFuZCBkZWZhdWx0c1xyXG5cdHZhciBzZXR0aW5ncyA9IHtcclxuXHRcdGFkZEJhbGFuY2VTaGVldE9uQ2xhaW06IHRydWUsXHJcblx0XHRjbGVhblplcm9zOiB0cnVlLFxyXG5cdFx0bmVnYXRpdmVBc3NldHM6IGZhbHNlXHJcblx0fVxyXG5cdC8vVE9ETyBtYWtlIG5lZ2F0aXZlQXNzZXRzIChhbmQgbmVnYXRpdmVMaWFiaWxpdGllcykgd29ya1xyXG5cclxuXHJcblx0Ly8gQXNzZXRzIENsYXNzZXNcclxuXHJcblx0Ly8gQ2xhaW0gcGFyZW50IGNsYXNzXHJcblx0dmFyIENsYWltID0gZnVuY3Rpb24oY2xhaW1hbnQsIGFtb3VudCkge1xyXG5cdFx0Ly8gQWRkIGJhbGFuY2Ugc2hlZXQgaWYgbmVjZXNzYXJ5IGFuZCBwZXJtaXR0ZWRcclxuXHRcdGlmICghY2xhaW1hbnQuYmFsYW5jZVNoZWV0KSB7XHJcblx0XHRcdGlmIChzZXR0aW5ncy5hZGRCYWxhbmNlU2hlZXRPbkNsYWltKSBhZGRFbnRyaWVzKHJlZ2lzdHJ5LnBsYXllcnNbY2xhaW1hbnQuaWQoKV0pXHJcblx0XHRcdC8vIEZhaWwgaWYgbm90IHBlcm1pdHRlZCB0byBhZGQgbmVjZXNzYXJ5IGJhbGFuY2Ugc2hlZXQuXHJcblx0XHRcdGVsc2UgcmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYW1vdW50ID0gYW1vdW50O1xyXG5cdFx0dGhpcy5jbGFpbWFudCA9IGNsYWltYW50XHJcblx0XHRjbGFpbWFudC5lbmRvdyh0aGlzKVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHQvLyBFbmQgb3duZXJzaGlwIGNsYWltXHJcblx0Q2xhaW0ucHJvdG90eXBlLmVyYXNlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLmNsYWltYW50LnJldm9rZSh0aGlzKVxyXG5cdFx0dGhpcy5jbGFpbWFudCA9IG51bGw7XHJcblx0XHR0aGlzLmFtb3VudCA9IDBcclxuXHR9XHJcblxyXG5cdC8vIE1lcmdlIGNsYWltcyBpZiB0aGV5J3JlIHRoZSBzYW1lIGZhbWlseSBidXQgZGlmZmVyZW50IGFtb3VudHNcclxuXHRDbGFpbS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihvdGhlckNsYWltKSB7XHJcblx0XHRpZiAodGhpcy5jbGFpbWFudCAhPT0gb3RoZXJDbGFpbS5jbGFpbWFudCkgcmV0dXJuIGZhbHNlXHJcblx0XHQvLyBBZGQgYW1vdW50c1xyXG5cdFx0dGhpcy5hbW91bnQgPSB0aGlzLmFtb3VudCArIG90aGVyQ2xhaW0uYW1vdW50XHJcblxyXG5cdFx0Ly8gUmVtb3ZlIGZyb20gYmFsYW5jZSBzaGVldFxyXG5cdFx0b3RoZXJDbGFpbS5lcmFzZSgpO1xyXG5cdH1cclxuXHJcblx0Ly8gU3BsaXQgdGhpcyBpbnRvIHR3byBzZXBhcmF0ZSBjbGFpbXMsIHdpdGggZGlmZmVyZW50IGFtb3VudHNcclxuXHRDbGFpbS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbihuZXdBbW91bnQpIHtcclxuXHRcdHZhciBjbG9uZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpLCB0aGlzKTtcclxuXHRcdGNsb25lLmFtb3VudCA9IG5ld0Ftb3VudDtcclxuXHRcdHRoaXMuYW1vdW50ID0gdGhpcy5hbW91bnQgLSBuZXdBbW91bnQ7XHJcblx0XHR0aGlzLmNsYWltYW50LmVuZG93KGNsb25lLCBmYWxzZSlcclxuXHRcdHJldHVybiBjbG9uZTtcclxuXHR9XHJcblxyXG5cdC8vIFRyYW5zZmVyIHRvIG5ldyBvd25lclxyXG5cdENsYWltLnByb3RvdHlwZS50cmFuc2ZlciA9IGZ1bmN0aW9uKG5ld0NsYWltYW50LCBhbW91bnQgPSBcImFsbFwiKSB7XHJcblx0XHQvLyBBZGQgYmFsYW5jZSBzaGVldCBpZiBuZWNlc3NhcnkgYW5kIHBlcm1pdHRlZFxyXG5cdFx0aWYgKCFuZXdDbGFpbWFudC5iYWxhbmNlU2hlZXQpIHtcclxuXHRcdFx0aWYgKHNldHRpbmdzLmFkZEJhbGFuY2VTaGVldE9uQ2xhaW0pIGFkZEVudHJpZXMocmVnaXN0cnkucGxheWVyc1tuZXdDbGFpbWFudC5pZCgpXSlcclxuXHRcdFx0Ly8gRmFpbCBpZiBub3QgcGVybWl0dGVkIHRvIGFkZCBuZWNlc3NhcnkgYmFsYW5jZSBzaGVldC5cclxuXHRcdFx0ZWxzZSByZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVHJhbnNmZXIgYWxsIG9mIGl0XHJcblx0XHRpZiAoYW1vdW50ID09IFwiYWxsXCIgfHwgYW1vdW50ID09IHRoaXMuYW1vdW50KSB7XHJcblx0XHRcdHZhciBvbGRDbGFpbWFudCA9IHRoaXMuY2xhaW1hbnQ7XHJcblx0XHRcdHRoaXMuY2xhaW1hbnQucmV2b2tlKHRoaXMpO1xyXG5cdFx0XHR0aGlzLmNsYWltYW50ID0gbmV3Q2xhaW1hbnQ7XHJcblx0XHRcdG5ld0NsYWltYW50LmVuZG93KHRoaXMpO1xyXG5cclxuXHRcdH1cclxuXHRcdC8vIG9yIG9ubHkgYSBwb3J0aW9uXHJcblx0XHRlbHNlIHtcclxuXHRcdFx0dmFyIG5ld0NsYWltID0gdGhpcy5zcGxpdChhbW91bnQpO1xyXG5cdFx0XHRuZXdDbGFpbS50cmFuc2ZlcihuZXdDbGFpbWFudCwgXCJhbGxcIilcclxuXHRcdFx0Y2xlYW5Bc3NldCh0aGlzKVxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cclxuXHJcblx0Ly8gQ2xhaW1zIG9uIHJlYWwgdGhpbmdzIChsaWtlIGNhcnMsIGhvdXNlcywgZ29sZClcclxuXHR2YXIgUmVhbENsYWltID0gZnVuY3Rpb24oY2xhaW1hbnQsIGdvb2QsIGFtb3VudCkge1xyXG5cdFx0aWYgKCFDbGFpbS5jYWxsKHRoaXMsIGNsYWltYW50LCBhbW91bnQpKSByZXR1cm4gZmFsc2U7XHJcblx0XHR0aGlzLmdvb2QgPSBnb29kO1xyXG5cdH1cclxuXHRSZWFsQ2xhaW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFpbS5wcm90b3R5cGUpXHJcblx0UmVhbENsYWltLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlYWxDbGFpbVxyXG5cclxuXHQvLyBMb3NlIHZhbHVlIGJ5IHBlcmNlbnRhZ2VcclxuXHRSZWFsQ2xhaW0ucHJvdG90eXBlLmRlcHJlY2lhdGUgPSBmdW5jdGlvbihyYXRlID0gLjEpIHtcclxuXHRcdHRoaXMuYW1vdW50ID0gdGhpcy5hbW91bnQgKiAoMSAtIHJhdGUpXHJcblx0fVxyXG5cclxuXHQvLyBBZGQgZ29vZCBlbmZvcmNlbWVudCB0byBtZXJnZVxyXG5cdFJlYWxDbGFpbS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihvdGhlckNsYWltKSB7XHJcblx0XHRpZiAodGhpcy5nb29kID09PSBvdGhlckNsYWltLmdvb2QpIHJldHVybiBDbGFpbS5wcm90b3R5cGUubWVyZ2UuY2FsbCh0aGlzLCBvdGhlckNsYWltKTtcclxuXHR9XHJcblxyXG5cdC8vIFJlcGxhY2UgcGxheWVyIG9iamVjdCB3aXRoIGlkIHdoZW4gc3RyaW5naWZ5aW5nXHJcblx0UmVhbENsYWltLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGNsYWltYW50OiB0aGlzLmNsYWltYW50LmlkKCksXHJcblx0XHRcdGdvb2Q6IHRoaXMuZ29vZCxcclxuXHRcdFx0YW1vdW50OiB0aGlzLmFtb3VudFxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQ2xhaW1zIG9uIG90aGVyIGVudGl0aWVzIHdpdGggYmFsYW5jZSBzaGVldHNcclxuXHR2YXIgRmluYW5jaWFsQ2xhaW0gPSBmdW5jdGlvbihjbGFpbWFudCwgY2xhaW1lZCwgYW1vdW50LCBpbnN0cnVtZW50ID0gXCJEZWJ0XCIpIHtcclxuXHRcdC8vIEFkZCBiYWxhbmNlIHNoZWV0IGlmIG5lY2Vzc2FyeSBhbmQgcGVybWl0dGVkXHJcblx0XHRpZiAoIWNsYWltZWQuYmFsYW5jZVNoZWV0KSB7XHJcblx0XHRcdGlmIChzZXR0aW5ncy5hZGRCYWxhbmNlU2hlZXRPbkNsYWltKSBhZGRFbnRyaWVzKHJlZ2lzdHJ5LnBsYXllcnNbY2xhaW1lZC5pZCgpXSlcclxuXHRcdFx0Ly8gRmFpbCBpZiBub3QgcGVybWl0dGVkIHRvIGFkZCBuZWNlc3NhcnkgYmFsYW5jZSBzaGVldC5cclxuXHRcdFx0ZWxzZSByZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHR0aGlzLmNsYWltZWQgPSBjbGFpbWVkO1xyXG5cdFx0dGhpcy5pbnN0cnVtZW50ID0gaW5zdHJ1bWVudDtcclxuXHJcblx0XHRpZiAoIUNsYWltLmNhbGwodGhpcywgY2xhaW1hbnQsIGFtb3VudCkpIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRjbGFpbWVkLmluZGVidCh0aGlzKVxyXG5cdH1cclxuXHRGaW5hbmNpYWxDbGFpbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYWltLnByb3RvdHlwZSlcclxuXHRGaW5hbmNpYWxDbGFpbS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGaW5hbmNpYWxDbGFpbVxyXG5cclxuXHQvLyBBZGQgdG8gZXJhc2UgZnVuY3Rpb24sIHRvIGVyYXNlIGZyb20gY2xhaW1lZCdzIGJhbGFuY2Ugc2hlZXQgdG9vXHJcblx0RmluYW5jaWFsQ2xhaW0ucHJvdG90eXBlLmVyYXNlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgYnMgPSByZWdpc3RyeS5wbGF5ZXJzW3RoaXMuY2xhaW1lZC5pZCgpXS5iYWxhbmNlU2hlZXQubGlhYmlsaXRpZXNcclxuXHRcdGJzLnNwbGljZShicy5pbmRleE9mKHRoaXMpLCAxKVxyXG5cdFx0dGhpcy5jbGFpbWVkID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gQ2xhaW0ucHJvdG90eXBlLmVyYXNlLmNhbGwodGhpcylcclxuXHR9XHJcblxyXG5cdC8vIEFkZCBjbGFpbWVkIGVuZm9yY2VtZW50IHRvIG1lcmdlXHJcblx0RmluYW5jaWFsQ2xhaW0ucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24ob3RoZXJDbGFpbSkge1xyXG5cdFx0aWYgKHRoaXMuY2xhaW1lZCA9PT0gb3RoZXJDbGFpbS5jbGFpbWVkKSByZXR1cm4gQ2xhaW0ucHJvdG90eXBlLm1lcmdlLmNhbGwodGhpcywgb3RoZXJDbGFpbSk7XHJcblx0fVxyXG5cclxuXHJcblx0Ly8gQWRkIHRvIHNwbGl0IGZ1bmN0aW9uLCB0byBzcGxpdCBvbiBjbGFpbWVkJ3MgYmFsYW5jZSBzaGVldCB0b29cclxuXHRGaW5hbmNpYWxDbGFpbS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbihuZXdBbW91bnQpIHtcclxuXHRcdHZhciBjbG9uZSA9IENsYWltLnByb3RvdHlwZS5zcGxpdC5jYWxsKHRoaXMsIG5ld0Ftb3VudCk7XHJcblx0XHRjbG9uZS5jbGFpbWVkLmluZGVidChjbG9uZSwgZmFsc2UpO1xyXG5cdFx0cmV0dXJuIGNsb25lO1xyXG5cdH1cclxuXHJcblx0Ly8gUmVwbGFjZSBwbGF5ZXIgb2JqZWN0IHdpdGggaWQgd2hlbiBzdHJpbmdpZnlpbmdcclxuXHRGaW5hbmNpYWxDbGFpbS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRjbGFpbWFudDogdGhpcy5jbGFpbWFudC5pZCgpLFxyXG5cdFx0XHRjbGFpbWVkOiB0aGlzLmNsYWltZWQuaWQoKSxcclxuXHRcdFx0aW5zdHJ1bWVudDogdGhpcy5pbnN0cnVtZW50LFxyXG5cdFx0XHRhbW91bnQ6IHRoaXMuYW1vdW50XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHJcblx0Ly8gQ2xlYW4gdGhlIHNpbWlsYXIgY2xhaW1zIG9uIHRoZSBjbGFpbWFudCBzdXBwbGllZFxyXG5cdHZhciBjbGVhbkFzc2V0ID0gZnVuY3Rpb24oY2xhaW0pIHtcclxuXHRcdHZhciBicyA9IHJlZ2lzdHJ5LnBsYXllcnNbY2xhaW0uY2xhaW1hbnQuaWQoKV0uYmFsYW5jZVNoZWV0LmFzc2V0cztcclxuXHJcblx0XHR2YXIgZGlydHkgPSBicy5maWx0ZXIoZnVuY3Rpb24oZW50cnkpIHtcclxuXHRcdFx0cmV0dXJuIChlbnRyeSAhPT0gY2xhaW0gJiYgZW50cnkuZ29vZCA9PT0gY2xhaW0uZ29vZCAmJiBlbnRyeS5pbnN0cnVtZW50ID09PSBjbGFpbS5pbnN0cnVtZW50KTtcclxuXHRcdH0pXHJcblxyXG5cdFx0ZGlydHkuZm9yRWFjaChmdW5jdGlvbihkaXJ0KSB7XHJcblx0XHRcdGNsYWltLm1lcmdlKGRpcnQpXHJcblx0XHR9KVxyXG5cclxuXHRcdGlmIChzZXR0aW5ncy5jbGVhblplcm9zICYmIGNsYWltLmFtb3VudCA9PSAwKSBjbGFpbS5lcmFzZSgpXHJcblx0fVxyXG5cclxuXHR2YXIgY2xlYW5MaWFiaWxpdHkgPSBmdW5jdGlvbihjbGFpbSkge1xyXG5cdFx0dmFyIGJzID0gcmVnaXN0cnkucGxheWVyc1tjbGFpbS5jbGFpbWVkLmlkKCldLmJhbGFuY2VTaGVldC5saWFiaWxpdGllcztcclxuXHJcblx0XHR2YXIgZGlydHkgPSBicy5maWx0ZXIoZnVuY3Rpb24oZW50cnkpIHtcclxuXHRcdFx0cmV0dXJuIChlbnRyeSAhPT0gY2xhaW0gJiYgZW50cnkuY2xhaW1hbnQgPT09IGNsYWltLmNsYWltYW50ICYmIGVudHJ5Lmluc3RydW1lbnQgPT09IGNsYWltLmluc3RydW1lbnQpO1xyXG5cdFx0fSlcclxuXHJcblx0XHRkaXJ0eS5mb3JFYWNoKGZ1bmN0aW9uKGRpcnQpIHtcclxuXHRcdFx0Y2xhaW0ubWVyZ2UoZGlydClcclxuXHRcdH0pXHJcblxyXG5cdFx0aWYgKHNldHRpbmdzLmNsZWFuWmVyb3MgJiYgY2xhaW0uYW1vdW50ID09IDApIGNsYWltLmVyYXNlXHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8vIEFkZCBiYWxhbmNlIHNoZWV0IG9iamVjdCBhbmQgbWV0aG9kcyB0byBwbGF5ZXIuXHJcblx0dmFyIGFkZEVudHJpZXMgPSBmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHJcblx0XHQvL19wbGF5ZXIgcHJvcGVydGllcy9tZXRob2RzXHJcblx0XHRwbGF5ZXIuYmFsYW5jZVNoZWV0ID0geyBhc3NldHM6IFtdLCBsaWFiaWxpdGllczogW10gfVxyXG5cclxuXHRcdC8qXHJcblx0XHR2YXIgbG9va3VwID0gZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0XHR0aGlzLnJlZHVjZShmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUpIHtcclxuXHRcdFx0XHRpZiAodHlwZSA9PT0gdmFsdWUuZ29vZCkgYWNjdW11bGF0b3IgKz0gdmFsdWUuYW1vdW50XHJcblx0XHRcdFx0ZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIE9iamVjdCAmJiB0eXBlLmluc3RydW1lbnQgPT0gdmFsdWUuaW5zdHJ1bWVudCAmJiAodHlwZS5jbGFpbWVkID09PSB2YWx1ZS5jbGFpbWVkKSlcclxuXHRcdFx0XHRcdGFjY3VtdWxhdG9yICs9IHZhbHVlLmFtb3VudFxyXG5cdFx0XHRcdHJldHVybiBhY2N1bXVsYXRvcjtcclxuXHRcdFx0fSwgMClcclxuXHRcdH1cclxuXHRcdHBsYXllci5iYWxhbmNlU2hlZXQuYXNzZXRzLmxvb2t1cCA9IGxvb2t1cDtcclxuXHRcdHBsYXllci5iYWxhbmNlU2hlZXQubGlhYmlsaXRpZXMubG9va3VwID0gbG9va3VwO1xyXG5cdFx0Ki9cclxuXHJcblx0XHRwbGF5ZXIubmV0V29ydGggPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdHZhciBhc3NldHMgPSB0aGlzLmJhbGFuY2VTaGVldC5hc3NldHMucmVkdWNlKGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpIHtcclxuXHRcdFx0XHRyZXR1cm4gYWNjdW11bGF0b3IgKyBjdXJyZW50VmFsdWUuYW1vdW50XHJcblx0XHRcdH0sIDApO1xyXG5cclxuXHRcdFx0dmFyIGxpYWJpbGl0aWVzID0gdGhpcy5iYWxhbmNlU2hlZXQubGlhYmlsaXRpZXMucmVkdWNlKGZ1bmN0aW9uKGFjY3VtdWxhdG9yLFxyXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSkge1xyXG5cdFx0XHRcdHJldHVybiBhY2N1bXVsYXRvciArIGN1cnJlbnRWYWx1ZS5hbW91bnRcclxuXHRcdFx0fSwgMCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gYXNzZXRzIC0gbGlhYmlsaXRpZXM7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVXNlciBpbnRlcmZhY2VcclxuXHRcdHBsYXllci5pbnRlcmZhY2UuYmFsYW5jZVNoZWV0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyLmlkXS5iYWxhbmNlU2hlZXQpKTtcclxuXHRcdH1cclxuXHJcblx0XHRwbGF5ZXIuaW50ZXJmYWNlLm5ldFdvcnRoID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiByZWdpc3RyeS5wbGF5ZXJzW3BsYXllci5pZF0ubmV0V29ydGgoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBUT0RPIHZhbGlkYXRlIG9iamVjdC5cclxuXHRcdHBsYXllci5pbnRlcmZhY2UuZW5kb3cgPSBmdW5jdGlvbihhc3NldCwgY2xlYW4gPSB0cnVlKSB7XHJcblx0XHRcdGlmIChhc3NldCBpbnN0YW5jZW9mIENsYWltKSB7XHJcblx0XHRcdFx0cmVnaXN0cnkucGxheWVyc1twbGF5ZXIuaWRdLmJhbGFuY2VTaGVldC5hc3NldHMucHVzaChhc3NldCk7XHJcblx0XHRcdFx0aWYgKGNsZWFuKSBjbGVhbkFzc2V0KGFzc2V0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHBsYXllci5pbnRlcmZhY2UuaW5kZWJ0ID0gZnVuY3Rpb24obGlhYmlsaXR5LCBjbGVhbiA9IHRydWUpIHtcclxuXHRcdFx0aWYgKGxpYWJpbGl0eSBpbnN0YW5jZW9mIEZpbmFuY2lhbENsYWltKSB7XHJcblx0XHRcdFx0cmVnaXN0cnkucGxheWVyc1twbGF5ZXIuaWRdLmJhbGFuY2VTaGVldC5saWFiaWxpdGllcy5wdXNoKFxyXG5cdFx0XHRcdFx0bGlhYmlsaXR5KTtcclxuXHRcdFx0XHRpZiAoY2xlYW4pIGNsZWFuTGlhYmlsaXR5KGxpYWJpbGl0eSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRwbGF5ZXIuaW50ZXJmYWNlLnJldm9rZSA9IGZ1bmN0aW9uKGFzc2V0KSB7XHJcblx0XHRcdGlmIChhc3NldCBpbnN0YW5jZW9mIENsYWltKSB7XHJcblx0XHRcdFx0dmFyIGJzID0gcmVnaXN0cnkucGxheWVyc1twbGF5ZXIuaWRdLmJhbGFuY2VTaGVldC5hc3NldHNcclxuXHRcdFx0XHRicy5zcGxpY2UoYnMuaW5kZXhPZihhc3NldCksIDEpXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBUT0RPIGNvbnZlcnQgdGhpcyBvdmVyXHJcblx0XHRwbGF5ZXIuaW50ZXJmYWNlLmxlbmQgPSBmdW5jdGlvbihib3Jyb3dlciwgYW1vdW50LCBpbnN0cnVtZW50ID0gXCJEZWJ0XCIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBGaW5hbmNpYWxDbGFpbShwbGF5ZXIuaW50ZXJmYWNlLCBib3Jyb3dlciwgYW1vdW50LCBpbnN0cnVtZW50KVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBUaGUgcGx1Z2luIG9iamVjdC5cclxuXHR2YXIgUGx1Z2luID0ge1xyXG5cdFx0bmFtZTogXCJiYWxhbmNlLXNoZWV0LWNvbXBsZXhcIixcclxuXHJcblx0XHRzZXR0aW5nczogZnVuY3Rpb24ocGFyYW1ldGVycyA9IHt9KSB7XHJcblx0XHRcdE9iamVjdC5hc3NpZ24oc2V0dGluZ3MsIHBhcmFtZXRlcnMpXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIE9wdGlvbiB0byBpbml0aWFsaXplIGJ5IGNyZWF0aW5nICdwcm9wZXJ0eScgZm9yIGEgZ3JvdXAgb2YgcGxheWVycy5cclxuXHRcdGluaXQocGxheWVycyA9IFtdKSB7XHJcblx0XHRcdC8vIEFkZCBzb21lIHBsYXllcmxpc3QgZnVuY3Rpb25hbGl0eVxyXG5cdFx0XHRQbGF5ZXJMaXN0LnByb3RvdHlwZS5iYWxhbmNlU2hlZXRzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdFx0aWYgKHBsYXllci5iYWxhbmNlU2hlZXQpIHJldHVybiBwbGF5ZXIuaW50ZXJmYWNlLmJhbGFuY2VTaGVldCgpO1xyXG5cdFx0XHRcdFx0ZWxzZSByZXR1cm4gbnVsbDtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0UGxheWVyTGlzdC5wcm90b3R5cGUuYXNzZXRzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdFx0aWYgKHBsYXllci5iYWxhbmNlU2hlZXQpIHJldHVybiBwbGF5ZXIuaW50ZXJmYWNlLmJhbGFuY2VTaGVldCgpLmFzc2V0cztcclxuXHRcdFx0XHRcdGVsc2UgcmV0dXJuIG51bGw7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdFBsYXllckxpc3QucHJvdG90eXBlLmxpYWJpbGl0aWVzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdFx0aWYgKHBsYXllci5iYWxhbmNlU2hlZXQpIHJldHVybiBwbGF5ZXIuaW50ZXJmYWNlLmJhbGFuY2VTaGVldCgpLmxpYWJpbGl0aWVzO1xyXG5cdFx0XHRcdFx0ZWxzZSByZXR1cm4gbnVsbDtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0UGxheWVyTGlzdC5wcm90b3R5cGUubmV0V29ydGggPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0XHRpZiAocGxheWVyLmJhbGFuY2VTaGVldCkgcmV0dXJuIHBsYXllci5uZXRXb3J0aCgpO1xyXG5cdFx0XHRcdFx0ZWxzZSByZXR1cm4gbnVsbDtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0UGxheWVyTGlzdC5wcm90b3R5cGUuemVyb0JhbGFuY2VTaGVldHMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR0aGlzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0XHRhZGRFbnRyaWVzKHBsYXllcilcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQWRkIGJzIGZvciBzcGVjaWZpZWQgcGxheWVyc1xyXG5cdFx0XHRwbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0YWRkRW50cmllcyhyZWdpc3RyeS5wbGF5ZXJzW3BsYXllci5pZCgpXSk7XHJcblx0XHRcdH0pXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIElmIHdlJ3ZlIGluaXQtZWQgYWxyZWR5LCBqdXN0IGFkZCBicydzIHRvIHRoZSBjdXJyZW50IHBsYXllciBsaXN0IGlmIHRoZXkgZG9uJ3QgaGF2ZSBhbHJlYWR5XHJcblx0XHRyZXF1aXJlKHBsYXllcnMgPSBbXSkge1xyXG5cdFx0XHRwbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0aWYgKCFwbGF5ZXIuYmFsYW5jZVNoZWV0KSBhZGRFbnRyaWVzKHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyLmlkKCldKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdHN0b3AoKSB7XHJcblx0XHRcdC8vIHJlbW92ZSBwcm90b3R5cGUgYWRkRW50cmllc1xyXG5cdFx0XHRkZWxldGUgUGxheWVyTGlzdC5wcm90b3R5cGUuYmFsYW5jZVNoZWV0cztcclxuXHRcdFx0ZGVsZXRlIFBsYXllckxpc3QucHJvdG90eXBlLmFzc2V0cztcclxuXHRcdFx0ZGVsZXRlIFBsYXllckxpc3QucHJvdG90eXBlLmxpYWJpbGl0aWVzO1xyXG5cdFx0XHRkZWxldGUgUGxheWVyTGlzdC5wcm90b3R5cGUubmV0V29ydGg7XHJcblxyXG5cdFx0XHQvLyBkZWxldGUgYmFsYW5jZSBzaGVldCBwcm9wZXJ0aWVzIGZyb20gZXZlcnkgcGxheWVyIGFuZCBpbnRlcmZhY2UuXHJcblx0XHRcdGdhbWVQb3B1bGF0aW9uKCkuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLmJhbGFuY2VTaGVldDtcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLm5ldFdvcnRoO1xyXG5cdFx0XHRcdGRlbGV0ZSBwbGF5ZXIuaW50ZXJmYWNlLmJhbGFuY2VTaGVldDtcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLmludGVyZmFjZS5uZXRXb3J0aDtcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLmludGVyZmFjZS5lbmRvd0Fzc2V0cztcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLmludGVyZmFjZS5sZW5kO1xyXG5cdFx0XHR9KVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBQdWJsaWMgY2xhc3NlcyBmb3IgYXNzZXQvbGlhYmlsaXR5XHJcblx0XHRwdWJsaWNJZkFjdGl2ZToge1xyXG5cdFx0XHRSZWFsQ2xhaW0sXHJcblx0XHRcdEZpbmFuY2lhbENsYWltXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGNyZWF0ZSBwcm9wZXJ0eSBhbmQgaW50ZXJmYWNlIGZ1bmN0aW9uIHdoZW4gcGxheWVyIGlzIGNyZWF0ZWRcclxuXHRcdCdwbGF5ZXItY3JlYXRlJzogYWRkRW50cmllcyxcclxuXHJcblx0XHQvLyBCbGFuayBwcm9wZXJ0eSB3aGVuIHBsYXllciBpcyByZS1pbml0aWFsaXplZFxyXG5cdFx0XCJwbGF5ZXItcmVpbml0aWFsaXplXCIgKHBsYXllcikge1xyXG5cdFx0XHRwbGF5ZXIuYmFsYW5jZVNoZWV0ID0geyBhc3NldHM6IFtdLCBsaWFiaWxpdGllczogW10gfVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIFBsdWdpbjtcclxufVxyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhbGFuY2VTaGVldDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBQbHVnaW4gdG8gYWRkICdwcm9wZXJ0eScgKGFzIGluIHBlcnNvbmFsIHByb3BlcnR5KSBwcm9wZXJ0eSB0byBQbGF5ZXJzIHdoZW4gdGhleSBhcmUgaW5pdGlhbGl6ZWQuIE1lYW50IHRvIGJlIHVzZWQgZm9yXHJcbi8vIHNpbXVsYXRpb25zIGludm9sdmluZyBwZXJzb25hbCBwb3Nlc3Npb25zLCBmb3IgaW5zdGFuY2UgZWNvbm9taWMgc2ltdWxhdGlvbnMuXHJcblxyXG4vLyBOYXNoSlMgZW5naW5lIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG4vLyBHYW1lIHN0YXRlXHJcbnZhciB7IHJlZ2lzdHJ5LCBnYW1lUG9wdWxhdGlvbiB9ID0gRW5naW5lLkJhY2tlbmQuU3RhdGU7XHJcblxyXG4vLyBMZXQncyBhZGQgc29tZSBQbGF5ZXJMaXN0IGZ1bmN0aW9uYWxpdHlcclxudmFyIHsgUGxheWVyTGlzdCB9ID0gRW5naW5lLkJhY2tlbmQuQ2xhc3NlcztcclxuXHJcblxyXG52YXIgQmFsYW5jZVNoZWV0ID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHZhciBhZGRFbnRyaWVzID0gZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHQvL19wbGF5ZXIgcHJvcGVydGllcy9tZXRob2RzXHJcblx0XHRwbGF5ZXIuYmFsYW5jZVNoZWV0ID0geyBhc3NldHM6IHt9LCBsaWFiaWxpdGllczoge30gfVxyXG5cclxuXHRcdHBsYXllci5uZXRXb3J0aCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0dmFyIGFzc2V0cyA9IE9iamVjdC5lbnRyaWVzKHRoaXMuYmFsYW5jZVNoZWV0LmFzc2V0cykucmVkdWNlKGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpIHtcclxuXHRcdFx0XHRyZXR1cm4gYWNjdW11bGF0b3IgKyBjdXJyZW50VmFsdWVbMV1cclxuXHRcdFx0fSwgMCk7XHJcblxyXG5cdFx0XHR2YXIgbGlhYmlsaXRpZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLmJhbGFuY2VTaGVldC5saWFiaWxpdGllcykucmVkdWNlKGZ1bmN0aW9uKGFjY3VtdWxhdG9yLFxyXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSkge1xyXG5cdFx0XHRcdHJldHVybiBhY2N1bXVsYXRvciArIGN1cnJlbnRWYWx1ZVsxXVxyXG5cdFx0XHR9LCAwKTtcclxuXHJcblx0XHRcdHJldHVybiBhc3NldHMgLSBsaWFiaWxpdGllcztcclxuXHRcdH1cclxuXHJcblx0XHQvLyBVc2VyIGludGVyZmFjZVxyXG5cdFx0cGxheWVyLmludGVyZmFjZS5iYWxhbmNlU2hlZXQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVnaXN0cnkucGxheWVyc1twbGF5ZXIuaWRdLmJhbGFuY2VTaGVldCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHBsYXllci5pbnRlcmZhY2UubmV0V29ydGggPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyLmlkXS5uZXRXb3J0aCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRPRE8gdmFsaWRhdGUgb2JqZWN0LiBTaG91bGQgYmUgb2YgZm9ybSB7YXBwbGVzOjIsIGRvZ3M6MX1cclxuXHRcdHBsYXllci5pbnRlcmZhY2UuZW5kb3dBc3NldHMgPSBmdW5jdGlvbihhc3NldE9iamVjdCkge1xyXG5cclxuXHRcdFx0T2JqZWN0LmFzc2lnbihyZWdpc3RyeS5wbGF5ZXJzW3BsYXllci5pZF0uYmFsYW5jZVNoZWV0LmFzc2V0cywgYXNzZXRPYmplY3QpXHJcblx0XHR9XHJcblxyXG5cdFx0cGxheWVyLmludGVyZmFjZS5sZW5kID0gZnVuY3Rpb24obG9hbk9iamVjdCkge1xyXG5cdFx0XHQvL1RPRE8gdmFsaWRhdGUgb2JqZWN0LiBTaG91bGQgYmUgb2YgZm9ybSB7cGxheWVyMTp7bW9ydGdhZ2U6MTB9fVxyXG5cdFx0XHR2YXIgbGVuZGVyID0gcmVnaXN0cnkucGxheWVyc1twbGF5ZXIuaWRdLmJhbGFuY2VTaGVldC5hc3NldHNcclxuXHRcdFx0T2JqZWN0LmVudHJpZXMobG9hbk9iamVjdCkuZm9yRWFjaChmdW5jdGlvbihsb2FuVG8pIHtcclxuXHRcdFx0XHR2YXIgZGVidHM7XHJcblx0XHRcdFx0bGVuZGVyW2xvYW5Ub1swXV0gP1xyXG5cdFx0XHRcdFx0ZGVidHMgPSBsZW5kZXJbbG9hblRvWzBdXSA6IGRlYnRzID0gbGVuZGVyW2xvYW5Ub1swXV0gPSB7fTtcclxuXHJcblx0XHRcdFx0T2JqZWN0LmVudHJpZXMobG9hblRvWzFdKS5mb3JFYWNoKGZ1bmN0aW9uKG5ld0xvYW4pIHtcclxuXHRcdFx0XHRcdGRlYnRzW25ld0xvYW5bMF1dID8gZGVidHNbbmV3TG9hblswXV0gKz0gbmV3TG9hblsxXSA6IGRlYnRzW25ld0xvYW5bMF1dID0gbmV3TG9hblsxXVxyXG5cdFx0XHRcdFx0cmVnaXN0cnkucGxheWVyc1tsb2FuVG9bMF1dLmJhbGFuY2VTaGVldC5saWFiaWxpdGllc1tuZXdMb2FuWzBdXSA/IHJlZ2lzdHJ5LnBsYXllcnNbbG9hblRvWzBdXS5iYWxhbmNlU2hlZXRcclxuXHRcdFx0XHRcdFx0LmxpYWJpbGl0aWVzW25ld0xvYW5bMF1dICs9IG5ld0xvYW5bMV0gOiByZWdpc3RyeS5wbGF5ZXJzW2xvYW5Ub1swXV0uYmFsYW5jZVNoZWV0LmxpYWJpbGl0aWVzW1xyXG5cdFx0XHRcdFx0XHRcdG5ld0xvYW5bMF1dID0gbmV3TG9hblsxXTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8vIFRoZSBwbHVnaW4gb2JqZWN0LlxyXG5cdHZhciBQbHVnaW4gPSB7XHJcblx0XHRuYW1lOiBcImJhbGFuY2Utc2hlZXRcIixcclxuXHJcblx0XHQvLyBPcHRpb24gdG8gaW5pdGlhbGl6ZSBieSBjcmVhdGluZyAncHJvcGVydHknIGZvciBhIGdyb3VwIG9mIHBsYXllcnMuXHJcblx0XHRpbml0KHBsYXllcnMgPSBbXSkge1xyXG5cdFx0XHQvLyBBZGQgc29tZSBwbGF5ZXJsaXN0IGZ1bmN0aW9uYWxpdHlcclxuXHRcdFx0UGxheWVyTGlzdC5wcm90b3R5cGUuYmFsYW5jZVNoZWV0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0XHRcdGlmIChwbGF5ZXIuYmFsYW5jZVNoZWV0KSByZXR1cm4gcGxheWVyLmludGVyZmFjZS5iYWxhbmNlU2hlZXQoKTtcclxuXHRcdFx0XHRcdGVsc2UgcmV0dXJuIG51bGw7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdFBsYXllckxpc3QucHJvdG90eXBlLmFzc2V0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0XHRcdGlmIChwbGF5ZXIuYmFsYW5jZVNoZWV0KSByZXR1cm4gcGxheWVyLmludGVyZmFjZS5iYWxhbmNlU2hlZXQoKS5hc3NldHM7XHJcblx0XHRcdFx0XHRlbHNlIHJldHVybiBudWxsO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRQbGF5ZXJMaXN0LnByb3RvdHlwZS5saWFiaWxpdGllcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0XHRcdGlmIChwbGF5ZXIuYmFsYW5jZVNoZWV0KSByZXR1cm4gcGxheWVyLmludGVyZmFjZS5iYWxhbmNlU2hlZXQoKS5saWFiaWxpdGllcztcclxuXHRcdFx0XHRcdGVsc2UgcmV0dXJuIG51bGw7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdFBsYXllckxpc3QucHJvdG90eXBlLm5ldFdvcnRoID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdFx0aWYgKHBsYXllci5iYWxhbmNlU2hlZXQpIHJldHVybiBwbGF5ZXIubmV0V29ydGgoKTtcclxuXHRcdFx0XHRcdGVsc2UgcmV0dXJuIG51bGw7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdFBsYXllckxpc3QucHJvdG90eXBlLnplcm9CYWxhbmNlU2hlZXRzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdFx0YWRkRW50cmllcyhwbGF5ZXIpXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEFkZCBicyBmb3Igc3BlY2lmaWVkIHBsYXllcnNcclxuXHRcdFx0cGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdGFkZEVudHJpZXMocmVnaXN0cnkucGxheWVyc1twbGF5ZXIuaWQoKV0pO1xyXG5cdFx0XHR9KVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBJZiB3ZSd2ZSBpbml0LWVkIGFscmVkeSwganVzdCBhZGQgYnMncyB0byB0aGUgY3VycmVudCBwbGF5ZXIgbGlzdCBpZiB0aGV5IGRvbid0IGhhdmUgYWxyZWFkeVxyXG5cdFx0cmVxdWlyZShwbGF5ZXJzID0gW10pIHtcclxuXHRcdFx0cGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdGlmICghcGxheWVyLmJhbGFuY2VTaGVldCkgYWRkRW50cmllcyhyZWdpc3RyeS5wbGF5ZXJzW3BsYXllci5pZCgpXSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHRzdG9wKCkge1xyXG5cdFx0XHQvLyByZW1vdmUgcHJvdG90eXBlIGFkZEVudHJpZXNcclxuXHRcdFx0ZGVsZXRlIFBsYXllckxpc3QucHJvdG90eXBlLmJhbGFuY2VTaGVldHM7XHJcblx0XHRcdGRlbGV0ZSBQbGF5ZXJMaXN0LnByb3RvdHlwZS5hc3NldHM7XHJcblx0XHRcdGRlbGV0ZSBQbGF5ZXJMaXN0LnByb3RvdHlwZS5saWFiaWxpdGllcztcclxuXHRcdFx0ZGVsZXRlIFBsYXllckxpc3QucHJvdG90eXBlLm5ldFdvcnRoO1xyXG5cclxuXHRcdFx0Ly8gZGVsZXRlIGJhbGFuY2Ugc2hlZXQgcHJvcGVydGllcyBmcm9tIGV2ZXJ5IHBsYXllciBhbmQgaW50ZXJmYWNlLlxyXG5cdFx0XHRnYW1lUG9wdWxhdGlvbigpLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0ZGVsZXRlIHBsYXllci5iYWxhbmNlU2hlZXQ7XHJcblx0XHRcdFx0ZGVsZXRlIHBsYXllci5uZXRXb3J0aDtcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLmludGVyZmFjZS5iYWxhbmNlU2hlZXQ7XHJcblx0XHRcdFx0ZGVsZXRlIHBsYXllci5pbnRlcmZhY2UubmV0V29ydGg7XHJcblx0XHRcdFx0ZGVsZXRlIHBsYXllci5pbnRlcmZhY2UuZW5kb3dBc3NldHM7XHJcblx0XHRcdFx0ZGVsZXRlIHBsYXllci5pbnRlcmZhY2UubGVuZDtcclxuXHRcdFx0fSlcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gY3JlYXRlIHByb3BlcnR5IGFuZCBpbnRlcmZhY2UgZnVuY3Rpb24gd2hlbiBwbGF5ZXIgaXMgY3JlYXRlZFxyXG5cdFx0J3BsYXllci1jcmVhdGUnOiBhZGRFbnRyaWVzLFxyXG5cclxuXHRcdC8vIEJsYW5rIHByb3BlcnR5IHdoZW4gcGxheWVyIGlzIHJlLWluaXRpYWxpemVkXHJcblx0XHRcInBsYXllci1yZWluaXRpYWxpemVcIiAocGxheWVyKSB7XHJcblx0XHRcdHBsYXllci5iYWxhbmNlU2hlZXQgPSB7IGFzc2V0czogW10sIGxpYWJpbGl0aWVzOiBbXSB9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gUGx1Z2luO1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWxhbmNlU2hlZXQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gZ2FtZSBwaWVjZXNcclxudmFyIHByaXNvbmVyRGlsZW1tYSA9IHJlcXVpcmUoXCIuL2l0ZXJhdGVkLXByaXNvbmVyLWRpbGVtbWFcIikuY3JlYXRlR2VuZXJhdG9yO1xyXG52YXIgcm91bmRSb2JpbiA9IHJlcXVpcmUoXCIuL3JvdW5kLXJvYmluXCIpO1xyXG5cclxuLy8gTmFzaEpTIGVuZ2luZSBjb21wb25lbnRzXHJcbnZhciBFbmdpbmUgPSByZXF1aXJlKFwiLi4vbGliL2VuZ2luZVwiKVxyXG5cclxudmFyIHsgTG9vcCB9ID0gRW5naW5lLkZyb250ZW5kLlBsYXlhYmxlcztcclxuXHJcbi8vIGhlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgZ2FtZVdyYXBwZXIgfSA9IEVuZ2luZS5CYWNrZW5kLkhlbHBlckZ1bmN0aW9ucyhcInN0b2NrLWdhbWVzXCIpXHJcbnZhciB7IGdlbmVyYXRlUG9wdWxhdGlvbiB9ID0gRW5naW5lLkJhY2tlbmQuSGVscGVyRnVuY3Rpb25zKFwidG91cm5hbWVudFwiKTtcclxuXHJcbi8vIFBvcHVsYXRpb24gaW50ZXJmYWNlc1xyXG52YXIgeyBQb3B1bGF0aW9uIH0gPSBFbmdpbmUuRnJvbnRlbmQuUG9wdWxhdGlvbjtcclxuXHJcblxyXG52YXIgQXhlbHJvZFRvdXJuYW1lbnQgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHR2YXIgeyBnZW5lcmF0ZVBsYXllcnMgPSB0cnVlLCByZXBlYXRzID0gNSwgZ2FtZUxlbmd0aCA9IDIwMCB9ID0gcGFyYW1ldGVycztcclxuXHJcblx0Ly8gRWl0aGVyIGNyZWF0ZSBhbiBlbnRpcmUgcG9wdWxhdGlvblxyXG5cdGlmIChnZW5lcmF0ZVBsYXllcnMpIHtcclxuXHRcdC8vIEdldCB0d28gc2V0cyBvZiBwbGF5ZXJzLiBUaGUgc2Vjb25kIGlzIHNvIHBsYXllcnMgY2FuIHBsYXkgdGhlbXNlbHZlc1xyXG5cdFx0cGxheWVycyA9IGdlbmVyYXRlUG9wdWxhdGlvbigpO1xyXG5cdFx0dmFyIGNvcGllcyA9IGdlbmVyYXRlUG9wdWxhdGlvbigpO1xyXG5cdFx0cGFyYW1ldGVycy5jb3BpZXMgPSBjb3BpZXM7XHJcblx0fVxyXG5cclxuXHQvLyBvciB1c2UgdGhlIHN1cHBsaWVkIHBsYXllcnNcclxuXHRlbHNlIGlmIChwbGF5ZXJzKSB7XHJcblx0XHQvLyBkbyBub3RoaW5nXHJcblx0fSBlbHNlIHtcclxuXHRcdC8vIG9yIHVzZSB0aGUgcGxheWVycyBhbHJlYWR5IHByZXNlbnRcclxuXHRcdHBsYXllcnMgPSBQb3B1bGF0aW9uKCkub25seUFsaXZlKCkub25seUF2YWlsYWJsZSgpO1xyXG5cdH1cclxuXHJcblx0Ly8gYXNzaWduIHBhcmFtZXRlcnMgYW5kIGdlbmVyYXRlIHRoZSBnYW1lXHJcblx0cGFyYW1ldGVycy5pbml0aWFsaXplUGxheWVycyA9IHBsYXllcnM7XHJcblx0dmFyIGl0ZXJhdGlvbiA9IHJvdW5kUm9iaW4ocGxheWVycywgcHJpc29uZXJEaWxlbW1hKGdhbWVMZW5ndGgpLCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0cmV0dXJuIExvb3AoaXRlcmF0aW9uLCByZXBlYXRzLCB7IGlkOiBcIkF4ZWxyb2QtVG91cm5hbWVudFwiIH0pO1xyXG59KTtcclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBeGVscm9kVG91cm5hbWVudDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vL2Jhc2UgZ2FtZVxyXG52YXIgVHdvUGxheWVyTm9ybWFsID0gcmVxdWlyZShcIi4vc2ltcGxlLW5vcm1hbFwiKTtcclxuXHJcbi8vIGhlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgZ2FtZVdyYXBwZXIgfSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpLkJhY2tlbmQuSGVscGVyRnVuY3Rpb25zKFwic3RvY2stZ2FtZXNcIilcclxuXHJcblxyXG4vLyBCYXR0bGUgb2YgdGhlIFNleGVzXHJcbnZhciBCYXR0bGVPZlRoZVNleGVzID0gZ2FtZVdyYXBwZXIoZnVuY3Rpb24ocGxheWVycywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0cGFyYW1ldGVycy5pZCA9IHBhcmFtZXRlcnMuaWQgfHwgXCJCYXR0bGUtb2YtdGhlLVNleGVzXCI7XHJcblxyXG5cdHZhciBjaG9pY2VzID0gW1xyXG5cdFx0W1wiT3BlcmFcIiwgXCJGb290YmFsbFwiXSxcclxuXHRcdFtcIk9wZXJhXCIsIFwiRm9vdGJhbGxcIl1cclxuXHRdO1xyXG5cdHZhciBwYXlvZmZzID0gW1xyXG5cdFx0W1xyXG5cdFx0XHRbMiwgMV0sXHJcblx0XHRcdFswLCAwXVxyXG5cdFx0XSxcclxuXHRcdFtcclxuXHRcdFx0WzAsIDBdLFxyXG5cdFx0XHRbMSwgMl1cclxuXHRcdF1cclxuXHRdO1xyXG5cclxuXHRyZXR1cm4gVHdvUGxheWVyTm9ybWFsKHBsYXllcnMsIGNob2ljZXMsIHBheW9mZnMsIHBhcmFtZXRlcnMpO1xyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmF0dGxlT2ZUaGVTZXhlcztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBOYXNoSlMgZW5naW5lIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG4vLyBVc2VyIGRhdGFcclxudmFyIHsgUG9wdWxhdGlvbiB9ID0gRW5naW5lLkZyb250ZW5kXHJcblxyXG4vLyBQbGF5YWJsZXNcclxudmFyIHsgTGFtYmRhLCBTaW11bHRhbmVvdXMsIFNlcXVlbmNlLCBMb29wIH0gPSBFbmdpbmUuRnJvbnRlbmQuUGxheWFibGVzO1xyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpc0Z1bmN0aW9uIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJnZW5lcmFsXCIpO1xyXG5cclxuXHJcbi8vQ3VsdHVyYWwgZXZvbHV0aW9uXHJcbi8vXHJcbi8vIFRPRE86IGFkZCBpbnN0cnVjdGlvbnMgaGVyZVxyXG5mdW5jdGlvbiBDdWx0dXJhbEV2b2x1dGlvbihnYW1lR2VuZXJhdG9yLCBudW1Mb29wcyA9IDEsIHtcclxuXHRpZCA9IFwiQ3VsdHVyYWxFdm9sdXRpb25cIixcclxuXHRnYW1lUHJvYmFiaWxpdHkgPSAuMjUsXHJcblx0cGFpclByb2JhYmlsaXR5ID0gLjI1LFxyXG5cdGdlbmVyYXRlUG9wdWxhdGlvbiA9IG51bGwsXHJcblx0bG9vcCA9IHRydWVcclxufSA9IHt9KSB7XHJcblxyXG5cdGlmIChsb29wICYmIGlzTmFOKG51bUxvb3BzKSkgdGhyb3cgbmV3IEVycm9yKFwiQ3VsdHVyYWxFdm9sdXRpb24gYXJndW1lbnQgJ251bUxvb3BzIG11c3QgYmUgYSBudW1iZXJcIik7XHJcblx0aWYgKCFpc0Z1bmN0aW9uKGdhbWVHZW5lcmF0b3IpKSB0aHJvdyBuZXcgRXJyb3IoXHJcblx0XHRcIkN1bHR1cmFsRXZvbHV0aW9uIGFyZ3VtZW50ICdnYW1lR2VuZXJhdG9yJyBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XHJcblx0aWYgKGlzTmFOKGdhbWVQcm9iYWJpbGl0eSkgfHwgZ2FtZVByb2JhYmlsaXR5IDwgMCB8fCBnYW1lUHJvYmFiaWxpdHkgPiAxKSB0aHJvdyBuZXcgRXJyb3IoXHJcblx0XHRcIkN1bHR1cmFsRXZvbHV0aW9uIGFyZ3VtZW50ICdnYW1lUHJvYmFiaWxpdHknIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxXCIpO1xyXG5cdGlmIChpc05hTihwYWlyUHJvYmFiaWxpdHkpIHx8IHBhaXJQcm9iYWJpbGl0eSA8IDAgfHwgcGFpclByb2JhYmlsaXR5ID4gMSkgdGhyb3cgbmV3IEVycm9yKFxyXG5cdFx0XCJDdWx0dXJhbEV2b2x1dGlvbiBhcmd1bWVudCAncGFpclByb2JhYmlsaXR5JyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMVwiKTtcclxuXHJcblx0Ly8gR2VuZXJhdGUgcG9wdWxhdGlvbiBpZiB1c2VyIHdhbnRzIHVzIHRvLlxyXG5cdGlmIChpc0Z1bmN0aW9uKGdlbmVyYXRlUG9wdWxhdGlvbikpIGdlbmVyYXRlUG9wdWxhdGlvbigpO1xyXG5cclxuXHQvL1Jlc2V0IHRoZSBzY29yZXMgZWFjaCByb3VuZC5cclxuXHR2YXIgUmVzZXRTY29yZXMgPSBMYW1iZGEoZnVuY3Rpb24oKSB7XHJcblx0XHRQb3B1bGF0aW9uKCkub25seUFsaXZlKCkucmVzZXRTY29yZXMoKTtcclxuXHR9KTtcclxuXHJcblx0Ly8gQ2FsY3VsYXRlIG51bWJlciBvZiBtYXRjaGVzXHJcblx0dmFyIG4gPSBNYXRoLmZsb29yKFBvcHVsYXRpb24oKS5vbmx5QWxpdmUoKS5sZW5ndGggKiBnYW1lUHJvYmFiaWxpdHkpO1xyXG5cclxuXHQvLyBDcmVhdGUgbWF0Y2hlcy5cclxuXHR2YXIgbWF0Y2hlcyA9IFsuLi5BcnJheShuKV1cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0bWF0Y2hlc1tpXSA9IGdhbWVHZW5lcmF0b3IoKTtcclxuXHRcdGlmICghbWF0Y2hlc1tpXS5wbGF5KSB0aHJvdyBuZXcgRXJyb3IoXCJDdWx0dXJhbEV2b2x1dGlvbiBhcmd1bWVudCAnZ2FtZUdlbmVyYXRvcicgbXVzdCByZXR1cm4gYSBQbGF5YWJsZVwiKTtcclxuXHR9XHJcblxyXG5cdC8vUnVuIGFsbCBtYXRjaGVzIHNpbXVsdGFuZW91c2x5XHJcblx0dmFyIFJvdW5kID0gU2ltdWx0YW5lb3VzKG1hdGNoZXMpO1xyXG5cclxuXHQvL0NhbGN1bGF0ZSBudW1iZXIgb2YgcGFpcmluZ3NcclxuXHR2YXIgbiA9IE1hdGguZmxvb3IoUG9wdWxhdGlvbigpLm9ubHlBbGl2ZSgpLmxlbmd0aCAqIHBhaXJQcm9iYWJpbGl0eSlcclxuXHJcblx0Ly9DcmVhdGUgcGFpcmluZ3NcclxuXHR2YXIgcGFpcmluZ3MgPSBbLi4uQXJyYXkobildO1xyXG5cdGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHJcblx0XHRwYWlyaW5nc1tpXSA9IExhbWJkYShmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdC8vRmluZCBzb21lIGF2YWlsYWJsZSBwbGF5ZXJzXHJcblx0XHRcdHZhciBwb29sID0gUG9wdWxhdGlvbigpLm9ubHlBbGl2ZSgpLm9ubHlBdmFpbGFibGUoKTtcclxuXHRcdFx0dmFyIHAxID0gcG9vbFtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwb29sLmxlbmd0aCldO1xyXG5cdFx0XHR2YXIgcDIgPSBwb29sW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvb2wubGVuZ3RoKV07XHJcblxyXG5cdFx0XHQvL01hcmsgdGhlbSBidXN5XHJcblx0XHRcdHAxLmJ1c3koKTtcclxuXHRcdFx0cDIuYnVzeSgpO1xyXG5cclxuXHRcdFx0Ly8gQXNzaWduIHN0cmF0ZWd5IG9mIHBsYXllciB3aXRoIGhpZ2hlciBzY29yZVxyXG5cdFx0XHRpZiAocDEuc2NvcmUoKSA+IHAyLnNjb3JlKCkpIHAyLmFzc2lnbihwMS5zdHJhdGVneSgpKTtcclxuXHRcdFx0ZWxzZSBpZiAocDEuc2NvcmUoKSA9PSBwMi5zY29yZSgpKSBudWxsO1xyXG5cdFx0XHRlbHNlIHAxLmFzc2lnbihwMi5zdHJhdGVneSgpKTtcclxuXHJcblx0XHRcdC8vUmV0dXJuIHZhbHVlIG9mIHBsYXllciBpZHMsIHNvIHRoZSBsb2cgbWFrZXMgc29tZSBzZW5zZS5cclxuXHRcdFx0cmV0dXJuIFtwMS5pZCgpLCBwMi5pZCgpXTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Ly8gUnVuIHBhaXJpbmdzIHNpbXVsdGFuZW91c2x5XHJcblx0dmFyIFBhaXJpbmcgPSBTaW11bHRhbmVvdXMocGFpcmluZ3MpO1xyXG5cclxuXHQvLyBBZnRlciBwYWlyaW5ncywgbWFyayBhbGwgcGxheWVycyBhcyBhdmFpbGFibGUuXHJcblx0dmFyIFJlbGVhc2VQbGF5ZXJzID0gTGFtYmRhKGZ1bmN0aW9uKCkge1xyXG5cdFx0UG9wdWxhdGlvbigpLm9ubHlBbGl2ZSgpLnJlbGVhc2UoKTtcclxuXHR9KTtcclxuXHJcblx0Ly8gRGVmaW5lIHRoZSBnYW1lLlxyXG5cdFJvdW5kKFJlc2V0U2NvcmVzKTtcclxuXHRQYWlyaW5nKFJvdW5kKTtcclxuXHRSZWxlYXNlUGxheWVycyhQYWlyaW5nKTtcclxuXHR2YXIgSXRlcmF0aW9uID0gU2VxdWVuY2UoUmVzZXRTY29yZXMsIFJlbGVhc2VQbGF5ZXJzKTtcclxuXHJcblx0Ly8gVXNlciBjYW4gc2V0IGxvb3AgcGFyYW1ldGVyIHRvIGZhbHNlLCB0byBhdm9pZCB3cmFwcGluZyB0aGlzIGluIGEgbG9vcC5cclxuXHRpZiAobG9vcClcclxuXHRcdHZhciBDRSA9IExvb3AoSXRlcmF0aW9uLCBudW1Mb29wcywgeyBwbGF5YWJsZVBhcmFtZXRlcnM6IHsgaW5pdGlhbGl6ZVBsYXllcnM6IHRydWUgfSB9KTtcclxuXHRlbHNlXHJcblx0XHR2YXIgQ0UgPSBJdGVyYXRpb247XHJcblxyXG5cdHJldHVybiBDRTtcclxufVxyXG5cclxuLy9UT0RPOiBmaXggcGFyYW1ldGVycy4gVXNlciBzaG91bGQgYmUgYWJsZSB0byBzdXBwbHkgcGFyYW1ldGVycyB3aGljaCBlaXRoZXJcclxuLy8gZW5kIHVwIGFzIHBhcmFtZXRlcnMgZm9yIHRoZSBMb29wIG9yIHRoZSBTZXF1ZW5jZS5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEN1bHR1cmFsRXZvbHV0aW9uO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIGJhc2UgZ2FtZVxyXG52YXIgVHdvUGxheWVyTm9ybWFsID0gcmVxdWlyZShcIi4vc2ltcGxlLW5vcm1hbFwiKS5Ud29QbGF5ZXJOb3JtYWw7XHJcblxyXG4vLyBOYXNoSlMgZW5naW5lIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG4vLyBOYXNoIGVuZ2luZSBjb21wb25lbnRzXHJcbnZhciB7IFNlcXVlbmNlLCBMYW1iZGEgfSA9IEVuZ2luZS5Gcm9udGVuZC5QbGF5YWJsZXM7XHJcblxyXG4vLyBHYW1lIHN0YXRlXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSBFbmdpbmUuQmFja2VuZC5TdGF0ZVxyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lV3JhcHBlciB9ID0gRW5naW5lLkJhY2tlbmQuSGVscGVyRnVuY3Rpb25zKFwic3RvY2stZ2FtZXNcIilcclxuXHJcbi8vIFdlJ2xsIG5lZWQgdGhlICdiYWxhbmNlLXNoZWV0JyBwbHVnaW5cclxudmFyIFBsdWdpbk1hbmFnZXIgPSBFbmdpbmUuQmFja2VuZC5QbHVnaW5NYW5hZ2VyO1xyXG5cclxuZnVuY3Rpb24gaW52ZXJ0VGVybXModGVybXNPZlRyYWRlKSB7XHJcblx0dmFyIGludmVyc2UgPSB7fVxyXG5cdE9iamVjdC5lbnRyaWVzKHRlcm1zT2ZUcmFkZSkuZm9yRWFjaChmdW5jdGlvbih0ZXJtKSB7XHJcblx0XHRpZiAodGVybVswXSA9PSBcImJvcnJvd1wiKSB7XHJcblx0XHRcdGludmVyc2UubGVuZCA9IHRlcm1bMV1cclxuXHRcdH0gZWxzZSBpZiAodGVybVswXSA9PSBcImxlbmRcIikge1xyXG5cdFx0XHRpbnZlcnNlLmJvcnJvdyA9IHRlcm1bMV1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGludmVyc2VbdGVybVswXV0gPSB0ZXJtWzFdICogLTFcclxuXHRcdH1cclxuXHR9KTtcclxuXHRyZXR1cm4gaW52ZXJzZTtcclxufVxyXG5cclxuLy8gdGVybXNPZlRyYWRlIHNob3VsZCBiZSBhbiBvYmplY3QgcmVmbGVjdGluZyB0aGUgb3V0Y29tZXMgZm9yIHBsYXllciAxLlxyXG4vLyBFeGFtcGxlIHthcHBsZToyLCBvcmFuZ2U6LTJ9LiBUbyBib3Jyb3cgb3IgbGVuZCwgY3JlYXRlIGEgc3ViLW9iamVjdCBkZXNjcmliaW5nIHRoZSBsb2FuIHRlcm1zLlxyXG4vLyBlZyB7YXBwbGU6MiwgYm9ycm93OntJT1U6NX19LCBvciB7Y291Y2g6LTEwLCBsZW5kOnsnY3JlZGl0IGNhcmQnOjUwfX1cclxudmFyIEV4Y2hhbmdlID0gZ2FtZVdyYXBwZXIoZnVuY3Rpb24ocGxheWVycywgdGVybXNPZlRyYWRlID0ge30sIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHZhciB7IHV0aWxpdHlGdW5jdGlvbnMsIHV0aWxpdHlNb2RlID0gXCJhYnNvbHV0ZVwiLCBpbml0aWFsRW5kb3dtZW50ID0gW3t9LCB7fV0gfSA9IHBhcmFtZXRlcnMgLy91dGlsaXR5RnVuY3Rpb25zIHNob3VsZCBiZSBhbiBhcnJheSBvZiAyIGZ1bmN0aW9ucywgd2hpY2ggdGFrZSBhIHJlc3VsdHMgb2JqZWN0IGFuZCByZXR1cm4gYSBjaGFuZ2UgaW4gdXRpbGl0eVxyXG5cdHBhcmFtZXRlcnMuaWQgPSBcIkV4Y2hhbmdlXCIgfHwgcGFyYW1ldGVycy5pZDtcclxuXHJcblxyXG5cclxuXHJcblx0Ly8gVG8gcGxheSB0aGlzIGdhbWUsIHBsYXllcnMgd2lsbCBuZWVkIGEgYmFsYW5jZSBzaGVldC4gVGhpcyBwbHVnaW4gd2lsbCBhZGQgYmFsYW5jZSBzaGVldHMgdG8gdGhlIHBsYXllcnMsXHJcblx0Ly8gYXMgd2VsbCBhcyBlbnN1cmUgdGhhdCBuZXcgcGxheWVycyBhcmUgY3JlYXRlZCB3aXRoIG9uZSwgYW5kIHRoYXQgdGhleSBhcmUgcmUtaW5pdGlhbGl6ZWQgcHJvcGVybHkuXHJcblx0dmFyIGJhbGFuY2VTaGVldCA9IFBsdWdpbk1hbmFnZXIucGFja2FnZShcImJhbGFuY2Utc2hlZXQtY29tcGxleFwiKS5yZXF1aXJlKHBsYXllcnMpO1xyXG5cdGJhbGFuY2VTaGVldC5zZXR0aW5ncyh7IGNsZWFuWmVyb3M6IGZhbHNlIH0pXHJcblxyXG5cdHZhciBwMSA9IHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyc1swXS5pZCgpXTtcclxuXHR2YXIgcDIgPSByZWdpc3RyeS5wbGF5ZXJzW3BsYXllcnNbMV0uaWQoKV07XHJcblxyXG5cdC8vIERvIGluaXRpYWwgZW5kb3dtZW50cyBpZiB0aGVyZSBhcmUgYW55LiBGb3JtYXQgc2FtZSBhcyBmb3IgdGVybXMgb2YgdHJhZGUuXHJcblx0aW5pdGlhbEVuZG93bWVudC5mb3JFYWNoKGZ1bmN0aW9uKGVuZG93bWVudCwgaW5kZXgpIHtcclxuXHRcdHZhciBwbGF5ZXIgPSBwbGF5ZXJzW2luZGV4XVxyXG5cdFx0dmFyIGludmVydFBsYXllciA9IHBsYXllcnNbTnVtYmVyKCFpbmRleCldXHJcblx0XHRPYmplY3QuZW50cmllcyhlbmRvd21lbnQpLmZvckVhY2goZnVuY3Rpb24odGVybSkge1xyXG5cdFx0XHRpZiAodGVybVswXSA9PSBcImJvcnJvd1wiKSB7XHJcblx0XHRcdFx0dmFyIGxvYW5UZXJtcyA9IE9iamVjdC5lbnRyaWVzKHRlcm1bMV0pWzBdXHJcblx0XHRcdFx0bmV3IGJhbGFuY2VTaGVldC5GaW5hbmNpYWxDbGFpbShpbnZlcnRQbGF5ZXIsIHBsYXllciwgbG9hblRlcm1zWzFdLCBsb2FuVGVybXNbMF0pXHJcblx0XHRcdH0gZWxzZSBpZiAodGVybVswXSA9PSBcImxlbmRcIikge1xyXG5cdFx0XHRcdHZhciBsb2FuVGVybXMgPSBPYmplY3QuZW50cmllcyh0ZXJtWzFdKVswXVxyXG5cdFx0XHRcdG5ldyBiYWxhbmNlU2hlZXQuRmluYW5jaWFsQ2xhaW0ocGxheWVyLCBpbnZlcnRQbGF5ZXIsIGxvYW5UZXJtc1sxXSwgbG9hblRlcm1zWzBdKVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG5ldyBiYWxhbmNlU2hlZXQuUmVhbENsYWltKHBsYXllciwgdGVybVswXSwgdGVybVsxXSlcclxuXHRcdFx0fVxyXG5cdFx0fSlcclxuXHR9KVxyXG5cclxuXHQvLyBUaGUgYWN0dWFsIHBsYXlhYmxlXHJcblx0dmFyIERlY2lzaW9uID0gVHdvUGxheWVyTm9ybWFsKHBsYXllcnMsIFtcclxuXHRcdFtcIkFjY2VwdFwiLCBcIlJlamVjdFwiXSxcclxuXHRcdFtcIkFjY2VwdFwiLCBcIlJlamVjdFwiXVxyXG5cdF0sIG51bGwsIHtcclxuXHRcdGlkOiBcIkRlY2lzaW9uXCIsXHJcblx0XHRpbmZvcm1hdGlvbkZpbHRlcjogZnVuY3Rpb24oaW5mbykgeyAvL1RPRE8gbWlnaHQgbmVlZCB0byB3cmFwIHVzZXItc3VwcGxpZWQgaW5mb3JtYXRpb25GaWx0ZXI/XHJcblx0XHRcdGluZm8udGVybXNPZlRyYWRlID0ge1xyXG5cdFx0XHRcdFtwMS5pZF06IHRlcm1zT2ZUcmFkZSxcclxuXHRcdFx0XHRbcDIuaWRdOiBpbnZlcnRUZXJtcyh0ZXJtc09mVHJhZGUpXHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGluZm87XHJcblx0XHR9XHJcblx0fSlcclxuXHJcblx0Ly8gRGlzdHJpYnV0ZSB0aGUgZ29vZHNcclxuXHR2YXIgRGlzdHJpYnV0ZSA9IExhbWJkYShmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0cyA9IFtdO1xyXG5cclxuXHRcdE9iamVjdC5lbnRyaWVzKHRlcm1zT2ZUcmFkZSkuZm9yRWFjaChmdW5jdGlvbih0ZXJtKSB7XHJcblx0XHRcdGlmICh0ZXJtWzBdID09IFwiYm9ycm93XCIpIHtcclxuXHRcdFx0XHR2YXIgbG9hblRlcm1zID0gT2JqZWN0LmVudHJpZXModGVybVsxXSlbMF1cclxuXHRcdFx0XHR2YXIgbG9hbiA9IG5ldyBiYWxhbmNlU2hlZXQuRmluYW5jaWFsQ2xhaW0ocDIuaW50ZXJmYWNlLCBwMS5pbnRlcmZhY2UsIGxvYW5UZXJtc1sxXSwgbG9hblRlcm1zWzBdKVxyXG5cclxuXHRcdFx0XHRyZXN1bHRzLnB1c2goe1xyXG5cdFx0XHRcdFx0cGxheWVyOiBwMS5pZCxcclxuXHRcdFx0XHRcdGJvcnJvdzoge1xyXG5cdFx0XHRcdFx0XHRbbG9hblRlcm1zWzBdXTogbG9hblRlcm1zWzFdXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHJlc3VsdHMucHVzaCh7XHJcblx0XHRcdFx0XHRwbGF5ZXI6IHAyLmlkLFxyXG5cdFx0XHRcdFx0bGVuZDoge1xyXG5cdFx0XHRcdFx0XHRbcDEuaWRdOiB7XHJcblx0XHRcdFx0XHRcdFx0W2xvYW5UZXJtc1swXV06IGxvYW5UZXJtc1sxXVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKHRlcm1bMF0gPT0gXCJsZW5kXCIpIHtcclxuXHRcdFx0XHR2YXIgbG9hblRlcm1zID0gT2JqZWN0LmVudHJpZXModGVybVsxXSlbMF1cclxuXHRcdFx0XHR2YXIgbG9hbiA9IG5ldyBiYWxhbmNlU2hlZXQuRmluYW5jaWFsQ2xhaW0ocDEuaW50ZXJmYWNlLCBwMi5pbnRlcmZhY2UsIGxvYW5UZXJtc1sxXSwgbG9hblRlcm1zWzBdKVxyXG5cclxuXHRcdFx0XHRyZXN1bHRzLnB1c2goe1xyXG5cdFx0XHRcdFx0cGxheWVyOiBwMi5pZCxcclxuXHRcdFx0XHRcdGJvcnJvdzoge1xyXG5cdFx0XHRcdFx0XHRbbG9hblRlcm1zWzBdXTogbG9hblRlcm1zWzFdXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHJlc3VsdHMucHVzaCh7XHJcblx0XHRcdFx0XHRwbGF5ZXI6IHAxLmlkLFxyXG5cdFx0XHRcdFx0bGVuZDoge1xyXG5cdFx0XHRcdFx0XHRbcDIuaWRdOiB7XHJcblx0XHRcdFx0XHRcdFx0W2xvYW5UZXJtc1swXV06IGxvYW5UZXJtc1sxXVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBnb29kID0gbmV3IGJhbGFuY2VTaGVldC5SZWFsQ2xhaW0ocDEuaW50ZXJmYWNlLCB0ZXJtWzBdLCAwKVxyXG5cdFx0XHRcdGdvb2QudHJhbnNmZXIocDIuaW50ZXJmYWNlLCB0ZXJtWzFdICogLTEpXHJcblxyXG5cdFx0XHRcdHJlc3VsdHMucHVzaCh7IHBsYXllcjogcDEuaWQsIFt0ZXJtWzBdXTogdGVybVsxXSB9KTtcclxuXHRcdFx0XHRyZXN1bHRzLnB1c2goeyBwbGF5ZXI6IHAyLmlkLCBbdGVybVswXV06IC0xICogdGVybVsxXSB9KTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cclxuXHRcdGlmICh1dGlsaXR5RnVuY3Rpb25zKSB7XHJcblxyXG5cdFx0XHRwMS5zY29yZSA9IHV0aWxpdHlNb2RlLnRvTG93ZXJDYXNlKCkgPT0gXCJyZWxhdGl2ZVwiID8gcDEuc2NvcmUgKyB1dGlsaXR5RnVuY3Rpb25zWzBdKHJlc3VsdHMpIDpcclxuXHRcdFx0XHR1dGlsaXR5RnVuY3Rpb25zWzBdKHJlc3VsdHMpXHJcblx0XHRcdHAyLnNjb3JlID0gdXRpbGl0eU1vZGUudG9Mb3dlckNhc2UoKSA9PSBcInJlbGF0aXZlXCIgPyBwMi5zY29yZSArIHV0aWxpdHlGdW5jdGlvbnNbMV0ocmVzdWx0cykgOlxyXG5cdFx0XHRcdHV0aWxpdHlGdW5jdGlvbnNbMV0ocmVzdWx0cylcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0cztcclxuXHR9LCB7IGlkOiBcIkRpc3RyaWJ1dGlvblwiIH0pO1xyXG5cclxuXHQvL0J1dCBvbmx5IGRvIGl0IGlmIHRoZSB0cmFkZSBnb2VzIHRocm91Z2guXHJcblx0RGlzdHJpYnV0ZShEZWNpc2lvbi5BY2NlcHQuQWNjZXB0KCkpXHJcblxyXG5cclxuXHJcblx0cmV0dXJuIFNlcXVlbmNlKERlY2lzaW9uLCBEaXN0cmlidXRlLCBwYXJhbWV0ZXJzKTtcclxufSwge1xyXG5cdGFyZ3VtZW50VmFsaWRhdG9yKHBsYXllcnMsIHRlcm1zT2ZUcmFkZSkge1xyXG5cdFx0Ly8gVE9ETzogdmFsaWRhdGUgcGFyYW1ldGVyc1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV4Y2hhbmdlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBTdG9ja0dhbWVzID0ge1xyXG5cdC8vR2FtZSBza2VsZXRvbnNcclxuXHRcIlR3by1QbGF5ZXIgTm9ybWFsXCI6IHJlcXVpcmUoXCIuL3NpbXBsZS1ub3JtYWxcIikuVHdvUGxheWVyTm9ybWFsLFxyXG5cdFwiTm9ybWFsXCI6IHJlcXVpcmUoXCIuL3NpbXBsZS1ub3JtYWxcIikuTm9ybWFsLFxyXG5cdFwiU2ltcGxlIFplcm8tU3VtXCI6IHJlcXVpcmUoXCIuL3NpbXBsZS16ZXJvLXN1bVwiKSxcclxuXHJcblx0Ly8gQ2xhc3NpYyBnYW1lc1xyXG5cdFwiQmF0dGxlIE9mIFRoZSBTZXhlc1wiOiByZXF1aXJlKFwiLi9iYXR0bGUtb2YtdGhlLXNleGVzXCIpLFxyXG5cdFwiTWF0Y2hpbmcgUGVubmllc1wiOiByZXF1aXJlKFwiLi9tYXRjaGluZy1wZW5uaWVzXCIpLFxyXG5cdFwiUHJpc29uZXIncyBEaWxlbW1hXCI6IHJlcXVpcmUoXCIuL3ByaXNvbmVyLWRpbGVtbWFcIiksXHJcblx0XCJSb2NrLVBhcGVyLVNjaXNzb3JzXCI6IHJlcXVpcmUoXCIuL3JvY2stcGFwZXItc2Npc3NvcnNcIiksXHJcblxyXG5cdC8vIEl0ZXJhdGVkIGdhbWVzXHJcblx0XCJJdGVyYXRlZFwiOiByZXF1aXJlKFwiLi9pdGVyYXRlZFwiKSxcclxuXHRcIkl0ZXJhdGVkIFByaXNvbmVyJ3MgRGlsZW1tYVwiOiByZXF1aXJlKFwiLi9pdGVyYXRlZC1wcmlzb25lci1kaWxlbW1hXCIpLFxyXG5cclxuXHQvLyBFdm9sdXRpb25hcnkgZ2FtZXNcclxuXHRcIkN1bHR1cmFsIEV2b2x1dGlvblwiOiByZXF1aXJlKFwiLi9jdWx0dXJhbC1ldm9sdXRpb25cIiksXHJcblxyXG5cdC8vVG91cm5hbWVudHNcclxuXHRcIlJvdW5kIFJvYmluXCI6IHJlcXVpcmUoXCIuL3JvdW5kLXJvYmluXCIpLFxyXG5cdFwiQXhlbHJvZCBUb3VybmFtZW50XCI6IHJlcXVpcmUoXCIuL2F4ZWxyb2QtdG91cm5hbWVudFwiKSxcclxuXHJcblx0Ly8gUHJvYmFiaWxpdHkgVGhlb3J5XHJcblx0XCJNb250eSBIYWxsXCI6IHJlcXVpcmUoXCIuL21vbnR5LWhhbGxcIiksXHJcblxyXG5cdC8vTmVvY2xhc3NpY2FsIGVjb25vbWljc1xyXG5cdFwiRXhjaGFuZ2VcIjogcmVxdWlyZShcIi4vZXhjaGFuZ2UtY29tcGxleFwiKSxcclxuXHJcblx0Ly8gRnVuY3Rpb24gdG8gZGlzcGxheSBsb2FkZWQgcXVlcnkgc2hvcnRjdXRzLlxyXG5cdHF1ZXJpZXMoKSB7XHJcblx0XHRyZXR1cm4gT2JqZWN0LmtleXMocmVnaXN0cnkucXVlcmllcykubWFwKGZ1bmN0aW9uKHF1ZXJ5KSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0W3F1ZXJ5XTogcmVnaXN0cnkucXVlcmllc1txdWVyeV0uZGVzY3JpcHRpb25cclxuXHRcdFx0fVxyXG5cdFx0fSlcclxuXHR9XHJcbn07XHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3RvY2tHYW1lcztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBCYXNlIGdhbWVcclxudmFyIHByaXNvbmVyRGlsZW1tYSA9IHJlcXVpcmUoXCIuL3ByaXNvbmVyLWRpbGVtbWFcIikuY3JlYXRlR2VuZXJhdG9yKCk7XHJcblxyXG4vLyBOYXNoSlMgZW5naW5lIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG4vLyBnYW1lIGVuZ2luZVxyXG52YXIgeyBMb29wIH0gPSBFbmdpbmUuRnJvbnRlbmQuUGxheWFibGVzO1xyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lV3JhcHBlciB9ID0gRW5naW5lLkJhY2tlbmQuSGVscGVyRnVuY3Rpb25zKFwic3RvY2stZ2FtZXNcIilcclxuXHJcbi8vIEdhbWUgdXRpbGl0eVxyXG52YXIgSXRlcmF0ZWQgPSByZXF1aXJlKFwiLi9pdGVyYXRlZFwiKVxyXG5cclxuXHJcblxyXG52YXIgSXRlcmF0ZWRQcmlzb25lckRpbGVtbWEgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCBudW1iZXJJdGVyYXRpb25zID0gNTAsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHJldHVybiBJdGVyYXRlZChwbGF5ZXJzLCBwcmlzb25lckRpbGVtbWEsIFwiUHJpc29uZXItRGlsZW1tYVwiLCBudW1iZXJJdGVyYXRpb25zLCBwYXJhbWV0ZXJzKVxyXG59LCB7XHJcblx0cXVlcmllczogW3tcclxuXHRcdFx0c2hvcnRjdXQ6IFwiQElQRC1jaG9pY2VzXCIsXHJcblx0XHRcdHF1ZXJ5OiBcIiRtYXAoJC5bYWN0aW9uXS5yZXN1bHRzLCBmdW5jdGlvbigkbCl7JGwucmVzdWx0fSlcIixcclxuXHRcdFx0ZGVzY3JpcHRpb246IFwiUmVzdWx0cywgb3JnYW5pemVkIGJ5IHJvdW5kLlwiXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRzaG9ydGN1dDogXCJASVBELXBsYXllcnNcIixcclxuXHRcdFx0cXVlcnk6IFwiJG1hcCgkLlthY3Rpb25dLnJlc3VsdHMsIGZ1bmN0aW9uKCRsKXskbC5wbGF5ZXJ9KVwiLFxyXG5cdFx0XHRkZXNjcmlwdGlvbjogXCJQbGF5ZXJzLCBvcmdhbml6ZWQgYnkgcm91bmQuXCJcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdHNob3J0Y3V0OiBcIkBJUEQtcGF5b3V0c1wiLFxyXG5cdFx0XHRxdWVyeTogXCIkLmFjdGlvbi5wYXlvdXRzXCIsXHJcblx0XHRcdGRlc2NyaXB0aW9uOiBcIlBheW91dHMsIGFzIGFycmF5IG9mIG9iamVjdHMuXCJcclxuXHRcdH1cclxuXHRdLFxyXG5cdHN0cmF0ZWd5TG9hZGVyKCkge1xyXG5cdFx0cmV0dXJuIFt7XHJcblx0XHRcdFx0bmFtZTogXCJUaXQgRm9yIFRhdFwiLFxyXG5cdFx0XHRcdGRlc2NyaXB0aW9uOiBcIkRvIHdoYXRldmVyIHlvdXIgb3Bwb25lbnQgZGlkIGxhc3QgdHVybi4gQ29vcGVyYXRlIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHR1cm4uXCIsXHJcblx0XHRcdFx0c3RyYXRlZ3k6IGZ1bmN0aW9uIHRpdEZvclRhdCgpIHtcclxuXHRcdFx0XHRcdHRoaXMuY2hvb3NlID0gZnVuY3Rpb24oY2hvaWNlcywgaW5mb3JtYXRpb24pIHtcclxuXHRcdFx0XHRcdFx0aWYgKGluZm9ybWF0aW9uLm9wcG9uZW50Lmhpc3RvcnkubGVuZ3RoKSByZXR1cm4gaW5mb3JtYXRpb24ub3Bwb25lbnQuaGlzdG9yeVtpbmZvcm1hdGlvbi5vcHBvbmVudFxyXG5cdFx0XHRcdFx0XHRcdFx0Lmhpc3RvcnkubGVuZ3RoIC0gMV1cclxuXHRcdFx0XHRcdFx0XHQucmVzdWx0XHJcblx0XHRcdFx0XHRcdGVsc2UgcmV0dXJuIFwiQ29vcGVyYXRlXCI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0bmFtZTogXCJHcnVkZ2VyXCIsXHJcblx0XHRcdFx0ZGVzY3JpcHRpb246IFwiQ29vcGVyYXRlIHVudGlsIHlvdXIgb3Bwb25lbnQgZG9lc24ndCwgdGhlbiBEZWZlY3QuXCIsXHJcblx0XHRcdFx0c3RyYXRlZ3k6IGZ1bmN0aW9uIGdydWRnZXIoKSB7XHJcblx0XHRcdFx0XHR0aGlzLmNvb3BlcmF0aW5nID0gdHJ1ZVxyXG5cclxuXHRcdFx0XHRcdHRoaXMuY2hvb3NlID0gZnVuY3Rpb24oY2hvaWNlcywgaW5mb3JtYXRpb24pIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIElmIG9wcG9uZW50IGp1c3QgZGVmZWN0ZWQsIHRoZW4gc3RvcCBjb29wZXJhdGluZ1xyXG5cdFx0XHRcdFx0XHRpZiAoaW5mb3JtYXRpb24ub3Bwb25lbnQuaGlzdG9yeS5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoaW5mb3JtYXRpb24ub3Bwb25lbnQuaGlzdG9yeVtpbmZvcm1hdGlvbi5vcHBvbmVudC5oaXN0b3J5Lmxlbmd0aCAtIDFdLnJlc3VsdCA9PSBcIkRlZmVjdFwiKSB0aGlzXHJcblx0XHRcdFx0XHRcdFx0XHQuY29vcGVyYXRpbmcgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuY29vcGVyYXRpbmcpIHJldHVybiBcIkNvb3BlcmF0ZVwiO1xyXG5cdFx0XHRcdFx0XHRlbHNlIHJldHVybiBcIkRlZmVjdFwiO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHtcclxuXHRcdFx0XHRuYW1lOiBcIk5haXZlIFByb2JlclwiLFxyXG5cdFx0XHRcdGRlc2NyaXB0aW9uOiBcIkxpa2UgVGl0IEZvciBUYXQsIGJ1dCBvY2Nhc2lvbmFsbHkgRGVmZWN0cyB3aXRoIHNtYWxsIHByb2JhYmlsaXR5XCIsXHJcblx0XHRcdFx0c3RyYXRlZ3k6IGZ1bmN0aW9uIHByb2Jlcihwcm9iYWJpbGl0eSA9IDAuMSkge1xyXG5cdFx0XHRcdFx0dGhpcy5jaG9vc2UgPSBmdW5jdGlvbihjaG9pY2VzLCBpbmZvcm1hdGlvbikge1xyXG5cdFx0XHRcdFx0XHRpZiAoTWF0aC5yYW5kb20oKSA8IHByb2JhYmlsaXR5KSByZXR1cm4gXCJEZWZlY3RcIjtcclxuXHJcblx0XHRcdFx0XHRcdGlmIChpbmZvcm1hdGlvbi5vcHBvbmVudC5oaXN0b3J5Lmxlbmd0aCkgcmV0dXJuIGluZm9ybWF0aW9uLm9wcG9uZW50Lmhpc3RvcnlbaW5mb3JtYXRpb24ub3Bwb25lbnRcclxuXHRcdFx0XHRcdFx0XHRcdC5oaXN0b3J5Lmxlbmd0aCAtIDFdXHJcblx0XHRcdFx0XHRcdFx0LnJlc3VsdFxyXG5cdFx0XHRcdFx0XHRlbHNlIHJldHVybiBcIkNvb3BlcmF0ZVwiO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHtcclxuXHRcdFx0XHRuYW1lOiBcIlRpdCBGb3IgVHdvIFRhdHNcIixcclxuXHRcdFx0XHRkZXNjcmlwdGlvbjogXCJDb29wZXJhdGVzIG9uIHRoZSBmaXJzdCBtb3ZlLCB0aGVuIERlZmVjdHMgb25seSB3aGVuIHRoZSBvcHBvbmVudCBEZWZlY3RzIHR3byB0aW1lc1wiLFxyXG5cdFx0XHRcdHN0cmF0ZWd5OiBmdW5jdGlvbiBURjJUKCkge1xyXG5cdFx0XHRcdFx0dGhpcy5jaG9vc2UgPSBmdW5jdGlvbihjaG9pY2VzLCBpbmZvcm1hdGlvbikge1xyXG5cdFx0XHRcdFx0XHRpZiAoaW5mb3JtYXRpb24ub3Bwb25lbnQuaGlzdG9yeS5sZW5ndGggPiAxKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGluZm9ybWF0aW9uLm9wcG9uZW50Lmhpc3RvcnlbaW5mb3JtYXRpb24ub3Bwb25lbnQuaGlzdG9yeS5sZW5ndGggLSAxXS5yZXN1bHQgPT0gXCJEZWZlY3RcIiAmJlxyXG5cdFx0XHRcdFx0XHRcdFx0aW5mb3JtYXRpb24ub3Bwb25lbnQuaGlzdG9yeVtpbmZvcm1hdGlvbi5vcHBvbmVudC5oaXN0b3J5Lmxlbmd0aCAtIDJdLnJlc3VsdCA9PSBcIkRlZmVjdFwiKSByZXR1cm4gXCJEZWZlY3RcIjtcclxuXHRcdFx0XHRcdFx0XHRlbHNlIHJldHVybiBcIkNvb3BlcmF0ZVwiO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgcmV0dXJuIFwiQ29vcGVyYXRlXCI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XVxyXG5cdH1cclxufSk7XHJcbi8vIFRPRE8gdmFsaWRhdGUgYXJndW1lbnRzXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEl0ZXJhdGVkUHJpc29uZXJEaWxlbW1hXHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gTmFzaEpTIGVuZ2luZSBjb21wb25lbnRzXHJcbnZhciBFbmdpbmUgPSByZXF1aXJlKFwiLi4vbGliL2VuZ2luZVwiKVxyXG5cclxuLy8gZ2FtZSBlbmdpbmVcclxudmFyIHsgTG9vcCB9ID0gRW5naW5lLkZyb250ZW5kLlBsYXlhYmxlcztcclxuXHJcbi8vIGhlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgZ2FtZVdyYXBwZXIgfSA9IEVuZ2luZS5CYWNrZW5kLkhlbHBlckZ1bmN0aW9ucyhcInN0b2NrLWdhbWVzXCIpXHJcblxyXG5cclxudmFyIEl0ZXJhdGVkID0gZ2FtZVdyYXBwZXIoZnVuY3Rpb24ocGxheWVycywgZ2FtZUdlbmVyYXRvciwgZ2FtZU5hbWUsIG51bWJlckl0ZXJhdGlvbnMgPSA1MCwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblxyXG5cdHZhciB7IHBhcmFtZXRlcnM6IGdhbWVQYXJhbWV0ZXJzID0ge30gfSA9IHBhcmFtZXRlcnNcclxuXHJcblx0Z2FtZVBhcmFtZXRlcnMuaWQgPSBnYW1lUGFyYW1ldGVycy5pZCB8fCBnYW1lTmFtZVxyXG5cdHBhcmFtZXRlcnMuaWQgPSBwYXJhbWV0ZXJzLmlkIHx8IFwiSXRlcmF0ZWQtXCIgKyBnYW1lTmFtZTtcclxuXHJcblx0cmV0dXJuIExvb3AoZ2FtZUdlbmVyYXRvcihwbGF5ZXJzLCBnYW1lUGFyYW1ldGVycyksIG51bWJlckl0ZXJhdGlvbnMsIHBhcmFtZXRlcnMpO1xyXG59KVxyXG5cclxuLy8gVE9ETyB2YWxpZGF0ZSBhcmd1bWVudHNcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSXRlcmF0ZWQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gYmFzZSBnYW1lXHJcbnZhciBTaW1wbGVaZXJvU3VtID0gcmVxdWlyZShcIi4vc2ltcGxlLXplcm8tc3VtXCIpO1xyXG5cclxuLy8gTmFzaEpTIGVuZ2luZSBjb21wb25lbnRzXHJcbnZhciBFbmdpbmUgPSByZXF1aXJlKFwiLi4vbGliL2VuZ2luZVwiKVxyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lV3JhcHBlciB9ID0gRW5naW5lLkJhY2tlbmQuSGVscGVyRnVuY3Rpb25zKFwic3RvY2stZ2FtZXNcIilcclxuXHJcbi8vIFBsYXktdGltZSBsb2dpY1xyXG52YXIgeyBFeHByZXNzaW9uIH0gPSBFbmdpbmUuRnJvbnRlbmRcclxuXHJcblxyXG52YXIgTWF0Y2hpbmdQZW5uaWVzID0gZ2FtZVdyYXBwZXIoZnVuY3Rpb24ocGxheWVycywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0cGFyYW1ldGVycy5pZCA9IHBhcmFtZXRlcnMuaWQgfHwgXCJNYXRjaGluZy1QZW5uaWVzXCI7XHJcblx0cGF5b2ZmID0gcGFyYW1ldGVycy5wYXlvZmYgfHwgMTtcclxuXHJcblx0dmFyIHdpbiA9IHBheW9mZjtcclxuXHR2YXIgbG9zZSA9IEV4cHJlc3Npb24oZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gLXBheW9mZjtcclxuXHR9KTtcclxuXHJcblx0dmFyIGNob2ljZXMgPSBbXHJcblx0XHRbXCJIZWFkc1wiLCBcIlRhaWxzXCJdLFxyXG5cdFx0W1wiSGVhZHNcIiwgXCJUYWlsc1wiXVxyXG5cdF07XHJcblxyXG5cdHZhciBwYXlvZmZzID0gW1xyXG5cdFx0W3dpbiwgbG9zZV0sXHJcblx0XHRbbG9zZSwgd2luXVxyXG5cdF07XHJcblxyXG5cdHJldHVybiBTaW1wbGVaZXJvU3VtKHBsYXllcnMsIGNob2ljZXMsIHBheW9mZnMsIHBhcmFtZXRlcnMpO1xyXG59KTtcclxuXHJcbi8vIE1hdGNoaW5nIFBlbm5pZXNcclxubW9kdWxlLmV4cG9ydHMgPSBNYXRjaGluZ1Blbm5pZXM7XHJcbiIsIlwidXNlIHN0cmljdFwiXHJcblxyXG4vLyBOYXNoSlMgZW5naW5lIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpO1xyXG5cclxuLy8gUGxheWFibGVzXHJcbnZhciB7IENob2ljZSwgTGFtYmRhIH0gPSBFbmdpbmUuRnJvbnRlbmQuUGxheWFibGVzO1xyXG5cclxuLy8gbG9naWNcclxudmFyIHsgVmFyaWFibGUsIENvbXBsZXhWYXJpYWJsZSB9ID0gRW5naW5lLkZyb250ZW5kXHJcblxyXG4vLyBoZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKTtcclxuXHJcblxyXG52YXIgTW9udHlIYWxsID0gZ2FtZVdyYXBwZXIoZnVuY3Rpb24ocGxheWVyLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRwYXJhbWV0ZXJzLmlkID0gcGFyYW1ldGVycy5pZCB8fCBcIk1vbnR5LUhhbGxcIlxyXG5cdHZhciBudW1Eb29ycyA9IHBhcmFtZXRlcnMubnVtRG9vcnMgfHwgMztcclxuXHR2YXIgbnVtUHJpemVzID0gcGFyYW1ldGVycy5udW1Qcml6ZXMgfHwgMTtcclxuXHR2YXIgbnVtUmV2ZWFscyA9IHBhcmFtZXRlcnMubnVtUmV2ZWFscyB8fCAxO1xyXG5cdHZhciBwcml6ZSA9IHBhcmFtZXRlcnMucHJpemUgfHwgNTtcclxuXHJcblx0Ly8gQWxsb3cgYXJyYXkgb3Igc2luZ2xlIHBsYXllclxyXG5cdGlmIChBcnJheS5pc0FycmF5KHBsYXllcikpIHBsYXllciA9IHBsYXllclswXVxyXG5cclxuXHQvL0dlbmVyYXRlIGxpc3Qgb2YgZG9vcnNcclxuXHR2YXIgZG9vcnMgPSBbXTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG51bURvb3JzOyBpKyspIHtcclxuXHRcdGRvb3JzLnB1c2goXCJEb29yIFwiICsgaS50b1N0cmluZygpKVxyXG5cdH1cclxuXHJcblx0dmFyIENob29zZSA9IENob2ljZShwbGF5ZXIsIGRvb3JzLCB7IGlkOiBcIkNob29zZVwiIH0pO1xyXG5cclxuXHJcblx0dmFyIHByaXplc1xyXG5cdHZhciBzY29yZXMgPSBBcnJheS5hcHBseShudWxsLCBBcnJheShkb29ycy5sZW5ndGgpKS5tYXAoZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gVmFyaWFibGUoMClcclxuXHR9KVxyXG5cclxuXHQvL05lZWQgdG8gc2V0IHRoaXMgaGVyZSBpbiBvcmRlciBmb3Igc2NvcmluZyB0byB3b3JrXHJcblx0dmFyIGRvb3JzMiA9IENvbXBsZXhWYXJpYWJsZShkb29ycy5zbGljZSgpKTtcclxuXHJcblx0dmFyIFJldmVhbCA9IExhbWJkYShmdW5jdGlvbih7IGhpc3RvcnkgfSkge1xyXG5cclxuXHRcdC8vIFJlLWluaXRpYWxpemUgcGF5b2Zmcy5cclxuXHRcdHByaXplcyA9IFtdXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNjb3Jlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRzY29yZXNbaV0uc2V0KDApXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gV2hhdCBkb29yIGRpZCB0aGUgcGxheWVyIG9wZW4/XHJcblx0XHR2YXIgcGxheWVyQ2hvaWNlID0gaGlzdG9yeS5sb2cucXVlcnkoXCIkW2Nob2ljZT0nXCIgKyBDaG9vc2UuaWQoKSArIFwiJ11bLTFdXCIpLnJlc3VsdCAvLyBUT0RPIGRvZXMgdGhpcyB3b3JrP1xyXG5cclxuXHRcdC8vIFNlbGVjdCB3aGljaCBkb29ycyBoYXZlIHByaXplc1xyXG5cdFx0dmFyIHJldmVhbEZyb20gPSBkb29ycy5zbGljZSgpOyAvLyBDb3B5IHRoZSBkb29ycyBsaXN0XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG51bVByaXplczsgaSsrKSB7XHJcblx0XHRcdHZhciBwcml6ZUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcmV2ZWFsRnJvbS5sZW5ndGgpIC8vIFNlbGVjdCBhIGRvb3IgZnJvbSB0aGUgZG9vcnMgY29weVxyXG5cdFx0XHRwcml6ZXMucHVzaChyZXZlYWxGcm9tW3ByaXplSW5kZXhdKSAvLyBBZGQgdGhlIHByaXplIHRvIHRoZSBsaXN0c1xyXG5cdFx0XHRzY29yZXNbcHJpemVJbmRleF0uc2V0KHByaXplKSAvLyBTZXQgcGF5b2ZmcyBhcHByb3ByaWF0ZWx5XHJcblx0XHRcdHJldmVhbEZyb20uc3BsaWNlKHByaXplSW5kZXgsIDEpIC8vIFJlbW92ZSB0aGUgcHJpemVkIGRvb3IgZnJvbSB0aGUgZG9vcnMgY29weSwgc28gdGhhdCB3ZSBkb24ndCBzZWxlY3QgaXQgbW9yZSB0aGFuIG9uY2VcclxuXHRcdH1cclxuXHJcblx0XHQvL1JlbW92ZSBwbGF5ZXIgY2hvaWNlIGZyb20gZG9vcnMgY29weVxyXG5cdFx0dmFyIHBsYXllckNob2ljZUluZGV4ID0gcmV2ZWFsRnJvbS5pbmRleE9mKHBsYXllckNob2ljZSlcclxuXHRcdGlmIChwbGF5ZXJDaG9pY2VJbmRleCA+IC0xKSByZXZlYWxGcm9tLnNwbGljZShwbGF5ZXJDaG9pY2VJbmRleCwgMSlcclxuXHJcblx0XHQvLyBDaG9vc2UgZG9vcnMgdG8gcmV2ZWFsXHJcblx0XHR2YXIgcmV2ZWFsID0gW107XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG51bVJldmVhbHM7IGkrKykge1xyXG5cdFx0XHRyZXZlYWwucHVzaChyZXZlYWxGcm9tW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSkgKiByZXZlYWxGcm9tLmxlbmd0aF0pXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ29weSBkb29ycyBsaXN0IHRvIHNlbmQgb253YXJkLCB0aGVuIHJlbW92ZSB0aGUgcmV2ZWFsZWQgZG9vcnMgZnJvbSBsaXN0XHJcblx0XHRkb29yczIuc2V0KGRvb3JzLnNsaWNlKCkpOyAvLyBOZWVkIHRvIHNldCB0aGlzIGhlcmUgc28gcmV2ZWFsaW5nIHRvIHdvcmtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcmV2ZWFsLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBpbmRleCA9IGRvb3JzMi5pbmRleE9mKHJldmVhbFtpXSlcclxuXHRcdFx0ZG9vcnMyKCkuc3BsaWNlKGluZGV4LCAxKVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXZlYWwubGVuZ3RoID09IDEgPyByZXZlYWxbMF0gOiByZXZlYWw7XHJcblx0fSwgeyBpZDogXCJSZXZlYWxcIiB9KVxyXG5cclxuXHR2YXIgU2Vjb25kQ2hvaWNlID0gQ2hvaWNlKHBsYXllciwgZG9vcnMyLCB7IGlkOiBcIlN0YXktb3ItU3dpdGNoXCIsIHVzZVBheW9mZnM6IHRydWUgfSk7XHJcblx0U2Vjb25kQ2hvaWNlLnNldEFsbFBheW9mZnMoc2NvcmVzKVxyXG5cclxuXHRSZXZlYWwoQ2hvb3NlKVxyXG5cdFNlY29uZENob2ljZShSZXZlYWwpXHJcblxyXG5cdHJldHVybiBTZXF1ZW5jZShDaG9vc2UsIFNlY29uZENob2ljZSwgcGFyYW1ldGVycyk7XHJcbn0sIHtcclxuXHJcblx0c3RyYXRlZ3lMb2FkZXIoKSB7XHJcblx0XHRyZXR1cm4gW3tcclxuXHRcdFx0XHRuYW1lOiBcIkFsd2F5cyBTd2l0Y2hcIixcclxuXHRcdFx0XHRkZXNjcmlwdGlvbjogXCJSYW5kb21seSBzZWxlY3QgYSBkb29yLiBUaGVuLCBhbHdheXMgc3dpdGNoIHRvIGEgZGlmZmVyZW50IG9uZS5cIixcclxuXHJcblx0XHRcdFx0c3RyYXRlZ3k6IGZ1bmN0aW9uIGFsd2F5c1N3aXRjaCgpIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLmRvb3IgPSBudWxsO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuY2hvb3NlID0gZnVuY3Rpb24ob3B0aW9ucywgaW5mb3JtYXRpb24pIHtcclxuXHRcdFx0XHRcdFx0dmFyIGNob2ljZVxyXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5kb29yKSB7XHJcblx0XHRcdFx0XHRcdFx0b3B0aW9ucy5zcGxpY2Uob3B0aW9ucy5pbmRleE9mKHRoaXMuZG9vciksIDEpXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5kb29yID0gbnVsbDtcclxuXHRcdFx0XHRcdFx0XHRjaG9pY2UgPSBvcHRpb25zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG9wdGlvbnMubGVuZ3RoKV1cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRjaG9pY2UgPSBvcHRpb25zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG9wdGlvbnMubGVuZ3RoKV1cclxuXHRcdFx0XHRcdFx0XHR0aGlzLmRvb3IgPSBjaG9pY2VcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIGNob2ljZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdG5hbWU6IFwiQWx3YXlzIFN0YXlcIixcclxuXHRcdFx0XHRkZXNjcmlwdGlvbjogXCJSYW5kb21seSBzZWxlY3QgYSBkb29yLiBUaGVuLCBhbHdheXMgc3RheSB3aXRoIHRoYXQgZG9vci5cIixcclxuXHJcblx0XHRcdFx0c3RyYXRlZ3k6IGZ1bmN0aW9uIGFsd2F5c1N0YXkoKSB7XHJcblx0XHRcdFx0XHR0aGlzLmRvb3IgPSBudWxsO1xyXG5cclxuXHRcdFx0XHRcdC8vVE9ETyBhZGQgc3RyYXRlZ3kgZGVzY3JpcHRpb24gZmVhdHVyZVxyXG5cdFx0XHRcdFx0dGhpcy5jaG9vc2UgPSBmdW5jdGlvbihvcHRpb25zLCBpbmZvcm1hdGlvbikge1xyXG5cdFx0XHRcdFx0XHR2YXIgY2hvaWNlXHJcblx0XHRcdFx0XHRcdGlmICh0aGlzLmRvb3IpIHtcclxuXHRcdFx0XHRcdFx0XHRjaG9pY2UgPSB0aGlzLmRvb3JcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmRvb3IgPSBudWxsO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRjaG9pY2UgPSBvcHRpb25zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG9wdGlvbnMubGVuZ3RoKV1cclxuXHRcdFx0XHRcdFx0XHR0aGlzLmRvb3IgPSBjaG9pY2VcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIGNob2ljZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XVxyXG5cdH1cclxufSlcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTW9udHlIYWxsXHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gYmFzZSBnYW1lXHJcbnZhciBUd29QbGF5ZXJOb3JtYWwgPSByZXF1aXJlKFwiLi9zaW1wbGUtbm9ybWFsXCIpLlR3b1BsYXllck5vcm1hbDtcclxuXHJcbi8vTmFzaEpTIGVuZ2luZSBjb21wb25lbnRzXHJcbnZhciBFbmdpbmUgPSByZXF1aXJlKFwiLi4vbGliL2VuZ2luZVwiKVxyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lV3JhcHBlciB9ID0gRW5naW5lLkJhY2tlbmQuSGVscGVyRnVuY3Rpb25zKFwic3RvY2stZ2FtZXNcIik7XHJcblxyXG4vLyBwbGF5LXRpbWUgbG9naWNcclxudmFyIHsgVmFyaWFibGUsIEV4cHJlc3Npb24gfSA9IEVuZ2luZS5Gcm9udGVuZDtcclxuXHJcblxyXG52YXIgcHJpc29uZXJEaWxlbW1hID0gZ2FtZVdyYXBwZXIoZnVuY3Rpb24ocGxheWVycywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0cGFyYW1ldGVycy5pZCA9IHBhcmFtZXRlcnMuaWQgfHwgXCJQcmlzb25lci1EaWxlbW1hXCI7XHJcblx0dmFyIHBheW9mZnMgPSBwYXJhbWV0ZXJzLnBheW9mZnMgfHwgW1ZhcmlhYmxlKDEpLCBWYXJpYWJsZSgyKSwgVmFyaWFibGUoMyksIFZhcmlhYmxlKDQpXTtcclxuXHJcblxyXG5cdC8vIHNvcnQgbnVtYmVycyBiZWNhdXNlIHRoZSB3cm9uZyBvcmRlciB3b3VsZCBzY3JldyB1cCB0aGUgZ2FtZVxyXG5cdHBheW9mZnMuc29ydCgpXHJcblx0dmFyIHN1Y2tlciA9IHBheW9mZnNbMF1cclxuXHR2YXIgcHVuaXNobWVudCA9IHBheW9mZnNbMV1cclxuXHR2YXIgcmV3YXJkID0gcGF5b2Zmc1syXVxyXG5cdHZhciB0ZW1wdGF0aW9uID0gcGF5b2Zmc1szXVxyXG5cclxuXHJcblx0dmFyIGNob2ljZXMgPSBbXHJcblx0XHRbXCJDb29wZXJhdGVcIiwgXCJEZWZlY3RcIl0sXHJcblx0XHRbXCJDb29wZXJhdGVcIiwgXCJEZWZlY3RcIl1cclxuXHRdO1xyXG5cdHZhciBnYW1lUGF5b2ZmcyA9IFtcclxuXHRcdFtcclxuXHRcdFx0W3Jld2FyZCwgcmV3YXJkXSxcclxuXHRcdFx0W3N1Y2tlciwgdGVtcHRhdGlvbl1cclxuXHRcdF0sXHJcblx0XHRbXHJcblx0XHRcdFt0ZW1wdGF0aW9uLCBzdWNrZXJdLFxyXG5cdFx0XHRbcHVuaXNobWVudCwgcHVuaXNobWVudF1cclxuXHRcdF1cclxuXHRdO1xyXG5cclxuXHRyZXR1cm4gVHdvUGxheWVyTm9ybWFsKHBsYXllcnMsIGNob2ljZXMsIGdhbWVQYXlvZmZzLCBwYXJhbWV0ZXJzKTtcclxufSk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBwcmlzb25lckRpbGVtbWE7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gYmFzZSBnYW1lXHJcbnZhciBTaW1wbGVaZXJvU3VtID0gcmVxdWlyZShcIi4vc2ltcGxlLXplcm8tc3VtXCIpO1xyXG5cclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG4vLyBoZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKVxyXG5cclxuLy8gUGxheS10aW1lIGxvZ2ljXHJcbnZhciB7IEV4cHJlc3Npb24gfSA9IEVuZ2luZS5Gcm9udGVuZFxyXG5cclxuXHJcbi8vIFJvY2stUGFwZXItU2Npc3NvcnNcclxudmFyIFJvY2tQYXBlclNjaXNzb3JzID0gZ2FtZVdyYXBwZXIoZnVuY3Rpb24ocGxheWVycywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0cGFyYW1ldGVycy5pZCA9IHBhcmFtZXRlcnMuaWQgfHwgXCJSb2NrLVBhcGVyLVNjaXNzb3JzXCI7XHJcblx0cGFyYW1ldGVycy5wYXlvZmYgPSBwYXJhbWV0ZXJzLnBheW9mZiB8fCAxO1xyXG5cclxuXHR2YXIgd2luID0gcGFyYW1ldGVycy5wYXlvZmY7XHJcblx0dmFyIGxvc2UgPSBFeHByZXNzaW9uKGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIC1wYXlvZmY7XHJcblx0fSk7XHJcblxyXG5cdHZhciBjaG9pY2VzID0gW1xyXG5cdFx0W1wiUm9ja1wiLCBcIlBhcGVyXCIsIFwiU2Npc3NvcnNcIl0sXHJcblx0XHRbXCJSb2NrXCIsIFwiUGFwZXJcIiwgXCJTY2lzc29yc1wiXVxyXG5cdF07XHJcblx0dmFyIHBheW9mZnMgPSBbXHJcblx0XHRbMCwgbG9zZSwgd2luXSxcclxuXHRcdFt3aW4sIDAsIGxvc2VdLFxyXG5cdFx0W2xvc2UsIHdpbiwgMF1cclxuXHRdO1xyXG5cclxuXHRyZXR1cm4gU2ltcGxlWmVyb1N1bShwbGF5ZXJzLCBjaG9pY2VzLCBwYXlvZmZzLCBwYXJhbWV0ZXJzKTtcclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvY2tQYXBlclNjaXNzb3JzXHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy9OYXNoSlMgRW5naW5lXHJcbnZhciBFbmdpbmUgPSByZXF1aXJlKFwiLi4vbGliL2VuZ2luZVwiKVxyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uXHJcbnZhciB7IHNodWZmbGUgfSA9IEVuZ2luZS5CYWNrZW5kLkhlbHBlckZ1bmN0aW9ucyhcImdlbmVyYWxcIik7XHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKVxyXG5cclxuLy8gbmFzaEpTIGVuZ2luZSBjb21wb25lbnRcclxudmFyIHsgU2VxdWVuY2UsIFNpbXVsdGFuZW91cyB9ID0gRW5naW5lLkZyb250ZW5kLlBsYXlhYmxlcztcclxuXHJcbi8vZm9yIGluZm9ybWF0aW9uIG1lY2hhbmljc1xyXG52YXIgeyBJbmZvcm1hdGlvbiwgSGlzdG9yeSwgUGxheWVyTGlzdCB9ID0gRW5naW5lLkJhY2tlbmQuQ2xhc3NlcztcclxuXHJcblxyXG4vLyBnYW1lR2VuZXJhdG9yIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHdob3NlIGZpcnN0IGFyZ3VtZW50IGlzIGFuIGFycmF5IG9mIHBsYXllcnNcclxudmFyIFJvdW5kUm9iaW4gPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCBnYW1lR2VuZXJhdG9yLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRwYXJhbWV0ZXJzLmlkID0gcGFyYW1ldGVycy5pZCB8fCBcIlJvdW5kLVJvYmluXCI7XHJcblx0cGFyYW1ldGVycy5pbml0aWFsaXplUGxheWVycyA9IHBhcmFtZXRlcnMuaW5pdGlhbGl6ZVBsYXllcnMgJiYgdHJ1ZTtcclxuXHJcblx0Ly8gQ3JlYXRlIGFycmF5IG9mIGVhY2ggY29tYmluYXRpb24gb2YgcGxheWVyc1xyXG5cdHZhciBtYXRjaGVzID0gW107XHJcblxyXG5cdHBsYXllcnMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIxLCBpbmRleDEpIHtcclxuXHRcdGZvciAodmFyIGluZGV4MiA9IDA7IGluZGV4MiA8IGluZGV4MTsgaW5kZXgyKyspIHtcclxuXHRcdFx0bWF0Y2hlcy5wdXNoKFtwbGF5ZXJzW2luZGV4Ml0sIHBsYXllcjFdKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvcHRpb25hbCBwYXJhbWV0ZXIgJ2NvcGllcy4nIFBhc3MgYW4gZXh0cmEgY29weSBvZiBlYWNoIHBsYXllciwgdG8gcGxheSB0aGVtc2VsdmVzXHJcblx0XHRpZiAocGFyYW1ldGVycy5jb3BpZXMpIG1hdGNoZXMucHVzaChbcGFyYW1ldGVycy5jb3BpZXNbaW5kZXgxXSwgcGxheWVyMV0pO1xyXG5cdH0pO1xyXG5cclxuXHQvL3JhbmRvbWl6ZSB0aGUgb3JkZXJcclxuXHRzaHVmZmxlKG1hdGNoZXMpO1xyXG5cclxuXHQvLyBUcmFjayBzY29yZXNcclxuXHR2YXIgc2NvcmVzUmVjb3JkID0gW107XHJcblxyXG5cdC8vXHJcblx0dmFyIGFkZFJvdW5kID0gZnVuY3Rpb24ocGxheWVycywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0XHQvLyBpbmZvcm1hdGlvbiBtZWNoYW5pY3MgYW5kIG90aGVyIHBhcmFtZXRlcnNcclxuXHRcdHZhciBwb3B1bGF0aW9uID0gbmV3IFBsYXllckxpc3QocGxheWVycykuZ2VuZXJhdG9yXHJcblx0XHRwYXJhbWV0ZXJzLmNvbXBhcnRtZW50YWxpemUgPSB7IHBvcHVsYXRpb24gfVxyXG5cdFx0cGFyYW1ldGVycy5pbml0aWFsaXplUGxheWVycyA9IHBvcHVsYXRpb247XHJcblxyXG5cdFx0Ly8gZ2VuZXJhdGUgcm91bmRcclxuXHRcdHZhciByb3VuZCA9IGdhbWVHZW5lcmF0b3IocGxheWVycywgcGFyYW1ldGVycyk7XHJcblxyXG5cdFx0Ly8gdHJhY2sgdGhlIHNjb3Jlc1xyXG5cdFx0dmFyIHJlY29yZFNjb3JlcyA9IExhbWJkYShmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHNjb3JlID0ge31cclxuXHRcdFx0Zm9yIChsZXQgW3N0cmF0ZWd5LCBzY29yZXNdIG9mIE9iamVjdC5lbnRyaWVzKHBvcHVsYXRpb24oKS5zY29yZXNCeVN0cmF0ZWd5KCkpKSB7XHJcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoc2NvcmVzKSkge1xyXG5cdFx0XHRcdFx0aWYgKHNjb3Jlcy5sZW5ndGggPT0gMSkgc2NvcmVzID0gc2NvcmVzWzBdXHJcblx0XHRcdFx0XHRzY29yZVtzdHJhdGVneV0gPSBzY29yZXM7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHNjb3Jlc1JlY29yZC5wdXNoKHNjb3JlKTtcclxuXHJcblx0XHRcdC8vcmV0dXJuIHNjb3JlIGZvciBoaXN0b3J5XHJcblx0XHRcdHJldHVybiBzY29yZTtcclxuXHRcdH0sIHsgaWQ6IFwiUmVjb3JkLVNjb3Jlc1wiIH0pO1xyXG5cclxuXHRcdC8vQ2hhaW4gdG9nZXRoZXJcclxuXHRcdHJlY29yZFNjb3Jlcyhyb3VuZCk7XHJcblxyXG5cdFx0Ly8gcmV0dXJuIGJvdGhcclxuXHRcdHJldHVybiBbcm91bmQsIHJlY29yZFNjb3Jlc1xyXG5cdFx0XHQvLyAsU2VxdWVuY2Uocm91bmQsIHJlY29yZFNjb3JlcykgLy8gVW5jb21tZW50IGZvciBTaW11bHRhbmVvdXMgaW1wbGVtZW50YXRpb25cclxuXHRcdF07XHJcblx0fTtcclxuXHJcblxyXG5cclxuXHQvLyBTZXF1ZW50aWFsIGltcGxlbWVudGF0aW9uXHJcblx0Ly8gbG9hZCB0aGUgZmlyc3QgbWF0Y2ggbWFudWFsbHlcclxuXHR2YXIgW2ZpcnN0Um91bmQsIGZpcnN0UmVjb3JkXSA9IGFkZFJvdW5kKFxyXG5cdFx0bWF0Y2hlcy5zaGlmdCgpLFxyXG5cdFx0cGFyYW1ldGVycy5wYXJhbWV0ZXJzXHJcblx0KTtcclxuXHJcblx0Ly90aGVuIGxvYWQgc3Vic2VxdWVudCBtYXRjaGVzXHJcblx0dmFyIHJlY29yZCA9IGZpcnN0UmVjb3JkO1xyXG5cdHZhciBsYXN0UmVjb3JkLCBsYXN0Um91bmQ7XHJcblxyXG5cdG1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbihtYXRjaCkge1xyXG5cdFx0W2xhc3RSb3VuZCwgbGFzdFJlY29yZF0gPSBhZGRSb3VuZChtYXRjaCwgcGFyYW1ldGVycy5wYXJhbWV0ZXJzKTtcclxuXHJcblx0XHRsYXN0Um91bmQocmVjb3JkKTtcclxuXHRcdHJlY29yZCA9IGxhc3RSZWNvcmQ7XHJcblx0fSk7XHJcblxyXG5cclxuXHRyZXR1cm4gU2VxdWVuY2UoZmlyc3RSb3VuZCwgbGFzdFJlY29yZCwgcGFyYW1ldGVycyk7XHJcblxyXG5cdC8qIC8vIFNpbXVsdGFuZW91cyBpbXBsZW1lbnRhdGlvblxyXG5cdHZhciByb3VuZHMgPSBbXTtcclxuXHRtYXRjaGVzLmZvckVhY2goZnVuY3Rpb24obWF0Y2gpIHtcclxuXHQgIHJvdW5kcy5wdXNoKGFkZFJvdW5kKG1hdGNoLCBwYXJhbWV0ZXJzLmdhbWVQYXJhbWV0ZXJzKVsyXSk7XHJcblx0fSk7XHJcblxyXG5cdHJldHVybiBTaW11bHRhbmVvdXMocm91bmRzLCBwYXJhbWV0ZXJzKTsgKi9cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdW5kUm9iaW47XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy9HYW1lIGVuZ2luZVxyXG52YXIgRW5naW5lID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIilcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpc0Z1bmN0aW9uIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJnZW5lcmFsXCIpXHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKVxyXG5cclxuLy8gUGxheWFibGVzXHJcbnZhciB7IFR1cm4sIENob2ljZSwgUmFuZG9tUGxheWVyQ2hvaWNlIH0gPSBFbmdpbmUuRnJvbnRlbmQuUGxheWFibGVzO1xyXG5cclxuLy9QbGF5LXRpbWUgTG9naWNcclxudmFyIHsgUmFuZG9tVmFyaWFibGUgfSA9IEVuZ2luZS5Gcm9udGVuZFxyXG5cclxudmFyIE5vcm1hbCA9IGdhbWVXcmFwcGVyKGZ1bmN0aW9uKHBsYXllcnMsIGNob2ljZUxpc3RzLCBwYXlvZmZzID0gbnVsbCwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblxyXG5cdFx0Ly9wcm9wb2dhdGUgdGhlIGluZm9ybWF0aW9uIGZpbHRlclxyXG5cdFx0cGFyYW1ldGVycy5wYXJhbWV0ZXJzID8gcGFyYW1ldGVycy5wYXJhbWV0ZXJzLmluZm9ybWF0aW9uRmlsdGVyID0gcGFyYW1ldGVycy5pbmZvcm1hdGlvbkZpbHRlciA6XHJcblx0XHRcdHBhcmFtZXRlcnMucGFyYW1ldGVycyA9IHsgaW5mb3JtYXRpb25GaWx0ZXI6IHBhcmFtZXRlcnMuaW5mb3JtYXRpb25GaWx0ZXIgfVxyXG5cclxuXHRcdC8vIGNvbnN0cnVjdCB0aGUgY2hvaWNlc1xyXG5cdFx0dmFyIGNob2ljZXMgPSBjaG9pY2VMaXN0cy5tYXAoZnVuY3Rpb24obGlzdCwgaW5kZXgpIHtcclxuXHRcdFx0cmV0dXJuIHBsYXllcnMgPT0gXCJyYW5kb21cIiA/IFJhbmRvbVBsYXllckNob2ljZShsaXN0LCBwYXJhbWV0ZXJzLnBhcmFtZXRlcnMpIDogQ2hvaWNlKHBsYXllcnNbaW5kZXhdLFxyXG5cdFx0XHRcdGxpc3QsIHBhcmFtZXRlcnMucGFyYW1ldGVycyk7XHJcblx0XHR9KTtcclxuXHJcblx0XHR2YXIgZ2FtZSA9IFR1cm4oY2hvaWNlcywgcGFyYW1ldGVycyk7XHJcblxyXG5cdFx0aWYgKHBheW9mZnMpIGdhbWUuc2V0QWxsUGF5b2ZmcyhwYXlvZmZzKTtcclxuXHJcblx0XHRyZXR1cm4gZ2FtZTtcclxuXHR9LCB7XHJcblx0XHRxdWVyaWVzOiBbe1xyXG5cdFx0XHRcdHNob3J0Y3V0OiBcIkBOLWNob2ljZXNcIixcclxuXHRcdFx0XHRxdWVyeTogXCIkLnJlc3VsdHN7cGxheWVyOnJlc3VsdH1cIixcclxuXHRcdFx0XHRkZXNjcmlwdGlvbjogXCJOb3JtYWw6IFBsYXllcnMgYW5kIHRoZWlyIGNob2ljZS5cIlxyXG5cdFx0XHR9LFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0c2hvcnRjdXQ6IFwiQE4tcGF5b3V0c1wiLFxyXG5cdFx0XHRcdHF1ZXJ5OiBcIiQucGF5b3V0c1wiLFxyXG5cdFx0XHRcdGRlc2NyaXB0aW9uOiBcIk5vcm1hbDogUGF5b3V0cyBvYmplY3QsIGJ5IHBsYXllci5cIlxyXG5cdFx0XHR9LFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0c2hvcnRjdXQ6IFwiQE4tcGxheWVyc1wiLFxyXG5cdFx0XHRcdHF1ZXJ5OiBcIiQucmVzdWx0cy5wbGF5ZXJcIixcclxuXHRcdFx0XHRkZXNjcmlwdGlvbjogXCJOb3JtYWw6IFdobyBwbGF5ZWQuXCJcclxuXHRcdFx0fVxyXG5cdFx0XSxcclxuXHRcdHN0cmF0ZWd5TG9hZGVyOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIFt7XHJcblx0XHRcdFx0XHRzdHJhdGVneTogZnVuY3Rpb24gY2hvb3NlRmlyc3QoKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuY2hvb3NlID0gZnVuY3Rpb24oY2hvaWNlcywgaW5mb3JtYXRpb24pIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY2hvaWNlc1swXVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0bmFtZTogXCJDaG9vc2UgRmlyc3RcIixcclxuXHRcdFx0XHRcdGRlc2NyaXB0aW9uOiBcIkFsd2F5cyBjaG9vc2UgZmlyc3QgYXZhaWxhYmxlIG9wdGlvbi5cIlxyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHN0cmF0ZWd5OiBmdW5jdGlvbiBjaG9vc2VTZWNvbmQoKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuY2hvb3NlID0gZnVuY3Rpb24oY2hvaWNlcywgaW5mb3JtYXRpb24pIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY2hvaWNlc1sxXVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0bmFtZTogXCJDaG9vc2UgU2Vjb25kXCIsXHJcblx0XHRcdFx0XHRkZXNjcmlwdGlvbjogXCJBbHdheXMgY2hvb3NlIHNlY29uZCBhdmFpbGFibGUgb3B0aW9uLlwiXHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0c3RyYXRlZ3k6IGZ1bmN0aW9uIHJhbmRvbWl6ZShjaG9pY2VzID0gWzAsIDFdKSB7XHJcblx0XHRcdFx0XHRcdC8vIENyZWF0aW5nIGEgbWFwIHdpbGwgbWFrZSBwaWNraW5nIGEgcmFuZG9tIHZhbHVlIGVhc2llclxyXG5cdFx0XHRcdFx0XHRjaG9pY2VzID0gY2hvaWNlcy5tYXAoZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gW2luZGV4LCBpdGVtXVxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0dmFyIGNob2ljZU1hcCA9IG5ldyBNYXAoY2hvaWNlcylcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMuY2hvb3NlID0gZnVuY3Rpb24oY2hvaWNlcywgaW5mb3JtYXRpb24pIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY2hvaWNlc1tjaG9pY2VNYXAuZ2V0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNob2ljZU1hcC5zaXplKSldO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0bmFtZTogXCJSYW5kb21pemVcIixcclxuXHRcdFx0XHRcdGRlc2NyaXB0aW9uOiBcIkNob29zZSByYW5kb21seSBmcm9tIGF2YWlsYWJsZSBvcHRpb25zLlwiXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRdO1xyXG5cdFx0fVxyXG5cdH0gLy8gXHRcdFx0XHRcdFx0XHRcdFx0XHRUT0RPOiB2YWxpZGF0ZSBhbGwgYXJndW1lbnRzXHJcbik7XHJcblxyXG5cclxudmFyIFR3b1BsYXllck5vcm1hbCA9IGdhbWVXcmFwcGVyKGZ1bmN0aW9uKHBsYXllcnMsIGNob2ljZXMsIHBheW9mZnMgPSBudWxsLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHJcblx0Ly8gSW5mb3JtYXRpb24gbWVjaGFuaWNzLi4gVGhlcmUgYXJlIG9ubHkgdHdvIHBsYXllcnMsIHNvIHdlIGNhbiBoYXZlIGEgJ21lJyBhbmQgJ29wcG9uZW50JyBlbnRyeS5cclxuXHQvLyBJZiB1c2VyIHN1cHBsaWVkIGFuIGluZm9ybWF0aW9uIGZpbHRlciwgd3JhcCB0aGF0IGZpbHRlciBpbiBvdXJzLlxyXG5cdHZhciB7IGluZm9ybWF0aW9uRmlsdGVyIH0gPSBwYXJhbWV0ZXJzO1xyXG5cdGlmICghaXNGdW5jdGlvbihpbmZvcm1hdGlvbkZpbHRlcikpIGluZm9ybWF0aW9uRmlsdGVyID0gbnVsbDtcclxuXHJcblx0Ly8gV3JhcCB0aGUgdXNlcidzIGZpbHRlclxyXG5cdHZhciB3cmFwcGVkRmlsdGVyID0gZnVuY3Rpb24oaW5mb3JtYXRpb24pIHtcclxuXHRcdC8vIEZpZ3VyZSBvdXQgd2hvIEkgYW0gYW5kIHdobyB0aGUgb3Bwb25lbnQgaXNcclxuXHRcdHZhciBtZSA9IGluZm9ybWF0aW9uLm1lLmlkXHJcblx0XHR2YXIgcGxheWVycyA9IFtpbmZvcm1hdGlvbi50dXJuLmNob2ljZXNbMF0uY2hvaWNlLnBsYXllciwgaW5mb3JtYXRpb24udHVybi5jaG9pY2VzWzFdLmNob2ljZS5wbGF5ZXJdXHJcblx0XHR2YXIgb3Bwb25lbnQgPSBwbGF5ZXJzLnNwbGljZShwbGF5ZXJzLmluZGV4T2YobWUpLCAxKSAmJiBwbGF5ZXJzWzBdO1xyXG5cclxuXHRcdC8vIGFkZCBlbnRyeSBmb3Igb3Bwb25lbnRcclxuXHRcdHZhciBvcHBvbmVudERldGFpbCA9IGluZm9ybWF0aW9uLnBvcHVsYXRpb24uZmlsdGVyKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRyZXR1cm4gKHBsYXllci5pZCA9PSBvcHBvbmVudClcclxuXHRcdH0pWzBdO1xyXG5cdFx0aW5mb3JtYXRpb24ub3Bwb25lbnQgPSBvcHBvbmVudERldGFpbDtcclxuXHJcblx0XHQvLyBydW4gdGhlIHVzZXIncyBpbmZvcm1hdGlvbiBmaWx0ZXJcclxuXHRcdGlmIChpbmZvcm1hdGlvbkZpbHRlcikgaW5mb3JtYXRpb24gPSBpbmZvcm1hdGlvbkZpbHRlcihpbmZvcm1hdGlvbik7XHJcblxyXG5cdFx0cmV0dXJuIGluZm9ybWF0aW9uO1xyXG5cdH1cclxuXHJcblx0Ly8gUGFzcyB0aGUgaW5mb3JtYXRpb24gZmlsdGVyXHJcblx0cGFyYW1ldGVycy5pbmZvcm1hdGlvbkZpbHRlciA9IHdyYXBwZWRGaWx0ZXJcclxuXHJcblx0cmV0dXJuIE5vcm1hbChwbGF5ZXJzLCBjaG9pY2VzLCBwYXlvZmZzLCBwYXJhbWV0ZXJzKVxyXG59KTsgLy9cdFx0XHRcdCBcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFRPRE86IG1heSB3YW50IHRvIHZhbGlkYXRlIGFyZ3VtZW50cyBoZXJlIHRvb1xyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgVHdvUGxheWVyTm9ybWFsLCBOb3JtYWwgfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBiYXNlIGdhbWVcclxudmFyIFR3b1BsYXllck5vcm1hbCA9IHJlcXVpcmUoXCIuL3NpbXBsZS1ub3JtYWxcIikuVHdvUGxheWVyTm9ybWFsO1xyXG5cclxuLy8gTmFzaEpTIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG4vLyBHYW1lIHN0YXRlIGNvbnRyb2xsZXJcclxudmFyIHsgcmVnaXN0cnkgfSA9IEVuZ2luZS5CYWNrZW5kLlN0YXRlXHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKTtcclxuXHJcbi8vIFBsYXktdGltZSBsb2dpY1xyXG52YXIgeyBWYXJpYWJsZSwgRXhwcmVzc2lvbiB9ID0gRW5naW5lLkZyb250ZW5kO1xyXG5cclxuLyogYmVhdXRpZnkgcHJlc2VydmU6c3RhcnQgKi9cclxudmFyIFNpbXBsZVplcm9TdW0gPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCBjaG9pY2VzLCBwYXlvZmZzID0gW1swLCAwXSxcdFswLCAwXV0sIHBhcmFtZXRlcnM9e30pIHtcclxuLyogYmVhdXRpZnkgcHJlc2VydmU6ZW5kICovXHJcblxyXG5cdHZhciBnYW1lID0gVHdvUGxheWVyTm9ybWFsKHBsYXllcnMsIGNob2ljZXMsIG51bGwsIHBhcmFtZXRlcnMpXHJcblxyXG5cdHZhciBlO1xyXG5cclxuXHRjaG9pY2VzWzBdLmZvckVhY2goZnVuY3Rpb24oY2hvaWNlMCwgaW5kZXgwKSB7XHJcblx0XHRjaG9pY2VzWzFdLmZvckVhY2goZnVuY3Rpb24oY2hvaWNlMSwgaW5kZXgxKSB7XHJcblxyXG5cdFx0XHQvLyBTZXQgZXhwcmVzc2lvblxyXG5cdFx0XHRlID0gRXhwcmVzc2lvbihmdW5jdGlvbigpIHtcclxuXHRcdFx0XHQvL1JldHVybiB0aGUgbmVnYXRpdmUgcGF5b2ZmLCBvciB6ZXJvXHJcblx0XHRcdFx0cmV0dXJuICgwIC0gcmVnaXN0cnkudHVybnNbZ2FtZS5pZCgpXS5wYXlvZmZzSW1wbGljaXRbY2hvaWNlMF1bY2hvaWNlMV1bMF0gfHwgMCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly9TZXQgcGF5b2Zmc1xyXG5cdFx0XHRnYW1lW2Nob2ljZTBdW2Nob2ljZTFdKFtwYXlvZmZzW2luZGV4MF1baW5kZXgxXSwgZV0pO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblxyXG5cdHJldHVybiBnYW1lO1xyXG59KTsgLy9cdFx0XHRcdFx0VE9ETzogdmFsaWRhdGUgYXJndW1lbnRzXHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2ltcGxlWmVyb1N1bTtcclxuIl19
