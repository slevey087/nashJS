(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":3}],3:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],4:[function(require,module,exports){
//Main module code
var NashJS = require('./lib/engine').Frontend;

//Stock-games
NashJS.StockGames = require('./stock-games');


module.exports = NashJS;

},{"./lib/engine":6,"./stock-games":78}],5:[function(require,module,exports){
({
	Player,
	_Player,
	gamePopulation,
	Population,
	PlayerList,
	registerStrategy,
	Strategies,
	strategyLoader,
	_expose,
	registry,
	Variable,
	Expression,
	RandomVariable,
	ComplexVariable,
	History,
	excludedPlayers,
	startREPL,
	nhistory,
	Information,
	PerfectInformation,
	PluginManager
} = require("../index"));
({
	Choice,
	Turn,
	Sequence,
	Consecutive,
	Loop,
	StochasticLoop,
	HaltIf,
	StochasticHalt,
	Lambda,
	RandomPlayerChoice,
	PopulationDynamics,
	Simultaneous
} = require("../index").Playables);
StockGames = require("../index").StockGames;



p1 = Player();
p2 = Player();
p3 = Player();
ipd = StockGames["Iterated Prisoner's Dilemma"]([p1, p2], 20)
/*
StockGames["Prisoner's Dilemma"]([p1, p2])

p1.assign("chooseFirst")
p2.assign("randomize");

p3 = Player();
p3.assign("chooseSecond");
p4 = Player();
p4.assign("randomize")

c1 = Choice(p1, ["cooperate", "defect"]);
//c1['left'](5) ;
//c1['right'](2);
c2 = Choice(p2, ["Cooperate", "Defect"]);
//c2['up'](1);
//c2['down'](7);

t2 = Turn([c1, c2]);
t3 = Turn([c1, c2]);
t4 = Turn([c1, c2]);
t5 = Turn([c1, c2]);
s1 = Simultaneous([t2, t3, t4, t5])

c = Consecutive([
	Turn([c1, c2]),
	Turn([c2, c1]),
	Choice(p1, ["cooperate", "defect"]),
	Lambda(function() { console.log("hi") }),
	HaltIf(function() { return true })
])

c3 = RandomPlayerChoice(["cooperate", "defect"]);
c4 = RandomPlayerChoice(["Cooperate", "Defect"]);

t1 = Turn([c3, c4]);

v1 = new Variable(3);

t1.defect.Defect([2, 2]);
t1.defect.Cooperate([4, 1]);
t1.cooperate.Defect([1, 4]);
t1.cooperate.Cooperate([v1, v1]);

L1 = Lambda(function() {
	v1.set(v1 + 1);
});

pd1 = PopulationDynamics(1.5, 1);

h2 = HaltIf(function() {
	return Population().onlyAlive().length == 0;
});

L1(t1);
pd1(L1);
h2(pd1);

//s1 = Sequence(t1, h2);

//l1 = Loop(s1, 10, { logContinue: true });

//console.log(_expose(t1).next)
//console.log(_expose(t1).next.cooperate.Cooperate)

h2 = HaltIf(function() {
	return Population().onlyAlive().length == 0;
});

L2 = Lambda(function() {
	p1.kill();
});

t2(L2);

generatePopulation = function() {
	for (i = 0; i < 30; i++) {
		Player({ assign: "chooseFirst" });
	}
	for (i = 0; i < 30; i++) {
		Player({ assign: "chooseSecond" });
	}
};

function gameGenerator() {
	var t = Turn([
		RandomPlayerChoice(["cooperate", "defect"]),
		RandomPlayerChoice(["Cooperate", "Defect"])
	]);

	t.defect.Defect([2, 2]);
	t.defect.Cooperate([4, 1]);
	t.cooperate.Defect([1, 4]);
	t.cooperate.Cooperate([3, 3]);

	return t;
}
//
//
//

//CE = StockGames["Cultural Evolution"](gameGenerator, 1, {generatePopulation});

//n = StockGames["Two-Player Normal"](p1,p2,[["left","right"],["up","down"]]);
//pd1 = StockGames["Prisoner's Dilemma"]([p1, p2]);
//pd2 = StockGames["Prisoner's Dilemma"]([p3, p4]);

//s = Simultaneous([pd1, pd2])

v2 = Variable(1);

//n = StockGames["Simple Zero-Sum"](p1,p2,[["left","right"],["up","down"]], [[v2,2],[3,4]]);

//rpc = StockGames["Rock-Paper-Scissors"]([p1, p2]);
//t = StockGames["Axelrod Tournament"];
//t = StockGames["Iterated Prisoner's Dilemma"]([p1, p2]);
//The code below is to run the repl for testing purposes.
//var toRepl = {_expose, registry,Player,Choice,Turn,Sequence,Loop,StochasticLoop,HaltIf, StochasticHalt, Lambda, p1,c1,c2,t1};
//startREPL(toRepl);
*/

},{"../index":4}],6:[function(require,module,exports){
"use strict";

// Start plug-in manager
var PluginManager = require("./plugin-manager")
PluginManager.start(function() {})


//Logging
var log = require("./logger");
//log.useWinston();  				Winston doesn't work with browserify, so this is a shim. Uncomment to use Winston.
log.setLevel("debug");
log("info", "Starting NashJS");


//Game state controllers
var { registry, idCounters } = require('./state');


// History
var { gameHistory, userGameHistory, History, UserHistory } = require('./history');


//Players
var { _Player, Player } = require('./player');
registry._addType_("players");
idCounters._addType_("player");


//Population
var { gamePopulation, Population, PlayerList, UserPlayerList } = require('./population');


//Information mechanics
var { Information, PerfectInformation } = require("./information");


//Playables
var { playableClasses, playableInterfaces } = require('./playables/')
for (var _class in playableClasses) {
	registry._addType_(playableClasses[_class].registryName);
	idCounters._addType_(playableClasses[_class].counterName);
}

//Symbolic Logic
var {
	variablePrototype,
	Variable,
	expressionPrototype,
	Expression,
	RandomVariable,
	ComplexVariable
} = require("./logic");


//Strategies
registry._addType_("strategies");
idCounters._addType_("strategy");

var { registerStrategy, registerStrategyObject, Strategies } = require('./strategy');
var { loadStrategy, loadStrategyFolder } = require('./strategy-loader');


// Helper function loader
var HelperFunctions = require('./helperFunctions');


//THIS FUNCTION IS ONLY FOR DEBUGGING. REMOVE IT FROM MODULE EXPORTS WHEN PUBLISHING
function Expose(interfacePlayable) {
	return registry.playables[interfacePlayable.id()];
}


function startREPL(toREPL) {
	var repl = require("repl");

	var replServer = repl.start({
		prompt: "Nash >> "
	});

	Object.assign(replServer.context, toREPL);
}



var Engine = {
	Frontend: {
		Player,
		_Player, //REMOVE THIS LINE WHEN PUBLISHING
		gamePopulation, //REMOVE THIS LINE WHEN PUBLISHING
		'PlayerList': UserPlayerList,
		Population,
		Information, //REMOVE THIS LINE WHEN PUBLISHING
		PerfectInformation, //REMOVE THIS LINE WHEN PUBLISHING
		'Playables': playableInterfaces,
		registerStrategy,
		registerStrategyObject,
		Strategies,
		loadStrategy,
		loadStrategyFolder,
		History: userGameHistory,
		Expose, //REMOVE THIS LINE WHEN PUBLISHING
		registry, //REMOVE THIS LINE WHEN PUBLISHING
		startREPL, //Should this line be removed when publishing?
		Variable,
		Expression,
		RandomVariable,
		ComplexVariable,
		PluginManager //REMOVE THIS LINE WHEN PUBLISHING
	},

	Backend: {
		logger: log,
		State: { registry, idCounters, gameHistory, gamePopulation, PerfectInformation },
		Classes: {
			Player: _Player,
			History,
			UserHistory,
			PlayerList,
			UserPlayerList,
			Information,
			PlayableClasses: { playableClasses },
			variablePrototype,
			expressionPrototype
		},
		HelperFunctions,
		PluginManager,
		Expose
	}
}

module.exports = Engine;

},{"./helperFunctions":8,"./history":25,"./information":26,"./logger":27,"./logic":28,"./playables/":32,"./player":43,"./plugin-manager":45,"./population":49,"./state":50,"./strategy":52,"./strategy-loader":51,"repl":1}],7:[function(require,module,exports){
var general = {
	//Check if variable is an Object
	isObject(a) {
		return !!a && a.constructor === Object;
	},

	//What do you think?
	isFunction(a) {
		return typeof a === "function";
	},

	//Provide a function, a context ('this'), and an argument array.
	//Returns a function that can be called.
	applyBind(func, that, argArray) {
		return func.bind.apply(func, [that].concat(argArray));
	},

	//Wraps a function to ensure it only gets called one time.
	once(fn, context) {
		var result;

		return function() {
			if (fn) {
				result = fn.apply(context || this, arguments);
				fn = null;
			}

			return result;
		};
	},

	// Randomly re-order array
	shuffle(array) {
		var currentIndex = array.length,
			temporaryValue,
			randomIndex;

		// While there remain elements to shuffle...
		while (0 !== currentIndex) {
			// Pick a remaining element...
			randomIndex = Math.floor(Math.random() * currentIndex);
			currentIndex -= 1;

			// And swap it with the current element.
			temporaryValue = array[currentIndex];
			array[currentIndex] = array[randomIndex];
			array[randomIndex] = temporaryValue;
		}

		return array;
	}
};

module.exports = general;

},{}],8:[function(require,module,exports){
"use strict";

var log = require("../logger");

log("debug", "helperFunctions-index: Loading helper functions loader.");

/*
var general  = require('./general');
var player   = require('./player');
var playable = require('./playable');
var turn 	 = require('./turn');
var state 	 = require('./state'); 
*/

function loader(file) {
	return require("./" + file + ".js");
}

module.exports = loader;
//module.exports = {general, player, playable, turn, state};

// Hack to compile Glob files (in browserify). Don´t call this function!
(function() {
	require('./general.js');require('./index.js');require('./logic.js');require('./playable.js');require('./player.js');require('./state.js');require('./stock-games.js');require('./tournament.js');require('./turn.js');
});

},{"../logger":27,"./general.js":7,"./index.js":8,"./logic.js":9,"./playable.js":10,"./player.js":11,"./state.js":12,"./stock-games.js":13,"./tournament.js":14,"./turn.js":15}],9:[function(require,module,exports){
"use strict";

var logic = {

	// Check to see if object is Variable/Expression or not. Returns true/false
	isLogic(logic) {

		if (logic instanceof Function && logic == logic * 1) return true
		else return false;
	}
};

module.exports = logic;

},{}],10:[function(require,module,exports){
"use strict";

var { SynchronousPromise } = require('synchronous-promise');

//Game state controllers
var { registry } = require('../state');

var playable = {
	// Generates the function that gets returned when a Playable is called, which can then be called to chain playables together.
	chainerGenerator(externalObj, internalObj) {
		externalObj = this;
		return function(source) {
			var previousPlayable, path;

			//TODO: verify that source is the right type

			return SynchronousPromise.all([function() {
				if (source instanceof Promise || source instanceof SynchronousPromise) {
					source.then(function(result) {
						previousPlayable = registry.playables[result.playable.id()];
						path = result.path
						return SynchronousPromise.resolve();
					});
				}
				return SynchronousPromise.resolve()
			}(), function() {
				if (!(source instanceof Promise || source instanceof SynchronousPromise)) {
					previousPlayable = registry.playables[source.id()];
					path = source.path;
				}
				return SynchronousPromise.resolve();
			}()]).then(function(result) {

				if (path == "all") previousPlayable.addNext(internalObj);
				else {

					outcomeTreeGetValue(previousPlayable.next, path).push(internalObj);
				}

				//previousPlayable.next[selected].push(_choice);

				return SynchronousPromise.resolve({
					'playable': externalObj,
					path: "all"
				});
			});
		};
	},


	//Use to set every value of an outcome tree
	outcomeTreeAddAll(tree, value) {

		//If it's an array, then we're already done.
		if (Array.isArray(tree)) {
			tree.push(value); //Use push here because this will be a unique array
		} else {
			var recurse = function(obj, val) {

				for (var keys in obj) {

					//If no keys left to traverse, then assign value. If not, recurse.
					if (Array.isArray(obj[keys])) {
						obj[keys] = obj[keys].slice().concat(val); //Use slice-concat here because this might not be a unique array (the creation process duplicates them)
					} else recurse(obj[keys], val);

				}
			};
			recurse(tree, value);
		}
	},


	//Traverse an outcome tree to obtain the value for a desired key-set
	//Argument one is a nested object, while argument 2 is an array of keys for the object, 1 layer at a time.
	outcomeTreeGetValue(tree, selector) {

		//Find the next item in the chain associated with the resultant outcome
		for (var i = 0, len = selector.length; i < len; i++) {
			tree = tree[selector[i]];
		}

		return tree;
	},


	//Traverse an outcome tree to set the value for a desired key-set
	//Argument one is a nested object, while argument 2 is an array of keys for the object, 1 layer at a time.
	outcomeTreeSetValue(tree, selector, value) {

		//Find the next item in the chain associated with the resultant outcome
		for (var i = 0, len = selector.length - 1; i < len; i++) {
			tree = tree[selector[i]];
		}

		return tree[selector[i]] = value;
	}
}



module.exports = playable;

},{"../state":50,"synchronous-promise":71}],11:[function(require,module,exports){
"use strict";

//  Game state
var { registry } = require("../state");

// helper function
var { isFunction } = require("./general");

// Player claass
var { _Player } = require("../player");

// Population
var { gamePopulation } = require("../population")

// Plugins
var PluginManager = require("../plugin-manager/")

var player = {

	//reset all players. Recreate from class, re-assign strategy, loop through objects that reference player to set new reference. result argument is only for pass-through.
	reinitializePlayers(population = "all", result = null) {
		return Promise.resolve().then(function() {
			var oldPlayer, strategy, strategyArgs, parameters;

			// if no population is supplied, fetch everybody
			if (population === "all") population = Object.keys(registry.players)
			else(population = population.ids())

			//Redefine each player
			for (var i = 0; i < population.length; i++) {
				var player = population[i];

				oldPlayer = registry.players[player];
				strategy = oldPlayer.strategy ? oldPlayer.strategy._id : null;
				strategyArgs = strategy ? oldPlayer.strategy._args : [];
				parameters = {}; //TODO: when adding player parameters, be sure they're included here

				registry.players[player] = new _Player(oldPlayer.id, parameters);
				registry.players[player].interface = oldPlayer.interface;
				strategy && registry.players[player].assign(strategy, ...strategyArgs);

				// Plugin, to alter players in re-initialization
				PluginManager.run("player-reinitialize", registry.players[player]);
			}

			//For each choice, recreate player references
			for (var choice in registry.choices) {
				if (registry.choices[choice].player)
					registry.choices[choice].player = registry.players[registry.choices[choice].player.id];
			}

			return Promise.resolve(result);
		});
	}
};

module.exports = player;

},{"../player":43,"../plugin-manager/":45,"../population":49,"../state":50,"./general":7}],12:[function(require,module,exports){
"use strict";

var log = require('../logger');

// State variables
var {idCounters, registry} = require('../state');

var state = {
	
	//Handle ID setting for all objects that get stored in the registry
	idHandler: function idHandler(id, type, recursing=false){
		//Assign id
		
		idCounters[type]++;
		var counter = idCounters[type];
		
		if (!id) {
			return type + counter.toString();
		}
		else {
			
			// Check that id isn't taken. If it is, construct a new one.
			
			//Construct list of all objects by extracting all registry entries
			var items = []
			Object.keys(registry).forEach(function(reg){items.push.apply(items, Object.keys(registry[reg]))})
			
			// if id is already taken, generate a new one by adding a number at the end.
			if (items.indexOf(id) > -1) {
				
				var match, oldNum, exp, newId;
				var oldId = id;
				
				do {
					// This finds a number at the end, and increments it, or starts with 1 if there wasn't one.
					match = /\d+$/.exec(id);
					oldNum = match ? match[0] : "";
					exp = new RegExp(oldNum + "$");
					id = id.replace(exp, Number(oldNum) + 1)
				
				}	
				while (items.indexOf(id) >-1)
				
				// Log warning
				log("warn", "ID " + oldId + " is taken. Using instead " + id);
			}
			
			return id
		}
	}
};

module.exports = state;
},{"../logger":27,"../state":50}],13:[function(require,module,exports){
"use strict";

// Strategy registration
var { registerStrategyObject } = require("../engine").Frontend;

// Helper functions
var { isFunction, once } = require("./general");

//External dependency
var esprima = require("esprima");


// For handling queries
var { registry } = require("../engine").Backend.State
var { idHandler } = require("./state")

var registerQueryObject = function(queryObject, gameName) {
	// If there are multiple queries, recurse
	if (Array.isArray(queryObject)) return queryObject.map(function(query) {
		return registerQueryObject(query)
	});

	var { name, query, description = "No description given." } = queryObject;
	// Enforce naming convention, first character '@'
	if (name[0] != "@") name = "@".concat(name)

	// Check for duplicates. Abort if so, but return the data for display purposes.
	if (registry.queries[name] && registry.queries[name].query == query &&
		registry.queries[name].description == description)
		return { name, description };

	// assign id and add to registry
	var id = idHandler(name, "query")
	registry.queries[id] = { query, description }

	//return the data for display purposes
	return { id, description }
}



var stockGames = {
	// utility function to create two ways to call a game, either with all the arguments, or curried, where the returned function takes players and parameters
	// The combineParameters setting will
	gameWrapper(game, {
		argumentValidator = function() { return true; },
		combineParameters = true,
		gameDescription = "No description given.",
		strategyLoader = null,
		queryLoader = null
	} = {}) {

		var generate;

		// If there's a strategy loader, make sure it only runs once
		var loadStrategies
		if (isFunction(strategyLoader)) loadStrategies = once(function() {
			return registerStrategyObject(strategyLoader());
		});
		else loadStrategies = function() {}

		// If there's a query loader, make sure it only runs once
		var loadQueries, queries
		if (isFunction(queryLoader)) loadQueries = once(function() {
			return registerQueryObject(queryLoader());
		});
		else loadQueries = function() {}

		// run the game. Optionally, validate the arguments and load strageies first
		generate = function(...args) {
			var result = argumentValidator(...args)
			if (result === true) {
				loadStrategies();
				queries = loadQueries();
				return game(...args);
			} else throw new Error(result);
		}

		// creates a wrapper around the game, which accepts the first argument (players) and last argument (parameters), and passes it forward.
		// If combineParameters is set to true, then the second argument of the returned function will get merged with the last argument
		// given when generator is called.
		generate.createGenerator = function(...args) {

			var gameCode = esprima.parseScript("(" + game.toString() + ")")

			var gameArgs = gameCode.body[0].expression.params
			var lastArg = gameArgs[gameArgs.length - 1]

			var originalParameters
			if ((lastArg.name && lastArg.name.toLowerCase() === "parameters") || lastArg.type === "ObjectPattern" ||
				(lastArg.type == "AssignmentPattern" && lastArg.left.type == "ObjectPattern")) {
				// Check that the game arguments and createGenerator arguments are the correct lengths. createGenerator should be
				// 1 less than game, because players is omitted.
				// TODO: use esprima to allow players to be anywhere in the game definition (or even omitted) rather than first
				if (args.length == gameArgs.length - 1) originalParameters = args.pop();
			}


			return function(players, parameters = {}) {

				// If combining parameters, merge and remove from arguments
				if (combineParameters && originalParameters) parameters = Object.assign({}, originalParameters,
					parameters)

				return generate(players, ...args, parameters)
			}
		}

		// Allow for game description feature
		generate.description = function() {
			return gameDescription;
		};

		// Display any queries
		generate.queries = function() {
			return queries;
		}

		return generate;
	}


}

module.exports = stockGames;

},{"../engine":6,"./general":7,"./state":12,"esprima":59}],14:[function(require,module,exports){
"use strict";

// Strategies
var { Strategies } = require("../strategy");

// Players
var { Player } = require("../player");

module.exports = {
	// Create a player for each available strategy
	generatePopulation() {
		var players = [];

		Strategies().forEach(function(strategy) {
			players.push(Player({ assign: strategy }));
		});

		return players;
	}
};

},{"../player":43,"../strategy":52}],15:[function(require,module,exports){
"use strict";

var {SynchronousPromise} = require('synchronous-promise');

var turn = {
	
	//Recurse through the options in input, and write val to output. 
	recurse : function recurse(input, output, val, valGenerator=function(){}, path=[]){
		return SynchronousPromise.resolve(path).then(function(path){
			
			//Since we slice the array each time, if there are no more entries left then we're done with this branch.
			if (input.length == 0) return SynchronousPromise.resolve(path)
			
			
			//Among all values from the array
			return SynchronousPromise.all(input[0].map(function(item){
				var value;
				var splitPath = path.slice(0).concat(item);
				
				//If there are more items to iterate over, include them in the output then recurse.
				//If not, put in the new value.
				if (input.length == 1) {
					
					//If val is a function, wrap it in a function that will get supplied an argument with where we are				
					if (typeof val == "function") {
						value = function(){	
							var args = [splitPath].concat(Array.prototype.slice.call(arguments));
							return val.apply(null, args);
						};
					}
					else value = val || valGenerator(splitPath);
					
					output[item] = value;
				}
				else output[item] = {};
				
				
				return recurse(input.slice(1),output[item], val, valGenerator, splitPath);
			}));		
		});
	}
};


module.exports = turn;
},{"synchronous-promise":71}],16:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],17:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"../logger":27,"./general.js":16,"./index.js":17,"./logic.js":18,"./playable.js":19,"./player.js":20,"./state.js":21,"./stock-games.js":22,"./tournament.js":23,"./turn.js":24,"dup":8}],18:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"dup":9}],19:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"../state":50,"dup":10,"synchronous-promise":71}],20:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"../player":43,"../plugin-manager/":45,"../population":49,"../state":50,"./general":16,"dup":11}],21:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"../logger":27,"../state":50,"dup":12}],22:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"../engine":6,"./general":16,"./state":21,"dup":13,"esprima":59}],23:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"../player":43,"../strategy":52,"dup":14}],24:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"synchronous-promise":71}],25:[function(require,module,exports){
"use strict";

//External dependency
var jsonata = require("jsonata");


var { isObject, isFunction } = require("./helperfunctions")("general");

//Extension of array to handle history lists.
function History(...args) {
	if (Array.isArray(args[0])) args = args[0];

	Object.setPrototypeOf(args, History.prototype);

	args.log = args.slice();
	args.log.tree = args;
	Object.setPrototypeOf(args.log, History.prototype);

	args.scores = [];
	args.scores.tree = args;
	Object.setPrototypeOf(args.scores, History.prototype);

	return args;
}

History.prototype = Object.create(Array.prototype);
History.prototype.constructor = History;

//To add entry
History.prototype.add = function(entry) {
	//Add to history and to log
	this.push(entry);
	if (this.log) this.log.push(entry);

	//Cycle up the parent tree, add to each log
	var check = this;
	if (check.tree instanceof History && check.tree.parent instanceof History) {
		check.tree.parent.log.add(entry);
	}
	if (check.parent instanceof History) {
		check.parent.log.add(entry);
	}

	//If we're being called fr

	return this;
};

//To add entry without logging (for playables that would like the tree history
//to be structured differently than the log history.
History.prototype.addNoLog = function(entry) {
	this.push(entry);
	return this;
};


History.prototype.addScores = function(entry) {
	//Add to history
	this.scores.push(entry);

	//Cycle up the parent tree, add to each log
	var check = this;
	if (check.parent instanceof History) {
		check.parent.addScores(entry);
	}



	return this;
};


//A temporary History that can be merged back in later. The child and parent are linked until .orphan() is called.
History.prototype.child = function(parent = this) {
	var h = new History();
	h.parent = parent;
	return h;
};

//Same as .child except includes prior parent history when .print() is called.
History.prototype.childWithContent = function(parent = this) {
	var storedLog = parent.slice();
	var storedScores = parent.slice();

	var h = new History();


	h.log.print = function() {
		History.prototype.print.call(storedLog.concat(h.log))
	}
	h.scores.print = function() {
		History.prototype.print.call(storedScores.concat(h.scores))
	}

	h.parent = parent;
	return h;
};

//This severs the link between the temporary history and its parent. Use this when merging composite entries.
History.prototype.orphan = function() {
	delete this.parent;
	delete this.log;
	delete this.scores;
	return this;
};

//Clear history
History.prototype.clearHistory = function() {
	this.splice(0, this.length);
	if (this.log) this.log.splice(0, this.log.length);
	if (this.scores) this.scores.splice(0, this.scores.length);
	delete this.parent;
};

//End the game.
History.prototype.end = function() {
	this.stop = true;
	if (this.parent) this.parent.end();
};

//Get a particular sort of entry, eg. Turn.
History.prototype.getType = function(type) {
	return new History(
		this.filter(function(entry) {
			//If it's not an object, don't even bother.
			if (!isObject(entry)) return false;

			for (var key in entry) {
				if (key == type) return true;
			}

			return false;
		})
	);
};

History.prototype.mostRecent = function() {
	return this[this.length - 1]
}

//Help read the history in Chrome with less clutter.
History.prototype.print = function() {
	var history = JSON.parse(JSON.stringify(this));
	history.query = History.prototype.query
	return history;
};

History.prototype.query = function(queryString, ...args) {
	// Check for pre-programmed query, designated by '@'
	if (queryString[0] == "@" && registry.queries[queryString]) queryString = registry.queries[queryString].query
	else if (queryString[0] == "@") queryString = queryString.slice(1)

	return jsonata(queryString).evaluate(this, ...args);
}

//Supply an entry, it will check for a property that is a History
History.prototype.recurse = function(type) {
	var list = this;

	return new History(
		list.map(function(entry) {
			for (var key in entry) {
				console.log(key, entry);
				if (entry[key] instanceof History) return entry[key].recurse(type);
				else if (key == type) return entry;
			}
			return null;
		})
	);
};

//Accept a History and return one suitable for the user
function UserHistory(history) {
	var userHistory = history.map(function(entry) {
		return JSON.parse(JSON.stringify(entry));
	});
	if (history.log) {
		userHistory.log = new UserHistory(history.log)
	};
	if (history.scores) {
		userHistory.scores = new UserHistory(history.scores)
	}

	Object.setPrototypeOf(userHistory, UserHistory.prototype);

	//Attach methods from History, wrapped in a function. If those methods return a history,
	//then the function will convert that to a userHistory.
	for (var method in History.prototype) {
		if (isFunction(history[method])) {
			if (method != "constructor")
				userHistory[method] = (function(method) {
					return function() {
						var result = history[method].apply(history, arguments);
						if (result instanceof History) return new UserHistory(result);
						else if (isObject(result))
							return JSON.parse(JSON.stringify(result));
						else return result;
					};
				})(method);
		}
	}

	return userHistory;
}

UserHistory.prototype = Object.create(History.prototype);
UserHistory.prototype.constructor = UserHistory;

var gameHistory = new History(); //TODO: add choice-only history

var userGameHistory = function() {
	return new UserHistory(gameHistory)
}

module.exports = { History, UserHistory, gameHistory, userGameHistory };

},{"./helperfunctions":17,"jsonata":64}],26:[function(require,module,exports){
"use strict";

//When a strategy's .choose() function is called, it is given an information set. That data is a limited map of the internal objects of the game engine, including information on the game history and the players. This is threaded through playables, much like History, so that a parent playable can specify an information set for the playables it calls, or else the default construction will be used. Additionally, the user can provide a filter function, to selectively delete (or add) information elements before they are passed to .choose().

//History functions
var { gameHistory, History } = require('./history');

//Population functions
var { gamePopulation, PlayerList } = require('./population');


function Information(history = gameHistory, population = gamePopulation, { parentHistory = [] } = {}) {
	this.history = history;
	this.population = population;

	// Record any history entries that need to be added to the records
	this.parentHistory = parentHistory.slice(0);

	this.additional = [];

	this.update();
};

//Check the source then cache a hard-copy.
Information.prototype.update = function(player, local) {
	this.infoPopulation = this.population().info();

	this.infoHistory = { log: this.parentHistory.concat(this.history.log).slice(0), scores: this.history.scores
			.slice(0) };

	this.additional = [];

	//Return value. Mimics .deliver()
	var information = {
		history: { log: this.infoHistory.log, scores: this.infoHistory.scores },
		population: this
			.infoPopulation
	}
	if (player) information.me = information.population.get(player.id);
	if (local) Object.assign(information, local);

	return information;
};

//Clone the cached copies and provide them. Will deliver the same thing every time until update is called.
Information.prototype.deliver = function(player, local) {
	var information = {
		history: { log: this.infoHistory.log, scores: this.infoHistory.scores },
		population: this
			.infoPopulation
	}


	if (player) information.me = information.population.get(player.id);
	if (local) Object.assign(information, local);
	if (this.additional) this.additional.forEach(function(entry) { Object.assign(information, entry) });

	return JSON.parse(JSON.stringify(information));
};

//This probably doesn't need to be a separate function, but adding it in case it expands later.
Information.prototype.addAdditional = function(entry = null) {
	if (entry) this.additional.push(entry);
};

//Make copy of this information function, which allows for updating and freezing.
Information.prototype.child = function() {
	var information = new Information(this.history, this.population, { parentHistory: this.parentHistory });

	return information;
};



//Game state, analogous to gameHistory
var PerfectInformation = new Information(gameHistory, gamePopulation);

//Overwrite .deliver(). PerfectInformation is always up-to-date! Thus no need to do a 2nd JSON.stringify.
PerfectInformation.deliver = function(player, local) {

	var information = this.update(player, local);

	if (player) information.me = information.population.get(player.id);
	if (local) Object.assign(information, local);

	return information;
};


module.exports = { Information, PerfectInformation };

},{"./history":25,"./population":49}],27:[function(require,module,exports){
"use strict";



var logger = function() {
	var args = [...arguments];
	var level = (args[0] == "silly" || !args[0]) ? "trace" : args[0];
	var level = level == "warning" ? "warn" : level;
	args.shift();

	logger.logger[level].apply(logger.logger, args);
};

//logger.logger = console;					//TODO clean this all up a lot.

var getLogger = require("loglevel-colored-level-prefix");
var options = { prefix: 'nashJS', level: 'trace' }
logger.logger = getLogger(options)

logger.setLevel = function(level) {
	logger.logger.level = level;
	logger.logger.setLevel(level)
};

/*
logger.useWinston = function(){

	var winston = require('winston');
	var util = require('util');

	winston.level = "warn";

	winston.clear()
	winston.add(winston.transports.Console, {
		level: 'trace',
		prettyPrint:  function ( object ){
			return util.inspect(object);
		},
		colorize: true,
		silent: false,
		timestamp: false
	});

	this.logger = winston;
};
*/

module.exports = logger;

},{"loglevel-colored-level-prefix":65}],28:[function(require,module,exports){
"use strict";

var log = require("./logger");

//Helper functions
var { isFunction } = require("./helperFunctions")("general");

// Extend function, the sneaky way.
var variablePrototype = Object.create(Function.prototype);

variablePrototype.constructor = function(value, { enforceNumber = true } = {}) {
	var variable = this;
	variable.value = enforceNumber ? value * 1 : value;
	variable.enforceNumber = enforceNumber

	this.id = function() {
		return _playable.id;
	}; //TODO: work on ids and registration
};

variablePrototype.call = function() {
	return this.value;
};

variablePrototype.toJSON = function() {
	return this.call();
};
variablePrototype.toString = function() {
	return this.call();
};
variablePrototype.valueOf = function() {
	return this.call();
};

variablePrototype.set = function(newValue) {
	this.value = this.enforceNumber ? newValue * 1 : newValue
	return this.value;
};

//Repurpose the very-similar code for Variable, but re-write certain keys
var expressionPrototype = Object.create(Function.prototype);

expressionPrototype.constructor = function(expression) {
	if (!isFunction(expression)) log("error", "Expression must be a function.");

	var value = expression();
	if (isNaN(value)) log("error", "Expression must return a number"); //TODO: should Expressions/Variables allow strings?

	this.value = expression;

	return value;
};

expressionPrototype.call = function() {
	return this.value() * 1;
};

expressionPrototype.toJSON = function() {
	return this.call();
};
expressionPrototype.toString = function() {
	return this.call();
};
expressionPrototype.valueOf = function() {
	return this.call();
};

expressionPrototype.set = function(newExpression) {
	if (!isFunction(newExpression))
		log("error", "Expression must be a function.");

	var value = newExpression();
	this.value = newExpression;

	return value;
};

//Produces the function that will produce the end result. This part is reusable if you need to do this again.
var classFactory = function(proto) {
	return function() {
		var f = function() {
			return f.call.apply(f, arguments);
		};

		Object.defineProperty(f, "constructor", {
			configurable: true,
			writable: true
		});
		Object.defineProperty(f, "call", {
			writable: true
		});
		Object.defineProperty(f, "toString", {
			writable: true
		});
		Object.defineProperty(f, "valueOf", {
			writable: true
		});

		Object.keys(proto).forEach(function(key) {
			f[key] = proto[key];
		});

		f.constructor.apply(f, arguments);

		return f;
	};
};

var Variable = classFactory(variablePrototype);
var Expression = classFactory(expressionPrototype);
// called as: var instance = Variable();

// A pre-built Expression generator, for generating random numbers
var RandomVariable = function({ lowerbound = 0, upperbound = 10, generator = "uniform" }) {

	if (isFunction(generator)) {
		var expression = Expression(generator);
		expression.generator = generator;
		return expression;

	} else if (generator.toLowerCase() == "uniform") {
		generator = function() {
			return Math.floor(Math.random() * (upperbound - lowerbound + 1) + lowerbound);
		};
		//	TODO: add more distributions here.
	}

	return Expression(generator);
};



// A way to have Variables which are more complicated things, like arrays or obects
var ComplexVariable = function(value) {
	var variable = Variable(value, { enforceNumber: false })

	var excludeList = ["set", "call", "toJSON", "toString", "valueOf"]

	var handler = {
		get(target, key) {
			var prop;
			if (excludeList.indexOf(key) > -1) prop = target[key].bind(target);
			else {
				prop = target.value[key]
				if (isFunction(prop)) prop = prop.bind(target.value)
			}

			return prop
		},
		set(target, key, prop) {
			target.value[key] = prop;
			return true;
		}
	}
	return new Proxy(variable, handler)
}




module.exports = {
	variablePrototype,
	Variable,
	expressionPrototype,
	Expression,
	RandomVariable,
	ComplexVariable
};

},{"./helperFunctions":8,"./logger":27}],29:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Choice");

// External dependency
var { SynchronousPromise } = require("synchronous-promise");

//Game state controllers
var { registry } = require("../state");
var { gameHistory } = require("../history");
var { PerfectInformation } = require("../information");

//Helper functions
var { idHandler } = require("../helperFunctions")("state");
var { isFunction } = require("../helperFunctions")("general");
var { chainerGenerator } = require("../helperFunctions")("playable");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Choice
function _Choice(id, player, options, parameters = {}) {
	_Playable.call(this, id);

	this.next = {};

	this.player = registry.players[player];
	this.options = options;
	this.defaultOption = parameters.defaultOption || options[0]; //TODO: make defaultOption functional
	this.informationFilter = parameters.informationFilter || null;
	this.usePayoffs = parameters.usePayoffs || false;

	registry.choices[id] = this;

	var choice = this;
	this.options.forEach(function(item) {
		choice.next[item] = [];
	});
}

_Choice.prototype = Object.create(_Playable.prototype);
_Choice.prototype.constructor = _Choice;

_Choice.registryName = "choices";
_Choice.counterName = "choice";

_Choice.prototype.play = function({
	usePayoffs = this.usePayoffs,
	history = gameHistory,
	information: rawInformation = PerfectInformation,
	releasePlayer = true,
	informationFilter = this.informationFilter,
	_compileInformation = null
} = {}) {
	var choice = this;

	if (!choice.player.alive)
		return Promise.reject({
			result: choice.id + ": Player " + choice.player.id + " is dead."
		});

	//While this choice is happening, don't allow other choices to use this player.
	choice.player.available = false;

	//Information mechanics. If we're dealing with PerfectInformation, this won't get delivered, so we'll include it in the call to .deliver(). If we're using an information supplied from some other playable, then they can do what they like with it.
	var choiceInfo = {
		choice: {
			id: choice.id,
			player: choice.player.id,
			options: choice.options
		}
	};
	rawInformation.addAdditional(choiceInfo);
	//Perform some data processing if other playables need it.
	if (_compileInformation) _compileInformation(rawInformation);

	return Promise.resolve()
		.then(function() {
			//Prep information
			var information = rawInformation.deliver(choice.player, choiceInfo);
			if (informationFilter) information = informationFilter(information);

			return choice.player.choose(choice.options.slice(0), information);
		})
		.then(function(result) {
			var player = choice.player;
			var id = choice.id;

			//Add to player's individual history;
			player.history.push({
				choice: id,
				options: choice.options,
				result
			});

			result = result || choice.defaultOption;

			var resultObject = {
				result,
				historyEntry: {
					choice: id,
					player: player.id,
					result
				}
			};

			//This will probably only happen if it's a single-player game, otherwise we'll use playoffs defined in a Turn
			if (usePayoffs) {
				var payout = choice.payoffs[result];

				player.score += payout;

				//track the payoff
				var scoreEntry = {
					choice: id,
					payouts: {
						[player.id]: Number(payout)
					}
				};

				history.addScores(scoreEntry);
				resultObject.historyEntry.payouts = {
					[player.id]: payout
				};
			}

			log(
				"silly",
				"_Choice.play: removing from occupiedPlayers: ",
				choice.player.id
			);
			if (releasePlayer) choice.releasePlayer();

			return Promise.resolve(resultObject); //TODO: add information mechanisms
		});
};

//Release player from excluded players list, so that other objects can use it.
_Choice.prototype.releasePlayer = function() {
	this.player.available = true;
};

_Choice.prototype.findNext = function({ result } = {}) {
	return this.next[result.result];
};

_Choice.prototype.generateChainingFunctions = function(choice) {
	var _choice = this;

	_choice.options.forEach(function(option) {
		_choice.payoffs[option] = 0; //Start payoffs at zero

		choice[option] = function(payoff) {
			//Create functions for user to assign payoffs
			if (!isNaN(payoff)) _choice.payoffs[option] = payoff;
			return SynchronousPromise.resolve({
				playable: choice,
				path: [option]
			});
		};
	});
};

_Choice.prototype.summaryThis = function(summary) {
	summary.player = this.player.id;
	summary.options = this.options.slice();

	return summary;
};

//TODO: un-fuck this.
_Choice.prototype.summaryNext = function(
	summary,
	entries = {},
	shortCircuit = false,
	maxEntries = 10
) {
	// Copy over the choice options
	summary.next = Object.assign({}, this.next);

	// Loop through them and summarize at each step.
	var count = 0;
	for (var key in summary.next) {
		summary.next[key] = summary.next[key].map(function(playable) {
			count++;
			return playable.summarize({}, entries);
		});
	}

	// If there weren't any next steps, delete the next key, to reduce clutter.
	if (count == 0) delete summary.next;

	return summary;
};

//Set all payoffs to zero.
_Choice.prototype.zeroPayoffs = function() {
	var choice = this;

	choice.payoffs = {};

	choice.options.forEach(function(option) {
		choice.payoffs[option] = 0;
	});
};

function Choice(player, options, parameters = {}) {
	var id = idHandler(parameters.id, "choice");

	//If informationFilter was supplied, it must be a function
	if (parameters.informationFilter && !isFunction(parameters.informationFilter))
		throw new Error("informationFilter must be a function");

	//Create backend choice object
	var _choice = new _Choice(id, player.id(), options, parameters);

	//Return this reference object to the user. Run the function to select a source
	var choice = Playable(_choice);

	//Interface to specify single-player payoffs in single-player/single-choice games
	_choice.zeroPayoffs();

	_choice.generateChainingFunctions(choice);

	/*
	options.forEach(function(option){
		_choice.payoffs[option] = 0;			//Start payoffs at zero

		choice[option] = function(payoff){					//Create functions for user to assign payoffs
			if (!isNaN(payoff))_choice.payoffs[option] = payoff;
			return Promise.resolve({
				playable:choice,
				path:[option]
			})
		};
	});
	*/

	//Function to set all payoffs at once
	choice.setAllPayoffs = function(payoffs) {
		if (!Array.isArray(payoffs)) throw new Error("Payoffs must be array")
		if (payoffs.length != registry.choices[id].options.length) throw new Error(
			"Payoffs must be same dimensions as choice options")

		payoffs.forEach(function(payoff, index) {
			registry.choices[id].payoffs[options[index]] = payoff;
		})
		//TODO: make this work. Include error handling if array given isn't expected dimensions.
	};

	//Way for user to interact with payoffs
	choice.payoffs = function() {
		return registry.choices[id].payoffs;
	};

	return choice;
}

module.exports = { _Choice, Choice };

},{"../helperFunctions":8,"../history":25,"../information":26,"../logger":27,"../state":50,"./playable":35,"synchronous-promise":71}],30:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Consecutive");

//Game state controllers
var { registry } = require("../state");
var { gameHistory } = require("../history");

//Helper functions
var { idHandler } = require("../helperFunctions")("state");

//Information
var { Information, PerfectInformation } = require("../information");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Consecutive
function _Consecutive(id, playablesArray, parameters = {}) {
	_Playable.call(this, id, parameters);

	playablesArray = playablesArray.map(function(playable) {
		return registry.playables[playable.id()]
	})
	this.playablesArray = playablesArray

	registry.consecutives[id] = this;
}
_Consecutive.prototype = Object.create(_Playable.prototype);
_Consecutive.prototype.constructor = _Consecutive;

_Consecutive.registryName = "consecutives";
_Consecutive.counterName = "consecutive";

_Consecutive.prototype.play = function({
	history = gameHistory,
	information = this.information ||
	PerfectInformation
} = {}) {

	var consecutive = this;

	//Log the history appropriately
	var startEntry = {
		consecutive: consecutive.id,
		action: "start"
	};
	history.log.add(startEntry);

	//History object to give to consecutived playables.
	var consecutiveHistory = history.child();

	//compartmentalize if set. "compartmentalize" means pass on information as if this playable is the entire game.
	if (consecutive.compartmentalize) {
		information = new Information(consecutive.compartmentalize.history || consecutiveHistory,
			consecutive.compartmentalize.population || information.population);
	}

	var action = function action(playablesArray) {
		//Stop if the game is over.
		if (history.stop) return { playable: consecutive };

		if (playablesArray.length > 0) {
			return playablesArray.shift().play({ shortCircuit: true, history: consecutiveHistory, information })
				.then(function(result) {
					return action(playablesArray) || result
				})
		} else return false
	}

	return action(consecutive.playablesArray.slice())
		.then(function(result) {
			result.historyEntry = {
				consecutive: consecutive.id,
				action: consecutiveHistory.orphan()
			};

			//TODO: add information mechanisms

			return Promise.resolve(result);
		});
};

//Overwrite history handler so that tree doesn't have "start" and "finish" entries.
_Consecutive.prototype.handleHistory = function({ history = gameHistory } = {},
	result
) {
	var consecutive = this;

	return Promise.resolve(result).then(function(result) {
		history.log.add({
			consecutive: consecutive.id,
			action: "finish",
			duration: result.historyEntry.duration
		});

		history.addNoLog(result.historyEntry);
		return Promise.resolve(result);
	});
};

//TODO: finish this!
_Consecutive.prototype.summaryThis = function(summary, entries, shortCircuit) {
	summary.action = {};

	this.playableStart.summarize(
		summary.action,
		entries,
		(shortCircuit = this.playableFinish)
	);
};

function Consecutive(playablesArray, parameters = {}) {
	var id = idHandler(parameters.id, "consecutive");

	//Create backend loop object
	var _consecutive = new _Consecutive(id, playablesArray, parameters);

	//Return this reference object to the user. Run the function to select a source
	var consecutive = Playable(_consecutive);

	consecutive.ids = function() {
		return playablesArray.map(function(playable) {
			return playable.id();
		})
	}

	return consecutive;
}

module.exports = { _Consecutive, Consecutive };

},{"../helperFunctions":8,"../history":25,"../information":26,"../logger":27,"../state":50,"./playable":35}],31:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: HaltIf")

//Game state controllers
var {registry} = require('../state');
var {gameHistory} = require('../history');

//Helper functions
var {isFunction}	= require('../helperFunctions')("general");
var {idHandler} 	= require('../helperFunctions')("state");

//Parent class
var {_Playable, Playable} = require('./playable');



//Backend function class for Game
function _Halt(id,testCondition, {logContinue = false}){
	_Playable.call(this,id);
	
	this.testCondition = testCondition;
	this.logContinue = logContinue;
	
	registry.halts[id] = this;
}

_Halt.prototype = Object.create(_Playable.prototype);
_Halt.prototype.constructor = _Halt;

_Halt.registryName = "halts";
_Halt.counterName = "haltIf";

_Halt.prototype.play = function({initializePlayers=false, shortCircuit=false, history=gameHistory}={}){
	
	var halt = this;
	
	var resultObject = {
		'playable':halt,
		'historyEntry':{
			'halt':halt.id
		}
	};
	
	
	var test = halt.testCondition();
	
	
	if (test) {
		log("info", "Halting at " + halt.id)
		
		resultObject.historyEntry.action = "halt";
		resultObject.result = "Halt";
	
		return Promise.reject(resultObject);
	}
	
	//Halt probably gets used for loops, and we might not want to see lots of continue messages, so "logContinue" will omit them.
	if (halt.logContinue) {
		resultObject.historyEntry.action = "continue";
	}
	else delete resultObject.historyEntry
	
	
	return Promise.resolve(resultObject)
};


_Halt.prototype.summaryThis = function(summary){
	summary.condition = this.testCondition.toString();
}



function HaltIf(testCondition=function(){}, {id=null, logContinue=false}={}){
	var id = idHandler(id,"haltIf")
	
	if (!isFunction(testCondition)) log("warn",id + ": testCondition should be a function, or else game will not halt.")

	//Create backend loop object
	var _halt = new _Halt(id, testCondition, {logContinue});
	
	
	//Return this reference object to the user. Run the function to select a source
	var halt = Playable(_halt);	
	return halt;	
}


module.exports = {_Halt, HaltIf};
},{"../helperFunctions":8,"../history":25,"../logger":27,"../state":50,"./playable":35}],32:[function(require,module,exports){
"use strict";

//Loads the playables that will be used by Nash. This is basically the controller list: if it's not in these lists,
// then it won't be available for us.

//External dependency
var present = require("present");

var log = require("../logger");

var { applyBind } = require("../helperFunctions")("general");

log("debug", "Loading Playable Classes: ");

//Playables
var { _Playable } = require("./playable");
var { _Choice, Choice } = require("./choice");
var { _Turn, Turn } = require("./turn");
var { _Sequence, Sequence } = require("./sequence");
var { _Consecutive, Consecutive } = require("./consecutive");
var { _Loop, Loop } = require("./loop");
var { _SLoop, StochasticLoop } = require("./stochasticLoop");
var { _Halt, HaltIf } = require("./halt-if");
var { _SHalt, StochasticHalt } = require("./stochastic-halt");
var { _Lambda, Lambda } = require("./lambda");
var { _RPChoice, RandomPlayerChoice } = require("./random-player-choice");
var { _PopulationDynamics, PopulationDynamics } = require("./population-dynamics");
var { _Simultaneous, Simultaneous } = require("./simultaneous");

//Runs when loading Playable classes.
function initializePlayableClass(playableClass) {
	//Replace the .play() method with a wrapper which calls it and a few other functions
	if (playableClass.prototype.hasOwnProperty("play")) {
		playableClass.prototype.play = (function(play) {
			return function({ history = gameHistory } = {}) {
				var playable = this;
				var args = [].slice.call(arguments);

				// Set our history
				args[0].history ? null : args[0].history = this.history || gameHistory

				// how to halt the game without errors. TODO this is probably fucked
				if (history.stop) return { playable };


				return _Playable.prototype._startTimer
					.apply(playable, args)
					.then(applyBind(playable.checkInit, playable, args))
					.then(applyBind(playable.prePlay, playable, args))
					.then(applyBind(play, playable, args))
					.then(applyBind(playable.postPlay, playable, args))
					.then(applyBind(_Playable.prototype._stopTimer, playable, args))
					.then(applyBind(playable.handleHistory, playable, args))
					.then(applyBind(_Playable.prototype.proceed, playable, args));
			};
		})(playableClass.prototype.play);
	}
}

exports.playableClasses = {
	_Playable,
	_Choice,
	_Turn,
	_Sequence,
	_Consecutive,
	_Loop,
	_SLoop,
	_Halt,
	_SHalt,
	_Lambda,
	_RPChoice,
	_PopulationDynamics,
	_Simultaneous
};
exports.playableInterfaces = {
	Choice,
	Turn,
	Sequence,
	Consecutive,
	Loop,
	StochasticLoop,
	HaltIf,
	StochasticHalt,
	Lambda,
	RandomPlayerChoice,
	PopulationDynamics,
	Simultaneous
};

for (var playableClass in exports.playableClasses) {
	if (playableClass != "_Playable")
		initializePlayableClass(exports.playableClasses[playableClass]);
}

},{"../helperFunctions":8,"../logger":27,"./choice":29,"./consecutive":30,"./halt-if":31,"./lambda":33,"./loop":34,"./playable":35,"./population-dynamics":36,"./random-player-choice":37,"./sequence":38,"./simultaneous":39,"./stochastic-halt":40,"./stochasticLoop":41,"./turn":42,"present":67}],33:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: Lambda")

//Game state controllers
var { registry, gameHistory } = require('../state');

// Information mechanics
var { PerfectInformation } = require("../information");

//Helper functions
var { isFunction } = require('../helperFunctions')("general");
var { idHandler } = require('../helperFunctions')("state");

//Parent class
var { _Playable, Playable } = require('./playable');



//Backend function class for Game
function _Lambda(id, action, parameters = {}) {
	_Playable.call(this, id);

	this.action = action;

	registry.lambdas[id] = this;
}
_Lambda.prototype = Object.create(_Playable.prototype);
_Lambda.prototype.constructor = _Lambda

_Lambda.registryName = "lambdas";
_Lambda.counterName = "lambda";


_Lambda.prototype.play = function({ initializePlayers = false, shortCircuit = false, history = gameHistory,
	information = PerfectInformation } = {}) {

	var lambda = this;

	var result = lambda.action({ history, information })

	var resultObject = {
		result,
		'playable': lambda,
		historyEntry: {
			lambda: lambda.id,
			result
		}
	};

	return Promise.resolve(resultObject)
};

// Simple helper to just run synchronously whatever the Lambda is. Useful for debugging.
_Lambda.prototype.run = function() {
	return this.action();
}

_Lambda.prototype.summaryThis = function(summary) {
	summary.action = this.action.toString();
}


function Lambda(action = function() {}, parameters = {}) {
	var id = idHandler(parameters.id, "lambda")

	if (!isFunction(action)) log("warn", id + ": action should be a function.")

	//Create backend lambda object
	var _lambda = new _Lambda(id, action, parameters);


	//Return this reference object to the user. Run the function to select a source
	var lambda = Playable(_lambda);


	lambda.run = function() {
		return _lambda.run();
	}

	return lambda;
}


module.exports = { _Lambda, Lambda };

},{"../helperFunctions":8,"../information":26,"../logger":27,"../state":50,"./playable":35}],34:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Loop");

//Game state controllers
var { registry } = require("../state");
var { gameHistory, History } = require("../history");

//Helper functions
var { idHandler } = require("../helperFunctions")("state");
var { chainerGenerator } = require("../helperFunctions")("playable");

// Information mechanics
var { Information, PerfectInformation } = require("../information");
var { gamePopulation } = require("../population");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Loop

function _Loop(id, playable, count, parameters) {
	_Playable.call(this, id, parameters);

	var { logContinue = true, playableParameters = {} } = parameters;

	this.playable = registry.playables[playable.id()];
	this.logContinue = logContinue;
	this.playableParameters = playableParameters;

	this.count = count;

	registry.loops[id] = this;
}
_Loop.prototype = Object.create(_Playable.prototype);
_Loop.prototype.constructor = _Loop;

_Loop.registryName = "loops";
_Loop.counterName = "loop";

_Loop.prototype.play = function({
	history = this.history || gameHistory,
	information = this.information || PerfectInformation,
	playableParameters = this.playableParameters
} = {}) {

	var loop = this;
	loop.counter = 0;

	// Split the history entry
	var loopHistory = history.child();

	// information mechanics.
	//compartmentalize If set
	if (loop.compartmentalize) {
		information = new Information(loop.compartmentalize.history || loopHistory,
			loop.compartmentalize.population || information.population);
	}
	// Pass along
	playableParameters.information = information


	var promise = Promise.resolve();

	var action = function(result) {
		//If the game has been ended early, don't continue.
		if (history.stop) return { playable: loop };

		loop.counter++;
		if (!result) result = {};

		//Deal with history
		history.log.add({
			loop: loop.id,
			loopTo: loop.playable.id,
			count: loop.counter
		});

		playableParameters.shortCircuit = true;
		playableParameters.history = loopHistory;

		return loop.playable.play(playableParameters).then(function(result) {
			//Re-format result, replace playable with Loop playable
			result.playable = loop;

			//TODO: add information mechanisms

			return Promise.resolve(result);
		});
	};

	//Repeat the playable loop.count times, by chaining promises.
	for (var i = 0; i < loop.count; i++) {
		promise = promise.then(action);
	}

	return promise.then(function(result) {
		result.historyEntry = {
			loop: loop.id,
			count: loop.counter,
			action: loopHistory.orphan()
		};
		return Promise.resolve(result);
	});
};

//Overwrite history handler to prevent "loop finished" entry from hitting the tree.
_Loop.prototype.handleHistory = function({
		history = this.history || gameHistory,
		information = this.information || PerfectInformation,
		logContinue = this.logContinue
	} = {},
	result
) {
	var loop = this;

	return Promise.resolve(result).then(function(result) {
		//Write final entry if logContinue is set to true
		if (logContinue) {
			history.log.add({
				loop: loop.id,
				loopTo: "Loop finished.",
				count: loop.counter
			});
		}

		history.addNoLog(result.historyEntry);

		return result;
	});
};

// Add detail/nesting to summary.
_Loop.prototype.summaryThis = function(summary, entries) {
	summary.count = this.count;

	summary.action = {};
	this.playable.summarize(summary.action, entries, true);
};

function Loop(playable, count = 1, parameters = {}) {
	var id = idHandler(parameters.id, "loop");

	//Create backend loop object
	var _loop = new _Loop(id, playable, count, parameters);

	//Return this reference object to the user. Run the function to select a source
	var loop = Playable(_loop);
	return loop;
}

module.exports = { _Loop, Loop };

},{"../helperFunctions":8,"../history":25,"../information":26,"../logger":27,"../population":49,"../state":50,"./playable":35}],35:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Playable");

var { SynchronousPromise } = require("synchronous-promise");
var present = require("present");

//Game state controllers
var { registry, idCounters } = require("../state");
var { gameHistory, History } = require("../history");

//Helper functions
var { isFunction } = require("../helperFunctions")("general");
var { outcomeTreeAddAll, outcomeTreeGetValue } = require("../helperFunctions")("playable");
var { reinitializePlayers } = require("../helperFunctions")("player");

//To return to user
var { Population, PlayerList } = require("../population");

//_playable class, superclass for objects which can execute game steps (choice, turn, game)
function _Playable(id, parameters = {}) {
	this.id = id;
	this.next = [];
	registry.playables[id] = this;
	idCounters.playable++;

	parameters.compartmentalize ? this.compartmentalize = parameters.compartmentalize : null;
	parameters.history ? (this.history = parameters.history) : null;
	parameters.information ? (this.information = parameters.information) : null;
	parameters.initializePlayers ? (this.initializePlayers = parameters.initializePlayers) : null;
}

_Playable.registryName = "playables";
_Playable.counterName = "playable";

//Add reference to next playable branch, to chain playables together.
_Playable.prototype.addNext = function(nextPlayable) {
	outcomeTreeAddAll(this.next, nextPlayable);
};

//Called before .play() to start timing.
_Playable.prototype._startTimer = function() {
	this._timer = present();
	return Promise.resolve();
};

//Called before prePlay, initialize players if true.
_Playable.prototype.checkInit = function({ initializePlayers = this.initializePlayers } = {}, result) {
	// if we get something
	if (initializePlayers) {
		// if it's just true, then reinitialize everybody
		if (initializePlayers === true) return reinitializePlayers("all", result)

		// if it's a playerList, use that
		else if (initializePlayers instanceof PlayerList) return reinitializePlayers(initializePlayers)

		// if we get a function, then run the function and check that it's returning a playerList
		else if (isFunction(initializePlayers)) {
			var list = initializePlayers()
			if (list instanceof PlayerList) return reinitializePlayers(list, result);
		}

		// otherwise, convert it to a playerList and let PlayerList deal with it.
		else return reinitializePlayers(new PlayerList(initializePlayers), result);
	}

	// if we didn't get anything or got false, we're done here.
	else return Promise.resolve(result);
};


//Called before .play() but after _startTimer
_Playable.prototype.prePlay = function({} = {}, result) {
	return Promise.resolve(result);
};

//Called after .play(), overwritable.
_Playable.prototype.postPlay = function({} = {}, result) {
	return Promise.resolve(result);
};

//Called after .postPlay() to stop timer and log.
_Playable.prototype._stopTimer = function({} = {}, result) {
	if (result.historyEntry)
		result.historyEntry.duration = present() - this._timer;
	delete this._timer;

	return Promise.resolve(result);
};

//Called after timer stops, to write log. Overwiteable if playable has specific logging behavior.
_Playable.prototype.handleHistory = function({ history = gameHistory } = {},
	result
) {
	return Promise.resolve(result).then(function(result) {
		if (result.historyEntry) history.add(result.historyEntry);
		return Promise.resolve(result);
	});
};

//Determine whether to play next, and if so, do.
_Playable.prototype.proceed = function({ shortCircuit } = {}, result) {
	var playable = this;

	return Promise.resolve(result).then(function(result) {
		//Replace reported playable with latest running playable (this is necessary for short-circuit logic)
		result.playable = playable;

		//Short-circuit logic allows higher-order playable to figure out what to do next.
		if (shortCircuit) return Promise.resolve(result);

		return playable.playNext(result);
	});
};

//Play next.
_Playable.prototype.playNext = function(result, parameters = {}) {
	var playable = this;

	return Promise.resolve(result).then(function(result) {
		//Find out where to go next
		var next = playable.findNext({ result });

		//If there's somewhere to go, then go.
		if (next[0] instanceof _Playable)
			return Promise.all(
				next.map(function(playable) {
					return playable.play(parameters);
				})
			);

		//Otherwise, we're done here
		return Promise.resolve(result);
	});
};

// Return the next playable in the sequence. Overwriteable for playables with more complicated branching.
_Playable.prototype.findNext = function() {
	return this.next;
};

_Playable.prototype._summarize = function() {};

// Summarize the game structure. Calls summaryThis and summaryNext, which are overwritable.
_Playable.prototype.summarize = function(
	summary = {},
	entries = {},
	shortCircuit = false,
	maxEntries = 10
) {
	// Start summary for this playable
	summary[this.constructor.counterName] = this.id;

	// Track how many times we've been here before, to avoid circular recursion
	entries[this.id] ? ++entries[this.id] : (entries[this.id] = 1);
	if (entries[this.id] > maxEntries) shortCircuit = true;

	// Add summary
	this.summaryThis(summary, entries);

	// Proceed to next steps
	if (!shortCircuit || shortCircuit !== this)
		this.summaryNext(summary, entries);

	return summary;
};

// Adds the summary information on this playable. Overwrite this in order to add specific information.
_Playable.prototype.summaryThis = function(summary = {}, entries = {}) {
	return summary;
};

// Adds summary information down the next-path. Overwite this for playables with more complex branching.
_Playable.prototype.summaryNext = function(summary = {}, entries = {}) {
	// If there's a next-entry
	if (this.next.length > 0) {
		// Loop over each next-item, and summarize it.
		summary.next = this.next.map(function(playable) {
			return playable.summarize({}, entries);
		});

		// If there's only one item, no need for an array.
		if (summary.next.length == 1) summary.next = summary.next[0];
	}
};


//Convoluted code here to produce the object that user interacts with (ie c1 in 'c1 = Choice()')
//This mimics creating a class that inherits from Function. First define the "prototype", which includes
//a "constructor", a "call" method that will get called, and any other properties and methods.
//Then 'classFactory' produces the class/constructing object (see below), which you can use to
//produce the actual objects.

var playablePrototype = Object.create(Function.prototype);

playablePrototype.constructor = function(_playable) {
	var playable = this;

	//Tag-back. Store the front-end object in the back-end object, for retrieval
	_playable.interface = playable;

	this.call = function(source) {
		var previousPlayable, path;

		//TODO: verify that source is the right type

		return SynchronousPromise.all([
			(function() {
				if (source instanceof Promise || source instanceof SynchronousPromise) {
					source.then(function(result) {
						previousPlayable = registry.playables[result.playable.id()];
						path = result.path;
						console.log(path);
						return SynchronousPromise.resolve();
					});
				}
				return SynchronousPromise.resolve();
			})(),
			(function() {
				if (!(source instanceof Promise || source instanceof SynchronousPromise)) {
					previousPlayable = registry.playables[source.id()];
					path = source.path;
				}

				return SynchronousPromise.resolve();
			})()
		]).then(function(result) {
			console.log(path);
			log(
				"debug",
				"Adding next playable to " +
				previousPlayable.id +
				", node " +
				_playable.id
			);

			if (path == "all") previousPlayable.addNext(_playable);
			else {
				outcomeTreeGetValue(previousPlayable.next, path).push(_playable);
			}

			log("silly", previousPlayable.next);
			//previousPlayable.next[selected].push(_choice);

			return SynchronousPromise.resolve({
				playable: playable,
				path: "all"
			});
		});
	};

	this.id = function() {
		return _playable.id;
	};

	this.play = function({
		initializePlayers = false,
		usePayoffs = true,
		shortCircuit = false,
		writeHistory = true,
		clearHistory = true,
		releasePlayers = true
	} = {}) {

		if (clearHistory) gameHistory.clearHistory();

		var history = writeHistory ?
			_playable.history || gameHistory :
			new History();

		return Promise.resolve()
			.then(function(result) {
				return _playable.play({ initializePlayers, usePayoffs, shortCircuit, history, releasePlayers });
			})
			.catch(function(reason) {
				console.log(reason);

				//If the game was stopped by a Halt playable or everybody's dead, we'll end up here, and things are fine. Just log it.
				if (reason.result == "Halt") {
					gameHistory.add(reason.historyEntry);
					return Promise.resolve(reason.result);
				} else if (reason.result == "Population Collapse")
					return Promise.resolve(reason.result);
				else {
					history.log.add({ error: reason });
					return Promise.reject(reason);
				}
			})
			.then(function(result) {
				//Replace result, so that user can't get access to _playables

				return Promise.resolve({
					Population: Population(),
					gameHistory
				});
			});
	};

	this.summarize = function() {
		return _playable.summarize({});
	};
};

playablePrototype.call = function() {
	//This will get overwritten when the "constructor" is called, but leaving it here so you can figure out how the hell this works.
};

playablePrototype.path = "all";

//Produces the function that will produce the end result. This part is reusable if you need to do this again.
var classFactory = function(proto) {
	return function() {
		var f = function() {
			return f.call.apply(f, arguments);
		};

		Object.defineProperty(f, "constructor", {
			configurable: true,
			writable: true
		});
		Object.defineProperty(f, "call", { writable: true });

		Object.keys(proto).forEach(function(key) {
			f[key] = proto[key];
		});

		f.constructor.apply(f, arguments);

		delete f.constructor; //Added this bit here, to prevent the user from trying to create new objects.

		return f;
	};
};

var Playable = classFactory(playablePrototype);
// called as: var instance = Playable(/* some internal object like _choice */);

module.exports = { _Playable, Playable };

},{"../helperFunctions":8,"../history":25,"../logger":27,"../population":49,"../state":50,"present":67,"synchronous-promise":71}],36:[function(require,module,exports){
"use strict";

var log = require('../logger');

//External dependency
var poisson = require('randgen').rpoisson;

//Game state controllers
var {registry, gameHistory} = require('../state');

//Helper functions
var {isFunction}	= require('../helperFunctions')("general");
var {idHandler} 	= require('../helperFunctions')("state");

//Parent class
var {_Playable, Playable} = require('./playable');

//Player controllers
var {_Player, Player} = require('../player');
var {PlayerList, UserPlayerList, gamePopulation, Population} = require('../population');

//Update this each time .play is called, but leave it available to the whole scope so that 
//growth and decay can access it
var population;

//Default growth function
var growthDefault = function growth(player, population, birthRate, selectiveMultiplier) {
	var score = player.score;
	var mean = population.scoresMean();
	var std = population.scoresStd();
	
	var Z = !(isNaN(std) || std==0) ? (score-mean)/std : 0
	
	console.log(score, mean, std,Z);
	
	var rate = birthRate + selectiveMultiplier*Z;

	var generated = poisson(rate);
	log("silly","growthDefault: generated random number " + generated.toString()+ " using rate "+ rate.toString());
	
	return generated;
}

//Default decay function
var decayDefault = function decay(player, population, deathRate, selectiveMultiplier) {
	var score = player.score;
	var mean = population.scoresMean();
	var std = population.scoresStd();
	
	console.log(score, mean, std);
	
	var Z =  !(isNaN(std)||std==0) ? (score-mean)/std : 0;
	
	console.log(Z)
	var rate = deathRate - selectiveMultiplier*Z;
	
	var generated = poisson(rate);
	log("silly","decayDefault: generated random number " + generated.toString()+ " using rate "+ rate.toString());
	return generated;
}



//Backend function class for PopulationDynamics
function _PopulationDynamics(id, birthRate,deathRate, {growthFunction=growthDefault, decayFunction=decayDefault, selectiveMultiplier= .5, playerParameters={}}={}){
	_Playable.call(this,id);
	
	var pd = this;
	
	this.birthRate = birthRate;
	this.deathRate = deathRate;
	this.selectiveMultiplier = selectiveMultiplier;
	
	//Wrap the growth and decay functions, so that the user doesn't have to worry about calling this.birthRate or this.deathRate
	this.growth = function(player){
		log("silly","_pd.growth: Checking grow condition");
		return growthFunction(player, population, pd.birthRate, pd.selectiveMultiplier)
	};
	this.decay = function(player){
		log("silly","_pd.decay: Checking decay condition");
		return decayFunction(player, population, pd.deathRate, pd.selectiveMultiplier);
	};
	
	this.playerParameters = playerParameters;
	
	registry.controllers[id] = this;
}
_PopulationDynamics.prototype = Object.create(_Playable.prototype);
_PopulationDynamics.prototype.constructor = _PopulationDynamics;

_PopulationDynamics.registryName = "controllers";
_PopulationDynamics.counterName = "populationDynamics";


_PopulationDynamics.prototype.play = function({initializePlayers=false, shortCircuit=false, history=gameHistory}={}){
	
	var pd = this;
	
	var births = 0;
	var deaths = 0;
	
	//Update population using whoever's alive currently
	population = gamePopulation().onlyAlive();
		
	
	//Kill cycle
	var killed = new PlayerList([]);
	population.forEach(function(player){
		// If the decay function is returns truthy, kill.
		
		if (pd.decay(player)) {
			log("silly","must kill...")
			player.kill();
			deaths++;
			killed.push(player);
			log("silly","dead");
		}
		
		
	});
	
	//Update update again to prevent the recently deceased from reproducing
	population = gamePopulation().onlyAlive();
	
	if (population.length == 0) {
		//Everybody's dead. Let's wrap it up.
		var reason = {result:"Population Collapse", playable:pd};
		history.end();
		return Promise.resolve(reason);
	}
	
	//Birth cycle
	var born = new UserPlayerList([]);
	population.forEach(function(player){
		//Birth whatever number is returned
		var numBirth = pd.growth(player)
		console.log(numBirth);
		for (var i=1; i<=numBirth; i++){
			log("silly", "Player " + player.id +" giving birth!");
			
			var playerParameters = Object.assign({},{
					assign:player.strategy ? player.strategy._id : "",
					parent:player.id}
				,pd.playerParameters);
			
			born.push(Player(playerParameters));
		}	
	});
	
	
	var result = {births, deaths};
	
	var resultObject = {
		result,
		'playable':pd,
		historyEntry:{
			populationDynamics:pd.id,
			result
		}
	};
	
	return Promise.resolve(resultObject);
};



function PopulationDynamics(birthRate=.05, deathRate = .05, parameters={}){
	var id = idHandler(parameters.id,"populationDynamics")
	
	if (parameters.growth && !isFunction(growth)) log("error",id + ": growth should be a function.");
	if (parameters.decay && !isFunction(decay))   log("error",id + ": decay should be a function.");
		
	//Create backend lambda object
	var _pd = new _PopulationDynamics(id, birthRate, deathRate, parameters);
	
	
	//Return this reference object to the user. Run the function to select a source
	var pd = Playable(_pd);	
	return pd;	
}


module.exports = {_PopulationDynamics, PopulationDynamics};
},{"../helperFunctions":8,"../logger":27,"../player":43,"../population":49,"../state":50,"./playable":35,"randgen":68}],37:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: RandomPlayerChoice")

//Game state controllers
var { registry, gameHistory, occupiedPlayers } = require('../state');

//Helper functions
var { idHandler } = require('../helperFunctions')("state");
var { chainerGenerator } = require('../helperFunctions')("playable");

//Parent class
var { _Playable, Playable } = require('./playable');
var { _Choice, Choice } = require('./choice');

//Population helpers
var { PlayerList } = require('../population');


//Backend function class for RPChoice
function _RPChoice(id, options, parameters = {}) {

	//If they specify players to draw from, use only that list. Otherwise, use whoever's around.
	this.includePlayers = parameters.includePlayers || "all";

	this.excludePlayers = parameters.excludePlayers ? new PlayerList(parameters.excludePlayers) : new PlayerList()

	this.generator = Math.random;

	var player = null;


	_Choice.call(this, id, player, options, parameters);
}

_RPChoice.prototype = Object.create(_Choice.prototype);
_RPChoice.prototype.constructor = _RPChoice;

_RPChoice.registryName = "choices";
_RPChoice.counterName = "randomPlayerChoice";



//Select the player to make the choice
_RPChoice.prototype.choosePlayer = function choosePlayer() {

	var rpChoice = this;

	return Promise.resolve().then(function() {

		//Find players to choose from
		var pool = new PlayerList(rpChoice.includePlayers).onlyAlive().onlyAvailable().exclude(rpChoice.excludePlayers)
		if (pool.length == 0) return Promise.reject("No available players.");

		log("silly", "rpChoice.choosePlayer: choosing froom pool: " + pool.ids());

		var randomNumber = Math.floor(rpChoice.generator() * pool.length);
		var candidate = pool[randomNumber];


		log("silly", "rpChoice.choosePlayer: selecting player ", candidate.id)

		rpChoice.player = candidate;
		candidate.available = false;

		return Promise.resolve(candidate.id);
	});
};

_RPChoice.prototype.prePlay = function() {
	return this.choosePlayer();
};


_RPChoice.prototype.summaryThis = function(summary) {
	summary.options = this.options;
};



function RandomPlayerChoice(options, parameters = {}) {
	var { id = null, excludePlayers = [], playerList = null } = parameters

	var id = idHandler(id, "randomPlayerChoice")

	//Create backend choice object
	var _rpChoice = new _RPChoice(id, options, parameters);

	//Return this reference object to the user. Run the function to select a source
	var rpChoice = Playable(_rpChoice)

	rpChoice.playerList = function(playerList) {
		if (Array.isArray(playerList)) _rpChoice.playerList = playerList;
		return _rpChoice.playerList
	};

	rpChoice.excludePlayers = function(excludePlayers) {
		if (Array.isArray(excludePlayers)) {
			_rpChoice.excludePlayers = [];

			excludePlayers.forEach(function(player) {
				_rpChoice.excludePlayers.push(player.id());
			});

		}
		return _rpChoice.excludePlayers
	};

	//Interface to specify single-player payoffs in single-player/single-choice games
	_rpChoice.zeroPayoffs();

	_rpChoice.generateChainingFunctions(rpChoice);

	//Function to set all payoffs at once
	rpChoice.setAllPayoffs = function(payoffs) {
		//TODO: make this work. Include error handling if array given isn't expected dimensions.
	};


	//Way for user to interact with payoffs
	rpChoice.payoffs = function() { return registry.choices[id].payoffs; };

	return rpChoice;
}



module.exports = { _RPChoice, RandomPlayerChoice };

},{"../helperFunctions":8,"../logger":27,"../population":49,"../state":50,"./choice":29,"./playable":35}],38:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Sequence");

//Game state controllers
var { registry } = require("../state");
var { gameHistory } = require("../history");

//Helper functions
var { idHandler } = require("../helperFunctions")("state");

//Information
var { Information, PerfectInformation } = require("../information");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Sequence
function _Sequence(id, playableStart, playableFinish, parameters = {}) {
	_Playable.call(this, id, parameters);

	this.playableStart = registry.playables[playableStart.id()];
	this.playableFinish = registry.playables[playableFinish.id()];

	registry.sequences[id] = this;
}
_Sequence.prototype = Object.create(_Playable.prototype);
_Sequence.prototype.constructor = _Sequence;

_Sequence.registryName = "sequences";
_Sequence.counterName = "sequence";

_Sequence.prototype.play = function({
	history = gameHistory,
	information = this.information ||
	PerfectInformation
} = {}) {

	var sequence = this;

	//Log the history appropriately
	var startEntry = {
		sequence: sequence.id,
		action: "start"
	};
	history.log.add(startEntry);

	//History object to give to sequenced playables.
	var sequenceHistory = history.child();

	//compartmentalize if set. "compartmentalize" means pass on information as if this playable is the entire game.
	if (sequence.compartmentalize) {
		information = new Information(sequence.compartmentalize.history || sequenceHistory,
			sequence.compartmentalize.population || information.population);
	}

	// Recursion down the chain of playables
	var action = function action(result) {
		//Stop if the game is over.
		if (history.stop) return { playable: sequence };

		//Otherwise, recurse to figure out what to do next.
		if (Array.isArray(result)) {
			log("silly", "sequence.play: Next-item is an array, splitting into pieces.");

			return Promise.all(
				result.map(function(item) {
					log("silly", "sequence.play: recursing on", item);
					return action(item);
				})
			);
		}

		if (result.playable !== sequence.playableFinish) {
			log("silly", result);

			if (result.playable.findNext({ result }).length > 0) {
				log("silly", "Playable has next-item, continuing down chain.");

				return result.playable.playNext(result, { shortCircuit: true, history: sequenceHistory, information })
					.then(action); //Repeat for next playable in chain
			}
			return Promise.resolve(result);
		}
		return Promise.resolve(result);
	};

	return sequence.playableStart
		.play({ shortCircuit: true, history: sequenceHistory, information })
		.then(action)
		.then(function(result) {
			result.historyEntry = {
				sequence: sequence.id,
				action: sequenceHistory.orphan()
			};

			//TODO: add information mechanisms

			return Promise.resolve(result);
		});
};

//Overwrite history handler so that tree doesn't have "start" and "finish" entries.
_Sequence.prototype.handleHistory = function({ history = gameHistory } = {},
	result
) {
	var sequence = this;

	return Promise.resolve(result).then(function(result) {
		history.log.add({
			sequence: sequence.id,
			action: "finish",
			duration: result.historyEntry.duration
		});

		history.addNoLog(result.historyEntry);
		return Promise.resolve(result);
	});
};

//TODO: finish this!
_Sequence.prototype.summaryThis = function(summary, entries, shortCircuit) {
	summary.action = {};

	this.playableStart.summarize(
		summary.action,
		entries,
		(shortCircuit = this.playableFinish)
	);
};

function Sequence(playableStart, playableFinish, parameters = {}) {
	var id = idHandler(parameters.id, "sequence");

	//Create backend loop object
	var _sequence = new _Sequence(id, playableStart, playableFinish, parameters);

	//Return this reference object to the user. Run the function to select a source
	var sequence = Playable(_sequence);
	return sequence;
}

module.exports = { _Sequence, Sequence };

},{"../helperFunctions":8,"../history":25,"../information":26,"../logger":27,"../state":50,"./playable":35}],39:[function(require,module,exports){
"use strict";

var log = require('../logger');

//Helper functions
var { isObject } = require('../helperFunctions')("general");
var { idHandler } = require('../helperFunctions')("state");

//Parent class
var { _Playable, Playable } = require('./playable');

// Information mechanics
var { Information, PerfectInformation } = require('../information');


//Backend class
function _Simultaneous(id, playableArray, { playableParameters = {} } = {}) {
	_Playable.call(this, id);

	this.playableArray = playableArray;
	this.playableParameters = playableParameters;

	registry.controllers[id] = this;
}

_Simultaneous.prototype = Object.create(_Playable.prototype);
_Simultaneous.prototype.constructor = _Simultaneous;

_Simultaneous.registryName = "controllers";
_Simultaneous.counterName = "simultaneous";


//Simultaneous Promise.all's the playables, which causes them to run meshed.
_Simultaneous.prototype.play = function({ history = gameHistory, information = PerfectInformation } = {}) {

	var simultaneous = this;

	// Deal with history. Log start, then split history for children playables to fill in.
	history.log.add({
		simultaneous: simultaneous.id,
		action: "Simultaneous start."
	});
	var simultaneousHistory = []



	//TODO: is information mechanics correct?

	return Promise.all(simultaneous.playableArray.map(function(playable) {

		var branchHistory = history.child();
		simultaneousHistory.push(branchHistory)

		// Information mechanics
		var infoPopulation, parentHistory, infoHistory = branchHistory;
		//compartmentalize if set. "compartmentalize" means pass on information as if this playable is the entire game.
		if (simultaneous.compartmentalize) {
			infoPopulation = simultaneous.compartmentalize.population || information.population;
			parentHistory = simultaneous.compartmentalize.history || information.history;
		} else {
			infoPopulation = information.population;
			parentHistory = information.history
		}
		var simultaneousInformation = new Information(infoHistory, infoPopulation, { parentHistory });



		return playable.play({ history: branchHistory, information: simultaneousInformation });
	})).then(function(resultArray) {

		var resultObject = {
			resultArray,
			playable: simultaneous,
			historyEntry: {
				simultaneous: simultaneous.id,
				action: simultaneousHistory.map(function(history) {
					return history.orphan();
				})
			}
		};
		return resultObject;
	});
};


_Simultaneous.prototype.handleHistory = function({ history = gameHistory } = {}, result) {

	history.log.add({
		simultaneous: this.id,
		action: "Simultaneous complete."
	});

	history.addNoLog(result.historyEntry);

	return Promise.resolve(result);
};

_Simultaneous.prototype.summaryThis = function(summary, entries) {
	summary.action = [];

	this.playableArray.forEach(function(playable, index) {
		summary.action[index] = {}
		playable.summarize(summary.action[index], entries);
	});
}


//Frontend class
function Simultaneous(playableArray, parameters = {}) {
	var id = idHandler(parameters.id, "simultaneous")

	playableArray = playableArray.map(function(playable) {
		return registry.playables[playable.id()];
	});


	//Create backend instance.
	var _simultaneous = new _Simultaneous(id, playableArray, parameters);

	//Return this reference object to the user. Run the function to select a source
	var simultaneous = Playable(_simultaneous);
	return simultaneous;
}


module.exports = { _Simultaneous, Simultaneous };

},{"../helperFunctions":8,"../information":26,"../logger":27,"./playable":35}],40:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: Stochastic-Halt")

//Game state controllers
var {registry, gameHistory} = require('../state');

//Helper functions
var {isFunction}	= require('../helperFunctions')("general");
var {idHandler} 	= require('../helperFunctions')("state");

//Parent class
var {_Playable, Playable} 	= require('./playable');
var {_Halt, Halt}			= require('./halt-if');


//Backend function class for SHalt
function _SHalt(id, probability, parameters){
	_Halt.call(this,id,null,parameters);
	
	var sHalt = this;
	
	this.probability = probability;
	this.generator = Math.random;				//TODO: allow user to specify random number generator
	
	this.testCondition = function(){
		if (sHalt.generator() < sHalt.probability) return true;
	};
	
	
	registry.sHalts[id] = this;
}
_SHalt.prototype = Object.create(_Halt.prototype);
_SHalt.prototype.constructor = _SHalt;

_SHalt.registryName = "sHalts";
_SHalt.counterName = "stochasticHalt";

/*
_SHalt.prototype.play = function({initializePlayers=false, shortCircuit=false}={}){
	
	var sHalt = this;
	var test = sHalt.testCondition();
	
	if (test) {
		log("info", "Halting at " + sHalt.id)
		
		return Promise.reject({
			result:"Halt",
			playable:sHalt
		});
	}
	
	var resultObject = {
		'result':"Continued",
		'playable':sHalt
	};
	
	return Promise.resolve(resultObject)
	.then(function(result){	
		
		//TODO: add information mechanisms
		
		return Promise.resolve(result)		
	}).then(function(result){
		
		return sHalt.proceed(result, shortCircuit);
	});
};
*/

_SHalt.prototype.summaryThis = function(summary, entries){
	summary.probability = this.probability;
}


function StochasticHalt(probability, {id=null, logContinue=false}={}){
	var id = idHandler(id,"stochasticHalt")
	
	if (isNaN(probability) || probability < 0 || probability > 1) throw new Error('Invalid probability');

	//Create backend sHalt objects
	var _sHalt = new _SHalt(id, probability, {logContinue});
	
	
	//Return this reference object to the user. Run the function to select a source
	var sHalt = Playable(_sHalt);	
	return sHalt;	
}


module.exports = {_SHalt, StochasticHalt};
},{"../helperFunctions":8,"../logger":27,"../state":50,"./halt-if":31,"./playable":35}],41:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: StochasticLoop")

//Game state controllers
var { registry, gameHistory } = require('../state');

//Helper functions
var { idHandler } = require('../helperFunctions')("state");
var { chainerGenerator } = require('../helperFunctions')("playable");

//Parent classes
var { _Playable, Playable } = require('./playable');
var { _Loop, Loop } = require('./loop');


//Backend function class for StochasticLoop
function _SLoop(id, playable, probability, parameters) {
	_Loop.call(this, id, playable, null, parameters);

	this.playable = registry.playables[playable.id()];

	//This inherits from Loop which uses a count. Delete that and replace with probability.
	delete this.count;
	this.probability = probability;

	this.generator = Math.random; //TODO: allow user to specify random number generator

	registry.sLoops[id] = this;
}
_SLoop.prototype = Object.create(_Loop.prototype);
_SLoop.prototype.constructor = _SLoop;

_SLoop.registryName = "sLoops";
_SLoop.counterName = "stochasticLoop";


_SLoop.prototype.play = function({
	initializePlayers = false,
	shortCircuit = false,
	history = gameHistory,
	information: PerfectInformation
} = {}) {

	var sLoop = this;
	sLoop.counter = 0;
	var loopHistory = history.child();

	if (sLoop.compartmentalize) {
		information = new Information(sLoop.compartmentalize.history || loopHistory,
			sLoop.compartmentalize.population || information.population);
	}


	var promise = Promise.resolve({});

	//Section that will be looped
	var action = function(result) {

		sLoop.counter++;
		if (!result) result = {};


		//Deal with history
		history.log.add({
			loop: sLoop.id,
			loopTo: sLoop.playable.id,
			count: sLoop.counter
		});

		return sLoop.playable.play({ shortCircuit: true, history: loopHistory, information })
			.then(function(result) {

				result.playable = sLoop;
				//TODO: add information mechanisms

				return Promise.resolve(result)
			});
	};


	//Generate random numbers, repeat while number is above halting probability
	while (sLoop.generator() > sLoop.probability) {
		promise = promise.then(action);
	}


	return promise.then(function(result) {

		result.historyEntry = {
			loop: sLoop.id,
			count: sLoop.counter,
			action: loopHistory.orphan()
		};

		return Promise.resolve(result);
	});
};

_SLoop.prototype.summaryThis = function(summary, entries) {
	summary.probability = this.probability;

	summary.action = {}
	this.playable.summarize(summary.action, entries, true)
}


//User interface
function StochasticLoop(playable, probability = .5, parameters = {}) {
	var id = idHandler(parameters.id, "stochasticLoop")

	if (isNaN(probability) || probability < 0 || probability > 1) throw new Error('Invalid probability');

	//Create backend sLoop object
	var _sLoop = new _SLoop(id, playable, probability, parameters);


	//Return this reference object to the user. Run the function to select a source
	var sLoop = Playable(_sLoop);
	return sLoop;
}



module.exports = { _SLoop, StochasticLoop };

},{"../helperFunctions":8,"../logger":27,"../state":50,"./loop":34,"./playable":35}],42:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Turn");

//External dependency
var { SynchronousPromise } = require("synchronous-promise");

//Helper functions
var { isObject, once } = require("../helperFunctions")("general");
var { chainerGenerator, outcomeTreeGetValue, outcomeTreeSetValue } = require("../helperFunctions")("playable");
var { recurse } = require("../helperFunctions")("turn");
var { idHandler } = require("../helperFunctions")("state");

//Game state controllers
var { registry } = require("../state");
var { gameHistory } = require("../history");
var { Information, PerfectInformation } = require("../information");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Turn
function _Turn(id, choices, parameters = {}) {
	_Playable.call(this, id);

	this.payoffsImplicit = {};
	this.payoffsExplicit = {};

	this.next = {};

	this.choices = choices.map(function(choice) {
		return registry.choices[choice.id()];
	});

	registry.turns[id] = this;

	var turn = this;

	this.choiceMap = this.choices.map(function(item) {
		return item.options;
	});

	recurse(turn.choiceMap, turn.payoffsImplicit, null, function() {
			return Array(turn.choiceMap.length).fill(0);
		})
		.then(function(result) {
			log("silly", "Added implicit payoffs map to turn.");
			return recurse(turn.choiceMap, turn.payoffsExplicit, {});
		})
		.then(function(result) {
			log("silly", "Added explicit payoffs map to turn.");
			return recurse(turn.choiceMap, turn.next, null, function() {
				return [];
			});
		})
		.then(function(result) {
			log("silly", "Added blank next map to turn.");
			return Promise.resolve(result);
		})
		.catch(function(reason) {
			log("error", reason);
		}); //TODO: error handling here
}
_Turn.prototype = Object.create(_Playable.prototype);
_Turn.prototype.constructor = _Turn;

_Turn.registryName = "turns";
_Turn.counterName = "turn";


_Turn.prototype.play = function({
	usePayoffs = true,
	history = gameHistory,
	information = PerfectInformation,
	releasePlayers = true
} = {}) {

	var turn = this;
	var choiceHistory = history.child();
	var choiceInformation = information.child();

	if (turn.compartmentalize) {
		choiceInformation = new Information(turn.compartmentalize.history || choiceHistory,
			turn.compartmentalize.population || information.population);
	}

	history.log.add({
		turn: turn.id,
		choices: turn.choices.map(function(choice) {
			return choice.id;
		})
	});

	var compileInformation = function(ri) {
		//If there's no turn entry, create one.
		if (!choiceInformation.additional[0].turn) {
			var turnInfo = {
				turn: {
					id: turn.id,
					choices: [],
					exclude(player) {
						return this.choices.filter(function(choice) {
							return choice.player == player;
						});
					}
				}
			};
			choiceInformation.additional.unshift(turnInfo);
		}
		choiceInformation.additional[0].turn.choices.push(
			choiceInformation.additional.pop()
		);

		information.additional.forEach( // TODO: what does this do???
			choiceInformation.addAdditional.bind(choiceInformation)
		);
	};

	return Promise.all(
			turn.choices.map(function(choice) {
				return choice.play({
					shortCircuit: true,
					history: choiceHistory,
					information: choiceInformation,
					_compileInformation: compileInformation,
					releasePlayers: false
				});
			})
		)
		.then(function(result) {
			//Re-format output from array of Choice results to single Turn result
			//And release players
			var resultPath = result.map(function(choice, index) {
				if (releasePlayers) turn.choices[index].releasePlayer();
				return choice.result;
			});

			//Pass along results and record history
			var resultObject = {
				result: resultPath,
				playable: turn,
				historyEntry: {
					turn: turn.id,
					results: choiceHistory.orphan(),
					payouts: {}
				}
			};

			return Promise.resolve(resultObject);
		})
		.then(function(result) {
			//Implement payoffs
			if (usePayoffs) {
				var implicitPayoffs = outcomeTreeGetValue(
					turn.payoffsImplicit,
					result.result
				);
				var explicitPayoffs = outcomeTreeGetValue(
					turn.payoffsExplicit,
					result.result
				);

				// For the log
				var payouts = {};

				implicitPayoffs.forEach(function(payoff, index) {
					// Do nothing if payoff is zero.
					if (payoff == 0) return;

					// fetch player and increment score
					var player = turn.choices[index].player;
					player.score += payoff;

					//And include it in the log entry
					payouts[player.id] = Number(payoff);
				});

				for (var player in explicitPayoffs) {
					registry.players[player].score += explicitPayoffs[player];

					//And include it in the log entry
					payouts[player] = Number(explicitPayoffs[player]);
				}

				//Log for the scores log
				var scoreEntry = {
					turn: turn.id,
					result: result.result,
					payouts: payouts
				};
				history.addScores(scoreEntry);


				// Log for the game history
				result.historyEntry.payouts = payouts;
			}

			return Promise.resolve(result); //TODO: add information mechanisms
		});
};

//Overwrite default history handler, because we don't want a second entry in the tree
_Turn.prototype.handleHistory = function({ history = gameHistory } = {},
	result
) {
	history.addNoLog(result.historyEntry);

	return Promise.resolve(result);
};

_Turn.prototype.findNext = function({ result } = {}) {
	return outcomeTreeGetValue(this.next, result.result);
};

_Turn.prototype.generateChainingFunctions = function() {
	var _turn = this;
	var turn = _turn.interface;

	//Create payoff setter/branch router functions.
	//recurse adds a wrapper around this function which supplies the path.
	recurse(_turn.choiceMap, turn, function(path, payoffs) {
		//If user supplied payoffs in array form, then translate to object based on which players are involved in the choices
		if (Array.isArray(payoffs)) {
			if (payoffs.length !== _turn.choices.length) {
				//If array isn't right length, then this is unintelligible.
				log(
					"error",
					"Payoff array does not match Turn dimensions, cannot assign payoffs."
				);
				return Promise.reject(new Error("Payoff array is not correct length"));
			}

			var originalPayoffs = payoffs.slice();
			payoffs = {};

			outcomeTreeSetValue(_turn.payoffsImplicit, path, originalPayoffs);
		} else if (isObject(payoffs)) {
			payoffs = JSON.parse(JSON.stringify(payoffs));
			outcomeTreeSetValue(_turn.payoffsExplicit, path, payoffs);
		}

		return SynchronousPromise.resolve({
			playable: turn,
			path: path
		});
	});
};

_Turn.prototype.setAllPayoffs = function(payoffArray) {
	var turn = this;

	//Recurse through the options in input, to come up with a path to every combination of options in the array of arrays.
	function recurse(input, numPlayers, payoffs, path = [], coordinates = []) {
		return SynchronousPromise.resolve(path).then(function(path) {
			//Since we slice the array each time, if there are no more entries left then we're done with this branch.
			if (input.length == 0) return SynchronousPromise.resolve(path);

			//Among all values from the array
			return SynchronousPromise.all(
				input[0].map(function(item, index) {
					var splitPath = path.slice(0).concat(item);
					var splitCoordinates = coordinates.slice(0).concat(index);
					var splitPayoffs = payoffs[index];

					//If we're at the last position in the array of options, then we have a complete path.
					if (input.length == 1) {
						/* you might need these later
					console.log("path ", splitPath);
					console.log("coordinates ", splitCoordinates)
					console.log("payoff ",splitPayoffs)
					*/

						splitPayoffs = JSON.parse(JSON.stringify(splitPayoffs));

						//Allow the first few array elements to be implicit payoffs. Check that they are actually there and are numbers
						var implicit = splitPayoffs.slice(0, numPlayers);
						if (
							implicit.length == numPlayers &&
							implicit.every(function(payoff) {
								return !isNaN(payoff);
							})
						) {
							outcomeTreeSetValue(turn.payoffsImplicit, splitPath, implicit);
						}

						//Any remaining should be assigned as explicit payoffs, if they're objects.
						splitPayoffs.slice(numPlayers).forEach(function(explicit) {
							if (isObject(explicit))
								outcomeTreeSetValue(turn.payoffsExplicit, splitPath, explicit);
						});
					}

					//If there are more items to iterate over, include them in the output then recurse.
					return recurse(
						input.slice(1),
						numPlayers,
						splitPayoffs,
						splitPath,
						splitCoordinates
					);
				})
			);
		});
	}

	return recurse(turn.choiceMap, turn.choices.length, payoffArray).catch(
		function(reason) {
			log("error", reason);
		}
	);
};

// Adding more complicated summary entry
_Turn.prototype.summaryThis = function(summary, entries, shortCircuit = false) {
	// Fetch summaries for each choice.
	summary.choices = [];
	this.choices.forEach(function(choice, index) {
		summary.choices[index] = choice.summarize(
			summary.choices[index],
			entries,
			true
		);
	});

	// Include payoffs
	summary.payoffs = JSON.parse(
		JSON.stringify({
			implicit: this.payoffsImplicit,
			explicit: this.payoffsExplicit
		})
	);

	return summary;
};

//
_Turn.prototype.summaryNext = function(summary, entries) {
	var turn = this;

	// Create map
	summary.next = {};
	var count = 0;
	recurse(this.choiceMap, summary.next, null, function(path) {
		return outcomeTreeGetValue(turn.next, path).map(function(playable) {
			++count;
			return playable.summarize();
		});
	});

	// If there is no next, delete the key.
	if (count == 0) delete summary.next;
};

function Turn(choices, parameters = {}) {
	var id = idHandler(parameters.id, "turn");

	//Create backend choice object
	var _turn = new _Turn(id, choices, parameters);

	//Return this reference object to the user. Run the function to select a source
	var turn = Playable(_turn);

	_turn.generateChainingFunctions();

	//Function to set all payoffs at once
	turn.setAllPayoffs = function(payoffs) {
		//TODO: Include error handling if array given isn't expected dimensions.
		_turn.setAllPayoffs(payoffs);
	};

	//Way for user to interact with payoffs
	turn.payoffs = function() {
		return JSON.parse(
			JSON.stringify({
				implicit: _turn.payoffsImplicit,
				explicit: _turn.payoffsExplicit
			})
		);
	};

	// Returns the payoffs in nested array form, to make cloning easier, ie. t2.setAllPayoffs(t1.payoffsMatrix())
	turn.payoffsMatrix = function() {

		// recursion to construct payoff matrix
		var mapper = function(obj, path = []) {
			//If it's an array, then we've reached the payoffs
			if (Array.isArray(obj)) {
				var payoff = obj.slice(0)
				// Add explicit payoffs too
				var explicit = outcomeTreeGetValue(_turn.payoffsExplicit, path);

				// Only add an entry if the explicit payoffs object is not empty
				return Object.keys(explicit).length > 0 ? payoff.concat([outcomeTreeGetValue(_turn.payoffsExplicit,
					path)]) : payoff
			}

			// Otherwise, dig in deeper
			else return Object.keys(obj).map(function(key) { return mapper(obj[key], path.slice(0).concat([key])) })
		}
		return mapper(_turn.payoffsImplicit)
	}

	return turn;
}

module.exports = { _Turn, Turn };

},{"../helperFunctions":8,"../history":25,"../information":26,"../logger":27,"../state":50,"./playable":35,"synchronous-promise":71}],43:[function(require,module,exports){
"use strict";

var log = require('./logger');

//Game state controllers
var { registry } = require('./state');

//Helper functions
var { idHandler } = require('./helperFunctions')("state");
var { chainerGenerator } = require('./helperFunctions')("playable");

var { UserHistory } = require('./history');

// Plugins
var PluginManager = require("./plugin-manager")

//Backend for Player
function _Player(id, { name = "", assign = null } = {}) {
	log('silly', 'Creating interal player object.');

	this.id = id
	this.score = 0
	this.name = name;

	this.history = [];

	if (assign) this.assign(assign);

	this.alive = true;
	this.available = true;

	registry.players[id] = this;
}


//Make a copy of the player, in order to take a snapshot. ////TODO try this again sometime.
/*
_Player.prototype.clone = function(){
	//Make new copy. Don't keep more than one.
	delete this.copy

	var clone = new _Player(this.id);

	//Loop through properties and assign them.
	for (var key in this){
		clone[key] = this[key];
	}
	//Do not add to registry. This will keep duplicates out of population.

	//Do add reference so we can find it again.
	this.copy = clone;

	return clone;
};
*/


//Assign strategy to player
_Player.prototype.assign = function(strategy, ...args) {

	//TODO: verify strategy type
	if (registry.strategies[strategy]) {
		this.strategy = new registry.strategies[strategy](...args);
		this.strategy._id = strategy
		this.strategy._args = args
	} else throw new Error("Strategy '" + strategy + "' is not defined");
};


//Call strategy to make a choice
_Player.prototype.choose = function(options, information = {}) { //TODO: check that there's a strategy assigned before trying to play
	var player = this;
	if (player.strategy) {
		let result = player.strategy.choose(options, information)
		if (result) return Promise.resolve(result.toString());
		// If no response, give warning
		else log("warning", "No response from player " + player.id + ". Using default option.")
	}
	// If no strategy, give warning
	else
		log("warning", "No strategy assigned to player " + player.id + ". Using default option.");
	return Promise.resolve(null);
};


//Takes a JSON.parse(JSON.stringify()) copy of _player. Returns a cleaned up version
_Player.prototype.infoClean = function(infoObject) {
	delete infoObject.interface;
	infoObject.strategy = infoObject.strategy ? infoObject.strategy._id : null;

	return infoObject;
};


//Kill player. TODO: add player to some sort of "dead" list to avoid being picked to do things.
_Player.prototype.kill = function() {
	this.alive = false;
};



//Class that is the reference for the user to hold onto
function player() {}


//Frontend for Player
function Player(parameters = {}) {
	var id = idHandler(parameters.id, "player");

	//Create backend player object
	var _player = new _Player(id, parameters);


	//Return this reference object to the user
	var playerInterface = new player(); //Probably add functionality here

	//Tag-back. Store the front-end object in the back-end object, for retrieval
	_player.interface = playerInterface;

	playerInterface.alive = function() {
		return registry.players[id].alive;
	}

	playerInterface.assign = function(strategy, ...args) {
		registry.players[id].assign(strategy, ...args);
	};

	playerInterface.available = function() {
		return registry.players[id].available
	};

	playerInterface.busy = function() {
		registry.players[id].available = false;
	};

	playerInterface.history = function() {
		return new UserHistory(registry.players[id].history);
	};

	playerInterface.id = function() { return id; };

	playerInterface.kill = function() {
		registry.players[id].kill();
	}

	playerInterface.release = function() {
		registry.players[id].available = true;
	};

	playerInterface.resetScore = function() {
		registry.players[id].score = 0;
	}

	playerInterface.score = function() {
		return registry.players[id].score;
	};

	playerInterface.strategy = function() {
		return registry.players[id].strategy._id;
	};

	// PLUGIN: run after player creation
	PluginManager.run("player-create", _player)

	return playerInterface
}




module.exports = { _Player, Player };

},{"./helperFunctions":8,"./history":25,"./logger":27,"./plugin-manager":45,"./state":50}],44:[function(require,module,exports){
/**
 *
 * @type {{}}
 */

function AsyncCtx(callback) {
	this.callback = callback;
	this.sync = true;
}

AsyncCtx.prototype.async = function() {
	this.sync = false;
	return this.callback;
};

/**
 * This is an API meant to be used only from synchronous
 * callbacks into an asynchronous like hook.
 *
 * it represent continuity from the "sync()" or "waterfall()"
 * plugin management
 */
AsyncCtx.prototype.stop = function() {
	var callback = this.async();
	callback(true);
};

module.exports = AsyncCtx;
},{}],45:[function(require,module,exports){
// Stolen liberally and brazenly from "polite-plugin-manager".
"use strict";

const pluginDirectoryPath = "../../plugins/"
// Hack to compile Glob files for browserify. Don´t call this function!
function $_DONOTCALL() {
	require('../../plugins/balance-sheet-complex.js');require('../../plugins/balance-sheet.js')
}

/**
 * Polite Plugin Manager
 * register and run hooks granting extendability
 *
 */


// Global Dependencies
var fs = require('fs'),
	path = require('path'),
	extend = require('extend'),
	async = require('async'),

	// Local Modules
	AsyncCtx = require('./async-ctx'),
	WaterfallCtx = require('./waterfall-ctx'),
	PluginNameError = require('./plugin-name-error'),
	PluginCallbackError = require('./plugin-callback-error');


// ------------------------------------------------------------------------------------ //
// ---[[   C O N S T R U C T O R   A N D   L I F E C Y C L E   U T I L I T I E S   ]]-- //
// ------------------------------------------------------------------------------------ //

var PluginManager = {},
	packages = [],
	packageNames = [],
	hooks = {},
	skipProps = ['module', 'name', 'priority', 'active', 'init', 'require', 'stop', 'public', 'settings'];



PluginManager.reset = function() {
	packages = [];
	packageNames = [];
	hooks = {};
	return this;
};

/**
 * Apply package sorting,
 * register packages into hooks,
 * run packages init() method
 */
PluginManager.start = function(callback) {

	var self = this,
		inits = [];

	// sort by priorities
	packages.sort(function(a, b) {
		return a.priority > b.priority;
	});

	// register init & hooks
	// hooks are all functions who are not special properties
	// identified by "skipProps" list
	packages.forEach(function(pkg) {
		if (pkg.init) {
			inits.push(pkg.init);
		}
		for (var prop in pkg) {
			if (skipProps.indexOf(prop) === -1 && typeof pkg[prop] == 'function') {
				PluginManager.registerHook(prop, pkg[prop]);
			}
		}
	});

	// run all package.init() method in series!
	if (inits.length) {
		async.eachSeries(inits, function(fn, done) {

			var context = new AsyncCtx(done),
				result = fn.apply(context);

			// sync false stop initialization cycle!
			if (context.sync) {
				if (result === false) {
					callback.call(self);
				} else {
					done(result);
				}
			}

		}, callback.bind(this));
	} else {
		callback.call(self);
	}

	return this;
};




// --------------------------------- //
// ---[[   H O O K S   A P I   ]]--- //
// --------------------------------- //

PluginManager.registerHook = function(hookName, hookFn, hookPriority = 100) {
	hookFn.priority = hookPriority;

	if (!hooks[hookName]) {
		hooks[hookName] = [];
	}

	hooks[hookName].push(hookFn);
	return this;
};


PluginManager.isEmpty = function(hookName) {
	if (hooks[hookName] && hooks[hookName].length) {
		return false;
	} else {
		return true;
	}
};



/**
 * Run registered hook callbacks in series
 * (it supports asynchronous callbacks)
 */
PluginManager.run = function(hookName, ...args) {

	// Use the runWithCallback but with blank callback.
	PluginManager.runWithCallback(hookName, ...args, function() {})
};

// Same as above, but use last argument as callback
PluginManager.runWithCallback = function(hookName, ...args) {

	// collect hookName property
	if (!hookName) throw new PluginNameError('missing plugin name!');

	// obtain async callback
	if (!args.length || typeof args[args.length - 1] !== 'function') {
		throw new PluginCallbackError('[' + hookName + '] missing callback for async plugin!');
	} else {
		var callback = args.pop();
	}


	// check for some callbacks existance
	// [???] may give out an exception when no callbacks were found!
	if (!hooks[hookName] || !hooks[hookName].length) {
		callback(false);
		return false;
	}

	// Sort hooks by priority
	hooks[hookName].sort(function(a, b) {
		return a.priority > b.priority
	})

	// run async queque
	// NOTE: a step function should stop the queque by done(true)
	async.eachSeries(hooks[hookName], function(fn, done) {
		var context = new AsyncCtx(done),
			result = fn.apply(context, args);

		if (context.sync) {
			if (result === false) {
				callback();
			} else {
				done(result);
			}
		}
	}, callback);

	return true;
}

/**
 * Run registered hook callbacks in parallel
 * (it supports asynchronous callbacks)
 * @param hookName
 */

PluginManager.parallel = function() {

	var hookName = '',
		callback = null,
		args = Array.prototype.slice.call(arguments);

	// collect hookName property
	if (!args.length) {
		throw new PluginNameError('missing plugin name!');
	} else {
		hookName = args.shift();
	}

	// obtain async callback
	if (!args.length || typeof args[args.length - 1] !== 'function') {
		throw new PluginCallbackError('[' + hookName + '] missing callback for async plugin!');
	} else {
		callback = args[args.length - 1];
	}

	// check for some callbacks existance
	// [???] may give out an exception when no callbacks were found!
	if (!hooks[hookName] || !hooks[hookName].length) {
		callback(false);
		return false;
	}

	// run async in parallel
	// NOTE: a step function should stop the queque by done(true)
	async.each(hooks[hookName], function(fn, done) {
		var context = new AsyncCtx(done),
			result = fn.apply(context, args);

		// handle sync callbacks
		if (context.sync) {
			done(result);
		}
	}, callback);

	return true;
};


/**
 * WATERFALL
 * Run a hook as a normal function in a fully syncronous mode
 * Each hookFn should return a value who's forward as first argument for the next one
 * last hookFn return value is the final output
 */
PluginManager.waterfall = function(hookName) {

	if (!hookName) {
		throw new PluginNameError('missing plugin name!');
	}

	var args = Array.prototype.slice.call(arguments);
	args.shift();

	if (hooks[hookName]) {
		// use known exception to exit forEach cycle implementing a stoppable watefall
		// (http://stackoverflow.com/questions/2641347/how-to-short-circuit-array-foreach-like-calling-break?answertab=votes#tab-top)
		var WaterfallBreakException = {};
		try {
			hooks[hookName].forEach(function(fn) {
				var context = new WaterfallCtx(),
					result = fn.apply(context, args);

				if (args.length) {
					args[0] = result;
				}

				if (context.stopped) {
					throw WaterfallBreakException;
				}

			});
		} catch (e) {
			if (e !== WaterfallBreakException) throw e;
		}
	}

	if (args.length) {
		return args[0];
	} else {
		return;
	}
};




// --------------------------------------- //
// ---[[   P A C K A G E S   A P I   ]]--- //
// --------------------------------------- //

function getPackageByName(name) {
	var list = packages.filter(function(pkg) { return (pkg.name === name) })
	if (list.length == 1) return list[0]
	else return list;
}

// Package class
function Package(module, name = null, context = null) {
	// Basic assignment and default values
	Object.assign(this, {
		module,
		name,
		priority: 100,
		active: false,
		init: function() {},
		require: function() {},
		stop: function() {},
		settings: function() {},
		public: {}
	})
	// Package-defined values and hooks
	Object.assign(this, module(context || {}))

	// add to registry
	// Check to see if it's the same module being loaded twice, or different modules with the same name
	if (packageNames.includes(this.name)) {
		if (this.module === getPackageByName(this.name).module) {
			// Same module. Do nothing
		} else {
			// Different modules with same name, handle name conflict.
			//TODO: figure out how to handle name conflict.
		}
	}
	// No name conflict, add to registry
	else {
		packages.push(this);
		packageNames.push(this.name)
	}
}

Package.prototype.registerHooks = function() {
	var pkg = this;
	for (var prop in pkg) {
		if (skipProps.indexOf(prop) === -1 && typeof pkg[prop] == 'function') {
			PluginManager.registerHook(prop, pkg[prop]);
		}
	}
}

// Create interface for user to interact with package.
function PackageInterface(pkg) {

	// Merge any public items specified by the package with this interface format
	return Object.assign({}, pkg.public, {
		name: function() { return pkg.name },
		priority: function() { return pkg.priority },
		active: function() { return pkg.active },

		init: function(...args) {
			pkg.init(...args);
			pkg.registerHooks();
			pkg.active = true;
			return Object.assign(this, pkg.publicIfActive);
		},
		require: function(...args) {
			if (pkg.active) pkg.require(...args);
			else {
				pkg.init(...args);
				pkg.registerHooks();
				Object.assign(this, pkg.publicIfActive);
			}
			pkg.active = true;

			return this;
		},
		stop: function(...args) {
			if (pkg.active) pkg.stop(...args);
			pkg.active = false;
		},
		settings: function(...args) {
			return pkg.settings(...args);
		}

	}, pkg.active ? pkg.publicIfActive : null);
}




/**
 * Load a plugin package by folder path
 * @param sourceFolder
 */
PluginManager.package = function(source, context) {
	if (packageNames.includes(source)) {
		// Already loaded module, just return it
		return PackageInterface(getPackageByName(source))
	} else {
		var name = path.basename(source),
			module = require(pluginDirectoryPath + source + '.js')

		// obtain package informations and apply some default values
		var pkg = new Package(module, name, context)
		return PackageInterface(pkg)
	}
}

/*
			load: function(callback = function() {}, ...initArgs) {
				var self = pm,
					inits = [],


					// register init & hooks
					// hooks are all functions who are not special properties
					// identified by "skipProps" list

					if (pkg.init) {
						inits.push(pkg.init);
					}


				// run all package.init() method in series! //EDIT: will only be the one
				if (inits.length) {
					async.eachSeries(inits, function(fn, done) {

						var context = new AsyncCtx(done),
							result = fn.apply(context, initArgs);

						// sync false stop initialization cycle!
						if (context.sync) {
							if (result === false) {
								callback.call(self);
							} else {
								done(result);
							}
						}

					}, callback.bind(self));
				} else {
					callback.call(self);
				}

				return self;
			}

		};
	};
*/

/** TODO: this doesn't work right now
 * Load all packages from a given folder path
 * (syncronous)
 */
PluginManager.registerMany = function(sourceFolder, context) {
	var self = this;

	if (fs.existsSync(sourceFolder)) {
		fs.readdirSync(sourceFolder).forEach(function(item) {
			var itemPath = sourceFolder + '/' + item,
				itemStat = fs.lstatSync(itemPath);

			if (itemStat.isDirectory()) {
				self.loadPackage(itemPath, context);
			}
		});
	}

	return this;
};

module.exports = PluginManager

},{"../../plugins/balance-sheet-complex.js":72,"../../plugins/balance-sheet.js":73,"./async-ctx":44,"./plugin-callback-error":46,"./plugin-name-error":47,"./waterfall-ctx":48,"async":55,"extend":62,"fs":1,"path":2}],46:[function(require,module,exports){

function PluginCallbackError(message) {
	this.name = "PluginCallbackError";
	this.message = (message || "");
}


PluginCallbackError.prototype = new Error();
PluginCallbackError.prototype.constructor = PluginCallbackError;

module.exports = PluginCallbackError;
},{}],47:[function(require,module,exports){

function PluginNameError(message) {
	this.name = "PluginNameError";
	this.message = (message || "");
}


PluginNameError.prototype = new Error();
PluginNameError.prototype.constructor = PluginNameError;

module.exports = PluginNameError;
},{}],48:[function(require,module,exports){
/**
 *
 * @type {{}}
 */

function WaterfallCtx() {
	this.stopped = false;
}

WaterfallCtx.prototype.stop = function() {
	this.stopped = true;
};

module.exports = WaterfallCtx;
},{}],49:[function(require,module,exports){
"use strict";

var log = require("./logger");

//Helper functions
var { isFunction, isObject } = require("./helperFunctions")("general");

//Game state controllers
var { registry } = require("./state");

var { _Player } = require("./player");

//Class PlayerList is a list of players which includes some extra functionality. UserPlayerList takes a playerList and
//sanitizes it for the user (ie returns .interface for each player).

function PlayerList(...args) {
	if (Array.isArray(args[0])) args = args[0].slice(0);
	if (args == "all") return gamePopulation();

	// We'll need to retain the original arguments in order to create the generator
	var originalArgs = []

	// Loop over the arguments, save the originals, parse them to _players
	for (var i = 0, len = args.length; i < len; i++) {
		originalArgs.push(args[i]);
		if (isFunction(args[i].id)) args[i] = registry.players[args[i].id()];
		else if (typeof args[i] === 'string') args[i] = registry.players[args[i]]
	}

	Object.setPrototypeOf(args, PlayerList.prototype);

	// returns the same playerlist, but updated, using the original args.
	args.generator = function() {
		return new PlayerList(originalArgs);
	};

	return args;
}

PlayerList.prototype = Object.create(Array.prototype);
PlayerList.prototype.constructor = PlayerList;


// Assign a strategy en masse
PlayerList.prototype.assign = function(strategyName) {
	this.forEach(function(player) {
		player.assign(strategyName)
	})
	return this;
}


//Return a PlayerList minus the specified players.
//Argument can be _player, interface, or a player's id.
PlayerList.prototype.exclude = function(playerArg) {
	if (Array.isArray(playerArg))
		return playerArg.reduce(function(running, item) {
			return running.exclude(item);
		}, this);

	return new PlayerList(
		this.filter(function(player) {
			if (
				playerArg === player ||
				playerArg == player.interface ||
				playerArg == player.id ||
				(isObject(playerArg) && playerArg.id == player.id)
			)
				return false;
			else return true;
		})
	);
};


// Placeholder for generator method.
PlayerList.prototype.generator = function() {
	// This will get shadowed when the constructor is called, but it needs to be here so that the
	// UserPlayerList and InfoPlayerList constructors can see it.
}


//Create an InfoPlayerList out of this PlayerList. Useful for getting summary view.
PlayerList.prototype.info = function() {
	return new InfoPlayerList(this);
};


//Return array of ids of each player in the list
PlayerList.prototype.ids = function() {
	return this.map(function(player) {
		return player.id;
	});
};


//Kill all players in the playerList
PlayerList.prototype.kill = function() {
	this.forEach(function(player) {
		player.kill();
	});
	return this;
};


//Returns the single player with the highest score
PlayerList.prototype.leader = function() {
	var players = this.slice();

	players.sort(function(a, b) {
		return b.score - a.score;
	});

	players = players.filter(function(player) {
		return player.score == players[0].score
	})


	return players.length > 1 ? new PlayerList(players) : players[0];
};


PlayerList.prototype.release = function() {
	this.forEach(function(player) {
		player.available = true;
	});
	return this;
};



//Return a playerList with only the players who are available
PlayerList.prototype.onlyAlive = function() {
	return new PlayerList(
		this.filter(function(player) {
			return player.alive;
		})
	);
};


//Return a playerList with only the players who are available
PlayerList.prototype.onlyAvailable = function() {
	return new PlayerList(
		this.filter(function(player) {
			return player.available;
		})
	);
};


//Returns an array of scores of each player in the list
PlayerList.prototype.scores = function() {
	var scores = [];

	this.forEach(function(player) {
		scores.push(player.score); //Use the interface function to avoid users re-assigning the reference
	});
	return scores;
};


// Returns an object where each key is a strategy and each value is an array of the scores of players with that strategy.
// TODO: finish .total() method, which will sum the arrays (duplicating .scoresByStrategyTotals)
PlayerList.prototype.scoresByStrategy = function() {
	var scores = {};
	var list = this;

	list.strategies().map(function(strategy) {
		scores[strategy] = list.usingStrategy(strategy).scores();
	});

	scores.total = function() {
		var score = {};
		var scores = this;
		Object.keys(scores).forEach(function(strategy) {
			if (Array.isArray(scores[strategy])) score[strategy] = scores[strategy].reduce(function(a, b) {
				return a + b;
			}, 0);
		});
		return score;
	};

	return scores;
};

// Returns an object where each key is a strategy and each value is the sum of scores of all players with that value
PlayerList.prototype.scoresByStrategyTotals = function() {
	var scores = {};
	var list = this;

	list.strategies().map(function(strategy) {
		scores[strategy] = list
			.usingStrategy(strategy)
			.scores()
			.reduce(function(a, b) {
				return a + b;
			}, 0);
	});

	return scores;
};

//Returns an object where the keys are the player ids and the values
//are the players' score
PlayerList.prototype.scoresObject = function() {
	var scores = {};

	this.forEach(function(player) {
		scores[player.id] = player.score;
	});

	return scores;
};

//Mean of the scores
PlayerList.prototype.scoresMean = function() {
	var scores = this.scores();

	var mean =
		scores.reduce(function(sum, value) {
			return sum + value;
		}, 0) / scores.length;

	return mean;
};

//Array with 2 entries, the lowest and highest score
PlayerList.prototype.scoresRange = function() {
	var scores = this.scores();

	scores.sort(function(a, b) {
		return a - b;
	});

	return [scores[0], scores[scores.length - 1]];
};

//The standard deviation of the scores
PlayerList.prototype.scoresStd = function() {
	var scores = this.scores();
	var mean = this.scoresMean();

	var variance =
		scores.reduce(function(sum, value) {
			return sum + Math.pow(value - mean, 2);
		}, 0) / scores.length;

	var std = Math.sqrt(variance);

	return std;
};


//Return an array of the strategy of each player in the list
PlayerList.prototype.strategies = function() {
	return this.map(function(player) {
		return player.strategy ? player.strategy._id : "";
	});
};

//Return a PlayerList with only players using a given strategy
PlayerList.prototype.usingStrategy = function(strategy) {
	return new PlayerList(
		this.filter(function(player) {
			if (
				player.strategy == strategy ||
				player.strategy._id == strategy ||
				(isFunction(strategy) && player.strategy instanceof strategy)
			)
				return true;
			else return false;
		})
	);
};

/*

TODO figure out how to make this work

//Returns an object where the keys are strategy names and the values are arrays of players.
//This needs to be overridden on the UserPlayerList prototype, because the normal wrapper logic
//for UserPlayerList cannot sanitize this.
PlayerList.prototype.byStrategy = function(){
	var list = this;
	var data = {};

	Object.keys(registry.strategies).forEach(function(strategy){
		data[strategy] = list.usingStrategy(strategy);
	});

	return data;
};
*/

//Returns an object where the keys are each strategy and the values
//are the number of players in the list who are using it.
PlayerList.prototype.strategyDistribution = function() {
	var counts = {};

	this.forEach(function(player) {
		var s = player.strategy._id;
		counts[s] = (counts[s] || 0) + 1;
	});

	return counts;
};



PlayerList.prototype.resetScores = function() {
	this.forEach(function(player) {
		player.score = 0;
	});
	return this;
};

//Accept a PlayerList and return one suitable for the user, or create a playerlist and return one suitable for the user
function UserPlayerList(...playerList) {
	if (Array.isArray(playerList[0])) playerList = playerList[0];

	// If we've got a playerList, return the interface of each player
	if (playerList instanceof PlayerList) {
		var userPlayerList = playerList.map(function(player) {
			return player.interface;
		});
	}
	// If not, first create a playerList, then call this function again to wrap it.
	else return new UserPlayerList(new PlayerList(playerList));

	Object.setPrototypeOf(userPlayerList, UserPlayerList.prototype);

	//Attach methods from PlayerList, wrapped in a function. If those methods return a playerList,
	//then the function will convert that to a UserPlayerList.
	for (var method in PlayerList.prototype) {
		if (isFunction(playerList[method])) {
			if (method != "constructor")
				userPlayerList[method] = (function(method) {
					return function() {
						var result = playerList[method].apply(playerList, arguments);
						if (result instanceof PlayerList) return new UserPlayerList(result);
						else if (result instanceof _Player) return result.interface;
						else return result;
					};
				})(method);
		}
	}

	return userPlayerList;
}

UserPlayerList.prototype = Object.create(PlayerList.prototype);
UserPlayerList.prototype.constructor = UserPlayerList;

//Accept a PlayerList and return one suitable for a strategy information set.
function InfoPlayerList(playerList) {
	var infoPlayerList = playerList.map(function(player) {
		return player.infoClean(JSON.parse(JSON.stringify(player)));
	});

	Object.setPrototypeOf(infoPlayerList, InfoPlayerList.prototype);

	//Attach selected methods from PlayerList, wrapped in a function. If those methods return a playerList,
	//then the function will convert that to an InfoPlayerList.
	var methodsToInclude = [
		"onlyAlive",
		"onlyAvailable",
		"ids",
		"exclude",
		"generator",
		"strategies",
		"usingStrategy",
		"strategyDistribution",
		"scores",
		"scoresObject",
		"scoresMean",
		"scoresRange",
		"scoresStd",
		"leader"
	];

	for (var method in PlayerList.prototype) {
		if (isFunction(playerList[method])) {
			if (methodsToInclude.indexOf(method) > -1)
				infoPlayerList[method] = (function(method) {
					return function() {
						var result = playerList[method].apply(playerList, arguments);
						if (result instanceof PlayerList) return new InfoPlayerList(result);
						else if (result instanceof _Player)
							return result.infoClean(JSON.parse(JSON.stringify(result)));
						else return result;
					};
				})(method);
		}
	}

	return infoPlayerList;
}

InfoPlayerList.prototype = Object.create(Array.prototype);
InfoPlayerList.prototype.constructor = InfoPlayerList;

//Extra method to return a single player from an infoPlayerList
InfoPlayerList.prototype.get = function(playerID) {
	return this.find(function(player) {
		return player.id == playerID;
	});
};

//Generates a PlayerList containing all players.
var gamePopulation = function() {
	var population = [];

	for (var player in registry.players) {
		population.push(registry.players[player]);
	}

	return new PlayerList(population);
};

//Does the same, but a UserPlayerList
var Population = function() {
	return new UserPlayerList(gamePopulation());
};

//Does the same, but an InfoPlayerList
var InfoPopulation = function() {
	return new InfoPlayerList(gamePopulation());
};

//A short-hand to return total population size without creating a PlayerList
Population.size = function() {
	return Object.keys(registry.players).length;
};

module.exports = {
	PlayerList,
	UserPlayerList,
	InfoPlayerList,
	gamePopulation,
	Population,
	InfoPopulation
};

},{"./helperFunctions":8,"./logger":27,"./player":43,"./state":50}],50:[function(require,module,exports){
"use strict";

var log = require('./logger');

log("debug", "state: Creating game state variables.")


var registry = {}
registry._addType_ = function(type){	
	registry[type] = {};
	log("silly", "state: adding registry entry: ", type)
};


var idCounters = {}
idCounters._addType_ = function(type){
	idCounters[type] = 0
	log("silly", "state: adding counter entry: ", type)
};





module.exports = {registry, idCounters};
},{"./logger":27}],51:[function(require,module,exports){
"use strict";

const nashName = "./core"; //Change this when published, probably to 'nash-js'

var fs = require("fs");

var { registerStrategy, registerStrategyObject } = require('./strategy');

//Check to see if parsed expression is call to require or eval
function isBannedCall(node) {
	return (node.type === 'CallExpression') &&
		(node.callee.type === 'MemberExpression') &&
		(node.callee.object.type === 'Identifier') &&
		((node.callee.object.name === 'require') || (node.callee.object.name === 'eval'));
}


function removeCalls(source) {
	const entries = [];
	esprima.parseScript(source, {}, function(node, meta) {
		if (isBannedCall(node)) {
			entries.push({
				start: meta.start.offset,
				end: meta.end.offset
			});
		}
	});
	entries.sort((a, b) => { return b.end - a.end }).forEach(n => {
		source = source.slice(0, n.start) + " null; " + source.slice(n.end);
	});
	return source;
}



var loadStrategy = function(filepath, trusted = false) {
	var compiler = require('expression-sandbox');

	var source = fs.readFileSync(filepath);

	if (!trusted) {
		var originalSource = source;
		var parsedSource = removeCalls(source);

		if (originalSource != parsedSource) throw new Error("Strategy " + filepath + " uses require or eval.");
	}

	source = "\"use strict\"; \n " + source;
	compiler(source)({ registerStrategy, registerStrategyObject });

}; //TODO: change this so that strategies can't require any modules.



function loadStrategyFolder(path, trusted = false) {
	var files = fs.readdirSync(path);
	files.forEach(function(file) {
		var filePath = path + '/' + file;
		loadStrategy(filepath);
	});
};


module.exports = { loadStrategy, loadStrategyFolder };

},{"./strategy":52,"expression-sandbox":60,"fs":1}],52:[function(require,module,exports){
"use strict";

var log = require('./logger');

//Javascript code parser
var esprima = require('esprima');

//Game state controllers
var { registry } = require('./state');

//Helper functions
var { idHandler } = require('./helperFunctions')("state");



//User interface to declare strategy type.
function registerStrategy(strategy, name, description = "No description given.", playerName = "") {
	var id = idHandler(name, "strategy");

	if (id !== name) {
		//There was already a strategy registered with this name.
		//Check to see if it's the same strategy or not.
		if (!registry.strategies[id] === strategy) {
			//They're different, so we have a name conflict.
			throw new Error("Strategy name conflict with " + name);

		} else {
			// They're the same, do nothing.
			return true;
		}
	}

	// No name conflict and strategy not loaded yet. Add to registry.
	log("debug", "Loading strategy '" + id + "'")
	strategy.playerName = playerName;
	strategy.description = description;
	registry.strategies[id] = strategy;
	return name;
}

function registerStrategyObject(strategyObject) {
	// If multiple strategies, split into individuals
	if (Array.isArray(strategyObject)) return strategyObject.map(registerStrategyObject)

	return registerStrategy(strategyObject.strategy, strategyObject.name, strategyObject.description,
		strategyObject.playerName)
}

//Strip out requires and such
function sanitizeStrategy(strategy) {
	// console.log(x) or console['error'](y)
	function isRequireCall(node) {
		return (node.type === 'CallExpression') &&
			(node.callee.type === 'MemberExpression') &&
			(node.callee.object.type === 'Identifier') &&
			(node.callee.object.name === 'require');
	}

	function removeCalls(source) {
		const entries = [];
		esprima.parseScript(source, {}, function(node, meta) {
			if (isRequireCall(node)) {
				entries.push({
					start: meta.start.offset,
					end: meta.end.offset
				});
			}
		});
		entries.sort((a, b) => { return b.end - a.end }).forEach(n => {
			source = source.slice(0, n.start) + source.slice(n.end);
		});
		return source;
	}

	removeCalls(strategy.toString());

}

//Returns to the user an array of all registered strategies. TODO: have this mirror PlayerList, to provide functionality like onlyAlive and scoresObject.
function Strategies() {
	var strategies = [];
	for (var strategy in registry.strategies) strategies.push(strategy);
	return strategies;
};

// Fetch the descriptions of the strategies.
Strategies.descriptions = function() {
	var strategies = {};
	for (var strategy in registry.strategies) strategies[strategy] = registry.strategies[strategy].description;
	return strategies;
}


// A built-in debugging strategy. Calling this function loads the strategy.
// The strategy just calles 'debugger' when asked to choose.
Strategies.debugger = function() {
	registerStrategy(function() {
		this.choose = function(options, information) {
			debugger;
		}
	}, "debugger")
	return "debugger"
}

Strategies.logger = function() {
	registerStrategy(function() {
		this.choose = function(options, information) {
			console.log("Options: ", options);
			console.log("Information: ", information)
		}
	}, "logger")
	return "logger"
}

module.exports = { registerStrategy, registerStrategyObject, Strategies };

},{"./helperFunctions":8,"./logger":27,"./state":50,"esprima":59}],53:[function(require,module,exports){
'use strict';
module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};

},{}],54:[function(require,module,exports){
'use strict';

function assembleStyles () {
	var styles = {
		modifiers: {
			reset: [0, 0],
			bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		colors: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39]
		},
		bgColors: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49]
		}
	};

	// fix humans
	styles.colors.grey = styles.colors.gray;

	Object.keys(styles).forEach(function (groupName) {
		var group = styles[groupName];

		Object.keys(group).forEach(function (styleName) {
			var style = group[styleName];

			styles[styleName] = group[styleName] = {
				open: '\u001b[' + style[0] + 'm',
				close: '\u001b[' + style[1] + 'm'
			};
		});

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	});

	return styles;
}

Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});

},{}],55:[function(require,module,exports){
(function (process){
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                }
            }));
        });
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _each(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor !== Array) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (test()) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (!test()) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if(data.constructor !== Array) {
              data = [data];
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain) cargo.drain();
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.compose = function (/* functions... */) {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // Node.js
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))

},{"_process":3}],56:[function(require,module,exports){
(function (process){
'use strict';
var escapeStringRegexp = require('escape-string-regexp');
var ansiStyles = require('ansi-styles');
var stripAnsi = require('strip-ansi');
var hasAnsi = require('has-ansi');
var supportsColor = require('supports-color');
var defineProps = Object.defineProperties;
var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);

function Chalk(options) {
	// detect mode if not set manually
	this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
}

// use bright blue on Windows as the normal blue color is illegible
if (isSimpleWindowsTerm) {
	ansiStyles.blue.open = '\u001b[94m';
}

var styles = (function () {
	var ret = {};

	Object.keys(ansiStyles).forEach(function (key) {
		ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

		ret[key] = {
			get: function () {
				return build.call(this, this._styles.concat(key));
			}
		};
	});

	return ret;
})();

var proto = defineProps(function chalk() {}, styles);

function build(_styles) {
	var builder = function () {
		return applyStyle.apply(builder, arguments);
	};

	builder._styles = _styles;
	builder.enabled = this.enabled;
	// __proto__ is used because we must return a function, but there is
	// no way to create a function with a different prototype.
	/* eslint-disable no-proto */
	builder.__proto__ = proto;

	return builder;
}

function applyStyle() {
	// support varags, but simply cast to string in case there's only one arg
	var args = arguments;
	var argsLen = args.length;
	var str = argsLen !== 0 && String(arguments[0]);

	if (argsLen > 1) {
		// don't slice `arguments`, it prevents v8 optimizations
		for (var a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || !str) {
		return str;
	}

	var nestedStyles = this._styles;
	var i = nestedStyles.length;

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	var originalDim = ansiStyles.dim.open;
	if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
		ansiStyles.dim.open = '';
	}

	while (i--) {
		var code = ansiStyles[nestedStyles[i]];

		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;
	}

	// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
	ansiStyles.dim.open = originalDim;

	return str;
}

function init() {
	var ret = {};

	Object.keys(styles).forEach(function (name) {
		ret[name] = {
			get: function () {
				return build.call(this, [name]);
			}
		};
	});

	return ret;
}

defineProps(Chalk.prototype, init());

module.exports = new Chalk();
module.exports.styles = ansiStyles;
module.exports.hasColor = hasAnsi;
module.exports.stripColor = stripAnsi;
module.exports.supportsColor = supportsColor;

}).call(this,require('_process'))

},{"_process":3,"ansi-styles":54,"escape-string-regexp":58,"has-ansi":63,"strip-ansi":70,"supports-color":57}],57:[function(require,module,exports){
(function (process){
'use strict';
var argv = process.argv;

var terminator = argv.indexOf('--');
var hasFlag = function (flag) {
	flag = '--' + flag;
	var pos = argv.indexOf(flag);
	return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
};

module.exports = (function () {
	if ('FORCE_COLOR' in process.env) {
		return true;
	}

	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false')) {
		return false;
	}

	if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
})();

}).call(this,require('_process'))

},{"_process":3}],58:[function(require,module,exports){
'use strict';

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(matchOperatorsRe, '\\$&');
};

},{}],59:[function(require,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
/* istanbul ignore next */
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
/* istanbul ignore next */
	else if(typeof exports === 'object')
		exports["esprima"] = factory();
	else
		root["esprima"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/* istanbul ignore if */
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/*
	  Copyright JS Foundation and other contributors, https://js.foundation/

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	var comment_handler_1 = __webpack_require__(1);
	var jsx_parser_1 = __webpack_require__(3);
	var parser_1 = __webpack_require__(8);
	var tokenizer_1 = __webpack_require__(15);
	function parse(code, options, delegate) {
	    var commentHandler = null;
	    var proxyDelegate = function (node, metadata) {
	        if (delegate) {
	            delegate(node, metadata);
	        }
	        if (commentHandler) {
	            commentHandler.visit(node, metadata);
	        }
	    };
	    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;
	    var collectComment = false;
	    if (options) {
	        collectComment = (typeof options.comment === 'boolean' && options.comment);
	        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);
	        if (collectComment || attachComment) {
	            commentHandler = new comment_handler_1.CommentHandler();
	            commentHandler.attach = attachComment;
	            options.comment = true;
	            parserDelegate = proxyDelegate;
	        }
	    }
	    var isModule = false;
	    if (options && typeof options.sourceType === 'string') {
	        isModule = (options.sourceType === 'module');
	    }
	    var parser;
	    if (options && typeof options.jsx === 'boolean' && options.jsx) {
	        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
	    }
	    else {
	        parser = new parser_1.Parser(code, options, parserDelegate);
	    }
	    var program = isModule ? parser.parseModule() : parser.parseScript();
	    var ast = program;
	    if (collectComment && commentHandler) {
	        ast.comments = commentHandler.comments;
	    }
	    if (parser.config.tokens) {
	        ast.tokens = parser.tokens;
	    }
	    if (parser.config.tolerant) {
	        ast.errors = parser.errorHandler.errors;
	    }
	    return ast;
	}
	exports.parse = parse;
	function parseModule(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'module';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseModule = parseModule;
	function parseScript(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'script';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseScript = parseScript;
	function tokenize(code, options, delegate) {
	    var tokenizer = new tokenizer_1.Tokenizer(code, options);
	    var tokens;
	    tokens = [];
	    try {
	        while (true) {
	            var token = tokenizer.getNextToken();
	            if (!token) {
	                break;
	            }
	            if (delegate) {
	                token = delegate(token);
	            }
	            tokens.push(token);
	        }
	    }
	    catch (e) {
	        tokenizer.errorHandler.tolerate(e);
	    }
	    if (tokenizer.errorHandler.tolerant) {
	        tokens.errors = tokenizer.errors();
	    }
	    return tokens;
	}
	exports.tokenize = tokenize;
	var syntax_1 = __webpack_require__(2);
	exports.Syntax = syntax_1.Syntax;
	// Sync with *.json manifests.
	exports.version = '4.0.0';


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	var CommentHandler = (function () {
	    function CommentHandler() {
	        this.attach = false;
	        this.comments = [];
	        this.stack = [];
	        this.leading = [];
	        this.trailing = [];
	    }
	    CommentHandler.prototype.insertInnerComments = function (node, metadata) {
	        //  innnerComments for properties empty block
	        //  `function a() {/** comments **\/}`
	        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
	            var innerComments = [];
	            for (var i = this.leading.length - 1; i >= 0; --i) {
	                var entry = this.leading[i];
	                if (metadata.end.offset >= entry.start) {
	                    innerComments.unshift(entry.comment);
	                    this.leading.splice(i, 1);
	                    this.trailing.splice(i, 1);
	                }
	            }
	            if (innerComments.length) {
	                node.innerComments = innerComments;
	            }
	        }
	    };
	    CommentHandler.prototype.findTrailingComments = function (metadata) {
	        var trailingComments = [];
	        if (this.trailing.length > 0) {
	            for (var i = this.trailing.length - 1; i >= 0; --i) {
	                var entry_1 = this.trailing[i];
	                if (entry_1.start >= metadata.end.offset) {
	                    trailingComments.unshift(entry_1.comment);
	                }
	            }
	            this.trailing.length = 0;
	            return trailingComments;
	        }
	        var entry = this.stack[this.stack.length - 1];
	        if (entry && entry.node.trailingComments) {
	            var firstComment = entry.node.trailingComments[0];
	            if (firstComment && firstComment.range[0] >= metadata.end.offset) {
	                trailingComments = entry.node.trailingComments;
	                delete entry.node.trailingComments;
	            }
	        }
	        return trailingComments;
	    };
	    CommentHandler.prototype.findLeadingComments = function (metadata) {
	        var leadingComments = [];
	        var target;
	        while (this.stack.length > 0) {
	            var entry = this.stack[this.stack.length - 1];
	            if (entry && entry.start >= metadata.start.offset) {
	                target = entry.node;
	                this.stack.pop();
	            }
	            else {
	                break;
	            }
	        }
	        if (target) {
	            var count = target.leadingComments ? target.leadingComments.length : 0;
	            for (var i = count - 1; i >= 0; --i) {
	                var comment = target.leadingComments[i];
	                if (comment.range[1] <= metadata.start.offset) {
	                    leadingComments.unshift(comment);
	                    target.leadingComments.splice(i, 1);
	                }
	            }
	            if (target.leadingComments && target.leadingComments.length === 0) {
	                delete target.leadingComments;
	            }
	            return leadingComments;
	        }
	        for (var i = this.leading.length - 1; i >= 0; --i) {
	            var entry = this.leading[i];
	            if (entry.start <= metadata.start.offset) {
	                leadingComments.unshift(entry.comment);
	                this.leading.splice(i, 1);
	            }
	        }
	        return leadingComments;
	    };
	    CommentHandler.prototype.visitNode = function (node, metadata) {
	        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
	            return;
	        }
	        this.insertInnerComments(node, metadata);
	        var trailingComments = this.findTrailingComments(metadata);
	        var leadingComments = this.findLeadingComments(metadata);
	        if (leadingComments.length > 0) {
	            node.leadingComments = leadingComments;
	        }
	        if (trailingComments.length > 0) {
	            node.trailingComments = trailingComments;
	        }
	        this.stack.push({
	            node: node,
	            start: metadata.start.offset
	        });
	    };
	    CommentHandler.prototype.visitComment = function (node, metadata) {
	        var type = (node.type[0] === 'L') ? 'Line' : 'Block';
	        var comment = {
	            type: type,
	            value: node.value
	        };
	        if (node.range) {
	            comment.range = node.range;
	        }
	        if (node.loc) {
	            comment.loc = node.loc;
	        }
	        this.comments.push(comment);
	        if (this.attach) {
	            var entry = {
	                comment: {
	                    type: type,
	                    value: node.value,
	                    range: [metadata.start.offset, metadata.end.offset]
	                },
	                start: metadata.start.offset
	            };
	            if (node.loc) {
	                entry.comment.loc = node.loc;
	            }
	            node.type = type;
	            this.leading.push(entry);
	            this.trailing.push(entry);
	        }
	    };
	    CommentHandler.prototype.visit = function (node, metadata) {
	        if (node.type === 'LineComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (node.type === 'BlockComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (this.attach) {
	            this.visitNode(node, metadata);
	        }
	    };
	    return CommentHandler;
	}());
	exports.CommentHandler = CommentHandler;


/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Syntax = {
	    AssignmentExpression: 'AssignmentExpression',
	    AssignmentPattern: 'AssignmentPattern',
	    ArrayExpression: 'ArrayExpression',
	    ArrayPattern: 'ArrayPattern',
	    ArrowFunctionExpression: 'ArrowFunctionExpression',
	    AwaitExpression: 'AwaitExpression',
	    BlockStatement: 'BlockStatement',
	    BinaryExpression: 'BinaryExpression',
	    BreakStatement: 'BreakStatement',
	    CallExpression: 'CallExpression',
	    CatchClause: 'CatchClause',
	    ClassBody: 'ClassBody',
	    ClassDeclaration: 'ClassDeclaration',
	    ClassExpression: 'ClassExpression',
	    ConditionalExpression: 'ConditionalExpression',
	    ContinueStatement: 'ContinueStatement',
	    DoWhileStatement: 'DoWhileStatement',
	    DebuggerStatement: 'DebuggerStatement',
	    EmptyStatement: 'EmptyStatement',
	    ExportAllDeclaration: 'ExportAllDeclaration',
	    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	    ExportNamedDeclaration: 'ExportNamedDeclaration',
	    ExportSpecifier: 'ExportSpecifier',
	    ExpressionStatement: 'ExpressionStatement',
	    ForStatement: 'ForStatement',
	    ForOfStatement: 'ForOfStatement',
	    ForInStatement: 'ForInStatement',
	    FunctionDeclaration: 'FunctionDeclaration',
	    FunctionExpression: 'FunctionExpression',
	    Identifier: 'Identifier',
	    IfStatement: 'IfStatement',
	    ImportDeclaration: 'ImportDeclaration',
	    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	    ImportSpecifier: 'ImportSpecifier',
	    Literal: 'Literal',
	    LabeledStatement: 'LabeledStatement',
	    LogicalExpression: 'LogicalExpression',
	    MemberExpression: 'MemberExpression',
	    MetaProperty: 'MetaProperty',
	    MethodDefinition: 'MethodDefinition',
	    NewExpression: 'NewExpression',
	    ObjectExpression: 'ObjectExpression',
	    ObjectPattern: 'ObjectPattern',
	    Program: 'Program',
	    Property: 'Property',
	    RestElement: 'RestElement',
	    ReturnStatement: 'ReturnStatement',
	    SequenceExpression: 'SequenceExpression',
	    SpreadElement: 'SpreadElement',
	    Super: 'Super',
	    SwitchCase: 'SwitchCase',
	    SwitchStatement: 'SwitchStatement',
	    TaggedTemplateExpression: 'TaggedTemplateExpression',
	    TemplateElement: 'TemplateElement',
	    TemplateLiteral: 'TemplateLiteral',
	    ThisExpression: 'ThisExpression',
	    ThrowStatement: 'ThrowStatement',
	    TryStatement: 'TryStatement',
	    UnaryExpression: 'UnaryExpression',
	    UpdateExpression: 'UpdateExpression',
	    VariableDeclaration: 'VariableDeclaration',
	    VariableDeclarator: 'VariableDeclarator',
	    WhileStatement: 'WhileStatement',
	    WithStatement: 'WithStatement',
	    YieldExpression: 'YieldExpression'
	};


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
/* istanbul ignore next */
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var character_1 = __webpack_require__(4);
	var JSXNode = __webpack_require__(5);
	var jsx_syntax_1 = __webpack_require__(6);
	var Node = __webpack_require__(7);
	var parser_1 = __webpack_require__(8);
	var token_1 = __webpack_require__(13);
	var xhtml_entities_1 = __webpack_require__(14);
	token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
	token_1.TokenName[101 /* Text */] = 'JSXText';
	// Fully qualified element name, e.g. <svg:path> returns "svg:path"
	function getQualifiedElementName(elementName) {
	    var qualifiedName;
	    switch (elementName.type) {
	        case jsx_syntax_1.JSXSyntax.JSXIdentifier:
	            var id = elementName;
	            qualifiedName = id.name;
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
	            var ns = elementName;
	            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +
	                getQualifiedElementName(ns.name);
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
	            var expr = elementName;
	            qualifiedName = getQualifiedElementName(expr.object) + '.' +
	                getQualifiedElementName(expr.property);
	            break;
	        /* istanbul ignore next */
	        default:
	            break;
	    }
	    return qualifiedName;
	}
	var JSXParser = (function (_super) {
	    __extends(JSXParser, _super);
	    function JSXParser(code, options, delegate) {
	        return _super.call(this, code, options, delegate) || this;
	    }
	    JSXParser.prototype.parsePrimaryExpression = function () {
	        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
	    };
	    JSXParser.prototype.startJSX = function () {
	        // Unwind the scanner before the lookahead token.
	        this.scanner.index = this.startMarker.index;
	        this.scanner.lineNumber = this.startMarker.line;
	        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
	    };
	    JSXParser.prototype.finishJSX = function () {
	        // Prime the next lookahead.
	        this.nextToken();
	    };
	    JSXParser.prototype.reenterJSX = function () {
	        this.startJSX();
	        this.expectJSX('}');
	        // Pop the closing '}' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	    };
	    JSXParser.prototype.createJSXNode = function () {
	        this.collectComments();
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.createJSXChildNode = function () {
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.scanXHTMLEntity = function (quote) {
	        var result = '&';
	        var valid = true;
	        var terminated = false;
	        var numeric = false;
	        var hex = false;
	        while (!this.scanner.eof() && valid && !terminated) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === quote) {
	                break;
	            }
	            terminated = (ch === ';');
	            result += ch;
	            ++this.scanner.index;
	            if (!terminated) {
	                switch (result.length) {
	                    case 2:
	                        // e.g. '&#123;'
	                        numeric = (ch === '#');
	                        break;
	                    case 3:
	                        if (numeric) {
	                            // e.g. '&#x41;'
	                            hex = (ch === 'x');
	                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
	                            numeric = numeric && !hex;
	                        }
	                        break;
	                    default:
	                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
	                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
	                        break;
	                }
	            }
	        }
	        if (valid && terminated && result.length > 2) {
	            // e.g. '&#x41;' becomes just '#x41'
	            var str = result.substr(1, result.length - 2);
	            if (numeric && str.length > 1) {
	                result = String.fromCharCode(parseInt(str.substr(1), 10));
	            }
	            else if (hex && str.length > 2) {
	                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
	            }
	            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
	                result = xhtml_entities_1.XHTMLEntities[str];
	            }
	        }
	        return result;
	    };
	    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
	    JSXParser.prototype.lexJSX = function () {
	        var cp = this.scanner.source.charCodeAt(this.scanner.index);
	        // < > / : = { }
	        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
	            var value = this.scanner.source[this.scanner.index++];
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index - 1,
	                end: this.scanner.index
	            };
	        }
	        // " '
	        if (cp === 34 || cp === 39) {
	            var start = this.scanner.index;
	            var quote = this.scanner.source[this.scanner.index++];
	            var str = '';
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source[this.scanner.index++];
	                if (ch === quote) {
	                    break;
	                }
	                else if (ch === '&') {
	                    str += this.scanXHTMLEntity(quote);
	                }
	                else {
	                    str += ch;
	                }
	            }
	            return {
	                type: 8 /* StringLiteral */,
	                value: str,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // ... or .
	        if (cp === 46) {
	            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
	            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
	            var value = (n1 === 46 && n2 === 46) ? '...' : '.';
	            var start = this.scanner.index;
	            this.scanner.index += value.length;
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // `
	        if (cp === 96) {
	            // Only placeholder, since it will be rescanned as a real assignment expression.
	            return {
	                type: 10 /* Template */,
	                value: '',
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index,
	                end: this.scanner.index
	            };
	        }
	        // Identifer can not contain backslash (char code 92).
	        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {
	            var start = this.scanner.index;
	            ++this.scanner.index;
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source.charCodeAt(this.scanner.index);
	                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {
	                    ++this.scanner.index;
	                }
	                else if (ch === 45) {
	                    // Hyphen (char code 45) can be part of an identifier.
	                    ++this.scanner.index;
	                }
	                else {
	                    break;
	                }
	            }
	            var id = this.scanner.source.slice(start, this.scanner.index);
	            return {
	                type: 100 /* Identifier */,
	                value: id,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        return this.scanner.lex();
	    };
	    JSXParser.prototype.nextJSXToken = function () {
	        this.collectComments();
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = this.lexJSX();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        if (this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.nextJSXText = function () {
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var start = this.scanner.index;
	        var text = '';
	        while (!this.scanner.eof()) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === '{' || ch === '<') {
	                break;
	            }
	            ++this.scanner.index;
	            text += ch;
	            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.scanner.lineNumber;
	                if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
	                    ++this.scanner.index;
	                }
	                this.scanner.lineStart = this.scanner.index;
	            }
	        }
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = {
	            type: 101 /* Text */,
	            value: text,
	            lineNumber: this.scanner.lineNumber,
	            lineStart: this.scanner.lineStart,
	            start: start,
	            end: this.scanner.index
	        };
	        if ((text.length > 0) && this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.peekJSXToken = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.lexJSX();
	        this.scanner.restoreState(state);
	        return next;
	    };
	    // Expect the next JSX token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    JSXParser.prototype.expectJSX = function (value) {
	        var token = this.nextJSXToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next JSX token matches the specified punctuator.
	    JSXParser.prototype.matchJSX = function (value) {
	        var next = this.peekJSXToken();
	        return next.type === 7 /* Punctuator */ && next.value === value;
	    };
	    JSXParser.prototype.parseJSXIdentifier = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 100 /* Identifier */) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
	    };
	    JSXParser.prototype.parseJSXElementName = function () {
	        var node = this.createJSXNode();
	        var elementName = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = elementName;
	            this.expectJSX(':');
	            var name_1 = this.parseJSXIdentifier();
	            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
	        }
	        else if (this.matchJSX('.')) {
	            while (this.matchJSX('.')) {
	                var object = elementName;
	                this.expectJSX('.');
	                var property = this.parseJSXIdentifier();
	                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
	            }
	        }
	        return elementName;
	    };
	    JSXParser.prototype.parseJSXAttributeName = function () {
	        var node = this.createJSXNode();
	        var attributeName;
	        var identifier = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = identifier;
	            this.expectJSX(':');
	            var name_2 = this.parseJSXIdentifier();
	            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
	        }
	        else {
	            attributeName = identifier;
	        }
	        return attributeName;
	    };
	    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 8 /* StringLiteral */) {
	            this.throwUnexpectedToken(token);
	        }
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    JSXParser.prototype.parseJSXExpressionAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.finishJSX();
	        if (this.match('}')) {
	            this.tolerateError('JSX attributes must only be assigned a non-empty expression');
	        }
	        var expression = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXAttributeValue = function () {
	        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :
	            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
	    };
	    JSXParser.prototype.parseJSXNameValueAttribute = function () {
	        var node = this.createJSXNode();
	        var name = this.parseJSXAttributeName();
	        var value = null;
	        if (this.matchJSX('=')) {
	            this.expectJSX('=');
	            value = this.parseJSXAttributeValue();
	        }
	        return this.finalize(node, new JSXNode.JSXAttribute(name, value));
	    };
	    JSXParser.prototype.parseJSXSpreadAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.expectJSX('...');
	        this.finishJSX();
	        var argument = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
	    };
	    JSXParser.prototype.parseJSXAttributes = function () {
	        var attributes = [];
	        while (!this.matchJSX('/') && !this.matchJSX('>')) {
	            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :
	                this.parseJSXNameValueAttribute();
	            attributes.push(attribute);
	        }
	        return attributes;
	    };
	    JSXParser.prototype.parseJSXOpeningElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXBoundaryElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        if (this.matchJSX('/')) {
	            this.expectJSX('/');
	            var name_3 = this.parseJSXElementName();
	            this.expectJSX('>');
	            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
	        }
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXEmptyExpression = function () {
	        var node = this.createJSXChildNode();
	        this.collectComments();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        return this.finalize(node, new JSXNode.JSXEmptyExpression());
	    };
	    JSXParser.prototype.parseJSXExpressionContainer = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        var expression;
	        if (this.matchJSX('}')) {
	            expression = this.parseJSXEmptyExpression();
	            this.expectJSX('}');
	        }
	        else {
	            this.finishJSX();
	            expression = this.parseAssignmentExpression();
	            this.reenterJSX();
	        }
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXChildren = function () {
	        var children = [];
	        while (!this.scanner.eof()) {
	            var node = this.createJSXChildNode();
	            var token = this.nextJSXText();
	            if (token.start < token.end) {
	                var raw = this.getTokenRaw(token);
	                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
	                children.push(child);
	            }
	            if (this.scanner.source[this.scanner.index] === '{') {
	                var container = this.parseJSXExpressionContainer();
	                children.push(container);
	            }
	            else {
	                break;
	            }
	        }
	        return children;
	    };
	    JSXParser.prototype.parseComplexJSXElement = function (el) {
	        var stack = [];
	        while (!this.scanner.eof()) {
	            el.children = el.children.concat(this.parseJSXChildren());
	            var node = this.createJSXChildNode();
	            var element = this.parseJSXBoundaryElement();
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
	                var opening = element;
	                if (opening.selfClosing) {
	                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
	                    el.children.push(child);
	                }
	                else {
	                    stack.push(el);
	                    el = { node: node, opening: opening, closing: null, children: [] };
	                }
	            }
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
	                el.closing = element;
	                var open_1 = getQualifiedElementName(el.opening.name);
	                var close_1 = getQualifiedElementName(el.closing.name);
	                if (open_1 !== close_1) {
	                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
	                }
	                if (stack.length > 0) {
	                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
	                    el = stack[stack.length - 1];
	                    el.children.push(child);
	                    stack.pop();
	                }
	                else {
	                    break;
	                }
	            }
	        }
	        return el;
	    };
	    JSXParser.prototype.parseJSXElement = function () {
	        var node = this.createJSXNode();
	        var opening = this.parseJSXOpeningElement();
	        var children = [];
	        var closing = null;
	        if (!opening.selfClosing) {
	            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
	            children = el.children;
	            closing = el.closing;
	        }
	        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
	    };
	    JSXParser.prototype.parseJSXRoot = function () {
	        // Pop the opening '<' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	        this.startJSX();
	        var element = this.parseJSXElement();
	        this.finishJSX();
	        return element;
	    };
	    JSXParser.prototype.isStartOfExpression = function () {
	        return _super.prototype.isStartOfExpression.call(this) || this.match('<');
	    };
	    return JSXParser;
	}(parser_1.Parser));
	exports.JSXParser = JSXParser;


/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// See also tools/generate-unicode-regex.js.
	var Regex = {
	    // Unicode v8.0.0 NonAsciiIdentifierStart:
	    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
	    // Unicode v8.0.0 NonAsciiIdentifierPart:
	    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	};
	exports.Character = {
	    /* tslint:disable:no-bitwise */
	    fromCodePoint: function (cp) {
	        return (cp < 0x10000) ? String.fromCharCode(cp) :
	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
	                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
	    },
	    // https://tc39.github.io/ecma262/#sec-white-space
	    isWhiteSpace: function (cp) {
	        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
	            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
	    },
	    // https://tc39.github.io/ecma262/#sec-line-terminators
	    isLineTerminator: function (cp) {
	        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
	    },
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    isIdentifierStart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));
	    },
	    isIdentifierPart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp >= 0x30 && cp <= 0x39) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));
	    },
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    isDecimalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39); // 0..9
	    },
	    isHexDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39) ||
	            (cp >= 0x41 && cp <= 0x46) ||
	            (cp >= 0x61 && cp <= 0x66); // a..f
	    },
	    isOctalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x37); // 0..7
	    }
	};


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var jsx_syntax_1 = __webpack_require__(6);
	/* tslint:disable:max-classes-per-file */
	var JSXClosingElement = (function () {
	    function JSXClosingElement(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
	        this.name = name;
	    }
	    return JSXClosingElement;
	}());
	exports.JSXClosingElement = JSXClosingElement;
	var JSXElement = (function () {
	    function JSXElement(openingElement, children, closingElement) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXElement;
	        this.openingElement = openingElement;
	        this.children = children;
	        this.closingElement = closingElement;
	    }
	    return JSXElement;
	}());
	exports.JSXElement = JSXElement;
	var JSXEmptyExpression = (function () {
	    function JSXEmptyExpression() {
	        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
	    }
	    return JSXEmptyExpression;
	}());
	exports.JSXEmptyExpression = JSXEmptyExpression;
	var JSXExpressionContainer = (function () {
	    function JSXExpressionContainer(expression) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
	        this.expression = expression;
	    }
	    return JSXExpressionContainer;
	}());
	exports.JSXExpressionContainer = JSXExpressionContainer;
	var JSXIdentifier = (function () {
	    function JSXIdentifier(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
	        this.name = name;
	    }
	    return JSXIdentifier;
	}());
	exports.JSXIdentifier = JSXIdentifier;
	var JSXMemberExpression = (function () {
	    function JSXMemberExpression(object, property) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
	        this.object = object;
	        this.property = property;
	    }
	    return JSXMemberExpression;
	}());
	exports.JSXMemberExpression = JSXMemberExpression;
	var JSXAttribute = (function () {
	    function JSXAttribute(name, value) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
	        this.name = name;
	        this.value = value;
	    }
	    return JSXAttribute;
	}());
	exports.JSXAttribute = JSXAttribute;
	var JSXNamespacedName = (function () {
	    function JSXNamespacedName(namespace, name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
	        this.namespace = namespace;
	        this.name = name;
	    }
	    return JSXNamespacedName;
	}());
	exports.JSXNamespacedName = JSXNamespacedName;
	var JSXOpeningElement = (function () {
	    function JSXOpeningElement(name, selfClosing, attributes) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
	        this.name = name;
	        this.selfClosing = selfClosing;
	        this.attributes = attributes;
	    }
	    return JSXOpeningElement;
	}());
	exports.JSXOpeningElement = JSXOpeningElement;
	var JSXSpreadAttribute = (function () {
	    function JSXSpreadAttribute(argument) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
	        this.argument = argument;
	    }
	    return JSXSpreadAttribute;
	}());
	exports.JSXSpreadAttribute = JSXSpreadAttribute;
	var JSXText = (function () {
	    function JSXText(value, raw) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXText;
	        this.value = value;
	        this.raw = raw;
	    }
	    return JSXText;
	}());
	exports.JSXText = JSXText;


/***/ },
/* 6 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JSXSyntax = {
	    JSXAttribute: 'JSXAttribute',
	    JSXClosingElement: 'JSXClosingElement',
	    JSXElement: 'JSXElement',
	    JSXEmptyExpression: 'JSXEmptyExpression',
	    JSXExpressionContainer: 'JSXExpressionContainer',
	    JSXIdentifier: 'JSXIdentifier',
	    JSXMemberExpression: 'JSXMemberExpression',
	    JSXNamespacedName: 'JSXNamespacedName',
	    JSXOpeningElement: 'JSXOpeningElement',
	    JSXSpreadAttribute: 'JSXSpreadAttribute',
	    JSXText: 'JSXText'
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	/* tslint:disable:max-classes-per-file */
	var ArrayExpression = (function () {
	    function ArrayExpression(elements) {
	        this.type = syntax_1.Syntax.ArrayExpression;
	        this.elements = elements;
	    }
	    return ArrayExpression;
	}());
	exports.ArrayExpression = ArrayExpression;
	var ArrayPattern = (function () {
	    function ArrayPattern(elements) {
	        this.type = syntax_1.Syntax.ArrayPattern;
	        this.elements = elements;
	    }
	    return ArrayPattern;
	}());
	exports.ArrayPattern = ArrayPattern;
	var ArrowFunctionExpression = (function () {
	    function ArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = false;
	    }
	    return ArrowFunctionExpression;
	}());
	exports.ArrowFunctionExpression = ArrowFunctionExpression;
	var AssignmentExpression = (function () {
	    function AssignmentExpression(operator, left, right) {
	        this.type = syntax_1.Syntax.AssignmentExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentExpression;
	}());
	exports.AssignmentExpression = AssignmentExpression;
	var AssignmentPattern = (function () {
	    function AssignmentPattern(left, right) {
	        this.type = syntax_1.Syntax.AssignmentPattern;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentPattern;
	}());
	exports.AssignmentPattern = AssignmentPattern;
	var AsyncArrowFunctionExpression = (function () {
	    function AsyncArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = true;
	    }
	    return AsyncArrowFunctionExpression;
	}());
	exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
	var AsyncFunctionDeclaration = (function () {
	    function AsyncFunctionDeclaration(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionDeclaration;
	}());
	exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
	var AsyncFunctionExpression = (function () {
	    function AsyncFunctionExpression(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionExpression;
	}());
	exports.AsyncFunctionExpression = AsyncFunctionExpression;
	var AwaitExpression = (function () {
	    function AwaitExpression(argument) {
	        this.type = syntax_1.Syntax.AwaitExpression;
	        this.argument = argument;
	    }
	    return AwaitExpression;
	}());
	exports.AwaitExpression = AwaitExpression;
	var BinaryExpression = (function () {
	    function BinaryExpression(operator, left, right) {
	        var logical = (operator === '||' || operator === '&&');
	        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return BinaryExpression;
	}());
	exports.BinaryExpression = BinaryExpression;
	var BlockStatement = (function () {
	    function BlockStatement(body) {
	        this.type = syntax_1.Syntax.BlockStatement;
	        this.body = body;
	    }
	    return BlockStatement;
	}());
	exports.BlockStatement = BlockStatement;
	var BreakStatement = (function () {
	    function BreakStatement(label) {
	        this.type = syntax_1.Syntax.BreakStatement;
	        this.label = label;
	    }
	    return BreakStatement;
	}());
	exports.BreakStatement = BreakStatement;
	var CallExpression = (function () {
	    function CallExpression(callee, args) {
	        this.type = syntax_1.Syntax.CallExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return CallExpression;
	}());
	exports.CallExpression = CallExpression;
	var CatchClause = (function () {
	    function CatchClause(param, body) {
	        this.type = syntax_1.Syntax.CatchClause;
	        this.param = param;
	        this.body = body;
	    }
	    return CatchClause;
	}());
	exports.CatchClause = CatchClause;
	var ClassBody = (function () {
	    function ClassBody(body) {
	        this.type = syntax_1.Syntax.ClassBody;
	        this.body = body;
	    }
	    return ClassBody;
	}());
	exports.ClassBody = ClassBody;
	var ClassDeclaration = (function () {
	    function ClassDeclaration(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassDeclaration;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassDeclaration;
	}());
	exports.ClassDeclaration = ClassDeclaration;
	var ClassExpression = (function () {
	    function ClassExpression(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassExpression;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassExpression;
	}());
	exports.ClassExpression = ClassExpression;
	var ComputedMemberExpression = (function () {
	    function ComputedMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = true;
	        this.object = object;
	        this.property = property;
	    }
	    return ComputedMemberExpression;
	}());
	exports.ComputedMemberExpression = ComputedMemberExpression;
	var ConditionalExpression = (function () {
	    function ConditionalExpression(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.ConditionalExpression;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return ConditionalExpression;
	}());
	exports.ConditionalExpression = ConditionalExpression;
	var ContinueStatement = (function () {
	    function ContinueStatement(label) {
	        this.type = syntax_1.Syntax.ContinueStatement;
	        this.label = label;
	    }
	    return ContinueStatement;
	}());
	exports.ContinueStatement = ContinueStatement;
	var DebuggerStatement = (function () {
	    function DebuggerStatement() {
	        this.type = syntax_1.Syntax.DebuggerStatement;
	    }
	    return DebuggerStatement;
	}());
	exports.DebuggerStatement = DebuggerStatement;
	var Directive = (function () {
	    function Directive(expression, directive) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	        this.directive = directive;
	    }
	    return Directive;
	}());
	exports.Directive = Directive;
	var DoWhileStatement = (function () {
	    function DoWhileStatement(body, test) {
	        this.type = syntax_1.Syntax.DoWhileStatement;
	        this.body = body;
	        this.test = test;
	    }
	    return DoWhileStatement;
	}());
	exports.DoWhileStatement = DoWhileStatement;
	var EmptyStatement = (function () {
	    function EmptyStatement() {
	        this.type = syntax_1.Syntax.EmptyStatement;
	    }
	    return EmptyStatement;
	}());
	exports.EmptyStatement = EmptyStatement;
	var ExportAllDeclaration = (function () {
	    function ExportAllDeclaration(source) {
	        this.type = syntax_1.Syntax.ExportAllDeclaration;
	        this.source = source;
	    }
	    return ExportAllDeclaration;
	}());
	exports.ExportAllDeclaration = ExportAllDeclaration;
	var ExportDefaultDeclaration = (function () {
	    function ExportDefaultDeclaration(declaration) {
	        this.type = syntax_1.Syntax.ExportDefaultDeclaration;
	        this.declaration = declaration;
	    }
	    return ExportDefaultDeclaration;
	}());
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	var ExportNamedDeclaration = (function () {
	    function ExportNamedDeclaration(declaration, specifiers, source) {
	        this.type = syntax_1.Syntax.ExportNamedDeclaration;
	        this.declaration = declaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ExportNamedDeclaration;
	}());
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	var ExportSpecifier = (function () {
	    function ExportSpecifier(local, exported) {
	        this.type = syntax_1.Syntax.ExportSpecifier;
	        this.exported = exported;
	        this.local = local;
	    }
	    return ExportSpecifier;
	}());
	exports.ExportSpecifier = ExportSpecifier;
	var ExpressionStatement = (function () {
	    function ExpressionStatement(expression) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	    }
	    return ExpressionStatement;
	}());
	exports.ExpressionStatement = ExpressionStatement;
	var ForInStatement = (function () {
	    function ForInStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForInStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	        this.each = false;
	    }
	    return ForInStatement;
	}());
	exports.ForInStatement = ForInStatement;
	var ForOfStatement = (function () {
	    function ForOfStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForOfStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	    }
	    return ForOfStatement;
	}());
	exports.ForOfStatement = ForOfStatement;
	var ForStatement = (function () {
	    function ForStatement(init, test, update, body) {
	        this.type = syntax_1.Syntax.ForStatement;
	        this.init = init;
	        this.test = test;
	        this.update = update;
	        this.body = body;
	    }
	    return ForStatement;
	}());
	exports.ForStatement = ForStatement;
	var FunctionDeclaration = (function () {
	    function FunctionDeclaration(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionDeclaration;
	}());
	exports.FunctionDeclaration = FunctionDeclaration;
	var FunctionExpression = (function () {
	    function FunctionExpression(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionExpression;
	}());
	exports.FunctionExpression = FunctionExpression;
	var Identifier = (function () {
	    function Identifier(name) {
	        this.type = syntax_1.Syntax.Identifier;
	        this.name = name;
	    }
	    return Identifier;
	}());
	exports.Identifier = Identifier;
	var IfStatement = (function () {
	    function IfStatement(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.IfStatement;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return IfStatement;
	}());
	exports.IfStatement = IfStatement;
	var ImportDeclaration = (function () {
	    function ImportDeclaration(specifiers, source) {
	        this.type = syntax_1.Syntax.ImportDeclaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ImportDeclaration;
	}());
	exports.ImportDeclaration = ImportDeclaration;
	var ImportDefaultSpecifier = (function () {
	    function ImportDefaultSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportDefaultSpecifier;
	        this.local = local;
	    }
	    return ImportDefaultSpecifier;
	}());
	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	var ImportNamespaceSpecifier = (function () {
	    function ImportNamespaceSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
	        this.local = local;
	    }
	    return ImportNamespaceSpecifier;
	}());
	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
	var ImportSpecifier = (function () {
	    function ImportSpecifier(local, imported) {
	        this.type = syntax_1.Syntax.ImportSpecifier;
	        this.local = local;
	        this.imported = imported;
	    }
	    return ImportSpecifier;
	}());
	exports.ImportSpecifier = ImportSpecifier;
	var LabeledStatement = (function () {
	    function LabeledStatement(label, body) {
	        this.type = syntax_1.Syntax.LabeledStatement;
	        this.label = label;
	        this.body = body;
	    }
	    return LabeledStatement;
	}());
	exports.LabeledStatement = LabeledStatement;
	var Literal = (function () {
	    function Literal(value, raw) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	    }
	    return Literal;
	}());
	exports.Literal = Literal;
	var MetaProperty = (function () {
	    function MetaProperty(meta, property) {
	        this.type = syntax_1.Syntax.MetaProperty;
	        this.meta = meta;
	        this.property = property;
	    }
	    return MetaProperty;
	}());
	exports.MetaProperty = MetaProperty;
	var MethodDefinition = (function () {
	    function MethodDefinition(key, computed, value, kind, isStatic) {
	        this.type = syntax_1.Syntax.MethodDefinition;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.static = isStatic;
	    }
	    return MethodDefinition;
	}());
	exports.MethodDefinition = MethodDefinition;
	var Module = (function () {
	    function Module(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'module';
	    }
	    return Module;
	}());
	exports.Module = Module;
	var NewExpression = (function () {
	    function NewExpression(callee, args) {
	        this.type = syntax_1.Syntax.NewExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return NewExpression;
	}());
	exports.NewExpression = NewExpression;
	var ObjectExpression = (function () {
	    function ObjectExpression(properties) {
	        this.type = syntax_1.Syntax.ObjectExpression;
	        this.properties = properties;
	    }
	    return ObjectExpression;
	}());
	exports.ObjectExpression = ObjectExpression;
	var ObjectPattern = (function () {
	    function ObjectPattern(properties) {
	        this.type = syntax_1.Syntax.ObjectPattern;
	        this.properties = properties;
	    }
	    return ObjectPattern;
	}());
	exports.ObjectPattern = ObjectPattern;
	var Property = (function () {
	    function Property(kind, key, computed, value, method, shorthand) {
	        this.type = syntax_1.Syntax.Property;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.method = method;
	        this.shorthand = shorthand;
	    }
	    return Property;
	}());
	exports.Property = Property;
	var RegexLiteral = (function () {
	    function RegexLiteral(value, raw, pattern, flags) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	        this.regex = { pattern: pattern, flags: flags };
	    }
	    return RegexLiteral;
	}());
	exports.RegexLiteral = RegexLiteral;
	var RestElement = (function () {
	    function RestElement(argument) {
	        this.type = syntax_1.Syntax.RestElement;
	        this.argument = argument;
	    }
	    return RestElement;
	}());
	exports.RestElement = RestElement;
	var ReturnStatement = (function () {
	    function ReturnStatement(argument) {
	        this.type = syntax_1.Syntax.ReturnStatement;
	        this.argument = argument;
	    }
	    return ReturnStatement;
	}());
	exports.ReturnStatement = ReturnStatement;
	var Script = (function () {
	    function Script(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'script';
	    }
	    return Script;
	}());
	exports.Script = Script;
	var SequenceExpression = (function () {
	    function SequenceExpression(expressions) {
	        this.type = syntax_1.Syntax.SequenceExpression;
	        this.expressions = expressions;
	    }
	    return SequenceExpression;
	}());
	exports.SequenceExpression = SequenceExpression;
	var SpreadElement = (function () {
	    function SpreadElement(argument) {
	        this.type = syntax_1.Syntax.SpreadElement;
	        this.argument = argument;
	    }
	    return SpreadElement;
	}());
	exports.SpreadElement = SpreadElement;
	var StaticMemberExpression = (function () {
	    function StaticMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = false;
	        this.object = object;
	        this.property = property;
	    }
	    return StaticMemberExpression;
	}());
	exports.StaticMemberExpression = StaticMemberExpression;
	var Super = (function () {
	    function Super() {
	        this.type = syntax_1.Syntax.Super;
	    }
	    return Super;
	}());
	exports.Super = Super;
	var SwitchCase = (function () {
	    function SwitchCase(test, consequent) {
	        this.type = syntax_1.Syntax.SwitchCase;
	        this.test = test;
	        this.consequent = consequent;
	    }
	    return SwitchCase;
	}());
	exports.SwitchCase = SwitchCase;
	var SwitchStatement = (function () {
	    function SwitchStatement(discriminant, cases) {
	        this.type = syntax_1.Syntax.SwitchStatement;
	        this.discriminant = discriminant;
	        this.cases = cases;
	    }
	    return SwitchStatement;
	}());
	exports.SwitchStatement = SwitchStatement;
	var TaggedTemplateExpression = (function () {
	    function TaggedTemplateExpression(tag, quasi) {
	        this.type = syntax_1.Syntax.TaggedTemplateExpression;
	        this.tag = tag;
	        this.quasi = quasi;
	    }
	    return TaggedTemplateExpression;
	}());
	exports.TaggedTemplateExpression = TaggedTemplateExpression;
	var TemplateElement = (function () {
	    function TemplateElement(value, tail) {
	        this.type = syntax_1.Syntax.TemplateElement;
	        this.value = value;
	        this.tail = tail;
	    }
	    return TemplateElement;
	}());
	exports.TemplateElement = TemplateElement;
	var TemplateLiteral = (function () {
	    function TemplateLiteral(quasis, expressions) {
	        this.type = syntax_1.Syntax.TemplateLiteral;
	        this.quasis = quasis;
	        this.expressions = expressions;
	    }
	    return TemplateLiteral;
	}());
	exports.TemplateLiteral = TemplateLiteral;
	var ThisExpression = (function () {
	    function ThisExpression() {
	        this.type = syntax_1.Syntax.ThisExpression;
	    }
	    return ThisExpression;
	}());
	exports.ThisExpression = ThisExpression;
	var ThrowStatement = (function () {
	    function ThrowStatement(argument) {
	        this.type = syntax_1.Syntax.ThrowStatement;
	        this.argument = argument;
	    }
	    return ThrowStatement;
	}());
	exports.ThrowStatement = ThrowStatement;
	var TryStatement = (function () {
	    function TryStatement(block, handler, finalizer) {
	        this.type = syntax_1.Syntax.TryStatement;
	        this.block = block;
	        this.handler = handler;
	        this.finalizer = finalizer;
	    }
	    return TryStatement;
	}());
	exports.TryStatement = TryStatement;
	var UnaryExpression = (function () {
	    function UnaryExpression(operator, argument) {
	        this.type = syntax_1.Syntax.UnaryExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = true;
	    }
	    return UnaryExpression;
	}());
	exports.UnaryExpression = UnaryExpression;
	var UpdateExpression = (function () {
	    function UpdateExpression(operator, argument, prefix) {
	        this.type = syntax_1.Syntax.UpdateExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = prefix;
	    }
	    return UpdateExpression;
	}());
	exports.UpdateExpression = UpdateExpression;
	var VariableDeclaration = (function () {
	    function VariableDeclaration(declarations, kind) {
	        this.type = syntax_1.Syntax.VariableDeclaration;
	        this.declarations = declarations;
	        this.kind = kind;
	    }
	    return VariableDeclaration;
	}());
	exports.VariableDeclaration = VariableDeclaration;
	var VariableDeclarator = (function () {
	    function VariableDeclarator(id, init) {
	        this.type = syntax_1.Syntax.VariableDeclarator;
	        this.id = id;
	        this.init = init;
	    }
	    return VariableDeclarator;
	}());
	exports.VariableDeclarator = VariableDeclarator;
	var WhileStatement = (function () {
	    function WhileStatement(test, body) {
	        this.type = syntax_1.Syntax.WhileStatement;
	        this.test = test;
	        this.body = body;
	    }
	    return WhileStatement;
	}());
	exports.WhileStatement = WhileStatement;
	var WithStatement = (function () {
	    function WithStatement(object, body) {
	        this.type = syntax_1.Syntax.WithStatement;
	        this.object = object;
	        this.body = body;
	    }
	    return WithStatement;
	}());
	exports.WithStatement = WithStatement;
	var YieldExpression = (function () {
	    function YieldExpression(argument, delegate) {
	        this.type = syntax_1.Syntax.YieldExpression;
	        this.argument = argument;
	        this.delegate = delegate;
	    }
	    return YieldExpression;
	}());
	exports.YieldExpression = YieldExpression;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var error_handler_1 = __webpack_require__(10);
	var messages_1 = __webpack_require__(11);
	var Node = __webpack_require__(7);
	var scanner_1 = __webpack_require__(12);
	var syntax_1 = __webpack_require__(2);
	var token_1 = __webpack_require__(13);
	var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
	var Parser = (function () {
	    function Parser(code, options, delegate) {
	        if (options === void 0) { options = {}; }
	        this.config = {
	            range: (typeof options.range === 'boolean') && options.range,
	            loc: (typeof options.loc === 'boolean') && options.loc,
	            source: null,
	            tokens: (typeof options.tokens === 'boolean') && options.tokens,
	            comment: (typeof options.comment === 'boolean') && options.comment,
	            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant
	        };
	        if (this.config.loc && options.source && options.source !== null) {
	            this.config.source = String(options.source);
	        }
	        this.delegate = delegate;
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = this.config.tolerant;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = this.config.comment;
	        this.operatorPrecedence = {
	            ')': 0,
	            ';': 0,
	            ',': 0,
	            '=': 0,
	            ']': 0,
	            '||': 1,
	            '&&': 2,
	            '|': 3,
	            '^': 4,
	            '&': 5,
	            '==': 6,
	            '!=': 6,
	            '===': 6,
	            '!==': 6,
	            '<': 7,
	            '>': 7,
	            '<=': 7,
	            '>=': 7,
	            '<<': 8,
	            '>>': 8,
	            '>>>': 8,
	            '+': 9,
	            '-': 9,
	            '*': 11,
	            '/': 11,
	            '%': 11
	        };
	        this.lookahead = {
	            type: 2 /* EOF */,
	            value: '',
	            lineNumber: this.scanner.lineNumber,
	            lineStart: 0,
	            start: 0,
	            end: 0
	        };
	        this.hasLineTerminator = false;
	        this.context = {
	            isModule: false,
	            await: false,
	            allowIn: true,
	            allowStrictDirective: true,
	            allowYield: true,
	            firstCoverInitializedNameError: null,
	            isAssignmentTarget: false,
	            isBindingElement: false,
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            labelSet: {},
	            strict: false
	        };
	        this.tokens = [];
	        this.startMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.lastMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.nextToken();
	        this.lastMarker = {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    }
	    Parser.prototype.throwError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.lastMarker.line;
	        var column = this.lastMarker.column + 1;
	        throw this.errorHandler.createError(index, line, column, msg);
	    };
	    Parser.prototype.tolerateError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.scanner.lineNumber;
	        var column = this.lastMarker.column + 1;
	        this.errorHandler.tolerateError(index, line, column, msg);
	    };
	    // Throw an exception because of the token.
	    Parser.prototype.unexpectedTokenError = function (token, message) {
	        var msg = message || messages_1.Messages.UnexpectedToken;
	        var value;
	        if (token) {
	            if (!message) {
	                msg = (token.type === 2 /* EOF */) ? messages_1.Messages.UnexpectedEOS :
	                    (token.type === 3 /* Identifier */) ? messages_1.Messages.UnexpectedIdentifier :
	                        (token.type === 6 /* NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :
	                            (token.type === 8 /* StringLiteral */) ? messages_1.Messages.UnexpectedString :
	                                (token.type === 10 /* Template */) ? messages_1.Messages.UnexpectedTemplate :
	                                    messages_1.Messages.UnexpectedToken;
	                if (token.type === 4 /* Keyword */) {
	                    if (this.scanner.isFutureReservedWord(token.value)) {
	                        msg = messages_1.Messages.UnexpectedReserved;
	                    }
	                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
	                        msg = messages_1.Messages.StrictReservedWord;
	                    }
	                }
	            }
	            value = token.value;
	        }
	        else {
	            value = 'ILLEGAL';
	        }
	        msg = msg.replace('%0', value);
	        if (token && typeof token.lineNumber === 'number') {
	            var index = token.start;
	            var line = token.lineNumber;
	            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
	            var column = token.start - lastMarkerLineStart + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	        else {
	            var index = this.lastMarker.index;
	            var line = this.lastMarker.line;
	            var column = this.lastMarker.column + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	    };
	    Parser.prototype.throwUnexpectedToken = function (token, message) {
	        throw this.unexpectedTokenError(token, message);
	    };
	    Parser.prototype.tolerateUnexpectedToken = function (token, message) {
	        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
	    };
	    Parser.prototype.collectComments = function () {
	        if (!this.config.comment) {
	            this.scanner.scanComments();
	        }
	        else {
	            var comments = this.scanner.scanComments();
	            if (comments.length > 0 && this.delegate) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var node = void 0;
	                    node = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
	                    };
	                    if (this.config.range) {
	                        node.range = e.range;
	                    }
	                    if (this.config.loc) {
	                        node.loc = e.loc;
	                    }
	                    var metadata = {
	                        start: {
	                            line: e.loc.start.line,
	                            column: e.loc.start.column,
	                            offset: e.range[0]
	                        },
	                        end: {
	                            line: e.loc.end.line,
	                            column: e.loc.end.column,
	                            offset: e.range[1]
	                        }
	                    };
	                    this.delegate(node, metadata);
	                }
	            }
	        }
	    };
	    // From internal representation to an external structure
	    Parser.prototype.getTokenRaw = function (token) {
	        return this.scanner.source.slice(token.start, token.end);
	    };
	    Parser.prototype.convertToken = function (token) {
	        var t = {
	            type: token_1.TokenName[token.type],
	            value: this.getTokenRaw(token)
	        };
	        if (this.config.range) {
	            t.range = [token.start, token.end];
	        }
	        if (this.config.loc) {
	            t.loc = {
	                start: {
	                    line: this.startMarker.line,
	                    column: this.startMarker.column
	                },
	                end: {
	                    line: this.scanner.lineNumber,
	                    column: this.scanner.index - this.scanner.lineStart
	                }
	            };
	        }
	        if (token.type === 9 /* RegularExpression */) {
	            var pattern = token.pattern;
	            var flags = token.flags;
	            t.regex = { pattern: pattern, flags: flags };
	        }
	        return t;
	    };
	    Parser.prototype.nextToken = function () {
	        var token = this.lookahead;
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        this.collectComments();
	        if (this.scanner.index !== this.startMarker.index) {
	            this.startMarker.index = this.scanner.index;
	            this.startMarker.line = this.scanner.lineNumber;
	            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        }
	        var next = this.scanner.lex();
	        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
	        if (next && this.context.strict && next.type === 3 /* Identifier */) {
	            if (this.scanner.isStrictModeReservedWord(next.value)) {
	                next.type = 4 /* Keyword */;
	            }
	        }
	        this.lookahead = next;
	        if (this.config.tokens && next.type !== 2 /* EOF */) {
	            this.tokens.push(this.convertToken(next));
	        }
	        return token;
	    };
	    Parser.prototype.nextRegexToken = function () {
	        this.collectComments();
	        var token = this.scanner.scanRegExp();
	        if (this.config.tokens) {
	            // Pop the previous token, '/' or '/='
	            // This is added from the lookahead token.
	            this.tokens.pop();
	            this.tokens.push(this.convertToken(token));
	        }
	        // Prime the next lookahead.
	        this.lookahead = token;
	        this.nextToken();
	        return token;
	    };
	    Parser.prototype.createNode = function () {
	        return {
	            index: this.startMarker.index,
	            line: this.startMarker.line,
	            column: this.startMarker.column
	        };
	    };
	    Parser.prototype.startNode = function (token) {
	        return {
	            index: token.start,
	            line: token.lineNumber,
	            column: token.start - token.lineStart
	        };
	    };
	    Parser.prototype.finalize = function (marker, node) {
	        if (this.config.range) {
	            node.range = [marker.index, this.lastMarker.index];
	        }
	        if (this.config.loc) {
	            node.loc = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column
	                }
	            };
	            if (this.config.source) {
	                node.loc.source = this.config.source;
	            }
	        }
	        if (this.delegate) {
	            var metadata = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                    offset: marker.index
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column,
	                    offset: this.lastMarker.index
	                }
	            };
	            this.delegate(node, metadata);
	        }
	        return node;
	    };
	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    Parser.prototype.expect = function (value) {
	        var token = this.nextToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
	    Parser.prototype.expectCommaSeparator = function () {
	        if (this.config.tolerant) {
	            var token = this.lookahead;
	            if (token.type === 7 /* Punctuator */ && token.value === ',') {
	                this.nextToken();
	            }
	            else if (token.type === 7 /* Punctuator */ && token.value === ';') {
	                this.nextToken();
	                this.tolerateUnexpectedToken(token);
	            }
	            else {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
	            }
	        }
	        else {
	            this.expect(',');
	        }
	    };
	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.
	    Parser.prototype.expectKeyword = function (keyword) {
	        var token = this.nextToken();
	        if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next token matches the specified punctuator.
	    Parser.prototype.match = function (value) {
	        return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
	    };
	    // Return true if the next token matches the specified keyword
	    Parser.prototype.matchKeyword = function (keyword) {
	        return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token matches the specified contextual keyword
	    // (where an identifier is sometimes a keyword depending on the context)
	    Parser.prototype.matchContextualKeyword = function (keyword) {
	        return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token is an assignment operator
	    Parser.prototype.matchAssign = function () {
	        if (this.lookahead.type !== 7 /* Punctuator */) {
	            return false;
	        }
	        var op = this.lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '**=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    };
	    // Cover grammar support.
	    //
	    // When an assignment expression position starts with an left parenthesis, the determination of the type
	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	    //
	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
	    // after the outermost pair is closed. They are:
	    //
	    //   1. AssignmentExpression
	    //   2. BindingElements
	    //   3. AssignmentTargets
	    //
	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
	    // binding element or assignment target.
	    //
	    // The three productions have the relationship:
	    //
	    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
	    //
	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	    //
	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	    // the CoverInitializedName check is conducted.
	    //
	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	    // pattern. The CoverInitializedName check is deferred.
	    Parser.prototype.isolateCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        if (this.context.firstCoverInitializedNameError !== null) {
	            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
	        }
	        this.context.isBindingElement = previousIsBindingElement;
	        this.context.isAssignmentTarget = previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.inheritCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
	        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.consumeSemicolon = function () {
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else if (!this.hasLineTerminator) {
	            if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.lastMarker.index = this.startMarker.index;
	            this.lastMarker.line = this.startMarker.line;
	            this.lastMarker.column = this.startMarker.column;
	        }
	    };
	    // https://tc39.github.io/ecma262/#sec-primary-expression
	    Parser.prototype.parsePrimaryExpression = function () {
	        var node = this.createNode();
	        var expr;
	        var token, raw;
	        switch (this.lookahead.type) {
	            case 3 /* Identifier */:
	                if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
	                    this.tolerateUnexpectedToken(this.lookahead);
	                }
	                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
	                break;
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	                if (this.context.strict && this.lookahead.octal) {
	                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
	                }
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 1 /* BooleanLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
	                break;
	            case 5 /* NullLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(null, raw));
	                break;
	            case 10 /* Template */:
	                expr = this.parseTemplateLiteral();
	                break;
	            case 7 /* Punctuator */:
	                switch (this.lookahead.value) {
	                    case '(':
	                        this.context.isBindingElement = false;
	                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
	                        break;
	                    case '[':
	                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
	                        break;
	                    case '{':
	                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
	                        break;
	                    case '/':
	                    case '/=':
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                        this.scanner.index = this.startMarker.index;
	                        token = this.nextRegexToken();
	                        raw = this.getTokenRaw(token);
	                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
	                        break;
	                    default:
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                }
	                break;
	            case 4 /* Keyword */:
	                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
	                    expr = this.parseIdentifierName();
	                }
	                else if (!this.context.strict && this.matchKeyword('let')) {
	                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
	                }
	                else {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    if (this.matchKeyword('function')) {
	                        expr = this.parseFunctionExpression();
	                    }
	                    else if (this.matchKeyword('this')) {
	                        this.nextToken();
	                        expr = this.finalize(node, new Node.ThisExpression());
	                    }
	                    else if (this.matchKeyword('class')) {
	                        expr = this.parseClassExpression();
	                    }
	                    else {
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                    }
	                }
	                break;
	            default:
	                expr = this.throwUnexpectedToken(this.nextToken());
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-array-initializer
	    Parser.prototype.parseSpreadElement = function () {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
	        return this.finalize(node, new Node.SpreadElement(arg));
	    };
	    Parser.prototype.parseArrayInitializer = function () {
	        var node = this.createNode();
	        var elements = [];
	        this.expect('[');
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else if (this.match('...')) {
	                var element = this.parseSpreadElement();
	                if (!this.match(']')) {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    this.expect(',');
	                }
	                elements.push(element);
	            }
	            else {
	                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayExpression(elements));
	    };
	    // https://tc39.github.io/ecma262/#sec-object-initializer
	    Parser.prototype.parsePropertyMethod = function (params) {
	        this.context.isAssignmentTarget = false;
	        this.context.isBindingElement = false;
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = params.simple;
	        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
	        if (this.context.strict && params.firstRestricted) {
	            this.tolerateUnexpectedToken(params.firstRestricted, params.message);
	        }
	        if (this.context.strict && params.stricted) {
	            this.tolerateUnexpectedToken(params.stricted, params.message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        return body;
	    };
	    Parser.prototype.parsePropertyMethodFunction = function () {
	        var isGenerator = false;
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = false;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    Parser.prototype.parsePropertyMethodAsyncFunction = function () {
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        var previousAwait = this.context.await;
	        this.context.allowYield = false;
	        this.context.await = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        this.context.await = previousAwait;
	        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
	    };
	    Parser.prototype.parseObjectPropertyKey = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        var key;
	        switch (token.type) {
	            case 8 /* StringLiteral */:
	            case 6 /* NumericLiteral */:
	                if (this.context.strict && token.octal) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
	                }
	                var raw = this.getTokenRaw(token);
	                key = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 3 /* Identifier */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 4 /* Keyword */:
	                key = this.finalize(node, new Node.Identifier(token.value));
	                break;
	            case 7 /* Punctuator */:
	                if (token.value === '[') {
	                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    this.expect(']');
	                }
	                else {
	                    key = this.throwUnexpectedToken(token);
	                }
	                break;
	            default:
	                key = this.throwUnexpectedToken(token);
	        }
	        return key;
	    };
	    Parser.prototype.isPropertyKey = function (key, value) {
	        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||
	            (key.type === syntax_1.Syntax.Literal && key.value === value);
	    };
	    Parser.prototype.parseObjectProperty = function (hasProto) {
	        var node = this.createNode();
	        var token = this.lookahead;
	        var kind;
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var shorthand = false;
	        var isAsync = false;
	        if (token.type === 3 /* Identifier */) {
	            var id = token.value;
	            this.nextToken();
	            computed = this.match('[');
	            isAsync = !this.hasLineTerminator && (id === 'async') &&
	                !this.match(':') && !this.match('(') && !this.match('*');
	            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
	        }
	        else if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
	            kind = 'get';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.context.allowYield = false;
	            value = this.parseGetterMethod();
	        }
	        else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
	            kind = 'set';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseSetterMethod();
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        else {
	            if (!key) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            kind = 'init';
	            if (this.match(':') && !isAsync) {
	                if (!computed && this.isPropertyKey(key, '__proto__')) {
	                    if (hasProto.value) {
	                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
	                    }
	                    hasProto.value = true;
	                }
	                this.nextToken();
	                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
	            }
	            else if (this.match('(')) {
	                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	                method = true;
	            }
	            else if (token.type === 3 /* Identifier */) {
	                var id = this.finalize(node, new Node.Identifier(token.value));
	                if (this.match('=')) {
	                    this.context.firstCoverInitializedNameError = this.lookahead;
	                    this.nextToken();
	                    shorthand = true;
	                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
	                }
	                else {
	                    shorthand = true;
	                    value = id;
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectInitializer = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var properties = [];
	        var hasProto = { value: false };
	        while (!this.match('}')) {
	            properties.push(this.parseObjectProperty(hasProto));
	            if (!this.match('}')) {
	                this.expectCommaSeparator();
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectExpression(properties));
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literals
	    Parser.prototype.parseTemplateHead = function () {
	        assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateElement = function () {
	        if (this.lookahead.type !== 10 /* Template */) {
	            this.throwUnexpectedToken();
	        }
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateLiteral = function () {
	        var node = this.createNode();
	        var expressions = [];
	        var quasis = [];
	        var quasi = this.parseTemplateHead();
	        quasis.push(quasi);
	        while (!quasi.tail) {
	            expressions.push(this.parseExpression());
	            quasi = this.parseTemplateElement();
	            quasis.push(quasi);
	        }
	        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
	    };
	    // https://tc39.github.io/ecma262/#sec-grouping-operator
	    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	            case syntax_1.Syntax.MemberExpression:
	            case syntax_1.Syntax.RestElement:
	            case syntax_1.Syntax.AssignmentPattern:
	                break;
	            case syntax_1.Syntax.SpreadElement:
	                expr.type = syntax_1.Syntax.RestElement;
	                this.reinterpretExpressionAsPattern(expr.argument);
	                break;
	            case syntax_1.Syntax.ArrayExpression:
	                expr.type = syntax_1.Syntax.ArrayPattern;
	                for (var i = 0; i < expr.elements.length; i++) {
	                    if (expr.elements[i] !== null) {
	                        this.reinterpretExpressionAsPattern(expr.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectExpression:
	                expr.type = syntax_1.Syntax.ObjectPattern;
	                for (var i = 0; i < expr.properties.length; i++) {
	                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
	                }
	                break;
	            case syntax_1.Syntax.AssignmentExpression:
	                expr.type = syntax_1.Syntax.AssignmentPattern;
	                delete expr.operator;
	                this.reinterpretExpressionAsPattern(expr.left);
	                break;
	            default:
	                // Allow other node type for tolerant parsing.
	                break;
	        }
	    };
	    Parser.prototype.parseGroupExpression = function () {
	        var expr;
	        this.expect('(');
	        if (this.match(')')) {
	            this.nextToken();
	            if (!this.match('=>')) {
	                this.expect('=>');
	            }
	            expr = {
	                type: ArrowParameterPlaceHolder,
	                params: [],
	                async: false
	            };
	        }
	        else {
	            var startToken = this.lookahead;
	            var params = [];
	            if (this.match('...')) {
	                expr = this.parseRestElement(params);
	                this.expect(')');
	                if (!this.match('=>')) {
	                    this.expect('=>');
	                }
	                expr = {
	                    type: ArrowParameterPlaceHolder,
	                    params: [expr],
	                    async: false
	                };
	            }
	            else {
	                var arrow = false;
	                this.context.isBindingElement = true;
	                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                if (this.match(',')) {
	                    var expressions = [];
	                    this.context.isAssignmentTarget = false;
	                    expressions.push(expr);
	                    while (this.lookahead.type !== 2 /* EOF */) {
	                        if (!this.match(',')) {
	                            break;
	                        }
	                        this.nextToken();
	                        if (this.match(')')) {
	                            this.nextToken();
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else if (this.match('...')) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            expressions.push(this.parseRestElement(params));
	                            this.expect(')');
	                            if (!this.match('=>')) {
	                                this.expect('=>');
	                            }
	                            this.context.isBindingElement = false;
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else {
	                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        if (arrow) {
	                            break;
	                        }
	                    }
	                    if (!arrow) {
	                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	                    }
	                }
	                if (!arrow) {
	                    this.expect(')');
	                    if (this.match('=>')) {
	                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: [expr],
	                                async: false
	                            };
	                        }
	                        if (!arrow) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            if (expr.type === syntax_1.Syntax.SequenceExpression) {
	                                for (var i = 0; i < expr.expressions.length; i++) {
	                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);
	                                }
	                            }
	                            else {
	                                this.reinterpretExpressionAsPattern(expr);
	                            }
	                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: parameters,
	                                async: false
	                            };
	                        }
	                    }
	                    this.context.isBindingElement = false;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
	    Parser.prototype.parseArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAssignmentExpression);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.isIdentifierName = function (token) {
	        return token.type === 3 /* Identifier */ ||
	            token.type === 4 /* Keyword */ ||
	            token.type === 1 /* BooleanLiteral */ ||
	            token.type === 5 /* NullLiteral */;
	    };
	    Parser.prototype.parseIdentifierName = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (!this.isIdentifierName(token)) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseNewExpression = function () {
	        var node = this.createNode();
	        var id = this.parseIdentifierName();
	        assert_1.assert(id.name === 'new', 'New expression must start with `new`');
	        var expr;
	        if (this.match('.')) {
	            this.nextToken();
	            if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
	                var property = this.parseIdentifierName();
	                expr = new Node.MetaProperty(id, property);
	            }
	            else {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
	            var args = this.match('(') ? this.parseArguments() : [];
	            expr = new Node.NewExpression(callee, args);
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return this.finalize(node, expr);
	    };
	    Parser.prototype.parseAsyncArgument = function () {
	        var arg = this.parseAssignmentExpression();
	        this.context.firstCoverInitializedNameError = null;
	        return arg;
	    };
	    Parser.prototype.parseAsyncArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAsyncArgument);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
	        var startToken = this.lookahead;
	        var maybeAsync = this.matchContextualKeyword('async');
	        var previousAllowIn = this.context.allowIn;
	        this.context.allowIn = true;
	        var expr;
	        if (this.matchKeyword('super') && this.context.inFunctionBody) {
	            expr = this.createNode();
	            this.nextToken();
	            expr = this.finalize(expr, new Node.Super());
	            if (!this.match('(') && !this.match('.') && !this.match('[')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        }
	        while (true) {
	            if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.match('(')) {
	                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = false;
	                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
	                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
	                if (asyncArrow && this.match('=>')) {
	                    for (var i = 0; i < args.length; ++i) {
	                        this.reinterpretExpressionAsPattern(args[i]);
	                    }
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: args,
	                        async: true
	                    };
	                }
	            }
	            else if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        this.context.allowIn = previousAllowIn;
	        return expr;
	    };
	    Parser.prototype.parseSuper = function () {
	        var node = this.createNode();
	        this.expectKeyword('super');
	        if (!this.match('[') && !this.match('.')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        return this.finalize(node, new Node.Super());
	    };
	    Parser.prototype.parseLeftHandSideExpression = function () {
	        assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
	        var node = this.startNode(this.lookahead);
	        var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :
	            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        while (true) {
	            if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-update-expressions
	    Parser.prototype.parseUpdateExpression = function () {
	        var expr;
	        var startToken = this.lookahead;
	        if (this.match('++') || this.match('--')) {
	            var node = this.startNode(startToken);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
	            }
	            if (!this.context.isAssignmentTarget) {
	                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	            }
	            var prefix = true;
	            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
	                if (this.match('++') || this.match('--')) {
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
	                    }
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    var operator = this.nextToken().value;
	                    var prefix = false;
	                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-unary-operators
	    Parser.prototype.parseAwaitExpression = function () {
	        var node = this.createNode();
	        this.nextToken();
	        var argument = this.parseUnaryExpression();
	        return this.finalize(node, new Node.AwaitExpression(argument));
	    };
	    Parser.prototype.parseUnaryExpression = function () {
	        var expr;
	        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||
	            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
	            var node = this.startNode(this.lookahead);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
	            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
	                this.tolerateError(messages_1.Messages.StrictDelete);
	            }
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else if (this.context.await && this.matchContextualKeyword('await')) {
	            expr = this.parseAwaitExpression();
	        }
	        else {
	            expr = this.parseUpdateExpression();
	        }
	        return expr;
	    };
	    Parser.prototype.parseExponentiationExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-exp-operator
	    // https://tc39.github.io/ecma262/#sec-multiplicative-operators
	    // https://tc39.github.io/ecma262/#sec-additive-operators
	    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
	    // https://tc39.github.io/ecma262/#sec-relational-operators
	    // https://tc39.github.io/ecma262/#sec-equality-operators
	    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
	    // https://tc39.github.io/ecma262/#sec-binary-logical-operators
	    Parser.prototype.binaryPrecedence = function (token) {
	        var op = token.value;
	        var precedence;
	        if (token.type === 7 /* Punctuator */) {
	            precedence = this.operatorPrecedence[op] || 0;
	        }
	        else if (token.type === 4 /* Keyword */) {
	            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;
	        }
	        else {
	            precedence = 0;
	        }
	        return precedence;
	    };
	    Parser.prototype.parseBinaryExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
	        var token = this.lookahead;
	        var prec = this.binaryPrecedence(token);
	        if (prec > 0) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var markers = [startToken, this.lookahead];
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            var stack = [left, token.value, right];
	            var precedences = [prec];
	            while (true) {
	                prec = this.binaryPrecedence(this.lookahead);
	                if (prec <= 0) {
	                    break;
	                }
	                // Reduce: make a binary expression from the three topmost entries.
	                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {
	                    right = stack.pop();
	                    var operator = stack.pop();
	                    precedences.pop();
	                    left = stack.pop();
	                    markers.pop();
	                    var node = this.startNode(markers[markers.length - 1]);
	                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
	                }
	                // Shift.
	                stack.push(this.nextToken().value);
	                precedences.push(prec);
	                markers.push(this.lookahead);
	                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
	            }
	            // Final reduce to clean-up the stack.
	            var i = stack.length - 1;
	            expr = stack[i];
	            markers.pop();
	            while (i > 1) {
	                var node = this.startNode(markers.pop());
	                var operator = stack[i - 1];
	                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
	                i -= 2;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-conditional-operator
	    Parser.prototype.parseConditionalExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
	        if (this.match('?')) {
	            this.nextToken();
	            var previousAllowIn = this.context.allowIn;
	            this.context.allowIn = true;
	            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowIn = previousAllowIn;
	            this.expect(':');
	            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-assignment-operators
	    Parser.prototype.checkPatternParam = function (options, param) {
	        switch (param.type) {
	            case syntax_1.Syntax.Identifier:
	                this.validateParam(options, param, param.name);
	                break;
	            case syntax_1.Syntax.RestElement:
	                this.checkPatternParam(options, param.argument);
	                break;
	            case syntax_1.Syntax.AssignmentPattern:
	                this.checkPatternParam(options, param.left);
	                break;
	            case syntax_1.Syntax.ArrayPattern:
	                for (var i = 0; i < param.elements.length; i++) {
	                    if (param.elements[i] !== null) {
	                        this.checkPatternParam(options, param.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectPattern:
	                for (var i = 0; i < param.properties.length; i++) {
	                    this.checkPatternParam(options, param.properties[i].value);
	                }
	                break;
	            default:
	                break;
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	    };
	    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
	        var params = [expr];
	        var options;
	        var asyncArrow = false;
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	                break;
	            case ArrowParameterPlaceHolder:
	                params = expr.params;
	                asyncArrow = expr.async;
	                break;
	            default:
	                return null;
	        }
	        options = {
	            simple: true,
	            paramSet: {}
	        };
	        for (var i = 0; i < params.length; ++i) {
	            var param = params[i];
	            if (param.type === syntax_1.Syntax.AssignmentPattern) {
	                if (param.right.type === syntax_1.Syntax.YieldExpression) {
	                    if (param.right.argument) {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                    param.right.type = syntax_1.Syntax.Identifier;
	                    param.right.name = 'yield';
	                    delete param.right.argument;
	                    delete param.right.delegate;
	                }
	            }
	            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.checkPatternParam(options, param);
	            params[i] = param;
	        }
	        if (this.context.strict || !this.context.allowYield) {
	            for (var i = 0; i < params.length; ++i) {
	                var param = params[i];
	                if (param.type === syntax_1.Syntax.YieldExpression) {
	                    this.throwUnexpectedToken(this.lookahead);
	                }
	            }
	        }
	        if (options.message === messages_1.Messages.StrictParamDupe) {
	            var token = this.context.strict ? options.stricted : options.firstRestricted;
	            this.throwUnexpectedToken(token, options.message);
	        }
	        return {
	            simple: options.simple,
	            params: params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.parseAssignmentExpression = function () {
	        var expr;
	        if (!this.context.allowYield && this.matchKeyword('yield')) {
	            expr = this.parseYieldExpression();
	        }
	        else {
	            var startToken = this.lookahead;
	            var token = startToken;
	            expr = this.parseConditionalExpression();
	            if (token.type === 3 /* Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {
	                if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
	                    var arg = this.parsePrimaryExpression();
	                    this.reinterpretExpressionAsPattern(arg);
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: [arg],
	                        async: true
	                    };
	                }
	            }
	            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
	                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                var isAsync = expr.async;
	                var list = this.reinterpretAsCoverFormalsList(expr);
	                if (list) {
	                    if (this.hasLineTerminator) {
	                        this.tolerateUnexpectedToken(this.lookahead);
	                    }
	                    this.context.firstCoverInitializedNameError = null;
	                    var previousStrict = this.context.strict;
	                    var previousAllowStrictDirective = this.context.allowStrictDirective;
	                    this.context.allowStrictDirective = list.simple;
	                    var previousAllowYield = this.context.allowYield;
	                    var previousAwait = this.context.await;
	                    this.context.allowYield = true;
	                    this.context.await = isAsync;
	                    var node = this.startNode(startToken);
	                    this.expect('=>');
	                    var body = void 0;
	                    if (this.match('{')) {
	                        var previousAllowIn = this.context.allowIn;
	                        this.context.allowIn = true;
	                        body = this.parseFunctionSourceElements();
	                        this.context.allowIn = previousAllowIn;
	                    }
	                    else {
	                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    }
	                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
	                    if (this.context.strict && list.firstRestricted) {
	                        this.throwUnexpectedToken(list.firstRestricted, list.message);
	                    }
	                    if (this.context.strict && list.stricted) {
	                        this.tolerateUnexpectedToken(list.stricted, list.message);
	                    }
	                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :
	                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
	                    this.context.strict = previousStrict;
	                    this.context.allowStrictDirective = previousAllowStrictDirective;
	                    this.context.allowYield = previousAllowYield;
	                    this.context.await = previousAwait;
	                }
	            }
	            else {
	                if (this.matchAssign()) {
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
	                        var id = expr;
	                        if (this.scanner.isRestrictedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
	                        }
	                        if (this.scanner.isStrictModeReservedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	                        }
	                    }
	                    if (!this.match('=')) {
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                    }
	                    else {
	                        this.reinterpretExpressionAsPattern(expr);
	                    }
	                    token = this.nextToken();
	                    var operator = token.value;
	                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
	                    this.context.firstCoverInitializedNameError = null;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-comma-operator
	    Parser.prototype.parseExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        if (this.match(',')) {
	            var expressions = [];
	            expressions.push(expr);
	            while (this.lookahead.type !== 2 /* EOF */) {
	                if (!this.match(',')) {
	                    break;
	                }
	                this.nextToken();
	                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	            }
	            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-block
	    Parser.prototype.parseStatementListItem = function () {
	        var statement;
	        this.context.isAssignmentTarget = true;
	        this.context.isBindingElement = true;
	        if (this.lookahead.type === 4 /* Keyword */) {
	            switch (this.lookahead.value) {
	                case 'export':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
	                    }
	                    statement = this.parseExportDeclaration();
	                    break;
	                case 'import':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
	                    }
	                    statement = this.parseImportDeclaration();
	                    break;
	                case 'const':
	                    statement = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'function':
	                    statement = this.parseFunctionDeclaration();
	                    break;
	                case 'class':
	                    statement = this.parseClassDeclaration();
	                    break;
	                case 'let':
	                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
	                    break;
	                default:
	                    statement = this.parseStatement();
	                    break;
	            }
	        }
	        else {
	            statement = this.parseStatement();
	        }
	        return statement;
	    };
	    Parser.prototype.parseBlock = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var block = [];
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            block.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.BlockStatement(block));
	    };
	    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations
	    Parser.prototype.parseLexicalBinding = function (kind, options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, kind);
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (kind === 'const') {
	            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
	                if (this.match('=')) {
	                    this.nextToken();
	                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                }
	                else {
	                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
	                }
	            }
	        }
	        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {
	            this.expect('=');
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseBindingList = function (kind, options) {
	        var list = [this.parseLexicalBinding(kind, options)];
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseLexicalBinding(kind, options));
	        }
	        return list;
	    };
	    Parser.prototype.isLexicalDeclaration = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.scanner.lex();
	        this.scanner.restoreState(state);
	        return (next.type === 3 /* Identifier */) ||
	            (next.type === 7 /* Punctuator */ && next.value === '[') ||
	            (next.type === 7 /* Punctuator */ && next.value === '{') ||
	            (next.type === 4 /* Keyword */ && next.value === 'let') ||
	            (next.type === 4 /* Keyword */ && next.value === 'yield');
	    };
	    Parser.prototype.parseLexicalDeclaration = function (options) {
	        var node = this.createNode();
	        var kind = this.nextToken().value;
	        assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
	        var declarations = this.parseBindingList(kind, options);
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
	    };
	    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
	    Parser.prototype.parseBindingRestElement = function (params, kind) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params, kind);
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseArrayPattern = function (params, kind) {
	        var node = this.createNode();
	        this.expect('[');
	        var elements = [];
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else {
	                if (this.match('...')) {
	                    elements.push(this.parseBindingRestElement(params, kind));
	                    break;
	                }
	                else {
	                    elements.push(this.parsePatternWithDefault(params, kind));
	                }
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayPattern(elements));
	    };
	    Parser.prototype.parsePropertyPattern = function (params, kind) {
	        var node = this.createNode();
	        var computed = false;
	        var shorthand = false;
	        var method = false;
	        var key;
	        var value;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            var keyToken = this.lookahead;
	            key = this.parseVariableIdentifier();
	            var init = this.finalize(node, new Node.Identifier(keyToken.value));
	            if (this.match('=')) {
	                params.push(keyToken);
	                shorthand = true;
	                this.nextToken();
	                var expr = this.parseAssignmentExpression();
	                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
	            }
	            else if (!this.match(':')) {
	                params.push(keyToken);
	                shorthand = true;
	                value = init;
	            }
	            else {
	                this.expect(':');
	                value = this.parsePatternWithDefault(params, kind);
	            }
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.expect(':');
	            value = this.parsePatternWithDefault(params, kind);
	        }
	        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectPattern = function (params, kind) {
	        var node = this.createNode();
	        var properties = [];
	        this.expect('{');
	        while (!this.match('}')) {
	            properties.push(this.parsePropertyPattern(params, kind));
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectPattern(properties));
	    };
	    Parser.prototype.parsePattern = function (params, kind) {
	        var pattern;
	        if (this.match('[')) {
	            pattern = this.parseArrayPattern(params, kind);
	        }
	        else if (this.match('{')) {
	            pattern = this.parseObjectPattern(params, kind);
	        }
	        else {
	            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
	                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
	            }
	            params.push(this.lookahead);
	            pattern = this.parseVariableIdentifier(kind);
	        }
	        return pattern;
	    };
	    Parser.prototype.parsePatternWithDefault = function (params, kind) {
	        var startToken = this.lookahead;
	        var pattern = this.parsePattern(params, kind);
	        if (this.match('=')) {
	            this.nextToken();
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = true;
	            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowYield = previousAllowYield;
	            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
	        }
	        return pattern;
	    };
	    // https://tc39.github.io/ecma262/#sec-variable-statement
	    Parser.prototype.parseVariableIdentifier = function (kind) {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (token.type === 4 /* Keyword */ && token.value === 'yield') {
	            if (this.context.strict) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else if (!this.context.allowYield) {
	                this.throwUnexpectedToken(token);
	            }
	        }
	        else if (token.type !== 3 /* Identifier */) {
	            if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else {
	                if (this.context.strict || token.value !== 'let' || kind !== 'var') {
	                    this.throwUnexpectedToken(token);
	                }
	            }
	        }
	        else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
	            this.tolerateUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseVariableDeclaration = function (options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, 'var');
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (this.match('=')) {
	            this.nextToken();
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
	            this.expect('=');
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseVariableDeclarationList = function (options) {
	        var opt = { inFor: options.inFor };
	        var list = [];
	        list.push(this.parseVariableDeclaration(opt));
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseVariableDeclaration(opt));
	        }
	        return list;
	    };
	    Parser.prototype.parseVariableStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('var');
	        var declarations = this.parseVariableDeclarationList({ inFor: false });
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
	    };
	    // https://tc39.github.io/ecma262/#sec-empty-statement
	    Parser.prototype.parseEmptyStatement = function () {
	        var node = this.createNode();
	        this.expect(';');
	        return this.finalize(node, new Node.EmptyStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-expression-statement
	    Parser.prototype.parseExpressionStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ExpressionStatement(expr));
	    };
	    // https://tc39.github.io/ecma262/#sec-if-statement
	    Parser.prototype.parseIfClause = function () {
	        if (this.context.strict && this.matchKeyword('function')) {
	            this.tolerateError(messages_1.Messages.StrictFunction);
	        }
	        return this.parseStatement();
	    };
	    Parser.prototype.parseIfStatement = function () {
	        var node = this.createNode();
	        var consequent;
	        var alternate = null;
	        this.expectKeyword('if');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            consequent = this.parseIfClause();
	            if (this.matchKeyword('else')) {
	                this.nextToken();
	                alternate = this.parseIfClause();
	            }
	        }
	        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
	    };
	    // https://tc39.github.io/ecma262/#sec-do-while-statement
	    Parser.prototype.parseDoWhileStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('do');
	        var previousInIteration = this.context.inIteration;
	        this.context.inIteration = true;
	        var body = this.parseStatement();
	        this.context.inIteration = previousInIteration;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	        }
	        else {
	            this.expect(')');
	            if (this.match(';')) {
	                this.nextToken();
	            }
	        }
	        return this.finalize(node, new Node.DoWhileStatement(body, test));
	    };
	    // https://tc39.github.io/ecma262/#sec-while-statement
	    Parser.prototype.parseWhileStatement = function () {
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.parseStatement();
	            this.context.inIteration = previousInIteration;
	        }
	        return this.finalize(node, new Node.WhileStatement(test, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-for-statement
	    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
	    Parser.prototype.parseForStatement = function () {
	        var init = null;
	        var test = null;
	        var update = null;
	        var forIn = true;
	        var left, right;
	        var node = this.createNode();
	        this.expectKeyword('for');
	        this.expect('(');
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else {
	            if (this.matchKeyword('var')) {
	                init = this.createNode();
	                this.nextToken();
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                var declarations = this.parseVariableDeclarationList({ inFor: true });
	                this.context.allowIn = previousAllowIn;
	                if (declarations.length === 1 && this.matchKeyword('in')) {
	                    var decl = declarations[0];
	                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
	                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
	                    }
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.expect(';');
	                }
	            }
	            else if (this.matchKeyword('const') || this.matchKeyword('let')) {
	                init = this.createNode();
	                var kind = this.nextToken().value;
	                if (!this.context.strict && this.lookahead.value === 'in') {
	                    init = this.finalize(init, new Node.Identifier(kind));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else {
	                    var previousAllowIn = this.context.allowIn;
	                    this.context.allowIn = false;
	                    var declarations = this.parseBindingList(kind, { inFor: true });
	                    this.context.allowIn = previousAllowIn;
	                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseExpression();
	                        init = null;
	                    }
	                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseAssignmentExpression();
	                        init = null;
	                        forIn = false;
	                    }
	                    else {
	                        this.consumeSemicolon();
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                    }
	                }
	            }
	            else {
	                var initStartToken = this.lookahead;
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                this.context.allowIn = previousAllowIn;
	                if (this.matchKeyword('in')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (this.matchContextualKeyword('of')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    if (this.match(',')) {
	                        var initSeq = [init];
	                        while (this.match(',')) {
	                            this.nextToken();
	                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
	                    }
	                    this.expect(';');
	                }
	            }
	        }
	        if (typeof left === 'undefined') {
	            if (!this.match(';')) {
	                test = this.parseExpression();
	            }
	            this.expect(';');
	            if (!this.match(')')) {
	                update = this.parseExpression();
	            }
	        }
	        var body;
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.isolateCoverGrammar(this.parseStatement);
	            this.context.inIteration = previousInIteration;
	        }
	        return (typeof left === 'undefined') ?
	            this.finalize(node, new Node.ForStatement(init, test, update, body)) :
	            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :
	                this.finalize(node, new Node.ForOfStatement(left, right, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-continue-statement
	    Parser.prototype.parseContinueStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('continue');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            label = id;
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration) {
	            this.throwError(messages_1.Messages.IllegalContinue);
	        }
	        return this.finalize(node, new Node.ContinueStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-break-statement
	    Parser.prototype.parseBreakStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('break');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	            label = id;
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration && !this.context.inSwitch) {
	            this.throwError(messages_1.Messages.IllegalBreak);
	        }
	        return this.finalize(node, new Node.BreakStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-return-statement
	    Parser.prototype.parseReturnStatement = function () {
	        if (!this.context.inFunctionBody) {
	            this.tolerateError(messages_1.Messages.IllegalReturn);
	        }
	        var node = this.createNode();
	        this.expectKeyword('return');
	        var hasArgument = !this.match(';') && !this.match('}') &&
	            !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */;
	        var argument = hasArgument ? this.parseExpression() : null;
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ReturnStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-with-statement
	    Parser.prototype.parseWithStatement = function () {
	        if (this.context.strict) {
	            this.tolerateError(messages_1.Messages.StrictModeWith);
	        }
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('with');
	        this.expect('(');
	        var object = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            body = this.parseStatement();
	        }
	        return this.finalize(node, new Node.WithStatement(object, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-switch-statement
	    Parser.prototype.parseSwitchCase = function () {
	        var node = this.createNode();
	        var test;
	        if (this.matchKeyword('default')) {
	            this.nextToken();
	            test = null;
	        }
	        else {
	            this.expectKeyword('case');
	            test = this.parseExpression();
	        }
	        this.expect(':');
	        var consequent = [];
	        while (true) {
	            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
	                break;
	            }
	            consequent.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.SwitchCase(test, consequent));
	    };
	    Parser.prototype.parseSwitchStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('switch');
	        this.expect('(');
	        var discriminant = this.parseExpression();
	        this.expect(')');
	        var previousInSwitch = this.context.inSwitch;
	        this.context.inSwitch = true;
	        var cases = [];
	        var defaultFound = false;
	        this.expect('{');
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            var clause = this.parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }
	        this.expect('}');
	        this.context.inSwitch = previousInSwitch;
	        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
	    };
	    // https://tc39.github.io/ecma262/#sec-labelled-statements
	    Parser.prototype.parseLabelledStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var statement;
	        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {
	            this.nextToken();
	            var id = expr;
	            var key = '$' + id.name;
	            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
	            }
	            this.context.labelSet[key] = true;
	            var body = void 0;
	            if (this.matchKeyword('class')) {
	                this.tolerateUnexpectedToken(this.lookahead);
	                body = this.parseClassDeclaration();
	            }
	            else if (this.matchKeyword('function')) {
	                var token = this.lookahead;
	                var declaration = this.parseFunctionDeclaration();
	                if (this.context.strict) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
	                }
	                else if (declaration.generator) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
	                }
	                body = declaration;
	            }
	            else {
	                body = this.parseStatement();
	            }
	            delete this.context.labelSet[key];
	            statement = new Node.LabeledStatement(id, body);
	        }
	        else {
	            this.consumeSemicolon();
	            statement = new Node.ExpressionStatement(expr);
	        }
	        return this.finalize(node, statement);
	    };
	    // https://tc39.github.io/ecma262/#sec-throw-statement
	    Parser.prototype.parseThrowStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('throw');
	        if (this.hasLineTerminator) {
	            this.throwError(messages_1.Messages.NewlineAfterThrow);
	        }
	        var argument = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ThrowStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-try-statement
	    Parser.prototype.parseCatchClause = function () {
	        var node = this.createNode();
	        this.expectKeyword('catch');
	        this.expect('(');
	        if (this.match(')')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        var params = [];
	        var param = this.parsePattern(params);
	        var paramMap = {};
	        for (var i = 0; i < params.length; i++) {
	            var key = '$' + params[i].value;
	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
	                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
	            }
	            paramMap[key] = true;
	        }
	        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(param.name)) {
	                this.tolerateError(messages_1.Messages.StrictCatchVariable);
	            }
	        }
	        this.expect(')');
	        var body = this.parseBlock();
	        return this.finalize(node, new Node.CatchClause(param, body));
	    };
	    Parser.prototype.parseFinallyClause = function () {
	        this.expectKeyword('finally');
	        return this.parseBlock();
	    };
	    Parser.prototype.parseTryStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('try');
	        var block = this.parseBlock();
	        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
	        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
	        if (!handler && !finalizer) {
	            this.throwError(messages_1.Messages.NoCatchOrFinally);
	        }
	        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
	    };
	    // https://tc39.github.io/ecma262/#sec-debugger-statement
	    Parser.prototype.parseDebuggerStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('debugger');
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.DebuggerStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
	    Parser.prototype.parseStatement = function () {
	        var statement;
	        switch (this.lookahead.type) {
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	            case 10 /* Template */:
	            case 9 /* RegularExpression */:
	                statement = this.parseExpressionStatement();
	                break;
	            case 7 /* Punctuator */:
	                var value = this.lookahead.value;
	                if (value === '{') {
	                    statement = this.parseBlock();
	                }
	                else if (value === '(') {
	                    statement = this.parseExpressionStatement();
	                }
	                else if (value === ';') {
	                    statement = this.parseEmptyStatement();
	                }
	                else {
	                    statement = this.parseExpressionStatement();
	                }
	                break;
	            case 3 /* Identifier */:
	                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
	                break;
	            case 4 /* Keyword */:
	                switch (this.lookahead.value) {
	                    case 'break':
	                        statement = this.parseBreakStatement();
	                        break;
	                    case 'continue':
	                        statement = this.parseContinueStatement();
	                        break;
	                    case 'debugger':
	                        statement = this.parseDebuggerStatement();
	                        break;
	                    case 'do':
	                        statement = this.parseDoWhileStatement();
	                        break;
	                    case 'for':
	                        statement = this.parseForStatement();
	                        break;
	                    case 'function':
	                        statement = this.parseFunctionDeclaration();
	                        break;
	                    case 'if':
	                        statement = this.parseIfStatement();
	                        break;
	                    case 'return':
	                        statement = this.parseReturnStatement();
	                        break;
	                    case 'switch':
	                        statement = this.parseSwitchStatement();
	                        break;
	                    case 'throw':
	                        statement = this.parseThrowStatement();
	                        break;
	                    case 'try':
	                        statement = this.parseTryStatement();
	                        break;
	                    case 'var':
	                        statement = this.parseVariableStatement();
	                        break;
	                    case 'while':
	                        statement = this.parseWhileStatement();
	                        break;
	                    case 'with':
	                        statement = this.parseWithStatement();
	                        break;
	                    default:
	                        statement = this.parseExpressionStatement();
	                        break;
	                }
	                break;
	            default:
	                statement = this.throwUnexpectedToken(this.lookahead);
	        }
	        return statement;
	    };
	    // https://tc39.github.io/ecma262/#sec-function-definitions
	    Parser.prototype.parseFunctionSourceElements = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var body = this.parseDirectivePrologues();
	        var previousLabelSet = this.context.labelSet;
	        var previousInIteration = this.context.inIteration;
	        var previousInSwitch = this.context.inSwitch;
	        var previousInFunctionBody = this.context.inFunctionBody;
	        this.context.labelSet = {};
	        this.context.inIteration = false;
	        this.context.inSwitch = false;
	        this.context.inFunctionBody = true;
	        while (this.lookahead.type !== 2 /* EOF */) {
	            if (this.match('}')) {
	                break;
	            }
	            body.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        this.context.labelSet = previousLabelSet;
	        this.context.inIteration = previousInIteration;
	        this.context.inSwitch = previousInSwitch;
	        this.context.inFunctionBody = previousInFunctionBody;
	        return this.finalize(node, new Node.BlockStatement(body));
	    };
	    Parser.prototype.validateParam = function (options, param, name) {
	        var key = '$' + name;
	        if (this.context.strict) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        else if (!options.firstRestricted) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            else if (this.scanner.isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictReservedWord;
	            }
	            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        /* istanbul ignore next */
	        if (typeof Object.defineProperty === 'function') {
	            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
	        }
	        else {
	            options.paramSet[key] = true;
	        }
	    };
	    Parser.prototype.parseRestElement = function (params) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params);
	        if (this.match('=')) {
	            this.throwError(messages_1.Messages.DefaultRestParameter);
	        }
	        if (!this.match(')')) {
	            this.throwError(messages_1.Messages.ParameterAfterRestParameter);
	        }
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseFormalParameter = function (options) {
	        var params = [];
	        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
	        for (var i = 0; i < params.length; i++) {
	            this.validateParam(options, params[i], params[i].value);
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	        options.params.push(param);
	    };
	    Parser.prototype.parseFormalParameters = function (firstRestricted) {
	        var options;
	        options = {
	            simple: true,
	            params: [],
	            firstRestricted: firstRestricted
	        };
	        this.expect('(');
	        if (!this.match(')')) {
	            options.paramSet = {};
	            while (this.lookahead.type !== 2 /* EOF */) {
	                this.parseFormalParameter(options);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expect(',');
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return {
	            simple: options.simple,
	            params: options.params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.matchAsyncFunction = function () {
	        var match = this.matchContextualKeyword('async');
	        if (match) {
	            var state = this.scanner.saveState();
	            this.scanner.scanComments();
	            var next = this.scanner.lex();
	            this.scanner.restoreState(state);
	            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Keyword */) && (next.value === 'function');
	        }
	        return match;
	    };
	    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted = null;
	        if (!identifierIsOptional || !this.match('(')) {
	            var token = this.lookahead;
	            id = this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :
	            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
	    };
	    Parser.prototype.parseFunctionExpression = function () {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted;
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        if (!this.match('(')) {
	            var token = this.lookahead;
	            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :
	            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
	    Parser.prototype.parseDirective = function () {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;
	        this.consumeSemicolon();
	        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
	    };
	    Parser.prototype.parseDirectivePrologues = function () {
	        var firstRestricted = null;
	        var body = [];
	        while (true) {
	            var token = this.lookahead;
	            if (token.type !== 8 /* StringLiteral */) {
	                break;
	            }
	            var statement = this.parseDirective();
	            body.push(statement);
	            var directive = statement.directive;
	            if (typeof directive !== 'string') {
	                break;
	            }
	            if (directive === 'use strict') {
	                this.context.strict = true;
	                if (firstRestricted) {
	                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
	                }
	                if (!this.context.allowStrictDirective) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
	                }
	            }
	            else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }
	        return body;
	    };
	    // https://tc39.github.io/ecma262/#sec-method-definitions
	    Parser.prototype.qualifiedPropertyName = function (token) {
	        switch (token.type) {
	            case 3 /* Identifier */:
	            case 8 /* StringLiteral */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 4 /* Keyword */:
	                return true;
	            case 7 /* Punctuator */:
	                return token.value === '[';
	            default:
	                break;
	        }
	        return false;
	    };
	    Parser.prototype.parseGetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = false;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length > 0) {
	            this.tolerateError(messages_1.Messages.BadGetterArity);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseSetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = false;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length !== 1) {
	            this.tolerateError(messages_1.Messages.BadSetterArity);
	        }
	        else if (formalParameters.params[0] instanceof Node.RestElement) {
	            this.tolerateError(messages_1.Messages.BadSetterRestParameter);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseGeneratorMethod = function () {
	        var node = this.createNode();
	        var isGenerator = true;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        this.context.allowYield = false;
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-generator-function-definitions
	    Parser.prototype.isStartOfExpression = function () {
	        var start = true;
	        var value = this.lookahead.value;
	        switch (this.lookahead.type) {
	            case 7 /* Punctuator */:
	                start = (value === '[') || (value === '(') || (value === '{') ||
	                    (value === '+') || (value === '-') ||
	                    (value === '!') || (value === '~') ||
	                    (value === '++') || (value === '--') ||
	                    (value === '/') || (value === '/='); // regular expression literal
	                break;
	            case 4 /* Keyword */:
	                start = (value === 'class') || (value === 'delete') ||
	                    (value === 'function') || (value === 'let') || (value === 'new') ||
	                    (value === 'super') || (value === 'this') || (value === 'typeof') ||
	                    (value === 'void') || (value === 'yield');
	                break;
	            default:
	                break;
	        }
	        return start;
	    };
	    Parser.prototype.parseYieldExpression = function () {
	        var node = this.createNode();
	        this.expectKeyword('yield');
	        var argument = null;
	        var delegate = false;
	        if (!this.hasLineTerminator) {
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = false;
	            delegate = this.match('*');
	            if (delegate) {
	                this.nextToken();
	                argument = this.parseAssignmentExpression();
	            }
	            else if (this.isStartOfExpression()) {
	                argument = this.parseAssignmentExpression();
	            }
	            this.context.allowYield = previousAllowYield;
	        }
	        return this.finalize(node, new Node.YieldExpression(argument, delegate));
	    };
	    // https://tc39.github.io/ecma262/#sec-class-definitions
	    Parser.prototype.parseClassElement = function (hasConstructor) {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var kind = '';
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var isStatic = false;
	        var isAsync = false;
	        if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            var id = key;
	            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
	                token = this.lookahead;
	                isStatic = true;
	                computed = this.match('[');
	                if (this.match('*')) {
	                    this.nextToken();
	                }
	                else {
	                    key = this.parseObjectPropertyKey();
	                }
	            }
	            if ((token.type === 3 /* Identifier */) && !this.hasLineTerminator && (token.value === 'async')) {
	                var punctuator = this.lookahead.value;
	                if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
	                    isAsync = true;
	                    token = this.lookahead;
	                    key = this.parseObjectPropertyKey();
	                    if (token.type === 3 /* Identifier */) {
	                        if (token.value === 'get' || token.value === 'set') {
	                            this.tolerateUnexpectedToken(token);
	                        }
	                        else if (token.value === 'constructor') {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
	                        }
	                    }
	                }
	            }
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */) {
	            if (token.value === 'get' && lookaheadPropertyKey) {
	                kind = 'get';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                this.context.allowYield = false;
	                value = this.parseGetterMethod();
	            }
	            else if (token.value === 'set' && lookaheadPropertyKey) {
	                kind = 'set';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                value = this.parseSetterMethod();
	            }
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        if (!kind && key && this.match('(')) {
	            kind = 'init';
	            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	            method = true;
	        }
	        if (!kind) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        if (kind === 'init') {
	            kind = 'method';
	        }
	        if (!computed) {
	            if (isStatic && this.isPropertyKey(key, 'prototype')) {
	                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
	            }
	            if (!isStatic && this.isPropertyKey(key, 'constructor')) {
	                if (kind !== 'method' || !method || (value && value.generator)) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
	                }
	                if (hasConstructor.value) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
	                }
	                else {
	                    hasConstructor.value = true;
	                }
	                kind = 'constructor';
	            }
	        }
	        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
	    };
	    Parser.prototype.parseClassElementList = function () {
	        var body = [];
	        var hasConstructor = { value: false };
	        this.expect('{');
	        while (!this.match('}')) {
	            if (this.match(';')) {
	                this.nextToken();
	            }
	            else {
	                body.push(this.parseClassElement(hasConstructor));
	            }
	        }
	        this.expect('}');
	        return body;
	    };
	    Parser.prototype.parseClassBody = function () {
	        var node = this.createNode();
	        var elementList = this.parseClassElementList();
	        return this.finalize(node, new Node.ClassBody(elementList));
	    };
	    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Identifier */)) ? null : this.parseVariableIdentifier();
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
	    };
	    Parser.prototype.parseClassExpression = function () {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (this.lookahead.type === 3 /* Identifier */) ? this.parseVariableIdentifier() : null;
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
	    };
	    // https://tc39.github.io/ecma262/#sec-scripts
	    // https://tc39.github.io/ecma262/#sec-modules
	    Parser.prototype.parseModule = function () {
	        this.context.strict = true;
	        this.context.isModule = true;
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Module(body));
	    };
	    Parser.prototype.parseScript = function () {
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Script(body));
	    };
	    // https://tc39.github.io/ecma262/#sec-imports
	    Parser.prototype.parseModuleSpecifier = function () {
	        var node = this.createNode();
	        if (this.lookahead.type !== 8 /* StringLiteral */) {
	            this.throwError(messages_1.Messages.InvalidModuleSpecifier);
	        }
	        var token = this.nextToken();
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    // import {<foo as bar>} ...;
	    Parser.prototype.parseImportSpecifier = function () {
	        var node = this.createNode();
	        var imported;
	        var local;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            imported = this.parseVariableIdentifier();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	        }
	        else {
	            imported = this.parseIdentifierName();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.ImportSpecifier(local, imported));
	    };
	    // {foo, bar as bas}
	    Parser.prototype.parseNamedImports = function () {
	        this.expect('{');
	        var specifiers = [];
	        while (!this.match('}')) {
	            specifiers.push(this.parseImportSpecifier());
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return specifiers;
	    };
	    // import <foo> ...;
	    Parser.prototype.parseImportDefaultSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportDefaultSpecifier(local));
	    };
	    // import <* as foo> ...;
	    Parser.prototype.parseImportNamespaceSpecifier = function () {
	        var node = this.createNode();
	        this.expect('*');
	        if (!this.matchContextualKeyword('as')) {
	            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
	        }
	        this.nextToken();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
	    };
	    Parser.prototype.parseImportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalImportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('import');
	        var src;
	        var specifiers = [];
	        if (this.lookahead.type === 8 /* StringLiteral */) {
	            // import 'foo';
	            src = this.parseModuleSpecifier();
	        }
	        else {
	            if (this.match('{')) {
	                // import {bar}
	                specifiers = specifiers.concat(this.parseNamedImports());
	            }
	            else if (this.match('*')) {
	                // import * as foo
	                specifiers.push(this.parseImportNamespaceSpecifier());
	            }
	            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
	                // import foo
	                specifiers.push(this.parseImportDefaultSpecifier());
	                if (this.match(',')) {
	                    this.nextToken();
	                    if (this.match('*')) {
	                        // import foo, * as foo
	                        specifiers.push(this.parseImportNamespaceSpecifier());
	                    }
	                    else if (this.match('{')) {
	                        // import foo, {bar}
	                        specifiers = specifiers.concat(this.parseNamedImports());
	                    }
	                    else {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            src = this.parseModuleSpecifier();
	        }
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
	    };
	    // https://tc39.github.io/ecma262/#sec-exports
	    Parser.prototype.parseExportSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        var exported = local;
	        if (this.matchContextualKeyword('as')) {
	            this.nextToken();
	            exported = this.parseIdentifierName();
	        }
	        return this.finalize(node, new Node.ExportSpecifier(local, exported));
	    };
	    Parser.prototype.parseExportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalExportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('export');
	        var exportDeclaration;
	        if (this.matchKeyword('default')) {
	            // export default ...
	            this.nextToken();
	            if (this.matchKeyword('function')) {
	                // export default function foo () {}
	                // export default function () {}
	                var declaration = this.parseFunctionDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchKeyword('class')) {
	                // export default class foo {}
	                var declaration = this.parseClassDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchContextualKeyword('async')) {
	                // export default async function f () {}
	                // export default async function () {}
	                // export default async x => x
	                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else {
	                if (this.matchContextualKeyword('from')) {
	                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
	                }
	                // export default {};
	                // export default [];
	                // export default (1 + 2);
	                var declaration = this.match('{') ? this.parseObjectInitializer() :
	                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
	                this.consumeSemicolon();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	        }
	        else if (this.match('*')) {
	            // export * from 'foo';
	            this.nextToken();
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            var src = this.parseModuleSpecifier();
	            this.consumeSemicolon();
	            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
	        }
	        else if (this.lookahead.type === 4 /* Keyword */) {
	            // export var f = 1;
	            var declaration = void 0;
	            switch (this.lookahead.value) {
	                case 'let':
	                case 'const':
	                    declaration = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'var':
	                case 'class':
	                case 'function':
	                    declaration = this.parseStatementListItem();
	                    break;
	                default:
	                    this.throwUnexpectedToken(this.lookahead);
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else if (this.matchAsyncFunction()) {
	            var declaration = this.parseFunctionDeclaration();
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else {
	            var specifiers = [];
	            var source = null;
	            var isExportFromIdentifier = false;
	            this.expect('{');
	            while (!this.match('}')) {
	                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
	                specifiers.push(this.parseExportSpecifier());
	                if (!this.match('}')) {
	                    this.expect(',');
	                }
	            }
	            this.expect('}');
	            if (this.matchContextualKeyword('from')) {
	                // export {default} from 'foo';
	                // export {foo} from 'foo';
	                this.nextToken();
	                source = this.parseModuleSpecifier();
	                this.consumeSemicolon();
	            }
	            else if (isExportFromIdentifier) {
	                // export {default}; // missing fromClause
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            else {
	                // export {foo};
	                this.consumeSemicolon();
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
	        }
	        return exportDeclaration;
	    };
	    return Parser;
	}());
	exports.Parser = Parser;


/***/ },
/* 9 */
/***/ function(module, exports) {

	"use strict";
	// Ensure the condition is true, otherwise throw an error.
	// This is only to have a better contract semantic, i.e. another safety net
	// to catch a logic error. The condition shall be fulfilled in normal case.
	// Do NOT use this to enforce a certain condition on any user input.
	Object.defineProperty(exports, "__esModule", { value: true });
	function assert(condition, message) {
	    /* istanbul ignore if */
	    if (!condition) {
	        throw new Error('ASSERT: ' + message);
	    }
	}
	exports.assert = assert;


/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	/* tslint:disable:max-classes-per-file */
	Object.defineProperty(exports, "__esModule", { value: true });
	var ErrorHandler = (function () {
	    function ErrorHandler() {
	        this.errors = [];
	        this.tolerant = false;
	    }
	    ErrorHandler.prototype.recordError = function (error) {
	        this.errors.push(error);
	    };
	    ErrorHandler.prototype.tolerate = function (error) {
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    ErrorHandler.prototype.constructError = function (msg, column) {
	        var error = new Error(msg);
	        try {
	            throw error;
	        }
	        catch (base) {
	            /* istanbul ignore else */
	            if (Object.create && Object.defineProperty) {
	                error = Object.create(base);
	                Object.defineProperty(error, 'column', { value: column });
	            }
	        }
	        /* istanbul ignore next */
	        return error;
	    };
	    ErrorHandler.prototype.createError = function (index, line, col, description) {
	        var msg = 'Line ' + line + ': ' + description;
	        var error = this.constructError(msg, col);
	        error.index = index;
	        error.lineNumber = line;
	        error.description = description;
	        return error;
	    };
	    ErrorHandler.prototype.throwError = function (index, line, col, description) {
	        throw this.createError(index, line, col, description);
	    };
	    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
	        var error = this.createError(index, line, col, description);
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    return ErrorHandler;
	}());
	exports.ErrorHandler = ErrorHandler;


/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// Error messages should be identical to V8.
	exports.Messages = {
	    BadGetterArity: 'Getter must not have any formal parameters',
	    BadSetterArity: 'Setter must have exactly one formal parameter',
	    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
	    ConstructorIsAsync: 'Class constructor may not be an async method',
	    ConstructorSpecialMethod: 'Class constructor may not be an accessor',
	    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
	    DefaultRestParameter: 'Unexpected token =',
	    DuplicateBinding: 'Duplicate binding %0',
	    DuplicateConstructor: 'A class may only have one constructor',
	    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
	    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
	    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
	    IllegalBreak: 'Illegal break statement',
	    IllegalContinue: 'Illegal continue statement',
	    IllegalExportDeclaration: 'Unexpected token',
	    IllegalImportDeclaration: 'Unexpected token',
	    IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
	    IllegalReturn: 'Illegal return statement',
	    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
	    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
	    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	    InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
	    InvalidModuleSpecifier: 'Unexpected token',
	    InvalidRegExp: 'Invalid regular expression',
	    LetInLexicalBinding: 'let is disallowed as a lexically bound name',
	    MissingFromClause: 'Unexpected token',
	    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	    NewlineAfterThrow: 'Illegal newline after throw',
	    NoAsAfterImportNamespace: 'Unexpected token',
	    NoCatchOrFinally: 'Missing catch or finally after try',
	    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
	    Redeclaration: '%0 \'%1\' has already been declared',
	    StaticPrototype: 'Classes may not have static property named prototype',
	    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	    StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
	    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictModeWith: 'Strict mode code may not include a with statement',
	    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	    StrictReservedWord: 'Use of future reserved word in strict mode',
	    StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
	    UnexpectedEOS: 'Unexpected end of input',
	    UnexpectedIdentifier: 'Unexpected identifier',
	    UnexpectedNumber: 'Unexpected number',
	    UnexpectedReserved: 'Unexpected reserved word',
	    UnexpectedString: 'Unexpected string',
	    UnexpectedTemplate: 'Unexpected quasi %0',
	    UnexpectedToken: 'Unexpected token %0',
	    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
	    UnknownLabel: 'Undefined label \'%0\'',
	    UnterminatedRegExp: 'Invalid regular expression: missing /'
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var character_1 = __webpack_require__(4);
	var messages_1 = __webpack_require__(11);
	function hexValue(ch) {
	    return '0123456789abcdef'.indexOf(ch.toLowerCase());
	}
	function octalValue(ch) {
	    return '01234567'.indexOf(ch);
	}
	var Scanner = (function () {
	    function Scanner(code, handler) {
	        this.source = code;
	        this.errorHandler = handler;
	        this.trackComment = false;
	        this.length = code.length;
	        this.index = 0;
	        this.lineNumber = (code.length > 0) ? 1 : 0;
	        this.lineStart = 0;
	        this.curlyStack = [];
	    }
	    Scanner.prototype.saveState = function () {
	        return {
	            index: this.index,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart
	        };
	    };
	    Scanner.prototype.restoreState = function (state) {
	        this.index = state.index;
	        this.lineNumber = state.lineNumber;
	        this.lineStart = state.lineStart;
	    };
	    Scanner.prototype.eof = function () {
	        return this.index >= this.length;
	    };
	    Scanner.prototype.throwUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    Scanner.prototype.tolerateUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    // https://tc39.github.io/ecma262/#sec-comments
	    Scanner.prototype.skipSingleLineComment = function (offset) {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - offset;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - offset
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            ++this.index;
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (this.trackComment) {
	                    loc.end = {
	                        line: this.lineNumber,
	                        column: this.index - this.lineStart - 1
	                    };
	                    var entry = {
	                        multiLine: false,
	                        slice: [start + offset, this.index - 1],
	                        range: [start, this.index - 1],
	                        loc: loc
	                    };
	                    comments.push(entry);
	                }
	                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                return comments;
	            }
	        }
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: false,
	                slice: [start + offset, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        return comments;
	    };
	    Scanner.prototype.skipMultiLineComment = function () {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - 2;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - 2
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                ++this.index;
	                this.lineStart = this.index;
	            }
	            else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (this.source.charCodeAt(this.index + 1) === 0x2F) {
	                    this.index += 2;
	                    if (this.trackComment) {
	                        loc.end = {
	                            line: this.lineNumber,
	                            column: this.index - this.lineStart
	                        };
	                        var entry = {
	                            multiLine: true,
	                            slice: [start + 2, this.index - 2],
	                            range: [start, this.index],
	                            loc: loc
	                        };
	                        comments.push(entry);
	                    }
	                    return comments;
	                }
	                ++this.index;
	            }
	            else {
	                ++this.index;
	            }
	        }
	        // Ran off the end of the file - the whole thing is a comment
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: true,
	                slice: [start + 2, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        this.tolerateUnexpectedToken();
	        return comments;
	    };
	    Scanner.prototype.scanComments = function () {
	        var comments;
	        if (this.trackComment) {
	            comments = [];
	        }
	        var start = (this.index === 0);
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isWhiteSpace(ch)) {
	                ++this.index;
	            }
	            else if (character_1.Character.isLineTerminator(ch)) {
	                ++this.index;
	                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                start = true;
	            }
	            else if (ch === 0x2F) {
	                ch = this.source.charCodeAt(this.index + 1);
	                if (ch === 0x2F) {
	                    this.index += 2;
	                    var comment = this.skipSingleLineComment(2);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                    start = true;
	                }
	                else if (ch === 0x2A) {
	                    this.index += 2;
	                    var comment = this.skipMultiLineComment();
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (start && ch === 0x2D) {
	                // U+003E is '>'
	                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    this.index += 3;
	                    var comment = this.skipSingleLineComment(3);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (ch === 0x3C) {
	                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
	                    this.index += 4; // `<!--`
	                    var comment = this.skipSingleLineComment(4);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else {
	                break;
	            }
	        }
	        return comments;
	    };
	    // https://tc39.github.io/ecma262/#sec-future-reserved-words
	    Scanner.prototype.isFutureReservedWord = function (id) {
	        switch (id) {
	            case 'enum':
	            case 'export':
	            case 'import':
	            case 'super':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isStrictModeReservedWord = function (id) {
	        switch (id) {
	            case 'implements':
	            case 'interface':
	            case 'package':
	            case 'private':
	            case 'protected':
	            case 'public':
	            case 'static':
	            case 'yield':
	            case 'let':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isRestrictedWord = function (id) {
	        return id === 'eval' || id === 'arguments';
	    };
	    // https://tc39.github.io/ecma262/#sec-keywords
	    Scanner.prototype.isKeyword = function (id) {
	        switch (id.length) {
	            case 2:
	                return (id === 'if') || (id === 'in') || (id === 'do');
	            case 3:
	                return (id === 'var') || (id === 'for') || (id === 'new') ||
	                    (id === 'try') || (id === 'let');
	            case 4:
	                return (id === 'this') || (id === 'else') || (id === 'case') ||
	                    (id === 'void') || (id === 'with') || (id === 'enum');
	            case 5:
	                return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                    (id === 'class') || (id === 'super');
	            case 6:
	                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                    (id === 'switch') || (id === 'export') || (id === 'import');
	            case 7:
	                return (id === 'default') || (id === 'finally') || (id === 'extends');
	            case 8:
	                return (id === 'function') || (id === 'continue') || (id === 'debugger');
	            case 10:
	                return (id === 'instanceof');
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.codePointAt = function (i) {
	        var cp = this.source.charCodeAt(i);
	        if (cp >= 0xD800 && cp <= 0xDBFF) {
	            var second = this.source.charCodeAt(i + 1);
	            if (second >= 0xDC00 && second <= 0xDFFF) {
	                var first = cp;
	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            }
	        }
	        return cp;
	    };
	    Scanner.prototype.scanHexEscape = function (prefix) {
	        var len = (prefix === 'u') ? 4 : 2;
	        var code = 0;
	        for (var i = 0; i < len; ++i) {
	            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                code = code * 16 + hexValue(this.source[this.index++]);
	            }
	            else {
	                return null;
	            }
	        }
	        return String.fromCharCode(code);
	    };
	    Scanner.prototype.scanUnicodeCodePointEscape = function () {
	        var ch = this.source[this.index];
	        var code = 0;
	        // At least, one hex digit is required.
	        if (ch === '}') {
	            this.throwUnexpectedToken();
	        }
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
	                break;
	            }
	            code = code * 16 + hexValue(ch);
	        }
	        if (code > 0x10FFFF || ch !== '}') {
	            this.throwUnexpectedToken();
	        }
	        return character_1.Character.fromCodePoint(code);
	    };
	    Scanner.prototype.getIdentifier = function () {
	        var start = this.index++;
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            else if (ch >= 0xD800 && ch < 0xDFFF) {
	                // Need to handle surrogate pairs.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            if (character_1.Character.isIdentifierPart(ch)) {
	                ++this.index;
	            }
	            else {
	                break;
	            }
	        }
	        return this.source.slice(start, this.index);
	    };
	    Scanner.prototype.getComplexIdentifier = function () {
	        var cp = this.codePointAt(this.index);
	        var id = character_1.Character.fromCodePoint(cp);
	        this.index += id.length;
	        // '\u' (U+005C, U+0075) denotes an escaped character.
	        var ch;
	        if (cp === 0x5C) {
	            if (this.source.charCodeAt(this.index) !== 0x75) {
	                this.throwUnexpectedToken();
	            }
	            ++this.index;
	            if (this.source[this.index] === '{') {
	                ++this.index;
	                ch = this.scanUnicodeCodePointEscape();
	            }
	            else {
	                ch = this.scanHexEscape('u');
	                if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken();
	                }
	            }
	            id = ch;
	        }
	        while (!this.eof()) {
	            cp = this.codePointAt(this.index);
	            if (!character_1.Character.isIdentifierPart(cp)) {
	                break;
	            }
	            ch = character_1.Character.fromCodePoint(cp);
	            id += ch;
	            this.index += ch.length;
	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (cp === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (this.source.charCodeAt(this.index) !== 0x75) {
	                    this.throwUnexpectedToken();
	                }
	                ++this.index;
	                if (this.source[this.index] === '{') {
	                    ++this.index;
	                    ch = this.scanUnicodeCodePointEscape();
	                }
	                else {
	                    ch = this.scanHexEscape('u');
	                    if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                        this.throwUnexpectedToken();
	                    }
	                }
	                id += ch;
	            }
	        }
	        return id;
	    };
	    Scanner.prototype.octalToDecimal = function (ch) {
	        // \0 is not octal escape sequence
	        var octal = (ch !== '0');
	        var code = octalValue(ch);
	        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	            octal = true;
	            code = code * 8 + octalValue(this.source[this.index++]);
	            // 3 digits are only allowed when string starts
	            // with 0, 1, 2, 3
	            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                code = code * 8 + octalValue(this.source[this.index++]);
	            }
	        }
	        return {
	            code: code,
	            octal: octal
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    Scanner.prototype.scanIdentifier = function () {
	        var type;
	        var start = this.index;
	        // Backslash (U+005C) starts an escaped character.
	        var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();
	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = 3 /* Identifier */;
	        }
	        else if (this.isKeyword(id)) {
	            type = 4 /* Keyword */;
	        }
	        else if (id === 'null') {
	            type = 5 /* NullLiteral */;
	        }
	        else if (id === 'true' || id === 'false') {
	            type = 1 /* BooleanLiteral */;
	        }
	        else {
	            type = 3 /* Identifier */;
	        }
	        if (type !== 3 /* Identifier */ && (start + id.length !== this.index)) {
	            var restore = this.index;
	            this.index = start;
	            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
	            this.index = restore;
	        }
	        return {
	            type: type,
	            value: id,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-punctuators
	    Scanner.prototype.scanPunctuator = function () {
	        var start = this.index;
	        // Check for most common single-character punctuators.
	        var str = this.source[this.index];
	        switch (str) {
	            case '(':
	            case '{':
	                if (str === '{') {
	                    this.curlyStack.push('{');
	                }
	                ++this.index;
	                break;
	            case '.':
	                ++this.index;
	                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
	                    // Spread operator: ...
	                    this.index += 2;
	                    str = '...';
	                }
	                break;
	            case '}':
	                ++this.index;
	                this.curlyStack.pop();
	                break;
	            case ')':
	            case ';':
	            case ',':
	            case '[':
	            case ']':
	            case ':':
	            case '?':
	            case '~':
	                ++this.index;
	                break;
	            default:
	                // 4-character punctuator.
	                str = this.source.substr(this.index, 4);
	                if (str === '>>>=') {
	                    this.index += 4;
	                }
	                else {
	                    // 3-character punctuators.
	                    str = str.substr(0, 3);
	                    if (str === '===' || str === '!==' || str === '>>>' ||
	                        str === '<<=' || str === '>>=' || str === '**=') {
	                        this.index += 3;
	                    }
	                    else {
	                        // 2-character punctuators.
	                        str = str.substr(0, 2);
	                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
	                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
	                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
	                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
	                            str === '<=' || str === '>=' || str === '=>' || str === '**') {
	                            this.index += 2;
	                        }
	                        else {
	                            // 1-character punctuators.
	                            str = this.source[this.index];
	                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
	                                ++this.index;
	                            }
	                        }
	                    }
	                }
	        }
	        if (this.index === start) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 7 /* Punctuator */,
	            value: str,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    Scanner.prototype.scanHexLiteral = function (start) {
	        var num = '';
	        while (!this.eof()) {
	            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt('0x' + num, 16),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanBinaryLiteral = function (start) {
	        var num = '';
	        var ch;
	        while (!this.eof()) {
	            ch = this.source[this.index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            // only 0b or 0B
	            this.throwUnexpectedToken();
	        }
	        if (!this.eof()) {
	            ch = this.source.charCodeAt(this.index);
	            /* istanbul ignore else */
	            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
	                this.throwUnexpectedToken();
	            }
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 2),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanOctalLiteral = function (prefix, start) {
	        var num = '';
	        var octal = false;
	        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
	            octal = true;
	            num = '0' + this.source[this.index++];
	        }
	        else {
	            ++this.index;
	        }
	        while (!this.eof()) {
	            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (!octal && num.length === 0) {
	            // only 0o or 0O
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 8),
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.isImplicitOctalLiteral = function () {
	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (var i = this.index + 1; i < this.length; ++i) {
	            var ch = this.source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                return true;
	            }
	        }
	        return true;
	    };
	    Scanner.prototype.scanNumericLiteral = function () {
	        var start = this.index;
	        var ch = this.source[start];
	        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
	        var num = '';
	        if (ch !== '.') {
	            num = this.source[this.index++];
	            ch = this.source[this.index];
	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (num === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++this.index;
	                    return this.scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++this.index;
	                    return this.scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O') {
	                    return this.scanOctalLiteral(ch, start);
	                }
	                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                    if (this.isImplicitOctalLiteral()) {
	                        return this.scanOctalLiteral(ch, start);
	                    }
	                }
	            }
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === '.') {
	            num += this.source[this.index++];
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === 'e' || ch === 'E') {
	            num += this.source[this.index++];
	            ch = this.source[this.index];
	            if (ch === '+' || ch === '-') {
	                num += this.source[this.index++];
	            }
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                    num += this.source[this.index++];
	                }
	            }
	            else {
	                this.throwUnexpectedToken();
	            }
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseFloat(num),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-string-literals
	    Scanner.prototype.scanStringLiteral = function () {
	        var start = this.index;
	        var quote = this.source[start];
	        assert_1.assert((quote === '\'' || quote === '"'), 'String literal must starts with a quote');
	        ++this.index;
	        var octal = false;
	        var str = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === quote) {
	                quote = '';
	                break;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                str += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var unescaped_1 = this.scanHexEscape(ch);
	                                if (unescaped_1 === null) {
	                                    this.throwUnexpectedToken();
	                                }
	                                str += unescaped_1;
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            str += unescaped;
	                            break;
	                        case 'n':
	                            str += '\n';
	                            break;
	                        case 'r':
	                            str += '\r';
	                            break;
	                        case 't':
	                            str += '\t';
	                            break;
	                        case 'b':
	                            str += '\b';
	                            break;
	                        case 'f':
	                            str += '\f';
	                            break;
	                        case 'v':
	                            str += '\x0B';
	                            break;
	                        case '8':
	                        case '9':
	                            str += ch;
	                            this.tolerateUnexpectedToken();
	                            break;
	                        default:
	                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                var octToDec = this.octalToDecimal(ch);
	                                octal = octToDec.octal || octal;
	                                str += String.fromCharCode(octToDec.code);
	                            }
	                            else {
	                                str += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            }
	            else {
	                str += ch;
	            }
	        }
	        if (quote !== '') {
	            this.index = start;
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 8 /* StringLiteral */,
	            value: str,
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
	    Scanner.prototype.scanTemplate = function () {
	        var cooked = '';
	        var terminated = false;
	        var start = this.index;
	        var head = (this.source[start] === '`');
	        var tail = false;
	        var rawOffset = 2;
	        ++this.index;
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === '`') {
	                rawOffset = 1;
	                tail = true;
	                terminated = true;
	                break;
	            }
	            else if (ch === '$') {
	                if (this.source[this.index] === '{') {
	                    this.curlyStack.push('${');
	                    ++this.index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'n':
	                            cooked += '\n';
	                            break;
	                        case 'r':
	                            cooked += '\r';
	                            break;
	                        case 't':
	                            cooked += '\t';
	                            break;
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                cooked += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var restore = this.index;
	                                var unescaped_2 = this.scanHexEscape(ch);
	                                if (unescaped_2 !== null) {
	                                    cooked += unescaped_2;
	                                }
	                                else {
	                                    this.index = restore;
	                                    cooked += ch;
	                                }
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            cooked += unescaped;
	                            break;
	                        case 'b':
	                            cooked += '\b';
	                            break;
	                        case 'f':
	                            cooked += '\f';
	                            break;
	                        case 'v':
	                            cooked += '\v';
	                            break;
	                        default:
	                            if (ch === '0') {
	                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                                    // Illegal: \01 \02 and so on
	                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                                }
	                                cooked += '\0';
	                            }
	                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                // Illegal: \1 \2
	                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                            }
	                            else {
	                                cooked += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.lineNumber;
	                if (ch === '\r' && this.source[this.index] === '\n') {
	                    ++this.index;
	                }
	                this.lineStart = this.index;
	                cooked += '\n';
	            }
	            else {
	                cooked += ch;
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken();
	        }
	        if (!head) {
	            this.curlyStack.pop();
	        }
	        return {
	            type: 10 /* Template */,
	            value: this.source.slice(start + 1, this.index - rawOffset),
	            cooked: cooked,
	            head: head,
	            tail: tail,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	    Scanner.prototype.testRegExp = function (pattern, flags) {
	        // The BMP character to use as a replacement for astral symbols when
	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
	        // approximation.
	        // Note: replacing with '\uFFFF' enables false positives in unlikely
	        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
	        // pattern that would not be detected by this substitution.
	        var astralSubstitute = '\uFFFF';
	        var tmp = pattern;
	        var self = this;
	        if (flags.indexOf('u') >= 0) {
	            tmp = tmp
	                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
	                var codePoint = parseInt($1 || $2, 16);
	                if (codePoint > 0x10FFFF) {
	                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	                }
	                if (codePoint <= 0xFFFF) {
	                    return String.fromCharCode(codePoint);
	                }
	                return astralSubstitute;
	            })
	                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
	        }
	        // First, detect invalid regular expressions.
	        try {
	            RegExp(tmp);
	        }
	        catch (e) {
	            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	        }
	        // Return a regular expression object for this pattern-flag pair, or
	        // `null` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        }
	        catch (exception) {
	            /* istanbul ignore next */
	            return null;
	        }
	    };
	    Scanner.prototype.scanRegExpBody = function () {
	        var ch = this.source[this.index];
	        assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
	        var str = this.source[this.index++];
	        var classMarker = false;
	        var terminated = false;
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = this.source[this.index++];
	                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	            }
	            else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            }
	            else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                }
	                else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	        }
	        // Exclude leading and trailing slash.
	        return str.substr(1, str.length - 2);
	    };
	    Scanner.prototype.scanRegExpFlags = function () {
	        var str = '';
	        var flags = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index];
	            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }
	            ++this.index;
	            if (ch === '\\' && !this.eof()) {
	                ch = this.source[this.index];
	                if (ch === 'u') {
	                    ++this.index;
	                    var restore = this.index;
	                    var char = this.scanHexEscape('u');
	                    if (char !== null) {
	                        flags += char;
	                        for (str += '\\u'; restore < this.index; ++restore) {
	                            str += this.source[restore];
	                        }
	                    }
	                    else {
	                        this.index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    this.tolerateUnexpectedToken();
	                }
	                else {
	                    str += '\\';
	                    this.tolerateUnexpectedToken();
	                }
	            }
	            else {
	                flags += ch;
	                str += ch;
	            }
	        }
	        return flags;
	    };
	    Scanner.prototype.scanRegExp = function () {
	        var start = this.index;
	        var pattern = this.scanRegExpBody();
	        var flags = this.scanRegExpFlags();
	        var value = this.testRegExp(pattern, flags);
	        return {
	            type: 9 /* RegularExpression */,
	            value: '',
	            pattern: pattern,
	            flags: flags,
	            regex: value,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.lex = function () {
	        if (this.eof()) {
	            return {
	                type: 2 /* EOF */,
	                value: '',
	                lineNumber: this.lineNumber,
	                lineStart: this.lineStart,
	                start: this.index,
	                end: this.index
	            };
	        }
	        var cp = this.source.charCodeAt(this.index);
	        if (character_1.Character.isIdentifierStart(cp)) {
	            return this.scanIdentifier();
	        }
	        // Very common: ( and ) and ;
	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
	            return this.scanPunctuator();
	        }
	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (cp === 0x27 || cp === 0x22) {
	            return this.scanStringLiteral();
	        }
	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (cp === 0x2E) {
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
	                return this.scanNumericLiteral();
	            }
	            return this.scanPunctuator();
	        }
	        if (character_1.Character.isDecimalDigit(cp)) {
	            return this.scanNumericLiteral();
	        }
	        // Template literals start with ` (U+0060) for template head
	        // or } (U+007D) for template middle or template tail.
	        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${')) {
	            return this.scanTemplate();
	        }
	        // Possible identifier start in a surrogate pair.
	        if (cp >= 0xD800 && cp < 0xDFFF) {
	            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
	                return this.scanIdentifier();
	            }
	        }
	        return this.scanPunctuator();
	    };
	    return Scanner;
	}());
	exports.Scanner = Scanner;


/***/ },
/* 13 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TokenName = {};
	exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
	exports.TokenName[2 /* EOF */] = '<end>';
	exports.TokenName[3 /* Identifier */] = 'Identifier';
	exports.TokenName[4 /* Keyword */] = 'Keyword';
	exports.TokenName[5 /* NullLiteral */] = 'Null';
	exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
	exports.TokenName[7 /* Punctuator */] = 'Punctuator';
	exports.TokenName[8 /* StringLiteral */] = 'String';
	exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
	exports.TokenName[10 /* Template */] = 'Template';


/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	// Generated by generate-xhtml-entities.js. DO NOT MODIFY!
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.XHTMLEntities = {
	    quot: '\u0022',
	    amp: '\u0026',
	    apos: '\u0027',
	    gt: '\u003E',
	    nbsp: '\u00A0',
	    iexcl: '\u00A1',
	    cent: '\u00A2',
	    pound: '\u00A3',
	    curren: '\u00A4',
	    yen: '\u00A5',
	    brvbar: '\u00A6',
	    sect: '\u00A7',
	    uml: '\u00A8',
	    copy: '\u00A9',
	    ordf: '\u00AA',
	    laquo: '\u00AB',
	    not: '\u00AC',
	    shy: '\u00AD',
	    reg: '\u00AE',
	    macr: '\u00AF',
	    deg: '\u00B0',
	    plusmn: '\u00B1',
	    sup2: '\u00B2',
	    sup3: '\u00B3',
	    acute: '\u00B4',
	    micro: '\u00B5',
	    para: '\u00B6',
	    middot: '\u00B7',
	    cedil: '\u00B8',
	    sup1: '\u00B9',
	    ordm: '\u00BA',
	    raquo: '\u00BB',
	    frac14: '\u00BC',
	    frac12: '\u00BD',
	    frac34: '\u00BE',
	    iquest: '\u00BF',
	    Agrave: '\u00C0',
	    Aacute: '\u00C1',
	    Acirc: '\u00C2',
	    Atilde: '\u00C3',
	    Auml: '\u00C4',
	    Aring: '\u00C5',
	    AElig: '\u00C6',
	    Ccedil: '\u00C7',
	    Egrave: '\u00C8',
	    Eacute: '\u00C9',
	    Ecirc: '\u00CA',
	    Euml: '\u00CB',
	    Igrave: '\u00CC',
	    Iacute: '\u00CD',
	    Icirc: '\u00CE',
	    Iuml: '\u00CF',
	    ETH: '\u00D0',
	    Ntilde: '\u00D1',
	    Ograve: '\u00D2',
	    Oacute: '\u00D3',
	    Ocirc: '\u00D4',
	    Otilde: '\u00D5',
	    Ouml: '\u00D6',
	    times: '\u00D7',
	    Oslash: '\u00D8',
	    Ugrave: '\u00D9',
	    Uacute: '\u00DA',
	    Ucirc: '\u00DB',
	    Uuml: '\u00DC',
	    Yacute: '\u00DD',
	    THORN: '\u00DE',
	    szlig: '\u00DF',
	    agrave: '\u00E0',
	    aacute: '\u00E1',
	    acirc: '\u00E2',
	    atilde: '\u00E3',
	    auml: '\u00E4',
	    aring: '\u00E5',
	    aelig: '\u00E6',
	    ccedil: '\u00E7',
	    egrave: '\u00E8',
	    eacute: '\u00E9',
	    ecirc: '\u00EA',
	    euml: '\u00EB',
	    igrave: '\u00EC',
	    iacute: '\u00ED',
	    icirc: '\u00EE',
	    iuml: '\u00EF',
	    eth: '\u00F0',
	    ntilde: '\u00F1',
	    ograve: '\u00F2',
	    oacute: '\u00F3',
	    ocirc: '\u00F4',
	    otilde: '\u00F5',
	    ouml: '\u00F6',
	    divide: '\u00F7',
	    oslash: '\u00F8',
	    ugrave: '\u00F9',
	    uacute: '\u00FA',
	    ucirc: '\u00FB',
	    uuml: '\u00FC',
	    yacute: '\u00FD',
	    thorn: '\u00FE',
	    yuml: '\u00FF',
	    OElig: '\u0152',
	    oelig: '\u0153',
	    Scaron: '\u0160',
	    scaron: '\u0161',
	    Yuml: '\u0178',
	    fnof: '\u0192',
	    circ: '\u02C6',
	    tilde: '\u02DC',
	    Alpha: '\u0391',
	    Beta: '\u0392',
	    Gamma: '\u0393',
	    Delta: '\u0394',
	    Epsilon: '\u0395',
	    Zeta: '\u0396',
	    Eta: '\u0397',
	    Theta: '\u0398',
	    Iota: '\u0399',
	    Kappa: '\u039A',
	    Lambda: '\u039B',
	    Mu: '\u039C',
	    Nu: '\u039D',
	    Xi: '\u039E',
	    Omicron: '\u039F',
	    Pi: '\u03A0',
	    Rho: '\u03A1',
	    Sigma: '\u03A3',
	    Tau: '\u03A4',
	    Upsilon: '\u03A5',
	    Phi: '\u03A6',
	    Chi: '\u03A7',
	    Psi: '\u03A8',
	    Omega: '\u03A9',
	    alpha: '\u03B1',
	    beta: '\u03B2',
	    gamma: '\u03B3',
	    delta: '\u03B4',
	    epsilon: '\u03B5',
	    zeta: '\u03B6',
	    eta: '\u03B7',
	    theta: '\u03B8',
	    iota: '\u03B9',
	    kappa: '\u03BA',
	    lambda: '\u03BB',
	    mu: '\u03BC',
	    nu: '\u03BD',
	    xi: '\u03BE',
	    omicron: '\u03BF',
	    pi: '\u03C0',
	    rho: '\u03C1',
	    sigmaf: '\u03C2',
	    sigma: '\u03C3',
	    tau: '\u03C4',
	    upsilon: '\u03C5',
	    phi: '\u03C6',
	    chi: '\u03C7',
	    psi: '\u03C8',
	    omega: '\u03C9',
	    thetasym: '\u03D1',
	    upsih: '\u03D2',
	    piv: '\u03D6',
	    ensp: '\u2002',
	    emsp: '\u2003',
	    thinsp: '\u2009',
	    zwnj: '\u200C',
	    zwj: '\u200D',
	    lrm: '\u200E',
	    rlm: '\u200F',
	    ndash: '\u2013',
	    mdash: '\u2014',
	    lsquo: '\u2018',
	    rsquo: '\u2019',
	    sbquo: '\u201A',
	    ldquo: '\u201C',
	    rdquo: '\u201D',
	    bdquo: '\u201E',
	    dagger: '\u2020',
	    Dagger: '\u2021',
	    bull: '\u2022',
	    hellip: '\u2026',
	    permil: '\u2030',
	    prime: '\u2032',
	    Prime: '\u2033',
	    lsaquo: '\u2039',
	    rsaquo: '\u203A',
	    oline: '\u203E',
	    frasl: '\u2044',
	    euro: '\u20AC',
	    image: '\u2111',
	    weierp: '\u2118',
	    real: '\u211C',
	    trade: '\u2122',
	    alefsym: '\u2135',
	    larr: '\u2190',
	    uarr: '\u2191',
	    rarr: '\u2192',
	    darr: '\u2193',
	    harr: '\u2194',
	    crarr: '\u21B5',
	    lArr: '\u21D0',
	    uArr: '\u21D1',
	    rArr: '\u21D2',
	    dArr: '\u21D3',
	    hArr: '\u21D4',
	    forall: '\u2200',
	    part: '\u2202',
	    exist: '\u2203',
	    empty: '\u2205',
	    nabla: '\u2207',
	    isin: '\u2208',
	    notin: '\u2209',
	    ni: '\u220B',
	    prod: '\u220F',
	    sum: '\u2211',
	    minus: '\u2212',
	    lowast: '\u2217',
	    radic: '\u221A',
	    prop: '\u221D',
	    infin: '\u221E',
	    ang: '\u2220',
	    and: '\u2227',
	    or: '\u2228',
	    cap: '\u2229',
	    cup: '\u222A',
	    int: '\u222B',
	    there4: '\u2234',
	    sim: '\u223C',
	    cong: '\u2245',
	    asymp: '\u2248',
	    ne: '\u2260',
	    equiv: '\u2261',
	    le: '\u2264',
	    ge: '\u2265',
	    sub: '\u2282',
	    sup: '\u2283',
	    nsub: '\u2284',
	    sube: '\u2286',
	    supe: '\u2287',
	    oplus: '\u2295',
	    otimes: '\u2297',
	    perp: '\u22A5',
	    sdot: '\u22C5',
	    lceil: '\u2308',
	    rceil: '\u2309',
	    lfloor: '\u230A',
	    rfloor: '\u230B',
	    loz: '\u25CA',
	    spades: '\u2660',
	    clubs: '\u2663',
	    hearts: '\u2665',
	    diams: '\u2666',
	    lang: '\u27E8',
	    rang: '\u27E9'
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var error_handler_1 = __webpack_require__(10);
	var scanner_1 = __webpack_require__(12);
	var token_1 = __webpack_require__(13);
	var Reader = (function () {
	    function Reader() {
	        this.values = [];
	        this.curly = this.paren = -1;
	    }
	    // A function following one of those tokens is an expression.
	    Reader.prototype.beforeFunctionExpression = function (t) {
	        return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	            'return', 'case', 'delete', 'throw', 'void',
	            // assignment operators
	            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',
	            '&=', '|=', '^=', ',',
	            // binary/unary operators
	            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
	    };
	    // Determine if forward slash (/) is an operator or part of a regular expression
	    // https://github.com/mozilla/sweet.js/wiki/design
	    Reader.prototype.isRegexStart = function () {
	        var previous = this.values[this.values.length - 1];
	        var regex = (previous !== null);
	        switch (previous) {
	            case 'this':
	            case ']':
	                regex = false;
	                break;
	            case ')':
	                var keyword = this.values[this.paren - 1];
	                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');
	                break;
	            case '}':
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                regex = false;
	                if (this.values[this.curly - 3] === 'function') {
	                    // Anonymous function, e.g. function(){} /42
	                    var check = this.values[this.curly - 4];
	                    regex = check ? !this.beforeFunctionExpression(check) : false;
	                }
	                else if (this.values[this.curly - 4] === 'function') {
	                    // Named function, e.g. function f(){} /42/
	                    var check = this.values[this.curly - 5];
	                    regex = check ? !this.beforeFunctionExpression(check) : true;
	                }
	                break;
	            default:
	                break;
	        }
	        return regex;
	    };
	    Reader.prototype.push = function (token) {
	        if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
	            if (token.value === '{') {
	                this.curly = this.values.length;
	            }
	            else if (token.value === '(') {
	                this.paren = this.values.length;
	            }
	            this.values.push(token.value);
	        }
	        else {
	            this.values.push(null);
	        }
	    };
	    return Reader;
	}());
	var Tokenizer = (function () {
	    function Tokenizer(code, config) {
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;
	        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;
	        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;
	        this.buffer = [];
	        this.reader = new Reader();
	    }
	    Tokenizer.prototype.errors = function () {
	        return this.errorHandler.errors;
	    };
	    Tokenizer.prototype.getNextToken = function () {
	        if (this.buffer.length === 0) {
	            var comments = this.scanner.scanComments();
	            if (this.scanner.trackComment) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
	                    var comment = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: value
	                    };
	                    if (this.trackRange) {
	                        comment.range = e.range;
	                    }
	                    if (this.trackLoc) {
	                        comment.loc = e.loc;
	                    }
	                    this.buffer.push(comment);
	                }
	            }
	            if (!this.scanner.eof()) {
	                var loc = void 0;
	                if (this.trackLoc) {
	                    loc = {
	                        start: {
	                            line: this.scanner.lineNumber,
	                            column: this.scanner.index - this.scanner.lineStart
	                        },
	                        end: {}
	                    };
	                }
	                var startRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();
	                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
	                this.reader.push(token);
	                var entry = {
	                    type: token_1.TokenName[token.type],
	                    value: this.scanner.source.slice(token.start, token.end)
	                };
	                if (this.trackRange) {
	                    entry.range = [token.start, token.end];
	                }
	                if (this.trackLoc) {
	                    loc.end = {
	                        line: this.scanner.lineNumber,
	                        column: this.scanner.index - this.scanner.lineStart
	                    };
	                    entry.loc = loc;
	                }
	                if (token.type === 9 /* RegularExpression */) {
	                    var pattern = token.pattern;
	                    var flags = token.flags;
	                    entry.regex = { pattern: pattern, flags: flags };
	                }
	                this.buffer.push(entry);
	            }
	        }
	        return this.buffer.shift();
	    };
	    return Tokenizer;
	}());
	exports.Tokenizer = Tokenizer;


/***/ }
/******/ ])
});
;
},{}],60:[function(require,module,exports){
'use strict'
var readonlyProxies = new WeakMap
var currentSandbox = undefined
var GLOBAL = new Function('return this')()
var unscopablesSymbol = Symbol.unscopables
var FunctionConstructor = 0..constructor.constructor

function compileExpression(src) {
	if (typeof src !== 'string') {
		throw new TypeError('Expected argument to be a string.')
	}
	
	new FunctionConstructor('"use strict"; return ' + src) // Tests for syntax errors without running the code
	var code = new FunctionConstructor('sandbox', 'with (sandbox) {return (function () {"use strict"; return ' + src + '}).call(this)}')
	
	return function (sandbox) {
		if (!isObject(sandbox)) {
			throw new TypeError('Expected argument to be an object or function.')
		}
		if (currentSandbox) {
			throw new Error('You cannot run sandboxed code inside an already-running sandbox.')
		}
		var sandboxProxy = getProxy(sandbox)
		var result, error
		
		currentSandbox = sandbox
		try {
			result = code.call(sandboxProxy, sandboxProxy)
			currentSandbox = undefined
		} catch (ex) {
			currentSandbox = undefined
			if (ex instanceof Error) {
				error = new ex.constructor('' + ex.message)
				error.stack = '' + ex.stack
				throw error
			}
			throw new Error(String(ex))
		}
		if (isObject(result)) {
			throw TypeError('Sandboxes are only allowed to return primitive values.')
		}
		return result
	}
}
module.exports = compileExpression

var traps = {
	get: function (target, key, receiver) {
		if (currentSandbox) {
			if (key === unscopablesSymbol && target === currentSandbox) {
				return undefined
			}
			if (!notPrivate(key)) {
				return undefined
			}
			return getProxyOrPrimitive(Reflect.get(target, key, receiver))
		}
		return Reflect.get(target, key, receiver)
	},
	set: function (target, key, value, receiver) {
		if (currentSandbox) {
			throw new TypeError('You cannot set properties on a sandboxed object.')
		}
		return Reflect.set(target, key, value, receiver)
	},
	has: function (target, key) {
		if (currentSandbox) {
			if (target === currentSandbox) {
				return true
			}
			if (!notPrivate(key)) {
				return false
			}
			return getProxyOrPrimitive(Reflect.has(target, key))
		}
		return Reflect.has(target, key)
	},
	getPrototypeOf: function (target) {
		if (currentSandbox) {
			return getProxyOrPrimitive(Reflect.getPrototypeOf(target))
		}
		return Reflect.getPrototypeOf(target)
	},
	setPrototypeOf: function (target, proto) {
		if (currentSandbox) {
			throw new TypeError('You cannot set the prototype of a sandboxed object.')
		}
		return Reflect.setPrototypeOf(target, proto)
	},
	isExtensible: function (target) {
		if (currentSandbox) {
			return getProxyOrPrimitive(Reflect.isExtensible(target))
		}
		return Reflect.isExtensible(target)
	},
	preventExtensions: function (target) {
		if (currentSandbox) {
			throw new TypeError('You cannot change the extensibility of a sandboxed object.')
		}
		return Reflect.preventExtensions(target)
	},
	getOwnPropertyDescriptor: function (target, key) {
		if (currentSandbox) {
			if (key === Symbol.unscopables && target === currentSandbox) {
				return undefined
			}
			if (!notPrivate(key)) {
				return undefined
			}
			return getProxyOrPrimitive(Reflect.getOwnPropertyDescriptor(target, key))
		}
		return Reflect.getOwnPropertyDescriptor(target, key)
	},
	defineProperty: function (target, key, descriptor) {
		if (currentSandbox) {
			throw new TypeError('You cannot define properties on a sandboxed object.')
		}
		return Reflect.defineProperty(target, key, descriptor)
	},
	deleteProperty: function (target, key) {
		if (currentSandbox) {
			throw new TypeError('You cannot delete properties on a sandboxed object.')
		}
		return Reflect.deleteProperty(target, key)
	},
	ownKeys: function (target) {
		if (currentSandbox) {
			return getProxyOrPrimitive(Reflect.ownKeys(target).filter(notPrivate))
		}
		return Reflect.ownKeys(target)
	},
	apply: function (target, thisArg, argumentsList) {
		if (currentSandbox) {
			if (target === FunctionConstructor || target === FunctionConstructorProxy) {
				throw new TypeError('You cannot use the Function constructor in a sandboxed context.')
			}
			return getProxyOrPrimitive(Reflect.apply(target, thisArg, argumentsList))
		}
		return Reflect.apply(target, thisArg, argumentsList)
	},
	construct: function (target, argumentsList, newTarget) {
		if (currentSandbox) {
			if (target === FunctionConstructor || target === FunctionConstructorProxy) {
				throw new TypeError('You cannot use the Function constructor in a sandboxed context.')
			}
			return getProxyOrPrimitive(Reflect.construct(target, argumentsList, newTarget))
		}
		return Reflect.construct(target, argumentsList, newTarget)
	}
}

function isObject(value) {
	return typeof value === 'function' || (value !== null && typeof value === 'object')
}

function getProxyOrPrimitive(value) {
	if (isObject(value)) {
		return safeObjects.indexOf(value) >= 0 ? value : getProxy(value)
	}
	return value
}

function getProxy(object, hideOriginal) {
	if (object === GLOBAL) {
		throw new TypeError('The global object is forbidden from entering a sandboxed context.')
	}
	if (object === evalFunction) {
		throw new TypeError('The eval function is forbidden from entering a sandboxed context.')
	}
	var proxy = readonlyProxies.get(object)
	if (typeof proxy === 'undefined') {
		proxy = new Proxy(object, traps)
		readonlyProxies.set(hideOriginal ? proxy : object, proxy)
	}
	return proxy
}

function notPrivate(key) {
	return typeof key !== 'string' || key[0] !== '_'
}

// Freeze and proxy anything that is accessible through JavaScript syntax alone
// This should include any value that you can get from JavaScript syntax itself.
// For example:
//     "my string".foobar
//     try {throw 1} catch (err) {err.foobar}
// Symbols are included here because they are not protected by our proxying
// because they are primitives.
var safeObjects = require('./lib/make-safe')([
	Boolean.prototype,
	Number.prototype,
	String.prototype,
	Symbol.prototype,
	Function.prototype,
	Object.prototype,
	Array.prototype,
	RegExp.prototype,
	Error.prototype,
	EvalError.prototype,
	RangeError.prototype,
	ReferenceError.prototype,
	SyntaxError.prototype,
	TypeError.prototype,
	URIError.prototype,
	Promise.prototype,
	Object.getPrototypeOf(function*(){}),
	Object.getPrototypeOf(function*(){}())
], isObject, getProxy, GLOBAL)

var evalFunction = GLOBAL.eval
var FunctionConstructorProxy = 0..constructor.constructor

module.exports.equals = function (a, b) {
	return a === b || (readonlyProxies.get(a) || a) === (readonlyProxies.get(b) || b)
}



},{"./lib/make-safe":61}],61:[function(require,module,exports){
'use strict'

module.exports = function (unsafeObjects, isObject, getProxy, GLOBAL) {
	var proxies = []
	var safeObjects = []
	var returnsSafeValues = [
		Function.prototype[Symbol.hasInstance]
	]
	var globalKeys = Object.getOwnPropertyNames(GLOBAL).filter(function (key) {return key !== 'root' && key !== 'GLOBAL' && key !== 'global' && key !== 'window' && key !== 'self'})
	var globalValues = globalKeys.map(function (key) {return this[key]}, GLOBAL)
	
	while (unsafeObjects.length) {
		makeSafe(unsafeObjects.shift())
	}
	
	function makeSafe(object) {
		if (isSafe(object)) {
			return
		}
		
		var reachable = Object.getOwnPropertyNames(object)
			.concat(Object.getOwnPropertySymbols(object))
		
		if (object === Function.prototype) {
			reachable = reachable.filter(ignoredKeys)
		}
		
		reachable.forEach(replaceWithProxy, object)
		Object.freeze(object)
		safeObjects.push(object)
		
		unsafeObjects.push(Object.getPrototypeOf(object))
	}
	
	function ignoredKeys(key) {
		return key !== 'caller' && key !== 'arguments'
	}
	
	function isSafe(value) {
		return !isObject(value) || proxies.indexOf(value) >= 0 || safeObjects.indexOf(value) >= 0
	}
	
	function replaceWithProxy(key) {
		var d = Object.getOwnPropertyDescriptor(this, key)
		if (!('value' in d)) {
			if (key === '__proto__' && isSafe(this[key])) {
				return
			}
			if (!d.configurable) {
				d.get && unsafeObjects.push(d.get)
				d.set && unsafeObjects.push(d.set)
				// This getter/setter could potentially return a non-proxied object
				console.warn('Potentially vulnerable getter/setter at %s in %s', key, this)
				return
			}
			var getter = d.get && getProxy(d.get, true)
			var setter = d.set && getProxy(d.set, true)
			Object.defineProperty(this, key, {
				get: getter,
				set: setter,
				enumerable: d.enumerable,
				configurable: false
			})
			getter && proxies.push(getter)
			setter && proxies.push(setter)
			return
		}
		
		var value = this[key]
		if (isSafe(value)) {
			return
		}
		
		if (d.writable) {
			var proxy = getProxy(value, true)
			proxies.push(this[key] = proxy)
			replaceInGlobal(value, proxy)
			return
		}
		
		if (d.configurable) {
			var proxy = getProxy(value, true)
			Object.defineProperty(this, key, {
				value: proxy,
				writable: false,
				enumerable: d.enumerable,
				configurable: false
			})
			replaceInGlobal(value, proxy)
			proxies.push(proxy)
			return
		}
		
		unsafeObjects.push(value)
		if (typeof value === 'function' && returnsSafeValues.indexOf(value) === -1) {
			// This function could potentially return a non-proxied object
			console.warn('Potentially vulnerable function at %s in %s', key, this)
		}
	}
	
	function replaceInGlobal(value, proxy) {
		var index = globalValues.indexOf(value)
		if (index >= 0) {
			var key = globalKeys[index]
			var d = Object.getOwnPropertyDescriptor(GLOBAL, key)
			if (d.writable) {
				GLOBAL[key] = proxy
			} else if (d.configurable) {
				Object.defineProperty(GLOBAL, key, {
					value: proxy,
					writable: false,
					enumerable: d.enumerable,
					configurable: false
				})
			} else {
				console.warn('Was not able to replace %s in global object', key)
			}
		}
	}
	
	return safeObjects
}

},{}],62:[function(require,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

function isPlainObject(obj) {
	if (!obj || toString.call(obj) !== '[object Object]' || obj.nodeType || obj.setInterval)
		return false;

	var has_own_constructor = hasOwn.call(obj, 'constructor');
	var has_is_property_of_method = hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !has_own_constructor && !has_is_property_of_method)
		return false;

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for ( key in obj ) {}

	return key === undefined || hasOwn.call( obj, key );
};

module.exports = function extend() {
	var options, name, src, copy, copyIsArray, clone,
	    target = arguments[0] || {},
	    i = 1,
	    length = arguments.length,
	    deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && typeof target !== "function") {
		target = {};
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( isPlainObject(copy) || (copyIsArray = Array.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray(src) ? src : [];

					} else {
						clone = src && isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

},{}],63:[function(require,module,exports){
'use strict';
var ansiRegex = require('ansi-regex');
var re = new RegExp(ansiRegex().source); // remove the `g` flag
module.exports = re.test.bind(re);

},{"ansi-regex":53}],64:[function(require,module,exports){
(function (global){
/**
 * © Copyright IBM Corp. 2016, 2017 All Rights Reserved
 *   Project name: JSONata
 *   This project is licensed under the MIT License, see LICENSE
 */

/**
 * @module JSONata
 * @description JSON query and transformation language
 */

/**
 * jsonata
 * @function
 * @param {Object} expr - JSONata expression
 * @returns {{evaluate: evaluate, assign: assign}} Evaluated expression
 */
var jsonata = (function() {
    'use strict';

    var operators = {
        '.': 75,
        '[': 80,
        ']': 0,
        '{': 70,
        '}': 0,
        '(': 80,
        ')': 0,
        ',': 0,
        '@': 75,
        '#': 70,
        ';': 80,
        ':': 80,
        '?': 20,
        '+': 50,
        '-': 50,
        '*': 60,
        '/': 60,
        '%': 60,
        '|': 20,
        '=': 40,
        '<': 40,
        '>': 40,
        '^': 40,
        '**': 60,
        '..': 20,
        ':=': 10,
        '!=': 40,
        '<=': 40,
        '>=': 40,
        '~>': 40,
        'and': 30,
        'or': 25,
        'in': 40,
        '&': 50,
        '!': 0,   // not an operator, but needed as a stop character for name tokens
        '~': 0   // not an operator, but needed as a stop character for name tokens
    };

    var escapes = {  // JSON string escape sequences - see json.org
        '"': '"',
        '\\': '\\',
        '/': '/',
        'b': '\b',
        'f': '\f',
        'n': '\n',
        'r': '\r',
        't': '\t'
    };

    // Tokenizer (lexer) - invoked by the parser to return one token at a time
    var tokenizer = function (path) {
        var position = 0;
        var length = path.length;

        var create = function (type, value) {
            var obj = {type: type, value: value, position: position};
            return obj;
        };

        var scanRegex = function() {
            // the prefix '/' will have been previously scanned. Find the end of the regex.
            // search for closing '/' ignoring any that are escaped, or within brackets
            var start = position;
            var depth = 0;
            var pattern;
            var flags;
            while(position < length) {
                var currentChar = path.charAt(position);
                if(currentChar === '/' && path.charAt(position - 1) !== '\\' && depth === 0) {
                    // end of regex found
                    pattern = path.substring(start, position);
                    if(pattern === '') {
                        throw {
                            code: "S0301",
                            stack: (new Error()).stack,
                            position: position
                        };
                    }
                    position++;
                    currentChar = path.charAt(position);
                    // flags
                    start = position;
                    while(currentChar === 'i' || currentChar === 'm') {
                        position++;
                        currentChar = path.charAt(position);
                    }
                    flags = path.substring(start, position) + 'g';
                    return new RegExp(pattern, flags);
                }
                if((currentChar === '(' || currentChar === '[' || currentChar === '{') && path.charAt(position - 1) !== '\\' ) {
                    depth++;
                }
                if((currentChar === ')' || currentChar === ']' || currentChar === '}') && path.charAt(position - 1) !== '\\' ) {
                    depth--;
                }

                position++;
            }
            throw {
                code: "S0302",
                stack: (new Error()).stack,
                position: position
            };
        };

        var next = function (prefix) {
            if (position >= length) return null;
            var currentChar = path.charAt(position);
            // skip whitespace
            while (position < length && ' \t\n\r\v'.indexOf(currentChar) > -1) {
                position++;
                currentChar = path.charAt(position);
            }
            // test for regex
            if (prefix !== true && currentChar === '/') {
                position++;
                return create('regex', scanRegex());
            }
            // handle double-char operators
            if (currentChar === '.' && path.charAt(position + 1) === '.') {
                // double-dot .. range operator
                position += 2;
                return create('operator', '..');
            }
            if (currentChar === ':' && path.charAt(position + 1) === '=') {
                // := assignment
                position += 2;
                return create('operator', ':=');
            }
            if (currentChar === '!' && path.charAt(position + 1) === '=') {
                // !=
                position += 2;
                return create('operator', '!=');
            }
            if (currentChar === '>' && path.charAt(position + 1) === '=') {
                // >=
                position += 2;
                return create('operator', '>=');
            }
            if (currentChar === '<' && path.charAt(position + 1) === '=') {
                // <=
                position += 2;
                return create('operator', '<=');
            }
            if (currentChar === '*' && path.charAt(position + 1) === '*') {
                // **  descendant wildcard
                position += 2;
                return create('operator', '**');
            }
            if (currentChar === '~' && path.charAt(position + 1) === '>') {
                // ~>  chain function
                position += 2;
                return create('operator', '~>');
            }
            // test for single char operators
            if (operators.hasOwnProperty(currentChar)) {
                position++;
                return create('operator', currentChar);
            }
            // test for string literals
            if (currentChar === '"' || currentChar === "'") {
                var quoteType = currentChar;
                // double quoted string literal - find end of string
                position++;
                var qstr = "";
                while (position < length) {
                    currentChar = path.charAt(position);
                    if (currentChar === '\\') { // escape sequence
                        position++;
                        currentChar = path.charAt(position);
                        if (escapes.hasOwnProperty(currentChar)) {
                            qstr += escapes[currentChar];
                        } else if (currentChar === 'u') {
                            // \u should be followed by 4 hex digits
                            var octets = path.substr(position + 1, 4);
                            if (/^[0-9a-fA-F]+$/.test(octets)) {
                                var codepoint = parseInt(octets, 16);
                                qstr += String.fromCharCode(codepoint);
                                position += 4;
                            } else {
                                throw {
                                    code: "S0104",
                                    stack: (new Error()).stack,
                                    position: position
                                };
                            }
                        } else {
                            // illegal escape sequence
                            throw {
                                code: "S0103",
                                stack: (new Error()).stack,
                                position: position,
                                token: currentChar
                            };

                        }
                    } else if (currentChar === quoteType) {
                        position++;
                        return create('string', qstr);
                    } else {
                        qstr += currentChar;
                    }
                    position++;
                }
                throw {
                    code: "S0101",
                    stack: (new Error()).stack,
                    position: position
                };
            }
            // test for numbers
            var numregex = /^-?(0|([1-9][0-9]*))(\.[0-9]+)?([Ee][-+]?[0-9]+)?/;
            var match = numregex.exec(path.substring(position));
            if (match !== null) {
                var num = parseFloat(match[0]);
                if (!isNaN(num) && isFinite(num)) {
                    position += match[0].length;
                    return create('number', num);
                } else {
                    throw {
                        code: "S0102",
                        stack: (new Error()).stack,
                        position: position,
                        token: match[0]
                    };
                }
            }
            // test for quoted names (backticks)
            var name;
            if(currentChar === '`') {
                // scan for closing quote
                position++;
                var end = path.indexOf('`', position);
                if(end !== -1) {
                    name = path.substring(position, end);
                    position = end + 1;
                    return create('name', name);
                }
                position = length;
                throw {
                    code: "S0105",
                    stack: (new Error()).stack,
                    position: position
                };
            }
            // test for names
            var i = position;
            var ch;
            for (;;) {
                ch = path.charAt(i);
                if (i === length || ' \t\n\r\v'.indexOf(ch) > -1 || operators.hasOwnProperty(ch)) {
                    if (path.charAt(position) === '$') {
                        // variable reference
                        name = path.substring(position + 1, i);
                        position = i;
                        return create('variable', name);
                    } else {
                        name = path.substring(position, i);
                        position = i;
                        switch (name) {
                            case 'or':
                            case 'in':
                            case 'and':
                                return create('operator', name);
                            case 'true':
                                return create('value', true);
                            case 'false':
                                return create('value', false);
                            case 'null':
                                return create('value', null);
                            default:
                                if (position === length && name === '') {
                                    // whitespace at end of input
                                    return null;
                                }
                                return create('name', name);
                        }
                    }
                } else {
                    i++;
                }
            }
        };

        return next;
    };

    /**
     * Parses a function signature definition and returns a validation function
     * @param {string} signature - the signature between the <angle brackets>
     * @returns {Function} validation function
     */
    function parseSignature(signature) {
        // create a Regex that represents this signature and return a function that when invoked,
        // returns the validated (possibly fixed-up) arguments, or throws a validation error
        // step through the signature, one symbol at a time
        var position = 1;
        var params = [];
        var param = {};
        var prevParam = param;
        while (position < signature.length) {
            var symbol = signature.charAt(position);
            if(symbol === ':') {
                // TODO figure out what to do with the return type
                // ignore it for now
                break;
            }

            var next = function() {
                params.push(param);
                prevParam = param;
                param = {};
            };

            var findClosingBracket = function(str, start, openSymbol, closeSymbol) {
                // returns the position of the closing symbol (e.g. bracket) in a string
                // that balances the opening symbol at position start
                var depth = 1;
                var position = start;
                while(position < str.length) {
                    position++;
                    symbol = str.charAt(position);
                    if(symbol === closeSymbol) {
                        depth--;
                        if(depth === 0) {
                            // we're done
                            break; // out of while loop
                        }
                    } else if(symbol === openSymbol) {
                        depth++;
                    }
                }
                return position;
            };

            switch (symbol) {
                case 's': // string
                case 'n': // number
                case 'b': // boolean
                case 'l': // not so sure about expecting null?
                case 'o': // object
                    param.regex = '[' + symbol + 'm]';
                    param.type = symbol;
                    next();
                    break;
                case 'a': // array
                    //  normally treat any value as singleton array
                    param.regex = '[asnblfom]';
                    param.type = symbol;
                    param.array = true;
                    next();
                    break;
                case 'f': // function
                    param.regex = 'f';
                    param.type = symbol;
                    next();
                    break;
                case 'j': // any JSON type
                    param.regex = '[asnblom]';
                    param.type = symbol;
                    next();
                    break;
                case 'x': // any type
                    param.regex = '[asnblfom]';
                    param.type = symbol;
                    next();
                    break;
                case '-': // use context if param not supplied
                    prevParam.context = true;
                    prevParam.contextRegex = new RegExp(prevParam.regex); // pre-compiled to test the context type at runtime
                    prevParam.regex += '?';
                    break;
                case '?': // optional param
                case '+': // one or more
                    prevParam.regex += symbol;
                    break;
                case '(': // choice of types
                    // search forward for matching ')'
                    var endParen = findClosingBracket(signature, position, '(', ')');
                    var choice = signature.substring(position + 1, endParen);
                    if(choice.indexOf('<') === -1) {
                        // no parameterized types, simple regex
                        param.regex = '[' + choice + 'm]';
                    } else {
                        // TODO harder
                        throw {
                            code: "S0402",
                            stack: (new Error()).stack,
                            value: choice,
                            offset: position
                        };
                    }
                    param.type = '(' + choice + ')';
                    position = endParen;
                    next();
                    break;
                case '<': // type parameter - can only be applied to 'a' and 'f'
                    if(prevParam.type === 'a' || prevParam.type === 'f') {
                        // search forward for matching '>'
                        var endPos = findClosingBracket(signature, position, '<', '>');
                        prevParam.subtype = signature.substring(position + 1, endPos);
                        position = endPos;
                    } else {
                        throw {
                            code: "S0401",
                            stack: (new Error()).stack,
                            value: prevParam.type,
                            offset: position
                        };
                    }
                    break;
            }
            position++;
        }
        var regexStr = '^' +
          params.map(function(param) {
              return '(' + param.regex + ')';
          }).join('') +
          '$';
        var regex = new RegExp(regexStr);
        var getSymbol = function(value) {
            var symbol;
            if(isFunction(value)) {
                symbol = 'f';
            } else {
                var type = typeof value;
                switch (type) {
                    case 'string':
                        symbol = 's';
                        break;
                    case 'number':
                        symbol = 'n';
                        break;
                    case 'boolean':
                        symbol = 'b';
                        break;
                    case 'object':
                        if (value === null) {
                            symbol = 'l';
                        } else if (Array.isArray(value)) {
                            symbol = 'a';
                        } else {
                            symbol = 'o';
                        }
                        break;
                    case 'undefined':
                        // any value can be undefined, but should be allowed to match
                        symbol = 'm'; // m for missing
                }
            }
            return symbol;
        };

        var throwValidationError = function(badArgs, badSig) {
            // to figure out where this went wrong we need apply each component of the
            // regex to each argument until we get to the one that fails to match
            var partialPattern = '^';
            var goodTo = 0;
            for(var index = 0; index < params.length; index++) {
                partialPattern += params[index].regex;
                var match = badSig.match(partialPattern);
                if(match === null) {
                    // failed here
                    throw {
                        code: "T0410",
                        stack: (new Error()).stack,
                        value: badArgs[goodTo],
                        index: goodTo + 1
                    };
                }
                goodTo = match[0].length;
            }
            // if it got this far, it's probably because of extraneous arguments (we
            // haven't added the trailing '$' in the regex yet.
            throw {
                code: "T0410",
                stack: (new Error()).stack,
                value: badArgs[goodTo],
                index: goodTo + 1
            };
        };

        return {
            definition: signature,
            validate: function(args, context) {
                var suppliedSig = '';
                args.forEach(function(arg) {
                    suppliedSig += getSymbol(arg);
                });
                var isValid = regex.exec(suppliedSig);
                if(isValid) {
                    var validatedArgs = [];
                    var argIndex = 0;
                    params.forEach(function(param, index) {
                        var arg = args[argIndex];
                        var match = isValid[index + 1];
                        if(match === '') {
                            if (param.context) {
                                // substitute context value for missing arg
                                // first check that the context value is the right type
                                var contextType = getSymbol(context);
                                // test contextType against the regex for this arg (without the trailing ?)
                                if(param.contextRegex.test(contextType)) {
                                    validatedArgs.push(context);
                                } else {
                                    // context value not compatible with this argument
                                    throw {
                                        code: "T0411",
                                        stack: (new Error()).stack,
                                        value: context,
                                        index: argIndex + 1
                                    };
                                }
                            } else {
                                validatedArgs.push(arg);
                                argIndex++;
                            }
                        } else {
                            // may have matched multiple args (if the regex ends with a '+'
                            // split into single tokens
                            match.split('').forEach(function(single) {
                                if (param.type === 'a') {
                                    if (single === 'm') {
                                        // missing (undefined)
                                        arg = undefined;
                                    } else {
                                        arg = args[argIndex];
                                        var arrayOK = true;
                                        // is there type information on the contents of the array?
                                        if (typeof param.subtype !== 'undefined') {
                                            if (single !== 'a' && match !== param.subtype) {
                                                arrayOK = false;
                                            } else if (single === 'a') {
                                                if (arg.length > 0) {
                                                    var itemType = getSymbol(arg[0]);
                                                    if (itemType !== param.subtype.charAt(0)) { // TODO recurse further
                                                        arrayOK = false;
                                                    } else {
                                                        // make sure every item in the array is this type
                                                        var differentItems = arg.filter(function (val) {
                                                            return (getSymbol(val) !== itemType);
                                                        });
                                                        arrayOK = (differentItems.length === 0);
                                                    }
                                                }
                                            }
                                        }
                                        if (!arrayOK) {
                                            throw {
                                                code: "T0412",
                                                stack: (new Error()).stack,
                                                value: arg,
                                                index: argIndex + 1,
                                                type: param.subtype // TODO translate symbol to type name
                                            };
                                        }
                                        // the function expects an array. If it's not one, make it so
                                        if (single !== 'a') {
                                            arg = [arg];
                                        }
                                    }
                                    validatedArgs.push(arg);
                                    argIndex++;
                                } else {
                                    validatedArgs.push(arg);
                                    argIndex++;
                                }
                            });
                        }
                    });
                    return validatedArgs;
                }
                throwValidationError(args, suppliedSig);
            }
        };
    }

    // This parser implements the 'Top down operator precedence' algorithm developed by Vaughan R Pratt; http://dl.acm.org/citation.cfm?id=512931.
    // and builds on the Javascript framework described by Douglas Crockford at http://javascript.crockford.com/tdop/tdop.html
    // and in 'Beautiful Code', edited by Andy Oram and Greg Wilson, Copyright 2007 O'Reilly Media, Inc. 798-0-596-51004-6

    var parser = function (source, recover) {
        var node;
        var lexer;

        var symbol_table = {};
        var errors = [];

        var remainingTokens = function() {
            var remaining = [];
            if(node.id !== '(end)') {
                remaining.push({type: node.type, value: node.value, position: node.position});
            }
            var nxt = lexer();
            while(nxt !== null) {
                remaining.push(nxt);
                nxt = lexer();
            }
            return remaining;
        };

        var base_symbol = {
            nud: function () {
                // error - symbol has been invoked as a unary operator
                var err = {
                    code: 'S0211',
                    token: this.value,
                    position: this.position
                };

                if(recover) {
                    err.remaining = remainingTokens();
                    err.type = 'error';
                    errors.push(err);
                    return err;
                } else {
                    err.stack = (new Error()).stack;
                    throw err;
                }
            }
        };

        var symbol = function (id, bp) {
            var s = symbol_table[id];
            bp = bp || 0;
            if (s) {
                if (bp >= s.lbp) {
                    s.lbp = bp;
                }
            } else {
                s = Object.create(base_symbol);
                s.id = s.value = id;
                s.lbp = bp;
                symbol_table[id] = s;
            }
            return s;
        };

        var handleError = function(err) {
            if(recover) {
                // tokenize the rest of the buffer and add it to an error token
                err.remaining = remainingTokens();
                errors.push(err);
                var symbol = symbol_table["(error)"];
                node = Object.create(symbol);
                node.error = err;
                node.type = "(error)";
                return node;
            } else {
                err.stack = (new Error()).stack;
                throw err;
            }
        };

        var advance = function (id, infix) {
            if (id && node.id !== id) {
                var code;
                if(node.id === '(end)') {
                    // unexpected end of buffer
                    code = "S0203";
                } else {
                    code = "S0202";
                }
                var err = {
                    code: code,
                    position: node.position,
                    token: node.value,
                    value: id
                };
                return handleError(err);
            }
            var next_token = lexer(infix);
            if (next_token === null) {
                node = symbol_table["(end)"];
                node.position = source.length;
                return node;
            }
            var value = next_token.value;
            var type = next_token.type;
            var symbol;
            switch (type) {
                case 'name':
                case 'variable':
                    symbol = symbol_table["(name)"];
                    break;
                case 'operator':
                    symbol = symbol_table[value];
                    if (!symbol) {
                        return handleError( {
                            code: "S0204",
                            stack: (new Error()).stack,
                            position: next_token.position,
                            token: value
                        });
                    }
                    break;
                case 'string':
                case 'number':
                case 'value':
                    type = "literal";
                    symbol = symbol_table["(literal)"];
                    break;
                case 'regex':
                    type = "regex";
                    symbol = symbol_table["(regex)"];
                    break;
                    /* istanbul ignore next */
                default:
                    return handleError( {
                        code: "S0205",
                        stack: (new Error()).stack,
                        position: next_token.position,
                        token: value
                    });
            }

            node = Object.create(symbol);
            node.value = value;
            node.type = type;
            node.position = next_token.position;
            return node;
        };

        // Pratt's algorithm
        var expression = function (rbp) {
            var left;
            var t = node;
            advance(null, true);
            left = t.nud();
            while (rbp < node.lbp) {
                t = node;
                advance();
                left = t.led(left);
            }
            return left;
        };

        var terminal = function(id) {
            var s = symbol(id, 0);
            s.nud = function() {
                return this;
            };
        };

        // match infix operators
        // <expression> <operator> <expression>
        // left associative
        var infix = function (id, bp, led) {
            var bindingPower = bp || operators[id];
            var s = symbol(id, bindingPower);
            s.led = led || function (left) {
                this.lhs = left;
                this.rhs = expression(bindingPower);
                this.type = "binary";
                return this;
            };
            return s;
        };

        // match infix operators
        // <expression> <operator> <expression>
        // right associative
        var infixr = function (id, bp, led) {
            var bindingPower = bp || operators[id];
            var s = symbol(id, bindingPower);
            s.led = led || function (left) {
                this.lhs = left;
                this.rhs = expression(bindingPower - 1); // subtract 1 from bindingPower for right associative operators
                this.type = "binary";
                return this;
            };
            return s;
        };

        // match prefix operators
        // <operator> <expression>
        var prefix = function (id, nud) {
            var s = symbol(id);
            s.nud = nud || function () {
                this.expression = expression(70);
                this.type = "unary";
                return this;
            };
            return s;
        };

        terminal("(end)");
        terminal("(name)");
        terminal("(literal)");
        terminal("(regex)");
        symbol(":");
        symbol(";");
        symbol(",");
        symbol(")");
        symbol("]");
        symbol("}");
        symbol(".."); // range operator
        infix("."); // field reference
        infix("+"); // numeric addition
        infix("-"); // numeric subtraction
        infix("*"); // numeric multiplication
        infix("/"); // numeric division
        infix("%"); // numeric modulus
        infix("="); // equality
        infix("<"); // less than
        infix(">"); // greater than
        infix("!="); // not equal to
        infix("<="); // less than or equal
        infix(">="); // greater than or equal
        infix("&"); // string concatenation
        infix("and"); // Boolean AND
        infix("or"); // Boolean OR
        infix("in"); // is member of array
        terminal("and"); // the 'keywords' can also be used as terminals (field names)
        terminal("or"); //
        terminal("in"); //
        infixr(":="); // bind variable
        prefix("-"); // unary numeric negation
        infix("~>"); // function application

        infixr("(error)", 10, function(left) {
            this.lhs = left;

            this.error = node.error;
            this.remaining = remainingTokens();
            this.type = 'error';
            return this;
        });

        // field wildcard (single level)
        prefix('*', function () {
            this.type = "wildcard";
            return this;
        });

        // descendant wildcard (multi-level)
        prefix('**', function () {
            this.type = "descendant";
            return this;
        });

        // function invocation
        infix("(", operators['('], function (left) {
            // left is is what we are trying to invoke
            this.procedure = left;
            this.type = 'function';
            this.arguments = [];
            if (node.id !== ')') {
                for (;;) {
                    if (node.type === 'operator' && node.id === '?') {
                        // partial function application
                        this.type = 'partial';
                        this.arguments.push(node);
                        advance('?');
                    } else {
                        this.arguments.push(expression(0));
                    }
                    if (node.id !== ',') break;
                    advance(',');
                }
            }
            advance(")", true);
            // if the name of the function is 'function' or λ, then this is function definition (lambda function)
            if (left.type === 'name' && (left.value === 'function' || left.value === '\u03BB')) {
                // all of the args must be VARIABLE tokens
                this.arguments.forEach(function (arg, index) {
                    if (arg.type !== 'variable') {
                        return handleError( {
                            code: "S0208",
                            stack: (new Error()).stack,
                            position: arg.position,
                            token: arg.value,
                            value: index + 1
                        });
                    }
                });
                this.type = 'lambda';
                // is the next token a '<' - if so, parse the function signature
                if(node.id === '<') {
                    var sigPos = node.position;
                    var depth = 1;
                    var sig = '<';
                    while(depth > 0 && node.id !== '{' && node.id !== '(end)') {
                        var tok = advance();
                        if(tok.id === '>') {
                            depth--;
                        } else if(tok.id === '<') {
                            depth++;
                        }
                        sig += tok.value;
                    }
                    advance('>');
                    try {
                        this.signature = parseSignature(sig);
                    } catch(err) {
                        // insert the position into this error
                        err.position = sigPos + err.offset;
                        return handleError( err );
                    }
                }
                // parse the function body
                advance('{');
                this.body = expression(0);
                advance('}');
            }
            return this;
        });

        // parenthesis - block expression
        prefix("(", function () {
            var expressions = [];
            while (node.id !== ")") {
                expressions.push(expression(0));
                if (node.id !== ";") {
                    break;
                }
                advance(";");
            }
            advance(")", true);
            this.type = 'block';
            this.expressions = expressions;
            return this;
        });

        // array constructor
        prefix("[", function () {
            var a = [];
            if (node.id !== "]") {
                for (;;) {
                    var item = expression(0);
                    if (node.id === "..") {
                        // range operator
                        var range = {type: "binary", value: "..", position: node.position, lhs: item};
                        advance("..");
                        range.rhs = expression(0);
                        item = range;
                    }
                    a.push(item);
                    if (node.id !== ",") {
                        break;
                    }
                    advance(",");
                }
            }
            advance("]", true);
            this.expressions = a;
            this.type = "unary";
            return this;
        });

        // filter - predicate or array index
        infix("[", operators['['], function (left) {
            if(node.id === "]") {
                // empty predicate means maintain singleton arrays in the output
                var step = left;
                while(step && step.type === 'binary' && step.value === '[') {
                    step = step.lhs;
                }
                step.keepArray = true;
                advance("]");
                return left;
            } else {
                this.lhs = left;
                this.rhs = expression(operators[']']);
                this.type = 'binary';
                advance("]", true);
                return this;
            }
        });

        // order-by
        infix("^", operators['^'], function (left) {
            advance("(");
            var terms = [];
            for(;;) {
                var term = {
                    descending: false
                };
                if (node.id === "<") {
                    // ascending sort
                    advance("<");
                } else if (node.id === ">") {
                    // descending sort
                    term.descending = true;
                    advance(">");
                } else {
                    //unspecified - default to ascending
                }
                term.expression = expression(0);
                terms.push(term);
                if(node.id !== ",") {
                    break;
                }
                advance(",");
            }
            advance(")");
            this.lhs = left;
            this.rhs = terms;
            this.type = 'binary';
            return this;
        });

        var objectParser = function (left) {
            var a = [];
            if (node.id !== "}") {
                for (;;) {
                    var n = expression(0);
                    advance(":");
                    var v = expression(0);
                    a.push([n, v]); // holds an array of name/value expression pairs
                    if (node.id !== ",") {
                        break;
                    }
                    advance(",");
                }
            }
            advance("}", true);
            if(typeof left === 'undefined') {
                // NUD - unary prefix form
                this.lhs = a;
                this.type = "unary";
            } else {
                // LED - binary infix form
                this.lhs = left;
                this.rhs = a;
                this.type = 'binary';
            }
            return this;
        };

        // object constructor
        prefix("{", objectParser);

        // object grouping
        infix("{", operators['{'], objectParser);

        // if/then/else ternary operator ?:
        infix("?", operators['?'], function (left) {
            this.type = 'condition';
            this.condition = left;
            this.then = expression(0);
            if (node.id === ':') {
                // else condition
                advance(":");
                this.else = expression(0);
            }
            return this;
        });

        // object transformer
        prefix("|", function () {
            this.type = 'transform';
            this.pattern = expression(0);
            advance('|');
            this.update = expression(0);
            if(node.id === ',') {
                advance(',');
                this.delete = expression(0);
            }
            advance('|');
            return this;
        });

        // tail call optimization
        // this is invoked by the post parser to analyse lambda functions to see
        // if they make a tail call.  If so, it is replaced by a thunk which will
        // be invoked by the trampoline loop during function application.
        // This enables tail-recursive functions to be written without growing the stack
        var tail_call_optimize = function(expr) {
            var result;
            if(expr.type === 'function') {
                var thunk = {type: 'lambda', thunk: true, arguments: [], position: expr.position};
                thunk.body = expr;
                result = thunk;
            } else if(expr.type === 'condition') {
                // analyse both branches
                expr.then = tail_call_optimize(expr.then);
                if(typeof expr.else !== 'undefined') {
                    expr.else = tail_call_optimize(expr.else);
                }
                result = expr;
            } else if(expr.type === 'block') {
                // only the last expression in the block
                var length = expr.expressions.length;
                if(length > 0) {
                    expr.expressions[length - 1] = tail_call_optimize(expr.expressions[length - 1]);
                }
                result = expr;
            } else {
                result = expr;
            }
            return result;
        };

        // post-parse stage
        // the purpose of this is flatten the parts of the AST representing location paths,
        // converting them to arrays of steps which in turn may contain arrays of predicates.
        // following this, nodes containing '.' and '[' should be eliminated from the AST.
        var ast_optimize = function (expr) {
            var result;
            switch (expr.type) {
                case 'binary':
                    switch (expr.value) {
                        case '.':
                            var lstep = ast_optimize(expr.lhs);
                            result = {type: 'path', steps: []};
                            if (lstep.type === 'path') {
                                Array.prototype.push.apply(result.steps, lstep.steps);
                            } else {
                                result.steps = [lstep];
                            }
                            var rest = ast_optimize(expr.rhs);
                            if(rest.type === 'function' &&
                              rest.procedure.type === 'path' &&
                              rest.procedure.steps.length === 1 &&
                              rest.procedure.steps[0].type === 'name' &&
                              result.steps[result.steps.length-1].type === 'function') {
                                // next function in chain of functions - will override a thenable
                                result.steps[result.steps.length-1].nextFunction = rest.procedure.steps[0].value;
                            }
                            if(rest.type !== 'path') {
                                rest = {type: 'path', steps: [rest]};
                            }
                            Array.prototype.push.apply(result.steps, rest.steps);
                            // any steps within a path that are literals, should be changed to 'name'
                            result.steps.filter(function(step) {
                                return step.type === 'literal';
                            }).forEach(function(lit) {
                                lit.type = 'name';
                            });
                            // any step that signals keeping a singleton array, should be flagged on the path
                            if(result.steps.filter(function(step) { return step.keepArray === true;}).length > 0) {
                                result.keepSingletonArray = true;
                            }
                            // if first step is a path constructor, flag it for special handling
                            if(result.steps[0].type === 'unary' && result.steps[0].value === '[') {
                                result.steps[0].consarray = true;
                            }
                            break;
                        case '[':
                            // predicated step
                            // LHS is a step or a predicated step
                            // RHS is the predicate expr
                            result = ast_optimize(expr.lhs);
                            var step = result;
                            if(result.type === 'path') {
                                step = result.steps[result.steps.length - 1];
                            }
                            if (typeof step.group !== 'undefined') {
                                throw {
                                    code: "S0209",
                                    stack: (new Error()).stack,
                                    position: expr.position
                                };
                            }
                            if (typeof step.predicate === 'undefined') {
                                step.predicate = [];
                            }
                            step.predicate.push(ast_optimize(expr.rhs));
                            break;
                        case '{':
                            // group-by
                            // LHS is a step or a predicated step
                            // RHS is the object constructor expr
                            result = ast_optimize(expr.lhs);
                            if (typeof result.group !== 'undefined') {
                                throw {
                                    code: "S0210",
                                    stack: (new Error()).stack,
                                    position: expr.position
                                };
                            }
                            // object constructor - process each pair
                            result.group = {
                                lhs: expr.rhs.map(function (pair) {
                                    return [ast_optimize(pair[0]), ast_optimize(pair[1])];
                                }),
                                position: expr.position
                            };
                            break;
                        case '^':
                            // order-by
                            // LHS is the array to be ordered
                            // RHS defines the terms
                            result = {type: 'sort', value: expr.value, position: expr.position};
                            result.lhs = ast_optimize(expr.lhs);
                            result.rhs = expr.rhs.map(function (terms) {
                                return {
                                    descending: terms.descending,
                                    expression: ast_optimize(terms.expression)
                                };
                            });
                            break;
                        case ':=':
                            result = {type: 'bind', value: expr.value, position: expr.position};
                            result.lhs = ast_optimize(expr.lhs);
                            result.rhs = ast_optimize(expr.rhs);
                            break;
                        case '~>':
                            result = {type: 'apply', value: expr.value, position: expr.position};
                            result.lhs = ast_optimize(expr.lhs);
                            result.rhs = ast_optimize(expr.rhs);
                            break;
                        default:
                            result = {type: expr.type, value: expr.value, position: expr.position};
                            result.lhs = ast_optimize(expr.lhs);
                            result.rhs = ast_optimize(expr.rhs);
                    }
                    break;
                case 'unary':
                    result = {type: expr.type, value: expr.value, position: expr.position};
                    if (expr.value === '[') {
                        // array constructor - process each item
                        result.expressions = expr.expressions.map(function (item) {
                            return ast_optimize(item);
                        });
                    } else if (expr.value === '{') {
                        // object constructor - process each pair
                        result.lhs = expr.lhs.map(function (pair) {
                            return [ast_optimize(pair[0]), ast_optimize(pair[1])];
                        });
                    } else {
                        // all other unary expressions - just process the expression
                        result.expression = ast_optimize(expr.expression);
                        // if unary minus on a number, then pre-process
                        if (expr.value === '-' && result.expression.type === 'literal' && isNumeric(result.expression.value)) {
                            result = result.expression;
                            result.value = -result.value;
                        }
                    }
                    break;
                case 'function':
                case 'partial':
                    result = {type: expr.type, name: expr.name, value: expr.value, position: expr.position};
                    result.arguments = expr.arguments.map(function (arg) {
                        return ast_optimize(arg);
                    });
                    result.procedure = ast_optimize(expr.procedure);
                    break;
                case 'lambda':
                    result = {type: expr.type, arguments: expr.arguments, signature: expr.signature, position: expr.position};
                    var body = ast_optimize(expr.body);
                    result.body = tail_call_optimize(body);
                    break;
                case 'condition':
                    result = {type: expr.type, position: expr.position};
                    result.condition = ast_optimize(expr.condition);
                    result.then = ast_optimize(expr.then);
                    if (typeof expr.else !== 'undefined') {
                        result.else = ast_optimize(expr.else);
                    }
                    break;
                case 'transform':
                    result = {type: expr.type, position: expr.position};
                    result.pattern = ast_optimize(expr.pattern);
                    result.update = ast_optimize(expr.update);
                    if(typeof expr.delete !== 'undefined') {
                        result.delete = ast_optimize(expr.delete);
                    }
                    break;
                case 'block':
                    result = {type: expr.type, position: expr.position};
                    // array of expressions - process each one
                    result.expressions = expr.expressions.map(function (item) {
                        return ast_optimize(item);
                    });
                    // TODO scan the array of expressions to see if any of them assign variables
                    // if so, need to mark the block as one that needs to create a new frame
                    break;
                case 'name':
                    result = {type: 'path', steps: [expr]};
                    if(expr.keepArray) {
                        result.keepSingletonArray = true;
                    }
                    break;
                case 'literal':
                case 'wildcard':
                case 'descendant':
                case 'variable':
                case 'regex':
                    result = expr;
                    break;
                case 'operator':
                    // the tokens 'and' and 'or' might have been used as a name rather than an operator
                    if (expr.value === 'and' || expr.value === 'or' || expr.value === 'in') {
                        expr.type = 'name';
                        result = ast_optimize(expr);
                    } else /* istanbul ignore else */ if (expr.value === '?') {
                        // partial application
                        result = expr;
                    } else {
                        throw {
                            code: "S0201",
                            stack: (new Error()).stack,
                            position: expr.position,
                            token: expr.value
                        };
                    }
                    break;
                case 'error':
                    result = expr;
                    if(expr.lhs) {
                        result = ast_optimize(expr.lhs);
                    }
                    break;
                default:
                    var code = "S0206";
                    /* istanbul ignore else */
                    if (expr.id === '(end)') {
                        code = "S0207";
                    }
                    var err = {
                        code: code,
                        position: expr.position,
                        token: expr.value
                    };
                    if(recover) {
                        errors.push(err);
                        return {type: 'error', error: err};
                    } else {
                        err.stack = (new Error()).stack;
                        throw err;
                    }
            }
            return result;
        };

        // now invoke the tokenizer and the parser and return the syntax tree
        lexer = tokenizer(source);
        advance();
        // parse the tokens
        var expr = expression(0);
        if (node.id !== '(end)') {
            var err = {
                code: "S0201",
                position: node.position,
                token: node.value
            };
            handleError(err);
        }
        expr = ast_optimize(expr);

        if(errors.length > 0) {
            expr.errors = errors;
        }

        return expr;
    };

    // Start of Evaluator code

    var staticFrame = createFrame(null);

    /**
     * Check if value is a finite number
     * @param {float} n - number to evaluate
     * @returns {boolean} True if n is a finite number
     */
    function isNumeric(n) {
        var isNum = false;
        if(typeof n === 'number') {
            var num = parseFloat(n);
            isNum = !isNaN(num);
            if (isNum && !isFinite(num)) {
                throw {
                    code: "D1001",
                    value: n,
                    stack: (new Error()).stack
                };
            }
        }
        return isNum;
    }

    /**
     * Returns true if the arg is an array of strings
     * @param {*} arg - the item to test
     * @returns {boolean} True if arg is an array of strings
     */
    function isArrayOfStrings(arg) {
        var result = false;
        /* istanbul ignore else */
        if(Array.isArray(arg)) {
            result = (arg.filter(function(item){return typeof item !== 'string';}).length === 0);
        }
        return result;
    }

    /**
     * Returns true if the arg is an array of numbers
     * @param {*} arg - the item to test
     * @returns {boolean} True if arg is an array of numbers
     */
    function isArrayOfNumbers(arg) {
        var result = false;
        if(Array.isArray(arg)) {
            result = (arg.filter(function(item){return !isNumeric(item);}).length === 0);
        }
        return result;
    }

    // Polyfill
    /* istanbul ignore next */
    Number.isInteger = Number.isInteger || function(value) {
        return typeof value === "number" &&
          isFinite(value) &&
          Math.floor(value) === value;
    };

    /**
     * Evaluate expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluate(expr, input, environment) {
        var result;

        var entryCallback = environment.lookup('__evaluate_entry');
        if(entryCallback) {
            entryCallback(expr, input, environment);
        }

        switch (expr.type) {
            case 'path':
                result = yield * evaluatePath(expr.steps, input, environment);
                result = normalizeSequence(result, expr.keepSingletonArray);
                break;
            case 'binary':
                result = yield * evaluateBinary(expr, input, environment);
                break;
            case 'unary':
                result = yield * evaluateUnary(expr, input, environment);
                break;
            case 'name':
                result = evaluateName(expr, input, environment);
                break;
            case 'literal':
                result = evaluateLiteral(expr, input, environment);
                break;
            case 'wildcard':
                result = evaluateWildcard(expr, input, environment);
                break;
            case 'descendant':
                result = evaluateDescendants(expr, input, environment);
                break;
            case 'condition':
                result = yield * evaluateCondition(expr, input, environment);
                break;
            case 'block':
                result = yield * evaluateBlock(expr, input, environment);
                break;
            case 'bind':
                result = yield * evaluateBindExpression(expr, input, environment);
                break;
            case 'regex':
                result = evaluateRegex(expr, input, environment);
                break;
            case 'function':
                result = yield * evaluateFunction(expr, input, environment);
                break;
            case 'variable':
                result = evaluateVariable(expr, input, environment);
                break;
            case 'lambda':
                result = evaluateLambda(expr, input, environment);
                break;
            case 'partial':
                result = yield * evaluatePartialApplication(expr, input, environment);
                break;
            case 'apply':
                result = yield * evaluateApplyExpression(expr, input, environment);
                break;
            case 'sort':
                result = yield * evaluateSortExpression(expr, input, environment);
                break;
            case 'transform':
                result = evaluateTransformExpression(expr, input, environment);
                break;
        }

        if(environment.lookup('__jsonata_async') &&
          (typeof result === 'undefined' || result === null || typeof result.then !== 'function')) {
            result = Promise.resolve(result);
        }
        if(environment.lookup('__jsonata_async') && typeof result.then === 'function' && expr.nextFunction && typeof result[expr.nextFunction] === 'function') {
            // although this is a 'thenable', it is chaining a different function
            // so don't yield since yielding will trigger the .then()
        } else {
            result = yield result;
        }


        if (expr.hasOwnProperty('predicate')) {
            result = yield * applyPredicates(expr.predicate, result, environment);
            result = normalizeSequence(result);

        }
        if (expr.hasOwnProperty('group')) {
            result = yield * evaluateGroupExpression(expr.group, result, environment);
        }

        var exitCallback = environment.lookup('__evaluate_exit');
        if(exitCallback) {
            exitCallback(expr, input, environment, result);
        }

        return result;
    }

    /**
     * Evaluate path expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluatePath(expr, input, environment) {
        var inputSequence;
        // expr is an array of steps
        // if the first step is a variable reference ($...), including root reference ($$),
        //   then the path is absolute rather than relative
        if (expr[0].type === 'variable') {
            inputSequence = [input]; // dummy singleton sequence for first (absolute) step
        } else if (Array.isArray(input)) {
            inputSequence = input;
        } else {
            // if input is not an array, make it so
            inputSequence = [input];
        }

        var resultSequence;

        // evaluate each step in turn
        for(var ii = 0; ii < expr.length; ii++) {
            var step = expr[ii];

            // if the first step is an explicit array constructor, then just evaluate that (i.e. don't iterate over a context array)
            if(ii === 0 && step.consarray) {
                resultSequence = yield * evaluate(step, inputSequence, environment);
            } else {
                resultSequence = yield * evaluateStep(step, inputSequence, environment);
            }

            if(typeof resultSequence === 'undefined' || resultSequence.length === 0) {
                break;
            }
            inputSequence = resultSequence;
        }

        return resultSequence;
    }

    /**
     * Normalize a JSONata sequence - singleton arrays become atomic values
     * @param {Array} sequence - input sequence
     * @param {Boolean} keepSingleton - keep singleton sequences as arrays
     * @returns {*} normalized sequence
     */
    function normalizeSequence(sequence, keepSingleton) {
        var result;
        if(typeof sequence === 'undefined') {
            result = undefined;
        } else if(!Array.isArray(sequence)) {
            result = sequence;
        } else if (sequence.length === 1) {
            if(keepSingleton) {
                result = sequence;
            } else {
                result = sequence[0];
            }
        } else if (sequence.length > 1) {
            result = sequence;
        }
        return result;
    }

    /**
     * Evaluate a step within a path
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateStep(expr, input, environment) {
        var result = [];


        for(var ii = 0; ii < input.length; ii++) {
            var res = yield * evaluate(expr, input[ii], environment);
            if (!(Array.isArray(res) && (expr.value !== '[' )) && !expr.consarray) {
                res = [res];
            }
            // is res an array - if so, flatten it into the parent array
            res.forEach(function (innerRes) {
                if (typeof innerRes !== 'undefined') {
                    result.push(innerRes);
                }
            });
        }
        return result;
    }

    /**
     * Apply predicates to input data
     * @param {Object} predicates - Predicates
     * @param {Object} input - Input data to apply predicates against
     * @param {Object} environment - Environment
     * @returns {*} Result after applying predicates
     */
    function* applyPredicates(predicates, input, environment) {
        var inputSequence = input;
        // lhs potentially holds an array
        // we want to iterate over the array, and only keep the items that are
        // truthy when applied to the predicate.
        // if the predicate evaluates to an integer, then select that index

        var results = [];
        for(var ii = 0; ii < predicates.length; ii++) {
            var predicate = predicates[ii];
            // if it's not an array, turn it into one
            // since in XPath >= 2.0 an item is equivalent to a singleton sequence of that item
            // if input is not an array, make it so
            if (!Array.isArray(inputSequence)) {
                inputSequence = [inputSequence];
            }
            results = [];
            if (predicate.type === 'literal' && isNumeric(predicate.value)) {
                var index = predicate.value;
                if (!Number.isInteger(index)) {
                    // round it down
                    index = Math.floor(index);
                }
                if (index < 0) {
                    // count in from end of array
                    index = inputSequence.length + index;
                }
                results = inputSequence[index];
            } else {
                results = yield * evaluateFilter(predicate, inputSequence, environment);
            }
            inputSequence = results;
        }
        return results;
    }

    /**
     * Apply filter predicate to input data
     * @param {Object} predicate - filter expression
     * @param {Object} input - Input data to apply predicates against
     * @param {Object} environment - Environment
     * @returns {*} Result after applying predicates
     */
    function* evaluateFilter(predicate, input, environment) {
        var results = [];
        for(var index = 0; index < input.length; index++) {
            var item = input[index];
            var res = yield * evaluate(predicate, item, environment);
            if (isNumeric(res)) {
                res = [res];
            }
            if(isArrayOfNumbers(res)) {
                res.forEach(function(ires) {
                    if (!Number.isInteger(ires)) {
                        // round it down
                        ires = Math.floor(ires);
                    }
                    if (ires < 0) {
                        // count in from end of array
                        ires = input.length + ires;
                    }
                    if (ires === index) {
                        results.push(item);
                    }
                });
            } else if (functionBoolean(res)) { // truthy
                results.push(item);
            }
        }
        return results;
    }

    /**
     * Evaluate binary expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function * evaluateBinary(expr, input, environment) {
        var result;
        var lhs = yield * evaluate(expr.lhs, input, environment);
        var rhs = yield * evaluate(expr.rhs, input, environment);
        var op = expr.value;

        try {
            switch (op) {
                case '+':
                case '-':
                case '*':
                case '/':
                case '%':
                    result = evaluateNumericExpression(lhs, rhs, op);
                    break;
                case '=':
                case '!=':
                case '<':
                case '<=':
                case '>':
                case '>=':
                    result = evaluateComparisonExpression(lhs, rhs, op);
                    break;
                case '&':
                    result = evaluateStringConcat(lhs, rhs);
                    break;
                case 'and':
                case 'or':
                    result = evaluateBooleanExpression(lhs, rhs, op);
                    break;
                case '..':
                    result = evaluateRangeExpression(lhs, rhs);
                    break;
                case 'in':
                    result = evaluateIncludesExpression(lhs, rhs);
                    break;
            }
        } catch(err) {
            err.position = expr.position;
            err.token = op;
            throw err;
        }
        return result;
    }

    /**
     * Evaluate unary expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateUnary(expr, input, environment) {
        var result;

        switch (expr.value) {
            case '-':
                result = yield * evaluate(expr.expression, input, environment);
                if (isNumeric(result)) {
                    result = -result;
                } else {
                    throw {
                        code: "D1002",
                        stack: (new Error()).stack,
                        position: expr.position,
                        token: expr.value,
                        value: result
                    };
                }
                break;
            case '[':
                // array constructor - evaluate each item
                result = [];
                for(var ii = 0; ii < expr.expressions.length; ii++) {
                    var item = expr.expressions[ii];
                    var value = yield * evaluate(item, input, environment);
                    if (typeof value !== 'undefined') {
                        if(item.value === '[') {
                            result.push(value);
                        } else {
                            result = functionAppend(result, value);
                        }
                    }
                }
                break;
            case '{':
                // object constructor - apply grouping
                result = yield * evaluateGroupExpression(expr, input, environment);
                break;

        }
        return result;
    }

    /**
     * Evaluate name object against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function evaluateName(expr, input, environment) {
        // lookup the 'name' item in the input
        var result;
        if (Array.isArray(input)) {
            result = [];
            for(var ii = 0; ii < input.length; ii++) {
                var res =  evaluateName(expr, input[ii], environment);
                if (typeof res !== 'undefined') {
                    result.push(res);
                }
            }
        } else if (input !== null && typeof input === 'object') {
            result = input[expr.value];
        }
        result = normalizeSequence(result);
        return result;
    }

    /**
     * Evaluate literal against input data
     * @param {Object} expr - JSONata expression
     * @returns {*} Evaluated input data
     */
    function evaluateLiteral(expr) {
        return expr.value;
    }

    /**
     * Evaluate wildcard against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @returns {*} Evaluated input data
     */
    function evaluateWildcard(expr, input) {
        var result;
        var results = [];
        if (input !== null && typeof input === 'object') {
            Object.keys(input).forEach(function (key) {
                var value = input[key];
                if(Array.isArray(value)) {
                    value = flatten(value);
                    results = functionAppend(results, value);
                } else {
                    results.push(value);
                }
            });
        }

        result = normalizeSequence(results);
        return result;
    }

    /**
     * Returns a flattened array
     * @param {Array} arg - the array to be flatten
     * @param {Array} flattened - carries the flattened array - if not defined, will initialize to []
     * @returns {Array} - the flattened array
     */
    function flatten(arg, flattened) {
        if(typeof flattened === 'undefined') {
            flattened = [];
        }
        if(Array.isArray(arg)) {
            arg.forEach(function (item) {
                flatten(item, flattened);
            });
        } else {
            flattened.push(arg);
        }
        return flattened;
    }

    /**
     * Evaluate descendants against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @returns {*} Evaluated input data
     */
    function evaluateDescendants(expr, input) {
        var result;
        var resultSequence = [];
        if (typeof input !== 'undefined') {
            // traverse all descendants of this object/array
            recurseDescendants(input, resultSequence);
            if (resultSequence.length === 1) {
                result = resultSequence[0];
            } else {
                result = resultSequence;
            }
        }
        return result;
    }

    /**
     * Recurse through descendants
     * @param {Object} input - Input data
     * @param {Object} results - Results
     */
    function recurseDescendants(input, results) {
        // this is the equivalent of //* in XPath
        if (!Array.isArray(input)) {
            results.push(input);
        }
        if (Array.isArray(input)) {
            input.forEach(function (member) {
                recurseDescendants(member, results);
            });
        } else if (input !== null && typeof input === 'object') {
            Object.keys(input).forEach(function (key) {
                recurseDescendants(input[key], results);
            });
        }
    }

    /**
     * Evaluate numeric expression against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @param {Object} op - opcode
     * @returns {*} Result
     */
    function evaluateNumericExpression(lhs, rhs, op) {
        var result;

        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {
            // if either side is undefined, the result is undefined
            return result;
        }

        if (!isNumeric(lhs)) {
            throw {
                code: "T2001",
                stack: (new Error()).stack,
                value: lhs
            };
        }
        if (!isNumeric(rhs)) {
            throw {
                code: "T2002",
                stack: (new Error()).stack,
                value: rhs
            };
        }

        switch (op) {
            case '+':
                result = lhs + rhs;
                break;
            case '-':
                result = lhs - rhs;
                break;
            case '*':
                result = lhs * rhs;
                break;
            case '/':
                result = lhs / rhs;
                break;
            case '%':
                result = lhs % rhs;
                break;
        }
        return result;
    }

    /**
     * Evaluate comparison expression against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @param {Object} op - opcode
     * @returns {*} Result
     */
    function evaluateComparisonExpression(lhs, rhs, op) {
        var result;

        // type checks
        var ltype = typeof lhs;
        var rtype = typeof rhs;

        if (ltype === 'undefined' || rtype === 'undefined') {
            // if either side is undefined, the result is false
            return false;
        }

        var validate = function() {
            // if aa or bb are not string or numeric values, then throw an error
            if (!(ltype === 'string' || ltype === 'number') || !(rtype === 'string' || rtype === 'number')) {
                throw {
                    code: "T2010",
                    stack: (new Error()).stack,
                    value: !(ltype === 'string' || ltype === 'number') ? lhs : rhs
                };
            }

            //if aa and bb are not of the same type
            if (ltype !== rtype) {
                throw {
                    code: "T2009",
                    stack: (new Error()).stack,
                    value: lhs,
                    value2: rhs
                };
            }
        };

        switch (op) {
            case '=':
                result = lhs === rhs;
                break;
            case '!=':
                result = (lhs !== rhs);
                break;
            case '<':
                validate();
                result = lhs < rhs;
                break;
            case '<=':
                validate();
                result = lhs <= rhs;
                break;
            case '>':
                validate();
                result = lhs > rhs;
                break;
            case '>=':
                validate();
                result = lhs >= rhs;
                break;
        }
        return result;
    }

    /**
     * Inclusion operator - in
     *
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @returns {boolean} - true if lhs is a member of rhs
     */
    function evaluateIncludesExpression(lhs, rhs) {
        var result = false;

        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {
            // if either side is undefined, the result is false
            return false;
        }

        if(!Array.isArray(rhs)) {
            rhs = [rhs];
        }

        for(var i = 0; i < rhs.length; i++) {
            if(rhs[i] === lhs) {
                result = true;
                break;
            }
        }

        return result;
    }

    /**
     * Evaluate boolean expression against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @param {Object} op - opcode
     * @returns {*} Result
     */
    function evaluateBooleanExpression(lhs, rhs, op) {
        var result;

        switch (op) {
            case 'and':
                result = functionBoolean(lhs) && functionBoolean(rhs);
                break;
            case 'or':
                result = functionBoolean(lhs) || functionBoolean(rhs);
                break;
        }
        return result;
    }

    /**
     * Evaluate string concatenation against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @returns {string|*} Concatenated string
     */
    function evaluateStringConcat(lhs, rhs) {
        var result;

        var lstr = '';
        var rstr = '';
        if (typeof lhs !== 'undefined') {
            lstr = functionString(lhs);
        }
        if (typeof rhs !== 'undefined') {
            rstr = functionString(rhs);
        }

        result = lstr.concat(rstr);
        return result;
    }

    /**
     * Evaluate group expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {{}} Evaluated input data
     */
    function* evaluateGroupExpression(expr, input, environment) {
        var result = {};
        var groups = {};
        // group the input sequence by 'key' expression
        if (!Array.isArray(input)) {
            input = [input];
        }
        for(var itemIndex = 0; itemIndex < input.length; itemIndex++) {
            var item = input[itemIndex];
            for(var pairIndex = 0; pairIndex < expr.lhs.length; pairIndex++) {
                var pair = expr.lhs[pairIndex];
                var key = yield * evaluate(pair[0], item, environment);
                // key has to be a string
                if (typeof  key !== 'string') {
                    throw {
                        code: "T1003",
                        stack: (new Error()).stack,
                        position: expr.position,
                        value: key
                    };
                }
                var entry = {data: item, expr: pair[1]};
                if (groups.hasOwnProperty(key)) {
                    // a value already exists in this slot
                    // append it as an array
                    groups[key].data = functionAppend(groups[key].data, item);
                } else {
                    groups[key] = entry;
                }
            }
        }

        // iterate over the groups to evaluate the 'value' expression
        for (key in groups) {
            entry = groups[key];
            var value = yield * evaluate(entry.expr, entry.data, environment);
            if(typeof value !== 'undefined') {
                result[key] = value;
            }
        }

        return result;
    }

    /**
     * Evaluate range expression against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @returns {Array} Resultant array
     */
    function evaluateRangeExpression(lhs, rhs) {
        var result;

        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {
            // if either side is undefined, the result is undefined
            return result;
        }

        if (lhs > rhs) {
            // if the lhs is greater than the rhs, return undefined
            return result;
        }

        if (!Number.isInteger(lhs)) {
            throw {
                code: "T2003",
                stack: (new Error()).stack,
                value: lhs
            };
        }
        if (!Number.isInteger(rhs)) {
            throw {
                code: "T2004",
                stack: (new Error()).stack,
                value: rhs
            };
        }

        result = new Array(rhs - lhs + 1);
        for (var item = lhs, index = 0; item <= rhs; item++, index++) {
            result[index] = item;
        }
        return result;
    }

    /**
     * Evaluate bind expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateBindExpression(expr, input, environment) {
        // The RHS is the expression to evaluate
        // The LHS is the name of the variable to bind to - should be a VARIABLE token
        var value = yield * evaluate(expr.rhs, input, environment);
        if (expr.lhs.type !== 'variable') {
            throw {
                code: "D2005",
                stack: (new Error()).stack,
                position: expr.position,
                token: expr.value,
                value: expr.lhs.type === 'path' ? expr.lhs.steps[0].value : expr.lhs.value
            };
        }
        environment.bind(expr.lhs.value, value);
        return value;
    }

    /**
     * Evaluate condition against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateCondition(expr, input, environment) {
        var result;
        var condition = yield * evaluate(expr.condition, input, environment);
        if (functionBoolean(condition)) {
            result = yield * evaluate(expr.then, input, environment);
        } else if (typeof expr.else !== 'undefined') {
            result = yield * evaluate(expr.else, input, environment);
        }
        return result;
    }

    /**
     * Evaluate block against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateBlock(expr, input, environment) {
        var result;
        // create a new frame to limit the scope of variable assignments
        // TODO, only do this if the post-parse stage has flagged this as required
        var frame = createFrame(environment);
        // invoke each expression in turn
        // only return the result of the last one
        for(var ii = 0; ii < expr.expressions.length; ii++) {
            result = yield * evaluate(expr.expressions[ii], input, frame);
        }

        return result;
    }

    /**
     * Prepare a regex
     * @param {Object} expr - expression containing regex
     * @returns {Function} Higher order function representing prepared regex
     */
    function evaluateRegex(expr) {
        expr.value.lastIndex = 0;
        var closure = function(str) {
            var re = expr.value;
            var result;
            var match = re.exec(str);
            if(match !== null) {
                result = {
                    match: match[0],
                    start: match.index,
                    end: match.index + match[0].length,
                    groups: []
                };
                if(match.length > 1) {
                    for(var i = 1; i < match.length; i++) {
                        result.groups.push(match[i]);
                    }
                }
                result.next = function() {
                    if(re.lastIndex >= str.length) {
                        return undefined;
                    } else {
                        var next = closure(str);
                        if(next && next.match === '' && re.lastIndex === expr.value.lastIndex) {
                            // matches zero length string; this will never progress
                            throw {
                                code: "D1004",
                                stack: (new Error()).stack,
                                position: expr.position,
                                value: expr.value.source
                            };
                        }
                        return next;
                    }
                };
            }

            return result;
        };
        return closure;
    }

    /**
     * Evaluate variable against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function evaluateVariable(expr, input, environment) {
        // lookup the variable value in the environment
        var result;
        // if the variable name is empty string, then it refers to context value
        if (expr.value === '') {
            result = input;
        } else {
            result = environment.lookup(expr.value);
        }
        return result;
    }

    /**
     * sort / order-by operator
     * @param {Object} expr - AST for operator
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Ordered sequence
     */
    function* evaluateSortExpression(expr, input, environment) {
        var result;

        // evaluate the lhs, then sort the results in order according to rhs expression
        var lhs = yield * evaluate(expr.lhs, input, environment);

        // sort the lhs array
        // use comparator function
        var comparator = function(a, b) {
            // expr.rhs is an array of order-by in priority order
            var comp = 0;
            for(var index = 0; comp === 0 && index < expr.rhs.length; index++) {
                var term = expr.rhs[index];
                //evaluate the rhs expression in the context of a
                var aa = driveGenerator(term.expression, a, environment);
                //evaluate the rhs expression in the context of b
                var bb = driveGenerator(term.expression, b, environment);

                // type checks
                var atype = typeof aa;
                var btype = typeof bb;
                // undefined should be last in sort order
                if(atype === 'undefined') {
                    // swap them, unless btype is also undefined
                    comp = (btype === 'undefined') ? 0 : 1;
                    continue;
                }
                if(btype === 'undefined') {
                    comp = -1;
                    continue;
                }

                // if aa or bb are not string or numeric values, then throw an error
                if(!(atype === 'string' || atype === 'number') || !(btype === 'string' || btype === 'number')) {
                    throw {
                        code: "T2008",
                        stack: (new Error()).stack,
                        position: expr.position,
                        value: !(atype === 'string' || atype === 'number') ? aa : bb
                    };
                }

                //if aa and bb are not of the same type
                if(atype !== btype) {
                    throw {
                        code: "T2007",
                        stack: (new Error()).stack,
                        position: expr.position,
                        value: aa,
                        value2: bb
                    };
                }
                if(aa === bb) {
                    // both the same - move on to next term
                    continue;
                } else if (aa < bb) {
                    comp = -1;
                } else {
                    comp = 1;
                }
                if(term.descending === true) {
                    comp = -comp;
                }
            }
            // only swap a & b if comp equals 1
            return comp === 1;
        };

        result = functionSort(lhs, comparator);

        return result;
    }

    /**
     * create a transformer function
     * @param {Object} expr - AST for operator
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} tranformer function
     */
    function evaluateTransformExpression(expr, input, environment) {
        // create a function to implement the transform definition
        var transformer = function*(obj) { // signature <(oa):o>
            // undefined inputs always return undefined
            if(typeof obj === 'undefined') {
                return undefined;
            }

            // this function returns a copy of obj with changes specified by the pattern/operation
            var cloneFunction = environment.lookup('clone');
            if(!isFunction(cloneFunction)) {
                // throw type error
                throw {
                    code: "T2013",
                    stack: (new Error()).stack,
                    position: expr.position
                };
            }
            var result = yield * apply(cloneFunction, [obj], environment);
            var matches = yield * evaluate(expr.pattern, result, environment);
            if(typeof matches !== 'undefined') {
                if(!Array.isArray(matches)) {
                    matches = [matches];
                }
                for(var ii = 0; ii < matches.length; ii++) {
                    var match = matches[ii];
                    // evaluate the update value for each match
                    var update = yield * evaluate(expr.update, match, environment);
                    // update must be an object
                    var updateType = typeof update;
                    if(updateType !== 'undefined') {
                        if(updateType !== 'object' || update === null) {
                            // throw type error
                            throw {
                                code: "T2011",
                                stack: (new Error()).stack,
                                position: expr.update.position,
                                value: update
                            };
                        }
                        // merge the update
                        for(var prop in update) {
                            match[prop] = update[prop];
                        }
                    }

                    // delete, if specified, must be an array of strings (or single string)
                    if(typeof expr.delete !== 'undefined') {
                        var deletions = yield * evaluate(expr.delete, match, environment);
                        if(typeof deletions !== 'undefined') {
                            var val = deletions;
                            if (!Array.isArray(deletions)) {
                                deletions = [deletions];
                            }
                            if (!isArrayOfStrings(deletions)) {
                                // throw type error
                                throw {
                                    code: "T2012",
                                    stack: (new Error()).stack,
                                    position: expr.delete.position,
                                    value: val
                                };
                            }
                            for (var jj = 0; jj < deletions.length; jj++) {
                                delete match[deletions[jj]];
                            }
                        }
                    }
                }
            }

            return result;
        };

        return defineFunction(transformer, '<(oa):o>');
    }

    /**
     * Evaluate an expression by driving the generator to completion
     * Used when it's not possible to yield
     * @param {Object} expr - AST
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} result
     */
    function driveGenerator(expr, input, environment) {
        var gen = evaluate(expr, input, environment);
        // returns a generator - so iterate over it
        var comp = gen.next();
        while (!comp.done) {
            comp = gen.next(comp.value);
        }
        return comp.value;
    }

    var chain = driveGenerator(parser('function($f, $g) { function($x){ $g($f($x)) } }'), null, staticFrame);

    /**
     * Apply the function on the RHS using the sequence on the LHS as the first argument
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateApplyExpression(expr, input, environment) {
        var result;


        if(expr.rhs.type === 'function') {
            // this is a function _invocation_; invoke it with lhs expression as the first argument
            expr.rhs.arguments.unshift(expr.lhs);
            result = yield * evaluateFunction(expr.rhs, input, environment);
            expr.rhs.arguments.shift();
        } else {
            var lhs = yield * evaluate(expr.lhs, input, environment);
            var func = yield * evaluate(expr.rhs, input, environment);

            if(!isFunction(func)) {
                throw {
                    code: "T2006",
                    stack: (new Error()).stack,
                    position: expr.position,
                    value: func
                };
            }

            if(isFunction(lhs)) {
                // this is function chaining (func1 ~> func2)
                // λ($f, $g) { λ($x){ $g($f($x)) } }
                result = yield * apply(chain, [lhs, func], environment, null);
            } else {
                result = yield * apply(func, [lhs], environment, null);
            }

        }

        return result;
    }

    /**
     *
     * @param {Object} arg - expression to test
     * @returns {boolean} - true if it is a function (lambda or built-in)
     */
    function isFunction(arg) {
        return ((arg && (arg._jsonata_function === true || arg._jsonata_lambda === true)) || typeof arg === 'function');
    }

    /**
     * Tests whether arg is a lambda function
     * @param {*} arg - the value to test
     * @returns {boolean} - true if it is a lambda function
     */
    function isLambda(arg) {
        return arg && arg._jsonata_lambda === true;
    }

    /**
     * @param {Object} arg - expression to test
     * @returns {boolean} - true if it is a generator i.e. the result from calling a
     * generator function
     */
    function isGenerator(arg) {
        return (
            typeof arg === 'object' &&
            arg !== null &&
            Symbol.iterator in arg &&
            typeof arg[Symbol.iterator] === 'function' &&
            'next' in arg &&
            typeof arg.next === 'function'
        );
    }

    /**
     * Evaluate function against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @param {Object} [applyto] - LHS of ~> operator
     * @returns {*} Evaluated input data
     */
    function* evaluateFunction(expr, input, environment) {
        var result;

        // create the procedure
        // can't assume that expr.procedure is a lambda type directly
        // could be an expression that evaluates to a function (e.g. variable reference, parens expr etc.
        // evaluate it generically first, then check that it is a function.  Throw error if not.
        var proc = yield * evaluate(expr.procedure, input, environment);

        if (typeof proc === 'undefined' && expr.procedure.type === 'path' && environment.lookup(expr.procedure.steps[0].value)) {
            // help the user out here if they simply forgot the leading $
            throw {
                code: "T1005",
                stack: (new Error()).stack,
                position: expr.position,
                token: expr.procedure.steps[0].value
            };
        }

        var evaluatedArgs = [];
        // eager evaluation - evaluate the arguments
        for (var jj = 0; jj < expr.arguments.length; jj++) {
            // only evaluate 'eager' arguments at this stage; wrap the 'lazy' ones in a closure
            evaluatedArgs.push(yield* evaluate(expr.arguments[jj], input, environment));
        }
        // apply the procedure
        try {
            // if(input instanceof Object) {
            //     Object.defineProperty(input, '__env__', {
            //         enumerable: false,
            //         configurable: true,
            //         get: function () {
            //             return environment;
            //         }
            //     });
            // }
            result = yield * apply(proc, evaluatedArgs, input);
        } catch (err) {
            // add the position field to the error
            err.position = expr.position;
            // and the function identifier
            err.token = expr.procedure.type === 'path' ? expr.procedure.steps[0].value : expr.procedure.value;
            throw err;
        }
        return result;
    }

    /**
     * Apply procedure or function
     * @param {Object} proc - Procedure
     * @param {Array} args - Arguments
     * @param {Object} self - Self
     * @returns {*} Result of procedure
     */
    function* apply(proc, args, self) {
        var result;
        result = yield * applyInner(proc, args, self);
        while(isLambda(result) && result.thunk === true) {
            // trampoline loop - this gets invoked as a result of tail-call optimization
            // the function returned a tail-call thunk
            // unpack it, evaluate its arguments, and apply the tail call
            var next = yield * evaluate(result.body.procedure, result.input, result.environment);
            var evaluatedArgs = [];
            for(var ii = 0; ii < result.body.arguments.length; ii++) {
                evaluatedArgs.push(yield * evaluate(result.body.arguments[ii], result.input, result.environment));
            }

            result = yield * applyInner(next, evaluatedArgs, self);
        }
        return result;
    }

    /**
     * Apply procedure or function
     * @param {Object} proc - Procedure
     * @param {Array} args - Arguments
     * @param {Object} self - Self
     * @returns {*} Result of procedure
     */
    function* applyInner(proc, args, self) {
        var result;
        var validatedArgs = args;
        if(proc) {
            validatedArgs = validateArguments(proc.signature, args, self);
        }
        if (isLambda(proc)) {
            result = yield * applyProcedure(proc, validatedArgs);
        } else if (proc && proc._jsonata_function === true) {
            result = proc.implementation.apply(self, validatedArgs);
            // `proc.implementation` might be a generator function
            // and `result` might be a generator - if so, yield
            if(isGenerator(result)) {
                result = yield *result;
            }
        } else if (typeof proc === 'function') {
            result = proc.apply(self, validatedArgs);
            /* istanbul ignore next */
            if(isGenerator(result)) {
                result = yield *result;
            }
        } else {
            throw {
                code: "T1006",
                stack: (new Error()).stack
            };
        }
        return result;
    }

    /**
     * Evaluate lambda against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {{lambda: boolean, input: *, environment: *, arguments: *, body: *}} Evaluated input data
     */
    function evaluateLambda(expr, input, environment) {
        // make a function (closure)
        var procedure = {
            _jsonata_lambda: true,
            input: input,
            environment: environment,
            arguments: expr.arguments,
            signature: expr.signature,
            body: expr.body
        };
        if(expr.thunk === true) {
            procedure.thunk = true;
        }
        return procedure;
    }

    /**
     * Evaluate partial application
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluatePartialApplication(expr, input, environment) {
        // partially apply a function
        var result;
        // evaluate the arguments
        var evaluatedArgs = [];
        for(var ii = 0; ii < expr.arguments.length; ii++) {
            var arg = expr.arguments[ii];
            if (arg.type === 'operator' && arg.value === '?') {
                evaluatedArgs.push(arg);
            } else {
                evaluatedArgs.push(yield * evaluate(arg, input, environment));
            }
        }
        // lookup the procedure
        var proc = yield * evaluate(expr.procedure, input, environment);
        if (typeof proc === 'undefined' && expr.procedure.type === 'path' && environment.lookup(expr.procedure.steps[0].value)) {
            // help the user out here if they simply forgot the leading $
            throw {
                code: "T1007",
                stack: (new Error()).stack,
                position: expr.position,
                token: expr.procedure.steps[0].value
            };
        }
        if (isLambda(proc)) {
            result = partialApplyProcedure(proc, evaluatedArgs);
        } else if (proc && proc._jsonata_function === true) {
            result = partialApplyNativeFunction(proc.implementation, evaluatedArgs);
        } else if (typeof proc === 'function') {
            result = partialApplyNativeFunction(proc, evaluatedArgs);
        } else {
            throw {
                code: "T1008",
                stack: (new Error()).stack,
                position: expr.position,
                token: expr.procedure.type === 'path' ? expr.procedure.steps[0].value : expr.procedure.value
            };
        }
        return result;
    }

    /**
     * Validate the arguments against the signature validator (if it exists)
     * @param {Function} signature - validator function
     * @param {Array} args - function arguments
     * @param {*} context - context value
     * @returns {Array} - validated arguments
     */
    function validateArguments(signature, args, context) {
        if(typeof signature === 'undefined') {
            // nothing to validate
            return args;
        }
        var validatedArgs = signature.validate(args, context);
        return validatedArgs;
    }

    /**
     * Apply procedure
     * @param {Object} proc - Procedure
     * @param {Array} args - Arguments
     * @returns {*} Result of procedure
     */
    function* applyProcedure(proc, args) {
        var result;
        var env = createFrame(proc.environment);
        proc.arguments.forEach(function (param, index) {
            env.bind(param.value, args[index]);
        });
        if (typeof proc.body === 'function') {
            // this is a lambda that wraps a native function - generated by partially evaluating a native
            result = yield * applyNativeFunction(proc.body, env);
        } else {
            result = yield * evaluate(proc.body, proc.input, env);
        }
        return result;
    }

    /**
     * Partially apply procedure
     * @param {Object} proc - Procedure
     * @param {Array} args - Arguments
     * @returns {{lambda: boolean, input: *, environment: {bind, lookup}, arguments: Array, body: *}} Result of partially applied procedure
     */
    function partialApplyProcedure(proc, args) {
        // create a closure, bind the supplied parameters and return a function that takes the remaining (?) parameters
        var env = createFrame(proc.environment);
        var unboundArgs = [];
        proc.arguments.forEach(function (param, index) {
            var arg = args[index];
            if (arg && arg.type === 'operator' && arg.value === '?') {
                unboundArgs.push(param);
            } else {
                env.bind(param.value, arg);
            }
        });
        var procedure = {
            _jsonata_lambda: true,
            input: proc.input,
            environment: env,
            arguments: unboundArgs,
            body: proc.body
        };
        return procedure;
    }

    /**
     * Partially apply native function
     * @param {Function} native - Native function
     * @param {Array} args - Arguments
     * @returns {{lambda: boolean, input: *, environment: {bind, lookup}, arguments: Array, body: *}} Result of partially applying native function
     */
    function partialApplyNativeFunction(native, args) {
        // create a lambda function that wraps and invokes the native function
        // get the list of declared arguments from the native function
        // this has to be picked out from the toString() value
        var sigArgs = getNativeFunctionArguments(native);
        sigArgs = sigArgs.map(function (sigArg) {
            return '$' + sigArg.trim();
        });
        var body = 'function(' + sigArgs.join(', ') + '){ _ }';

        var bodyAST = parser(body);
        bodyAST.body = native;

        var partial = partialApplyProcedure(bodyAST, args);
        return partial;
    }

    /**
     * Apply native function
     * @param {Object} proc - Procedure
     * @param {Object} env - Environment
     * @returns {*} Result of applying native function
     */
    function* applyNativeFunction(proc, env) {
        var sigArgs = getNativeFunctionArguments(proc);
        // generate the array of arguments for invoking the function - look them up in the environment
        var args = sigArgs.map(function (sigArg) {
            return env.lookup(sigArg.trim());
        });

        var result = proc.apply(null, args);
        if(isGenerator(result)) {
            result = yield * result;
        }
        return result;
    }

    /**
     * Get native function arguments
     * @param {Function} func - Function
     * @returns {*|Array} Native function arguments
     */
    function getNativeFunctionArguments(func) {
        var signature = func.toString();
        var sigParens = /\(([^)]*)\)/.exec(signature)[1]; // the contents of the parens
        var sigArgs = sigParens.split(',');
        return sigArgs;
    }

    /**
     * Creates a function definition
     * @param {Function} func - function implementation in Javascript
     * @param {string} signature - JSONata function signature definition
     * @returns {{implementation: *, signature: *}} function definition
     */
    function defineFunction(func, signature) {
        var definition = {
            _jsonata_function: true,
            implementation: func
        };
        if(typeof signature !== 'undefined') {
            definition.signature = parseSignature(signature);
        }
        return definition;
    }

    /**
     * Sum function
     * @param {Object} args - Arguments
     * @returns {number} Total value of arguments
     */
    function functionSum(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined') {
            return undefined;
        }

        var total = 0;
        args.forEach(function(num){total += num;});
        return total;
    }

    /**
     * Count function
     * @param {Object} args - Arguments
     * @returns {number} Number of elements in the array
     */
    function functionCount(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined') {
            return 0;
        }

        return args.length;
    }

    /**
     * Max function
     * @param {Object} args - Arguments
     * @returns {number} Max element in the array
     */
    function functionMax(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined' || args.length === 0) {
            return undefined;
        }

        return Math.max.apply(Math, args);
    }

    /**
     * Min function
     * @param {Object} args - Arguments
     * @returns {number} Min element in the array
     */
    function functionMin(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined' || args.length === 0) {
            return undefined;
        }

        return Math.min.apply(Math, args);
    }

    /**
     * Average function
     * @param {Object} args - Arguments
     * @returns {number} Average element in the array
     */
    function functionAverage(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined' || args.length === 0) {
            return undefined;
        }

        var total = 0;
        args.forEach(function(num){total += num;});
        return total/args.length;
    }

    /**
     * Stingify arguments
     * @param {Object} arg - Arguments
     * @returns {String} String from arguments
     */
    function functionString(arg) {
        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        var str;

        if (typeof arg === 'string') {
            // already a string
            str = arg;
        } else if(isFunction(arg)) {
            // functions (built-in and lambda convert to empty string
            str = '';
        } else if (typeof arg === 'number' && !isFinite(arg)) {
            throw {
                code: "D3001",
                value: arg,
                stack: (new Error()).stack
            };
        } else
            str = JSON.stringify(arg, function (key, val) {
                return (typeof val !== 'undefined' && val !== null && val.toPrecision && isNumeric(val)) ? Number(val.toPrecision(13)) :
                    (val && isFunction(val)) ? '' : val;
            });
        return str;
    }

    /**
     * Create substring based on character number and length
     * @param {String} str - String to evaluate
     * @param {Integer} start - Character number to start substring
     * @param {Integer} [length] - Number of characters in substring
     * @returns {string|*} Substring
     */
    function functionSubstring(str, start, length) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        return str.substr(start, length);
    }

    /**
     * Create substring up until a character
     * @param {String} str - String to evaluate
     * @param {String} chars - Character to define substring boundary
     * @returns {*} Substring
     */
    function functionSubstringBefore(str, chars) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        var pos = str.indexOf(chars);
        if (pos > -1) {
            return str.substr(0, pos);
        } else {
            return str;
        }
    }

    /**
     * Create substring after a character
     * @param {String} str - String to evaluate
     * @param {String} chars - Character to define substring boundary
     * @returns {*} Substring
     */
    function functionSubstringAfter(str, chars) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        var pos = str.indexOf(chars);
        if (pos > -1) {
            return str.substr(pos + chars.length);
        } else {
            return str;
        }
    }

    /**
     * Lowercase a string
     * @param {String} str - String to evaluate
     * @returns {string} Lowercase string
     */
    function functionLowercase(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        return str.toLowerCase();
    }

    /**
     * Uppercase a string
     * @param {String} str - String to evaluate
     * @returns {string} Uppercase string
     */
    function functionUppercase(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        return str.toUpperCase();
    }

    /**
     * length of a string
     * @param {String} str - string
     * @returns {Number} The number of characters in the string
     */
    function functionLength(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        return str.length;
    }

    /**
     * Normalize and trim whitespace within a string
     * @param {string} str - string to be trimmed
     * @returns {string} - trimmed string
     */
    function functionTrim(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        // normalize whitespace
        var result = str.replace(/[ \t\n\r]+/gm, ' ');
        if(result.charAt(0) === ' ') {
            // strip leading space
            result = result.substring(1);
        }
        if(result.charAt(result.length - 1) === ' ') {
            // strip trailing space
            result = result.substring(0, result.length - 1);
        }
        return result;
    }

    /**
     * Pad a string to a minimum width by adding characters to the start or end
     * @param {string} str - string to be padded
     * @param {number} width - the minimum width; +ve pads to the right, -ve pads to the left
     * @param {string} [char] - the pad character(s); defaults to ' '
     * @returns {string} - padded string
     */
    function functionPad(str, width, char) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        if(typeof char === 'undefined' || char.length === 0) {
            char = ' ';
        }

        var result;
        var padLength = Math.abs(width) - str.length;
        if(padLength > 0) {
            var padding = (new Array(padLength + 1)).join(char);
            if(char.length > 1) {
                padding = padding.substring(0, padLength);
            }
            if(width > 0) {
                result = str + padding;
            } else {
                result = padding + str;
            }
        } else {
            result = str;
        }
        return result;
    }

    /**
     * Tests if the str contains the token
     * @param {String} str - string to test
     * @param {String} token - substring or regex to find
     * @returns {Boolean} - true if str contains token
     */
    function functionContains(str, token) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        var result;

        if(typeof token === 'string') {
            result = (str.indexOf(token) !== -1);
        } else {
            var matches = token(str);
            result = (typeof matches !== 'undefined');
        }

        return result;
    }

    /**
     * Match a string with a regex returning an array of object containing details of each match
     * @param {String} str - string
     * @param {String} regex - the regex applied to the string
     * @param {Integer} [limit] - max number of matches to return
     * @returns {Array} The array of match objects
     */
    function functionMatch(str, regex, limit) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        // limit, if specified, must be a non-negative number
        if(limit < 0) {
            throw {
                stack: (new Error()).stack,
                value: limit,
                code: 'D3040',
                index: 3
            };
        }

        var result = [];

        if(typeof limit === 'undefined' || limit > 0) {
            var count = 0;
            var matches = regex(str);
            if (typeof matches !== 'undefined') {
                while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {
                    result.push({
                        match: matches.match,
                        index: matches.start,
                        groups: matches.groups
                    });
                    matches = matches.next();
                    count++;
                }
            }
        }

        return result;
    }

    /**
     * Match a string with a regex returning an array of object containing details of each match
     * @param {String} str - string
     * @param {String} pattern - the substring/regex applied to the string
     * @param {String} replacement - text to replace the matched substrings
     * @param {Integer} [limit] - max number of matches to return
     * @returns {Array} The array of match objects
     */
    function* functionReplace(str, pattern, replacement, limit) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        // pattern cannot be an empty string
        if(pattern === '') {
            throw {
                code: "D3010",
                stack: (new Error()).stack,
                value: pattern,
                index: 2
            };
        }

        // limit, if specified, must be a non-negative number
        if(limit < 0) {
            throw {
                code: "D3011",
                stack: (new Error()).stack,
                value: limit,
                index: 4
            };
        }

        var replacer;
        if(typeof replacement === 'string') {
            replacer = function (regexMatch) {
                var substitute = '';
                // scan forward, copying the replacement text into the substitute string
                // and replace any occurrence of $n with the values matched by the regex
                var position = 0;
                var index = replacement.indexOf('$', position);
                while (index !== -1 && position < replacement.length) {
                    substitute += replacement.substring(position, index);
                    position = index + 1;
                    var dollarVal = replacement.charAt(position);
                    if (dollarVal === '$') {
                        // literal $
                        substitute += '$';
                        position++;
                    } else if (dollarVal === '0') {
                        substitute += regexMatch.match;
                        position++;
                    } else {
                        var maxDigits;
                        if(regexMatch.groups.length === 0) {
                            // no sub-matches; any $ followed by a digit will be replaced by an empty string
                            maxDigits = 1;
                        } else {
                            // max number of digits to parse following the $
                            maxDigits = Math.floor(Math.log(regexMatch.groups.length) * Math.LOG10E) + 1;
                        }
                        index = parseInt(replacement.substring(position, position + maxDigits), 10);
                        if(maxDigits > 1 && index > regexMatch.groups.length) {
                            index = parseInt(replacement.substring(position, position + maxDigits - 1), 10);
                        }
                        if (!isNaN(index)) {
                            if(regexMatch.groups.length > 0 ) {
                                var submatch = regexMatch.groups[index - 1];
                                if (typeof submatch !== 'undefined') {
                                    substitute += submatch;
                                }
                            }
                            position += index.toString().length;
                        } else {
                            // not a capture group, treat the $ as literal
                            substitute += '$';
                        }
                    }
                    index = replacement.indexOf('$', position);
                }
                substitute += replacement.substring(position);
                return substitute;
            };
        } else {
            replacer = replacement;
        }

        var result = '';
        var position = 0;

        if(typeof limit === 'undefined' || limit > 0) {
            var count = 0;
            if(typeof pattern === 'string') {
                var index = str.indexOf(pattern, position);
                while(index !== -1 && (typeof limit === 'undefined' || count < limit)) {
                    result += str.substring(position, index);
                    result += replacement;
                    position = index + pattern.length;
                    count++;
                    index = str.indexOf(pattern, position);
                }
                result += str.substring(position);
            } else {
                var matches = pattern(str);
                if (typeof matches !== 'undefined') {
                    while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {
                        result += str.substring(position, matches.start);
                        var replacedWith = yield * apply(replacer, [matches], null);
                        // check replacedWith is a string
                        if(typeof replacedWith === 'string') {
                            result += replacedWith;
                        } else {
                            // not a string - throw error
                            throw {
                                code: "D3012",
                                stack: (new Error()).stack,
                                value: replacedWith
                            };
                        }
                        position = matches.start + matches.match.length;
                        count++;
                        matches = matches.next();
                    }
                    result += str.substring(position);
                } else {
                    result = str;
                }
            }
        } else {
            result = str;
        }

        return result;
    }

    /**
     * Base64 encode a string
     * @param {String} str - string
     * @returns {String} Base 64 encoding of the binary data
     */
    function functionBase64encode(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }
        // Use btoa in a browser, or Buffer in Node.js

        var btoa = typeof window !== 'undefined' ?
            /* istanbul ignore next */ window.btoa :
            function(str) {
                // Simply doing `new Buffer` at this point causes Browserify to pull
                // in the entire Buffer browser library, which is large and unnecessary.
                // Using `global.Buffer` defeats this.
                return new global.Buffer(str, 'binary').toString('base64');
            };
        return btoa(str);
    }

    /**
     * Base64 decode a string
     * @param {String} str - string
     * @returns {String} Base 64 encoding of the binary data
     */
    function functionBase64decode(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }
        // Use btoa in a browser, or Buffer in Node.js
        var atob = typeof window !== 'undefined' ?
            /* istanbul ignore next */ window.atob :
            function(str) {
                // Simply doing `new Buffer` at this point causes Browserify to pull
                // in the entire Buffer browser library, which is large and unnecessary.
                // Using `global.Buffer` defeats this.
                return new global.Buffer(str, 'base64').toString('binary');
            };
        return atob(str);
    }

    /**
     * Split a string into an array of substrings
     * @param {String} str - string
     * @param {String} separator - the token or regex that splits the string
     * @param {Integer} [limit] - max number of substrings
     * @returns {Array} The array of string
     */
    function functionSplit(str, separator, limit) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        // limit, if specified, must be a non-negative number
        if(limit < 0) {
            throw {
                code: "D3020",
                stack: (new Error()).stack,
                value: limit,
                index: 3
            };
        }

        var result = [];

        if(typeof limit === 'undefined' || limit > 0) {
            if (typeof separator === 'string') {
                result = str.split(separator, limit);
            } else {
                var count = 0;
                var matches = separator(str);
                if (typeof matches !== 'undefined') {
                    var start = 0;
                    while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {
                        result.push(str.substring(start, matches.start));
                        start = matches.end;
                        matches = matches.next();
                        count++;
                    }
                    if(typeof limit === 'undefined' || count < limit) {
                        result.push(str.substring(start));
                    }
                } else {
                    result = [str];
                }
            }
        }

        return result;
    }

    /**
     * Join an array of strings
     * @param {Array} strs - array of string
     * @param {String} [separator] - the token that splits the string
     * @returns {String} The concatenated string
     */
    function functionJoin(strs, separator) {
        // undefined inputs always return undefined
        if(typeof strs === 'undefined') {
            return undefined;
        }

        // if separator is not specified, default to empty string
        if(typeof separator === 'undefined') {
            separator = "";
        }

        return strs.join(separator);
    }

    /**
     * Formats a number into a decimal string representation using XPath 3.1 F&O fn:format-number spec
     * @param {number} value - number to format
     * @param {String} picture - picture string definition
     * @param {Object} [options] - override locale defaults
     * @returns {String} The formatted string
     */
    function functionFormatNumber(value, picture, options) {
        var defaults = {
            "decimal-separator": ".",
            "grouping-separator": ",",
            "exponent-separator": "e",
            "infinity": "Infinity",
            "minus-sign": "-",
            "NaN": "NaN",
            "percent": "%",
            "per-mille": "\u2030",
            "zero-digit": "0",
            "digit": "#",
            "pattern-separator": ";"
        };

        // if `options` is specified, then its entries override defaults
        var properties = defaults;
        if(typeof options !== 'undefined') {
            Object.keys(options).forEach(function (key) {
                properties[key] = options[key];
            });
        }

        var decimalDigitFamily = [];
        var zeroCharCode = properties['zero-digit'].charCodeAt(0);
        for(var ii = zeroCharCode; ii < zeroCharCode + 10; ii++) {
            decimalDigitFamily.push(String.fromCharCode(ii));
        }

        var activeChars = decimalDigitFamily.concat([properties['decimal-separator'], properties['exponent-separator'], properties['grouping-separator'], properties.digit, properties['pattern-separator']]);

        var subPictures = picture.split(properties['pattern-separator']);

        if(subPictures.length > 2) {
            throw {
                code: 'D3080',
                stack: (new Error()).stack
            };
        }

        var splitParts = function(subpicture) {
            var prefix = (function() {
                var ch;
                for(var ii = 0; ii < subpicture.length; ii++) {
                    ch = subpicture.charAt(ii);
                    if(activeChars.indexOf(ch) !== -1 && ch !== properties['exponent-separator']) {
                        return subpicture.substring(0, ii);
                    }
                }
            })();
            var suffix = (function() {
                var ch;
                for(var ii = subpicture.length - 1; ii >= 0; ii--) {
                    ch = subpicture.charAt(ii);
                    if(activeChars.indexOf(ch) !== -1 && ch !== properties['exponent-separator']) {
                        return subpicture.substring(ii + 1);
                    }
                }
            })();
            var activePart = subpicture.substring(prefix.length, subpicture.length - suffix.length);
            var mantissaPart, exponentPart, integerPart, fractionalPart;
            var exponentPosition = subpicture.indexOf(properties['exponent-separator'], prefix.length);
            if(exponentPosition === -1 || exponentPosition > subpicture.length - suffix.length) {
                mantissaPart = activePart;
                exponentPart = undefined;
            } else {
                mantissaPart = activePart.substring(0, exponentPosition);
                exponentPart = activePart.substring(exponentPosition + 1);
            }
            var decimalPosition = mantissaPart.indexOf(properties['decimal-separator']);
            if(decimalPosition === -1) {
                integerPart = mantissaPart;
                fractionalPart = suffix;
            } else {
                integerPart = mantissaPart.substring(0, decimalPosition);
                fractionalPart = mantissaPart.substring(decimalPosition + 1);
            }
            return {
                prefix: prefix,
                suffix: suffix,
                activePart: activePart,
                mantissaPart: mantissaPart,
                exponentPart: exponentPart,
                integerPart: integerPart,
                fractionalPart: fractionalPart,
                subpicture: subpicture
            };
        };

        // validate the picture string, F&O 4.7.3
        var validate = function(parts) {
            var error;
            var ii;
            var subpicture = parts.subpicture;
            var decimalPos = subpicture.indexOf(properties['decimal-separator']);
            if(decimalPos !== subpicture.lastIndexOf(properties['decimal-separator'])) {
                error = 'D3081';
            }
            if(subpicture.indexOf(properties.percent) !== subpicture.lastIndexOf(properties.percent)) {
                error = 'D3082';
            }
            if(subpicture.indexOf(properties['per-mille']) !== subpicture.lastIndexOf(properties['per-mille'])) {
                error = 'D3083';
            }
            if(subpicture.indexOf(properties.percent) !== -1 && subpicture.indexOf(properties['per-mille']) !== -1) {
                error = 'D3084';
            }
            var valid = false;
            for(ii = 0; ii < parts.mantissaPart.length; ii++) {
                var ch = parts.mantissaPart.charAt(ii);
                if(decimalDigitFamily.indexOf(ch) !== -1 || ch === properties.digit) {
                    valid = true;
                    break;
                }
            }
            if(!valid) {
                error = 'D3085';
            }
            var charTypes = parts.activePart.split('').map(function(char) {
                return activeChars.indexOf(char) === -1 ? 'p' : 'a';
            }).join('');
            if(charTypes.indexOf('p') !== -1) {
                error = 'D3086';
            }
            if(decimalPos !== -1) {
                if(subpicture.charAt(decimalPos - 1) === properties['grouping-separator'] || subpicture.charAt(decimalPos + 1) === properties['grouping-separator']) {
                    error = 'D3087';
                }
            } else if(parts.integerPart.charAt(parts.integerPart.length - 1) === properties['grouping-separator']) {
                error = 'D3088';
            }
            if(subpicture.indexOf(properties['grouping-separator'] + properties['grouping-separator']) !== -1) {
                error = 'D3089';
            }
            var optionalDigitPos = parts.integerPart.indexOf(properties.digit);
            if(optionalDigitPos !== -1 && parts.integerPart.substring(0, optionalDigitPos).split('').filter(function(char) {
                return decimalDigitFamily.indexOf(char) > -1;
            }).length > 0) {
                error = 'D3090';
            }
            optionalDigitPos = parts.fractionalPart.lastIndexOf(properties.digit);
            if(optionalDigitPos !== -1 && parts.fractionalPart.substring(optionalDigitPos).split('').filter(function(char) {
                return decimalDigitFamily.indexOf(char) > -1;
            }).length > 0) {
                error = 'D3091';
            }
            var exponentExists = (typeof parts.exponentPart === 'string');
            if(exponentExists && parts.exponentPart.length > 0 && (subpicture.indexOf(properties.percent) !== -1 || subpicture.indexOf(properties['per-mille']) !== -1)) {
                error = 'D3092';
            }
            if(exponentExists && (parts.exponentPart.length === 0 || parts.exponentPart.split('').filter(function(char) {
                return decimalDigitFamily.indexOf(char) === -1;
            }).length > 0)) {
                error = 'D3093';
            }
            if(error) {
                throw {
                    code: error,
                    stack: (new Error()).stack
                };
            }
        };

        // analyse the picture string, F&O 4.7.4
        var analyse = function(parts) {
            var getGroupingPositions = function(part, toLeft) {
                var positions = [];
                var groupingPosition = part.indexOf(properties['grouping-separator']);
                while(groupingPosition !== -1) {
                    var charsToTheRight = (toLeft ? part.substring(0, groupingPosition) : part.substring(groupingPosition)).split('').filter(function(char) {
                        return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit;
                    }).length;
                    positions.push(charsToTheRight);
                    groupingPosition = parts.integerPart.indexOf(properties['grouping-separator'], groupingPosition + 1);
                }
                return positions;
            };
            var integerPartGroupingPositions = getGroupingPositions(parts.integerPart);
            var regular = function(indexes) {
                // are the grouping positions regular? i.e. same interval between each of them
                if(indexes.length === 0) {
                    return 0;
                }
                var gcd = function(a, b) {
                    return b === 0 ? a : gcd(b, a % b);
                };
                // find the greatest common divisor of all the positions
                var factor = indexes.reduce(gcd);
                // is every position separated by this divisor? If so, it's regular
                for(var index = 1; index <= indexes.length; index++) {
                    if(indexes.indexOf(index * factor) === -1) {
                        return 0;
                    }
                }
                return factor;
            };

            var regularGrouping = regular(integerPartGroupingPositions);
            var fractionalPartGroupingPositions = getGroupingPositions(parts.fractionalPart, true);

            var minimumIntegerPartSize = parts.integerPart.split('').filter(function(char) { return decimalDigitFamily.indexOf(char) !== -1; }).length;
            var scalingFactor = minimumIntegerPartSize;

            var fractionalPartArray = parts.fractionalPart.split('');
            var minimumFactionalPartSize = fractionalPartArray.filter(function(char) { return decimalDigitFamily.indexOf(char) !== -1; }).length;
            var maximumFactionalPartSize = fractionalPartArray.filter(function(char) { return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit; }).length;
            var exponentPresent = typeof parts.exponentPart === 'string';
            if(minimumIntegerPartSize === 0 && maximumFactionalPartSize === 0) {
                if(exponentPresent) {
                    minimumFactionalPartSize = 1;
                    maximumFactionalPartSize = 1;
                } else {
                    minimumIntegerPartSize = 1;
                }
            }
            if(exponentPresent && minimumIntegerPartSize === 0 && parts.integerPart.indexOf(properties.digit) !== -1) {
                minimumIntegerPartSize = 1;
            }
            if(minimumIntegerPartSize === 0 && minimumFactionalPartSize === 0) {
                minimumFactionalPartSize = 1;
            }
            var minimumExponentSize = 0;
            if(exponentPresent) {
                minimumExponentSize = parts.exponentPart.split('').filter(function(char) { return decimalDigitFamily.indexOf(char) !== -1; }).length;
            }

            return {
                integerPartGroupingPositions: integerPartGroupingPositions,
                regularGrouping: regularGrouping,
                minimumIntegerPartSize: minimumIntegerPartSize,
                scalingFactor: scalingFactor,
                prefix: parts.prefix,
                fractionalPartGroupingPositions: fractionalPartGroupingPositions,
                minimumFactionalPartSize: minimumFactionalPartSize,
                maximumFactionalPartSize: maximumFactionalPartSize,
                minimumExponentSize: minimumExponentSize,
                suffix: parts.suffix,
                picture: parts.subpicture
            };
        };

        var parts = subPictures.map(splitParts);
        parts.forEach(validate);

        var variables = parts.map(analyse);

        if(variables.length === 1) {
            variables.push(JSON.parse(JSON.stringify(variables[0])));
            variables[1].prefix = properties['minus-sign'] + variables[1].prefix;
        }

        // TODO cache the result of the analysis

        // format the number
        // bullet 1: TODO: NaN - not sure we'd ever get this in JSON
        var pic;
        // bullet 2:
        if(value >= 0) {
            pic = variables[0];
        } else {
            pic = variables[1];
        }
        var adjustedNumber;
        // bullet 3:
        if(pic.picture.indexOf(properties.percent) !== -1) {
            adjustedNumber = value * 100;
        } else if(pic.picture.indexOf(properties['per-mille']) !== -1) {
            adjustedNumber = value * 1000;
        } else {
            adjustedNumber = value;
        }
        // bullet 4:
        // TODO: infinity - not sure we'd ever get this in JSON
        // bullet 5:
        var mantissa, exponent;
        if(pic.minimumExponentSize === 0) {
            mantissa = adjustedNumber;
        } else {
            // mantissa * 10^exponent = adjustedNumber
            var maxMantissa = Math.pow(10, pic.scalingFactor);
            var minMantissa = Math.pow(10, pic.scalingFactor - 1);
            mantissa = adjustedNumber;
            exponent = 0;
            while(mantissa < minMantissa) {
                mantissa *= 10;
                exponent -= 1;
            }
            while(mantissa > maxMantissa) {
                mantissa /= 10;
                exponent += 1;
            }
        }
        // bullet 6:
        var roundedNumber = functionRound(mantissa, pic.maximumFactionalPartSize);
        // bullet 7:
        var makeString = function(value, dp) {
            var str = Math.abs(value).toFixed(dp);
            if (properties['zero-digit'] !== '0') {
                str = str.split('').map(function (digit) {
                    if(digit >= '0' && digit <='9') {
                        return decimalDigitFamily[digit.charCodeAt(0) - 48];
                    } else {
                        return digit;
                    }
                }).join('');
            }
            return str;
        };
        var stringValue = makeString(roundedNumber, pic.maximumFactionalPartSize);
        var decimalPos = stringValue.indexOf('.');
        if(decimalPos === -1) {
            stringValue = stringValue + properties['decimal-separator'];
        } else {
            stringValue = stringValue.replace('.', properties['decimal-separator']);
        }
        while(stringValue.charAt(0) === properties['zero-digit']) {
            stringValue = stringValue.substring(1);
        }
        while(stringValue.charAt(stringValue.length - 1) === properties['zero-digit']) {
            stringValue = stringValue.substring(0, stringValue.length - 1);
        }
        // bullets 8 & 9:
        decimalPos = stringValue.indexOf(properties['decimal-separator']);
        var padLeft = pic.minimumIntegerPartSize - decimalPos;
        var padRight = pic.minimumFactionalPartSize - (stringValue.length - decimalPos - 1);
        stringValue = (padLeft > 0 ? new Array(padLeft + 1).join('0') : '') + stringValue;
        stringValue = stringValue + (padRight > 0 ? new Array(padRight + 1).join('0') : '');
        decimalPos = stringValue.indexOf(properties['decimal-separator']);
        // bullet 10:
        if(pic.regularGrouping > 0) {
            var groupCount = Math.floor((decimalPos - 1) / pic.regularGrouping);
            for(var group = 1; group <= groupCount; group++) {
                stringValue = [stringValue.slice(0, decimalPos - group * pic.regularGrouping), properties['grouping-separator'], stringValue.slice(decimalPos - group * pic.regularGrouping)].join('');
            }
        } else {
            pic.integerPartGroupingPositions.forEach(function (pos) {
                stringValue = [stringValue.slice(0, decimalPos - pos), properties['grouping-separator'], stringValue.slice(decimalPos - pos)].join('');
                decimalPos++;
            });
        }
        // bullet 11:
        decimalPos = stringValue.indexOf(properties['decimal-separator']);
        pic.fractionalPartGroupingPositions.forEach(function(pos) {
            stringValue = [stringValue.slice(0, pos + decimalPos + 1), properties['grouping-separator'], stringValue.slice(pos + decimalPos + 1)].join('');
        });
        // bullet 12:
        decimalPos = stringValue.indexOf(properties['decimal-separator']);
        if(pic.picture.indexOf(properties['decimal-separator']) === -1 || decimalPos === stringValue.length - 1) {
            stringValue = stringValue.substring(0, stringValue.length - 1);
        }
        // bullet 13:
        if(typeof exponent !== 'undefined') {
            var stringExponent = makeString(exponent, 0);
            padLeft = pic.minimumExponentSize - stringExponent.length;
            if(padLeft > 0) {
                stringExponent = new Array(padLeft + 1).join('0') + stringExponent;
            }
            stringValue = stringValue + properties['exponent-separator'] + (exponent < 0 ? properties['minus-sign'] : '') + stringExponent;
        }
        // bullet 14:
        stringValue = pic.prefix + stringValue + pic.suffix;
        return stringValue;
    }

    /**
     * Converts a number to a string using a specified number base
     * @param {string} value - the number to convert
     * @param {number} [radix] - the number base; must be between 2 and 36. Defaults to 10
     * @returns {string} - the converted string
     */
    function functionFormatBase(value, radix) {
        // undefined inputs always return undefined
        if(typeof value === 'undefined') {
            return undefined;
        }

        value = functionRound(value);

        if(typeof radix === 'undefined') {
            radix = 10;
        } else {
            radix = functionRound(radix);
        }

        if(radix < 2 || radix > 36) {
            throw {
                code: 'D3100',
                stack: (new Error()).stack,
                value: radix
            };

        }

        var result = value.toString(radix);

        return result;
    }

    /**
     * Cast argument to number
     * @param {Object} arg - Argument
     * @returns {Number} numeric value of argument
     */
    function functionNumber(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        if (typeof arg === 'number') {
            // already a number
            result = arg;
        } else if(typeof arg === 'string' && /^-?(0|([1-9][0-9]*))(\.[0-9]+)?([Ee][-+]?[0-9]+)?$/.test(arg) && !isNaN(parseFloat(arg)) && isFinite(arg)) {
            result = parseFloat(arg);
        } else {
            throw {
                code: "D3030",
                value: arg,
                stack: (new Error()).stack,
                index: 1
            };
        }
        return result;
    }

    /**
     * Absolute value of a number
     * @param {Number} arg - Argument
     * @returns {Number} absolute value of argument
     */
    function functionAbs(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        result = Math.abs(arg);
        return result;
    }

    /**
     * Rounds a number down to integer
     * @param {Number} arg - Argument
     * @returns {Number} rounded integer
     */
    function functionFloor(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        result = Math.floor(arg);
        return result;
    }

    /**
     * Rounds a number up to integer
     * @param {Number} arg - Argument
     * @returns {Number} rounded integer
     */
    function functionCeil(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        result = Math.ceil(arg);
        return result;
    }

    /**
     * Round to half even
     * @param {Number} arg - Argument
     * @param {Number} precision - number of decimal places
     * @returns {Number} rounded integer
     */
    function functionRound(arg, precision) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        if(precision) {
            // shift the decimal place - this needs to be done in a string since multiplying
            // by a power of ten can introduce floating point precision errors which mess up
            // this rounding algorithm - See 'Decimal rounding' in
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round
            // Shift
            var value = arg.toString().split('e');
            arg = +(value[0] + 'e' + (value[1] ? (+value[1] + precision) : precision));

        }

        // round up to nearest int
        result = Math.round(arg);
        var diff = result - arg;
        if(Math.abs(diff) === 0.5 && Math.abs(result % 2) === 1) {
            // rounded the wrong way - adjust to nearest even number
            result = result - 1;
        }
        if(precision) {
            // Shift back
            value = result.toString().split('e');
            /* istanbul ignore next */
            result = +(value[0] + 'e' + (value[1] ? (+value[1] - precision) : -precision));
        }
        if(Object.is(result, -0)) { // ESLint rule 'no-compare-neg-zero' suggests this way
            // JSON doesn't do -0
            result = 0;
        }
        return result;
    }

    /**
     * Square root of number
     * @param {Number} arg - Argument
     * @returns {Number} square root
     */
    function functionSqrt(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        if(arg < 0) {
            throw {
                stack: (new Error()).stack,
                code: "D3060",
                index: 1,
                value: arg
            };
        }

        result = Math.sqrt(arg);

        return result;
    }

    /**
     * Raises number to the power of the second number
     * @param {Number} arg - the base
     * @param {Number} exp - the exponent
     * @returns {Number} rounded integer
     */
    function functionPower(arg, exp) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        result = Math.pow(arg, exp);

        if(!isFinite(result)) {
            throw {
                stack: (new Error()).stack,
                code: "D3061",
                index: 1,
                value: arg,
                exp: exp
            };
        }

        return result;
    }

    /**
     * Returns a random number 0 <= n < 1
     * @returns {number} random number
     */
    function functionRandom() {
        return Math.random();
    }

    /**
     * Evaluate an input and return a boolean
     * @param {*} arg - Arguments
     * @returns {boolean} Boolean
     */
    function functionBoolean(arg) {
        // cast arg to its effective boolean value
        // boolean: unchanged
        // string: zero-length -> false; otherwise -> true
        // number: 0 -> false; otherwise -> true
        // null -> false
        // array: empty -> false; length > 1 -> true
        // object: empty -> false; non-empty -> true
        // function -> false

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        var result = false;
        if (Array.isArray(arg)) {
            if (arg.length === 1) {
                result = functionBoolean(arg[0]);
            } else if (arg.length > 1) {
                var trues = arg.filter(function(val) {return functionBoolean(val);});
                result = trues.length > 0;
            }
        } else if (typeof arg === 'string') {
            if (arg.length > 0) {
                result = true;
            }
        } else if (isNumeric(arg)) {
            if (arg !== 0) {
                result = true;
            }
        } else if (arg !== null && typeof arg === 'object') {
            if (Object.keys(arg).length > 0) {
                // make sure it's not a lambda function
                if (!(isLambda(arg) || arg._jsonata_function)) {
                    result = true;
                }
            }
        } else if (typeof arg === 'boolean' && arg === true) {
            result = true;
        }
        return result;
    }

    /**
     * returns the Boolean NOT of the arg
     * @param {*} arg - argument
     * @returns {boolean} - NOT arg
     */
    function functionNot(arg) {
        return !functionBoolean(arg);
    }

    /**
     * Create a map from an array of arguments
     * @param {Array} [arr] - array to map over
     * @param {Function} func - function to apply
     * @returns {Array} Map array
     */
    function* functionMap(arr, func) {
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        var result = [];
        // do the map - iterate over the arrays, and invoke func
        for (var i = 0; i < arr.length; i++) {
            var func_args = [arr[i]]; // the first arg (value) is required
            // the other two are optional - only supply it if the function can take it
            var length = typeof func === 'function' ? func.length :
                func._jsonata_function === true ? func.implementation.length : func.arguments.length;
            if(length >= 2) {
                func_args.push(i);
            }
            if(length >= 3) {
                func_args.push(arr);
            }
            // invoke func
            var res = yield * apply(func, func_args, null);
            if(typeof res !== 'undefined') {
                result.push(res);
            }
        }

        return result;
    }

    // This generator function does not have a yield(), presumably to make it
    // consistent with other similar functions.
    /**
     * Create a map from an array of arguments
     * @param {Array} [arr] - array to filter
     * @param {Function} func - predicate function
     * @returns {Array} Map array
     */
    function* functionFilter(arr, func) { // eslint-disable-line require-yield
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        var result = [];

        var predicate = function (value, index, array) {
            var it = apply(func, [value, index, array], null);
            // returns a generator - so iterate over it
            var res = it.next();
            while (!res.done) {
                res = it.next(res.value);
            }
            return res.value;
        };

        for(var i = 0; i < arr.length; i++) {
            var entry = arr[i];
            if(functionBoolean(predicate(entry, i, arr))) {
                result.push(entry);
            }
        }

        return result;
    }

    /**
     * Convolves (zips) each value from a set of arrays
     * @param {Array} [args] - arrays to zip
     * @returns {Array} Zipped array
     */
    function functionZip() {
        // this can take a variable number of arguments
        var result = [];
        var args = Array.prototype.slice.call(arguments);
        // length of the shortest array
        var length = Math.min.apply(Math, args.map(function(arg) {
            if(Array.isArray(arg)) {
                return arg.length;
            }
            return 0;
        }));
        for(var i = 0; i < length; i++) {
            var tuple = args.map((arg) => {return arg[i];});
            result.push(tuple);
        }
        return result;
    }

    /**
     * Fold left function
     * @param {Array} sequence - Sequence
     * @param {Function} func - Function
     * @param {Object} init - Initial value
     * @returns {*} Result
     */
    function* functionFoldLeft(sequence, func, init) {
        // undefined inputs always return undefined
        if(typeof sequence === 'undefined') {
            return undefined;
        }

        var result;

        if (!(func.length === 2 || (func._jsonata_function === true && func.implementation.length === 2) || func.arguments.length === 2)) {
            throw {
                stack: (new Error()).stack,
                code: "D3050",
                index: 1
            };
        }

        var index;
        if (typeof init === 'undefined' && sequence.length > 0) {
            result = sequence[0];
            index = 1;
        } else {
            result = init;
            index = 0;
        }

        while (index < sequence.length) {
            result = yield * apply(func, [result, sequence[index]], null);
            index++;
        }

        return result;
    }

    /**
     * Return keys for an object
     * @param {Object} arg - Object
     * @returns {Array} Array of keys
     */
    function functionKeys(arg) {
        var result = [];

        if(Array.isArray(arg)) {
            // merge the keys of all of the items in the array
            var merge = {};
            arg.forEach(function(item) {
                var keys = functionKeys(item);
                if(Array.isArray(keys)) {
                    keys.forEach(function(key) {
                        merge[key] = true;
                    });
                }
            });
            result = functionKeys(merge);
        } else if(arg !== null && typeof arg === 'object' && !(isLambda(arg))) {
            result = Object.keys(arg);
            if(result.length === 0) {
                result = undefined;
            }
        } else {
            result = undefined;
        }
        return result;
    }

    /**
     * Return value from an object for a given key
     * @param {Object} object - Object
     * @param {String} key - Key in object
     * @returns {*} Value of key in object
     */
    function functionLookup(object, key) {
        var result = evaluateName({value: key}, object);
        return result;
    }

    /**
     * Append second argument to first
     * @param {Array|Object} arg1 - First argument
     * @param {Array|Object} arg2 - Second argument
     * @returns {*} Appended arguments
     */
    function functionAppend(arg1, arg2) {
        // disregard undefined args
        if (typeof arg1 === 'undefined') {
            return arg2;
        }
        if (typeof arg2 === 'undefined') {
            return arg1;
        }
        // if either argument is not an array, make it so
        if (!Array.isArray(arg1)) {
            arg1 = [arg1];
        }
        if (!Array.isArray(arg2)) {
            arg2 = [arg2];
        }
        Array.prototype.push.apply(arg1, arg2);
        return arg1;
    }

    /**
     * Determines if the argument is undefined
     * @param {*} arg - argument
     * @returns {boolean} False if argument undefined, otherwise true
     */
    function functionExists(arg){
        if (typeof arg === 'undefined') {
            return false;
        } else {
            return true;
        }
    }

    /**
     * Splits an object into an array of object with one property each
     * @param {*} arg - the object to split
     * @returns {*} - the array
     */
    function functionSpread(arg) {
        var result = [];

        if(Array.isArray(arg)) {
            // spread all of the items in the array
            arg.forEach(function(item) {
                result = functionAppend(result, functionSpread(item));
            });
        } else if(arg !== null && typeof arg === 'object' && !isLambda(arg)) {
            for(var key in arg) {
                var obj = {};
                obj[key] = arg[key];
                result.push(obj);
            }
        } else {
            result = arg;
        }
        return result;
    }

    /**
     * Merges an array of objects into a single object.  Duplicate properties are
     * overridden by entries later in the array
     * @param {*} arg - the objects to merge
     * @returns {*} - the object
     */
    function functionMerge(arg) {
        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        var result = {};

        arg.forEach(function(obj) {
            for(var prop in obj) {
                result[prop] = obj[prop];
            }
        });
        return result;
    }

    /**
     * Reverses the order of items in an array
     * @param {Array} arr - the array to reverse
     * @returns {Array} - the reversed array
     */
    function functionReverse(arr) {
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        if(arr.length <= 1) {
            return arr;
        }

        var length = arr.length;
        var result = new Array(length);
        for(var i = 0; i < length; i++) {
            result[length - i - 1] = arr[i];
        }

        return result;
    }

    /**
     *
     * @param {*} obj - the input object to iterate over
     * @param {*} func - the function to apply to each key/value pair
     * @returns {Array} - the resultant array
     */
    function* functionEach(obj, func) {
        var result = [];

        for(var key in obj) {
            var func_args = [obj[key], key];
            // invoke func
            result.push(yield * apply(func, func_args, null));
        }

        return result;
    }

    /**
     * Implements the merge sort (stable) with optional comparator function
     *
     * @param {Array} arr - the array to sort
     * @param {*} comparator - comparator function
     * @returns {Array} - sorted array
     */
    function functionSort(arr, comparator) {
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        if(arr.length <= 1) {
            return arr;
        }

        var comp;
        if(typeof comparator === 'undefined') {
            // inject a default comparator - only works for numeric or string arrays
            if (!isArrayOfNumbers(arr) && !isArrayOfStrings(arr)) {
                throw {
                    stack: (new Error()).stack,
                    code: "D3070",
                    index: 1
                };
            }

            comp = function (a, b) {
                return a > b;
            };
        } else if(typeof comparator === 'function') {
            // for internal usage of functionSort (i.e. order-by syntax)
            comp = comparator;
        } else {
            comp = function (a, b) {
                var it = apply(comparator, [a, b], null);
                // returns a generator - so iterate over it
                var comp = it.next();
                while (!comp.done) {
                    comp = it.next(comp.value);
                }
                return comp.value;
            };
        }

        var merge = function(l, r) {
            var merge_iter = function(result, left, right) {
                if (left.length === 0) {
                    Array.prototype.push.apply(result, right);
                } else if (right.length === 0) {
                    Array.prototype.push.apply(result, left);
                } else if (comp(left[0], right[0])) { // invoke the comparator function
                    // if it returns true - swap left and right
                    result.push(right[0]);
                    merge_iter(result, left, right.slice(1));
                } else {
                    // otherwise keep the same order
                    result.push(left[0]);
                    merge_iter(result, left.slice(1), right);
                }
            };
            var merged = [];
            merge_iter(merged, l, r);
            return merged;
        };

        var sort = function(array) {
            if(array.length <= 1) {
                return array;
            } else {
                var middle = Math.floor(array.length / 2);
                var left = array.slice(0, middle);
                var right = array.slice(middle);
                left = sort(left);
                right = sort(right);
                return merge(left, right);
            }
        };

        var result = sort(arr);

        return result;
    }

    /**
     * Randomly shuffles the contents of an array
     * @param {Array} arr - the input array
     * @returns {Array} the shuffled array
     */
    function functionShuffle(arr) {
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        if(arr.length <= 1) {
            return arr;
        }

        // shuffle using the 'inside-out' variant of the Fisher-Yates algorithm
        var result = new Array(arr.length);
        for(var i = 0; i < arr.length; i++) {
            var j = Math.floor(Math.random() * (i + 1)); // random integer such that 0 ≤ j ≤ i
            if(i !== j) {
                result[i] = result[j];
            }
            result[j] = arr[i];
        }

        return result;
    }

    /**
     * Applies a predicate function to each key/value pair in an object, and returns an object containing
     * only the key/value pairs that passed the predicate
     *
     * @param {object} arg - the object to be sifted
     * @param {object} func - the predicate function (lambda or native)
     * @returns {object} - sifted object
     */
    function functionSift(arg, func) {
        var result = {};

        var predicate = function (value, key, object) {
            var it = apply(func, [value, key, object], null);
            // returns a generator - so iterate over it
            var res = it.next();
            while (!res.done) {
                res = it.next(res.value);
            }
            return res.value;
        };

        for(var item in arg) {
            var entry = arg[item];
            if(functionBoolean(predicate(entry, item, arg))) {
                result[item] = entry;
            }
        }

        // empty objects should be changed to undefined
        if(Object.keys(result).length === 0) {
            result = undefined;
        }

        return result;
    }

    // Regular expression to match an ISO 8601 formatted timestamp
    var iso8601regex = new RegExp('^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z)$');

    /**
     * Converts an ISO 8601 timestamp to milliseconds since the epoch
     *
     * @param {string} timestamp - the ISO 8601 timestamp to be converted
     * @returns {Number} - milliseconds since the epoch
     */
    function functionToMillis(timestamp) {
        // undefined inputs always return undefined
        if(typeof timestamp === 'undefined') {
            return undefined;
        }

        if(!iso8601regex.test(timestamp)) {
            throw {
                stack: (new Error()).stack,
                code: "D3110",
                value: timestamp
            };
        }

        return Date.parse(timestamp);
    }

    /**
     * Converts milliseconds since the epoch to an ISO 8601 timestamp
     * @param {Number} millis - milliseconds since the epoch to be converted
     * @returns {String} - an ISO 8601 formatted timestamp
     */
    function functionFromMillis(millis) {
        // undefined inputs always return undefined
        if(typeof millis === 'undefined') {
            return undefined;
        }

        return new Date(millis).toISOString();
    }

    /**
     * Clones an object
     * @param {Object} arg - object to clone (deep copy)
     * @returns {*} - the cloned object
     */
    function functionClone(arg) {
        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        return JSON.parse(functionString(arg));
    }

    /**
     * Create frame
     * @param {Object} enclosingEnvironment - Enclosing environment
     * @returns {{bind: bind, lookup: lookup}} Created frame
     */
    function createFrame(enclosingEnvironment) {
        var bindings = {};
        return {
            bind: function (name, value) {
                bindings[name] = value;
            },
            lookup: function (name) {
                var value;
                if(bindings.hasOwnProperty(name)) {
                    value = bindings[name];
                } else if (enclosingEnvironment) {
                    value = enclosingEnvironment.lookup(name);
                }
                return value;
            }
        };
    }

    // Function registration
    staticFrame.bind('sum', defineFunction(functionSum, '<a<n>:n>'));
    staticFrame.bind('count', defineFunction(functionCount, '<a:n>'));
    staticFrame.bind('max', defineFunction(functionMax, '<a<n>:n>'));
    staticFrame.bind('min', defineFunction(functionMin, '<a<n>:n>'));
    staticFrame.bind('average', defineFunction(functionAverage, '<a<n>:n>'));
    staticFrame.bind('string', defineFunction(functionString, '<x-:s>'));
    staticFrame.bind('substring', defineFunction(functionSubstring, '<s-nn?:s>'));
    staticFrame.bind('substringBefore', defineFunction(functionSubstringBefore, '<s-s:s>'));
    staticFrame.bind('substringAfter', defineFunction(functionSubstringAfter, '<s-s:s>'));
    staticFrame.bind('lowercase', defineFunction(functionLowercase, '<s-:s>'));
    staticFrame.bind('uppercase', defineFunction(functionUppercase, '<s-:s>'));
    staticFrame.bind('length', defineFunction(functionLength, '<s-:n>'));
    staticFrame.bind('trim', defineFunction(functionTrim, '<s-:s>'));
    staticFrame.bind('pad', defineFunction(functionPad, '<s-ns?:s>'));
    staticFrame.bind('match', defineFunction(functionMatch, '<s-f<s:o>n?:a<o>>'));
    staticFrame.bind('contains', defineFunction(functionContains, '<s-(sf):b>')); // TODO <s-(sf<s:o>):b>
    staticFrame.bind('replace', defineFunction(functionReplace, '<s-(sf)(sf)n?:s>')); // TODO <s-(sf<s:o>)(sf<o:s>)n?:s>
    staticFrame.bind('split', defineFunction(functionSplit, '<s-(sf)n?:a<s>>')); // TODO <s-(sf<s:o>)n?:a<s>>
    staticFrame.bind('join', defineFunction(functionJoin, '<a<s>s?:s>'));
    staticFrame.bind('formatNumber', defineFunction(functionFormatNumber, '<n-so?:s>'));
    staticFrame.bind('formatBase', defineFunction(functionFormatBase, '<n-n?:s>'));
    staticFrame.bind('number', defineFunction(functionNumber, '<(ns)-:n>'));
    staticFrame.bind('floor', defineFunction(functionFloor, '<n-:n>'));
    staticFrame.bind('ceil', defineFunction(functionCeil, '<n-:n>'));
    staticFrame.bind('round', defineFunction(functionRound, '<n-n?:n>'));
    staticFrame.bind('abs', defineFunction(functionAbs, '<n-:n>'));
    staticFrame.bind('sqrt', defineFunction(functionSqrt, '<n-:n>'));
    staticFrame.bind('power', defineFunction(functionPower, '<n-n:n>'));
    staticFrame.bind('random', defineFunction(functionRandom, '<:n>'));
    staticFrame.bind('boolean', defineFunction(functionBoolean, '<x-:b>'));
    staticFrame.bind('not', defineFunction(functionNot, '<x-:b>'));
    staticFrame.bind('map', defineFunction(functionMap, '<af>'));
    staticFrame.bind('zip', defineFunction(functionZip, '<a+>'));
    staticFrame.bind('filter', defineFunction(functionFilter, '<af>'));
    staticFrame.bind('reduce', defineFunction(functionFoldLeft, '<afj?:j>')); // TODO <f<jj:j>a<j>j?:j>
    staticFrame.bind('sift', defineFunction(functionSift, '<o-f?:o>'));
    staticFrame.bind('keys', defineFunction(functionKeys, '<x-:a<s>>'));
    staticFrame.bind('lookup', defineFunction(functionLookup, '<x-s:x>'));
    staticFrame.bind('append', defineFunction(functionAppend, '<xx:a>'));
    staticFrame.bind('exists', defineFunction(functionExists, '<x:b>'));
    staticFrame.bind('spread', defineFunction(functionSpread, '<x-:a<o>>'));
    staticFrame.bind('merge', defineFunction(functionMerge, '<a<o>:o>'));
    staticFrame.bind('reverse', defineFunction(functionReverse, '<a:a>'));
    staticFrame.bind('each', defineFunction(functionEach, '<o-f:a>'));
    staticFrame.bind('sort', defineFunction(functionSort, '<af?:a>'));
    staticFrame.bind('shuffle', defineFunction(functionShuffle, '<a:a>'));
    staticFrame.bind('base64encode', defineFunction(functionBase64encode, '<s-:s>'));
    staticFrame.bind('base64decode', defineFunction(functionBase64decode, '<s-:s>'));
    staticFrame.bind('toMillis', defineFunction(functionToMillis, '<s-:n>'));
    staticFrame.bind('fromMillis', defineFunction(functionFromMillis, '<n-:s>'));
    staticFrame.bind('clone', defineFunction(functionClone, '<(oa)-:o>'));

    /**
     * Error codes
     *
     */
    var errorCodes = {
        "S0101": "String literal must be terminated by a matching quote",
        "S0102": "Number out of range: {{token}}",
        "S0103": "Unsupported escape sequence: \\{{token}}",
        "S0104": "The escape sequence \\u must be followed by 4 hex digits",
        "S0105": "Quoted property name must be terminated with a backquote (`)",
        "S0201": "Syntax error: {{token}}",
        "S0202": "Expected {{value}}, got {{token}}",
        "S0203": "Expected {{value}} before end of expression",
        "S0204": "Unknown operator: {{token}}",
        "S0205": "Unexpected token: {{token}}",
        "S0206": "Unknown expression type: {{token}}",
        "S0207": "Unexpected end of expression",
        "S0208": "Parameter {{value}} of function definition must be a variable name (start with $)",
        "S0209": "A predicate cannot follow a grouping expression in a step",
        "S0210": "Each step can only have one grouping expression",
        "S0211": "The symbol {{token}} cannot be used as a unary operator",
        "S0301": "Empty regular expressions are not allowed",
        "S0302": "No terminating / in regular expression",
        "S0402": "Choice groups containing parameterized types are not supported",
        "S0401": "Type parameters can only be applied to functions and arrays",
        "S0500": "Attempted to evaluate an expression containing syntax error(s)",
        "T0410": "Argument {{index}} of function {{token}} does not match function signature",
        "T0411": "Context value is not a compatible type with argument {{index}} of function {{token}}",
        "T0412": "Argument {{index}} of function {{token}} must be an array of {{type}}",
        "D1001": "Number out of range: {{value}}",
        "D1002": "Cannot negate a non-numeric value: {{value}}",
        "T1003": "Key in object structure must evaluate to a string; got: {{value}}",
        "D1004": "Regular expression matches zero length string",
        "T1005": "Attempted to invoke a non-function. Did you mean ${{{token}}}?",
        "T1006": "Attempted to invoke a non-function",
        "T1007": "Attempted to partially apply a non-function. Did you mean ${{{token}}}?",
        "T1008": "Attempted to partially apply a non-function",
        "T2001": "The left side of the {{token}} operator must evaluate to a number",
        "T2002": "The right side of the {{token}} operator must evaluate to a number",
        "T2003": "The left side of the range operator (..) must evaluate to an integer",
        "T2004": "The right side of the range operator (..) must evaluate to an integer",
        "D2005": "The left side of := must be a variable name (start with $)",
        "T2006": "The right side of the function application operator ~> must be a function",
        "T2007": "Type mismatch when comparing values {{value}} and {{value2}} in order-by clause",
        "T2008": "The expressions within an order-by clause must evaluate to numeric or string values",
        "T2009": "The values {{value}} and {{value2}} either side of operator {{token}} must be of the same data type",
        "T2010": "The expressions either side of operator {{token}} must evaluate to numeric or string values",
        "T2011": "The insert/update clause of the transform expression must evaluate to an object: {{value}}",
        "T2012": "The delete clause of the transform expression must evaluate to a string or array of strings: {{value}}",
        "T2013": "The transform expression clones the input object using the $clone() function.  This has been overridden in the current scope by a non-function.",
        "D3001": "Attempting to invoke string function on Infinity or NaN",
        "D3010": "Second argument of replace function cannot be an empty string",
        "D3011": "Fourth argument of replace function must evaluate to a positive number",
        "D3012": "Attempted to replace a matched string with a non-string value",
        "D3020": "Third argument of split function must evaluate to a positive number",
        "D3030": "Unable to cast value to a number: {{value}}",
        "D3040": "Third argument of match function must evaluate to a positive number",
        "D3050": "First argument of reduce function must be a function with two arguments",
        "D3060": "The sqrt function cannot be applied to a negative number: {{value}}",
        "D3061": "The power function has resulted in a value that cannot be represented as a JSON number: base={{value}}, exponent={{exp}}",
        "D3070": "The single argument form of the sort function can only be applied to an array of strings or an array of numbers.  Use the second argument to specify a comparison function",
        "D3080": "The picture string must only contain a maximum of two sub-pictures",
        "D3081": "The sub-picture must not contain more than one instance of the 'decimal-separator' character",
        "D3082": "The sub-picture must not contain more than one instance of the 'percent' character",
        "D3083": "The sub-picture must not contain more than one instance of the 'per-mille' character",
        "D3084": "The sub-picture must not contain both a 'percent' and a 'per-mille' character",
        "D3085": "The mantissa part of a sub-picture must contain at least one character that is either an 'optional digit character' or a member of the 'decimal digit family'",
        "D3086": "The sub-picture must not contain a passive character that is preceded by an active character and that is followed by another active character",
        "D3087": "The sub-picture must not contain a 'grouping-separator' character that appears adjacent to a 'decimal-separator' character",
        "D3088": "The sub-picture must not contain a 'grouping-separator' at the end of the integer part",
        "D3089": "The sub-picture must not contain two adjacent instances of the 'grouping-separator' character",
        "D3090": "The integer part of the sub-picture must not contain a member of the 'decimal digit family' that is followed by an instance of the 'optional digit character'",
        "D3091": "The fractional part of the sub-picture must not contain an instance of the 'optional digit character' that is followed by a member of the 'decimal digit family'",
        "D3092": "A sub-picture that contains a 'percent' or 'per-mille' character must not contain a character treated as an 'exponent-separator'",
        "D3093": "The exponent part of the sub-picture must comprise only of one or more characters that are members of the 'decimal digit family'",
        "D3100": "The radix of the formatBase function must be between 2 and 36.  It was given {{value}}",
        "D3110": "The argument of the toMillis function must be an ISO 8601 formatted timestamp. Given {{value}}"
    };

    /**
     * lookup a message template from the catalog and substitute the inserts
     * @param {string} err - error code to lookup
     * @returns {string} message
     */
    function lookupMessage(err) {
        var message = 'Unknown error';
        if(typeof err.message !== 'undefined') {
            message = err.message;
        }
        var template = errorCodes[err.code];
        if(typeof template !== 'undefined') {
            // if there are any handlebars, replace them with the field references
            // triple braces - replace with value
            // double braces - replace with json stringified value
            message = template.replace(/\{\{\{([^}]+)}}}/g, function() {
                return err[arguments[1]];
            });
            message = message.replace(/\{\{([^}]+)}}/g, function() {
                return JSON.stringify(err[arguments[1]]);
            });
        }
        return message;
    }

    /**
     * JSONata
     * @param {Object} expr - JSONata expression
     * @param {boolean} options - recover: attempt to recover on parse error
     * @returns {{evaluate: evaluate, assign: assign}} Evaluated expression
     */
    function jsonata(expr, options) {
        var ast;
        var errors;
        try {
            ast = parser(expr, options && options.recover);
            errors = ast.errors;
            delete ast.errors;
        } catch(err) {
            // insert error message into structure
            err.message = lookupMessage(err);
            throw err;
        }
        var environment = createFrame(staticFrame);

        var timestamp = new Date(); // will be overridden on each call to evalute()
        environment.bind('now', defineFunction(function() {
            return timestamp.toJSON();
        }, '<:s>'));
        environment.bind('millis', defineFunction(function() {
            return timestamp.getTime();
        }, '<:n>'));

        return {
            evaluate: function (input, bindings, callback) {
                // throw if the expression compiled with syntax errors
                if(typeof errors !== 'undefined') {
                    var err = {
                        code: 'S0500',
                        position: 0
                    };
                    err.message = lookupMessage(err);
                    throw err;
                }

                if (typeof bindings !== 'undefined') {
                    var exec_env;
                    // the variable bindings have been passed in - create a frame to hold these
                    exec_env = createFrame(environment);
                    for (var v in bindings) {
                        exec_env.bind(v, bindings[v]);
                    }
                } else {
                    exec_env = environment;
                }
                // put the input document into the environment as the root object
                exec_env.bind('$', input);

                // capture the timestamp and put it in the execution environment
                // the $now() and $millis() functions will return this value - whenever it is called
                timestamp = new Date();

                var result, it;
                // if a callback function is supplied, then drive the generator in a promise chain
                if(typeof callback === 'function') {
                    exec_env.bind('__jsonata_async', true);
                    var thenHandler = function (response) {
                        result = it.next(response);
                        if (result.done) {
                            callback(null, result.value);
                        } else {
                            result.value.then(thenHandler)
                                .catch(function (err) {
                                    err.message = lookupMessage(err);
                                    callback(err, null);
                                });
                        }
                    };
                    it = evaluate(ast, input, exec_env);
                    result = it.next();
                    result.value.then(thenHandler);
                } else {
                    // no callback function - drive the generator to completion synchronously
                    try {
                        it = evaluate(ast, input, exec_env);
                        result = it.next();
                        while (!result.done) {
                            result = it.next(result.value);
                        }
                        return result.value;
                    } catch (err) {
                        // insert error message into structure
                        err.message = lookupMessage(err);
                        throw err;
                    }
                }
            },
            assign: function (name, value) {
                environment.bind(name, value);
            },
            registerFunction: function(name, implementation, signature) {
                var func = defineFunction(implementation, signature);
                environment.bind(name, func);
            },
            ast: function() {
                return ast;
            },
            errors: function() {
                return errors;
            }
        };
    }

    jsonata.parser = parser; // TODO remove this in a future release - use ast() instead

    return jsonata;

})();

// node.js only - export the jsonata and parser functions
// istanbul ignore else
if(typeof module !== 'undefined') {
    module.exports = jsonata;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],65:[function(require,module,exports){
(function (process){
'use strict';

var loglevel = require('loglevel');
var chalk = require('chalk');

var loggers = {};

module.exports = getLogger;

function getLogger() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$level = _ref.level,
      level = _ref$level === undefined ? getDefaultLevel() : _ref$level,
      _ref$prefix = _ref.prefix,
      prefix = _ref$prefix === undefined ? '' : _ref$prefix;

  if (loggers[prefix]) {
    return loggers[prefix];
  }
  var coloredPrefix = prefix ? `${chalk.dim(prefix)} ` : '';
  var levelPrefix = {
    TRACE: chalk.dim('[TRACE]'),
    DEBUG: chalk.cyan('[DEBUG]'),
    INFO: chalk.blue('[INFO]'),
    WARN: chalk.yellow('[WARN]'),
    ERROR: chalk.red('[ERROR]')
  };

  var logger = loglevel.getLogger(`${prefix}-logger`);

  // this is the plugin "api"
  var originalFactory = logger.methodFactory;
  logger.methodFactory = methodFactory;

  var originalSetLevel = logger.setLevel;
  logger.setLevel = setLevel;
  logger.setLevel(level);
  loggers[prefix] = logger;
  return logger;

  function methodFactory() {
    for (var _len = arguments.length, factoryArgs = Array(_len), _key = 0; _key < _len; _key++) {
      factoryArgs[_key] = arguments[_key];
    }

    var logLevel = factoryArgs[0];

    var rawMethod = originalFactory.apply(undefined, factoryArgs);
    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return rawMethod.apply(undefined, [`${coloredPrefix}${levelPrefix[logLevel.toUpperCase()]}:`].concat(args));
    };
  }

  function setLevel(levelToSetTo) {
    var persist = false; // uses browser localStorage
    return originalSetLevel.call(logger, levelToSetTo, persist);
  }
}

function getDefaultLevel() {
  var logLevel = process.env.LOG_LEVEL;

  if (logLevel === 'undefined' || !logLevel) {
    return 'warn';
  }
  return logLevel;
}
}).call(this,require('_process'))

},{"_process":3,"chalk":56,"loglevel":66}],66:[function(require,module,exports){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (typeof define === 'function' && define.amd) {
        define(definition);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = definition();
    } else {
        root.log = definition();
    }
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));

},{}],67:[function(require,module,exports){
(function (global){
var performance = global.performance || {};

var present = (function () {
  var names = ['now', 'webkitNow', 'msNow', 'mozNow', 'oNow'];
  while (names.length) {
    var name = names.shift();
    if (name in performance) {
      return performance[name].bind(performance);
    }
  }

  var dateNow = Date.now || function () { return new Date().getTime(); };
  var navigationStart = (performance.timing || {}).navigationStart || dateNow();
  return function () {
    return dateNow() - navigationStart;
  };
}());

present.performanceNow = performance.now;
present.noConflict = function () {
  performance.now = present.performanceNow;
};
present.conflict = function () {
  performance.now = present;
};
present.conflict();

module.exports = present;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],68:[function(require,module,exports){
// Export ./lib/randgen

module.exports = require("./lib/randgen");

},{"./lib/randgen":69}],69:[function(require,module,exports){
/*jslint indent: 2, plusplus: true, sloppy: true */
// Generate uniformly distributed random numbers
// Gives a random number on the interval [min, max).
// If discrete is true, the number will be an integer.
function runif(min, max, discrete) {
  if (min === undefined) {
    min = 0;
  }
  if (max === undefined) {
    max = 1;
  }
  if (discrete === undefined) {
    discrete = false;
  }
  if (discrete) {
    return Math.floor(runif(min, max, false));
  }
  return Math.random() * (max - min) + min;
}

// Generate normally-distributed random nubmers
// Algorithm adapted from:
// http://c-faq.com/lib/gaussian.html
function rnorm(mean, stdev) {
  var u1, u2, v1, v2, s;
  if (mean === undefined) {
    mean = 0.0;
  }
  if (stdev === undefined) {
    stdev = 1.0;
  }
  if (rnorm.v2 === null) {
    do {
      u1 = Math.random();
      u2 = Math.random();

      v1 = 2 * u1 - 1;
      v2 = 2 * u2 - 1;
      s = v1 * v1 + v2 * v2;
    } while (s === 0 || s >= 1);

    rnorm.v2 = v2 * Math.sqrt(-2 * Math.log(s) / s);
    return stdev * v1 * Math.sqrt(-2 * Math.log(s) / s) + mean;
  }

  v2 = rnorm.v2;
  rnorm.v2 = null;
  return stdev * v2 + mean;
}

rnorm.v2 = null;

// Generate Chi-square distributed random numbers
function rchisq(degreesOfFreedom) {
  if (degreesOfFreedom === undefined) {
    degreesOfFreedom = 1;
  }
  var i, z, sum = 0.0;
  for (i = 0; i < degreesOfFreedom; i++) {
    z = rnorm();
    sum += z * z;
  }

  return sum;
}

// Generate Poisson distributed random numbers
function rpoisson(lambda) {
  if (lambda === undefined) {
    lambda = 1;
  }
  var l = Math.exp(-lambda),
    k = 0,
    p = 1.0;
  do {
    k++;
    p *= Math.random();
  } while (p > l);

  return k - 1;
}

// Generate Cauchy distributed random numbers
function rcauchy(loc, scale) {
  if (loc === undefined) {
    loc = 0.0;
  }
  if (scale === undefined) {
    scale = 1.0;
  }
  var n2, n1 = rnorm();
  do {
    n2 = rnorm();
  } while (n2 === 0.0);

  return loc + scale * n1 / n2;
}

// Bernoulli distribution: gives 1 with probability p
function rbernoulli(p) {
  return Math.random() < p ? 1 : 0;
}

// Vectorize a random generator
function vectorize(generator) {
  return function () {
    var n, result, i, args;
    args = [].slice.call(arguments)
    n = args.shift();
    result = [];
    for (i = 0; i < n; i++) {
      result.push(generator.apply(this, args));
    }
    return result;
  };
}

// Generate a histogram from a list of numbers
function histogram(data, binCount) {
  binCount = binCount || 10;

  var bins, i, scaled,
    max = Math.max.apply(this, data),
    min = Math.min.apply(this, data);

  // edge case: max == min
  if (max === min) {
    return [data.length];
  }

  bins = [];

  // zero each bin
  for (i = 0; i < binCount; i++) {
    bins.push(0);
  }

  for (i = 0; i < data.length; i++) {
    // scale it to be between 0 and 1
    scaled = (data[i] - min) / (max - min);

    // scale it up to the histogram size
    scaled *= binCount;

    // drop it in a bin
    scaled = Math.floor(scaled);

    // edge case: the max
    if (scaled === binCount) { scaled--; }

    bins[scaled]++;
  }

  return bins;
}

/**
 * Get a random element from a list
 */
function rlist(list) {
  return list[runif(0, list.length, true)];
}

exports.runif = runif;
exports.rnorm = rnorm;
exports.rchisq = rchisq;
exports.rpoisson = rpoisson;
exports.rcauchy = rcauchy;
exports.rbernoulli = rbernoulli;
exports.rlist = rlist;

exports.rvunif = vectorize(runif);
exports.rvnorm = vectorize(rnorm);
exports.rvchisq = vectorize(rchisq);
exports.rvpoisson = vectorize(rpoisson);
exports.rvcauchy = vectorize(rcauchy);
exports.rvbernoulli = vectorize(rbernoulli);
exports.rvlist = vectorize(rlist);

exports.histogram = histogram;

},{}],70:[function(require,module,exports){
'use strict';
var ansiRegex = require('ansi-regex')();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};

},{"ansi-regex":53}],71:[function(require,module,exports){
/* jshint node: true */
"use strict";
function makeArrayFrom(obj) {
  return Array.prototype.slice.apply(obj);
}
var
  PENDING = "pending",
  RESOLVED = "resolved",
  REJECTED = "rejected";

function SynchronousPromise(handler) {
  this.status = PENDING;
  this._continuations = [];
  this._parent = null;
  this._paused = false;
  if (handler) {
    handler.call(
      this,
      this._continueWith.bind(this),
      this._failWith.bind(this)
    );
  }
}

function looksLikeAPromise(obj) {
  return obj && typeof (obj.then) === "function";
}

SynchronousPromise.prototype = {
  then: function (nextFn, catchFn) {
    var next = SynchronousPromise.unresolved()._setParent(this);
    if (this._isRejected()) {
      if (this._paused) {
        this._continuations.push({
          promise: next,
          nextFn: nextFn,
          catchFn: catchFn
        });
        return next;
      }
      if (catchFn) {
        try {
          var catchResult = catchFn(this._error);
          if (looksLikeAPromise(catchResult)) {
            this._chainPromiseData(catchResult, next);
            return next;
          } else {
            return SynchronousPromise.resolve(catchResult)._setParent(this);
          }
        } catch (e) {
          return SynchronousPromise.reject(e)._setParent(this);
        }
      }
      return SynchronousPromise.reject(this._error)._setParent(this);
    }
    this._continuations.push({
      promise: next,
      nextFn: nextFn,
      catchFn: catchFn
    });
    this._runResolutions();
    return next;
  },
  catch: function (handler) {
    if (this._isResolved()) {
      return SynchronousPromise.resolve(this._data)._setParent(this);
    }
    var next = SynchronousPromise.unresolved()._setParent(this);
    this._continuations.push({
      promise: next,
      catchFn: handler
    });
    this._runRejections();
    return next;
  },
  pause: function () {
    this._paused = true;
    return this;
  },
  resume: function () {
    var firstPaused = this._findFirstPaused();
    if (firstPaused) {
      firstPaused._paused = false;
      firstPaused._runResolutions();
      firstPaused._runRejections();
    }
    return this;
  },
  _findAncestry: function () {
    return this._continuations.reduce(function (acc, cur) {
      if (cur.promise) {
        var node = {
          promise: cur.promise,
          children: cur.promise._findAncestry()
        };
        acc.push(node);
      }
      return acc;
    }, []);
  },
  _setParent: function (parent) {
    if (this._parent) {
      throw new Error("parent already set");
    }
    this._parent = parent;
    return this;
  },
  _continueWith: function (data) {
    var firstPending = this._findFirstPending();
    if (firstPending) {
      firstPending._data = data;
      firstPending._setResolved();
    }
  },
  _findFirstPending: function () {
    return this._findFirstAncestor(function (test) {
      return test._isPending && test._isPending();
    });
  },
  _findFirstPaused: function () {
    return this._findFirstAncestor(function (test) {
      return test._paused;
    });
  },
  _findFirstAncestor: function (matching) {
    var test = this;
    var result;
    while (test) {
      if (matching(test)) {
        result = test;
      }
      test = test._parent;
    }
    return result;
  },
  _failWith: function (error) {
    var firstRejected = this._findFirstPending();
    if (firstRejected) {
      firstRejected._error = error;
      firstRejected._setRejected();
    }
  },
  _takeContinuations: function () {
    return this._continuations.splice(0, this._continuations.length);
  },
  _runRejections: function () {
    if (this._paused || !this._isRejected()) {
      return;
    }
    var
      error = this._error,
      continuations = this._takeContinuations(),
      self = this;
    continuations.forEach(function (cont) {
      if (cont.catchFn) {
        var catchResult = cont.catchFn(error);
        self._handleUserFunctionResult(catchResult, cont.promise);
      } else {
        cont.promise.reject(error);
      }
    });
  },
  _runResolutions: function () {
    if (this._paused || !this._isResolved()) {
      return;
    }
    var continuations = this._takeContinuations();
    if (looksLikeAPromise(this._data)) {
      return this._handleWhenResolvedDataIsPromise(this._data);
    }
    var data = this._data;
    var self = this;
    continuations.forEach(function (cont) {
      if (cont.nextFn) {
        try {
          var result = cont.nextFn(data);
          self._handleUserFunctionResult(result, cont.promise);
        } catch (e) {
          self._handleResolutionError(e, cont);
        }
      } else if (cont.promise) {
        cont.promise.resolve(data);
      }
    });
  },
  _handleResolutionError: function (e, continuation) {
    this._setRejected();
    if (continuation.catchFn) {
      try {
        continuation.catchFn(e);
        return;
      } catch (e2) {
        e = e2;
      }
    }
    if (continuation.promise) {
      continuation.promise.reject(e);
    }
  },
  _handleWhenResolvedDataIsPromise: function (data) {
    var self = this;
    return data.then(function (result) {
      self._data = result;
      self._runResolutions();
    }).catch(function (error) {
      self._error = error;
      self._setRejected();
      self._runRejections();
    });
  },
  _handleUserFunctionResult: function (data, nextSynchronousPromise) {
    if (looksLikeAPromise(data)) {
      this._chainPromiseData(data, nextSynchronousPromise);
    } else {
      nextSynchronousPromise.resolve(data);
    }
  },
  _chainPromiseData: function (promiseData, nextSynchronousPromise) {
    promiseData.then(function (newData) {
      nextSynchronousPromise.resolve(newData);
    }).catch(function (newError) {
      nextSynchronousPromise.reject(newError);
    });
  },
  _setResolved: function () {
    this.status = RESOLVED;
    if (!this._paused) {
      this._runResolutions();
    }
  },
  _setRejected: function () {
    this.status = REJECTED;
    if (!this._paused) {
      this._runRejections();
    }
  },
  _isPending: function () {
    return this.status === PENDING;
  },
  _isResolved: function () {
    return this.status === RESOLVED;
  },
  _isRejected: function () {
    return this.status === REJECTED;
  }
};

SynchronousPromise.resolve = function (result) {
  return new SynchronousPromise(function (resolve, reject) {
    if (looksLikeAPromise(result)) {
      result.then(function (newResult) {
        resolve(newResult);
      }).catch(function (error) {
        reject(error);
      });
    } else {
      resolve(result);
    }
  });
};

SynchronousPromise.reject = function (result) {
  return new SynchronousPromise(function (resolve, reject) {
    reject(result);
  });
};

SynchronousPromise.unresolved = function () {
  return new SynchronousPromise(function (resolve, reject) {
    this.resolve = resolve;
    this.reject = reject;
  });
};

SynchronousPromise.all = function () {
  var args = makeArrayFrom(arguments);
  if (Array.isArray(args[0])) {
    args = args[0];
  }
  if (!args.length) {
    return SynchronousPromise.resolve([]);
  }
  return new SynchronousPromise(function (resolve, reject) {
    var
      allData = [],
      numResolved = 0,
      doResolve = function () {
        if (numResolved === args.length) {
          resolve(allData);
        }
      },
      rejected = false,
      doReject = function (err) {
        if (rejected) {
          return;
        }
        rejected = true;
        reject(err);
      };
    args.forEach(function (arg, idx) {
      SynchronousPromise.resolve(arg).then(function (thisResult) {
        allData[idx] = thisResult;
        numResolved += 1;
        doResolve();
      }).catch(function (err) {
        doReject(err);
      });
    });
  });
};

/* jshint ignore:start */
if (Promise === SynchronousPromise) {
  throw new Error("Please use SynchronousPromise.installGlobally() to install globally");
}
var RealPromise = Promise;
SynchronousPromise.installGlobally = function(__awaiter) {
  if (Promise === SynchronousPromise) {
    return __awaiter;
  } 
  var result = patchAwaiterIfRequired(__awaiter);
  Promise = SynchronousPromise;
  return result;
};

SynchronousPromise.uninstallGlobally = function() {
  if (Promise === SynchronousPromise) {
    Promise = RealPromise;
  }
};

function patchAwaiterIfRequired(__awaiter) {
  if (typeof(__awaiter) === "undefined" || __awaiter.__patched) {
    return __awaiter;
  }
  var originalAwaiter = __awaiter;
  __awaiter = function() {
    var Promise = RealPromise;
    originalAwaiter.apply(this, makeArrayFrom(arguments));
  };
  __awaiter.__patched = true;
  return __awaiter;
}
/* jshint ignore:end */

module.exports = {
  SynchronousPromise: SynchronousPromise
};
},{}],72:[function(require,module,exports){
"use strict";

// Plugin to add 'property' (as in personal property) property to Players when they are initialized. Meant to be used for
// simulations involving personal posessions, for instance economic simulations.

// NashJS engine components
var Engine = require("../lib/engine")

// Game state
var { registry, gamePopulation } = Engine.Backend.State;

// Let's add some PlayerList functionality
var { PlayerList } = Engine.Backend.Classes;


var BalanceSheet = function() {

	// Variables to store settings, and defaults
	var settings = {
		addBalanceSheetOnClaim: true,
		cleanZeros: true,
		negativeAssets: false
	}
	//TODO make negativeAssets (and negativeLiabilities) work


	// Assets Classes

	// Claim parent class
	var Claim = function(claimant, amount) {
		// Add balance sheet if necessary and permitted
		if (!claimant.balanceSheet) {
			if (settings.addBalanceSheetOnClaim) addEntries(registry.players[claimant.id()])
			// Fail if not permitted to add necessary balance sheet.
			else return false;
		}

		this.amount = amount;
		this.claimant = claimant
		claimant.endow(this)
		return true;
	}

	// End ownership claim
	Claim.prototype.erase = function() {
		this.claimant.revoke(this)
		this.claimant = null;
		this.amount = 0
	}

	// Merge claims if they're the same family but different amounts
	Claim.prototype.merge = function(otherClaim) {
		if (this.claimant !== otherClaim.claimant) return false
		// Add amounts
		this.amount = this.amount + otherClaim.amount

		// Remove from balance sheet
		otherClaim.erase();
	}

	// Split this into two separate claims, with different amounts
	Claim.prototype.split = function(newAmount) {
		var clone = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
		clone.amount = newAmount;
		this.amount = this.amount - newAmount;
		this.claimant.endow(clone, false)
		return clone;
	}

	// Transfer to new owner
	Claim.prototype.transfer = function(newClaimant, amount = "all") {
		// Add balance sheet if necessary and permitted
		if (!newClaimant.balanceSheet) {
			if (settings.addBalanceSheetOnClaim) addEntries(registry.players[newClaimant.id()])
			// Fail if not permitted to add necessary balance sheet.
			else return false;
		}

		// Transfer all of it
		if (amount == "all" || amount == this.amount) {
			var oldClaimant = this.claimant;
			this.claimant.revoke(this);
			this.claimant = newClaimant;
			newClaimant.endow(this);

		}
		// or only a portion
		else {
			var newClaim = this.split(amount);
			newClaim.transfer(newClaimant, "all")
			cleanAsset(this)
		}

	}



	// Claims on real things (like cars, houses, gold)
	var RealClaim = function(claimant, good, amount) {
		if (!Claim.call(this, claimant, amount)) return false;
		this.good = good;
	}
	RealClaim.prototype = Object.create(Claim.prototype)
	RealClaim.prototype.constructor = RealClaim

	// Lose value by percentage
	RealClaim.prototype.depreciate = function(rate = .1) {
		this.amount = this.amount * (1 - rate)
	}

	// Add good enforcement to merge
	RealClaim.prototype.merge = function(otherClaim) {
		if (this.good === otherClaim.good) return Claim.prototype.merge.call(this, otherClaim);
	}

	// Replace player object with id when stringifying
	RealClaim.prototype.toJSON = function() {
		return {
			claimant: this.claimant.id(),
			good: this.good,
			amount: this.amount
		}
	}

	// Claims on other entities with balance sheets
	var FinancialClaim = function(claimant, claimed, amount, instrument = "Debt") {
		// Add balance sheet if necessary and permitted
		if (!claimed.balanceSheet) {
			if (settings.addBalanceSheetOnClaim) addEntries(registry.players[claimed.id()])
			// Fail if not permitted to add necessary balance sheet.
			else return false;
		}
		this.claimed = claimed;
		this.instrument = instrument;

		if (!Claim.call(this, claimant, amount)) return false;

		claimed.indebt(this)
	}
	FinancialClaim.prototype = Object.create(Claim.prototype)
	FinancialClaim.prototype.constructor = FinancialClaim

	// Add to erase function, to erase from claimed's balance sheet too
	FinancialClaim.prototype.erase = function() {
		var bs = registry.players[this.claimed.id()].balanceSheet.liabilities
		bs.splice(bs.indexOf(this), 1)
		this.claimed = null;

		return Claim.prototype.erase.call(this)
	}

	// Add claimed enforcement to merge
	FinancialClaim.prototype.merge = function(otherClaim) {
		if (this.claimed === otherClaim.claimed) return Claim.prototype.merge.call(this, otherClaim);
	}


	// Add to split function, to split on claimed's balance sheet too
	FinancialClaim.prototype.split = function(newAmount) {
		var clone = Claim.prototype.split.call(this, newAmount);
		clone.claimed.indebt(clone, false);
		return clone;
	}

	// Replace player object with id when stringifying
	FinancialClaim.prototype.toJSON = function() {
		return {
			claimant: this.claimant.id(),
			claimed: this.claimed.id(),
			instrument: this.instrument,
			amount: this.amount
		}
	}


	// Clean the similar claims on the claimant supplied
	var cleanAsset = function(claim) {
		var bs = registry.players[claim.claimant.id()].balanceSheet.assets;

		var dirty = bs.filter(function(entry) {
			return (entry !== claim && entry.good === claim.good && entry.instrument === claim.instrument);
		})

		dirty.forEach(function(dirt) {
			claim.merge(dirt)
		})

		if (settings.cleanZeros && claim.amount == 0) claim.erase()
	}

	var cleanLiability = function(claim) {
		var bs = registry.players[claim.claimed.id()].balanceSheet.liabilities;

		var dirty = bs.filter(function(entry) {
			return (entry !== claim && entry.claimant === claim.claimant && entry.instrument === claim.instrument);
		})

		dirty.forEach(function(dirt) {
			claim.merge(dirt)
		})

		if (settings.cleanZeros && claim.amount == 0) claim.erase
	}



	// Add balance sheet object and methods to player.
	var addEntries = function(player) {

		//_player properties/methods
		player.balanceSheet = { assets: [], liabilities: [] }

		/*
		var lookup = function(type) {
			this.reduce(function(accumulator, value) {
				if (type === value.good) accumulator += value.amount
				else if (type instanceof Object && type.instrument == value.instrument && (type.claimed === value.claimed))
					accumulator += value.amount
				return accumulator;
			}, 0)
		}
		player.balanceSheet.assets.lookup = lookup;
		player.balanceSheet.liabilities.lookup = lookup;
		*/

		player.netWorth = function() {

			var assets = this.balanceSheet.assets.reduce(function(accumulator, currentValue) {
				return accumulator + currentValue.amount
			}, 0);

			var liabilities = this.balanceSheet.liabilities.reduce(function(accumulator,
				currentValue) {
				return accumulator + currentValue.amount
			}, 0);

			return assets - liabilities;
		}

		// User interface
		player.interface.balanceSheet = function() {
			return JSON.parse(JSON.stringify(registry.players[player.id].balanceSheet));
		}

		player.interface.netWorth = function() {
			return registry.players[player.id].netWorth();
		}

		// TODO validate object.
		player.interface.endow = function(asset, clean = true) {
			if (asset instanceof Claim) {
				registry.players[player.id].balanceSheet.assets.push(asset);
				if (clean) cleanAsset(asset);
			}
		}

		player.interface.indebt = function(liability, clean = true) {
			if (liability instanceof FinancialClaim) {
				registry.players[player.id].balanceSheet.liabilities.push(
					liability);
				if (clean) cleanLiability(liability);
			}
		}

		player.interface.revoke = function(asset) {
			if (asset instanceof Claim) {
				var bs = registry.players[player.id].balanceSheet.assets
				bs.splice(bs.indexOf(asset), 1)
			}
		}

		// TODO convert this over
		player.interface.lend = function(borrower, amount, instrument = "Debt") {
			return new FinancialClaim(player.interface, borrower, amount, instrument)
		}
	}



	// The plugin object.
	var Plugin = {
		name: "balance-sheet-complex",

		settings: function(parameters = {}) {
			Object.assign(settings, parameters)
		},

		// Option to initialize by creating 'property' for a group of players.
		init(players = []) {
			// Add some playerlist functionality
			PlayerList.prototype.balanceSheets = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet();
					else return null;
				})
			};

			PlayerList.prototype.assets = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet().assets;
					else return null;
				})
			};

			PlayerList.prototype.liabilities = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet().liabilities;
					else return null;
				})
			};

			PlayerList.prototype.netWorth = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.netWorth();
					else return null;
				})
			};

			PlayerList.prototype.zeroBalanceSheets = function() {
				this.forEach(function(player) {
					addEntries(player)
				});
				return this;
			}

			// Add bs for specified players
			players.forEach(function(player) {
				addEntries(registry.players[player.id()]);
			})
		},

		// If we've init-ed alredy, just add bs's to the current player list if they don't have already
		require(players = []) {
			players.forEach(function(player) {
				if (!player.balanceSheet) addEntries(registry.players[player.id()]);
			});
		},

		stop() {
			// remove prototype addEntries
			delete PlayerList.prototype.balanceSheets;
			delete PlayerList.prototype.assets;
			delete PlayerList.prototype.liabilities;
			delete PlayerList.prototype.netWorth;

			// delete balance sheet properties from every player and interface.
			gamePopulation().forEach(function(player) {
				delete player.balanceSheet;
				delete player.netWorth;
				delete player.interface.balanceSheet;
				delete player.interface.netWorth;
				delete player.interface.endowAssets;
				delete player.interface.lend;
			})
		},

		// Public classes for asset/liability
		publicIfActive: {
			RealClaim,
			FinancialClaim
		},

		// create property and interface function when player is created
		'player-create': addEntries,

		// Blank property when player is re-initialized
		"player-reinitialize" (player) {
			player.balanceSheet = { assets: [], liabilities: [] }
		}
	}

	return Plugin;
}



module.exports = BalanceSheet;

},{"../lib/engine":6}],73:[function(require,module,exports){
"use strict";

// Plugin to add 'property' (as in personal property) property to Players when they are initialized. Meant to be used for
// simulations involving personal posessions, for instance economic simulations.

// NashJS engine components
var Engine = require("../lib/engine")

// Game state
var { registry, gamePopulation } = Engine.Backend.State;

// Let's add some PlayerList functionality
var { PlayerList } = Engine.Backend.Classes;


var BalanceSheet = function() {

	var addEntries = function(player) {
		//_player properties/methods
		player.balanceSheet = { assets: {}, liabilities: {} }

		player.netWorth = function() {

			var assets = Object.entries(this.balanceSheet.assets).reduce(function(accumulator, currentValue) {
				return accumulator + currentValue[1]
			}, 0);

			var liabilities = Object.entries(this.balanceSheet.liabilities).reduce(function(accumulator,
				currentValue) {
				return accumulator + currentValue[1]
			}, 0);

			return assets - liabilities;
		}

		// User interface
		player.interface.balanceSheet = function() {
			return JSON.parse(JSON.stringify(registry.players[player.id].balanceSheet));
		}

		player.interface.netWorth = function() {
			return registry.players[player.id].netWorth();
		}

		// TODO validate object. Should be of form {apples:2, dogs:1}
		player.interface.endowAssets = function(assetObject) {

			Object.assign(registry.players[player.id].balanceSheet.assets, assetObject)
		}

		player.interface.lend = function(loanObject) {
			//TODO validate object. Should be of form {player1:{mortgage:10}}
			var lender = registry.players[player.id].balanceSheet.assets
			Object.entries(loanObject).forEach(function(loanTo) {
				var debts;
				lender[loanTo[0]] ?
					debts = lender[loanTo[0]] : debts = lender[loanTo[0]] = {};

				Object.entries(loanTo[1]).forEach(function(newLoan) {
					debts[newLoan[0]] ? debts[newLoan[0]] += newLoan[1] : debts[newLoan[0]] = newLoan[1]
					registry.players[loanTo[0]].balanceSheet.liabilities[newLoan[0]] ? registry.players[loanTo[0]].balanceSheet
						.liabilities[newLoan[0]] += newLoan[1] : registry.players[loanTo[0]].balanceSheet.liabilities[
							newLoan[0]] = newLoan[1];
				});
			});
		}
	}



	// The plugin object.
	var Plugin = {
		name: "balance-sheet",

		// Option to initialize by creating 'property' for a group of players.
		init(players = []) {
			// Add some playerlist functionality
			PlayerList.prototype.balanceSheets = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet();
					else return null;
				})
			};

			PlayerList.prototype.assets = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet().assets;
					else return null;
				})
			};

			PlayerList.prototype.liabilities = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet().liabilities;
					else return null;
				})
			};

			PlayerList.prototype.netWorth = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.netWorth();
					else return null;
				})
			};

			PlayerList.prototype.zeroBalanceSheets = function() {
				this.forEach(function(player) {
					addEntries(player)
				});
				return this;
			}

			// Add bs for specified players
			players.forEach(function(player) {
				addEntries(registry.players[player.id()]);
			})
		},

		// If we've init-ed alredy, just add bs's to the current player list if they don't have already
		require(players = []) {
			players.forEach(function(player) {
				if (!player.balanceSheet) addEntries(registry.players[player.id()]);
			});
		},

		stop() {
			// remove prototype addEntries
			delete PlayerList.prototype.balanceSheets;
			delete PlayerList.prototype.assets;
			delete PlayerList.prototype.liabilities;
			delete PlayerList.prototype.netWorth;

			// delete balance sheet properties from every player and interface.
			gamePopulation().forEach(function(player) {
				delete player.balanceSheet;
				delete player.netWorth;
				delete player.interface.balanceSheet;
				delete player.interface.netWorth;
				delete player.interface.endowAssets;
				delete player.interface.lend;
			})
		},

		// create property and interface function when player is created
		'player-create': addEntries,

		// Blank property when player is re-initialized
		"player-reinitialize" (player) {
			player.balanceSheet = { assets: [], liabilities: [] }
		}
	}

	return Plugin;
}


module.exports = BalanceSheet;

},{"../lib/engine":6}],74:[function(require,module,exports){
"use strict";

// game pieces
var prisonerDilemma = require("./iterated-prisoner-dilemma").createGenerator;
var roundRobin = require("./round-robin");

// NashJS engine components
var Engine = require("../lib/engine")

var { Loop } = Engine.Frontend.Playables;

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")
var { generatePopulation } = Engine.Backend.HelperFunctions("tournament");

// Population interfaces
var { Population } = Engine.Frontend.Population;


var AxelrodTournament = gameWrapper(function(players, parameters = {}) {
	var { generatePlayers = true, repeats = 5, gameLength = 200 } = parameters;

	// Either create an entire population
	if (generatePlayers) {
		// Get two sets of players. The second is so players can play themselves
		players = generatePopulation();
		var copies = generatePopulation();
		parameters.copies = copies;
	}

	// or use the supplied players
	else if (players) {
		// do nothing
	} else {
		// or use the players already present
		players = Population().onlyAlive().onlyAvailable();
	}

	// assign parameters and generate the game
	parameters.initializePlayers = players;
	var iteration = roundRobin(players, prisonerDilemma(gameLength), parameters);

	return Loop(iteration, repeats, { id: "Axelrod-Tournament" });
});



module.exports = AxelrodTournament;

},{"../lib/engine":6,"./iterated-prisoner-dilemma":79,"./round-robin":85}],75:[function(require,module,exports){
"use strict";

//base game
var TwoPlayerNormal = require("./simple-normal");

// helper functions
var { gameWrapper } = require("../lib/engine").Backend.HelperFunctions("stock-games")


// Battle of the Sexes
var BattleOfTheSexes = gameWrapper(function(players, parameters = {}) {
	parameters.id = parameters.id || "Battle-of-the-Sexes";

	var choices = [
		["Opera", "Football"],
		["Opera", "Football"]
	];
	var payoffs = [
		[
			[2, 1],
			[0, 0]
		],
		[
			[0, 0],
			[1, 2]
		]
	];

	return TwoPlayerNormal(players, choices, payoffs, parameters);
});

module.exports = BattleOfTheSexes;

},{"../lib/engine":6,"./simple-normal":86}],76:[function(require,module,exports){
"use strict";

// NashJS engine components
var Engine = require("../lib/engine")

// User data
var { Population } = Engine.Frontend

// Playables
var { Lambda, Simultaneous, Sequence, Loop } = Engine.Frontend.Playables;

// Helper functions
var { isFunction } = Engine.Backend.HelperFunctions("general");


//Cultural evolution
//
// TODO: add instructions here
function CulturalEvolution(gameGenerator, numLoops = 1, {
	id = "CulturalEvolution",
	gameProbability = .25,
	pairProbability = .25,
	generatePopulation = null,
	loop = true
} = {}) {

	if (loop && isNaN(numLoops)) throw new Error("CulturalEvolution argument 'numLoops must be a number");
	if (!isFunction(gameGenerator)) throw new Error(
		"CulturalEvolution argument 'gameGenerator' must be a function");
	if (isNaN(gameProbability) || gameProbability < 0 || gameProbability > 1) throw new Error(
		"CulturalEvolution argument 'gameProbability' must be between 0 and 1");
	if (isNaN(pairProbability) || pairProbability < 0 || pairProbability > 1) throw new Error(
		"CulturalEvolution argument 'pairProbability' must be between 0 and 1");

	// Generate population if user wants us to.
	if (isFunction(generatePopulation)) generatePopulation();

	//Reset the scores each round.
	var ResetScores = Lambda(function() {
		Population().onlyAlive().resetScores();
	});

	// Calculate number of matches
	var n = Math.floor(Population().onlyAlive().length * gameProbability);

	// Create matches.
	var matches = [...Array(n)]
	for (var i = 0; i < n; i++) {
		matches[i] = gameGenerator();
		if (!matches[i].play) throw new Error("CulturalEvolution argument 'gameGenerator' must return a Playable");
	}

	//Run all matches simultaneously
	var Round = Simultaneous(matches);

	//Calculate number of pairings
	var n = Math.floor(Population().onlyAlive().length * pairProbability)

	//Create pairings
	var pairings = [...Array(n)];
	for (i = 0; i < n; i++) {

		pairings[i] = Lambda(function() {

			//Find some available players
			var pool = Population().onlyAlive().onlyAvailable();
			var p1 = pool[Math.floor(Math.random() * pool.length)];
			var p2 = pool[Math.floor(Math.random() * pool.length)];

			//Mark them busy
			p1.busy();
			p2.busy();

			// Assign strategy of player with higher score
			if (p1.score() > p2.score()) p2.assign(p1.strategy());
			else if (p1.score() == p2.score()) null;
			else p1.assign(p2.strategy());

			//Return value of player ids, so the log makes some sense.
			return [p1.id(), p2.id()];
		});
	}

	// Run pairings simultaneously
	var Pairing = Simultaneous(pairings);

	// After pairings, mark all players as available.
	var ReleasePlayers = Lambda(function() {
		Population().onlyAlive().release();
	});

	// Define the game.
	Round(ResetScores);
	Pairing(Round);
	ReleasePlayers(Pairing);
	var Iteration = Sequence(ResetScores, ReleasePlayers);

	// User can set loop parameter to false, to avoid wrapping this in a loop.
	if (loop)
		var CE = Loop(Iteration, numLoops, { playableParameters: { initializePlayers: true } });
	else
		var CE = Iteration;

	return CE;
}

//TODO: fix parameters. User should be able to supply parameters which either
// end up as parameters for the Loop or the Sequence.


module.exports = CulturalEvolution;

},{"../lib/engine":6}],77:[function(require,module,exports){
"use strict";

// base game
var TwoPlayerNormal = require("./simple-normal").TwoPlayerNormal;

// NashJS engine components
var Engine = require("../lib/engine")

// Nash engine components
var { Sequence, Lambda } = Engine.Frontend.Playables;

// Game state
var { registry } = Engine.Backend.State

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// We'll need the 'balance-sheet' plugin
var PluginManager = Engine.Backend.PluginManager;

function invertTerms(termsOfTrade) {
	var inverse = {}
	Object.entries(termsOfTrade).forEach(function(term) {
		if (term[0] == "borrow") {
			inverse.lend = term[1]
		} else if (term[0] == "lend") {
			inverse.borrow = term[1]
		} else {
			inverse[term[0]] = term[1] * -1
		}
	});
	return inverse;
}

// termsOfTrade should be an object reflecting the outcomes for player 1.
// Example {apple:2, orange:-2}. To borrow or lend, create a sub-object describing the loan terms.
// eg {apple:2, borrow:{IOU:5}}, or {couch:-10, lend:{'credit card':50}}
var Exchange = gameWrapper(function(players, termsOfTrade = {}, parameters = {}) {
	var { utilityFunctions, utilityMode = "absolute", initialEndowment = [{}, {}] } = parameters //utilityFunctions should be an array of 2 functions, which take a results object and return a change in utility
	parameters.id = "Exchange" || parameters.id;




	// To play this game, players will need a balance sheet. This plugin will add balance sheets to the players,
	// as well as ensure that new players are created with one, and that they are re-initialized properly.
	var balanceSheet = PluginManager.package("balance-sheet-complex").require(players);
	balanceSheet.settings({ cleanZeros: false })

	var p1 = registry.players[players[0].id()];
	var p2 = registry.players[players[1].id()];

	// Do initial endowments if there are any. Format same as for terms of trade.
	initialEndowment.forEach(function(endowment, index) {
		var player = players[index]
		var invertPlayer = players[Number(!index)]
		Object.entries(endowment).forEach(function(term) {
			if (term[0] == "borrow") {
				var loanTerms = Object.entries(term[1])[0]
				new balanceSheet.FinancialClaim(invertPlayer, player, loanTerms[1], loanTerms[0])
			} else if (term[0] == "lend") {
				var loanTerms = Object.entries(term[1])[0]
				new balanceSheet.FinancialClaim(player, invertPlayer, loanTerms[1], loanTerms[0])
			} else {
				new balanceSheet.RealClaim(player, term[0], term[1])
			}
		})
	})

	// The actual playable
	var Decision = TwoPlayerNormal(players, [
		["Accept", "Reject"],
		["Accept", "Reject"]
	], null, {
		id: "Decision",
		informationFilter: function(info) { //TODO might need to wrap user-supplied informationFilter?
			info.termsOfTrade = {
				[p1.id]: termsOfTrade,
				[p2.id]: invertTerms(termsOfTrade)
			}
			return info;
		}
	})

	// Distribute the goods
	var Distribute = Lambda(function() {

		var results = [];

		Object.entries(termsOfTrade).forEach(function(term) {
			if (term[0] == "borrow") {
				var loanTerms = Object.entries(term[1])[0]
				var loan = new balanceSheet.FinancialClaim(p2.interface, p1.interface, loanTerms[1], loanTerms[0])

				results.push({
					player: p1.id,
					borrow: {
						[loanTerms[0]]: loanTerms[1]
					}
				});

				results.push({
					player: p2.id,
					lend: {
						[p1.id]: {
							[loanTerms[0]]: loanTerms[1]
						}
					}
				});

			} else if (term[0] == "lend") {
				var loanTerms = Object.entries(term[1])[0]
				var loan = new balanceSheet.FinancialClaim(p1.interface, p2.interface, loanTerms[1], loanTerms[0])

				results.push({
					player: p2.id,
					borrow: {
						[loanTerms[0]]: loanTerms[1]
					}
				});

				results.push({
					player: p1.id,
					lend: {
						[p2.id]: {
							[loanTerms[0]]: loanTerms[1]
						}
					}
				});

			} else {
				var good = new balanceSheet.RealClaim(p1.interface, term[0], 0)
				good.transfer(p2.interface, term[1] * -1)

				results.push({ player: p1.id, [term[0]]: term[1] });
				results.push({ player: p2.id, [term[0]]: -1 * term[1] });
			}
		});


		if (utilityFunctions) {

			p1.score = utilityMode.toLowerCase() == "relative" ? p1.score + utilityFunctions[0](results) :
				utilityFunctions[0](results)
			p2.score = utilityMode.toLowerCase() == "relative" ? p2.score + utilityFunctions[1](results) :
				utilityFunctions[1](results)
		}

		return results;
	}, { id: "Distribution" });

	//But only do it if the trade goes through.
	Distribute(Decision.Accept.Accept())



	return Sequence(Decision, Distribute, parameters);
}, {
	argumentValidator(players, termsOfTrade) {
		// TODO: validate parameters
		return true;
	}

});

module.exports = Exchange;

},{"../lib/engine":6,"./simple-normal":86}],78:[function(require,module,exports){
"use strict";

// Code for stock game query shortcuts.
var { registry, idCounters } = require("../lib/engine").Backend.State
registry._addType_("queries")
idCounters._addType_("query")



var StockGames = {
	//Game skeletons
	"Two-Player Normal": require("./simple-normal").TwoPlayerNormal,
	"Normal": require("./simple-normal").Normal,
	"Simple Zero-Sum": require("./simple-zero-sum"),

	// Classic games
	"Battle Of The Sexes": require("./battle-of-the-sexes"),
	"Matching Pennies": require("./matching-pennies"),
	"Prisoner's Dilemma": require("./prisoner-dilemma"),
	"Rock-Paper-Scissors": require("./rock-paper-scissors"),

	// Iterated games
	"Iterated": require("./iterated"),
	"Iterated Prisoner's Dilemma": require("./iterated-prisoner-dilemma"),

	// Evolutionary games
	"Cultural Evolution": require("./cultural-evolution"),

	//Tournaments
	"Round Robin": require("./round-robin"),
	"Axelrod Tournament": require("./axelrod-tournament"),

	// Probability Theory
	"Monty Hall": require("./monty-hall"),

	//Neoclassical economics
	"Exchange": require("./exchange-complex"),

	queries() {
		return Object.keys(registry.queries).map(function(query) { return {
				[query]: registry.queries[query].description } })
	}
};



module.exports = StockGames;

},{"../lib/engine":6,"./axelrod-tournament":74,"./battle-of-the-sexes":75,"./cultural-evolution":76,"./exchange-complex":77,"./iterated":80,"./iterated-prisoner-dilemma":79,"./matching-pennies":81,"./monty-hall":82,"./prisoner-dilemma":83,"./rock-paper-scissors":84,"./round-robin":85,"./simple-normal":86,"./simple-zero-sum":87}],79:[function(require,module,exports){
"use strict";

// Base game
var prisonerDilemma = require("./prisoner-dilemma").createGenerator();

// NashJS engine components
var Engine = require("../lib/engine")

// game engine
var { Loop } = Engine.Frontend.Playables;

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// Game utility
var Iterated = require("./iterated")



var IteratedPrisonerDilemma = gameWrapper(function(players, numberIterations = 50, parameters = {}) {
	return Iterated(players, prisonerDilemma, "Prisoner-Dilemma", numberIterations, parameters)
}, {
	queryLoader() {
		return [{
				name: "@IPD-choices",
				query: "$map($.[action].results, function($l){$l.result})",
				description: "Results, organized by round."
			},
			{
				name: "@IPD-players",
				query: "$map($.[action].results, function($l){$l.player})",
				description: "Players, organized by round."
			},
			{
				name: "@IPD-payouts",
				query: "$.action.payouts",
				description: "Payouts, as array of objects."
			}
		]
	},
	strategyLoader() {
		return [{
				name: "Tit For Tat",
				description: "Do whatever your opponent did last turn. Cooperate if this is the first turn.",
				strategy: function titForTat() {
					this.choose = function(choices, information) {
						if (information.opponent.history.length) return information.opponent.history[information.opponent
								.history.length - 1]
							.result
						else return "Cooperate";
					}
				}
			},
			{
				name: "Grudger",
				description: "Cooperate until your opponent doesn't, then Defect.",
				strategy: function grudger() {
					this.cooperating = true

					this.choose = function(choices, information) {

						// If opponent just defected, then stop cooperating
						if (information.opponent.history.length) {
							if (information.opponent.history[information.opponent.history.length - 1].result == "Defect") this
								.cooperating = false;
						}

						if (this.cooperating) return "Cooperate";
						else return "Defect";
					}
				}
			},

			{
				name: "Naive Prober",
				description: "Like Tit For Tat, but occasionally Defects with small probability",
				strategy: function prober(probability = 0.1) {
					this.choose = function(choices, information) {
						if (Math.random() < probability) return "Defect";

						if (information.opponent.history.length) return information.opponent.history[information.opponent
								.history.length - 1]
							.result
						else return "Cooperate";
					}
				}
			},

			{
				name: "Tit For Two Tats",
				description: "Cooperates on the first move, then Defects only when the opponent Defects two times",
				strategy: function TF2T() {
					this.choose = function(choices, information) {
						if (information.opponent.history.length > 1) {
							if (information.opponent.history[information.opponent.history.length - 1].result == "Defect" &&
								information.opponent.history[information.opponent.history.length - 2].result == "Defect") return "Defect";
							else return "Cooperate";
						} else return "Cooperate";
					}
				}
			}

		]
	}
});
// TODO validate arguments

module.exports = IteratedPrisonerDilemma

},{"../lib/engine":6,"./iterated":80,"./prisoner-dilemma":83}],80:[function(require,module,exports){
"use strict";

// NashJS engine components
var Engine = require("../lib/engine")

// game engine
var { Loop } = Engine.Frontend.Playables;

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")


var Iterated = gameWrapper(function(players, gameGenerator, gameName, numberIterations = 50, parameters = {}) {

	var { parameters: gameParameters = {} } = parameters

	gameParameters.id = gameParameters.id || gameName
	parameters.id = parameters.id || "Iterated-" + gameName;

	return Loop(gameGenerator(players, gameParameters), numberIterations, parameters);
})

// TODO validate arguments

module.exports = Iterated;

},{"../lib/engine":6}],81:[function(require,module,exports){
"use strict";

// base game
var SimpleZeroSum = require("./simple-zero-sum");

// NashJS engine components
var Engine = require("../lib/engine")

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// Play-time logic
var { Expression } = Engine.Frontend


var MatchingPennies = gameWrapper(function(players, parameters = {}) {
	parameters.id = parameters.id || "Matching-Pennies";
	payoff = parameters.payoff || 1;

	var win = payoff;
	var lose = Expression(function() {
		return -payoff;
	});

	var choices = [
		["Heads", "Tails"],
		["Heads", "Tails"]
	];

	var payoffs = [
		[win, lose],
		[lose, win]
	];

	return SimpleZeroSum(players, choices, payoffs, parameters);
});

// Matching Pennies
module.exports = MatchingPennies;

},{"../lib/engine":6,"./simple-zero-sum":87}],82:[function(require,module,exports){
"use strict"

// NashJS engine components
var Engine = require("../lib/engine");

// Playables
var { Choice, Lambda } = Engine.Frontend.Playables;

// logic
var { Variable, ComplexVariable } = Engine.Frontend

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games");


var MontyHall = gameWrapper(function(player, parameters = {}) {
	parameters.id = parameters.id || "Monty-Hall"
	var numDoors = parameters.numDoors || 3;
	var numPrizes = parameters.numPrizes || 1;
	var numReveals = parameters.numReveals || 1;
	var prize = parameters.prize || 5;

	// Allow array or single player
	if (Array.isArray(player)) player = player[0]

	//Generate list of doors
	var doors = [];
	for (var i = 0; i < numDoors; i++) {
		doors.push("Door " + i.toString())
	}

	var Choose = Choice(player, doors, { id: "Choose" });


	var prizes
	var scores = Array.apply(null, Array(doors.length)).map(function() {
		return Variable(0)
	})

	//Need to set this here in order for scoring to work
	var doors2 = ComplexVariable(doors.slice());

	var Reveal = Lambda(function({ history }) {

		// Re-initialize payoffs.
		prizes = []
		for (var i = 0; i < scores.length; i++) {
			scores[i].set(0)
		}

		// What door did the player open?
		var playerChoice = history.log.query("$[choice='" + Choose.id() + "'][-1]").result // TODO does this work?

		// Select which doors have prizes
		var revealFrom = doors.slice(); // Copy the doors list
		for (var i = 0; i < numPrizes; i++) {
			var prizeIndex = Math.floor(Math.random() * revealFrom.length) // Select a door from the doors copy
			prizes.push(revealFrom[prizeIndex]) // Add the prize to the lists
			scores[prizeIndex].set(prize) // Set payoffs appropriately
			revealFrom.splice(prizeIndex, 1) // Remove the prized door from the doors copy, so that we don't select it more than once
		}

		//Remove player choice from doors copy
		var playerChoiceIndex = revealFrom.indexOf(playerChoice)
		if (playerChoiceIndex > -1) revealFrom.splice(playerChoiceIndex, 1)

		// Choose doors to reveal
		var reveal = [];
		for (var i = 0; i < numReveals; i++) {
			reveal.push(revealFrom[Math.floor(Math.random()) * revealFrom.length])
		}

		// Copy doors list to send onward, then remove the revealed doors from list
		doors2.set(doors.slice()); // Need to set this here so revealing to work
		for (var i = 0; i < reveal.length; i++) {
			let index = doors2.indexOf(reveal[i])
			doors2().splice(index, 1)
		}

		return reveal.length == 1 ? reveal[0] : reveal;
	}, { id: "Reveal" })

	var SecondChoice = Choice(player, doors2, { id: "Stay-or-Switch", usePayoffs: true });
	SecondChoice.setAllPayoffs(scores)

	Reveal(Choose)
	SecondChoice(Reveal)

	return Sequence(Choose, SecondChoice, parameters);
}, {

	strategyLoader() {
		return [{
				name: "Always Switch",
				description: "Randomly select a door. Then, always switch to a different one.",

				strategy: function alwaysSwitch() {

					this.door = null;

					this.choose = function(options, information) {
						var choice
						if (this.door) {
							options.splice(options.indexOf(this.door), 1)
							this.door = null;
							choice = options[Math.floor(Math.random() * options.length)]
						} else {
							choice = options[Math.floor(Math.random() * options.length)]
							this.door = choice
						}

						return choice
					}
				}
			},
			{
				name: "Always Stay",
				description: "Randomly select a door. Then, always stay with that door.",

				strategy: function alwaysStay() {
					this.door = null;

					//TODO add strategy description feature
					this.choose = function(options, information) {
						var choice
						if (this.door) {
							choice = this.door
							this.door = null;

						} else {
							choice = options[Math.floor(Math.random() * options.length)]
							this.door = choice
						}

						return choice
					}
				}
			}
		]
	}
})

module.exports = MontyHall

},{"../lib/engine":6}],83:[function(require,module,exports){
"use strict";

// base game
var TwoPlayerNormal = require("./simple-normal").TwoPlayerNormal;

//NashJS engine components
var Engine = require("../lib/engine")

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games");

// play-time logic
var { Variable, Expression } = Engine.Frontend;


var prisonerDilemma = gameWrapper(function(players, parameters = {}) {
	parameters.id = parameters.id || "Prisoner-Dilemma";
	var payoffs = parameters.payoffs || [Variable(1), Variable(2), Variable(3), Variable(4)];


	// sort numbers because the wrong order would screw up the game
	payoffs.sort()
	var sucker = payoffs[0]
	var punishment = payoffs[1]
	var reward = payoffs[2]
	var temptation = payoffs[3]


	var choices = [
		["Cooperate", "Defect"],
		["Cooperate", "Defect"]
	];
	var gamePayoffs = [
		[
			[reward, reward],
			[sucker, temptation]
		],
		[
			[temptation, sucker],
			[punishment, punishment]
		]
	];

	return TwoPlayerNormal(players, choices, gamePayoffs, parameters);
});


module.exports = prisonerDilemma;

},{"../lib/engine":6,"./simple-normal":86}],84:[function(require,module,exports){
"use strict";

// base game
var SimpleZeroSum = require("./simple-zero-sum");

var Engine = require("../lib/engine")

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// Play-time logic
var { Expression } = Engine.Frontend


// Rock-Paper-Scissors
var RockPaperScissors = gameWrapper(function(players, parameters = {}) {
	parameters.id = parameters.id || "Rock-Paper-Scissors";
	parameters.payoff = parameters.payoff || 1;

	var win = parameters.payoff;
	var lose = Expression(function() {
		return -payoff;
	});

	var choices = [
		["Rock", "Paper", "Scissors"],
		["Rock", "Paper", "Scissors"]
	];
	var payoffs = [
		[0, lose, win],
		[win, 0, lose],
		[lose, win, 0]
	];

	return SimpleZeroSum(players, choices, payoffs, parameters);
});

module.exports = RockPaperScissors

},{"../lib/engine":6,"./simple-zero-sum":87}],85:[function(require,module,exports){
"use strict";

//NashJS Engine
var Engine = require("../lib/engine")

// helper function
var { shuffle } = Engine.Backend.HelperFunctions("general");
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// nashJS engine component
var { Sequence, Simultaneous } = Engine.Frontend.Playables;

//for information mechanics
var { Information, History, PlayerList } = Engine.Backend.Classes;


// gameGenerator should be a function whose first argument is an array of players
var RoundRobin = gameWrapper(function(players, gameGenerator, parameters = {}) {
	parameters.id = parameters.id || "Round-Robin";
	parameters.initializePlayers = parameters.initializePlayers && true;

	// Create array of each combination of players
	var matches = [];

	players.forEach(function(player1, index1) {
		for (var index2 = 0; index2 < index1; index2++) {
			matches.push([players[index2], player1]);
		}

		// optional parameter 'copies.' Pass an extra copy of each player, to play themselves
		if (parameters.copies) matches.push([parameters.copies[index1], player1]);
	});

	//randomize the order
	shuffle(matches);

	// Track scores
	var scoresRecord = [];

	//
	var addRound = function(players, parameters = {}) {
		// information mechanics and other parameters
		var population = new PlayerList(players).generator
		parameters.compartmentalize = { population }
		parameters.initializePlayers = population;

		// generate round
		var round = gameGenerator(players, parameters);

		// track the scores
		var recordScores = Lambda(function() {
			var score = {}
			for (let [strategy, scores] of Object.entries(population().scoresByStrategy())) {
				if (Array.isArray(scores)) {
					if (scores.length == 1) scores = scores[0]
					score[strategy] = scores;
				}
			}
			scoresRecord.push(score);

			//return score for history
			return score;
		}, { id: "Record-Scores" });

		//Chain together
		recordScores(round);

		// return both
		return [round, recordScores
			// ,Sequence(round, recordScores) // Uncomment for Simultaneous implementation
		];
	};



	// Sequential implementation
	// load the first match manually
	var [firstRound, firstRecord] = addRound(
		matches.shift(),
		parameters.parameters
	);

	//then load subsequent matches
	var record = firstRecord;
	var lastRecord, lastRound;

	matches.forEach(function(match) {
		[lastRound, lastRecord] = addRound(match, parameters.parameters);

		lastRound(record);
		record = lastRecord;
	});


	return Sequence(firstRound, lastRecord, parameters);

	/* // Simultaneous implementation
	var rounds = [];
	matches.forEach(function(match) {
	  rounds.push(addRound(match, parameters.gameParameters)[2]);
	});

	return Simultaneous(rounds, parameters); */
});

module.exports = RoundRobin;

},{"../lib/engine":6}],86:[function(require,module,exports){
"use strict";

//Game engine
var Engine = require("../lib/engine")

//Helper functions
var { isFunction } = Engine.Backend.HelperFunctions("general")
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// Playables
var { Turn, Choice, RandomPlayerChoice } = Engine.Frontend.Playables;

//Play-time Logic
var { RandomVariable } = Engine.Frontend

var Normal = gameWrapper(function(players, choiceLists, payoffs = null, parameters = {}) {

		//propogate the information filter
		parameters.parameters ? parameters.parameters.informationFilter = parameters.informationFilter :
			parameters.parameters = { informationFilter: parameters.informationFilter }

		// construct the choices
		var choices = choiceLists.map(function(list, index) {
			return players == "random" ? RandomPlayerChoice(list, parameters.parameters) : Choice(players[index],
				list, parameters.parameters);
		});

		var game = Turn(choices, parameters);

		if (payoffs) game.setAllPayoffs(payoffs);

		return game;
	}, {
		queryLoader() {
			return [{
					name: "@N-choices",
					query: "$.results{player:result}",
					description: "Players and their choice."
				},
				{
					name: "@N-players",
					query: "$.results.player",
					description: "Who played."
				}
			]
		},
		strategyLoader: function() {
			return [{
					strategy: function chooseFirst() {
						this.choose = function(choices, information) {
							return choices[0]
						}
					},
					name: "Choose First",
					description: "Always choose first available option."
				},

				{
					strategy: function chooseSecond() {
						this.choose = function(choices, information) {
							return choices[1]
						}
					},
					name: "Choose Second",
					description: "Always choose second available option."
				},

				{
					strategy: function randomize(choices = [0, 1]) {
						// Creating a map will make picking a random value easier
						choices = choices.map(function(item, index) {
							return [index, item]
						});
						var choiceMap = new Map(choices)

						this.choose = function(choices, information) {
							return choices[choiceMap.get(Math.floor(Math.random() * choiceMap.size))];
						}
					},
					name: "Randomize",
					description: "Choose randomly from available options."
				}
			];
		}
	} // 										TODO: validate all arguments
);


var TwoPlayerNormal = gameWrapper(function(players, choices, payoffs = null, parameters = {}) {

	// Information mechanics.. There are only two players, so we can have a 'me' and 'opponent' entry.
	// If user supplied an information filter, wrap that filter in ours.
	var { informationFilter } = parameters;
	if (!isFunction(informationFilter)) informationFilter = null;

	// Wrap the user's filter
	var wrappedFilter = function(information) {
		// Figure out who I am and who the opponent is
		var me = information.me.id
		var players = [information.turn.choices[0].choice.player, information.turn.choices[1].choice.player]
		var opponent = players.splice(players.indexOf(me), 1) && players[0];

		// add entry for opponent
		var opponentDetail = information.population.filter(function(player) {
			return (player.id == opponent)
		})[0];
		information.opponent = opponentDetail;

		// run the user's information filter
		if (informationFilter) information = informationFilter(information);

		return information;
	}

	// Pass the information filter
	parameters.informationFilter = wrappedFilter

	return Normal(players, choices, payoffs, parameters)
}); //				 																												TODO: may want to validate arguments here too



module.exports = { TwoPlayerNormal, Normal };

},{"../lib/engine":6}],87:[function(require,module,exports){
"use strict";

// base game
var TwoPlayerNormal = require("./simple-normal").TwoPlayerNormal;

// NashJS components
var Engine = require("../lib/engine")

// Game state controller
var { registry } = Engine.Backend.State
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games");

// Play-time logic
var { Variable, Expression } = Engine.Frontend;

/* beautify preserve:start */
var SimpleZeroSum = gameWrapper(function(players, choices, payoffs = [[0, 0],	[0, 0]], parameters={}) {
/* beautify preserve:end */

	var game = TwoPlayerNormal(players, choices, null, parameters)

	var e;

	choices[0].forEach(function(choice0, index0) {
		choices[1].forEach(function(choice1, index1) {

			// Set expression
			e = Expression(function() {
				//Return the negative payoff, or zero
				return (0 - registry.turns[game.id()].payoffsImplicit[choice0][choice1][0] || 0);
			});

			//Set payoffs
			game[choice0][choice1]([payoffs[index0][index1], e]);
		});
	});

	return game;
}); //					TODO: validate arguments



module.exports = SimpleZeroSum;

},{"../lib/engine":6,"./simple-normal":86}]},{},[5])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwiLi4vLi4vLi4vLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJpbmRleC5qcyIsImxhYi9sYWIuanMiLCJsaWIvZW5naW5lLmpzIiwibGliL2hlbHBlckZ1bmN0aW9ucy9nZW5lcmFsLmpzIiwibGliL2hlbHBlckZ1bmN0aW9ucy9pbmRleC5qcyIsImxpYi9oZWxwZXJGdW5jdGlvbnMvbG9naWMuanMiLCJsaWIvaGVscGVyRnVuY3Rpb25zL3BsYXlhYmxlLmpzIiwibGliL2hlbHBlckZ1bmN0aW9ucy9wbGF5ZXIuanMiLCJsaWIvaGVscGVyRnVuY3Rpb25zL3N0YXRlLmpzIiwibGliL2hlbHBlckZ1bmN0aW9ucy9zdG9jay1nYW1lcy5qcyIsImxpYi9oZWxwZXJGdW5jdGlvbnMvdG91cm5hbWVudC5qcyIsImxpYi9oZWxwZXJGdW5jdGlvbnMvdHVybi5qcyIsImxpYi9oaXN0b3J5LmpzIiwibGliL2luZm9ybWF0aW9uLmpzIiwibGliL2xvZ2dlci5qcyIsImxpYi9sb2dpYy5qcyIsImxpYi9wbGF5YWJsZXMvY2hvaWNlLmpzIiwibGliL3BsYXlhYmxlcy9jb25zZWN1dGl2ZS5qcyIsImxpYi9wbGF5YWJsZXMvaGFsdC1pZi5qcyIsImxpYi9wbGF5YWJsZXMvaW5kZXguanMiLCJsaWIvcGxheWFibGVzL2xhbWJkYS5qcyIsImxpYi9wbGF5YWJsZXMvbG9vcC5qcyIsImxpYi9wbGF5YWJsZXMvcGxheWFibGUuanMiLCJsaWIvcGxheWFibGVzL3BvcHVsYXRpb24tZHluYW1pY3MuanMiLCJsaWIvcGxheWFibGVzL3JhbmRvbS1wbGF5ZXItY2hvaWNlLmpzIiwibGliL3BsYXlhYmxlcy9zZXF1ZW5jZS5qcyIsImxpYi9wbGF5YWJsZXMvc2ltdWx0YW5lb3VzLmpzIiwibGliL3BsYXlhYmxlcy9zdG9jaGFzdGljLWhhbHQuanMiLCJsaWIvcGxheWFibGVzL3N0b2NoYXN0aWNMb29wLmpzIiwibGliL3BsYXlhYmxlcy90dXJuLmpzIiwibGliL3BsYXllci5qcyIsImxpYi9wbHVnaW4tbWFuYWdlci9hc3luYy1jdHguanMiLCJsaWIvcGx1Z2luLW1hbmFnZXIvaW5kZXguanMiLCJsaWIvcGx1Z2luLW1hbmFnZXIvcGx1Z2luLWNhbGxiYWNrLWVycm9yLmpzIiwibGliL3BsdWdpbi1tYW5hZ2VyL3BsdWdpbi1uYW1lLWVycm9yLmpzIiwibGliL3BsdWdpbi1tYW5hZ2VyL3dhdGVyZmFsbC1jdHguanMiLCJsaWIvcG9wdWxhdGlvbi5qcyIsImxpYi9zdGF0ZS5qcyIsImxpYi9zdHJhdGVneS1sb2FkZXIuanMiLCJsaWIvc3RyYXRlZ3kuanMiLCJub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hbnNpLXN0eWxlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9saWIvYXN5bmMuanMiLCJub2RlX21vZHVsZXMvY2hhbGsvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2hhbGsvbm9kZV9tb2R1bGVzL3N1cHBvcnRzLWNvbG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzY2FwZS1zdHJpbmctcmVnZXhwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzcHJpbWEvZGlzdC9lc3ByaW1hLmpzIiwibm9kZV9tb2R1bGVzL2V4cHJlc3Npb24tc2FuZGJveC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9leHByZXNzaW9uLXNhbmRib3gvbGliL21ha2Utc2FmZS5qcyIsIm5vZGVfbW9kdWxlcy9leHRlbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLWFuc2kvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbmF0YS9qc29uYXRhLmpzIiwibm9kZV9tb2R1bGVzL2xvZ2xldmVsLWNvbG9yZWQtbGV2ZWwtcHJlZml4L2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIiwibm9kZV9tb2R1bGVzL3ByZXNlbnQvbGliL3ByZXNlbnQtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yYW5kZ2VuL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JhbmRnZW4vbGliL3JhbmRnZW4uanMiLCJub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zeW5jaHJvbm91cy1wcm9taXNlL2luZGV4LmpzIiwicGx1Z2lucy9iYWxhbmNlLXNoZWV0LWNvbXBsZXguanMiLCJwbHVnaW5zL2JhbGFuY2Utc2hlZXQuanMiLCJzdG9jay1nYW1lcy9heGVscm9kLXRvdXJuYW1lbnQuanMiLCJzdG9jay1nYW1lcy9iYXR0bGUtb2YtdGhlLXNleGVzLmpzIiwic3RvY2stZ2FtZXMvY3VsdHVyYWwtZXZvbHV0aW9uLmpzIiwic3RvY2stZ2FtZXMvZXhjaGFuZ2UtY29tcGxleC5qcyIsInN0b2NrLWdhbWVzL2luZGV4LmpzIiwic3RvY2stZ2FtZXMvaXRlcmF0ZWQtcHJpc29uZXItZGlsZW1tYS5qcyIsInN0b2NrLWdhbWVzL2l0ZXJhdGVkLmpzIiwic3RvY2stZ2FtZXMvbWF0Y2hpbmctcGVubmllcy5qcyIsInN0b2NrLWdhbWVzL21vbnR5LWhhbGwuanMiLCJzdG9jay1nYW1lcy9wcmlzb25lci1kaWxlbW1hLmpzIiwic3RvY2stZ2FtZXMvcm9jay1wYXBlci1zY2lzc29ycy5qcyIsInN0b2NrLWdhbWVzL3JvdW5kLXJvYmluLmpzIiwic3RvY2stZ2FtZXMvc2ltcGxlLW5vcm1hbC5qcyIsInN0b2NrLWdhbWVzL3NpbXBsZS16ZXJvLXN1bS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25WQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOTdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2lOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsMkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfXJldHVybiBlfSkoKSIsIiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8vTWFpbiBtb2R1bGUgY29kZVxyXG52YXIgTmFzaEpTID0gcmVxdWlyZSgnLi9saWIvZW5naW5lJykuRnJvbnRlbmQ7XHJcblxyXG4vL1N0b2NrLWdhbWVzXHJcbk5hc2hKUy5TdG9ja0dhbWVzID0gcmVxdWlyZSgnLi9zdG9jay1nYW1lcycpO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTmFzaEpTO1xyXG4iLCIoe1xyXG5cdFBsYXllcixcclxuXHRfUGxheWVyLFxyXG5cdGdhbWVQb3B1bGF0aW9uLFxyXG5cdFBvcHVsYXRpb24sXHJcblx0UGxheWVyTGlzdCxcclxuXHRyZWdpc3RlclN0cmF0ZWd5LFxyXG5cdFN0cmF0ZWdpZXMsXHJcblx0c3RyYXRlZ3lMb2FkZXIsXHJcblx0X2V4cG9zZSxcclxuXHRyZWdpc3RyeSxcclxuXHRWYXJpYWJsZSxcclxuXHRFeHByZXNzaW9uLFxyXG5cdFJhbmRvbVZhcmlhYmxlLFxyXG5cdENvbXBsZXhWYXJpYWJsZSxcclxuXHRIaXN0b3J5LFxyXG5cdGV4Y2x1ZGVkUGxheWVycyxcclxuXHRzdGFydFJFUEwsXHJcblx0bmhpc3RvcnksXHJcblx0SW5mb3JtYXRpb24sXHJcblx0UGVyZmVjdEluZm9ybWF0aW9uLFxyXG5cdFBsdWdpbk1hbmFnZXJcclxufSA9IHJlcXVpcmUoXCIuLi9pbmRleFwiKSk7XHJcbih7XHJcblx0Q2hvaWNlLFxyXG5cdFR1cm4sXHJcblx0U2VxdWVuY2UsXHJcblx0Q29uc2VjdXRpdmUsXHJcblx0TG9vcCxcclxuXHRTdG9jaGFzdGljTG9vcCxcclxuXHRIYWx0SWYsXHJcblx0U3RvY2hhc3RpY0hhbHQsXHJcblx0TGFtYmRhLFxyXG5cdFJhbmRvbVBsYXllckNob2ljZSxcclxuXHRQb3B1bGF0aW9uRHluYW1pY3MsXHJcblx0U2ltdWx0YW5lb3VzXHJcbn0gPSByZXF1aXJlKFwiLi4vaW5kZXhcIikuUGxheWFibGVzKTtcclxuU3RvY2tHYW1lcyA9IHJlcXVpcmUoXCIuLi9pbmRleFwiKS5TdG9ja0dhbWVzO1xyXG5cclxuXHJcblxyXG5wMSA9IFBsYXllcigpO1xyXG5wMiA9IFBsYXllcigpO1xyXG5wMyA9IFBsYXllcigpO1xyXG5pcGQgPSBTdG9ja0dhbWVzW1wiSXRlcmF0ZWQgUHJpc29uZXIncyBEaWxlbW1hXCJdKFtwMSwgcDJdLCAyMClcclxuLypcclxuU3RvY2tHYW1lc1tcIlByaXNvbmVyJ3MgRGlsZW1tYVwiXShbcDEsIHAyXSlcclxuXHJcbnAxLmFzc2lnbihcImNob29zZUZpcnN0XCIpXHJcbnAyLmFzc2lnbihcInJhbmRvbWl6ZVwiKTtcclxuXHJcbnAzID0gUGxheWVyKCk7XHJcbnAzLmFzc2lnbihcImNob29zZVNlY29uZFwiKTtcclxucDQgPSBQbGF5ZXIoKTtcclxucDQuYXNzaWduKFwicmFuZG9taXplXCIpXHJcblxyXG5jMSA9IENob2ljZShwMSwgW1wiY29vcGVyYXRlXCIsIFwiZGVmZWN0XCJdKTtcclxuLy9jMVsnbGVmdCddKDUpIDtcclxuLy9jMVsncmlnaHQnXSgyKTtcclxuYzIgPSBDaG9pY2UocDIsIFtcIkNvb3BlcmF0ZVwiLCBcIkRlZmVjdFwiXSk7XHJcbi8vYzJbJ3VwJ10oMSk7XHJcbi8vYzJbJ2Rvd24nXSg3KTtcclxuXHJcbnQyID0gVHVybihbYzEsIGMyXSk7XHJcbnQzID0gVHVybihbYzEsIGMyXSk7XHJcbnQ0ID0gVHVybihbYzEsIGMyXSk7XHJcbnQ1ID0gVHVybihbYzEsIGMyXSk7XHJcbnMxID0gU2ltdWx0YW5lb3VzKFt0MiwgdDMsIHQ0LCB0NV0pXHJcblxyXG5jID0gQ29uc2VjdXRpdmUoW1xyXG5cdFR1cm4oW2MxLCBjMl0pLFxyXG5cdFR1cm4oW2MyLCBjMV0pLFxyXG5cdENob2ljZShwMSwgW1wiY29vcGVyYXRlXCIsIFwiZGVmZWN0XCJdKSxcclxuXHRMYW1iZGEoZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKFwiaGlcIikgfSksXHJcblx0SGFsdElmKGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZSB9KVxyXG5dKVxyXG5cclxuYzMgPSBSYW5kb21QbGF5ZXJDaG9pY2UoW1wiY29vcGVyYXRlXCIsIFwiZGVmZWN0XCJdKTtcclxuYzQgPSBSYW5kb21QbGF5ZXJDaG9pY2UoW1wiQ29vcGVyYXRlXCIsIFwiRGVmZWN0XCJdKTtcclxuXHJcbnQxID0gVHVybihbYzMsIGM0XSk7XHJcblxyXG52MSA9IG5ldyBWYXJpYWJsZSgzKTtcclxuXHJcbnQxLmRlZmVjdC5EZWZlY3QoWzIsIDJdKTtcclxudDEuZGVmZWN0LkNvb3BlcmF0ZShbNCwgMV0pO1xyXG50MS5jb29wZXJhdGUuRGVmZWN0KFsxLCA0XSk7XHJcbnQxLmNvb3BlcmF0ZS5Db29wZXJhdGUoW3YxLCB2MV0pO1xyXG5cclxuTDEgPSBMYW1iZGEoZnVuY3Rpb24oKSB7XHJcblx0djEuc2V0KHYxICsgMSk7XHJcbn0pO1xyXG5cclxucGQxID0gUG9wdWxhdGlvbkR5bmFtaWNzKDEuNSwgMSk7XHJcblxyXG5oMiA9IEhhbHRJZihmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gUG9wdWxhdGlvbigpLm9ubHlBbGl2ZSgpLmxlbmd0aCA9PSAwO1xyXG59KTtcclxuXHJcbkwxKHQxKTtcclxucGQxKEwxKTtcclxuaDIocGQxKTtcclxuXHJcbi8vczEgPSBTZXF1ZW5jZSh0MSwgaDIpO1xyXG5cclxuLy9sMSA9IExvb3AoczEsIDEwLCB7IGxvZ0NvbnRpbnVlOiB0cnVlIH0pO1xyXG5cclxuLy9jb25zb2xlLmxvZyhfZXhwb3NlKHQxKS5uZXh0KVxyXG4vL2NvbnNvbGUubG9nKF9leHBvc2UodDEpLm5leHQuY29vcGVyYXRlLkNvb3BlcmF0ZSlcclxuXHJcbmgyID0gSGFsdElmKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBQb3B1bGF0aW9uKCkub25seUFsaXZlKCkubGVuZ3RoID09IDA7XHJcbn0pO1xyXG5cclxuTDIgPSBMYW1iZGEoZnVuY3Rpb24oKSB7XHJcblx0cDEua2lsbCgpO1xyXG59KTtcclxuXHJcbnQyKEwyKTtcclxuXHJcbmdlbmVyYXRlUG9wdWxhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdGZvciAoaSA9IDA7IGkgPCAzMDsgaSsrKSB7XHJcblx0XHRQbGF5ZXIoeyBhc3NpZ246IFwiY2hvb3NlRmlyc3RcIiB9KTtcclxuXHR9XHJcblx0Zm9yIChpID0gMDsgaSA8IDMwOyBpKyspIHtcclxuXHRcdFBsYXllcih7IGFzc2lnbjogXCJjaG9vc2VTZWNvbmRcIiB9KTtcclxuXHR9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBnYW1lR2VuZXJhdG9yKCkge1xyXG5cdHZhciB0ID0gVHVybihbXHJcblx0XHRSYW5kb21QbGF5ZXJDaG9pY2UoW1wiY29vcGVyYXRlXCIsIFwiZGVmZWN0XCJdKSxcclxuXHRcdFJhbmRvbVBsYXllckNob2ljZShbXCJDb29wZXJhdGVcIiwgXCJEZWZlY3RcIl0pXHJcblx0XSk7XHJcblxyXG5cdHQuZGVmZWN0LkRlZmVjdChbMiwgMl0pO1xyXG5cdHQuZGVmZWN0LkNvb3BlcmF0ZShbNCwgMV0pO1xyXG5cdHQuY29vcGVyYXRlLkRlZmVjdChbMSwgNF0pO1xyXG5cdHQuY29vcGVyYXRlLkNvb3BlcmF0ZShbMywgM10pO1xyXG5cclxuXHRyZXR1cm4gdDtcclxufVxyXG4vL1xyXG4vL1xyXG4vL1xyXG5cclxuLy9DRSA9IFN0b2NrR2FtZXNbXCJDdWx0dXJhbCBFdm9sdXRpb25cIl0oZ2FtZUdlbmVyYXRvciwgMSwge2dlbmVyYXRlUG9wdWxhdGlvbn0pO1xyXG5cclxuLy9uID0gU3RvY2tHYW1lc1tcIlR3by1QbGF5ZXIgTm9ybWFsXCJdKHAxLHAyLFtbXCJsZWZ0XCIsXCJyaWdodFwiXSxbXCJ1cFwiLFwiZG93blwiXV0pO1xyXG4vL3BkMSA9IFN0b2NrR2FtZXNbXCJQcmlzb25lcidzIERpbGVtbWFcIl0oW3AxLCBwMl0pO1xyXG4vL3BkMiA9IFN0b2NrR2FtZXNbXCJQcmlzb25lcidzIERpbGVtbWFcIl0oW3AzLCBwNF0pO1xyXG5cclxuLy9zID0gU2ltdWx0YW5lb3VzKFtwZDEsIHBkMl0pXHJcblxyXG52MiA9IFZhcmlhYmxlKDEpO1xyXG5cclxuLy9uID0gU3RvY2tHYW1lc1tcIlNpbXBsZSBaZXJvLVN1bVwiXShwMSxwMixbW1wibGVmdFwiLFwicmlnaHRcIl0sW1widXBcIixcImRvd25cIl1dLCBbW3YyLDJdLFszLDRdXSk7XHJcblxyXG4vL3JwYyA9IFN0b2NrR2FtZXNbXCJSb2NrLVBhcGVyLVNjaXNzb3JzXCJdKFtwMSwgcDJdKTtcclxuLy90ID0gU3RvY2tHYW1lc1tcIkF4ZWxyb2QgVG91cm5hbWVudFwiXTtcclxuLy90ID0gU3RvY2tHYW1lc1tcIkl0ZXJhdGVkIFByaXNvbmVyJ3MgRGlsZW1tYVwiXShbcDEsIHAyXSk7XHJcbi8vVGhlIGNvZGUgYmVsb3cgaXMgdG8gcnVuIHRoZSByZXBsIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxyXG4vL3ZhciB0b1JlcGwgPSB7X2V4cG9zZSwgcmVnaXN0cnksUGxheWVyLENob2ljZSxUdXJuLFNlcXVlbmNlLExvb3AsU3RvY2hhc3RpY0xvb3AsSGFsdElmLCBTdG9jaGFzdGljSGFsdCwgTGFtYmRhLCBwMSxjMSxjMix0MX07XHJcbi8vc3RhcnRSRVBMKHRvUmVwbCk7XHJcbiovXHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gU3RhcnQgcGx1Zy1pbiBtYW5hZ2VyXHJcbnZhciBQbHVnaW5NYW5hZ2VyID0gcmVxdWlyZShcIi4vcGx1Z2luLW1hbmFnZXJcIilcclxuUGx1Z2luTWFuYWdlci5zdGFydChmdW5jdGlvbigpIHt9KVxyXG5cclxuXHJcbi8vTG9nZ2luZ1xyXG52YXIgbG9nID0gcmVxdWlyZShcIi4vbG9nZ2VyXCIpO1xyXG4vL2xvZy51c2VXaW5zdG9uKCk7ICBcdFx0XHRcdFdpbnN0b24gZG9lc24ndCB3b3JrIHdpdGggYnJvd3NlcmlmeSwgc28gdGhpcyBpcyBhIHNoaW0uIFVuY29tbWVudCB0byB1c2UgV2luc3Rvbi5cclxubG9nLnNldExldmVsKFwiZGVidWdcIik7XHJcbmxvZyhcImluZm9cIiwgXCJTdGFydGluZyBOYXNoSlNcIik7XHJcblxyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5LCBpZENvdW50ZXJzIH0gPSByZXF1aXJlKCcuL3N0YXRlJyk7XHJcblxyXG5cclxuLy8gSGlzdG9yeVxyXG52YXIgeyBnYW1lSGlzdG9yeSwgdXNlckdhbWVIaXN0b3J5LCBIaXN0b3J5LCBVc2VySGlzdG9yeSB9ID0gcmVxdWlyZSgnLi9oaXN0b3J5Jyk7XHJcblxyXG5cclxuLy9QbGF5ZXJzXHJcbnZhciB7IF9QbGF5ZXIsIFBsYXllciB9ID0gcmVxdWlyZSgnLi9wbGF5ZXInKTtcclxucmVnaXN0cnkuX2FkZFR5cGVfKFwicGxheWVyc1wiKTtcclxuaWRDb3VudGVycy5fYWRkVHlwZV8oXCJwbGF5ZXJcIik7XHJcblxyXG5cclxuLy9Qb3B1bGF0aW9uXHJcbnZhciB7IGdhbWVQb3B1bGF0aW9uLCBQb3B1bGF0aW9uLCBQbGF5ZXJMaXN0LCBVc2VyUGxheWVyTGlzdCB9ID0gcmVxdWlyZSgnLi9wb3B1bGF0aW9uJyk7XHJcblxyXG5cclxuLy9JbmZvcm1hdGlvbiBtZWNoYW5pY3NcclxudmFyIHsgSW5mb3JtYXRpb24sIFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0gcmVxdWlyZShcIi4vaW5mb3JtYXRpb25cIik7XHJcblxyXG5cclxuLy9QbGF5YWJsZXNcclxudmFyIHsgcGxheWFibGVDbGFzc2VzLCBwbGF5YWJsZUludGVyZmFjZXMgfSA9IHJlcXVpcmUoJy4vcGxheWFibGVzLycpXHJcbmZvciAodmFyIF9jbGFzcyBpbiBwbGF5YWJsZUNsYXNzZXMpIHtcclxuXHRyZWdpc3RyeS5fYWRkVHlwZV8ocGxheWFibGVDbGFzc2VzW19jbGFzc10ucmVnaXN0cnlOYW1lKTtcclxuXHRpZENvdW50ZXJzLl9hZGRUeXBlXyhwbGF5YWJsZUNsYXNzZXNbX2NsYXNzXS5jb3VudGVyTmFtZSk7XHJcbn1cclxuXHJcbi8vU3ltYm9saWMgTG9naWNcclxudmFyIHtcclxuXHR2YXJpYWJsZVByb3RvdHlwZSxcclxuXHRWYXJpYWJsZSxcclxuXHRleHByZXNzaW9uUHJvdG90eXBlLFxyXG5cdEV4cHJlc3Npb24sXHJcblx0UmFuZG9tVmFyaWFibGUsXHJcblx0Q29tcGxleFZhcmlhYmxlXHJcbn0gPSByZXF1aXJlKFwiLi9sb2dpY1wiKTtcclxuXHJcblxyXG4vL1N0cmF0ZWdpZXNcclxucmVnaXN0cnkuX2FkZFR5cGVfKFwic3RyYXRlZ2llc1wiKTtcclxuaWRDb3VudGVycy5fYWRkVHlwZV8oXCJzdHJhdGVneVwiKTtcclxuXHJcbnZhciB7IHJlZ2lzdGVyU3RyYXRlZ3ksIHJlZ2lzdGVyU3RyYXRlZ3lPYmplY3QsIFN0cmF0ZWdpZXMgfSA9IHJlcXVpcmUoJy4vc3RyYXRlZ3knKTtcclxudmFyIHsgbG9hZFN0cmF0ZWd5LCBsb2FkU3RyYXRlZ3lGb2xkZXIgfSA9IHJlcXVpcmUoJy4vc3RyYXRlZ3ktbG9hZGVyJyk7XHJcblxyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIGxvYWRlclxyXG52YXIgSGVscGVyRnVuY3Rpb25zID0gcmVxdWlyZSgnLi9oZWxwZXJGdW5jdGlvbnMnKTtcclxuXHJcblxyXG4vL1RISVMgRlVOQ1RJT04gSVMgT05MWSBGT1IgREVCVUdHSU5HLiBSRU1PVkUgSVQgRlJPTSBNT0RVTEUgRVhQT1JUUyBXSEVOIFBVQkxJU0hJTkdcclxuZnVuY3Rpb24gRXhwb3NlKGludGVyZmFjZVBsYXlhYmxlKSB7XHJcblx0cmV0dXJuIHJlZ2lzdHJ5LnBsYXlhYmxlc1tpbnRlcmZhY2VQbGF5YWJsZS5pZCgpXTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHN0YXJ0UkVQTCh0b1JFUEwpIHtcclxuXHR2YXIgcmVwbCA9IHJlcXVpcmUoXCJyZXBsXCIpO1xyXG5cclxuXHR2YXIgcmVwbFNlcnZlciA9IHJlcGwuc3RhcnQoe1xyXG5cdFx0cHJvbXB0OiBcIk5hc2ggPj4gXCJcclxuXHR9KTtcclxuXHJcblx0T2JqZWN0LmFzc2lnbihyZXBsU2VydmVyLmNvbnRleHQsIHRvUkVQTCk7XHJcbn1cclxuXHJcblxyXG5cclxudmFyIEVuZ2luZSA9IHtcclxuXHRGcm9udGVuZDoge1xyXG5cdFx0UGxheWVyLFxyXG5cdFx0X1BsYXllciwgLy9SRU1PVkUgVEhJUyBMSU5FIFdIRU4gUFVCTElTSElOR1xyXG5cdFx0Z2FtZVBvcHVsYXRpb24sIC8vUkVNT1ZFIFRISVMgTElORSBXSEVOIFBVQkxJU0hJTkdcclxuXHRcdCdQbGF5ZXJMaXN0JzogVXNlclBsYXllckxpc3QsXHJcblx0XHRQb3B1bGF0aW9uLFxyXG5cdFx0SW5mb3JtYXRpb24sIC8vUkVNT1ZFIFRISVMgTElORSBXSEVOIFBVQkxJU0hJTkdcclxuXHRcdFBlcmZlY3RJbmZvcm1hdGlvbiwgLy9SRU1PVkUgVEhJUyBMSU5FIFdIRU4gUFVCTElTSElOR1xyXG5cdFx0J1BsYXlhYmxlcyc6IHBsYXlhYmxlSW50ZXJmYWNlcyxcclxuXHRcdHJlZ2lzdGVyU3RyYXRlZ3ksXHJcblx0XHRyZWdpc3RlclN0cmF0ZWd5T2JqZWN0LFxyXG5cdFx0U3RyYXRlZ2llcyxcclxuXHRcdGxvYWRTdHJhdGVneSxcclxuXHRcdGxvYWRTdHJhdGVneUZvbGRlcixcclxuXHRcdEhpc3Rvcnk6IHVzZXJHYW1lSGlzdG9yeSxcclxuXHRcdEV4cG9zZSwgLy9SRU1PVkUgVEhJUyBMSU5FIFdIRU4gUFVCTElTSElOR1xyXG5cdFx0cmVnaXN0cnksIC8vUkVNT1ZFIFRISVMgTElORSBXSEVOIFBVQkxJU0hJTkdcclxuXHRcdHN0YXJ0UkVQTCwgLy9TaG91bGQgdGhpcyBsaW5lIGJlIHJlbW92ZWQgd2hlbiBwdWJsaXNoaW5nP1xyXG5cdFx0VmFyaWFibGUsXHJcblx0XHRFeHByZXNzaW9uLFxyXG5cdFx0UmFuZG9tVmFyaWFibGUsXHJcblx0XHRDb21wbGV4VmFyaWFibGUsXHJcblx0XHRQbHVnaW5NYW5hZ2VyIC8vUkVNT1ZFIFRISVMgTElORSBXSEVOIFBVQkxJU0hJTkdcclxuXHR9LFxyXG5cclxuXHRCYWNrZW5kOiB7XHJcblx0XHRsb2dnZXI6IGxvZyxcclxuXHRcdFN0YXRlOiB7IHJlZ2lzdHJ5LCBpZENvdW50ZXJzLCBnYW1lSGlzdG9yeSwgZ2FtZVBvcHVsYXRpb24sIFBlcmZlY3RJbmZvcm1hdGlvbiB9LFxyXG5cdFx0Q2xhc3Nlczoge1xyXG5cdFx0XHRQbGF5ZXI6IF9QbGF5ZXIsXHJcblx0XHRcdEhpc3RvcnksXHJcblx0XHRcdFVzZXJIaXN0b3J5LFxyXG5cdFx0XHRQbGF5ZXJMaXN0LFxyXG5cdFx0XHRVc2VyUGxheWVyTGlzdCxcclxuXHRcdFx0SW5mb3JtYXRpb24sXHJcblx0XHRcdFBsYXlhYmxlQ2xhc3NlczogeyBwbGF5YWJsZUNsYXNzZXMgfSxcclxuXHRcdFx0dmFyaWFibGVQcm90b3R5cGUsXHJcblx0XHRcdGV4cHJlc3Npb25Qcm90b3R5cGVcclxuXHRcdH0sXHJcblx0XHRIZWxwZXJGdW5jdGlvbnMsXHJcblx0XHRQbHVnaW5NYW5hZ2VyLFxyXG5cdFx0RXhwb3NlXHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVuZ2luZTtcclxuIiwidmFyIGdlbmVyYWwgPSB7XHJcblx0Ly9DaGVjayBpZiB2YXJpYWJsZSBpcyBhbiBPYmplY3RcclxuXHRpc09iamVjdChhKSB7XHJcblx0XHRyZXR1cm4gISFhICYmIGEuY29uc3RydWN0b3IgPT09IE9iamVjdDtcclxuXHR9LFxyXG5cclxuXHQvL1doYXQgZG8geW91IHRoaW5rP1xyXG5cdGlzRnVuY3Rpb24oYSkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBhID09PSBcImZ1bmN0aW9uXCI7XHJcblx0fSxcclxuXHJcblx0Ly9Qcm92aWRlIGEgZnVuY3Rpb24sIGEgY29udGV4dCAoJ3RoaXMnKSwgYW5kIGFuIGFyZ3VtZW50IGFycmF5LlxyXG5cdC8vUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZC5cclxuXHRhcHBseUJpbmQoZnVuYywgdGhhdCwgYXJnQXJyYXkpIHtcclxuXHRcdHJldHVybiBmdW5jLmJpbmQuYXBwbHkoZnVuYywgW3RoYXRdLmNvbmNhdChhcmdBcnJheSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vV3JhcHMgYSBmdW5jdGlvbiB0byBlbnN1cmUgaXQgb25seSBnZXRzIGNhbGxlZCBvbmUgdGltZS5cclxuXHRvbmNlKGZuLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgcmVzdWx0O1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcclxuXHRcdFx0aWYgKGZuKSB7XHJcblx0XHRcdFx0cmVzdWx0ID0gZm4uYXBwbHkoY29udGV4dCB8fCB0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRcdGZuID0gbnVsbDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gUmFuZG9tbHkgcmUtb3JkZXIgYXJyYXlcclxuXHRzaHVmZmxlKGFycmF5KSB7XHJcblx0XHR2YXIgY3VycmVudEluZGV4ID0gYXJyYXkubGVuZ3RoLFxyXG5cdFx0XHR0ZW1wb3JhcnlWYWx1ZSxcclxuXHRcdFx0cmFuZG9tSW5kZXg7XHJcblxyXG5cdFx0Ly8gV2hpbGUgdGhlcmUgcmVtYWluIGVsZW1lbnRzIHRvIHNodWZmbGUuLi5cclxuXHRcdHdoaWxlICgwICE9PSBjdXJyZW50SW5kZXgpIHtcclxuXHRcdFx0Ly8gUGljayBhIHJlbWFpbmluZyBlbGVtZW50Li4uXHJcblx0XHRcdHJhbmRvbUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY3VycmVudEluZGV4KTtcclxuXHRcdFx0Y3VycmVudEluZGV4IC09IDE7XHJcblxyXG5cdFx0XHQvLyBBbmQgc3dhcCBpdCB3aXRoIHRoZSBjdXJyZW50IGVsZW1lbnQuXHJcblx0XHRcdHRlbXBvcmFyeVZhbHVlID0gYXJyYXlbY3VycmVudEluZGV4XTtcclxuXHRcdFx0YXJyYXlbY3VycmVudEluZGV4XSA9IGFycmF5W3JhbmRvbUluZGV4XTtcclxuXHRcdFx0YXJyYXlbcmFuZG9tSW5kZXhdID0gdGVtcG9yYXJ5VmFsdWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cdH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhbDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcclxuXHJcbmxvZyhcImRlYnVnXCIsIFwiaGVscGVyRnVuY3Rpb25zLWluZGV4OiBMb2FkaW5nIGhlbHBlciBmdW5jdGlvbnMgbG9hZGVyLlwiKTtcclxuXHJcbi8qXHJcbnZhciBnZW5lcmFsICA9IHJlcXVpcmUoJy4vZ2VuZXJhbCcpO1xyXG52YXIgcGxheWVyICAgPSByZXF1aXJlKCcuL3BsYXllcicpO1xyXG52YXIgcGxheWFibGUgPSByZXF1aXJlKCcuL3BsYXlhYmxlJyk7XHJcbnZhciB0dXJuIFx0ID0gcmVxdWlyZSgnLi90dXJuJyk7XHJcbnZhciBzdGF0ZSBcdCA9IHJlcXVpcmUoJy4vc3RhdGUnKTsgXHJcbiovXHJcblxyXG5mdW5jdGlvbiBsb2FkZXIoZmlsZSkge1xyXG5cdHJldHVybiByZXF1aXJlKFwiLi9cIiArIGZpbGUgKyBcIi5qc1wiKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBsb2FkZXI7XHJcbi8vbW9kdWxlLmV4cG9ydHMgPSB7Z2VuZXJhbCwgcGxheWVyLCBwbGF5YWJsZSwgdHVybiwgc3RhdGV9O1xyXG5cclxuLy8gSGFjayB0byBjb21waWxlIEdsb2IgZmlsZXMgKGluIGJyb3dzZXJpZnkpLiBEb27CtHQgY2FsbCB0aGlzIGZ1bmN0aW9uIVxyXG4oZnVuY3Rpb24oKSB7XHJcblx0cmVxdWlyZSgnLi9nZW5lcmFsLmpzJyk7cmVxdWlyZSgnLi9pbmRleC5qcycpO3JlcXVpcmUoJy4vbG9naWMuanMnKTtyZXF1aXJlKCcuL3BsYXlhYmxlLmpzJyk7cmVxdWlyZSgnLi9wbGF5ZXIuanMnKTtyZXF1aXJlKCcuL3N0YXRlLmpzJyk7cmVxdWlyZSgnLi9zdG9jay1nYW1lcy5qcycpO3JlcXVpcmUoJy4vdG91cm5hbWVudC5qcycpO3JlcXVpcmUoJy4vdHVybi5qcycpO1xyXG59KTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9naWMgPSB7XHJcblxyXG5cdC8vIENoZWNrIHRvIHNlZSBpZiBvYmplY3QgaXMgVmFyaWFibGUvRXhwcmVzc2lvbiBvciBub3QuIFJldHVybnMgdHJ1ZS9mYWxzZVxyXG5cdGlzTG9naWMobG9naWMpIHtcclxuXHJcblx0XHRpZiAobG9naWMgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBsb2dpYyA9PSBsb2dpYyAqIDEpIHJldHVybiB0cnVlXHJcblx0XHRlbHNlIHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGxvZ2ljO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciB7IFN5bmNocm9ub3VzUHJvbWlzZSB9ID0gcmVxdWlyZSgnc3luY2hyb25vdXMtcHJvbWlzZScpO1xyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKCcuLi9zdGF0ZScpO1xyXG5cclxudmFyIHBsYXlhYmxlID0ge1xyXG5cdC8vIEdlbmVyYXRlcyB0aGUgZnVuY3Rpb24gdGhhdCBnZXRzIHJldHVybmVkIHdoZW4gYSBQbGF5YWJsZSBpcyBjYWxsZWQsIHdoaWNoIGNhbiB0aGVuIGJlIGNhbGxlZCB0byBjaGFpbiBwbGF5YWJsZXMgdG9nZXRoZXIuXHJcblx0Y2hhaW5lckdlbmVyYXRvcihleHRlcm5hbE9iaiwgaW50ZXJuYWxPYmopIHtcclxuXHRcdGV4dGVybmFsT2JqID0gdGhpcztcclxuXHRcdHJldHVybiBmdW5jdGlvbihzb3VyY2UpIHtcclxuXHRcdFx0dmFyIHByZXZpb3VzUGxheWFibGUsIHBhdGg7XHJcblxyXG5cdFx0XHQvL1RPRE86IHZlcmlmeSB0aGF0IHNvdXJjZSBpcyB0aGUgcmlnaHQgdHlwZVxyXG5cclxuXHRcdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5hbGwoW2Z1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmIChzb3VyY2UgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHNvdXJjZSBpbnN0YW5jZW9mIFN5bmNocm9ub3VzUHJvbWlzZSkge1xyXG5cdFx0XHRcdFx0c291cmNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdFx0XHRcdHByZXZpb3VzUGxheWFibGUgPSByZWdpc3RyeS5wbGF5YWJsZXNbcmVzdWx0LnBsYXlhYmxlLmlkKCldO1xyXG5cdFx0XHRcdFx0XHRwYXRoID0gcmVzdWx0LnBhdGhcclxuXHRcdFx0XHRcdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKCk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKClcclxuXHRcdFx0fSgpLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHNvdXJjZSBpbnN0YW5jZW9mIFN5bmNocm9ub3VzUHJvbWlzZSkpIHtcclxuXHRcdFx0XHRcdHByZXZpb3VzUGxheWFibGUgPSByZWdpc3RyeS5wbGF5YWJsZXNbc291cmNlLmlkKCldO1xyXG5cdFx0XHRcdFx0cGF0aCA9IHNvdXJjZS5wYXRoO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoKTtcclxuXHRcdFx0fSgpXSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHJcblx0XHRcdFx0aWYgKHBhdGggPT0gXCJhbGxcIikgcHJldmlvdXNQbGF5YWJsZS5hZGROZXh0KGludGVybmFsT2JqKTtcclxuXHRcdFx0XHRlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRvdXRjb21lVHJlZUdldFZhbHVlKHByZXZpb3VzUGxheWFibGUubmV4dCwgcGF0aCkucHVzaChpbnRlcm5hbE9iaik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL3ByZXZpb3VzUGxheWFibGUubmV4dFtzZWxlY3RlZF0ucHVzaChfY2hvaWNlKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKHtcclxuXHRcdFx0XHRcdCdwbGF5YWJsZSc6IGV4dGVybmFsT2JqLFxyXG5cdFx0XHRcdFx0cGF0aDogXCJhbGxcIlxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblxyXG5cdC8vVXNlIHRvIHNldCBldmVyeSB2YWx1ZSBvZiBhbiBvdXRjb21lIHRyZWVcclxuXHRvdXRjb21lVHJlZUFkZEFsbCh0cmVlLCB2YWx1ZSkge1xyXG5cclxuXHRcdC8vSWYgaXQncyBhbiBhcnJheSwgdGhlbiB3ZSdyZSBhbHJlYWR5IGRvbmUuXHJcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xyXG5cdFx0XHR0cmVlLnB1c2godmFsdWUpOyAvL1VzZSBwdXNoIGhlcmUgYmVjYXVzZSB0aGlzIHdpbGwgYmUgYSB1bmlxdWUgYXJyYXlcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciByZWN1cnNlID0gZnVuY3Rpb24ob2JqLCB2YWwpIHtcclxuXHJcblx0XHRcdFx0Zm9yICh2YXIga2V5cyBpbiBvYmopIHtcclxuXHJcblx0XHRcdFx0XHQvL0lmIG5vIGtleXMgbGVmdCB0byB0cmF2ZXJzZSwgdGhlbiBhc3NpZ24gdmFsdWUuIElmIG5vdCwgcmVjdXJzZS5cclxuXHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KG9ialtrZXlzXSkpIHtcclxuXHRcdFx0XHRcdFx0b2JqW2tleXNdID0gb2JqW2tleXNdLnNsaWNlKCkuY29uY2F0KHZhbCk7IC8vVXNlIHNsaWNlLWNvbmNhdCBoZXJlIGJlY2F1c2UgdGhpcyBtaWdodCBub3QgYmUgYSB1bmlxdWUgYXJyYXkgKHRoZSBjcmVhdGlvbiBwcm9jZXNzIGR1cGxpY2F0ZXMgdGhlbSlcclxuXHRcdFx0XHRcdH0gZWxzZSByZWN1cnNlKG9ialtrZXlzXSwgdmFsKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0XHRyZWN1cnNlKHRyZWUsIHZhbHVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0Ly9UcmF2ZXJzZSBhbiBvdXRjb21lIHRyZWUgdG8gb2J0YWluIHRoZSB2YWx1ZSBmb3IgYSBkZXNpcmVkIGtleS1zZXRcclxuXHQvL0FyZ3VtZW50IG9uZSBpcyBhIG5lc3RlZCBvYmplY3QsIHdoaWxlIGFyZ3VtZW50IDIgaXMgYW4gYXJyYXkgb2Yga2V5cyBmb3IgdGhlIG9iamVjdCwgMSBsYXllciBhdCBhIHRpbWUuXHJcblx0b3V0Y29tZVRyZWVHZXRWYWx1ZSh0cmVlLCBzZWxlY3Rvcikge1xyXG5cclxuXHRcdC8vRmluZCB0aGUgbmV4dCBpdGVtIGluIHRoZSBjaGFpbiBhc3NvY2lhdGVkIHdpdGggdGhlIHJlc3VsdGFudCBvdXRjb21lXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZWN0b3IubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dHJlZSA9IHRyZWVbc2VsZWN0b3JbaV1dO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cmVlO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvL1RyYXZlcnNlIGFuIG91dGNvbWUgdHJlZSB0byBzZXQgdGhlIHZhbHVlIGZvciBhIGRlc2lyZWQga2V5LXNldFxyXG5cdC8vQXJndW1lbnQgb25lIGlzIGEgbmVzdGVkIG9iamVjdCwgd2hpbGUgYXJndW1lbnQgMiBpcyBhbiBhcnJheSBvZiBrZXlzIGZvciB0aGUgb2JqZWN0LCAxIGxheWVyIGF0IGEgdGltZS5cclxuXHRvdXRjb21lVHJlZVNldFZhbHVlKHRyZWUsIHNlbGVjdG9yLCB2YWx1ZSkge1xyXG5cclxuXHRcdC8vRmluZCB0aGUgbmV4dCBpdGVtIGluIHRoZSBjaGFpbiBhc3NvY2lhdGVkIHdpdGggdGhlIHJlc3VsdGFudCBvdXRjb21lXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZWN0b3IubGVuZ3RoIC0gMTsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRyZWUgPSB0cmVlW3NlbGVjdG9yW2ldXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJlZVtzZWxlY3RvcltpXV0gPSB2YWx1ZTtcclxuXHR9XHJcbn1cclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBwbGF5YWJsZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyAgR2FtZSBzdGF0ZVxyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZShcIi4uL3N0YXRlXCIpO1xyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uXHJcbnZhciB7IGlzRnVuY3Rpb24gfSA9IHJlcXVpcmUoXCIuL2dlbmVyYWxcIik7XHJcblxyXG4vLyBQbGF5ZXIgY2xhYXNzXHJcbnZhciB7IF9QbGF5ZXIgfSA9IHJlcXVpcmUoXCIuLi9wbGF5ZXJcIik7XHJcblxyXG4vLyBQb3B1bGF0aW9uXHJcbnZhciB7IGdhbWVQb3B1bGF0aW9uIH0gPSByZXF1aXJlKFwiLi4vcG9wdWxhdGlvblwiKVxyXG5cclxuLy8gUGx1Z2luc1xyXG52YXIgUGx1Z2luTWFuYWdlciA9IHJlcXVpcmUoXCIuLi9wbHVnaW4tbWFuYWdlci9cIilcclxuXHJcbnZhciBwbGF5ZXIgPSB7XHJcblxyXG5cdC8vcmVzZXQgYWxsIHBsYXllcnMuIFJlY3JlYXRlIGZyb20gY2xhc3MsIHJlLWFzc2lnbiBzdHJhdGVneSwgbG9vcCB0aHJvdWdoIG9iamVjdHMgdGhhdCByZWZlcmVuY2UgcGxheWVyIHRvIHNldCBuZXcgcmVmZXJlbmNlLiByZXN1bHQgYXJndW1lbnQgaXMgb25seSBmb3IgcGFzcy10aHJvdWdoLlxyXG5cdHJlaW5pdGlhbGl6ZVBsYXllcnMocG9wdWxhdGlvbiA9IFwiYWxsXCIsIHJlc3VsdCA9IG51bGwpIHtcclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgb2xkUGxheWVyLCBzdHJhdGVneSwgc3RyYXRlZ3lBcmdzLCBwYXJhbWV0ZXJzO1xyXG5cclxuXHRcdFx0Ly8gaWYgbm8gcG9wdWxhdGlvbiBpcyBzdXBwbGllZCwgZmV0Y2ggZXZlcnlib2R5XHJcblx0XHRcdGlmIChwb3B1bGF0aW9uID09PSBcImFsbFwiKSBwb3B1bGF0aW9uID0gT2JqZWN0LmtleXMocmVnaXN0cnkucGxheWVycylcclxuXHRcdFx0ZWxzZShwb3B1bGF0aW9uID0gcG9wdWxhdGlvbi5pZHMoKSlcclxuXHJcblx0XHRcdC8vUmVkZWZpbmUgZWFjaCBwbGF5ZXJcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb3B1bGF0aW9uLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIHBsYXllciA9IHBvcHVsYXRpb25baV07XHJcblxyXG5cdFx0XHRcdG9sZFBsYXllciA9IHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyXTtcclxuXHRcdFx0XHRzdHJhdGVneSA9IG9sZFBsYXllci5zdHJhdGVneSA/IG9sZFBsYXllci5zdHJhdGVneS5faWQgOiBudWxsO1xyXG5cdFx0XHRcdHN0cmF0ZWd5QXJncyA9IHN0cmF0ZWd5ID8gb2xkUGxheWVyLnN0cmF0ZWd5Ll9hcmdzIDogW107XHJcblx0XHRcdFx0cGFyYW1ldGVycyA9IHt9OyAvL1RPRE86IHdoZW4gYWRkaW5nIHBsYXllciBwYXJhbWV0ZXJzLCBiZSBzdXJlIHRoZXkncmUgaW5jbHVkZWQgaGVyZVxyXG5cclxuXHRcdFx0XHRyZWdpc3RyeS5wbGF5ZXJzW3BsYXllcl0gPSBuZXcgX1BsYXllcihvbGRQbGF5ZXIuaWQsIHBhcmFtZXRlcnMpO1xyXG5cdFx0XHRcdHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyXS5pbnRlcmZhY2UgPSBvbGRQbGF5ZXIuaW50ZXJmYWNlO1xyXG5cdFx0XHRcdHN0cmF0ZWd5ICYmIHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyXS5hc3NpZ24oc3RyYXRlZ3ksIC4uLnN0cmF0ZWd5QXJncyk7XHJcblxyXG5cdFx0XHRcdC8vIFBsdWdpbiwgdG8gYWx0ZXIgcGxheWVycyBpbiByZS1pbml0aWFsaXphdGlvblxyXG5cdFx0XHRcdFBsdWdpbk1hbmFnZXIucnVuKFwicGxheWVyLXJlaW5pdGlhbGl6ZVwiLCByZWdpc3RyeS5wbGF5ZXJzW3BsYXllcl0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL0ZvciBlYWNoIGNob2ljZSwgcmVjcmVhdGUgcGxheWVyIHJlZmVyZW5jZXNcclxuXHRcdFx0Zm9yICh2YXIgY2hvaWNlIGluIHJlZ2lzdHJ5LmNob2ljZXMpIHtcclxuXHRcdFx0XHRpZiAocmVnaXN0cnkuY2hvaWNlc1tjaG9pY2VdLnBsYXllcilcclxuXHRcdFx0XHRcdHJlZ2lzdHJ5LmNob2ljZXNbY2hvaWNlXS5wbGF5ZXIgPSByZWdpc3RyeS5wbGF5ZXJzW3JlZ2lzdHJ5LmNob2ljZXNbY2hvaWNlXS5wbGF5ZXIuaWRdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHBsYXllcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XHJcblxyXG4vLyBTdGF0ZSB2YXJpYWJsZXNcclxudmFyIHtpZENvdW50ZXJzLCByZWdpc3RyeX0gPSByZXF1aXJlKCcuLi9zdGF0ZScpO1xyXG5cclxudmFyIHN0YXRlID0ge1xyXG5cdFxyXG5cdC8vSGFuZGxlIElEIHNldHRpbmcgZm9yIGFsbCBvYmplY3RzIHRoYXQgZ2V0IHN0b3JlZCBpbiB0aGUgcmVnaXN0cnlcclxuXHRpZEhhbmRsZXI6IGZ1bmN0aW9uIGlkSGFuZGxlcihpZCwgdHlwZSwgcmVjdXJzaW5nPWZhbHNlKXtcclxuXHRcdC8vQXNzaWduIGlkXHJcblx0XHRcclxuXHRcdGlkQ291bnRlcnNbdHlwZV0rKztcclxuXHRcdHZhciBjb3VudGVyID0gaWRDb3VudGVyc1t0eXBlXTtcclxuXHRcdFxyXG5cdFx0aWYgKCFpZCkge1xyXG5cdFx0XHRyZXR1cm4gdHlwZSArIGNvdW50ZXIudG9TdHJpbmcoKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gQ2hlY2sgdGhhdCBpZCBpc24ndCB0YWtlbi4gSWYgaXQgaXMsIGNvbnN0cnVjdCBhIG5ldyBvbmUuXHJcblx0XHRcdFxyXG5cdFx0XHQvL0NvbnN0cnVjdCBsaXN0IG9mIGFsbCBvYmplY3RzIGJ5IGV4dHJhY3RpbmcgYWxsIHJlZ2lzdHJ5IGVudHJpZXNcclxuXHRcdFx0dmFyIGl0ZW1zID0gW11cclxuXHRcdFx0T2JqZWN0LmtleXMocmVnaXN0cnkpLmZvckVhY2goZnVuY3Rpb24ocmVnKXtpdGVtcy5wdXNoLmFwcGx5KGl0ZW1zLCBPYmplY3Qua2V5cyhyZWdpc3RyeVtyZWddKSl9KVxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gaWYgaWQgaXMgYWxyZWFkeSB0YWtlbiwgZ2VuZXJhdGUgYSBuZXcgb25lIGJ5IGFkZGluZyBhIG51bWJlciBhdCB0aGUgZW5kLlxyXG5cdFx0XHRpZiAoaXRlbXMuaW5kZXhPZihpZCkgPiAtMSkge1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdHZhciBtYXRjaCwgb2xkTnVtLCBleHAsIG5ld0lkO1xyXG5cdFx0XHRcdHZhciBvbGRJZCA9IGlkO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGRvIHtcclxuXHRcdFx0XHRcdC8vIFRoaXMgZmluZHMgYSBudW1iZXIgYXQgdGhlIGVuZCwgYW5kIGluY3JlbWVudHMgaXQsIG9yIHN0YXJ0cyB3aXRoIDEgaWYgdGhlcmUgd2Fzbid0IG9uZS5cclxuXHRcdFx0XHRcdG1hdGNoID0gL1xcZCskLy5leGVjKGlkKTtcclxuXHRcdFx0XHRcdG9sZE51bSA9IG1hdGNoID8gbWF0Y2hbMF0gOiBcIlwiO1xyXG5cdFx0XHRcdFx0ZXhwID0gbmV3IFJlZ0V4cChvbGROdW0gKyBcIiRcIik7XHJcblx0XHRcdFx0XHRpZCA9IGlkLnJlcGxhY2UoZXhwLCBOdW1iZXIob2xkTnVtKSArIDEpXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0fVx0XHJcblx0XHRcdFx0d2hpbGUgKGl0ZW1zLmluZGV4T2YoaWQpID4tMSlcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBMb2cgd2FybmluZ1xyXG5cdFx0XHRcdGxvZyhcIndhcm5cIiwgXCJJRCBcIiArIG9sZElkICsgXCIgaXMgdGFrZW4uIFVzaW5nIGluc3RlYWQgXCIgKyBpZCk7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdHJldHVybiBpZFxyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc3RhdGU7IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBTdHJhdGVneSByZWdpc3RyYXRpb25cclxudmFyIHsgcmVnaXN0ZXJTdHJhdGVneU9iamVjdCB9ID0gcmVxdWlyZShcIi4uL2VuZ2luZVwiKS5Gcm9udGVuZDtcclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgaXNGdW5jdGlvbiwgb25jZSB9ID0gcmVxdWlyZShcIi4vZ2VuZXJhbFwiKTtcclxuXHJcbi8vRXh0ZXJuYWwgZGVwZW5kZW5jeVxyXG52YXIgZXNwcmltYSA9IHJlcXVpcmUoXCJlc3ByaW1hXCIpO1xyXG5cclxuXHJcbi8vIEZvciBoYW5kbGluZyBxdWVyaWVzXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKFwiLi4vZW5naW5lXCIpLkJhY2tlbmQuU3RhdGVcclxudmFyIHsgaWRIYW5kbGVyIH0gPSByZXF1aXJlKFwiLi9zdGF0ZVwiKVxyXG5cclxudmFyIHJlZ2lzdGVyUXVlcnlPYmplY3QgPSBmdW5jdGlvbihxdWVyeU9iamVjdCwgZ2FtZU5hbWUpIHtcclxuXHQvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgcXVlcmllcywgcmVjdXJzZVxyXG5cdGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5T2JqZWN0KSkgcmV0dXJuIHF1ZXJ5T2JqZWN0Lm1hcChmdW5jdGlvbihxdWVyeSkge1xyXG5cdFx0cmV0dXJuIHJlZ2lzdGVyUXVlcnlPYmplY3QocXVlcnkpXHJcblx0fSk7XHJcblxyXG5cdHZhciB7IG5hbWUsIHF1ZXJ5LCBkZXNjcmlwdGlvbiA9IFwiTm8gZGVzY3JpcHRpb24gZ2l2ZW4uXCIgfSA9IHF1ZXJ5T2JqZWN0O1xyXG5cdC8vIEVuZm9yY2UgbmFtaW5nIGNvbnZlbnRpb24sIGZpcnN0IGNoYXJhY3RlciAnQCdcclxuXHRpZiAobmFtZVswXSAhPSBcIkBcIikgbmFtZSA9IFwiQFwiLmNvbmNhdChuYW1lKVxyXG5cclxuXHQvLyBDaGVjayBmb3IgZHVwbGljYXRlcy4gQWJvcnQgaWYgc28sIGJ1dCByZXR1cm4gdGhlIGRhdGEgZm9yIGRpc3BsYXkgcHVycG9zZXMuXHJcblx0aWYgKHJlZ2lzdHJ5LnF1ZXJpZXNbbmFtZV0gJiYgcmVnaXN0cnkucXVlcmllc1tuYW1lXS5xdWVyeSA9PSBxdWVyeSAmJlxyXG5cdFx0cmVnaXN0cnkucXVlcmllc1tuYW1lXS5kZXNjcmlwdGlvbiA9PSBkZXNjcmlwdGlvbilcclxuXHRcdHJldHVybiB7IG5hbWUsIGRlc2NyaXB0aW9uIH07XHJcblxyXG5cdC8vIGFzc2lnbiBpZCBhbmQgYWRkIHRvIHJlZ2lzdHJ5XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKG5hbWUsIFwicXVlcnlcIilcclxuXHRyZWdpc3RyeS5xdWVyaWVzW2lkXSA9IHsgcXVlcnksIGRlc2NyaXB0aW9uIH1cclxuXHJcblx0Ly9yZXR1cm4gdGhlIGRhdGEgZm9yIGRpc3BsYXkgcHVycG9zZXNcclxuXHRyZXR1cm4geyBpZCwgZGVzY3JpcHRpb24gfVxyXG59XHJcblxyXG5cclxuXHJcbnZhciBzdG9ja0dhbWVzID0ge1xyXG5cdC8vIHV0aWxpdHkgZnVuY3Rpb24gdG8gY3JlYXRlIHR3byB3YXlzIHRvIGNhbGwgYSBnYW1lLCBlaXRoZXIgd2l0aCBhbGwgdGhlIGFyZ3VtZW50cywgb3IgY3VycmllZCwgd2hlcmUgdGhlIHJldHVybmVkIGZ1bmN0aW9uIHRha2VzIHBsYXllcnMgYW5kIHBhcmFtZXRlcnNcclxuXHQvLyBUaGUgY29tYmluZVBhcmFtZXRlcnMgc2V0dGluZyB3aWxsXHJcblx0Z2FtZVdyYXBwZXIoZ2FtZSwge1xyXG5cdFx0YXJndW1lbnRWYWxpZGF0b3IgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0sXHJcblx0XHRjb21iaW5lUGFyYW1ldGVycyA9IHRydWUsXHJcblx0XHRnYW1lRGVzY3JpcHRpb24gPSBcIk5vIGRlc2NyaXB0aW9uIGdpdmVuLlwiLFxyXG5cdFx0c3RyYXRlZ3lMb2FkZXIgPSBudWxsLFxyXG5cdFx0cXVlcnlMb2FkZXIgPSBudWxsXHJcblx0fSA9IHt9KSB7XHJcblxyXG5cdFx0dmFyIGdlbmVyYXRlO1xyXG5cclxuXHRcdC8vIElmIHRoZXJlJ3MgYSBzdHJhdGVneSBsb2FkZXIsIG1ha2Ugc3VyZSBpdCBvbmx5IHJ1bnMgb25jZVxyXG5cdFx0dmFyIGxvYWRTdHJhdGVnaWVzXHJcblx0XHRpZiAoaXNGdW5jdGlvbihzdHJhdGVneUxvYWRlcikpIGxvYWRTdHJhdGVnaWVzID0gb25jZShmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHJlZ2lzdGVyU3RyYXRlZ3lPYmplY3Qoc3RyYXRlZ3lMb2FkZXIoKSk7XHJcblx0XHR9KTtcclxuXHRcdGVsc2UgbG9hZFN0cmF0ZWdpZXMgPSBmdW5jdGlvbigpIHt9XHJcblxyXG5cdFx0Ly8gSWYgdGhlcmUncyBhIHF1ZXJ5IGxvYWRlciwgbWFrZSBzdXJlIGl0IG9ubHkgcnVucyBvbmNlXHJcblx0XHR2YXIgbG9hZFF1ZXJpZXMsIHF1ZXJpZXNcclxuXHRcdGlmIChpc0Z1bmN0aW9uKHF1ZXJ5TG9hZGVyKSkgbG9hZFF1ZXJpZXMgPSBvbmNlKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gcmVnaXN0ZXJRdWVyeU9iamVjdChxdWVyeUxvYWRlcigpKTtcclxuXHRcdH0pO1xyXG5cdFx0ZWxzZSBsb2FkUXVlcmllcyA9IGZ1bmN0aW9uKCkge31cclxuXHJcblx0XHQvLyBydW4gdGhlIGdhbWUuIE9wdGlvbmFsbHksIHZhbGlkYXRlIHRoZSBhcmd1bWVudHMgYW5kIGxvYWQgc3RyYWdlaWVzIGZpcnN0XHJcblx0XHRnZW5lcmF0ZSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcclxuXHRcdFx0dmFyIHJlc3VsdCA9IGFyZ3VtZW50VmFsaWRhdG9yKC4uLmFyZ3MpXHJcblx0XHRcdGlmIChyZXN1bHQgPT09IHRydWUpIHtcclxuXHRcdFx0XHRsb2FkU3RyYXRlZ2llcygpO1xyXG5cdFx0XHRcdHF1ZXJpZXMgPSBsb2FkUXVlcmllcygpO1xyXG5cdFx0XHRcdHJldHVybiBnYW1lKC4uLmFyZ3MpO1xyXG5cdFx0XHR9IGVsc2UgdGhyb3cgbmV3IEVycm9yKHJlc3VsdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY3JlYXRlcyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBnYW1lLCB3aGljaCBhY2NlcHRzIHRoZSBmaXJzdCBhcmd1bWVudCAocGxheWVycykgYW5kIGxhc3QgYXJndW1lbnQgKHBhcmFtZXRlcnMpLCBhbmQgcGFzc2VzIGl0IGZvcndhcmQuXHJcblx0XHQvLyBJZiBjb21iaW5lUGFyYW1ldGVycyBpcyBzZXQgdG8gdHJ1ZSwgdGhlbiB0aGUgc2Vjb25kIGFyZ3VtZW50IG9mIHRoZSByZXR1cm5lZCBmdW5jdGlvbiB3aWxsIGdldCBtZXJnZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudFxyXG5cdFx0Ly8gZ2l2ZW4gd2hlbiBnZW5lcmF0b3IgaXMgY2FsbGVkLlxyXG5cdFx0Z2VuZXJhdGUuY3JlYXRlR2VuZXJhdG9yID0gZnVuY3Rpb24oLi4uYXJncykge1xyXG5cclxuXHRcdFx0dmFyIGdhbWVDb2RlID0gZXNwcmltYS5wYXJzZVNjcmlwdChcIihcIiArIGdhbWUudG9TdHJpbmcoKSArIFwiKVwiKVxyXG5cclxuXHRcdFx0dmFyIGdhbWVBcmdzID0gZ2FtZUNvZGUuYm9keVswXS5leHByZXNzaW9uLnBhcmFtc1xyXG5cdFx0XHR2YXIgbGFzdEFyZyA9IGdhbWVBcmdzW2dhbWVBcmdzLmxlbmd0aCAtIDFdXHJcblxyXG5cdFx0XHR2YXIgb3JpZ2luYWxQYXJhbWV0ZXJzXHJcblx0XHRcdGlmICgobGFzdEFyZy5uYW1lICYmIGxhc3RBcmcubmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInBhcmFtZXRlcnNcIikgfHwgbGFzdEFyZy50eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIiB8fFxyXG5cdFx0XHRcdChsYXN0QXJnLnR5cGUgPT0gXCJBc3NpZ25tZW50UGF0dGVyblwiICYmIGxhc3RBcmcubGVmdC50eXBlID09IFwiT2JqZWN0UGF0dGVyblwiKSkge1xyXG5cdFx0XHRcdC8vIENoZWNrIHRoYXQgdGhlIGdhbWUgYXJndW1lbnRzIGFuZCBjcmVhdGVHZW5lcmF0b3IgYXJndW1lbnRzIGFyZSB0aGUgY29ycmVjdCBsZW5ndGhzLiBjcmVhdGVHZW5lcmF0b3Igc2hvdWxkIGJlXHJcblx0XHRcdFx0Ly8gMSBsZXNzIHRoYW4gZ2FtZSwgYmVjYXVzZSBwbGF5ZXJzIGlzIG9taXR0ZWQuXHJcblx0XHRcdFx0Ly8gVE9ETzogdXNlIGVzcHJpbWEgdG8gYWxsb3cgcGxheWVycyB0byBiZSBhbnl3aGVyZSBpbiB0aGUgZ2FtZSBkZWZpbml0aW9uIChvciBldmVuIG9taXR0ZWQpIHJhdGhlciB0aGFuIGZpcnN0XHJcblx0XHRcdFx0aWYgKGFyZ3MubGVuZ3RoID09IGdhbWVBcmdzLmxlbmd0aCAtIDEpIG9yaWdpbmFsUGFyYW1ldGVycyA9IGFyZ3MucG9wKCk7XHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24ocGxheWVycywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblxyXG5cdFx0XHRcdC8vIElmIGNvbWJpbmluZyBwYXJhbWV0ZXJzLCBtZXJnZSBhbmQgcmVtb3ZlIGZyb20gYXJndW1lbnRzXHJcblx0XHRcdFx0aWYgKGNvbWJpbmVQYXJhbWV0ZXJzICYmIG9yaWdpbmFsUGFyYW1ldGVycykgcGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbmFsUGFyYW1ldGVycyxcclxuXHRcdFx0XHRcdHBhcmFtZXRlcnMpXHJcblxyXG5cdFx0XHRcdHJldHVybiBnZW5lcmF0ZShwbGF5ZXJzLCAuLi5hcmdzLCBwYXJhbWV0ZXJzKVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQWxsb3cgZm9yIGdhbWUgZGVzY3JpcHRpb24gZmVhdHVyZVxyXG5cdFx0Z2VuZXJhdGUuZGVzY3JpcHRpb24gPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIGdhbWVEZXNjcmlwdGlvbjtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gRGlzcGxheSBhbnkgcXVlcmllc1xyXG5cdFx0Z2VuZXJhdGUucXVlcmllcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gcXVlcmllcztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2VuZXJhdGU7XHJcblx0fVxyXG5cclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc3RvY2tHYW1lcztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBTdHJhdGVnaWVzXHJcbnZhciB7IFN0cmF0ZWdpZXMgfSA9IHJlcXVpcmUoXCIuLi9zdHJhdGVneVwiKTtcclxuXHJcbi8vIFBsYXllcnNcclxudmFyIHsgUGxheWVyIH0gPSByZXF1aXJlKFwiLi4vcGxheWVyXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0Ly8gQ3JlYXRlIGEgcGxheWVyIGZvciBlYWNoIGF2YWlsYWJsZSBzdHJhdGVneVxyXG5cdGdlbmVyYXRlUG9wdWxhdGlvbigpIHtcclxuXHRcdHZhciBwbGF5ZXJzID0gW107XHJcblxyXG5cdFx0U3RyYXRlZ2llcygpLmZvckVhY2goZnVuY3Rpb24oc3RyYXRlZ3kpIHtcclxuXHRcdFx0cGxheWVycy5wdXNoKFBsYXllcih7IGFzc2lnbjogc3RyYXRlZ3kgfSkpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHBsYXllcnM7XHJcblx0fVxyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciB7U3luY2hyb25vdXNQcm9taXNlfSA9IHJlcXVpcmUoJ3N5bmNocm9ub3VzLXByb21pc2UnKTtcclxuXHJcbnZhciB0dXJuID0ge1xyXG5cdFxyXG5cdC8vUmVjdXJzZSB0aHJvdWdoIHRoZSBvcHRpb25zIGluIGlucHV0LCBhbmQgd3JpdGUgdmFsIHRvIG91dHB1dC4gXHJcblx0cmVjdXJzZSA6IGZ1bmN0aW9uIHJlY3Vyc2UoaW5wdXQsIG91dHB1dCwgdmFsLCB2YWxHZW5lcmF0b3I9ZnVuY3Rpb24oKXt9LCBwYXRoPVtdKXtcclxuXHRcdHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZShwYXRoKS50aGVuKGZ1bmN0aW9uKHBhdGgpe1xyXG5cdFx0XHRcclxuXHRcdFx0Ly9TaW5jZSB3ZSBzbGljZSB0aGUgYXJyYXkgZWFjaCB0aW1lLCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBlbnRyaWVzIGxlZnQgdGhlbiB3ZSdyZSBkb25lIHdpdGggdGhpcyBicmFuY2guXHJcblx0XHRcdGlmIChpbnB1dC5sZW5ndGggPT0gMCkgcmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKHBhdGgpXHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0Ly9BbW9uZyBhbGwgdmFsdWVzIGZyb20gdGhlIGFycmF5XHJcblx0XHRcdHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UuYWxsKGlucHV0WzBdLm1hcChmdW5jdGlvbihpdGVtKXtcclxuXHRcdFx0XHR2YXIgdmFsdWU7XHJcblx0XHRcdFx0dmFyIHNwbGl0UGF0aCA9IHBhdGguc2xpY2UoMCkuY29uY2F0KGl0ZW0pO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vSWYgdGhlcmUgYXJlIG1vcmUgaXRlbXMgdG8gaXRlcmF0ZSBvdmVyLCBpbmNsdWRlIHRoZW0gaW4gdGhlIG91dHB1dCB0aGVuIHJlY3Vyc2UuXHJcblx0XHRcdFx0Ly9JZiBub3QsIHB1dCBpbiB0aGUgbmV3IHZhbHVlLlxyXG5cdFx0XHRcdGlmIChpbnB1dC5sZW5ndGggPT0gMSkge1xyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHQvL0lmIHZhbCBpcyBhIGZ1bmN0aW9uLCB3cmFwIGl0IGluIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGdldCBzdXBwbGllZCBhbiBhcmd1bWVudCB3aXRoIHdoZXJlIHdlIGFyZVx0XHRcdFx0XHJcblx0XHRcdFx0XHRpZiAodHlwZW9mIHZhbCA9PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdFx0XHRcdFx0dmFsdWUgPSBmdW5jdGlvbigpe1x0XHJcblx0XHRcdFx0XHRcdFx0dmFyIGFyZ3MgPSBbc3BsaXRQYXRoXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbC5hcHBseShudWxsLCBhcmdzKTtcclxuXHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2UgdmFsdWUgPSB2YWwgfHwgdmFsR2VuZXJhdG9yKHNwbGl0UGF0aCk7XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdG91dHB1dFtpdGVtXSA9IHZhbHVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIG91dHB1dFtpdGVtXSA9IHt9O1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdHJldHVybiByZWN1cnNlKGlucHV0LnNsaWNlKDEpLG91dHB1dFtpdGVtXSwgdmFsLCB2YWxHZW5lcmF0b3IsIHNwbGl0UGF0aCk7XHJcblx0XHRcdH0pKTtcdFx0XHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB0dXJuOyIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy9FeHRlcm5hbCBkZXBlbmRlbmN5XHJcbnZhciBqc29uYXRhID0gcmVxdWlyZShcImpzb25hdGFcIik7XHJcblxyXG5cclxudmFyIHsgaXNPYmplY3QsIGlzRnVuY3Rpb24gfSA9IHJlcXVpcmUoXCIuL2hlbHBlcmZ1bmN0aW9uc1wiKShcImdlbmVyYWxcIik7XHJcblxyXG4vL0V4dGVuc2lvbiBvZiBhcnJheSB0byBoYW5kbGUgaGlzdG9yeSBsaXN0cy5cclxuZnVuY3Rpb24gSGlzdG9yeSguLi5hcmdzKSB7XHJcblx0aWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIGFyZ3MgPSBhcmdzWzBdO1xyXG5cclxuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJncywgSGlzdG9yeS5wcm90b3R5cGUpO1xyXG5cclxuXHRhcmdzLmxvZyA9IGFyZ3Muc2xpY2UoKTtcclxuXHRhcmdzLmxvZy50cmVlID0gYXJncztcclxuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJncy5sb2csIEhpc3RvcnkucHJvdG90eXBlKTtcclxuXHJcblx0YXJncy5zY29yZXMgPSBbXTtcclxuXHRhcmdzLnNjb3Jlcy50cmVlID0gYXJncztcclxuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJncy5zY29yZXMsIEhpc3RvcnkucHJvdG90eXBlKTtcclxuXHJcblx0cmV0dXJuIGFyZ3M7XHJcbn1cclxuXHJcbkhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBcnJheS5wcm90b3R5cGUpO1xyXG5IaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhpc3Rvcnk7XHJcblxyXG4vL1RvIGFkZCBlbnRyeVxyXG5IaXN0b3J5LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihlbnRyeSkge1xyXG5cdC8vQWRkIHRvIGhpc3RvcnkgYW5kIHRvIGxvZ1xyXG5cdHRoaXMucHVzaChlbnRyeSk7XHJcblx0aWYgKHRoaXMubG9nKSB0aGlzLmxvZy5wdXNoKGVudHJ5KTtcclxuXHJcblx0Ly9DeWNsZSB1cCB0aGUgcGFyZW50IHRyZWUsIGFkZCB0byBlYWNoIGxvZ1xyXG5cdHZhciBjaGVjayA9IHRoaXM7XHJcblx0aWYgKGNoZWNrLnRyZWUgaW5zdGFuY2VvZiBIaXN0b3J5ICYmIGNoZWNrLnRyZWUucGFyZW50IGluc3RhbmNlb2YgSGlzdG9yeSkge1xyXG5cdFx0Y2hlY2sudHJlZS5wYXJlbnQubG9nLmFkZChlbnRyeSk7XHJcblx0fVxyXG5cdGlmIChjaGVjay5wYXJlbnQgaW5zdGFuY2VvZiBIaXN0b3J5KSB7XHJcblx0XHRjaGVjay5wYXJlbnQubG9nLmFkZChlbnRyeSk7XHJcblx0fVxyXG5cclxuXHQvL0lmIHdlJ3JlIGJlaW5nIGNhbGxlZCBmclxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vVG8gYWRkIGVudHJ5IHdpdGhvdXQgbG9nZ2luZyAoZm9yIHBsYXlhYmxlcyB0aGF0IHdvdWxkIGxpa2UgdGhlIHRyZWUgaGlzdG9yeVxyXG4vL3RvIGJlIHN0cnVjdHVyZWQgZGlmZmVyZW50bHkgdGhhbiB0aGUgbG9nIGhpc3RvcnkuXHJcbkhpc3RvcnkucHJvdG90eXBlLmFkZE5vTG9nID0gZnVuY3Rpb24oZW50cnkpIHtcclxuXHR0aGlzLnB1c2goZW50cnkpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuXHJcbkhpc3RvcnkucHJvdG90eXBlLmFkZFNjb3JlcyA9IGZ1bmN0aW9uKGVudHJ5KSB7XHJcblx0Ly9BZGQgdG8gaGlzdG9yeVxyXG5cdHRoaXMuc2NvcmVzLnB1c2goZW50cnkpO1xyXG5cclxuXHQvL0N5Y2xlIHVwIHRoZSBwYXJlbnQgdHJlZSwgYWRkIHRvIGVhY2ggbG9nXHJcblx0dmFyIGNoZWNrID0gdGhpcztcclxuXHRpZiAoY2hlY2sucGFyZW50IGluc3RhbmNlb2YgSGlzdG9yeSkge1xyXG5cdFx0Y2hlY2sucGFyZW50LmFkZFNjb3JlcyhlbnRyeSk7XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuXHJcbi8vQSB0ZW1wb3JhcnkgSGlzdG9yeSB0aGF0IGNhbiBiZSBtZXJnZWQgYmFjayBpbiBsYXRlci4gVGhlIGNoaWxkIGFuZCBwYXJlbnQgYXJlIGxpbmtlZCB1bnRpbCAub3JwaGFuKCkgaXMgY2FsbGVkLlxyXG5IaXN0b3J5LnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uKHBhcmVudCA9IHRoaXMpIHtcclxuXHR2YXIgaCA9IG5ldyBIaXN0b3J5KCk7XHJcblx0aC5wYXJlbnQgPSBwYXJlbnQ7XHJcblx0cmV0dXJuIGg7XHJcbn07XHJcblxyXG4vL1NhbWUgYXMgLmNoaWxkIGV4Y2VwdCBpbmNsdWRlcyBwcmlvciBwYXJlbnQgaGlzdG9yeSB3aGVuIC5wcmludCgpIGlzIGNhbGxlZC5cclxuSGlzdG9yeS5wcm90b3R5cGUuY2hpbGRXaXRoQ29udGVudCA9IGZ1bmN0aW9uKHBhcmVudCA9IHRoaXMpIHtcclxuXHR2YXIgc3RvcmVkTG9nID0gcGFyZW50LnNsaWNlKCk7XHJcblx0dmFyIHN0b3JlZFNjb3JlcyA9IHBhcmVudC5zbGljZSgpO1xyXG5cclxuXHR2YXIgaCA9IG5ldyBIaXN0b3J5KCk7XHJcblxyXG5cclxuXHRoLmxvZy5wcmludCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0SGlzdG9yeS5wcm90b3R5cGUucHJpbnQuY2FsbChzdG9yZWRMb2cuY29uY2F0KGgubG9nKSlcclxuXHR9XHJcblx0aC5zY29yZXMucHJpbnQgPSBmdW5jdGlvbigpIHtcclxuXHRcdEhpc3RvcnkucHJvdG90eXBlLnByaW50LmNhbGwoc3RvcmVkU2NvcmVzLmNvbmNhdChoLnNjb3JlcykpXHJcblx0fVxyXG5cclxuXHRoLnBhcmVudCA9IHBhcmVudDtcclxuXHRyZXR1cm4gaDtcclxufTtcclxuXHJcbi8vVGhpcyBzZXZlcnMgdGhlIGxpbmsgYmV0d2VlbiB0aGUgdGVtcG9yYXJ5IGhpc3RvcnkgYW5kIGl0cyBwYXJlbnQuIFVzZSB0aGlzIHdoZW4gbWVyZ2luZyBjb21wb3NpdGUgZW50cmllcy5cclxuSGlzdG9yeS5wcm90b3R5cGUub3JwaGFuID0gZnVuY3Rpb24oKSB7XHJcblx0ZGVsZXRlIHRoaXMucGFyZW50O1xyXG5cdGRlbGV0ZSB0aGlzLmxvZztcclxuXHRkZWxldGUgdGhpcy5zY29yZXM7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vL0NsZWFyIGhpc3RvcnlcclxuSGlzdG9yeS5wcm90b3R5cGUuY2xlYXJIaXN0b3J5ID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5zcGxpY2UoMCwgdGhpcy5sZW5ndGgpO1xyXG5cdGlmICh0aGlzLmxvZykgdGhpcy5sb2cuc3BsaWNlKDAsIHRoaXMubG9nLmxlbmd0aCk7XHJcblx0aWYgKHRoaXMuc2NvcmVzKSB0aGlzLnNjb3Jlcy5zcGxpY2UoMCwgdGhpcy5zY29yZXMubGVuZ3RoKTtcclxuXHRkZWxldGUgdGhpcy5wYXJlbnQ7XHJcbn07XHJcblxyXG4vL0VuZCB0aGUgZ2FtZS5cclxuSGlzdG9yeS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5zdG9wID0gdHJ1ZTtcclxuXHRpZiAodGhpcy5wYXJlbnQpIHRoaXMucGFyZW50LmVuZCgpO1xyXG59O1xyXG5cclxuLy9HZXQgYSBwYXJ0aWN1bGFyIHNvcnQgb2YgZW50cnksIGVnLiBUdXJuLlxyXG5IaXN0b3J5LnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24odHlwZSkge1xyXG5cdHJldHVybiBuZXcgSGlzdG9yeShcclxuXHRcdHRoaXMuZmlsdGVyKGZ1bmN0aW9uKGVudHJ5KSB7XHJcblx0XHRcdC8vSWYgaXQncyBub3QgYW4gb2JqZWN0LCBkb24ndCBldmVuIGJvdGhlci5cclxuXHRcdFx0aWYgKCFpc09iamVjdChlbnRyeSkpIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdGZvciAodmFyIGtleSBpbiBlbnRyeSkge1xyXG5cdFx0XHRcdGlmIChrZXkgPT0gdHlwZSkgcmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH0pXHJcblx0KTtcclxufTtcclxuXHJcbkhpc3RvcnkucHJvdG90eXBlLm1vc3RSZWNlbnQgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpc1t0aGlzLmxlbmd0aCAtIDFdXHJcbn1cclxuXHJcbi8vSGVscCByZWFkIHRoZSBoaXN0b3J5IGluIENocm9tZSB3aXRoIGxlc3MgY2x1dHRlci5cclxuSGlzdG9yeS5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgaGlzdG9yeSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcykpO1xyXG5cdGhpc3RvcnkucXVlcnkgPSBIaXN0b3J5LnByb3RvdHlwZS5xdWVyeVxyXG5cdHJldHVybiBoaXN0b3J5O1xyXG59O1xyXG5cclxuSGlzdG9yeS5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbihxdWVyeVN0cmluZywgLi4uYXJncykge1xyXG5cdC8vIENoZWNrIGZvciBwcmUtcHJvZ3JhbW1lZCBxdWVyeSwgZGVzaWduYXRlZCBieSAnQCdcclxuXHRpZiAocXVlcnlTdHJpbmdbMF0gPT0gXCJAXCIgJiYgcmVnaXN0cnkucXVlcmllc1txdWVyeVN0cmluZ10pIHF1ZXJ5U3RyaW5nID0gcmVnaXN0cnkucXVlcmllc1txdWVyeVN0cmluZ10ucXVlcnlcclxuXHRlbHNlIGlmIChxdWVyeVN0cmluZ1swXSA9PSBcIkBcIikgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5zbGljZSgxKVxyXG5cclxuXHRyZXR1cm4ganNvbmF0YShxdWVyeVN0cmluZykuZXZhbHVhdGUodGhpcywgLi4uYXJncyk7XHJcbn1cclxuXHJcbi8vU3VwcGx5IGFuIGVudHJ5LCBpdCB3aWxsIGNoZWNrIGZvciBhIHByb3BlcnR5IHRoYXQgaXMgYSBIaXN0b3J5XHJcbkhpc3RvcnkucHJvdG90eXBlLnJlY3Vyc2UgPSBmdW5jdGlvbih0eXBlKSB7XHJcblx0dmFyIGxpc3QgPSB0aGlzO1xyXG5cclxuXHRyZXR1cm4gbmV3IEhpc3RvcnkoXHJcblx0XHRsaXN0Lm1hcChmdW5jdGlvbihlbnRyeSkge1xyXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gZW50cnkpIHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhrZXksIGVudHJ5KTtcclxuXHRcdFx0XHRpZiAoZW50cnlba2V5XSBpbnN0YW5jZW9mIEhpc3RvcnkpIHJldHVybiBlbnRyeVtrZXldLnJlY3Vyc2UodHlwZSk7XHJcblx0XHRcdFx0ZWxzZSBpZiAoa2V5ID09IHR5cGUpIHJldHVybiBlbnRyeTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH0pXHJcblx0KTtcclxufTtcclxuXHJcbi8vQWNjZXB0IGEgSGlzdG9yeSBhbmQgcmV0dXJuIG9uZSBzdWl0YWJsZSBmb3IgdGhlIHVzZXJcclxuZnVuY3Rpb24gVXNlckhpc3RvcnkoaGlzdG9yeSkge1xyXG5cdHZhciB1c2VySGlzdG9yeSA9IGhpc3RvcnkubWFwKGZ1bmN0aW9uKGVudHJ5KSB7XHJcblx0XHRyZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbnRyeSkpO1xyXG5cdH0pO1xyXG5cdGlmIChoaXN0b3J5LmxvZykge1xyXG5cdFx0dXNlckhpc3RvcnkubG9nID0gbmV3IFVzZXJIaXN0b3J5KGhpc3RvcnkubG9nKVxyXG5cdH07XHJcblx0aWYgKGhpc3Rvcnkuc2NvcmVzKSB7XHJcblx0XHR1c2VySGlzdG9yeS5zY29yZXMgPSBuZXcgVXNlckhpc3RvcnkoaGlzdG9yeS5zY29yZXMpXHJcblx0fVxyXG5cclxuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YodXNlckhpc3RvcnksIFVzZXJIaXN0b3J5LnByb3RvdHlwZSk7XHJcblxyXG5cdC8vQXR0YWNoIG1ldGhvZHMgZnJvbSBIaXN0b3J5LCB3cmFwcGVkIGluIGEgZnVuY3Rpb24uIElmIHRob3NlIG1ldGhvZHMgcmV0dXJuIGEgaGlzdG9yeSxcclxuXHQvL3RoZW4gdGhlIGZ1bmN0aW9uIHdpbGwgY29udmVydCB0aGF0IHRvIGEgdXNlckhpc3RvcnkuXHJcblx0Zm9yICh2YXIgbWV0aG9kIGluIEhpc3RvcnkucHJvdG90eXBlKSB7XHJcblx0XHRpZiAoaXNGdW5jdGlvbihoaXN0b3J5W21ldGhvZF0pKSB7XHJcblx0XHRcdGlmIChtZXRob2QgIT0gXCJjb25zdHJ1Y3RvclwiKVxyXG5cdFx0XHRcdHVzZXJIaXN0b3J5W21ldGhvZF0gPSAoZnVuY3Rpb24obWV0aG9kKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdHZhciByZXN1bHQgPSBoaXN0b3J5W21ldGhvZF0uYXBwbHkoaGlzdG9yeSwgYXJndW1lbnRzKTtcclxuXHRcdFx0XHRcdFx0aWYgKHJlc3VsdCBpbnN0YW5jZW9mIEhpc3RvcnkpIHJldHVybiBuZXcgVXNlckhpc3RvcnkocmVzdWx0KTtcclxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoaXNPYmplY3QocmVzdWx0KSlcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcclxuXHRcdFx0XHRcdFx0ZWxzZSByZXR1cm4gcmVzdWx0O1xyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHR9KShtZXRob2QpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHVzZXJIaXN0b3J5O1xyXG59XHJcblxyXG5Vc2VySGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEhpc3RvcnkucHJvdG90eXBlKTtcclxuVXNlckhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVXNlckhpc3Rvcnk7XHJcblxyXG52YXIgZ2FtZUhpc3RvcnkgPSBuZXcgSGlzdG9yeSgpOyAvL1RPRE86IGFkZCBjaG9pY2Utb25seSBoaXN0b3J5XHJcblxyXG52YXIgdXNlckdhbWVIaXN0b3J5ID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBVc2VySGlzdG9yeShnYW1lSGlzdG9yeSlcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IEhpc3RvcnksIFVzZXJIaXN0b3J5LCBnYW1lSGlzdG9yeSwgdXNlckdhbWVIaXN0b3J5IH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy9XaGVuIGEgc3RyYXRlZ3kncyAuY2hvb3NlKCkgZnVuY3Rpb24gaXMgY2FsbGVkLCBpdCBpcyBnaXZlbiBhbiBpbmZvcm1hdGlvbiBzZXQuIFRoYXQgZGF0YSBpcyBhIGxpbWl0ZWQgbWFwIG9mIHRoZSBpbnRlcm5hbCBvYmplY3RzIG9mIHRoZSBnYW1lIGVuZ2luZSwgaW5jbHVkaW5nIGluZm9ybWF0aW9uIG9uIHRoZSBnYW1lIGhpc3RvcnkgYW5kIHRoZSBwbGF5ZXJzLiBUaGlzIGlzIHRocmVhZGVkIHRocm91Z2ggcGxheWFibGVzLCBtdWNoIGxpa2UgSGlzdG9yeSwgc28gdGhhdCBhIHBhcmVudCBwbGF5YWJsZSBjYW4gc3BlY2lmeSBhbiBpbmZvcm1hdGlvbiBzZXQgZm9yIHRoZSBwbGF5YWJsZXMgaXQgY2FsbHMsIG9yIGVsc2UgdGhlIGRlZmF1bHQgY29uc3RydWN0aW9uIHdpbGwgYmUgdXNlZC4gQWRkaXRpb25hbGx5LCB0aGUgdXNlciBjYW4gcHJvdmlkZSBhIGZpbHRlciBmdW5jdGlvbiwgdG8gc2VsZWN0aXZlbHkgZGVsZXRlIChvciBhZGQpIGluZm9ybWF0aW9uIGVsZW1lbnRzIGJlZm9yZSB0aGV5IGFyZSBwYXNzZWQgdG8gLmNob29zZSgpLlxyXG5cclxuLy9IaXN0b3J5IGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lSGlzdG9yeSwgSGlzdG9yeSB9ID0gcmVxdWlyZSgnLi9oaXN0b3J5Jyk7XHJcblxyXG4vL1BvcHVsYXRpb24gZnVuY3Rpb25zXHJcbnZhciB7IGdhbWVQb3B1bGF0aW9uLCBQbGF5ZXJMaXN0IH0gPSByZXF1aXJlKCcuL3BvcHVsYXRpb24nKTtcclxuXHJcblxyXG5mdW5jdGlvbiBJbmZvcm1hdGlvbihoaXN0b3J5ID0gZ2FtZUhpc3RvcnksIHBvcHVsYXRpb24gPSBnYW1lUG9wdWxhdGlvbiwgeyBwYXJlbnRIaXN0b3J5ID0gW10gfSA9IHt9KSB7XHJcblx0dGhpcy5oaXN0b3J5ID0gaGlzdG9yeTtcclxuXHR0aGlzLnBvcHVsYXRpb24gPSBwb3B1bGF0aW9uO1xyXG5cclxuXHQvLyBSZWNvcmQgYW55IGhpc3RvcnkgZW50cmllcyB0aGF0IG5lZWQgdG8gYmUgYWRkZWQgdG8gdGhlIHJlY29yZHNcclxuXHR0aGlzLnBhcmVudEhpc3RvcnkgPSBwYXJlbnRIaXN0b3J5LnNsaWNlKDApO1xyXG5cclxuXHR0aGlzLmFkZGl0aW9uYWwgPSBbXTtcclxuXHJcblx0dGhpcy51cGRhdGUoKTtcclxufTtcclxuXHJcbi8vQ2hlY2sgdGhlIHNvdXJjZSB0aGVuIGNhY2hlIGEgaGFyZC1jb3B5LlxyXG5JbmZvcm1hdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ocGxheWVyLCBsb2NhbCkge1xyXG5cdHRoaXMuaW5mb1BvcHVsYXRpb24gPSB0aGlzLnBvcHVsYXRpb24oKS5pbmZvKCk7XHJcblxyXG5cdHRoaXMuaW5mb0hpc3RvcnkgPSB7IGxvZzogdGhpcy5wYXJlbnRIaXN0b3J5LmNvbmNhdCh0aGlzLmhpc3RvcnkubG9nKS5zbGljZSgwKSwgc2NvcmVzOiB0aGlzLmhpc3Rvcnkuc2NvcmVzXHJcblx0XHRcdC5zbGljZSgwKSB9O1xyXG5cclxuXHR0aGlzLmFkZGl0aW9uYWwgPSBbXTtcclxuXHJcblx0Ly9SZXR1cm4gdmFsdWUuIE1pbWljcyAuZGVsaXZlcigpXHJcblx0dmFyIGluZm9ybWF0aW9uID0ge1xyXG5cdFx0aGlzdG9yeTogeyBsb2c6IHRoaXMuaW5mb0hpc3RvcnkubG9nLCBzY29yZXM6IHRoaXMuaW5mb0hpc3Rvcnkuc2NvcmVzIH0sXHJcblx0XHRwb3B1bGF0aW9uOiB0aGlzXHJcblx0XHRcdC5pbmZvUG9wdWxhdGlvblxyXG5cdH1cclxuXHRpZiAocGxheWVyKSBpbmZvcm1hdGlvbi5tZSA9IGluZm9ybWF0aW9uLnBvcHVsYXRpb24uZ2V0KHBsYXllci5pZCk7XHJcblx0aWYgKGxvY2FsKSBPYmplY3QuYXNzaWduKGluZm9ybWF0aW9uLCBsb2NhbCk7XHJcblxyXG5cdHJldHVybiBpbmZvcm1hdGlvbjtcclxufTtcclxuXHJcbi8vQ2xvbmUgdGhlIGNhY2hlZCBjb3BpZXMgYW5kIHByb3ZpZGUgdGhlbS4gV2lsbCBkZWxpdmVyIHRoZSBzYW1lIHRoaW5nIGV2ZXJ5IHRpbWUgdW50aWwgdXBkYXRlIGlzIGNhbGxlZC5cclxuSW5mb3JtYXRpb24ucHJvdG90eXBlLmRlbGl2ZXIgPSBmdW5jdGlvbihwbGF5ZXIsIGxvY2FsKSB7XHJcblx0dmFyIGluZm9ybWF0aW9uID0ge1xyXG5cdFx0aGlzdG9yeTogeyBsb2c6IHRoaXMuaW5mb0hpc3RvcnkubG9nLCBzY29yZXM6IHRoaXMuaW5mb0hpc3Rvcnkuc2NvcmVzIH0sXHJcblx0XHRwb3B1bGF0aW9uOiB0aGlzXHJcblx0XHRcdC5pbmZvUG9wdWxhdGlvblxyXG5cdH1cclxuXHJcblxyXG5cdGlmIChwbGF5ZXIpIGluZm9ybWF0aW9uLm1lID0gaW5mb3JtYXRpb24ucG9wdWxhdGlvbi5nZXQocGxheWVyLmlkKTtcclxuXHRpZiAobG9jYWwpIE9iamVjdC5hc3NpZ24oaW5mb3JtYXRpb24sIGxvY2FsKTtcclxuXHRpZiAodGhpcy5hZGRpdGlvbmFsKSB0aGlzLmFkZGl0aW9uYWwuZm9yRWFjaChmdW5jdGlvbihlbnRyeSkgeyBPYmplY3QuYXNzaWduKGluZm9ybWF0aW9uLCBlbnRyeSkgfSk7XHJcblxyXG5cdHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGluZm9ybWF0aW9uKSk7XHJcbn07XHJcblxyXG4vL1RoaXMgcHJvYmFibHkgZG9lc24ndCBuZWVkIHRvIGJlIGEgc2VwYXJhdGUgZnVuY3Rpb24sIGJ1dCBhZGRpbmcgaXQgaW4gY2FzZSBpdCBleHBhbmRzIGxhdGVyLlxyXG5JbmZvcm1hdGlvbi5wcm90b3R5cGUuYWRkQWRkaXRpb25hbCA9IGZ1bmN0aW9uKGVudHJ5ID0gbnVsbCkge1xyXG5cdGlmIChlbnRyeSkgdGhpcy5hZGRpdGlvbmFsLnB1c2goZW50cnkpO1xyXG59O1xyXG5cclxuLy9NYWtlIGNvcHkgb2YgdGhpcyBpbmZvcm1hdGlvbiBmdW5jdGlvbiwgd2hpY2ggYWxsb3dzIGZvciB1cGRhdGluZyBhbmQgZnJlZXppbmcuXHJcbkluZm9ybWF0aW9uLnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBpbmZvcm1hdGlvbiA9IG5ldyBJbmZvcm1hdGlvbih0aGlzLmhpc3RvcnksIHRoaXMucG9wdWxhdGlvbiwgeyBwYXJlbnRIaXN0b3J5OiB0aGlzLnBhcmVudEhpc3RvcnkgfSk7XHJcblxyXG5cdHJldHVybiBpbmZvcm1hdGlvbjtcclxufTtcclxuXHJcblxyXG5cclxuLy9HYW1lIHN0YXRlLCBhbmFsb2dvdXMgdG8gZ2FtZUhpc3RvcnlcclxudmFyIFBlcmZlY3RJbmZvcm1hdGlvbiA9IG5ldyBJbmZvcm1hdGlvbihnYW1lSGlzdG9yeSwgZ2FtZVBvcHVsYXRpb24pO1xyXG5cclxuLy9PdmVyd3JpdGUgLmRlbGl2ZXIoKS4gUGVyZmVjdEluZm9ybWF0aW9uIGlzIGFsd2F5cyB1cC10by1kYXRlISBUaHVzIG5vIG5lZWQgdG8gZG8gYSAybmQgSlNPTi5zdHJpbmdpZnkuXHJcblBlcmZlY3RJbmZvcm1hdGlvbi5kZWxpdmVyID0gZnVuY3Rpb24ocGxheWVyLCBsb2NhbCkge1xyXG5cclxuXHR2YXIgaW5mb3JtYXRpb24gPSB0aGlzLnVwZGF0ZShwbGF5ZXIsIGxvY2FsKTtcclxuXHJcblx0aWYgKHBsYXllcikgaW5mb3JtYXRpb24ubWUgPSBpbmZvcm1hdGlvbi5wb3B1bGF0aW9uLmdldChwbGF5ZXIuaWQpO1xyXG5cdGlmIChsb2NhbCkgT2JqZWN0LmFzc2lnbihpbmZvcm1hdGlvbiwgbG9jYWwpO1xyXG5cclxuXHRyZXR1cm4gaW5mb3JtYXRpb247XHJcbn07XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IEluZm9ybWF0aW9uLCBQZXJmZWN0SW5mb3JtYXRpb24gfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuXHJcbnZhciBsb2dnZXIgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgYXJncyA9IFsuLi5hcmd1bWVudHNdO1xyXG5cdHZhciBsZXZlbCA9IChhcmdzWzBdID09IFwic2lsbHlcIiB8fCAhYXJnc1swXSkgPyBcInRyYWNlXCIgOiBhcmdzWzBdO1xyXG5cdHZhciBsZXZlbCA9IGxldmVsID09IFwid2FybmluZ1wiID8gXCJ3YXJuXCIgOiBsZXZlbDtcclxuXHRhcmdzLnNoaWZ0KCk7XHJcblxyXG5cdGxvZ2dlci5sb2dnZXJbbGV2ZWxdLmFwcGx5KGxvZ2dlci5sb2dnZXIsIGFyZ3MpO1xyXG59O1xyXG5cclxuLy9sb2dnZXIubG9nZ2VyID0gY29uc29sZTtcdFx0XHRcdFx0Ly9UT0RPIGNsZWFuIHRoaXMgYWxsIHVwIGEgbG90LlxyXG5cclxudmFyIGdldExvZ2dlciA9IHJlcXVpcmUoXCJsb2dsZXZlbC1jb2xvcmVkLWxldmVsLXByZWZpeFwiKTtcclxudmFyIG9wdGlvbnMgPSB7IHByZWZpeDogJ25hc2hKUycsIGxldmVsOiAndHJhY2UnIH1cclxubG9nZ2VyLmxvZ2dlciA9IGdldExvZ2dlcihvcHRpb25zKVxyXG5cclxubG9nZ2VyLnNldExldmVsID0gZnVuY3Rpb24obGV2ZWwpIHtcclxuXHRsb2dnZXIubG9nZ2VyLmxldmVsID0gbGV2ZWw7XHJcblx0bG9nZ2VyLmxvZ2dlci5zZXRMZXZlbChsZXZlbClcclxufTtcclxuXHJcbi8qXHJcbmxvZ2dlci51c2VXaW5zdG9uID0gZnVuY3Rpb24oKXtcclxuXHJcblx0dmFyIHdpbnN0b24gPSByZXF1aXJlKCd3aW5zdG9uJyk7XHJcblx0dmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XHJcblxyXG5cdHdpbnN0b24ubGV2ZWwgPSBcIndhcm5cIjtcclxuXHJcblx0d2luc3Rvbi5jbGVhcigpXHJcblx0d2luc3Rvbi5hZGQod2luc3Rvbi50cmFuc3BvcnRzLkNvbnNvbGUsIHtcclxuXHRcdGxldmVsOiAndHJhY2UnLFxyXG5cdFx0cHJldHR5UHJpbnQ6ICBmdW5jdGlvbiAoIG9iamVjdCApe1xyXG5cdFx0XHRyZXR1cm4gdXRpbC5pbnNwZWN0KG9iamVjdCk7XHJcblx0XHR9LFxyXG5cdFx0Y29sb3JpemU6IHRydWUsXHJcblx0XHRzaWxlbnQ6IGZhbHNlLFxyXG5cdFx0dGltZXN0YW1wOiBmYWxzZVxyXG5cdH0pO1xyXG5cclxuXHR0aGlzLmxvZ2dlciA9IHdpbnN0b247XHJcbn07XHJcbiovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGxvZ2dlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZShcIi4vbG9nZ2VyXCIpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlzRnVuY3Rpb24gfSA9IHJlcXVpcmUoXCIuL2hlbHBlckZ1bmN0aW9uc1wiKShcImdlbmVyYWxcIik7XHJcblxyXG4vLyBFeHRlbmQgZnVuY3Rpb24sIHRoZSBzbmVha3kgd2F5LlxyXG52YXIgdmFyaWFibGVQcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZ1bmN0aW9uLnByb3RvdHlwZSk7XHJcblxyXG52YXJpYWJsZVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKHZhbHVlLCB7IGVuZm9yY2VOdW1iZXIgPSB0cnVlIH0gPSB7fSkge1xyXG5cdHZhciB2YXJpYWJsZSA9IHRoaXM7XHJcblx0dmFyaWFibGUudmFsdWUgPSBlbmZvcmNlTnVtYmVyID8gdmFsdWUgKiAxIDogdmFsdWU7XHJcblx0dmFyaWFibGUuZW5mb3JjZU51bWJlciA9IGVuZm9yY2VOdW1iZXJcclxuXHJcblx0dGhpcy5pZCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIF9wbGF5YWJsZS5pZDtcclxuXHR9OyAvL1RPRE86IHdvcmsgb24gaWRzIGFuZCByZWdpc3RyYXRpb25cclxufTtcclxuXHJcbnZhcmlhYmxlUHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy52YWx1ZTtcclxufTtcclxuXHJcbnZhcmlhYmxlUHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmNhbGwoKTtcclxufTtcclxudmFyaWFibGVQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5jYWxsKCk7XHJcbn07XHJcbnZhcmlhYmxlUHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5jYWxsKCk7XHJcbn07XHJcblxyXG52YXJpYWJsZVByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuZXdWYWx1ZSkge1xyXG5cdHRoaXMudmFsdWUgPSB0aGlzLmVuZm9yY2VOdW1iZXIgPyBuZXdWYWx1ZSAqIDEgOiBuZXdWYWx1ZVxyXG5cdHJldHVybiB0aGlzLnZhbHVlO1xyXG59O1xyXG5cclxuLy9SZXB1cnBvc2UgdGhlIHZlcnktc2ltaWxhciBjb2RlIGZvciBWYXJpYWJsZSwgYnV0IHJlLXdyaXRlIGNlcnRhaW4ga2V5c1xyXG52YXIgZXhwcmVzc2lvblByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRnVuY3Rpb24ucHJvdG90eXBlKTtcclxuXHJcbmV4cHJlc3Npb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBmdW5jdGlvbihleHByZXNzaW9uKSB7XHJcblx0aWYgKCFpc0Z1bmN0aW9uKGV4cHJlc3Npb24pKSBsb2coXCJlcnJvclwiLCBcIkV4cHJlc3Npb24gbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcclxuXHJcblx0dmFyIHZhbHVlID0gZXhwcmVzc2lvbigpO1xyXG5cdGlmIChpc05hTih2YWx1ZSkpIGxvZyhcImVycm9yXCIsIFwiRXhwcmVzc2lvbiBtdXN0IHJldHVybiBhIG51bWJlclwiKTsgLy9UT0RPOiBzaG91bGQgRXhwcmVzc2lvbnMvVmFyaWFibGVzIGFsbG93IHN0cmluZ3M/XHJcblxyXG5cdHRoaXMudmFsdWUgPSBleHByZXNzaW9uO1xyXG5cclxuXHRyZXR1cm4gdmFsdWU7XHJcbn07XHJcblxyXG5leHByZXNzaW9uUHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy52YWx1ZSgpICogMTtcclxufTtcclxuXHJcbmV4cHJlc3Npb25Qcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuY2FsbCgpO1xyXG59O1xyXG5leHByZXNzaW9uUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuY2FsbCgpO1xyXG59O1xyXG5leHByZXNzaW9uUHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5jYWxsKCk7XHJcbn07XHJcblxyXG5leHByZXNzaW9uUHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5ld0V4cHJlc3Npb24pIHtcclxuXHRpZiAoIWlzRnVuY3Rpb24obmV3RXhwcmVzc2lvbikpXHJcblx0XHRsb2coXCJlcnJvclwiLCBcIkV4cHJlc3Npb24gbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcclxuXHJcblx0dmFyIHZhbHVlID0gbmV3RXhwcmVzc2lvbigpO1xyXG5cdHRoaXMudmFsdWUgPSBuZXdFeHByZXNzaW9uO1xyXG5cclxuXHRyZXR1cm4gdmFsdWU7XHJcbn07XHJcblxyXG4vL1Byb2R1Y2VzIHRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgcHJvZHVjZSB0aGUgZW5kIHJlc3VsdC4gVGhpcyBwYXJ0IGlzIHJldXNhYmxlIGlmIHlvdSBuZWVkIHRvIGRvIHRoaXMgYWdhaW4uXHJcbnZhciBjbGFzc0ZhY3RvcnkgPSBmdW5jdGlvbihwcm90bykge1xyXG5cdHJldHVybiBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBmID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiBmLmNhbGwuYXBwbHkoZiwgYXJndW1lbnRzKTtcclxuXHRcdH07XHJcblxyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwiY29uc3RydWN0b3JcIiwge1xyXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXHJcblx0XHRcdHdyaXRhYmxlOiB0cnVlXHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcImNhbGxcIiwge1xyXG5cdFx0XHR3cml0YWJsZTogdHJ1ZVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJ0b1N0cmluZ1wiLCB7XHJcblx0XHRcdHdyaXRhYmxlOiB0cnVlXHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcInZhbHVlT2ZcIiwge1xyXG5cdFx0XHR3cml0YWJsZTogdHJ1ZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0T2JqZWN0LmtleXMocHJvdG8pLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcblx0XHRcdGZba2V5XSA9IHByb3RvW2tleV07XHJcblx0XHR9KTtcclxuXHJcblx0XHRmLmNvbnN0cnVjdG9yLmFwcGx5KGYsIGFyZ3VtZW50cyk7XHJcblxyXG5cdFx0cmV0dXJuIGY7XHJcblx0fTtcclxufTtcclxuXHJcbnZhciBWYXJpYWJsZSA9IGNsYXNzRmFjdG9yeSh2YXJpYWJsZVByb3RvdHlwZSk7XHJcbnZhciBFeHByZXNzaW9uID0gY2xhc3NGYWN0b3J5KGV4cHJlc3Npb25Qcm90b3R5cGUpO1xyXG4vLyBjYWxsZWQgYXM6IHZhciBpbnN0YW5jZSA9IFZhcmlhYmxlKCk7XHJcblxyXG4vLyBBIHByZS1idWlsdCBFeHByZXNzaW9uIGdlbmVyYXRvciwgZm9yIGdlbmVyYXRpbmcgcmFuZG9tIG51bWJlcnNcclxudmFyIFJhbmRvbVZhcmlhYmxlID0gZnVuY3Rpb24oeyBsb3dlcmJvdW5kID0gMCwgdXBwZXJib3VuZCA9IDEwLCBnZW5lcmF0b3IgPSBcInVuaWZvcm1cIiB9KSB7XHJcblxyXG5cdGlmIChpc0Z1bmN0aW9uKGdlbmVyYXRvcikpIHtcclxuXHRcdHZhciBleHByZXNzaW9uID0gRXhwcmVzc2lvbihnZW5lcmF0b3IpO1xyXG5cdFx0ZXhwcmVzc2lvbi5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XHJcblx0XHRyZXR1cm4gZXhwcmVzc2lvbjtcclxuXHJcblx0fSBlbHNlIGlmIChnZW5lcmF0b3IudG9Mb3dlckNhc2UoKSA9PSBcInVuaWZvcm1cIikge1xyXG5cdFx0Z2VuZXJhdG9yID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAodXBwZXJib3VuZCAtIGxvd2VyYm91bmQgKyAxKSArIGxvd2VyYm91bmQpO1xyXG5cdFx0fTtcclxuXHRcdC8vXHRUT0RPOiBhZGQgbW9yZSBkaXN0cmlidXRpb25zIGhlcmUuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gRXhwcmVzc2lvbihnZW5lcmF0b3IpO1xyXG59O1xyXG5cclxuXHJcblxyXG4vLyBBIHdheSB0byBoYXZlIFZhcmlhYmxlcyB3aGljaCBhcmUgbW9yZSBjb21wbGljYXRlZCB0aGluZ3MsIGxpa2UgYXJyYXlzIG9yIG9iZWN0c1xyXG52YXIgQ29tcGxleFZhcmlhYmxlID0gZnVuY3Rpb24odmFsdWUpIHtcclxuXHR2YXIgdmFyaWFibGUgPSBWYXJpYWJsZSh2YWx1ZSwgeyBlbmZvcmNlTnVtYmVyOiBmYWxzZSB9KVxyXG5cclxuXHR2YXIgZXhjbHVkZUxpc3QgPSBbXCJzZXRcIiwgXCJjYWxsXCIsIFwidG9KU09OXCIsIFwidG9TdHJpbmdcIiwgXCJ2YWx1ZU9mXCJdXHJcblxyXG5cdHZhciBoYW5kbGVyID0ge1xyXG5cdFx0Z2V0KHRhcmdldCwga2V5KSB7XHJcblx0XHRcdHZhciBwcm9wO1xyXG5cdFx0XHRpZiAoZXhjbHVkZUxpc3QuaW5kZXhPZihrZXkpID4gLTEpIHByb3AgPSB0YXJnZXRba2V5XS5iaW5kKHRhcmdldCk7XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHByb3AgPSB0YXJnZXQudmFsdWVba2V5XVxyXG5cdFx0XHRcdGlmIChpc0Z1bmN0aW9uKHByb3ApKSBwcm9wID0gcHJvcC5iaW5kKHRhcmdldC52YWx1ZSlcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHByb3BcclxuXHRcdH0sXHJcblx0XHRzZXQodGFyZ2V0LCBrZXksIHByb3ApIHtcclxuXHRcdFx0dGFyZ2V0LnZhbHVlW2tleV0gPSBwcm9wO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG5ldyBQcm94eSh2YXJpYWJsZSwgaGFuZGxlcilcclxufVxyXG5cclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0dmFyaWFibGVQcm90b3R5cGUsXHJcblx0VmFyaWFibGUsXHJcblx0ZXhwcmVzc2lvblByb3RvdHlwZSxcclxuXHRFeHByZXNzaW9uLFxyXG5cdFJhbmRvbVZhcmlhYmxlLFxyXG5cdENvbXBsZXhWYXJpYWJsZVxyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgQ2xhc3M6IENob2ljZVwiKTtcclxuXHJcbi8vIEV4dGVybmFsIGRlcGVuZGVuY3lcclxudmFyIHsgU3luY2hyb25vdXNQcm9taXNlIH0gPSByZXF1aXJlKFwic3luY2hyb25vdXMtcHJvbWlzZVwiKTtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZShcIi4uL3N0YXRlXCIpO1xyXG52YXIgeyBnYW1lSGlzdG9yeSB9ID0gcmVxdWlyZShcIi4uL2hpc3RvcnlcIik7XHJcbnZhciB7IFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0gcmVxdWlyZShcIi4uL2luZm9ybWF0aW9uXCIpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlkSGFuZGxlciB9ID0gcmVxdWlyZShcIi4uL2hlbHBlckZ1bmN0aW9uc1wiKShcInN0YXRlXCIpO1xyXG52YXIgeyBpc0Z1bmN0aW9uIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyRnVuY3Rpb25zXCIpKFwiZ2VuZXJhbFwiKTtcclxudmFyIHsgY2hhaW5lckdlbmVyYXRvciB9ID0gcmVxdWlyZShcIi4uL2hlbHBlckZ1bmN0aW9uc1wiKShcInBsYXlhYmxlXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9ID0gcmVxdWlyZShcIi4vcGxheWFibGVcIik7XHJcblxyXG4vL0JhY2tlbmQgZnVuY3Rpb24gY2xhc3MgZm9yIENob2ljZVxyXG5mdW5jdGlvbiBfQ2hvaWNlKGlkLCBwbGF5ZXIsIG9wdGlvbnMsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdF9QbGF5YWJsZS5jYWxsKHRoaXMsIGlkKTtcclxuXHJcblx0dGhpcy5uZXh0ID0ge307XHJcblxyXG5cdHRoaXMucGxheWVyID0gcmVnaXN0cnkucGxheWVyc1twbGF5ZXJdO1xyXG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0dGhpcy5kZWZhdWx0T3B0aW9uID0gcGFyYW1ldGVycy5kZWZhdWx0T3B0aW9uIHx8IG9wdGlvbnNbMF07IC8vVE9ETzogbWFrZSBkZWZhdWx0T3B0aW9uIGZ1bmN0aW9uYWxcclxuXHR0aGlzLmluZm9ybWF0aW9uRmlsdGVyID0gcGFyYW1ldGVycy5pbmZvcm1hdGlvbkZpbHRlciB8fCBudWxsO1xyXG5cdHRoaXMudXNlUGF5b2ZmcyA9IHBhcmFtZXRlcnMudXNlUGF5b2ZmcyB8fCBmYWxzZTtcclxuXHJcblx0cmVnaXN0cnkuY2hvaWNlc1tpZF0gPSB0aGlzO1xyXG5cclxuXHR2YXIgY2hvaWNlID0gdGhpcztcclxuXHR0aGlzLm9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRjaG9pY2UubmV4dFtpdGVtXSA9IFtdO1xyXG5cdH0pO1xyXG59XHJcblxyXG5fQ2hvaWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX1BsYXlhYmxlLnByb3RvdHlwZSk7XHJcbl9DaG9pY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gX0Nob2ljZTtcclxuXHJcbl9DaG9pY2UucmVnaXN0cnlOYW1lID0gXCJjaG9pY2VzXCI7XHJcbl9DaG9pY2UuY291bnRlck5hbWUgPSBcImNob2ljZVwiO1xyXG5cclxuX0Nob2ljZS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKHtcclxuXHR1c2VQYXlvZmZzID0gdGhpcy51c2VQYXlvZmZzLFxyXG5cdGhpc3RvcnkgPSBnYW1lSGlzdG9yeSxcclxuXHRpbmZvcm1hdGlvbjogcmF3SW5mb3JtYXRpb24gPSBQZXJmZWN0SW5mb3JtYXRpb24sXHJcblx0cmVsZWFzZVBsYXllciA9IHRydWUsXHJcblx0aW5mb3JtYXRpb25GaWx0ZXIgPSB0aGlzLmluZm9ybWF0aW9uRmlsdGVyLFxyXG5cdF9jb21waWxlSW5mb3JtYXRpb24gPSBudWxsXHJcbn0gPSB7fSkge1xyXG5cdHZhciBjaG9pY2UgPSB0aGlzO1xyXG5cclxuXHRpZiAoIWNob2ljZS5wbGF5ZXIuYWxpdmUpXHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3Qoe1xyXG5cdFx0XHRyZXN1bHQ6IGNob2ljZS5pZCArIFwiOiBQbGF5ZXIgXCIgKyBjaG9pY2UucGxheWVyLmlkICsgXCIgaXMgZGVhZC5cIlxyXG5cdFx0fSk7XHJcblxyXG5cdC8vV2hpbGUgdGhpcyBjaG9pY2UgaXMgaGFwcGVuaW5nLCBkb24ndCBhbGxvdyBvdGhlciBjaG9pY2VzIHRvIHVzZSB0aGlzIHBsYXllci5cclxuXHRjaG9pY2UucGxheWVyLmF2YWlsYWJsZSA9IGZhbHNlO1xyXG5cclxuXHQvL0luZm9ybWF0aW9uIG1lY2hhbmljcy4gSWYgd2UncmUgZGVhbGluZyB3aXRoIFBlcmZlY3RJbmZvcm1hdGlvbiwgdGhpcyB3b24ndCBnZXQgZGVsaXZlcmVkLCBzbyB3ZSdsbCBpbmNsdWRlIGl0IGluIHRoZSBjYWxsIHRvIC5kZWxpdmVyKCkuIElmIHdlJ3JlIHVzaW5nIGFuIGluZm9ybWF0aW9uIHN1cHBsaWVkIGZyb20gc29tZSBvdGhlciBwbGF5YWJsZSwgdGhlbiB0aGV5IGNhbiBkbyB3aGF0IHRoZXkgbGlrZSB3aXRoIGl0LlxyXG5cdHZhciBjaG9pY2VJbmZvID0ge1xyXG5cdFx0Y2hvaWNlOiB7XHJcblx0XHRcdGlkOiBjaG9pY2UuaWQsXHJcblx0XHRcdHBsYXllcjogY2hvaWNlLnBsYXllci5pZCxcclxuXHRcdFx0b3B0aW9uczogY2hvaWNlLm9wdGlvbnNcclxuXHRcdH1cclxuXHR9O1xyXG5cdHJhd0luZm9ybWF0aW9uLmFkZEFkZGl0aW9uYWwoY2hvaWNlSW5mbyk7XHJcblx0Ly9QZXJmb3JtIHNvbWUgZGF0YSBwcm9jZXNzaW5nIGlmIG90aGVyIHBsYXlhYmxlcyBuZWVkIGl0LlxyXG5cdGlmIChfY29tcGlsZUluZm9ybWF0aW9uKSBfY29tcGlsZUluZm9ybWF0aW9uKHJhd0luZm9ybWF0aW9uKTtcclxuXHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXHJcblx0XHQudGhlbihmdW5jdGlvbigpIHtcclxuXHRcdFx0Ly9QcmVwIGluZm9ybWF0aW9uXHJcblx0XHRcdHZhciBpbmZvcm1hdGlvbiA9IHJhd0luZm9ybWF0aW9uLmRlbGl2ZXIoY2hvaWNlLnBsYXllciwgY2hvaWNlSW5mbyk7XHJcblx0XHRcdGlmIChpbmZvcm1hdGlvbkZpbHRlcikgaW5mb3JtYXRpb24gPSBpbmZvcm1hdGlvbkZpbHRlcihpbmZvcm1hdGlvbik7XHJcblxyXG5cdFx0XHRyZXR1cm4gY2hvaWNlLnBsYXllci5jaG9vc2UoY2hvaWNlLm9wdGlvbnMuc2xpY2UoMCksIGluZm9ybWF0aW9uKTtcclxuXHRcdH0pXHJcblx0XHQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0dmFyIHBsYXllciA9IGNob2ljZS5wbGF5ZXI7XHJcblx0XHRcdHZhciBpZCA9IGNob2ljZS5pZDtcclxuXHJcblx0XHRcdC8vQWRkIHRvIHBsYXllcidzIGluZGl2aWR1YWwgaGlzdG9yeTtcclxuXHRcdFx0cGxheWVyLmhpc3RvcnkucHVzaCh7XHJcblx0XHRcdFx0Y2hvaWNlOiBpZCxcclxuXHRcdFx0XHRvcHRpb25zOiBjaG9pY2Uub3B0aW9ucyxcclxuXHRcdFx0XHRyZXN1bHRcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRyZXN1bHQgPSByZXN1bHQgfHwgY2hvaWNlLmRlZmF1bHRPcHRpb247XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0T2JqZWN0ID0ge1xyXG5cdFx0XHRcdHJlc3VsdCxcclxuXHRcdFx0XHRoaXN0b3J5RW50cnk6IHtcclxuXHRcdFx0XHRcdGNob2ljZTogaWQsXHJcblx0XHRcdFx0XHRwbGF5ZXI6IHBsYXllci5pZCxcclxuXHRcdFx0XHRcdHJlc3VsdFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdC8vVGhpcyB3aWxsIHByb2JhYmx5IG9ubHkgaGFwcGVuIGlmIGl0J3MgYSBzaW5nbGUtcGxheWVyIGdhbWUsIG90aGVyd2lzZSB3ZSdsbCB1c2UgcGxheW9mZnMgZGVmaW5lZCBpbiBhIFR1cm5cclxuXHRcdFx0aWYgKHVzZVBheW9mZnMpIHtcclxuXHRcdFx0XHR2YXIgcGF5b3V0ID0gY2hvaWNlLnBheW9mZnNbcmVzdWx0XTtcclxuXHJcblx0XHRcdFx0cGxheWVyLnNjb3JlICs9IHBheW91dDtcclxuXHJcblx0XHRcdFx0Ly90cmFjayB0aGUgcGF5b2ZmXHJcblx0XHRcdFx0dmFyIHNjb3JlRW50cnkgPSB7XHJcblx0XHRcdFx0XHRjaG9pY2U6IGlkLFxyXG5cdFx0XHRcdFx0cGF5b3V0czoge1xyXG5cdFx0XHRcdFx0XHRbcGxheWVyLmlkXTogTnVtYmVyKHBheW91dClcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRoaXN0b3J5LmFkZFNjb3JlcyhzY29yZUVudHJ5KTtcclxuXHRcdFx0XHRyZXN1bHRPYmplY3QuaGlzdG9yeUVudHJ5LnBheW91dHMgPSB7XHJcblx0XHRcdFx0XHRbcGxheWVyLmlkXTogcGF5b3V0XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bG9nKFxyXG5cdFx0XHRcdFwic2lsbHlcIixcclxuXHRcdFx0XHRcIl9DaG9pY2UucGxheTogcmVtb3ZpbmcgZnJvbSBvY2N1cGllZFBsYXllcnM6IFwiLFxyXG5cdFx0XHRcdGNob2ljZS5wbGF5ZXIuaWRcclxuXHRcdFx0KTtcclxuXHRcdFx0aWYgKHJlbGVhc2VQbGF5ZXIpIGNob2ljZS5yZWxlYXNlUGxheWVyKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdE9iamVjdCk7IC8vVE9ETzogYWRkIGluZm9ybWF0aW9uIG1lY2hhbmlzbXNcclxuXHRcdH0pO1xyXG59O1xyXG5cclxuLy9SZWxlYXNlIHBsYXllciBmcm9tIGV4Y2x1ZGVkIHBsYXllcnMgbGlzdCwgc28gdGhhdCBvdGhlciBvYmplY3RzIGNhbiB1c2UgaXQuXHJcbl9DaG9pY2UucHJvdG90eXBlLnJlbGVhc2VQbGF5ZXIgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLnBsYXllci5hdmFpbGFibGUgPSB0cnVlO1xyXG59O1xyXG5cclxuX0Nob2ljZS5wcm90b3R5cGUuZmluZE5leHQgPSBmdW5jdGlvbih7IHJlc3VsdCB9ID0ge30pIHtcclxuXHRyZXR1cm4gdGhpcy5uZXh0W3Jlc3VsdC5yZXN1bHRdO1xyXG59O1xyXG5cclxuX0Nob2ljZS5wcm90b3R5cGUuZ2VuZXJhdGVDaGFpbmluZ0Z1bmN0aW9ucyA9IGZ1bmN0aW9uKGNob2ljZSkge1xyXG5cdHZhciBfY2hvaWNlID0gdGhpcztcclxuXHJcblx0X2Nob2ljZS5vcHRpb25zLmZvckVhY2goZnVuY3Rpb24ob3B0aW9uKSB7XHJcblx0XHRfY2hvaWNlLnBheW9mZnNbb3B0aW9uXSA9IDA7IC8vU3RhcnQgcGF5b2ZmcyBhdCB6ZXJvXHJcblxyXG5cdFx0Y2hvaWNlW29wdGlvbl0gPSBmdW5jdGlvbihwYXlvZmYpIHtcclxuXHRcdFx0Ly9DcmVhdGUgZnVuY3Rpb25zIGZvciB1c2VyIHRvIGFzc2lnbiBwYXlvZmZzXHJcblx0XHRcdGlmICghaXNOYU4ocGF5b2ZmKSkgX2Nob2ljZS5wYXlvZmZzW29wdGlvbl0gPSBwYXlvZmY7XHJcblx0XHRcdHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZSh7XHJcblx0XHRcdFx0cGxheWFibGU6IGNob2ljZSxcclxuXHRcdFx0XHRwYXRoOiBbb3B0aW9uXVxyXG5cdFx0XHR9KTtcclxuXHRcdH07XHJcblx0fSk7XHJcbn07XHJcblxyXG5fQ2hvaWNlLnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnkpIHtcclxuXHRzdW1tYXJ5LnBsYXllciA9IHRoaXMucGxheWVyLmlkO1xyXG5cdHN1bW1hcnkub3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zbGljZSgpO1xyXG5cclxuXHRyZXR1cm4gc3VtbWFyeTtcclxufTtcclxuXHJcbi8vVE9ETzogdW4tZnVjayB0aGlzLlxyXG5fQ2hvaWNlLnByb3RvdHlwZS5zdW1tYXJ5TmV4dCA9IGZ1bmN0aW9uKFxyXG5cdHN1bW1hcnksXHJcblx0ZW50cmllcyA9IHt9LFxyXG5cdHNob3J0Q2lyY3VpdCA9IGZhbHNlLFxyXG5cdG1heEVudHJpZXMgPSAxMFxyXG4pIHtcclxuXHQvLyBDb3B5IG92ZXIgdGhlIGNob2ljZSBvcHRpb25zXHJcblx0c3VtbWFyeS5uZXh0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5uZXh0KTtcclxuXHJcblx0Ly8gTG9vcCB0aHJvdWdoIHRoZW0gYW5kIHN1bW1hcml6ZSBhdCBlYWNoIHN0ZXAuXHJcblx0dmFyIGNvdW50ID0gMDtcclxuXHRmb3IgKHZhciBrZXkgaW4gc3VtbWFyeS5uZXh0KSB7XHJcblx0XHRzdW1tYXJ5Lm5leHRba2V5XSA9IHN1bW1hcnkubmV4dFtrZXldLm1hcChmdW5jdGlvbihwbGF5YWJsZSkge1xyXG5cdFx0XHRjb3VudCsrO1xyXG5cdFx0XHRyZXR1cm4gcGxheWFibGUuc3VtbWFyaXplKHt9LCBlbnRyaWVzKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Ly8gSWYgdGhlcmUgd2VyZW4ndCBhbnkgbmV4dCBzdGVwcywgZGVsZXRlIHRoZSBuZXh0IGtleSwgdG8gcmVkdWNlIGNsdXR0ZXIuXHJcblx0aWYgKGNvdW50ID09IDApIGRlbGV0ZSBzdW1tYXJ5Lm5leHQ7XHJcblxyXG5cdHJldHVybiBzdW1tYXJ5O1xyXG59O1xyXG5cclxuLy9TZXQgYWxsIHBheW9mZnMgdG8gemVyby5cclxuX0Nob2ljZS5wcm90b3R5cGUuemVyb1BheW9mZnMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgY2hvaWNlID0gdGhpcztcclxuXHJcblx0Y2hvaWNlLnBheW9mZnMgPSB7fTtcclxuXHJcblx0Y2hvaWNlLm9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbihvcHRpb24pIHtcclxuXHRcdGNob2ljZS5wYXlvZmZzW29wdGlvbl0gPSAwO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gQ2hvaWNlKHBsYXllciwgb3B0aW9ucywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHBhcmFtZXRlcnMuaWQsIFwiY2hvaWNlXCIpO1xyXG5cclxuXHQvL0lmIGluZm9ybWF0aW9uRmlsdGVyIHdhcyBzdXBwbGllZCwgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uXHJcblx0aWYgKHBhcmFtZXRlcnMuaW5mb3JtYXRpb25GaWx0ZXIgJiYgIWlzRnVuY3Rpb24ocGFyYW1ldGVycy5pbmZvcm1hdGlvbkZpbHRlcikpXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJpbmZvcm1hdGlvbkZpbHRlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XHJcblxyXG5cdC8vQ3JlYXRlIGJhY2tlbmQgY2hvaWNlIG9iamVjdFxyXG5cdHZhciBfY2hvaWNlID0gbmV3IF9DaG9pY2UoaWQsIHBsYXllci5pZCgpLCBvcHRpb25zLCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0Ly9SZXR1cm4gdGhpcyByZWZlcmVuY2Ugb2JqZWN0IHRvIHRoZSB1c2VyLiBSdW4gdGhlIGZ1bmN0aW9uIHRvIHNlbGVjdCBhIHNvdXJjZVxyXG5cdHZhciBjaG9pY2UgPSBQbGF5YWJsZShfY2hvaWNlKTtcclxuXHJcblx0Ly9JbnRlcmZhY2UgdG8gc3BlY2lmeSBzaW5nbGUtcGxheWVyIHBheW9mZnMgaW4gc2luZ2xlLXBsYXllci9zaW5nbGUtY2hvaWNlIGdhbWVzXHJcblx0X2Nob2ljZS56ZXJvUGF5b2ZmcygpO1xyXG5cclxuXHRfY2hvaWNlLmdlbmVyYXRlQ2hhaW5pbmdGdW5jdGlvbnMoY2hvaWNlKTtcclxuXHJcblx0LypcclxuXHRvcHRpb25zLmZvckVhY2goZnVuY3Rpb24ob3B0aW9uKXtcclxuXHRcdF9jaG9pY2UucGF5b2Zmc1tvcHRpb25dID0gMDtcdFx0XHQvL1N0YXJ0IHBheW9mZnMgYXQgemVyb1xyXG5cclxuXHRcdGNob2ljZVtvcHRpb25dID0gZnVuY3Rpb24ocGF5b2ZmKXtcdFx0XHRcdFx0Ly9DcmVhdGUgZnVuY3Rpb25zIGZvciB1c2VyIHRvIGFzc2lnbiBwYXlvZmZzXHJcblx0XHRcdGlmICghaXNOYU4ocGF5b2ZmKSlfY2hvaWNlLnBheW9mZnNbb3B0aW9uXSA9IHBheW9mZjtcclxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XHJcblx0XHRcdFx0cGxheWFibGU6Y2hvaWNlLFxyXG5cdFx0XHRcdHBhdGg6W29wdGlvbl1cclxuXHRcdFx0fSlcclxuXHRcdH07XHJcblx0fSk7XHJcblx0Ki9cclxuXHJcblx0Ly9GdW5jdGlvbiB0byBzZXQgYWxsIHBheW9mZnMgYXQgb25jZVxyXG5cdGNob2ljZS5zZXRBbGxQYXlvZmZzID0gZnVuY3Rpb24ocGF5b2Zmcykge1xyXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KHBheW9mZnMpKSB0aHJvdyBuZXcgRXJyb3IoXCJQYXlvZmZzIG11c3QgYmUgYXJyYXlcIilcclxuXHRcdGlmIChwYXlvZmZzLmxlbmd0aCAhPSByZWdpc3RyeS5jaG9pY2VzW2lkXS5vcHRpb25zLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKFxyXG5cdFx0XHRcIlBheW9mZnMgbXVzdCBiZSBzYW1lIGRpbWVuc2lvbnMgYXMgY2hvaWNlIG9wdGlvbnNcIilcclxuXHJcblx0XHRwYXlvZmZzLmZvckVhY2goZnVuY3Rpb24ocGF5b2ZmLCBpbmRleCkge1xyXG5cdFx0XHRyZWdpc3RyeS5jaG9pY2VzW2lkXS5wYXlvZmZzW29wdGlvbnNbaW5kZXhdXSA9IHBheW9mZjtcclxuXHRcdH0pXHJcblx0XHQvL1RPRE86IG1ha2UgdGhpcyB3b3JrLiBJbmNsdWRlIGVycm9yIGhhbmRsaW5nIGlmIGFycmF5IGdpdmVuIGlzbid0IGV4cGVjdGVkIGRpbWVuc2lvbnMuXHJcblx0fTtcclxuXHJcblx0Ly9XYXkgZm9yIHVzZXIgdG8gaW50ZXJhY3Qgd2l0aCBwYXlvZmZzXHJcblx0Y2hvaWNlLnBheW9mZnMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiByZWdpc3RyeS5jaG9pY2VzW2lkXS5wYXlvZmZzO1xyXG5cdH07XHJcblxyXG5cdHJldHVybiBjaG9pY2U7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBfQ2hvaWNlLCBDaG9pY2UgfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBDb25zZWN1dGl2ZVwiKTtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZShcIi4uL3N0YXRlXCIpO1xyXG52YXIgeyBnYW1lSGlzdG9yeSB9ID0gcmVxdWlyZShcIi4uL2hpc3RvcnlcIik7XHJcblxyXG4vL0hlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgaWRIYW5kbGVyIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyRnVuY3Rpb25zXCIpKFwic3RhdGVcIik7XHJcblxyXG4vL0luZm9ybWF0aW9uXHJcbnZhciB7IEluZm9ybWF0aW9uLCBQZXJmZWN0SW5mb3JtYXRpb24gfSA9IHJlcXVpcmUoXCIuLi9pbmZvcm1hdGlvblwiKTtcclxuXHJcbi8vUGFyZW50IGNsYXNzXHJcbnZhciB7IF9QbGF5YWJsZSwgUGxheWFibGUgfSA9IHJlcXVpcmUoXCIuL3BsYXlhYmxlXCIpO1xyXG5cclxuLy9CYWNrZW5kIGZ1bmN0aW9uIGNsYXNzIGZvciBDb25zZWN1dGl2ZVxyXG5mdW5jdGlvbiBfQ29uc2VjdXRpdmUoaWQsIHBsYXlhYmxlc0FycmF5LCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRfUGxheWFibGUuY2FsbCh0aGlzLCBpZCwgcGFyYW1ldGVycyk7XHJcblxyXG5cdHBsYXlhYmxlc0FycmF5ID0gcGxheWFibGVzQXJyYXkubWFwKGZ1bmN0aW9uKHBsYXlhYmxlKSB7XHJcblx0XHRyZXR1cm4gcmVnaXN0cnkucGxheWFibGVzW3BsYXlhYmxlLmlkKCldXHJcblx0fSlcclxuXHR0aGlzLnBsYXlhYmxlc0FycmF5ID0gcGxheWFibGVzQXJyYXlcclxuXHJcblx0cmVnaXN0cnkuY29uc2VjdXRpdmVzW2lkXSA9IHRoaXM7XHJcbn1cclxuX0NvbnNlY3V0aXZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX1BsYXlhYmxlLnByb3RvdHlwZSk7XHJcbl9Db25zZWN1dGl2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBfQ29uc2VjdXRpdmU7XHJcblxyXG5fQ29uc2VjdXRpdmUucmVnaXN0cnlOYW1lID0gXCJjb25zZWN1dGl2ZXNcIjtcclxuX0NvbnNlY3V0aXZlLmNvdW50ZXJOYW1lID0gXCJjb25zZWN1dGl2ZVwiO1xyXG5cclxuX0NvbnNlY3V0aXZlLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oe1xyXG5cdGhpc3RvcnkgPSBnYW1lSGlzdG9yeSxcclxuXHRpbmZvcm1hdGlvbiA9IHRoaXMuaW5mb3JtYXRpb24gfHxcclxuXHRQZXJmZWN0SW5mb3JtYXRpb25cclxufSA9IHt9KSB7XHJcblxyXG5cdHZhciBjb25zZWN1dGl2ZSA9IHRoaXM7XHJcblxyXG5cdC8vTG9nIHRoZSBoaXN0b3J5IGFwcHJvcHJpYXRlbHlcclxuXHR2YXIgc3RhcnRFbnRyeSA9IHtcclxuXHRcdGNvbnNlY3V0aXZlOiBjb25zZWN1dGl2ZS5pZCxcclxuXHRcdGFjdGlvbjogXCJzdGFydFwiXHJcblx0fTtcclxuXHRoaXN0b3J5LmxvZy5hZGQoc3RhcnRFbnRyeSk7XHJcblxyXG5cdC8vSGlzdG9yeSBvYmplY3QgdG8gZ2l2ZSB0byBjb25zZWN1dGl2ZWQgcGxheWFibGVzLlxyXG5cdHZhciBjb25zZWN1dGl2ZUhpc3RvcnkgPSBoaXN0b3J5LmNoaWxkKCk7XHJcblxyXG5cdC8vY29tcGFydG1lbnRhbGl6ZSBpZiBzZXQuIFwiY29tcGFydG1lbnRhbGl6ZVwiIG1lYW5zIHBhc3Mgb24gaW5mb3JtYXRpb24gYXMgaWYgdGhpcyBwbGF5YWJsZSBpcyB0aGUgZW50aXJlIGdhbWUuXHJcblx0aWYgKGNvbnNlY3V0aXZlLmNvbXBhcnRtZW50YWxpemUpIHtcclxuXHRcdGluZm9ybWF0aW9uID0gbmV3IEluZm9ybWF0aW9uKGNvbnNlY3V0aXZlLmNvbXBhcnRtZW50YWxpemUuaGlzdG9yeSB8fCBjb25zZWN1dGl2ZUhpc3RvcnksXHJcblx0XHRcdGNvbnNlY3V0aXZlLmNvbXBhcnRtZW50YWxpemUucG9wdWxhdGlvbiB8fCBpbmZvcm1hdGlvbi5wb3B1bGF0aW9uKTtcclxuXHR9XHJcblxyXG5cdHZhciBhY3Rpb24gPSBmdW5jdGlvbiBhY3Rpb24ocGxheWFibGVzQXJyYXkpIHtcclxuXHRcdC8vU3RvcCBpZiB0aGUgZ2FtZSBpcyBvdmVyLlxyXG5cdFx0aWYgKGhpc3Rvcnkuc3RvcCkgcmV0dXJuIHsgcGxheWFibGU6IGNvbnNlY3V0aXZlIH07XHJcblxyXG5cdFx0aWYgKHBsYXlhYmxlc0FycmF5Lmxlbmd0aCA+IDApIHtcclxuXHRcdFx0cmV0dXJuIHBsYXlhYmxlc0FycmF5LnNoaWZ0KCkucGxheSh7IHNob3J0Q2lyY3VpdDogdHJ1ZSwgaGlzdG9yeTogY29uc2VjdXRpdmVIaXN0b3J5LCBpbmZvcm1hdGlvbiB9KVxyXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGFjdGlvbihwbGF5YWJsZXNBcnJheSkgfHwgcmVzdWx0XHJcblx0XHRcdFx0fSlcclxuXHRcdH0gZWxzZSByZXR1cm4gZmFsc2VcclxuXHR9XHJcblxyXG5cdHJldHVybiBhY3Rpb24oY29uc2VjdXRpdmUucGxheWFibGVzQXJyYXkuc2xpY2UoKSlcclxuXHRcdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHRyZXN1bHQuaGlzdG9yeUVudHJ5ID0ge1xyXG5cdFx0XHRcdGNvbnNlY3V0aXZlOiBjb25zZWN1dGl2ZS5pZCxcclxuXHRcdFx0XHRhY3Rpb246IGNvbnNlY3V0aXZlSGlzdG9yeS5vcnBoYW4oKVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0Ly9UT0RPOiBhZGQgaW5mb3JtYXRpb24gbWVjaGFuaXNtc1xyXG5cclxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdFx0fSk7XHJcbn07XHJcblxyXG4vL092ZXJ3cml0ZSBoaXN0b3J5IGhhbmRsZXIgc28gdGhhdCB0cmVlIGRvZXNuJ3QgaGF2ZSBcInN0YXJ0XCIgYW5kIFwiZmluaXNoXCIgZW50cmllcy5cclxuX0NvbnNlY3V0aXZlLnByb3RvdHlwZS5oYW5kbGVIaXN0b3J5ID0gZnVuY3Rpb24oeyBoaXN0b3J5ID0gZ2FtZUhpc3RvcnkgfSA9IHt9LFxyXG5cdHJlc3VsdFxyXG4pIHtcclxuXHR2YXIgY29uc2VjdXRpdmUgPSB0aGlzO1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdGhpc3RvcnkubG9nLmFkZCh7XHJcblx0XHRcdGNvbnNlY3V0aXZlOiBjb25zZWN1dGl2ZS5pZCxcclxuXHRcdFx0YWN0aW9uOiBcImZpbmlzaFwiLFxyXG5cdFx0XHRkdXJhdGlvbjogcmVzdWx0Lmhpc3RvcnlFbnRyeS5kdXJhdGlvblxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aGlzdG9yeS5hZGROb0xvZyhyZXN1bHQuaGlzdG9yeUVudHJ5KTtcclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vVE9ETzogZmluaXNoIHRoaXMhXHJcbl9Db25zZWN1dGl2ZS5wcm90b3R5cGUuc3VtbWFyeVRoaXMgPSBmdW5jdGlvbihzdW1tYXJ5LCBlbnRyaWVzLCBzaG9ydENpcmN1aXQpIHtcclxuXHRzdW1tYXJ5LmFjdGlvbiA9IHt9O1xyXG5cclxuXHR0aGlzLnBsYXlhYmxlU3RhcnQuc3VtbWFyaXplKFxyXG5cdFx0c3VtbWFyeS5hY3Rpb24sXHJcblx0XHRlbnRyaWVzLFxyXG5cdFx0KHNob3J0Q2lyY3VpdCA9IHRoaXMucGxheWFibGVGaW5pc2gpXHJcblx0KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIENvbnNlY3V0aXZlKHBsYXlhYmxlc0FycmF5LCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHR2YXIgaWQgPSBpZEhhbmRsZXIocGFyYW1ldGVycy5pZCwgXCJjb25zZWN1dGl2ZVwiKTtcclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBsb29wIG9iamVjdFxyXG5cdHZhciBfY29uc2VjdXRpdmUgPSBuZXcgX0NvbnNlY3V0aXZlKGlkLCBwbGF5YWJsZXNBcnJheSwgcGFyYW1ldGVycyk7XHJcblxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgY29uc2VjdXRpdmUgPSBQbGF5YWJsZShfY29uc2VjdXRpdmUpO1xyXG5cclxuXHRjb25zZWN1dGl2ZS5pZHMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBwbGF5YWJsZXNBcnJheS5tYXAoZnVuY3Rpb24ocGxheWFibGUpIHtcclxuXHRcdFx0cmV0dXJuIHBsYXlhYmxlLmlkKCk7XHJcblx0XHR9KVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNvbnNlY3V0aXZlO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX0NvbnNlY3V0aXZlLCBDb25zZWN1dGl2ZSB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBIYWx0SWZcIilcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIge3JlZ2lzdHJ5fSA9IHJlcXVpcmUoJy4uL3N0YXRlJyk7XHJcbnZhciB7Z2FtZUhpc3Rvcnl9ID0gcmVxdWlyZSgnLi4vaGlzdG9yeScpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7aXNGdW5jdGlvbn1cdD0gcmVxdWlyZSgnLi4vaGVscGVyRnVuY3Rpb25zJykoXCJnZW5lcmFsXCIpO1xyXG52YXIge2lkSGFuZGxlcn0gXHQ9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwic3RhdGVcIik7XHJcblxyXG4vL1BhcmVudCBjbGFzc1xyXG52YXIge19QbGF5YWJsZSwgUGxheWFibGV9ID0gcmVxdWlyZSgnLi9wbGF5YWJsZScpO1xyXG5cclxuXHJcblxyXG4vL0JhY2tlbmQgZnVuY3Rpb24gY2xhc3MgZm9yIEdhbWVcclxuZnVuY3Rpb24gX0hhbHQoaWQsdGVzdENvbmRpdGlvbiwge2xvZ0NvbnRpbnVlID0gZmFsc2V9KXtcclxuXHRfUGxheWFibGUuY2FsbCh0aGlzLGlkKTtcclxuXHRcclxuXHR0aGlzLnRlc3RDb25kaXRpb24gPSB0ZXN0Q29uZGl0aW9uO1xyXG5cdHRoaXMubG9nQ29udGludWUgPSBsb2dDb250aW51ZTtcclxuXHRcclxuXHRyZWdpc3RyeS5oYWx0c1tpZF0gPSB0aGlzO1xyXG59XHJcblxyXG5fSGFsdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9QbGF5YWJsZS5wcm90b3R5cGUpO1xyXG5fSGFsdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBfSGFsdDtcclxuXHJcbl9IYWx0LnJlZ2lzdHJ5TmFtZSA9IFwiaGFsdHNcIjtcclxuX0hhbHQuY291bnRlck5hbWUgPSBcImhhbHRJZlwiO1xyXG5cclxuX0hhbHQucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7aW5pdGlhbGl6ZVBsYXllcnM9ZmFsc2UsIHNob3J0Q2lyY3VpdD1mYWxzZSwgaGlzdG9yeT1nYW1lSGlzdG9yeX09e30pe1xyXG5cdFxyXG5cdHZhciBoYWx0ID0gdGhpcztcclxuXHRcclxuXHR2YXIgcmVzdWx0T2JqZWN0ID0ge1xyXG5cdFx0J3BsYXlhYmxlJzpoYWx0LFxyXG5cdFx0J2hpc3RvcnlFbnRyeSc6e1xyXG5cdFx0XHQnaGFsdCc6aGFsdC5pZFxyXG5cdFx0fVxyXG5cdH07XHJcblx0XHJcblx0XHJcblx0dmFyIHRlc3QgPSBoYWx0LnRlc3RDb25kaXRpb24oKTtcclxuXHRcclxuXHRcclxuXHRpZiAodGVzdCkge1xyXG5cdFx0bG9nKFwiaW5mb1wiLCBcIkhhbHRpbmcgYXQgXCIgKyBoYWx0LmlkKVxyXG5cdFx0XHJcblx0XHRyZXN1bHRPYmplY3QuaGlzdG9yeUVudHJ5LmFjdGlvbiA9IFwiaGFsdFwiO1xyXG5cdFx0cmVzdWx0T2JqZWN0LnJlc3VsdCA9IFwiSGFsdFwiO1xyXG5cdFxyXG5cdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KHJlc3VsdE9iamVjdCk7XHJcblx0fVxyXG5cdFxyXG5cdC8vSGFsdCBwcm9iYWJseSBnZXRzIHVzZWQgZm9yIGxvb3BzLCBhbmQgd2UgbWlnaHQgbm90IHdhbnQgdG8gc2VlIGxvdHMgb2YgY29udGludWUgbWVzc2FnZXMsIHNvIFwibG9nQ29udGludWVcIiB3aWxsIG9taXQgdGhlbS5cclxuXHRpZiAoaGFsdC5sb2dDb250aW51ZSkge1xyXG5cdFx0cmVzdWx0T2JqZWN0Lmhpc3RvcnlFbnRyeS5hY3Rpb24gPSBcImNvbnRpbnVlXCI7XHJcblx0fVxyXG5cdGVsc2UgZGVsZXRlIHJlc3VsdE9iamVjdC5oaXN0b3J5RW50cnlcclxuXHRcclxuXHRcclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdE9iamVjdClcclxufTtcclxuXHJcblxyXG5fSGFsdC5wcm90b3R5cGUuc3VtbWFyeVRoaXMgPSBmdW5jdGlvbihzdW1tYXJ5KXtcclxuXHRzdW1tYXJ5LmNvbmRpdGlvbiA9IHRoaXMudGVzdENvbmRpdGlvbi50b1N0cmluZygpO1xyXG59XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIEhhbHRJZih0ZXN0Q29uZGl0aW9uPWZ1bmN0aW9uKCl7fSwge2lkPW51bGwsIGxvZ0NvbnRpbnVlPWZhbHNlfT17fSl7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKGlkLFwiaGFsdElmXCIpXHJcblx0XHJcblx0aWYgKCFpc0Z1bmN0aW9uKHRlc3RDb25kaXRpb24pKSBsb2coXCJ3YXJuXCIsaWQgKyBcIjogdGVzdENvbmRpdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiwgb3IgZWxzZSBnYW1lIHdpbGwgbm90IGhhbHQuXCIpXHJcblxyXG5cdC8vQ3JlYXRlIGJhY2tlbmQgbG9vcCBvYmplY3RcclxuXHR2YXIgX2hhbHQgPSBuZXcgX0hhbHQoaWQsIHRlc3RDb25kaXRpb24sIHtsb2dDb250aW51ZX0pO1xyXG5cdFxyXG5cdFxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgaGFsdCA9IFBsYXlhYmxlKF9oYWx0KTtcdFxyXG5cdHJldHVybiBoYWx0O1x0XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtfSGFsdCwgSGFsdElmfTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vTG9hZHMgdGhlIHBsYXlhYmxlcyB0aGF0IHdpbGwgYmUgdXNlZCBieSBOYXNoLiBUaGlzIGlzIGJhc2ljYWxseSB0aGUgY29udHJvbGxlciBsaXN0OiBpZiBpdCdzIG5vdCBpbiB0aGVzZSBsaXN0cyxcclxuLy8gdGhlbiBpdCB3b24ndCBiZSBhdmFpbGFibGUgZm9yIHVzLlxyXG5cclxuLy9FeHRlcm5hbCBkZXBlbmRlbmN5XHJcbnZhciBwcmVzZW50ID0gcmVxdWlyZShcInByZXNlbnRcIik7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcclxuXHJcbnZhciB7IGFwcGx5QmluZCB9ID0gcmVxdWlyZShcIi4uL2hlbHBlckZ1bmN0aW9uc1wiKShcImdlbmVyYWxcIik7XHJcblxyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgUGxheWFibGUgQ2xhc3NlczogXCIpO1xyXG5cclxuLy9QbGF5YWJsZXNcclxudmFyIHsgX1BsYXlhYmxlIH0gPSByZXF1aXJlKFwiLi9wbGF5YWJsZVwiKTtcclxudmFyIHsgX0Nob2ljZSwgQ2hvaWNlIH0gPSByZXF1aXJlKFwiLi9jaG9pY2VcIik7XHJcbnZhciB7IF9UdXJuLCBUdXJuIH0gPSByZXF1aXJlKFwiLi90dXJuXCIpO1xyXG52YXIgeyBfU2VxdWVuY2UsIFNlcXVlbmNlIH0gPSByZXF1aXJlKFwiLi9zZXF1ZW5jZVwiKTtcclxudmFyIHsgX0NvbnNlY3V0aXZlLCBDb25zZWN1dGl2ZSB9ID0gcmVxdWlyZShcIi4vY29uc2VjdXRpdmVcIik7XHJcbnZhciB7IF9Mb29wLCBMb29wIH0gPSByZXF1aXJlKFwiLi9sb29wXCIpO1xyXG52YXIgeyBfU0xvb3AsIFN0b2NoYXN0aWNMb29wIH0gPSByZXF1aXJlKFwiLi9zdG9jaGFzdGljTG9vcFwiKTtcclxudmFyIHsgX0hhbHQsIEhhbHRJZiB9ID0gcmVxdWlyZShcIi4vaGFsdC1pZlwiKTtcclxudmFyIHsgX1NIYWx0LCBTdG9jaGFzdGljSGFsdCB9ID0gcmVxdWlyZShcIi4vc3RvY2hhc3RpYy1oYWx0XCIpO1xyXG52YXIgeyBfTGFtYmRhLCBMYW1iZGEgfSA9IHJlcXVpcmUoXCIuL2xhbWJkYVwiKTtcclxudmFyIHsgX1JQQ2hvaWNlLCBSYW5kb21QbGF5ZXJDaG9pY2UgfSA9IHJlcXVpcmUoXCIuL3JhbmRvbS1wbGF5ZXItY2hvaWNlXCIpO1xyXG52YXIgeyBfUG9wdWxhdGlvbkR5bmFtaWNzLCBQb3B1bGF0aW9uRHluYW1pY3MgfSA9IHJlcXVpcmUoXCIuL3BvcHVsYXRpb24tZHluYW1pY3NcIik7XHJcbnZhciB7IF9TaW11bHRhbmVvdXMsIFNpbXVsdGFuZW91cyB9ID0gcmVxdWlyZShcIi4vc2ltdWx0YW5lb3VzXCIpO1xyXG5cclxuLy9SdW5zIHdoZW4gbG9hZGluZyBQbGF5YWJsZSBjbGFzc2VzLlxyXG5mdW5jdGlvbiBpbml0aWFsaXplUGxheWFibGVDbGFzcyhwbGF5YWJsZUNsYXNzKSB7XHJcblx0Ly9SZXBsYWNlIHRoZSAucGxheSgpIG1ldGhvZCB3aXRoIGEgd3JhcHBlciB3aGljaCBjYWxscyBpdCBhbmQgYSBmZXcgb3RoZXIgZnVuY3Rpb25zXHJcblx0aWYgKHBsYXlhYmxlQ2xhc3MucHJvdG90eXBlLmhhc093blByb3BlcnR5KFwicGxheVwiKSkge1xyXG5cdFx0cGxheWFibGVDbGFzcy5wcm90b3R5cGUucGxheSA9IChmdW5jdGlvbihwbGF5KSB7XHJcblx0XHRcdHJldHVybiBmdW5jdGlvbih7IGhpc3RvcnkgPSBnYW1lSGlzdG9yeSB9ID0ge30pIHtcclxuXHRcdFx0XHR2YXIgcGxheWFibGUgPSB0aGlzO1xyXG5cdFx0XHRcdHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG5cclxuXHRcdFx0XHQvLyBTZXQgb3VyIGhpc3RvcnlcclxuXHRcdFx0XHRhcmdzWzBdLmhpc3RvcnkgPyBudWxsIDogYXJnc1swXS5oaXN0b3J5ID0gdGhpcy5oaXN0b3J5IHx8IGdhbWVIaXN0b3J5XHJcblxyXG5cdFx0XHRcdC8vIGhvdyB0byBoYWx0IHRoZSBnYW1lIHdpdGhvdXQgZXJyb3JzLiBUT0RPIHRoaXMgaXMgcHJvYmFibHkgZnVja2VkXHJcblx0XHRcdFx0aWYgKGhpc3Rvcnkuc3RvcCkgcmV0dXJuIHsgcGxheWFibGUgfTtcclxuXHJcblxyXG5cdFx0XHRcdHJldHVybiBfUGxheWFibGUucHJvdG90eXBlLl9zdGFydFRpbWVyXHJcblx0XHRcdFx0XHQuYXBwbHkocGxheWFibGUsIGFyZ3MpXHJcblx0XHRcdFx0XHQudGhlbihhcHBseUJpbmQocGxheWFibGUuY2hlY2tJbml0LCBwbGF5YWJsZSwgYXJncykpXHJcblx0XHRcdFx0XHQudGhlbihhcHBseUJpbmQocGxheWFibGUucHJlUGxheSwgcGxheWFibGUsIGFyZ3MpKVxyXG5cdFx0XHRcdFx0LnRoZW4oYXBwbHlCaW5kKHBsYXksIHBsYXlhYmxlLCBhcmdzKSlcclxuXHRcdFx0XHRcdC50aGVuKGFwcGx5QmluZChwbGF5YWJsZS5wb3N0UGxheSwgcGxheWFibGUsIGFyZ3MpKVxyXG5cdFx0XHRcdFx0LnRoZW4oYXBwbHlCaW5kKF9QbGF5YWJsZS5wcm90b3R5cGUuX3N0b3BUaW1lciwgcGxheWFibGUsIGFyZ3MpKVxyXG5cdFx0XHRcdFx0LnRoZW4oYXBwbHlCaW5kKHBsYXlhYmxlLmhhbmRsZUhpc3RvcnksIHBsYXlhYmxlLCBhcmdzKSlcclxuXHRcdFx0XHRcdC50aGVuKGFwcGx5QmluZChfUGxheWFibGUucHJvdG90eXBlLnByb2NlZWQsIHBsYXlhYmxlLCBhcmdzKSk7XHJcblx0XHRcdH07XHJcblx0XHR9KShwbGF5YWJsZUNsYXNzLnByb3RvdHlwZS5wbGF5KTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydHMucGxheWFibGVDbGFzc2VzID0ge1xyXG5cdF9QbGF5YWJsZSxcclxuXHRfQ2hvaWNlLFxyXG5cdF9UdXJuLFxyXG5cdF9TZXF1ZW5jZSxcclxuXHRfQ29uc2VjdXRpdmUsXHJcblx0X0xvb3AsXHJcblx0X1NMb29wLFxyXG5cdF9IYWx0LFxyXG5cdF9TSGFsdCxcclxuXHRfTGFtYmRhLFxyXG5cdF9SUENob2ljZSxcclxuXHRfUG9wdWxhdGlvbkR5bmFtaWNzLFxyXG5cdF9TaW11bHRhbmVvdXNcclxufTtcclxuZXhwb3J0cy5wbGF5YWJsZUludGVyZmFjZXMgPSB7XHJcblx0Q2hvaWNlLFxyXG5cdFR1cm4sXHJcblx0U2VxdWVuY2UsXHJcblx0Q29uc2VjdXRpdmUsXHJcblx0TG9vcCxcclxuXHRTdG9jaGFzdGljTG9vcCxcclxuXHRIYWx0SWYsXHJcblx0U3RvY2hhc3RpY0hhbHQsXHJcblx0TGFtYmRhLFxyXG5cdFJhbmRvbVBsYXllckNob2ljZSxcclxuXHRQb3B1bGF0aW9uRHluYW1pY3MsXHJcblx0U2ltdWx0YW5lb3VzXHJcbn07XHJcblxyXG5mb3IgKHZhciBwbGF5YWJsZUNsYXNzIGluIGV4cG9ydHMucGxheWFibGVDbGFzc2VzKSB7XHJcblx0aWYgKHBsYXlhYmxlQ2xhc3MgIT0gXCJfUGxheWFibGVcIilcclxuXHRcdGluaXRpYWxpemVQbGF5YWJsZUNsYXNzKGV4cG9ydHMucGxheWFibGVDbGFzc2VzW3BsYXlhYmxlQ2xhc3NdKTtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBMYW1iZGFcIilcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSwgZ2FtZUhpc3RvcnkgfSA9IHJlcXVpcmUoJy4uL3N0YXRlJyk7XHJcblxyXG4vLyBJbmZvcm1hdGlvbiBtZWNoYW5pY3NcclxudmFyIHsgUGVyZmVjdEluZm9ybWF0aW9uIH0gPSByZXF1aXJlKFwiLi4vaW5mb3JtYXRpb25cIik7XHJcblxyXG4vL0hlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgaXNGdW5jdGlvbiB9ID0gcmVxdWlyZSgnLi4vaGVscGVyRnVuY3Rpb25zJykoXCJnZW5lcmFsXCIpO1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwic3RhdGVcIik7XHJcblxyXG4vL1BhcmVudCBjbGFzc1xyXG52YXIgeyBfUGxheWFibGUsIFBsYXlhYmxlIH0gPSByZXF1aXJlKCcuL3BsYXlhYmxlJyk7XHJcblxyXG5cclxuXHJcbi8vQmFja2VuZCBmdW5jdGlvbiBjbGFzcyBmb3IgR2FtZVxyXG5mdW5jdGlvbiBfTGFtYmRhKGlkLCBhY3Rpb24sIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdF9QbGF5YWJsZS5jYWxsKHRoaXMsIGlkKTtcclxuXHJcblx0dGhpcy5hY3Rpb24gPSBhY3Rpb247XHJcblxyXG5cdHJlZ2lzdHJ5LmxhbWJkYXNbaWRdID0gdGhpcztcclxufVxyXG5fTGFtYmRhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX1BsYXlhYmxlLnByb3RvdHlwZSk7XHJcbl9MYW1iZGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gX0xhbWJkYVxyXG5cclxuX0xhbWJkYS5yZWdpc3RyeU5hbWUgPSBcImxhbWJkYXNcIjtcclxuX0xhbWJkYS5jb3VudGVyTmFtZSA9IFwibGFtYmRhXCI7XHJcblxyXG5cclxuX0xhbWJkYS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKHsgaW5pdGlhbGl6ZVBsYXllcnMgPSBmYWxzZSwgc2hvcnRDaXJjdWl0ID0gZmFsc2UsIGhpc3RvcnkgPSBnYW1lSGlzdG9yeSxcclxuXHRpbmZvcm1hdGlvbiA9IFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0ge30pIHtcclxuXHJcblx0dmFyIGxhbWJkYSA9IHRoaXM7XHJcblxyXG5cdHZhciByZXN1bHQgPSBsYW1iZGEuYWN0aW9uKHsgaGlzdG9yeSwgaW5mb3JtYXRpb24gfSlcclxuXHJcblx0dmFyIHJlc3VsdE9iamVjdCA9IHtcclxuXHRcdHJlc3VsdCxcclxuXHRcdCdwbGF5YWJsZSc6IGxhbWJkYSxcclxuXHRcdGhpc3RvcnlFbnRyeToge1xyXG5cdFx0XHRsYW1iZGE6IGxhbWJkYS5pZCxcclxuXHRcdFx0cmVzdWx0XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRPYmplY3QpXHJcbn07XHJcblxyXG4vLyBTaW1wbGUgaGVscGVyIHRvIGp1c3QgcnVuIHN5bmNocm9ub3VzbHkgd2hhdGV2ZXIgdGhlIExhbWJkYSBpcy4gVXNlZnVsIGZvciBkZWJ1Z2dpbmcuXHJcbl9MYW1iZGEucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmFjdGlvbigpO1xyXG59XHJcblxyXG5fTGFtYmRhLnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnkpIHtcclxuXHRzdW1tYXJ5LmFjdGlvbiA9IHRoaXMuYWN0aW9uLnRvU3RyaW5nKCk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBMYW1iZGEoYWN0aW9uID0gZnVuY3Rpb24oKSB7fSwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHBhcmFtZXRlcnMuaWQsIFwibGFtYmRhXCIpXHJcblxyXG5cdGlmICghaXNGdW5jdGlvbihhY3Rpb24pKSBsb2coXCJ3YXJuXCIsIGlkICsgXCI6IGFjdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbi5cIilcclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBsYW1iZGEgb2JqZWN0XHJcblx0dmFyIF9sYW1iZGEgPSBuZXcgX0xhbWJkYShpZCwgYWN0aW9uLCBwYXJhbWV0ZXJzKTtcclxuXHJcblxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgbGFtYmRhID0gUGxheWFibGUoX2xhbWJkYSk7XHJcblxyXG5cclxuXHRsYW1iZGEucnVuID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gX2xhbWJkYS5ydW4oKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBsYW1iZGE7XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX0xhbWJkYSwgTGFtYmRhIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XHJcbmxvZyhcImRlYnVnXCIsIFwiTG9hZGluZyBDbGFzczogTG9vcFwiKTtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZShcIi4uL3N0YXRlXCIpO1xyXG52YXIgeyBnYW1lSGlzdG9yeSwgSGlzdG9yeSB9ID0gcmVxdWlyZShcIi4uL2hpc3RvcnlcIik7XHJcblxyXG4vL0hlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgaWRIYW5kbGVyIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyRnVuY3Rpb25zXCIpKFwic3RhdGVcIik7XHJcbnZhciB7IGNoYWluZXJHZW5lcmF0b3IgfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJGdW5jdGlvbnNcIikoXCJwbGF5YWJsZVwiKTtcclxuXHJcbi8vIEluZm9ybWF0aW9uIG1lY2hhbmljc1xyXG52YXIgeyBJbmZvcm1hdGlvbiwgUGVyZmVjdEluZm9ybWF0aW9uIH0gPSByZXF1aXJlKFwiLi4vaW5mb3JtYXRpb25cIik7XHJcbnZhciB7IGdhbWVQb3B1bGF0aW9uIH0gPSByZXF1aXJlKFwiLi4vcG9wdWxhdGlvblwiKTtcclxuXHJcbi8vUGFyZW50IGNsYXNzXHJcbnZhciB7IF9QbGF5YWJsZSwgUGxheWFibGUgfSA9IHJlcXVpcmUoXCIuL3BsYXlhYmxlXCIpO1xyXG5cclxuLy9CYWNrZW5kIGZ1bmN0aW9uIGNsYXNzIGZvciBMb29wXHJcblxyXG5mdW5jdGlvbiBfTG9vcChpZCwgcGxheWFibGUsIGNvdW50LCBwYXJhbWV0ZXJzKSB7XHJcblx0X1BsYXlhYmxlLmNhbGwodGhpcywgaWQsIHBhcmFtZXRlcnMpO1xyXG5cclxuXHR2YXIgeyBsb2dDb250aW51ZSA9IHRydWUsIHBsYXlhYmxlUGFyYW1ldGVycyA9IHt9IH0gPSBwYXJhbWV0ZXJzO1xyXG5cclxuXHR0aGlzLnBsYXlhYmxlID0gcmVnaXN0cnkucGxheWFibGVzW3BsYXlhYmxlLmlkKCldO1xyXG5cdHRoaXMubG9nQ29udGludWUgPSBsb2dDb250aW51ZTtcclxuXHR0aGlzLnBsYXlhYmxlUGFyYW1ldGVycyA9IHBsYXlhYmxlUGFyYW1ldGVycztcclxuXHJcblx0dGhpcy5jb3VudCA9IGNvdW50O1xyXG5cclxuXHRyZWdpc3RyeS5sb29wc1tpZF0gPSB0aGlzO1xyXG59XHJcbl9Mb29wLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX1BsYXlhYmxlLnByb3RvdHlwZSk7XHJcbl9Mb29wLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9Mb29wO1xyXG5cclxuX0xvb3AucmVnaXN0cnlOYW1lID0gXCJsb29wc1wiO1xyXG5fTG9vcC5jb3VudGVyTmFtZSA9IFwibG9vcFwiO1xyXG5cclxuX0xvb3AucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7XHJcblx0aGlzdG9yeSA9IHRoaXMuaGlzdG9yeSB8fCBnYW1lSGlzdG9yeSxcclxuXHRpbmZvcm1hdGlvbiA9IHRoaXMuaW5mb3JtYXRpb24gfHwgUGVyZmVjdEluZm9ybWF0aW9uLFxyXG5cdHBsYXlhYmxlUGFyYW1ldGVycyA9IHRoaXMucGxheWFibGVQYXJhbWV0ZXJzXHJcbn0gPSB7fSkge1xyXG5cclxuXHR2YXIgbG9vcCA9IHRoaXM7XHJcblx0bG9vcC5jb3VudGVyID0gMDtcclxuXHJcblx0Ly8gU3BsaXQgdGhlIGhpc3RvcnkgZW50cnlcclxuXHR2YXIgbG9vcEhpc3RvcnkgPSBoaXN0b3J5LmNoaWxkKCk7XHJcblxyXG5cdC8vIGluZm9ybWF0aW9uIG1lY2hhbmljcy5cclxuXHQvL2NvbXBhcnRtZW50YWxpemUgSWYgc2V0XHJcblx0aWYgKGxvb3AuY29tcGFydG1lbnRhbGl6ZSkge1xyXG5cdFx0aW5mb3JtYXRpb24gPSBuZXcgSW5mb3JtYXRpb24obG9vcC5jb21wYXJ0bWVudGFsaXplLmhpc3RvcnkgfHwgbG9vcEhpc3RvcnksXHJcblx0XHRcdGxvb3AuY29tcGFydG1lbnRhbGl6ZS5wb3B1bGF0aW9uIHx8IGluZm9ybWF0aW9uLnBvcHVsYXRpb24pO1xyXG5cdH1cclxuXHQvLyBQYXNzIGFsb25nXHJcblx0cGxheWFibGVQYXJhbWV0ZXJzLmluZm9ybWF0aW9uID0gaW5mb3JtYXRpb25cclxuXHJcblxyXG5cdHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcblxyXG5cdHZhciBhY3Rpb24gPSBmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdC8vSWYgdGhlIGdhbWUgaGFzIGJlZW4gZW5kZWQgZWFybHksIGRvbid0IGNvbnRpbnVlLlxyXG5cdFx0aWYgKGhpc3Rvcnkuc3RvcCkgcmV0dXJuIHsgcGxheWFibGU6IGxvb3AgfTtcclxuXHJcblx0XHRsb29wLmNvdW50ZXIrKztcclxuXHRcdGlmICghcmVzdWx0KSByZXN1bHQgPSB7fTtcclxuXHJcblx0XHQvL0RlYWwgd2l0aCBoaXN0b3J5XHJcblx0XHRoaXN0b3J5LmxvZy5hZGQoe1xyXG5cdFx0XHRsb29wOiBsb29wLmlkLFxyXG5cdFx0XHRsb29wVG86IGxvb3AucGxheWFibGUuaWQsXHJcblx0XHRcdGNvdW50OiBsb29wLmNvdW50ZXJcclxuXHRcdH0pO1xyXG5cclxuXHRcdHBsYXlhYmxlUGFyYW1ldGVycy5zaG9ydENpcmN1aXQgPSB0cnVlO1xyXG5cdFx0cGxheWFibGVQYXJhbWV0ZXJzLmhpc3RvcnkgPSBsb29wSGlzdG9yeTtcclxuXHJcblx0XHRyZXR1cm4gbG9vcC5wbGF5YWJsZS5wbGF5KHBsYXlhYmxlUGFyYW1ldGVycykudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0Ly9SZS1mb3JtYXQgcmVzdWx0LCByZXBsYWNlIHBsYXlhYmxlIHdpdGggTG9vcCBwbGF5YWJsZVxyXG5cdFx0XHRyZXN1bHQucGxheWFibGUgPSBsb29wO1xyXG5cclxuXHRcdFx0Ly9UT0RPOiBhZGQgaW5mb3JtYXRpb24gbWVjaGFuaXNtc1xyXG5cclxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0Ly9SZXBlYXQgdGhlIHBsYXlhYmxlIGxvb3AuY291bnQgdGltZXMsIGJ5IGNoYWluaW5nIHByb21pc2VzLlxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbG9vcC5jb3VudDsgaSsrKSB7XHJcblx0XHRwcm9taXNlID0gcHJvbWlzZS50aGVuKGFjdGlvbik7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0cmVzdWx0Lmhpc3RvcnlFbnRyeSA9IHtcclxuXHRcdFx0bG9vcDogbG9vcC5pZCxcclxuXHRcdFx0Y291bnQ6IGxvb3AuY291bnRlcixcclxuXHRcdFx0YWN0aW9uOiBsb29wSGlzdG9yeS5vcnBoYW4oKVxyXG5cdFx0fTtcclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vT3ZlcndyaXRlIGhpc3RvcnkgaGFuZGxlciB0byBwcmV2ZW50IFwibG9vcCBmaW5pc2hlZFwiIGVudHJ5IGZyb20gaGl0dGluZyB0aGUgdHJlZS5cclxuX0xvb3AucHJvdG90eXBlLmhhbmRsZUhpc3RvcnkgPSBmdW5jdGlvbih7XHJcblx0XHRoaXN0b3J5ID0gdGhpcy5oaXN0b3J5IHx8IGdhbWVIaXN0b3J5LFxyXG5cdFx0aW5mb3JtYXRpb24gPSB0aGlzLmluZm9ybWF0aW9uIHx8IFBlcmZlY3RJbmZvcm1hdGlvbixcclxuXHRcdGxvZ0NvbnRpbnVlID0gdGhpcy5sb2dDb250aW51ZVxyXG5cdH0gPSB7fSxcclxuXHRyZXN1bHRcclxuKSB7XHJcblx0dmFyIGxvb3AgPSB0aGlzO1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdC8vV3JpdGUgZmluYWwgZW50cnkgaWYgbG9nQ29udGludWUgaXMgc2V0IHRvIHRydWVcclxuXHRcdGlmIChsb2dDb250aW51ZSkge1xyXG5cdFx0XHRoaXN0b3J5LmxvZy5hZGQoe1xyXG5cdFx0XHRcdGxvb3A6IGxvb3AuaWQsXHJcblx0XHRcdFx0bG9vcFRvOiBcIkxvb3AgZmluaXNoZWQuXCIsXHJcblx0XHRcdFx0Y291bnQ6IGxvb3AuY291bnRlclxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRoaXN0b3J5LmFkZE5vTG9nKHJlc3VsdC5oaXN0b3J5RW50cnkpO1xyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fSk7XHJcbn07XHJcblxyXG4vLyBBZGQgZGV0YWlsL25lc3RpbmcgdG8gc3VtbWFyeS5cclxuX0xvb3AucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSwgZW50cmllcykge1xyXG5cdHN1bW1hcnkuY291bnQgPSB0aGlzLmNvdW50O1xyXG5cclxuXHRzdW1tYXJ5LmFjdGlvbiA9IHt9O1xyXG5cdHRoaXMucGxheWFibGUuc3VtbWFyaXplKHN1bW1hcnkuYWN0aW9uLCBlbnRyaWVzLCB0cnVlKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIExvb3AocGxheWFibGUsIGNvdW50ID0gMSwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHBhcmFtZXRlcnMuaWQsIFwibG9vcFwiKTtcclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBsb29wIG9iamVjdFxyXG5cdHZhciBfbG9vcCA9IG5ldyBfTG9vcChpZCwgcGxheWFibGUsIGNvdW50LCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0Ly9SZXR1cm4gdGhpcyByZWZlcmVuY2Ugb2JqZWN0IHRvIHRoZSB1c2VyLiBSdW4gdGhlIGZ1bmN0aW9uIHRvIHNlbGVjdCBhIHNvdXJjZVxyXG5cdHZhciBsb29wID0gUGxheWFibGUoX2xvb3ApO1xyXG5cdHJldHVybiBsb29wO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX0xvb3AsIExvb3AgfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBQbGF5YWJsZVwiKTtcclxuXHJcbnZhciB7IFN5bmNocm9ub3VzUHJvbWlzZSB9ID0gcmVxdWlyZShcInN5bmNocm9ub3VzLXByb21pc2VcIik7XHJcbnZhciBwcmVzZW50ID0gcmVxdWlyZShcInByZXNlbnRcIik7XHJcblxyXG4vL0dhbWUgc3RhdGUgY29udHJvbGxlcnNcclxudmFyIHsgcmVnaXN0cnksIGlkQ291bnRlcnMgfSA9IHJlcXVpcmUoXCIuLi9zdGF0ZVwiKTtcclxudmFyIHsgZ2FtZUhpc3RvcnksIEhpc3RvcnkgfSA9IHJlcXVpcmUoXCIuLi9oaXN0b3J5XCIpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlzRnVuY3Rpb24gfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJGdW5jdGlvbnNcIikoXCJnZW5lcmFsXCIpO1xyXG52YXIgeyBvdXRjb21lVHJlZUFkZEFsbCwgb3V0Y29tZVRyZWVHZXRWYWx1ZSB9ID0gcmVxdWlyZShcIi4uL2hlbHBlckZ1bmN0aW9uc1wiKShcInBsYXlhYmxlXCIpO1xyXG52YXIgeyByZWluaXRpYWxpemVQbGF5ZXJzIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyRnVuY3Rpb25zXCIpKFwicGxheWVyXCIpO1xyXG5cclxuLy9UbyByZXR1cm4gdG8gdXNlclxyXG52YXIgeyBQb3B1bGF0aW9uLCBQbGF5ZXJMaXN0IH0gPSByZXF1aXJlKFwiLi4vcG9wdWxhdGlvblwiKTtcclxuXHJcbi8vX3BsYXlhYmxlIGNsYXNzLCBzdXBlcmNsYXNzIGZvciBvYmplY3RzIHdoaWNoIGNhbiBleGVjdXRlIGdhbWUgc3RlcHMgKGNob2ljZSwgdHVybiwgZ2FtZSlcclxuZnVuY3Rpb24gX1BsYXlhYmxlKGlkLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHR0aGlzLmlkID0gaWQ7XHJcblx0dGhpcy5uZXh0ID0gW107XHJcblx0cmVnaXN0cnkucGxheWFibGVzW2lkXSA9IHRoaXM7XHJcblx0aWRDb3VudGVycy5wbGF5YWJsZSsrO1xyXG5cclxuXHRwYXJhbWV0ZXJzLmNvbXBhcnRtZW50YWxpemUgPyB0aGlzLmNvbXBhcnRtZW50YWxpemUgPSBwYXJhbWV0ZXJzLmNvbXBhcnRtZW50YWxpemUgOiBudWxsO1xyXG5cdHBhcmFtZXRlcnMuaGlzdG9yeSA/ICh0aGlzLmhpc3RvcnkgPSBwYXJhbWV0ZXJzLmhpc3RvcnkpIDogbnVsbDtcclxuXHRwYXJhbWV0ZXJzLmluZm9ybWF0aW9uID8gKHRoaXMuaW5mb3JtYXRpb24gPSBwYXJhbWV0ZXJzLmluZm9ybWF0aW9uKSA6IG51bGw7XHJcblx0cGFyYW1ldGVycy5pbml0aWFsaXplUGxheWVycyA/ICh0aGlzLmluaXRpYWxpemVQbGF5ZXJzID0gcGFyYW1ldGVycy5pbml0aWFsaXplUGxheWVycykgOiBudWxsO1xyXG59XHJcblxyXG5fUGxheWFibGUucmVnaXN0cnlOYW1lID0gXCJwbGF5YWJsZXNcIjtcclxuX1BsYXlhYmxlLmNvdW50ZXJOYW1lID0gXCJwbGF5YWJsZVwiO1xyXG5cclxuLy9BZGQgcmVmZXJlbmNlIHRvIG5leHQgcGxheWFibGUgYnJhbmNoLCB0byBjaGFpbiBwbGF5YWJsZXMgdG9nZXRoZXIuXHJcbl9QbGF5YWJsZS5wcm90b3R5cGUuYWRkTmV4dCA9IGZ1bmN0aW9uKG5leHRQbGF5YWJsZSkge1xyXG5cdG91dGNvbWVUcmVlQWRkQWxsKHRoaXMubmV4dCwgbmV4dFBsYXlhYmxlKTtcclxufTtcclxuXHJcbi8vQ2FsbGVkIGJlZm9yZSAucGxheSgpIHRvIHN0YXJ0IHRpbWluZy5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5fc3RhcnRUaW1lciA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuX3RpbWVyID0gcHJlc2VudCgpO1xyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxufTtcclxuXHJcbi8vQ2FsbGVkIGJlZm9yZSBwcmVQbGF5LCBpbml0aWFsaXplIHBsYXllcnMgaWYgdHJ1ZS5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5jaGVja0luaXQgPSBmdW5jdGlvbih7IGluaXRpYWxpemVQbGF5ZXJzID0gdGhpcy5pbml0aWFsaXplUGxheWVycyB9ID0ge30sIHJlc3VsdCkge1xyXG5cdC8vIGlmIHdlIGdldCBzb21ldGhpbmdcclxuXHRpZiAoaW5pdGlhbGl6ZVBsYXllcnMpIHtcclxuXHRcdC8vIGlmIGl0J3MganVzdCB0cnVlLCB0aGVuIHJlaW5pdGlhbGl6ZSBldmVyeWJvZHlcclxuXHRcdGlmIChpbml0aWFsaXplUGxheWVycyA9PT0gdHJ1ZSkgcmV0dXJuIHJlaW5pdGlhbGl6ZVBsYXllcnMoXCJhbGxcIiwgcmVzdWx0KVxyXG5cclxuXHRcdC8vIGlmIGl0J3MgYSBwbGF5ZXJMaXN0LCB1c2UgdGhhdFxyXG5cdFx0ZWxzZSBpZiAoaW5pdGlhbGl6ZVBsYXllcnMgaW5zdGFuY2VvZiBQbGF5ZXJMaXN0KSByZXR1cm4gcmVpbml0aWFsaXplUGxheWVycyhpbml0aWFsaXplUGxheWVycylcclxuXHJcblx0XHQvLyBpZiB3ZSBnZXQgYSBmdW5jdGlvbiwgdGhlbiBydW4gdGhlIGZ1bmN0aW9uIGFuZCBjaGVjayB0aGF0IGl0J3MgcmV0dXJuaW5nIGEgcGxheWVyTGlzdFxyXG5cdFx0ZWxzZSBpZiAoaXNGdW5jdGlvbihpbml0aWFsaXplUGxheWVycykpIHtcclxuXHRcdFx0dmFyIGxpc3QgPSBpbml0aWFsaXplUGxheWVycygpXHJcblx0XHRcdGlmIChsaXN0IGluc3RhbmNlb2YgUGxheWVyTGlzdCkgcmV0dXJuIHJlaW5pdGlhbGl6ZVBsYXllcnMobGlzdCwgcmVzdWx0KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvdGhlcndpc2UsIGNvbnZlcnQgaXQgdG8gYSBwbGF5ZXJMaXN0IGFuZCBsZXQgUGxheWVyTGlzdCBkZWFsIHdpdGggaXQuXHJcblx0XHRlbHNlIHJldHVybiByZWluaXRpYWxpemVQbGF5ZXJzKG5ldyBQbGF5ZXJMaXN0KGluaXRpYWxpemVQbGF5ZXJzKSwgcmVzdWx0KTtcclxuXHR9XHJcblxyXG5cdC8vIGlmIHdlIGRpZG4ndCBnZXQgYW55dGhpbmcgb3IgZ290IGZhbHNlLCB3ZSdyZSBkb25lIGhlcmUuXHJcblx0ZWxzZSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcbn07XHJcblxyXG5cclxuLy9DYWxsZWQgYmVmb3JlIC5wbGF5KCkgYnV0IGFmdGVyIF9zdGFydFRpbWVyXHJcbl9QbGF5YWJsZS5wcm90b3R5cGUucHJlUGxheSA9IGZ1bmN0aW9uKHt9ID0ge30sIHJlc3VsdCkge1xyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxufTtcclxuXHJcbi8vQ2FsbGVkIGFmdGVyIC5wbGF5KCksIG92ZXJ3cml0YWJsZS5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5wb3N0UGxheSA9IGZ1bmN0aW9uKHt9ID0ge30sIHJlc3VsdCkge1xyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxufTtcclxuXHJcbi8vQ2FsbGVkIGFmdGVyIC5wb3N0UGxheSgpIHRvIHN0b3AgdGltZXIgYW5kIGxvZy5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5fc3RvcFRpbWVyID0gZnVuY3Rpb24oe30gPSB7fSwgcmVzdWx0KSB7XHJcblx0aWYgKHJlc3VsdC5oaXN0b3J5RW50cnkpXHJcblx0XHRyZXN1bHQuaGlzdG9yeUVudHJ5LmR1cmF0aW9uID0gcHJlc2VudCgpIC0gdGhpcy5fdGltZXI7XHJcblx0ZGVsZXRlIHRoaXMuX3RpbWVyO1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcbn07XHJcblxyXG4vL0NhbGxlZCBhZnRlciB0aW1lciBzdG9wcywgdG8gd3JpdGUgbG9nLiBPdmVyd2l0ZWFibGUgaWYgcGxheWFibGUgaGFzIHNwZWNpZmljIGxvZ2dpbmcgYmVoYXZpb3IuXHJcbl9QbGF5YWJsZS5wcm90b3R5cGUuaGFuZGxlSGlzdG9yeSA9IGZ1bmN0aW9uKHsgaGlzdG9yeSA9IGdhbWVIaXN0b3J5IH0gPSB7fSxcclxuXHRyZXN1bHRcclxuKSB7XHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRpZiAocmVzdWx0Lmhpc3RvcnlFbnRyeSkgaGlzdG9yeS5hZGQocmVzdWx0Lmhpc3RvcnlFbnRyeSk7XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcblx0fSk7XHJcbn07XHJcblxyXG4vL0RldGVybWluZSB3aGV0aGVyIHRvIHBsYXkgbmV4dCwgYW5kIGlmIHNvLCBkby5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5wcm9jZWVkID0gZnVuY3Rpb24oeyBzaG9ydENpcmN1aXQgfSA9IHt9LCByZXN1bHQpIHtcclxuXHR2YXIgcGxheWFibGUgPSB0aGlzO1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdC8vUmVwbGFjZSByZXBvcnRlZCBwbGF5YWJsZSB3aXRoIGxhdGVzdCBydW5uaW5nIHBsYXlhYmxlICh0aGlzIGlzIG5lY2Vzc2FyeSBmb3Igc2hvcnQtY2lyY3VpdCBsb2dpYylcclxuXHRcdHJlc3VsdC5wbGF5YWJsZSA9IHBsYXlhYmxlO1xyXG5cclxuXHRcdC8vU2hvcnQtY2lyY3VpdCBsb2dpYyBhbGxvd3MgaGlnaGVyLW9yZGVyIHBsYXlhYmxlIHRvIGZpZ3VyZSBvdXQgd2hhdCB0byBkbyBuZXh0LlxyXG5cdFx0aWYgKHNob3J0Q2lyY3VpdCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cclxuXHRcdHJldHVybiBwbGF5YWJsZS5wbGF5TmV4dChyZXN1bHQpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuLy9QbGF5IG5leHQuXHJcbl9QbGF5YWJsZS5wcm90b3R5cGUucGxheU5leHQgPSBmdW5jdGlvbihyZXN1bHQsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHZhciBwbGF5YWJsZSA9IHRoaXM7XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0Ly9GaW5kIG91dCB3aGVyZSB0byBnbyBuZXh0XHJcblx0XHR2YXIgbmV4dCA9IHBsYXlhYmxlLmZpbmROZXh0KHsgcmVzdWx0IH0pO1xyXG5cclxuXHRcdC8vSWYgdGhlcmUncyBzb21ld2hlcmUgdG8gZ28sIHRoZW4gZ28uXHJcblx0XHRpZiAobmV4dFswXSBpbnN0YW5jZW9mIF9QbGF5YWJsZSlcclxuXHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKFxyXG5cdFx0XHRcdG5leHQubWFwKGZ1bmN0aW9uKHBsYXlhYmxlKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gcGxheWFibGUucGxheShwYXJhbWV0ZXJzKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdC8vT3RoZXJ3aXNlLCB3ZSdyZSBkb25lIGhlcmVcclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vIFJldHVybiB0aGUgbmV4dCBwbGF5YWJsZSBpbiB0aGUgc2VxdWVuY2UuIE92ZXJ3cml0ZWFibGUgZm9yIHBsYXlhYmxlcyB3aXRoIG1vcmUgY29tcGxpY2F0ZWQgYnJhbmNoaW5nLlxyXG5fUGxheWFibGUucHJvdG90eXBlLmZpbmROZXh0ID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMubmV4dDtcclxufTtcclxuXHJcbl9QbGF5YWJsZS5wcm90b3R5cGUuX3N1bW1hcml6ZSA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4vLyBTdW1tYXJpemUgdGhlIGdhbWUgc3RydWN0dXJlLiBDYWxscyBzdW1tYXJ5VGhpcyBhbmQgc3VtbWFyeU5leHQsIHdoaWNoIGFyZSBvdmVyd3JpdGFibGUuXHJcbl9QbGF5YWJsZS5wcm90b3R5cGUuc3VtbWFyaXplID0gZnVuY3Rpb24oXHJcblx0c3VtbWFyeSA9IHt9LFxyXG5cdGVudHJpZXMgPSB7fSxcclxuXHRzaG9ydENpcmN1aXQgPSBmYWxzZSxcclxuXHRtYXhFbnRyaWVzID0gMTBcclxuKSB7XHJcblx0Ly8gU3RhcnQgc3VtbWFyeSBmb3IgdGhpcyBwbGF5YWJsZVxyXG5cdHN1bW1hcnlbdGhpcy5jb25zdHJ1Y3Rvci5jb3VudGVyTmFtZV0gPSB0aGlzLmlkO1xyXG5cclxuXHQvLyBUcmFjayBob3cgbWFueSB0aW1lcyB3ZSd2ZSBiZWVuIGhlcmUgYmVmb3JlLCB0byBhdm9pZCBjaXJjdWxhciByZWN1cnNpb25cclxuXHRlbnRyaWVzW3RoaXMuaWRdID8gKytlbnRyaWVzW3RoaXMuaWRdIDogKGVudHJpZXNbdGhpcy5pZF0gPSAxKTtcclxuXHRpZiAoZW50cmllc1t0aGlzLmlkXSA+IG1heEVudHJpZXMpIHNob3J0Q2lyY3VpdCA9IHRydWU7XHJcblxyXG5cdC8vIEFkZCBzdW1tYXJ5XHJcblx0dGhpcy5zdW1tYXJ5VGhpcyhzdW1tYXJ5LCBlbnRyaWVzKTtcclxuXHJcblx0Ly8gUHJvY2VlZCB0byBuZXh0IHN0ZXBzXHJcblx0aWYgKCFzaG9ydENpcmN1aXQgfHwgc2hvcnRDaXJjdWl0ICE9PSB0aGlzKVxyXG5cdFx0dGhpcy5zdW1tYXJ5TmV4dChzdW1tYXJ5LCBlbnRyaWVzKTtcclxuXHJcblx0cmV0dXJuIHN1bW1hcnk7XHJcbn07XHJcblxyXG4vLyBBZGRzIHRoZSBzdW1tYXJ5IGluZm9ybWF0aW9uIG9uIHRoaXMgcGxheWFibGUuIE92ZXJ3cml0ZSB0aGlzIGluIG9yZGVyIHRvIGFkZCBzcGVjaWZpYyBpbmZvcm1hdGlvbi5cclxuX1BsYXlhYmxlLnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnkgPSB7fSwgZW50cmllcyA9IHt9KSB7XHJcblx0cmV0dXJuIHN1bW1hcnk7XHJcbn07XHJcblxyXG4vLyBBZGRzIHN1bW1hcnkgaW5mb3JtYXRpb24gZG93biB0aGUgbmV4dC1wYXRoLiBPdmVyd2l0ZSB0aGlzIGZvciBwbGF5YWJsZXMgd2l0aCBtb3JlIGNvbXBsZXggYnJhbmNoaW5nLlxyXG5fUGxheWFibGUucHJvdG90eXBlLnN1bW1hcnlOZXh0ID0gZnVuY3Rpb24oc3VtbWFyeSA9IHt9LCBlbnRyaWVzID0ge30pIHtcclxuXHQvLyBJZiB0aGVyZSdzIGEgbmV4dC1lbnRyeVxyXG5cdGlmICh0aGlzLm5leHQubGVuZ3RoID4gMCkge1xyXG5cdFx0Ly8gTG9vcCBvdmVyIGVhY2ggbmV4dC1pdGVtLCBhbmQgc3VtbWFyaXplIGl0LlxyXG5cdFx0c3VtbWFyeS5uZXh0ID0gdGhpcy5uZXh0Lm1hcChmdW5jdGlvbihwbGF5YWJsZSkge1xyXG5cdFx0XHRyZXR1cm4gcGxheWFibGUuc3VtbWFyaXplKHt9LCBlbnRyaWVzKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIElmIHRoZXJlJ3Mgb25seSBvbmUgaXRlbSwgbm8gbmVlZCBmb3IgYW4gYXJyYXkuXHJcblx0XHRpZiAoc3VtbWFyeS5uZXh0Lmxlbmd0aCA9PSAxKSBzdW1tYXJ5Lm5leHQgPSBzdW1tYXJ5Lm5leHRbMF07XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbi8vQ29udm9sdXRlZCBjb2RlIGhlcmUgdG8gcHJvZHVjZSB0aGUgb2JqZWN0IHRoYXQgdXNlciBpbnRlcmFjdHMgd2l0aCAoaWUgYzEgaW4gJ2MxID0gQ2hvaWNlKCknKVxyXG4vL1RoaXMgbWltaWNzIGNyZWF0aW5nIGEgY2xhc3MgdGhhdCBpbmhlcml0cyBmcm9tIEZ1bmN0aW9uLiBGaXJzdCBkZWZpbmUgdGhlIFwicHJvdG90eXBlXCIsIHdoaWNoIGluY2x1ZGVzXHJcbi8vYSBcImNvbnN0cnVjdG9yXCIsIGEgXCJjYWxsXCIgbWV0aG9kIHRoYXQgd2lsbCBnZXQgY2FsbGVkLCBhbmQgYW55IG90aGVyIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXHJcbi8vVGhlbiAnY2xhc3NGYWN0b3J5JyBwcm9kdWNlcyB0aGUgY2xhc3MvY29uc3RydWN0aW5nIG9iamVjdCAoc2VlIGJlbG93KSwgd2hpY2ggeW91IGNhbiB1c2UgdG9cclxuLy9wcm9kdWNlIHRoZSBhY3R1YWwgb2JqZWN0cy5cclxuXHJcbnZhciBwbGF5YWJsZVByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRnVuY3Rpb24ucHJvdG90eXBlKTtcclxuXHJcbnBsYXlhYmxlUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZnVuY3Rpb24oX3BsYXlhYmxlKSB7XHJcblx0dmFyIHBsYXlhYmxlID0gdGhpcztcclxuXHJcblx0Ly9UYWctYmFjay4gU3RvcmUgdGhlIGZyb250LWVuZCBvYmplY3QgaW4gdGhlIGJhY2stZW5kIG9iamVjdCwgZm9yIHJldHJpZXZhbFxyXG5cdF9wbGF5YWJsZS5pbnRlcmZhY2UgPSBwbGF5YWJsZTtcclxuXHJcblx0dGhpcy5jYWxsID0gZnVuY3Rpb24oc291cmNlKSB7XHJcblx0XHR2YXIgcHJldmlvdXNQbGF5YWJsZSwgcGF0aDtcclxuXHJcblx0XHQvL1RPRE86IHZlcmlmeSB0aGF0IHNvdXJjZSBpcyB0aGUgcmlnaHQgdHlwZVxyXG5cclxuXHRcdHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UuYWxsKFtcclxuXHRcdFx0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmIChzb3VyY2UgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHNvdXJjZSBpbnN0YW5jZW9mIFN5bmNocm9ub3VzUHJvbWlzZSkge1xyXG5cdFx0XHRcdFx0c291cmNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdFx0XHRcdHByZXZpb3VzUGxheWFibGUgPSByZWdpc3RyeS5wbGF5YWJsZXNbcmVzdWx0LnBsYXlhYmxlLmlkKCldO1xyXG5cdFx0XHRcdFx0XHRwYXRoID0gcmVzdWx0LnBhdGg7XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKHBhdGgpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoKTtcclxuXHRcdFx0fSkoKSxcclxuXHRcdFx0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFByb21pc2UgfHwgc291cmNlIGluc3RhbmNlb2YgU3luY2hyb25vdXNQcm9taXNlKSkge1xyXG5cdFx0XHRcdFx0cHJldmlvdXNQbGF5YWJsZSA9IHJlZ2lzdHJ5LnBsYXlhYmxlc1tzb3VyY2UuaWQoKV07XHJcblx0XHRcdFx0XHRwYXRoID0gc291cmNlLnBhdGg7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoKTtcclxuXHRcdFx0fSkoKVxyXG5cdFx0XSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0Y29uc29sZS5sb2cocGF0aCk7XHJcblx0XHRcdGxvZyhcclxuXHRcdFx0XHRcImRlYnVnXCIsXHJcblx0XHRcdFx0XCJBZGRpbmcgbmV4dCBwbGF5YWJsZSB0byBcIiArXHJcblx0XHRcdFx0cHJldmlvdXNQbGF5YWJsZS5pZCArXHJcblx0XHRcdFx0XCIsIG5vZGUgXCIgK1xyXG5cdFx0XHRcdF9wbGF5YWJsZS5pZFxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0aWYgKHBhdGggPT0gXCJhbGxcIikgcHJldmlvdXNQbGF5YWJsZS5hZGROZXh0KF9wbGF5YWJsZSk7XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdG91dGNvbWVUcmVlR2V0VmFsdWUocHJldmlvdXNQbGF5YWJsZS5uZXh0LCBwYXRoKS5wdXNoKF9wbGF5YWJsZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxvZyhcInNpbGx5XCIsIHByZXZpb3VzUGxheWFibGUubmV4dCk7XHJcblx0XHRcdC8vcHJldmlvdXNQbGF5YWJsZS5uZXh0W3NlbGVjdGVkXS5wdXNoKF9jaG9pY2UpO1xyXG5cclxuXHRcdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKHtcclxuXHRcdFx0XHRwbGF5YWJsZTogcGxheWFibGUsXHJcblx0XHRcdFx0cGF0aDogXCJhbGxcIlxyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdHRoaXMuaWQgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBfcGxheWFibGUuaWQ7XHJcblx0fTtcclxuXHJcblx0dGhpcy5wbGF5ID0gZnVuY3Rpb24oe1xyXG5cdFx0aW5pdGlhbGl6ZVBsYXllcnMgPSBmYWxzZSxcclxuXHRcdHVzZVBheW9mZnMgPSB0cnVlLFxyXG5cdFx0c2hvcnRDaXJjdWl0ID0gZmFsc2UsXHJcblx0XHR3cml0ZUhpc3RvcnkgPSB0cnVlLFxyXG5cdFx0Y2xlYXJIaXN0b3J5ID0gdHJ1ZSxcclxuXHRcdHJlbGVhc2VQbGF5ZXJzID0gdHJ1ZVxyXG5cdH0gPSB7fSkge1xyXG5cclxuXHRcdGlmIChjbGVhckhpc3RvcnkpIGdhbWVIaXN0b3J5LmNsZWFySGlzdG9yeSgpO1xyXG5cclxuXHRcdHZhciBoaXN0b3J5ID0gd3JpdGVIaXN0b3J5ID9cclxuXHRcdFx0X3BsYXlhYmxlLmhpc3RvcnkgfHwgZ2FtZUhpc3RvcnkgOlxyXG5cdFx0XHRuZXcgSGlzdG9yeSgpO1xyXG5cclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxyXG5cdFx0XHQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0XHRyZXR1cm4gX3BsYXlhYmxlLnBsYXkoeyBpbml0aWFsaXplUGxheWVycywgdXNlUGF5b2Zmcywgc2hvcnRDaXJjdWl0LCBoaXN0b3J5LCByZWxlYXNlUGxheWVycyB9KTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmNhdGNoKGZ1bmN0aW9uKHJlYXNvbikge1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKHJlYXNvbik7XHJcblxyXG5cdFx0XHRcdC8vSWYgdGhlIGdhbWUgd2FzIHN0b3BwZWQgYnkgYSBIYWx0IHBsYXlhYmxlIG9yIGV2ZXJ5Ym9keSdzIGRlYWQsIHdlJ2xsIGVuZCB1cCBoZXJlLCBhbmQgdGhpbmdzIGFyZSBmaW5lLiBKdXN0IGxvZyBpdC5cclxuXHRcdFx0XHRpZiAocmVhc29uLnJlc3VsdCA9PSBcIkhhbHRcIikge1xyXG5cdFx0XHRcdFx0Z2FtZUhpc3RvcnkuYWRkKHJlYXNvbi5oaXN0b3J5RW50cnkpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFzb24ucmVzdWx0KTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHJlYXNvbi5yZXN1bHQgPT0gXCJQb3B1bGF0aW9uIENvbGxhcHNlXCIpXHJcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYXNvbi5yZXN1bHQpO1xyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0aGlzdG9yeS5sb2cuYWRkKHsgZXJyb3I6IHJlYXNvbiB9KTtcclxuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSlcclxuXHRcdFx0LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdFx0Ly9SZXBsYWNlIHJlc3VsdCwgc28gdGhhdCB1c2VyIGNhbid0IGdldCBhY2Nlc3MgdG8gX3BsYXlhYmxlc1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcclxuXHRcdFx0XHRcdFBvcHVsYXRpb246IFBvcHVsYXRpb24oKSxcclxuXHRcdFx0XHRcdGdhbWVIaXN0b3J5XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdHRoaXMuc3VtbWFyaXplID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gX3BsYXlhYmxlLnN1bW1hcml6ZSh7fSk7XHJcblx0fTtcclxufTtcclxuXHJcbnBsYXlhYmxlUHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbigpIHtcclxuXHQvL1RoaXMgd2lsbCBnZXQgb3ZlcndyaXR0ZW4gd2hlbiB0aGUgXCJjb25zdHJ1Y3RvclwiIGlzIGNhbGxlZCwgYnV0IGxlYXZpbmcgaXQgaGVyZSBzbyB5b3UgY2FuIGZpZ3VyZSBvdXQgaG93IHRoZSBoZWxsIHRoaXMgd29ya3MuXHJcbn07XHJcblxyXG5wbGF5YWJsZVByb3RvdHlwZS5wYXRoID0gXCJhbGxcIjtcclxuXHJcbi8vUHJvZHVjZXMgdGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBwcm9kdWNlIHRoZSBlbmQgcmVzdWx0LiBUaGlzIHBhcnQgaXMgcmV1c2FibGUgaWYgeW91IG5lZWQgdG8gZG8gdGhpcyBhZ2Fpbi5cclxudmFyIGNsYXNzRmFjdG9yeSA9IGZ1bmN0aW9uKHByb3RvKSB7XHJcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGYgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIGYuY2FsbC5hcHBseShmLCBhcmd1bWVudHMpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJjb25zdHJ1Y3RvclwiLCB7XHJcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuXHRcdFx0d3JpdGFibGU6IHRydWVcclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwiY2FsbFwiLCB7IHdyaXRhYmxlOiB0cnVlIH0pO1xyXG5cclxuXHRcdE9iamVjdC5rZXlzKHByb3RvKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG5cdFx0XHRmW2tleV0gPSBwcm90b1trZXldO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Zi5jb25zdHJ1Y3Rvci5hcHBseShmLCBhcmd1bWVudHMpO1xyXG5cclxuXHRcdGRlbGV0ZSBmLmNvbnN0cnVjdG9yOyAvL0FkZGVkIHRoaXMgYml0IGhlcmUsIHRvIHByZXZlbnQgdGhlIHVzZXIgZnJvbSB0cnlpbmcgdG8gY3JlYXRlIG5ldyBvYmplY3RzLlxyXG5cclxuXHRcdHJldHVybiBmO1xyXG5cdH07XHJcbn07XHJcblxyXG52YXIgUGxheWFibGUgPSBjbGFzc0ZhY3RvcnkocGxheWFibGVQcm90b3R5cGUpO1xyXG4vLyBjYWxsZWQgYXM6IHZhciBpbnN0YW5jZSA9IFBsYXlhYmxlKC8qIHNvbWUgaW50ZXJuYWwgb2JqZWN0IGxpa2UgX2Nob2ljZSAqLyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxuXHJcbi8vRXh0ZXJuYWwgZGVwZW5kZW5jeVxyXG52YXIgcG9pc3NvbiA9IHJlcXVpcmUoJ3JhbmRnZW4nKS5ycG9pc3NvbjtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIge3JlZ2lzdHJ5LCBnYW1lSGlzdG9yeX0gPSByZXF1aXJlKCcuLi9zdGF0ZScpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7aXNGdW5jdGlvbn1cdD0gcmVxdWlyZSgnLi4vaGVscGVyRnVuY3Rpb25zJykoXCJnZW5lcmFsXCIpO1xyXG52YXIge2lkSGFuZGxlcn0gXHQ9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwic3RhdGVcIik7XHJcblxyXG4vL1BhcmVudCBjbGFzc1xyXG52YXIge19QbGF5YWJsZSwgUGxheWFibGV9ID0gcmVxdWlyZSgnLi9wbGF5YWJsZScpO1xyXG5cclxuLy9QbGF5ZXIgY29udHJvbGxlcnNcclxudmFyIHtfUGxheWVyLCBQbGF5ZXJ9ID0gcmVxdWlyZSgnLi4vcGxheWVyJyk7XHJcbnZhciB7UGxheWVyTGlzdCwgVXNlclBsYXllckxpc3QsIGdhbWVQb3B1bGF0aW9uLCBQb3B1bGF0aW9ufSA9IHJlcXVpcmUoJy4uL3BvcHVsYXRpb24nKTtcclxuXHJcbi8vVXBkYXRlIHRoaXMgZWFjaCB0aW1lIC5wbGF5IGlzIGNhbGxlZCwgYnV0IGxlYXZlIGl0IGF2YWlsYWJsZSB0byB0aGUgd2hvbGUgc2NvcGUgc28gdGhhdCBcclxuLy9ncm93dGggYW5kIGRlY2F5IGNhbiBhY2Nlc3MgaXRcclxudmFyIHBvcHVsYXRpb247XHJcblxyXG4vL0RlZmF1bHQgZ3Jvd3RoIGZ1bmN0aW9uXHJcbnZhciBncm93dGhEZWZhdWx0ID0gZnVuY3Rpb24gZ3Jvd3RoKHBsYXllciwgcG9wdWxhdGlvbiwgYmlydGhSYXRlLCBzZWxlY3RpdmVNdWx0aXBsaWVyKSB7XHJcblx0dmFyIHNjb3JlID0gcGxheWVyLnNjb3JlO1xyXG5cdHZhciBtZWFuID0gcG9wdWxhdGlvbi5zY29yZXNNZWFuKCk7XHJcblx0dmFyIHN0ZCA9IHBvcHVsYXRpb24uc2NvcmVzU3RkKCk7XHJcblx0XHJcblx0dmFyIFogPSAhKGlzTmFOKHN0ZCkgfHwgc3RkPT0wKSA/IChzY29yZS1tZWFuKS9zdGQgOiAwXHJcblx0XHJcblx0Y29uc29sZS5sb2coc2NvcmUsIG1lYW4sIHN0ZCxaKTtcclxuXHRcclxuXHR2YXIgcmF0ZSA9IGJpcnRoUmF0ZSArIHNlbGVjdGl2ZU11bHRpcGxpZXIqWjtcclxuXHJcblx0dmFyIGdlbmVyYXRlZCA9IHBvaXNzb24ocmF0ZSk7XHJcblx0bG9nKFwic2lsbHlcIixcImdyb3d0aERlZmF1bHQ6IGdlbmVyYXRlZCByYW5kb20gbnVtYmVyIFwiICsgZ2VuZXJhdGVkLnRvU3RyaW5nKCkrIFwiIHVzaW5nIHJhdGUgXCIrIHJhdGUudG9TdHJpbmcoKSk7XHJcblx0XHJcblx0cmV0dXJuIGdlbmVyYXRlZDtcclxufVxyXG5cclxuLy9EZWZhdWx0IGRlY2F5IGZ1bmN0aW9uXHJcbnZhciBkZWNheURlZmF1bHQgPSBmdW5jdGlvbiBkZWNheShwbGF5ZXIsIHBvcHVsYXRpb24sIGRlYXRoUmF0ZSwgc2VsZWN0aXZlTXVsdGlwbGllcikge1xyXG5cdHZhciBzY29yZSA9IHBsYXllci5zY29yZTtcclxuXHR2YXIgbWVhbiA9IHBvcHVsYXRpb24uc2NvcmVzTWVhbigpO1xyXG5cdHZhciBzdGQgPSBwb3B1bGF0aW9uLnNjb3Jlc1N0ZCgpO1xyXG5cdFxyXG5cdGNvbnNvbGUubG9nKHNjb3JlLCBtZWFuLCBzdGQpO1xyXG5cdFxyXG5cdHZhciBaID0gICEoaXNOYU4oc3RkKXx8c3RkPT0wKSA/IChzY29yZS1tZWFuKS9zdGQgOiAwO1xyXG5cdFxyXG5cdGNvbnNvbGUubG9nKFopXHJcblx0dmFyIHJhdGUgPSBkZWF0aFJhdGUgLSBzZWxlY3RpdmVNdWx0aXBsaWVyKlo7XHJcblx0XHJcblx0dmFyIGdlbmVyYXRlZCA9IHBvaXNzb24ocmF0ZSk7XHJcblx0bG9nKFwic2lsbHlcIixcImRlY2F5RGVmYXVsdDogZ2VuZXJhdGVkIHJhbmRvbSBudW1iZXIgXCIgKyBnZW5lcmF0ZWQudG9TdHJpbmcoKSsgXCIgdXNpbmcgcmF0ZSBcIisgcmF0ZS50b1N0cmluZygpKTtcclxuXHRyZXR1cm4gZ2VuZXJhdGVkO1xyXG59XHJcblxyXG5cclxuXHJcbi8vQmFja2VuZCBmdW5jdGlvbiBjbGFzcyBmb3IgUG9wdWxhdGlvbkR5bmFtaWNzXHJcbmZ1bmN0aW9uIF9Qb3B1bGF0aW9uRHluYW1pY3MoaWQsIGJpcnRoUmF0ZSxkZWF0aFJhdGUsIHtncm93dGhGdW5jdGlvbj1ncm93dGhEZWZhdWx0LCBkZWNheUZ1bmN0aW9uPWRlY2F5RGVmYXVsdCwgc2VsZWN0aXZlTXVsdGlwbGllcj0gLjUsIHBsYXllclBhcmFtZXRlcnM9e319PXt9KXtcclxuXHRfUGxheWFibGUuY2FsbCh0aGlzLGlkKTtcclxuXHRcclxuXHR2YXIgcGQgPSB0aGlzO1xyXG5cdFxyXG5cdHRoaXMuYmlydGhSYXRlID0gYmlydGhSYXRlO1xyXG5cdHRoaXMuZGVhdGhSYXRlID0gZGVhdGhSYXRlO1xyXG5cdHRoaXMuc2VsZWN0aXZlTXVsdGlwbGllciA9IHNlbGVjdGl2ZU11bHRpcGxpZXI7XHJcblx0XHJcblx0Ly9XcmFwIHRoZSBncm93dGggYW5kIGRlY2F5IGZ1bmN0aW9ucywgc28gdGhhdCB0aGUgdXNlciBkb2Vzbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgY2FsbGluZyB0aGlzLmJpcnRoUmF0ZSBvciB0aGlzLmRlYXRoUmF0ZVxyXG5cdHRoaXMuZ3Jvd3RoID0gZnVuY3Rpb24ocGxheWVyKXtcclxuXHRcdGxvZyhcInNpbGx5XCIsXCJfcGQuZ3Jvd3RoOiBDaGVja2luZyBncm93IGNvbmRpdGlvblwiKTtcclxuXHRcdHJldHVybiBncm93dGhGdW5jdGlvbihwbGF5ZXIsIHBvcHVsYXRpb24sIHBkLmJpcnRoUmF0ZSwgcGQuc2VsZWN0aXZlTXVsdGlwbGllcilcclxuXHR9O1xyXG5cdHRoaXMuZGVjYXkgPSBmdW5jdGlvbihwbGF5ZXIpe1xyXG5cdFx0bG9nKFwic2lsbHlcIixcIl9wZC5kZWNheTogQ2hlY2tpbmcgZGVjYXkgY29uZGl0aW9uXCIpO1xyXG5cdFx0cmV0dXJuIGRlY2F5RnVuY3Rpb24ocGxheWVyLCBwb3B1bGF0aW9uLCBwZC5kZWF0aFJhdGUsIHBkLnNlbGVjdGl2ZU11bHRpcGxpZXIpO1xyXG5cdH07XHJcblx0XHJcblx0dGhpcy5wbGF5ZXJQYXJhbWV0ZXJzID0gcGxheWVyUGFyYW1ldGVycztcclxuXHRcclxuXHRyZWdpc3RyeS5jb250cm9sbGVyc1tpZF0gPSB0aGlzO1xyXG59XHJcbl9Qb3B1bGF0aW9uRHluYW1pY3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfUGxheWFibGUucHJvdG90eXBlKTtcclxuX1BvcHVsYXRpb25EeW5hbWljcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBfUG9wdWxhdGlvbkR5bmFtaWNzO1xyXG5cclxuX1BvcHVsYXRpb25EeW5hbWljcy5yZWdpc3RyeU5hbWUgPSBcImNvbnRyb2xsZXJzXCI7XHJcbl9Qb3B1bGF0aW9uRHluYW1pY3MuY291bnRlck5hbWUgPSBcInBvcHVsYXRpb25EeW5hbWljc1wiO1xyXG5cclxuXHJcbl9Qb3B1bGF0aW9uRHluYW1pY3MucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7aW5pdGlhbGl6ZVBsYXllcnM9ZmFsc2UsIHNob3J0Q2lyY3VpdD1mYWxzZSwgaGlzdG9yeT1nYW1lSGlzdG9yeX09e30pe1xyXG5cdFxyXG5cdHZhciBwZCA9IHRoaXM7XHJcblx0XHJcblx0dmFyIGJpcnRocyA9IDA7XHJcblx0dmFyIGRlYXRocyA9IDA7XHJcblx0XHJcblx0Ly9VcGRhdGUgcG9wdWxhdGlvbiB1c2luZyB3aG9ldmVyJ3MgYWxpdmUgY3VycmVudGx5XHJcblx0cG9wdWxhdGlvbiA9IGdhbWVQb3B1bGF0aW9uKCkub25seUFsaXZlKCk7XHJcblx0XHRcclxuXHRcclxuXHQvL0tpbGwgY3ljbGVcclxuXHR2YXIga2lsbGVkID0gbmV3IFBsYXllckxpc3QoW10pO1xyXG5cdHBvcHVsYXRpb24uZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpe1xyXG5cdFx0Ly8gSWYgdGhlIGRlY2F5IGZ1bmN0aW9uIGlzIHJldHVybnMgdHJ1dGh5LCBraWxsLlxyXG5cdFx0XHJcblx0XHRpZiAocGQuZGVjYXkocGxheWVyKSkge1xyXG5cdFx0XHRsb2coXCJzaWxseVwiLFwibXVzdCBraWxsLi4uXCIpXHJcblx0XHRcdHBsYXllci5raWxsKCk7XHJcblx0XHRcdGRlYXRocysrO1xyXG5cdFx0XHRraWxsZWQucHVzaChwbGF5ZXIpO1xyXG5cdFx0XHRsb2coXCJzaWxseVwiLFwiZGVhZFwiKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0XHJcblx0fSk7XHJcblx0XHJcblx0Ly9VcGRhdGUgdXBkYXRlIGFnYWluIHRvIHByZXZlbnQgdGhlIHJlY2VudGx5IGRlY2Vhc2VkIGZyb20gcmVwcm9kdWNpbmdcclxuXHRwb3B1bGF0aW9uID0gZ2FtZVBvcHVsYXRpb24oKS5vbmx5QWxpdmUoKTtcclxuXHRcclxuXHRpZiAocG9wdWxhdGlvbi5sZW5ndGggPT0gMCkge1xyXG5cdFx0Ly9FdmVyeWJvZHkncyBkZWFkLiBMZXQncyB3cmFwIGl0IHVwLlxyXG5cdFx0dmFyIHJlYXNvbiA9IHtyZXN1bHQ6XCJQb3B1bGF0aW9uIENvbGxhcHNlXCIsIHBsYXlhYmxlOnBkfTtcclxuXHRcdGhpc3RvcnkuZW5kKCk7XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYXNvbik7XHJcblx0fVxyXG5cdFxyXG5cdC8vQmlydGggY3ljbGVcclxuXHR2YXIgYm9ybiA9IG5ldyBVc2VyUGxheWVyTGlzdChbXSk7XHJcblx0cG9wdWxhdGlvbi5mb3JFYWNoKGZ1bmN0aW9uKHBsYXllcil7XHJcblx0XHQvL0JpcnRoIHdoYXRldmVyIG51bWJlciBpcyByZXR1cm5lZFxyXG5cdFx0dmFyIG51bUJpcnRoID0gcGQuZ3Jvd3RoKHBsYXllcilcclxuXHRcdGNvbnNvbGUubG9nKG51bUJpcnRoKTtcclxuXHRcdGZvciAodmFyIGk9MTsgaTw9bnVtQmlydGg7IGkrKyl7XHJcblx0XHRcdGxvZyhcInNpbGx5XCIsIFwiUGxheWVyIFwiICsgcGxheWVyLmlkICtcIiBnaXZpbmcgYmlydGghXCIpO1xyXG5cdFx0XHRcclxuXHRcdFx0dmFyIHBsYXllclBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LHtcclxuXHRcdFx0XHRcdGFzc2lnbjpwbGF5ZXIuc3RyYXRlZ3kgPyBwbGF5ZXIuc3RyYXRlZ3kuX2lkIDogXCJcIixcclxuXHRcdFx0XHRcdHBhcmVudDpwbGF5ZXIuaWR9XHJcblx0XHRcdFx0LHBkLnBsYXllclBhcmFtZXRlcnMpO1xyXG5cdFx0XHRcclxuXHRcdFx0Ym9ybi5wdXNoKFBsYXllcihwbGF5ZXJQYXJhbWV0ZXJzKSk7XHJcblx0XHR9XHRcclxuXHR9KTtcclxuXHRcclxuXHRcclxuXHR2YXIgcmVzdWx0ID0ge2JpcnRocywgZGVhdGhzfTtcclxuXHRcclxuXHR2YXIgcmVzdWx0T2JqZWN0ID0ge1xyXG5cdFx0cmVzdWx0LFxyXG5cdFx0J3BsYXlhYmxlJzpwZCxcclxuXHRcdGhpc3RvcnlFbnRyeTp7XHJcblx0XHRcdHBvcHVsYXRpb25EeW5hbWljczpwZC5pZCxcclxuXHRcdFx0cmVzdWx0XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdE9iamVjdCk7XHJcbn07XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIFBvcHVsYXRpb25EeW5hbWljcyhiaXJ0aFJhdGU9LjA1LCBkZWF0aFJhdGUgPSAuMDUsIHBhcmFtZXRlcnM9e30pe1xyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihwYXJhbWV0ZXJzLmlkLFwicG9wdWxhdGlvbkR5bmFtaWNzXCIpXHJcblx0XHJcblx0aWYgKHBhcmFtZXRlcnMuZ3Jvd3RoICYmICFpc0Z1bmN0aW9uKGdyb3d0aCkpIGxvZyhcImVycm9yXCIsaWQgKyBcIjogZ3Jvd3RoIHNob3VsZCBiZSBhIGZ1bmN0aW9uLlwiKTtcclxuXHRpZiAocGFyYW1ldGVycy5kZWNheSAmJiAhaXNGdW5jdGlvbihkZWNheSkpICAgbG9nKFwiZXJyb3JcIixpZCArIFwiOiBkZWNheSBzaG91bGQgYmUgYSBmdW5jdGlvbi5cIik7XHJcblx0XHRcclxuXHQvL0NyZWF0ZSBiYWNrZW5kIGxhbWJkYSBvYmplY3RcclxuXHR2YXIgX3BkID0gbmV3IF9Qb3B1bGF0aW9uRHluYW1pY3MoaWQsIGJpcnRoUmF0ZSwgZGVhdGhSYXRlLCBwYXJhbWV0ZXJzKTtcclxuXHRcclxuXHRcclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIHBkID0gUGxheWFibGUoX3BkKTtcdFxyXG5cdHJldHVybiBwZDtcdFxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7X1BvcHVsYXRpb25EeW5hbWljcywgUG9wdWxhdGlvbkR5bmFtaWNzfTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBSYW5kb21QbGF5ZXJDaG9pY2VcIilcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSwgZ2FtZUhpc3RvcnksIG9jY3VwaWVkUGxheWVycyB9ID0gcmVxdWlyZSgnLi4vc3RhdGUnKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwic3RhdGVcIik7XHJcbnZhciB7IGNoYWluZXJHZW5lcmF0b3IgfSA9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwicGxheWFibGVcIik7XHJcblxyXG4vL1BhcmVudCBjbGFzc1xyXG52YXIgeyBfUGxheWFibGUsIFBsYXlhYmxlIH0gPSByZXF1aXJlKCcuL3BsYXlhYmxlJyk7XHJcbnZhciB7IF9DaG9pY2UsIENob2ljZSB9ID0gcmVxdWlyZSgnLi9jaG9pY2UnKTtcclxuXHJcbi8vUG9wdWxhdGlvbiBoZWxwZXJzXHJcbnZhciB7IFBsYXllckxpc3QgfSA9IHJlcXVpcmUoJy4uL3BvcHVsYXRpb24nKTtcclxuXHJcblxyXG4vL0JhY2tlbmQgZnVuY3Rpb24gY2xhc3MgZm9yIFJQQ2hvaWNlXHJcbmZ1bmN0aW9uIF9SUENob2ljZShpZCwgb3B0aW9ucywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblxyXG5cdC8vSWYgdGhleSBzcGVjaWZ5IHBsYXllcnMgdG8gZHJhdyBmcm9tLCB1c2Ugb25seSB0aGF0IGxpc3QuIE90aGVyd2lzZSwgdXNlIHdob2V2ZXIncyBhcm91bmQuXHJcblx0dGhpcy5pbmNsdWRlUGxheWVycyA9IHBhcmFtZXRlcnMuaW5jbHVkZVBsYXllcnMgfHwgXCJhbGxcIjtcclxuXHJcblx0dGhpcy5leGNsdWRlUGxheWVycyA9IHBhcmFtZXRlcnMuZXhjbHVkZVBsYXllcnMgPyBuZXcgUGxheWVyTGlzdChwYXJhbWV0ZXJzLmV4Y2x1ZGVQbGF5ZXJzKSA6IG5ldyBQbGF5ZXJMaXN0KClcclxuXHJcblx0dGhpcy5nZW5lcmF0b3IgPSBNYXRoLnJhbmRvbTtcclxuXHJcblx0dmFyIHBsYXllciA9IG51bGw7XHJcblxyXG5cclxuXHRfQ2hvaWNlLmNhbGwodGhpcywgaWQsIHBsYXllciwgb3B0aW9ucywgcGFyYW1ldGVycyk7XHJcbn1cclxuXHJcbl9SUENob2ljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9DaG9pY2UucHJvdG90eXBlKTtcclxuX1JQQ2hvaWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9SUENob2ljZTtcclxuXHJcbl9SUENob2ljZS5yZWdpc3RyeU5hbWUgPSBcImNob2ljZXNcIjtcclxuX1JQQ2hvaWNlLmNvdW50ZXJOYW1lID0gXCJyYW5kb21QbGF5ZXJDaG9pY2VcIjtcclxuXHJcblxyXG5cclxuLy9TZWxlY3QgdGhlIHBsYXllciB0byBtYWtlIHRoZSBjaG9pY2VcclxuX1JQQ2hvaWNlLnByb3RvdHlwZS5jaG9vc2VQbGF5ZXIgPSBmdW5jdGlvbiBjaG9vc2VQbGF5ZXIoKSB7XHJcblxyXG5cdHZhciBycENob2ljZSA9IHRoaXM7XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdC8vRmluZCBwbGF5ZXJzIHRvIGNob29zZSBmcm9tXHJcblx0XHR2YXIgcG9vbCA9IG5ldyBQbGF5ZXJMaXN0KHJwQ2hvaWNlLmluY2x1ZGVQbGF5ZXJzKS5vbmx5QWxpdmUoKS5vbmx5QXZhaWxhYmxlKCkuZXhjbHVkZShycENob2ljZS5leGNsdWRlUGxheWVycylcclxuXHRcdGlmIChwb29sLmxlbmd0aCA9PSAwKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJObyBhdmFpbGFibGUgcGxheWVycy5cIik7XHJcblxyXG5cdFx0bG9nKFwic2lsbHlcIiwgXCJycENob2ljZS5jaG9vc2VQbGF5ZXI6IGNob29zaW5nIGZyb29tIHBvb2w6IFwiICsgcG9vbC5pZHMoKSk7XHJcblxyXG5cdFx0dmFyIHJhbmRvbU51bWJlciA9IE1hdGguZmxvb3IocnBDaG9pY2UuZ2VuZXJhdG9yKCkgKiBwb29sLmxlbmd0aCk7XHJcblx0XHR2YXIgY2FuZGlkYXRlID0gcG9vbFtyYW5kb21OdW1iZXJdO1xyXG5cclxuXHJcblx0XHRsb2coXCJzaWxseVwiLCBcInJwQ2hvaWNlLmNob29zZVBsYXllcjogc2VsZWN0aW5nIHBsYXllciBcIiwgY2FuZGlkYXRlLmlkKVxyXG5cclxuXHRcdHJwQ2hvaWNlLnBsYXllciA9IGNhbmRpZGF0ZTtcclxuXHRcdGNhbmRpZGF0ZS5hdmFpbGFibGUgPSBmYWxzZTtcclxuXHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhbmRpZGF0ZS5pZCk7XHJcblx0fSk7XHJcbn07XHJcblxyXG5fUlBDaG9pY2UucHJvdG90eXBlLnByZVBsYXkgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5jaG9vc2VQbGF5ZXIoKTtcclxufTtcclxuXHJcblxyXG5fUlBDaG9pY2UucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSkge1xyXG5cdHN1bW1hcnkub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxufTtcclxuXHJcblxyXG5cclxuZnVuY3Rpb24gUmFuZG9tUGxheWVyQ2hvaWNlKG9wdGlvbnMsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHZhciB7IGlkID0gbnVsbCwgZXhjbHVkZVBsYXllcnMgPSBbXSwgcGxheWVyTGlzdCA9IG51bGwgfSA9IHBhcmFtZXRlcnNcclxuXHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKGlkLCBcInJhbmRvbVBsYXllckNob2ljZVwiKVxyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIGNob2ljZSBvYmplY3RcclxuXHR2YXIgX3JwQ2hvaWNlID0gbmV3IF9SUENob2ljZShpZCwgb3B0aW9ucywgcGFyYW1ldGVycyk7XHJcblxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgcnBDaG9pY2UgPSBQbGF5YWJsZShfcnBDaG9pY2UpXHJcblxyXG5cdHJwQ2hvaWNlLnBsYXllckxpc3QgPSBmdW5jdGlvbihwbGF5ZXJMaXN0KSB7XHJcblx0XHRpZiAoQXJyYXkuaXNBcnJheShwbGF5ZXJMaXN0KSkgX3JwQ2hvaWNlLnBsYXllckxpc3QgPSBwbGF5ZXJMaXN0O1xyXG5cdFx0cmV0dXJuIF9ycENob2ljZS5wbGF5ZXJMaXN0XHJcblx0fTtcclxuXHJcblx0cnBDaG9pY2UuZXhjbHVkZVBsYXllcnMgPSBmdW5jdGlvbihleGNsdWRlUGxheWVycykge1xyXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoZXhjbHVkZVBsYXllcnMpKSB7XHJcblx0XHRcdF9ycENob2ljZS5leGNsdWRlUGxheWVycyA9IFtdO1xyXG5cclxuXHRcdFx0ZXhjbHVkZVBsYXllcnMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0XHRfcnBDaG9pY2UuZXhjbHVkZVBsYXllcnMucHVzaChwbGF5ZXIuaWQoKSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdH1cclxuXHRcdHJldHVybiBfcnBDaG9pY2UuZXhjbHVkZVBsYXllcnNcclxuXHR9O1xyXG5cclxuXHQvL0ludGVyZmFjZSB0byBzcGVjaWZ5IHNpbmdsZS1wbGF5ZXIgcGF5b2ZmcyBpbiBzaW5nbGUtcGxheWVyL3NpbmdsZS1jaG9pY2UgZ2FtZXNcclxuXHRfcnBDaG9pY2UuemVyb1BheW9mZnMoKTtcclxuXHJcblx0X3JwQ2hvaWNlLmdlbmVyYXRlQ2hhaW5pbmdGdW5jdGlvbnMocnBDaG9pY2UpO1xyXG5cclxuXHQvL0Z1bmN0aW9uIHRvIHNldCBhbGwgcGF5b2ZmcyBhdCBvbmNlXHJcblx0cnBDaG9pY2Uuc2V0QWxsUGF5b2ZmcyA9IGZ1bmN0aW9uKHBheW9mZnMpIHtcclxuXHRcdC8vVE9ETzogbWFrZSB0aGlzIHdvcmsuIEluY2x1ZGUgZXJyb3IgaGFuZGxpbmcgaWYgYXJyYXkgZ2l2ZW4gaXNuJ3QgZXhwZWN0ZWQgZGltZW5zaW9ucy5cclxuXHR9O1xyXG5cclxuXHJcblx0Ly9XYXkgZm9yIHVzZXIgdG8gaW50ZXJhY3Qgd2l0aCBwYXlvZmZzXHJcblx0cnBDaG9pY2UucGF5b2ZmcyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVnaXN0cnkuY2hvaWNlc1tpZF0ucGF5b2ZmczsgfTtcclxuXHJcblx0cmV0dXJuIHJwQ2hvaWNlO1xyXG59XHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBfUlBDaG9pY2UsIFJhbmRvbVBsYXllckNob2ljZSB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgQ2xhc3M6IFNlcXVlbmNlXCIpO1xyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKFwiLi4vc3RhdGVcIik7XHJcbnZhciB7IGdhbWVIaXN0b3J5IH0gPSByZXF1aXJlKFwiLi4vaGlzdG9yeVwiKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJGdW5jdGlvbnNcIikoXCJzdGF0ZVwiKTtcclxuXHJcbi8vSW5mb3JtYXRpb25cclxudmFyIHsgSW5mb3JtYXRpb24sIFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0gcmVxdWlyZShcIi4uL2luZm9ybWF0aW9uXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9ID0gcmVxdWlyZShcIi4vcGxheWFibGVcIik7XHJcblxyXG4vL0JhY2tlbmQgZnVuY3Rpb24gY2xhc3MgZm9yIFNlcXVlbmNlXHJcbmZ1bmN0aW9uIF9TZXF1ZW5jZShpZCwgcGxheWFibGVTdGFydCwgcGxheWFibGVGaW5pc2gsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdF9QbGF5YWJsZS5jYWxsKHRoaXMsIGlkLCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0dGhpcy5wbGF5YWJsZVN0YXJ0ID0gcmVnaXN0cnkucGxheWFibGVzW3BsYXlhYmxlU3RhcnQuaWQoKV07XHJcblx0dGhpcy5wbGF5YWJsZUZpbmlzaCA9IHJlZ2lzdHJ5LnBsYXlhYmxlc1twbGF5YWJsZUZpbmlzaC5pZCgpXTtcclxuXHJcblx0cmVnaXN0cnkuc2VxdWVuY2VzW2lkXSA9IHRoaXM7XHJcbn1cclxuX1NlcXVlbmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX1BsYXlhYmxlLnByb3RvdHlwZSk7XHJcbl9TZXF1ZW5jZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBfU2VxdWVuY2U7XHJcblxyXG5fU2VxdWVuY2UucmVnaXN0cnlOYW1lID0gXCJzZXF1ZW5jZXNcIjtcclxuX1NlcXVlbmNlLmNvdW50ZXJOYW1lID0gXCJzZXF1ZW5jZVwiO1xyXG5cclxuX1NlcXVlbmNlLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oe1xyXG5cdGhpc3RvcnkgPSBnYW1lSGlzdG9yeSxcclxuXHRpbmZvcm1hdGlvbiA9IHRoaXMuaW5mb3JtYXRpb24gfHxcclxuXHRQZXJmZWN0SW5mb3JtYXRpb25cclxufSA9IHt9KSB7XHJcblxyXG5cdHZhciBzZXF1ZW5jZSA9IHRoaXM7XHJcblxyXG5cdC8vTG9nIHRoZSBoaXN0b3J5IGFwcHJvcHJpYXRlbHlcclxuXHR2YXIgc3RhcnRFbnRyeSA9IHtcclxuXHRcdHNlcXVlbmNlOiBzZXF1ZW5jZS5pZCxcclxuXHRcdGFjdGlvbjogXCJzdGFydFwiXHJcblx0fTtcclxuXHRoaXN0b3J5LmxvZy5hZGQoc3RhcnRFbnRyeSk7XHJcblxyXG5cdC8vSGlzdG9yeSBvYmplY3QgdG8gZ2l2ZSB0byBzZXF1ZW5jZWQgcGxheWFibGVzLlxyXG5cdHZhciBzZXF1ZW5jZUhpc3RvcnkgPSBoaXN0b3J5LmNoaWxkKCk7XHJcblxyXG5cdC8vY29tcGFydG1lbnRhbGl6ZSBpZiBzZXQuIFwiY29tcGFydG1lbnRhbGl6ZVwiIG1lYW5zIHBhc3Mgb24gaW5mb3JtYXRpb24gYXMgaWYgdGhpcyBwbGF5YWJsZSBpcyB0aGUgZW50aXJlIGdhbWUuXHJcblx0aWYgKHNlcXVlbmNlLmNvbXBhcnRtZW50YWxpemUpIHtcclxuXHRcdGluZm9ybWF0aW9uID0gbmV3IEluZm9ybWF0aW9uKHNlcXVlbmNlLmNvbXBhcnRtZW50YWxpemUuaGlzdG9yeSB8fCBzZXF1ZW5jZUhpc3RvcnksXHJcblx0XHRcdHNlcXVlbmNlLmNvbXBhcnRtZW50YWxpemUucG9wdWxhdGlvbiB8fCBpbmZvcm1hdGlvbi5wb3B1bGF0aW9uKTtcclxuXHR9XHJcblxyXG5cdC8vIFJlY3Vyc2lvbiBkb3duIHRoZSBjaGFpbiBvZiBwbGF5YWJsZXNcclxuXHR2YXIgYWN0aW9uID0gZnVuY3Rpb24gYWN0aW9uKHJlc3VsdCkge1xyXG5cdFx0Ly9TdG9wIGlmIHRoZSBnYW1lIGlzIG92ZXIuXHJcblx0XHRpZiAoaGlzdG9yeS5zdG9wKSByZXR1cm4geyBwbGF5YWJsZTogc2VxdWVuY2UgfTtcclxuXHJcblx0XHQvL090aGVyd2lzZSwgcmVjdXJzZSB0byBmaWd1cmUgb3V0IHdoYXQgdG8gZG8gbmV4dC5cclxuXHRcdGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcclxuXHRcdFx0bG9nKFwic2lsbHlcIiwgXCJzZXF1ZW5jZS5wbGF5OiBOZXh0LWl0ZW0gaXMgYW4gYXJyYXksIHNwbGl0dGluZyBpbnRvIHBpZWNlcy5cIik7XHJcblxyXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoXHJcblx0XHRcdFx0cmVzdWx0Lm1hcChmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRcdFx0XHRsb2coXCJzaWxseVwiLCBcInNlcXVlbmNlLnBsYXk6IHJlY3Vyc2luZyBvblwiLCBpdGVtKTtcclxuXHRcdFx0XHRcdHJldHVybiBhY3Rpb24oaXRlbSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAocmVzdWx0LnBsYXlhYmxlICE9PSBzZXF1ZW5jZS5wbGF5YWJsZUZpbmlzaCkge1xyXG5cdFx0XHRsb2coXCJzaWxseVwiLCByZXN1bHQpO1xyXG5cclxuXHRcdFx0aWYgKHJlc3VsdC5wbGF5YWJsZS5maW5kTmV4dCh7IHJlc3VsdCB9KS5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0bG9nKFwic2lsbHlcIiwgXCJQbGF5YWJsZSBoYXMgbmV4dC1pdGVtLCBjb250aW51aW5nIGRvd24gY2hhaW4uXCIpO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0LnBsYXlhYmxlLnBsYXlOZXh0KHJlc3VsdCwgeyBzaG9ydENpcmN1aXQ6IHRydWUsIGhpc3Rvcnk6IHNlcXVlbmNlSGlzdG9yeSwgaW5mb3JtYXRpb24gfSlcclxuXHRcdFx0XHRcdC50aGVuKGFjdGlvbik7IC8vUmVwZWF0IGZvciBuZXh0IHBsYXlhYmxlIGluIGNoYWluXHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdH07XHJcblxyXG5cdHJldHVybiBzZXF1ZW5jZS5wbGF5YWJsZVN0YXJ0XHJcblx0XHQucGxheSh7IHNob3J0Q2lyY3VpdDogdHJ1ZSwgaGlzdG9yeTogc2VxdWVuY2VIaXN0b3J5LCBpbmZvcm1hdGlvbiB9KVxyXG5cdFx0LnRoZW4oYWN0aW9uKVxyXG5cdFx0LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdHJlc3VsdC5oaXN0b3J5RW50cnkgPSB7XHJcblx0XHRcdFx0c2VxdWVuY2U6IHNlcXVlbmNlLmlkLFxyXG5cdFx0XHRcdGFjdGlvbjogc2VxdWVuY2VIaXN0b3J5Lm9ycGhhbigpXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHQvL1RPRE86IGFkZCBpbmZvcm1hdGlvbiBtZWNoYW5pc21zXHJcblxyXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcblx0XHR9KTtcclxufTtcclxuXHJcbi8vT3ZlcndyaXRlIGhpc3RvcnkgaGFuZGxlciBzbyB0aGF0IHRyZWUgZG9lc24ndCBoYXZlIFwic3RhcnRcIiBhbmQgXCJmaW5pc2hcIiBlbnRyaWVzLlxyXG5fU2VxdWVuY2UucHJvdG90eXBlLmhhbmRsZUhpc3RvcnkgPSBmdW5jdGlvbih7IGhpc3RvcnkgPSBnYW1lSGlzdG9yeSB9ID0ge30sXHJcblx0cmVzdWx0XHJcbikge1xyXG5cdHZhciBzZXF1ZW5jZSA9IHRoaXM7XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0aGlzdG9yeS5sb2cuYWRkKHtcclxuXHRcdFx0c2VxdWVuY2U6IHNlcXVlbmNlLmlkLFxyXG5cdFx0XHRhY3Rpb246IFwiZmluaXNoXCIsXHJcblx0XHRcdGR1cmF0aW9uOiByZXN1bHQuaGlzdG9yeUVudHJ5LmR1cmF0aW9uXHJcblx0XHR9KTtcclxuXHJcblx0XHRoaXN0b3J5LmFkZE5vTG9nKHJlc3VsdC5oaXN0b3J5RW50cnkpO1xyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuLy9UT0RPOiBmaW5pc2ggdGhpcyFcclxuX1NlcXVlbmNlLnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnksIGVudHJpZXMsIHNob3J0Q2lyY3VpdCkge1xyXG5cdHN1bW1hcnkuYWN0aW9uID0ge307XHJcblxyXG5cdHRoaXMucGxheWFibGVTdGFydC5zdW1tYXJpemUoXHJcblx0XHRzdW1tYXJ5LmFjdGlvbixcclxuXHRcdGVudHJpZXMsXHJcblx0XHQoc2hvcnRDaXJjdWl0ID0gdGhpcy5wbGF5YWJsZUZpbmlzaClcclxuXHQpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gU2VxdWVuY2UocGxheWFibGVTdGFydCwgcGxheWFibGVGaW5pc2gsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihwYXJhbWV0ZXJzLmlkLCBcInNlcXVlbmNlXCIpO1xyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIGxvb3Agb2JqZWN0XHJcblx0dmFyIF9zZXF1ZW5jZSA9IG5ldyBfU2VxdWVuY2UoaWQsIHBsYXlhYmxlU3RhcnQsIHBsYXlhYmxlRmluaXNoLCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0Ly9SZXR1cm4gdGhpcyByZWZlcmVuY2Ugb2JqZWN0IHRvIHRoZSB1c2VyLiBSdW4gdGhlIGZ1bmN0aW9uIHRvIHNlbGVjdCBhIHNvdXJjZVxyXG5cdHZhciBzZXF1ZW5jZSA9IFBsYXlhYmxlKF9zZXF1ZW5jZSk7XHJcblx0cmV0dXJuIHNlcXVlbmNlO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX1NlcXVlbmNlLCBTZXF1ZW5jZSB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpc09iamVjdCB9ID0gcmVxdWlyZSgnLi4vaGVscGVyRnVuY3Rpb25zJykoXCJnZW5lcmFsXCIpO1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwic3RhdGVcIik7XHJcblxyXG4vL1BhcmVudCBjbGFzc1xyXG52YXIgeyBfUGxheWFibGUsIFBsYXlhYmxlIH0gPSByZXF1aXJlKCcuL3BsYXlhYmxlJyk7XHJcblxyXG4vLyBJbmZvcm1hdGlvbiBtZWNoYW5pY3NcclxudmFyIHsgSW5mb3JtYXRpb24sIFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0gcmVxdWlyZSgnLi4vaW5mb3JtYXRpb24nKTtcclxuXHJcblxyXG4vL0JhY2tlbmQgY2xhc3NcclxuZnVuY3Rpb24gX1NpbXVsdGFuZW91cyhpZCwgcGxheWFibGVBcnJheSwgeyBwbGF5YWJsZVBhcmFtZXRlcnMgPSB7fSB9ID0ge30pIHtcclxuXHRfUGxheWFibGUuY2FsbCh0aGlzLCBpZCk7XHJcblxyXG5cdHRoaXMucGxheWFibGVBcnJheSA9IHBsYXlhYmxlQXJyYXk7XHJcblx0dGhpcy5wbGF5YWJsZVBhcmFtZXRlcnMgPSBwbGF5YWJsZVBhcmFtZXRlcnM7XHJcblxyXG5cdHJlZ2lzdHJ5LmNvbnRyb2xsZXJzW2lkXSA9IHRoaXM7XHJcbn1cclxuXHJcbl9TaW11bHRhbmVvdXMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfUGxheWFibGUucHJvdG90eXBlKTtcclxuX1NpbXVsdGFuZW91cy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBfU2ltdWx0YW5lb3VzO1xyXG5cclxuX1NpbXVsdGFuZW91cy5yZWdpc3RyeU5hbWUgPSBcImNvbnRyb2xsZXJzXCI7XHJcbl9TaW11bHRhbmVvdXMuY291bnRlck5hbWUgPSBcInNpbXVsdGFuZW91c1wiO1xyXG5cclxuXHJcbi8vU2ltdWx0YW5lb3VzIFByb21pc2UuYWxsJ3MgdGhlIHBsYXlhYmxlcywgd2hpY2ggY2F1c2VzIHRoZW0gdG8gcnVuIG1lc2hlZC5cclxuX1NpbXVsdGFuZW91cy5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKHsgaGlzdG9yeSA9IGdhbWVIaXN0b3J5LCBpbmZvcm1hdGlvbiA9IFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0ge30pIHtcclxuXHJcblx0dmFyIHNpbXVsdGFuZW91cyA9IHRoaXM7XHJcblxyXG5cdC8vIERlYWwgd2l0aCBoaXN0b3J5LiBMb2cgc3RhcnQsIHRoZW4gc3BsaXQgaGlzdG9yeSBmb3IgY2hpbGRyZW4gcGxheWFibGVzIHRvIGZpbGwgaW4uXHJcblx0aGlzdG9yeS5sb2cuYWRkKHtcclxuXHRcdHNpbXVsdGFuZW91czogc2ltdWx0YW5lb3VzLmlkLFxyXG5cdFx0YWN0aW9uOiBcIlNpbXVsdGFuZW91cyBzdGFydC5cIlxyXG5cdH0pO1xyXG5cdHZhciBzaW11bHRhbmVvdXNIaXN0b3J5ID0gW11cclxuXHJcblxyXG5cclxuXHQvL1RPRE86IGlzIGluZm9ybWF0aW9uIG1lY2hhbmljcyBjb3JyZWN0P1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5hbGwoc2ltdWx0YW5lb3VzLnBsYXlhYmxlQXJyYXkubWFwKGZ1bmN0aW9uKHBsYXlhYmxlKSB7XHJcblxyXG5cdFx0dmFyIGJyYW5jaEhpc3RvcnkgPSBoaXN0b3J5LmNoaWxkKCk7XHJcblx0XHRzaW11bHRhbmVvdXNIaXN0b3J5LnB1c2goYnJhbmNoSGlzdG9yeSlcclxuXHJcblx0XHQvLyBJbmZvcm1hdGlvbiBtZWNoYW5pY3NcclxuXHRcdHZhciBpbmZvUG9wdWxhdGlvbiwgcGFyZW50SGlzdG9yeSwgaW5mb0hpc3RvcnkgPSBicmFuY2hIaXN0b3J5O1xyXG5cdFx0Ly9jb21wYXJ0bWVudGFsaXplIGlmIHNldC4gXCJjb21wYXJ0bWVudGFsaXplXCIgbWVhbnMgcGFzcyBvbiBpbmZvcm1hdGlvbiBhcyBpZiB0aGlzIHBsYXlhYmxlIGlzIHRoZSBlbnRpcmUgZ2FtZS5cclxuXHRcdGlmIChzaW11bHRhbmVvdXMuY29tcGFydG1lbnRhbGl6ZSkge1xyXG5cdFx0XHRpbmZvUG9wdWxhdGlvbiA9IHNpbXVsdGFuZW91cy5jb21wYXJ0bWVudGFsaXplLnBvcHVsYXRpb24gfHwgaW5mb3JtYXRpb24ucG9wdWxhdGlvbjtcclxuXHRcdFx0cGFyZW50SGlzdG9yeSA9IHNpbXVsdGFuZW91cy5jb21wYXJ0bWVudGFsaXplLmhpc3RvcnkgfHwgaW5mb3JtYXRpb24uaGlzdG9yeTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGluZm9Qb3B1bGF0aW9uID0gaW5mb3JtYXRpb24ucG9wdWxhdGlvbjtcclxuXHRcdFx0cGFyZW50SGlzdG9yeSA9IGluZm9ybWF0aW9uLmhpc3RvcnlcclxuXHRcdH1cclxuXHRcdHZhciBzaW11bHRhbmVvdXNJbmZvcm1hdGlvbiA9IG5ldyBJbmZvcm1hdGlvbihpbmZvSGlzdG9yeSwgaW5mb1BvcHVsYXRpb24sIHsgcGFyZW50SGlzdG9yeSB9KTtcclxuXHJcblxyXG5cclxuXHRcdHJldHVybiBwbGF5YWJsZS5wbGF5KHsgaGlzdG9yeTogYnJhbmNoSGlzdG9yeSwgaW5mb3JtYXRpb246IHNpbXVsdGFuZW91c0luZm9ybWF0aW9uIH0pO1xyXG5cdH0pKS50aGVuKGZ1bmN0aW9uKHJlc3VsdEFycmF5KSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdE9iamVjdCA9IHtcclxuXHRcdFx0cmVzdWx0QXJyYXksXHJcblx0XHRcdHBsYXlhYmxlOiBzaW11bHRhbmVvdXMsXHJcblx0XHRcdGhpc3RvcnlFbnRyeToge1xyXG5cdFx0XHRcdHNpbXVsdGFuZW91czogc2ltdWx0YW5lb3VzLmlkLFxyXG5cdFx0XHRcdGFjdGlvbjogc2ltdWx0YW5lb3VzSGlzdG9yeS5tYXAoZnVuY3Rpb24oaGlzdG9yeSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGhpc3Rvcnkub3JwaGFuKCk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHRcdHJldHVybiByZXN1bHRPYmplY3Q7XHJcblx0fSk7XHJcbn07XHJcblxyXG5cclxuX1NpbXVsdGFuZW91cy5wcm90b3R5cGUuaGFuZGxlSGlzdG9yeSA9IGZ1bmN0aW9uKHsgaGlzdG9yeSA9IGdhbWVIaXN0b3J5IH0gPSB7fSwgcmVzdWx0KSB7XHJcblxyXG5cdGhpc3RvcnkubG9nLmFkZCh7XHJcblx0XHRzaW11bHRhbmVvdXM6IHRoaXMuaWQsXHJcblx0XHRhY3Rpb246IFwiU2ltdWx0YW5lb3VzIGNvbXBsZXRlLlwiXHJcblx0fSk7XHJcblxyXG5cdGhpc3RvcnkuYWRkTm9Mb2cocmVzdWx0Lmhpc3RvcnlFbnRyeSk7XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxufTtcclxuXHJcbl9TaW11bHRhbmVvdXMucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSwgZW50cmllcykge1xyXG5cdHN1bW1hcnkuYWN0aW9uID0gW107XHJcblxyXG5cdHRoaXMucGxheWFibGVBcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHBsYXlhYmxlLCBpbmRleCkge1xyXG5cdFx0c3VtbWFyeS5hY3Rpb25baW5kZXhdID0ge31cclxuXHRcdHBsYXlhYmxlLnN1bW1hcml6ZShzdW1tYXJ5LmFjdGlvbltpbmRleF0sIGVudHJpZXMpO1xyXG5cdH0pO1xyXG59XHJcblxyXG5cclxuLy9Gcm9udGVuZCBjbGFzc1xyXG5mdW5jdGlvbiBTaW11bHRhbmVvdXMocGxheWFibGVBcnJheSwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHBhcmFtZXRlcnMuaWQsIFwic2ltdWx0YW5lb3VzXCIpXHJcblxyXG5cdHBsYXlhYmxlQXJyYXkgPSBwbGF5YWJsZUFycmF5Lm1hcChmdW5jdGlvbihwbGF5YWJsZSkge1xyXG5cdFx0cmV0dXJuIHJlZ2lzdHJ5LnBsYXlhYmxlc1twbGF5YWJsZS5pZCgpXTtcclxuXHR9KTtcclxuXHJcblxyXG5cdC8vQ3JlYXRlIGJhY2tlbmQgaW5zdGFuY2UuXHJcblx0dmFyIF9zaW11bHRhbmVvdXMgPSBuZXcgX1NpbXVsdGFuZW91cyhpZCwgcGxheWFibGVBcnJheSwgcGFyYW1ldGVycyk7XHJcblxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgc2ltdWx0YW5lb3VzID0gUGxheWFibGUoX3NpbXVsdGFuZW91cyk7XHJcblx0cmV0dXJuIHNpbXVsdGFuZW91cztcclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBfU2ltdWx0YW5lb3VzLCBTaW11bHRhbmVvdXMgfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XHJcbmxvZyhcImRlYnVnXCIsIFwiTG9hZGluZyBDbGFzczogU3RvY2hhc3RpYy1IYWx0XCIpXHJcblxyXG4vL0dhbWUgc3RhdGUgY29udHJvbGxlcnNcclxudmFyIHtyZWdpc3RyeSwgZ2FtZUhpc3Rvcnl9ID0gcmVxdWlyZSgnLi4vc3RhdGUnKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIge2lzRnVuY3Rpb259XHQ9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwiZ2VuZXJhbFwiKTtcclxudmFyIHtpZEhhbmRsZXJ9IFx0PSByZXF1aXJlKCcuLi9oZWxwZXJGdW5jdGlvbnMnKShcInN0YXRlXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHtfUGxheWFibGUsIFBsYXlhYmxlfSBcdD0gcmVxdWlyZSgnLi9wbGF5YWJsZScpO1xyXG52YXIge19IYWx0LCBIYWx0fVx0XHRcdD0gcmVxdWlyZSgnLi9oYWx0LWlmJyk7XHJcblxyXG5cclxuLy9CYWNrZW5kIGZ1bmN0aW9uIGNsYXNzIGZvciBTSGFsdFxyXG5mdW5jdGlvbiBfU0hhbHQoaWQsIHByb2JhYmlsaXR5LCBwYXJhbWV0ZXJzKXtcclxuXHRfSGFsdC5jYWxsKHRoaXMsaWQsbnVsbCxwYXJhbWV0ZXJzKTtcclxuXHRcclxuXHR2YXIgc0hhbHQgPSB0aGlzO1xyXG5cdFxyXG5cdHRoaXMucHJvYmFiaWxpdHkgPSBwcm9iYWJpbGl0eTtcclxuXHR0aGlzLmdlbmVyYXRvciA9IE1hdGgucmFuZG9tO1x0XHRcdFx0Ly9UT0RPOiBhbGxvdyB1c2VyIHRvIHNwZWNpZnkgcmFuZG9tIG51bWJlciBnZW5lcmF0b3JcclxuXHRcclxuXHR0aGlzLnRlc3RDb25kaXRpb24gPSBmdW5jdGlvbigpe1xyXG5cdFx0aWYgKHNIYWx0LmdlbmVyYXRvcigpIDwgc0hhbHQucHJvYmFiaWxpdHkpIHJldHVybiB0cnVlO1xyXG5cdH07XHJcblx0XHJcblx0XHJcblx0cmVnaXN0cnkuc0hhbHRzW2lkXSA9IHRoaXM7XHJcbn1cclxuX1NIYWx0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX0hhbHQucHJvdG90eXBlKTtcclxuX1NIYWx0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9TSGFsdDtcclxuXHJcbl9TSGFsdC5yZWdpc3RyeU5hbWUgPSBcInNIYWx0c1wiO1xyXG5fU0hhbHQuY291bnRlck5hbWUgPSBcInN0b2NoYXN0aWNIYWx0XCI7XHJcblxyXG4vKlxyXG5fU0hhbHQucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7aW5pdGlhbGl6ZVBsYXllcnM9ZmFsc2UsIHNob3J0Q2lyY3VpdD1mYWxzZX09e30pe1xyXG5cdFxyXG5cdHZhciBzSGFsdCA9IHRoaXM7XHJcblx0dmFyIHRlc3QgPSBzSGFsdC50ZXN0Q29uZGl0aW9uKCk7XHJcblx0XHJcblx0aWYgKHRlc3QpIHtcclxuXHRcdGxvZyhcImluZm9cIiwgXCJIYWx0aW5nIGF0IFwiICsgc0hhbHQuaWQpXHJcblx0XHRcclxuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdCh7XHJcblx0XHRcdHJlc3VsdDpcIkhhbHRcIixcclxuXHRcdFx0cGxheWFibGU6c0hhbHRcclxuXHRcdH0pO1xyXG5cdH1cclxuXHRcclxuXHR2YXIgcmVzdWx0T2JqZWN0ID0ge1xyXG5cdFx0J3Jlc3VsdCc6XCJDb250aW51ZWRcIixcclxuXHRcdCdwbGF5YWJsZSc6c0hhbHRcclxuXHR9O1xyXG5cdFxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0T2JqZWN0KVxyXG5cdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XHRcclxuXHRcdFxyXG5cdFx0Ly9UT0RPOiBhZGQgaW5mb3JtYXRpb24gbWVjaGFuaXNtc1xyXG5cdFx0XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdClcdFx0XHJcblx0fSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xyXG5cdFx0XHJcblx0XHRyZXR1cm4gc0hhbHQucHJvY2VlZChyZXN1bHQsIHNob3J0Q2lyY3VpdCk7XHJcblx0fSk7XHJcbn07XHJcbiovXHJcblxyXG5fU0hhbHQucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSwgZW50cmllcyl7XHJcblx0c3VtbWFyeS5wcm9iYWJpbGl0eSA9IHRoaXMucHJvYmFiaWxpdHk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBTdG9jaGFzdGljSGFsdChwcm9iYWJpbGl0eSwge2lkPW51bGwsIGxvZ0NvbnRpbnVlPWZhbHNlfT17fSl7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKGlkLFwic3RvY2hhc3RpY0hhbHRcIilcclxuXHRcclxuXHRpZiAoaXNOYU4ocHJvYmFiaWxpdHkpIHx8IHByb2JhYmlsaXR5IDwgMCB8fCBwcm9iYWJpbGl0eSA+IDEpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcm9iYWJpbGl0eScpO1xyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIHNIYWx0IG9iamVjdHNcclxuXHR2YXIgX3NIYWx0ID0gbmV3IF9TSGFsdChpZCwgcHJvYmFiaWxpdHksIHtsb2dDb250aW51ZX0pO1xyXG5cdFxyXG5cdFxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgc0hhbHQgPSBQbGF5YWJsZShfc0hhbHQpO1x0XHJcblx0cmV0dXJuIHNIYWx0O1x0XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtfU0hhbHQsIFN0b2NoYXN0aWNIYWx0fTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBTdG9jaGFzdGljTG9vcFwiKVxyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5LCBnYW1lSGlzdG9yeSB9ID0gcmVxdWlyZSgnLi4vc3RhdGUnKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwic3RhdGVcIik7XHJcbnZhciB7IGNoYWluZXJHZW5lcmF0b3IgfSA9IHJlcXVpcmUoJy4uL2hlbHBlckZ1bmN0aW9ucycpKFwicGxheWFibGVcIik7XHJcblxyXG4vL1BhcmVudCBjbGFzc2VzXHJcbnZhciB7IF9QbGF5YWJsZSwgUGxheWFibGUgfSA9IHJlcXVpcmUoJy4vcGxheWFibGUnKTtcclxudmFyIHsgX0xvb3AsIExvb3AgfSA9IHJlcXVpcmUoJy4vbG9vcCcpO1xyXG5cclxuXHJcbi8vQmFja2VuZCBmdW5jdGlvbiBjbGFzcyBmb3IgU3RvY2hhc3RpY0xvb3BcclxuZnVuY3Rpb24gX1NMb29wKGlkLCBwbGF5YWJsZSwgcHJvYmFiaWxpdHksIHBhcmFtZXRlcnMpIHtcclxuXHRfTG9vcC5jYWxsKHRoaXMsIGlkLCBwbGF5YWJsZSwgbnVsbCwgcGFyYW1ldGVycyk7XHJcblxyXG5cdHRoaXMucGxheWFibGUgPSByZWdpc3RyeS5wbGF5YWJsZXNbcGxheWFibGUuaWQoKV07XHJcblxyXG5cdC8vVGhpcyBpbmhlcml0cyBmcm9tIExvb3Agd2hpY2ggdXNlcyBhIGNvdW50LiBEZWxldGUgdGhhdCBhbmQgcmVwbGFjZSB3aXRoIHByb2JhYmlsaXR5LlxyXG5cdGRlbGV0ZSB0aGlzLmNvdW50O1xyXG5cdHRoaXMucHJvYmFiaWxpdHkgPSBwcm9iYWJpbGl0eTtcclxuXHJcblx0dGhpcy5nZW5lcmF0b3IgPSBNYXRoLnJhbmRvbTsgLy9UT0RPOiBhbGxvdyB1c2VyIHRvIHNwZWNpZnkgcmFuZG9tIG51bWJlciBnZW5lcmF0b3JcclxuXHJcblx0cmVnaXN0cnkuc0xvb3BzW2lkXSA9IHRoaXM7XHJcbn1cclxuX1NMb29wLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX0xvb3AucHJvdG90eXBlKTtcclxuX1NMb29wLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9TTG9vcDtcclxuXHJcbl9TTG9vcC5yZWdpc3RyeU5hbWUgPSBcInNMb29wc1wiO1xyXG5fU0xvb3AuY291bnRlck5hbWUgPSBcInN0b2NoYXN0aWNMb29wXCI7XHJcblxyXG5cclxuX1NMb29wLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oe1xyXG5cdGluaXRpYWxpemVQbGF5ZXJzID0gZmFsc2UsXHJcblx0c2hvcnRDaXJjdWl0ID0gZmFsc2UsXHJcblx0aGlzdG9yeSA9IGdhbWVIaXN0b3J5LFxyXG5cdGluZm9ybWF0aW9uOiBQZXJmZWN0SW5mb3JtYXRpb25cclxufSA9IHt9KSB7XHJcblxyXG5cdHZhciBzTG9vcCA9IHRoaXM7XHJcblx0c0xvb3AuY291bnRlciA9IDA7XHJcblx0dmFyIGxvb3BIaXN0b3J5ID0gaGlzdG9yeS5jaGlsZCgpO1xyXG5cclxuXHRpZiAoc0xvb3AuY29tcGFydG1lbnRhbGl6ZSkge1xyXG5cdFx0aW5mb3JtYXRpb24gPSBuZXcgSW5mb3JtYXRpb24oc0xvb3AuY29tcGFydG1lbnRhbGl6ZS5oaXN0b3J5IHx8IGxvb3BIaXN0b3J5LFxyXG5cdFx0XHRzTG9vcC5jb21wYXJ0bWVudGFsaXplLnBvcHVsYXRpb24gfHwgaW5mb3JtYXRpb24ucG9wdWxhdGlvbik7XHJcblx0fVxyXG5cclxuXHJcblx0dmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoe30pO1xyXG5cclxuXHQvL1NlY3Rpb24gdGhhdCB3aWxsIGJlIGxvb3BlZFxyXG5cdHZhciBhY3Rpb24gPSBmdW5jdGlvbihyZXN1bHQpIHtcclxuXHJcblx0XHRzTG9vcC5jb3VudGVyKys7XHJcblx0XHRpZiAoIXJlc3VsdCkgcmVzdWx0ID0ge307XHJcblxyXG5cclxuXHRcdC8vRGVhbCB3aXRoIGhpc3RvcnlcclxuXHRcdGhpc3RvcnkubG9nLmFkZCh7XHJcblx0XHRcdGxvb3A6IHNMb29wLmlkLFxyXG5cdFx0XHRsb29wVG86IHNMb29wLnBsYXlhYmxlLmlkLFxyXG5cdFx0XHRjb3VudDogc0xvb3AuY291bnRlclxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHNMb29wLnBsYXlhYmxlLnBsYXkoeyBzaG9ydENpcmN1aXQ6IHRydWUsIGhpc3Rvcnk6IGxvb3BIaXN0b3J5LCBpbmZvcm1hdGlvbiB9KVxyXG5cdFx0XHQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHJcblx0XHRcdFx0cmVzdWx0LnBsYXlhYmxlID0gc0xvb3A7XHJcblx0XHRcdFx0Ly9UT0RPOiBhZGQgaW5mb3JtYXRpb24gbWVjaGFuaXNtc1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdClcclxuXHRcdFx0fSk7XHJcblx0fTtcclxuXHJcblxyXG5cdC8vR2VuZXJhdGUgcmFuZG9tIG51bWJlcnMsIHJlcGVhdCB3aGlsZSBudW1iZXIgaXMgYWJvdmUgaGFsdGluZyBwcm9iYWJpbGl0eVxyXG5cdHdoaWxlIChzTG9vcC5nZW5lcmF0b3IoKSA+IHNMb29wLnByb2JhYmlsaXR5KSB7XHJcblx0XHRwcm9taXNlID0gcHJvbWlzZS50aGVuKGFjdGlvbik7XHJcblx0fVxyXG5cclxuXHJcblx0cmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHJcblx0XHRyZXN1bHQuaGlzdG9yeUVudHJ5ID0ge1xyXG5cdFx0XHRsb29wOiBzTG9vcC5pZCxcclxuXHRcdFx0Y291bnQ6IHNMb29wLmNvdW50ZXIsXHJcblx0XHRcdGFjdGlvbjogbG9vcEhpc3Rvcnkub3JwaGFuKClcclxuXHRcdH07XHJcblxyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuX1NMb29wLnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnksIGVudHJpZXMpIHtcclxuXHRzdW1tYXJ5LnByb2JhYmlsaXR5ID0gdGhpcy5wcm9iYWJpbGl0eTtcclxuXHJcblx0c3VtbWFyeS5hY3Rpb24gPSB7fVxyXG5cdHRoaXMucGxheWFibGUuc3VtbWFyaXplKHN1bW1hcnkuYWN0aW9uLCBlbnRyaWVzLCB0cnVlKVxyXG59XHJcblxyXG5cclxuLy9Vc2VyIGludGVyZmFjZVxyXG5mdW5jdGlvbiBTdG9jaGFzdGljTG9vcChwbGF5YWJsZSwgcHJvYmFiaWxpdHkgPSAuNSwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHBhcmFtZXRlcnMuaWQsIFwic3RvY2hhc3RpY0xvb3BcIilcclxuXHJcblx0aWYgKGlzTmFOKHByb2JhYmlsaXR5KSB8fCBwcm9iYWJpbGl0eSA8IDAgfHwgcHJvYmFiaWxpdHkgPiAxKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvYmFiaWxpdHknKTtcclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBzTG9vcCBvYmplY3RcclxuXHR2YXIgX3NMb29wID0gbmV3IF9TTG9vcChpZCwgcGxheWFibGUsIHByb2JhYmlsaXR5LCBwYXJhbWV0ZXJzKTtcclxuXHJcblxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgc0xvb3AgPSBQbGF5YWJsZShfc0xvb3ApO1xyXG5cdHJldHVybiBzTG9vcDtcclxufVxyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX1NMb29wLCBTdG9jaGFzdGljTG9vcCB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgQ2xhc3M6IFR1cm5cIik7XHJcblxyXG4vL0V4dGVybmFsIGRlcGVuZGVuY3lcclxudmFyIHsgU3luY2hyb25vdXNQcm9taXNlIH0gPSByZXF1aXJlKFwic3luY2hyb25vdXMtcHJvbWlzZVwiKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpc09iamVjdCwgb25jZSB9ID0gcmVxdWlyZShcIi4uL2hlbHBlckZ1bmN0aW9uc1wiKShcImdlbmVyYWxcIik7XHJcbnZhciB7IGNoYWluZXJHZW5lcmF0b3IsIG91dGNvbWVUcmVlR2V0VmFsdWUsIG91dGNvbWVUcmVlU2V0VmFsdWUgfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJGdW5jdGlvbnNcIikoXCJwbGF5YWJsZVwiKTtcclxudmFyIHsgcmVjdXJzZSB9ID0gcmVxdWlyZShcIi4uL2hlbHBlckZ1bmN0aW9uc1wiKShcInR1cm5cIik7XHJcbnZhciB7IGlkSGFuZGxlciB9ID0gcmVxdWlyZShcIi4uL2hlbHBlckZ1bmN0aW9uc1wiKShcInN0YXRlXCIpO1xyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKFwiLi4vc3RhdGVcIik7XHJcbnZhciB7IGdhbWVIaXN0b3J5IH0gPSByZXF1aXJlKFwiLi4vaGlzdG9yeVwiKTtcclxudmFyIHsgSW5mb3JtYXRpb24sIFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0gcmVxdWlyZShcIi4uL2luZm9ybWF0aW9uXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9ID0gcmVxdWlyZShcIi4vcGxheWFibGVcIik7XHJcblxyXG4vL0JhY2tlbmQgZnVuY3Rpb24gY2xhc3MgZm9yIFR1cm5cclxuZnVuY3Rpb24gX1R1cm4oaWQsIGNob2ljZXMsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdF9QbGF5YWJsZS5jYWxsKHRoaXMsIGlkKTtcclxuXHJcblx0dGhpcy5wYXlvZmZzSW1wbGljaXQgPSB7fTtcclxuXHR0aGlzLnBheW9mZnNFeHBsaWNpdCA9IHt9O1xyXG5cclxuXHR0aGlzLm5leHQgPSB7fTtcclxuXHJcblx0dGhpcy5jaG9pY2VzID0gY2hvaWNlcy5tYXAoZnVuY3Rpb24oY2hvaWNlKSB7XHJcblx0XHRyZXR1cm4gcmVnaXN0cnkuY2hvaWNlc1tjaG9pY2UuaWQoKV07XHJcblx0fSk7XHJcblxyXG5cdHJlZ2lzdHJ5LnR1cm5zW2lkXSA9IHRoaXM7XHJcblxyXG5cdHZhciB0dXJuID0gdGhpcztcclxuXHJcblx0dGhpcy5jaG9pY2VNYXAgPSB0aGlzLmNob2ljZXMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdHJldHVybiBpdGVtLm9wdGlvbnM7XHJcblx0fSk7XHJcblxyXG5cdHJlY3Vyc2UodHVybi5jaG9pY2VNYXAsIHR1cm4ucGF5b2Zmc0ltcGxpY2l0LCBudWxsLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIEFycmF5KHR1cm4uY2hvaWNlTWFwLmxlbmd0aCkuZmlsbCgwKTtcclxuXHRcdH0pXHJcblx0XHQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0bG9nKFwic2lsbHlcIiwgXCJBZGRlZCBpbXBsaWNpdCBwYXlvZmZzIG1hcCB0byB0dXJuLlwiKTtcclxuXHRcdFx0cmV0dXJuIHJlY3Vyc2UodHVybi5jaG9pY2VNYXAsIHR1cm4ucGF5b2Zmc0V4cGxpY2l0LCB7fSk7XHJcblx0XHR9KVxyXG5cdFx0LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdGxvZyhcInNpbGx5XCIsIFwiQWRkZWQgZXhwbGljaXQgcGF5b2ZmcyBtYXAgdG8gdHVybi5cIik7XHJcblx0XHRcdHJldHVybiByZWN1cnNlKHR1cm4uY2hvaWNlTWFwLCB0dXJuLm5leHQsIG51bGwsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBbXTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KVxyXG5cdFx0LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdGxvZyhcInNpbGx5XCIsIFwiQWRkZWQgYmxhbmsgbmV4dCBtYXAgdG8gdHVybi5cIik7XHJcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHRcdH0pXHJcblx0XHQuY2F0Y2goZnVuY3Rpb24ocmVhc29uKSB7XHJcblx0XHRcdGxvZyhcImVycm9yXCIsIHJlYXNvbik7XHJcblx0XHR9KTsgLy9UT0RPOiBlcnJvciBoYW5kbGluZyBoZXJlXHJcbn1cclxuX1R1cm4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfUGxheWFibGUucHJvdG90eXBlKTtcclxuX1R1cm4ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gX1R1cm47XHJcblxyXG5fVHVybi5yZWdpc3RyeU5hbWUgPSBcInR1cm5zXCI7XHJcbl9UdXJuLmNvdW50ZXJOYW1lID0gXCJ0dXJuXCI7XHJcblxyXG5cclxuX1R1cm4ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7XHJcblx0dXNlUGF5b2ZmcyA9IHRydWUsXHJcblx0aGlzdG9yeSA9IGdhbWVIaXN0b3J5LFxyXG5cdGluZm9ybWF0aW9uID0gUGVyZmVjdEluZm9ybWF0aW9uLFxyXG5cdHJlbGVhc2VQbGF5ZXJzID0gdHJ1ZVxyXG59ID0ge30pIHtcclxuXHJcblx0dmFyIHR1cm4gPSB0aGlzO1xyXG5cdHZhciBjaG9pY2VIaXN0b3J5ID0gaGlzdG9yeS5jaGlsZCgpO1xyXG5cdHZhciBjaG9pY2VJbmZvcm1hdGlvbiA9IGluZm9ybWF0aW9uLmNoaWxkKCk7XHJcblxyXG5cdGlmICh0dXJuLmNvbXBhcnRtZW50YWxpemUpIHtcclxuXHRcdGNob2ljZUluZm9ybWF0aW9uID0gbmV3IEluZm9ybWF0aW9uKHR1cm4uY29tcGFydG1lbnRhbGl6ZS5oaXN0b3J5IHx8IGNob2ljZUhpc3RvcnksXHJcblx0XHRcdHR1cm4uY29tcGFydG1lbnRhbGl6ZS5wb3B1bGF0aW9uIHx8IGluZm9ybWF0aW9uLnBvcHVsYXRpb24pO1xyXG5cdH1cclxuXHJcblx0aGlzdG9yeS5sb2cuYWRkKHtcclxuXHRcdHR1cm46IHR1cm4uaWQsXHJcblx0XHRjaG9pY2VzOiB0dXJuLmNob2ljZXMubWFwKGZ1bmN0aW9uKGNob2ljZSkge1xyXG5cdFx0XHRyZXR1cm4gY2hvaWNlLmlkO1xyXG5cdFx0fSlcclxuXHR9KTtcclxuXHJcblx0dmFyIGNvbXBpbGVJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uKHJpKSB7XHJcblx0XHQvL0lmIHRoZXJlJ3Mgbm8gdHVybiBlbnRyeSwgY3JlYXRlIG9uZS5cclxuXHRcdGlmICghY2hvaWNlSW5mb3JtYXRpb24uYWRkaXRpb25hbFswXS50dXJuKSB7XHJcblx0XHRcdHZhciB0dXJuSW5mbyA9IHtcclxuXHRcdFx0XHR0dXJuOiB7XHJcblx0XHRcdFx0XHRpZDogdHVybi5pZCxcclxuXHRcdFx0XHRcdGNob2ljZXM6IFtdLFxyXG5cdFx0XHRcdFx0ZXhjbHVkZShwbGF5ZXIpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY2hvaWNlcy5maWx0ZXIoZnVuY3Rpb24oY2hvaWNlKSB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNob2ljZS5wbGF5ZXIgPT0gcGxheWVyO1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHRcdGNob2ljZUluZm9ybWF0aW9uLmFkZGl0aW9uYWwudW5zaGlmdCh0dXJuSW5mbyk7XHJcblx0XHR9XHJcblx0XHRjaG9pY2VJbmZvcm1hdGlvbi5hZGRpdGlvbmFsWzBdLnR1cm4uY2hvaWNlcy5wdXNoKFxyXG5cdFx0XHRjaG9pY2VJbmZvcm1hdGlvbi5hZGRpdGlvbmFsLnBvcCgpXHJcblx0XHQpO1xyXG5cclxuXHRcdGluZm9ybWF0aW9uLmFkZGl0aW9uYWwuZm9yRWFjaCggLy8gVE9ETzogd2hhdCBkb2VzIHRoaXMgZG8/Pz9cclxuXHRcdFx0Y2hvaWNlSW5mb3JtYXRpb24uYWRkQWRkaXRpb25hbC5iaW5kKGNob2ljZUluZm9ybWF0aW9uKVxyXG5cdFx0KTtcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5hbGwoXHJcblx0XHRcdHR1cm4uY2hvaWNlcy5tYXAoZnVuY3Rpb24oY2hvaWNlKSB7XHJcblx0XHRcdFx0cmV0dXJuIGNob2ljZS5wbGF5KHtcclxuXHRcdFx0XHRcdHNob3J0Q2lyY3VpdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGhpc3Rvcnk6IGNob2ljZUhpc3RvcnksXHJcblx0XHRcdFx0XHRpbmZvcm1hdGlvbjogY2hvaWNlSW5mb3JtYXRpb24sXHJcblx0XHRcdFx0XHRfY29tcGlsZUluZm9ybWF0aW9uOiBjb21waWxlSW5mb3JtYXRpb24sXHJcblx0XHRcdFx0XHRyZWxlYXNlUGxheWVyczogZmFsc2VcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSlcclxuXHRcdClcclxuXHRcdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHQvL1JlLWZvcm1hdCBvdXRwdXQgZnJvbSBhcnJheSBvZiBDaG9pY2UgcmVzdWx0cyB0byBzaW5nbGUgVHVybiByZXN1bHRcclxuXHRcdFx0Ly9BbmQgcmVsZWFzZSBwbGF5ZXJzXHJcblx0XHRcdHZhciByZXN1bHRQYXRoID0gcmVzdWx0Lm1hcChmdW5jdGlvbihjaG9pY2UsIGluZGV4KSB7XHJcblx0XHRcdFx0aWYgKHJlbGVhc2VQbGF5ZXJzKSB0dXJuLmNob2ljZXNbaW5kZXhdLnJlbGVhc2VQbGF5ZXIoKTtcclxuXHRcdFx0XHRyZXR1cm4gY2hvaWNlLnJlc3VsdDtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvL1Bhc3MgYWxvbmcgcmVzdWx0cyBhbmQgcmVjb3JkIGhpc3RvcnlcclxuXHRcdFx0dmFyIHJlc3VsdE9iamVjdCA9IHtcclxuXHRcdFx0XHRyZXN1bHQ6IHJlc3VsdFBhdGgsXHJcblx0XHRcdFx0cGxheWFibGU6IHR1cm4sXHJcblx0XHRcdFx0aGlzdG9yeUVudHJ5OiB7XHJcblx0XHRcdFx0XHR0dXJuOiB0dXJuLmlkLFxyXG5cdFx0XHRcdFx0cmVzdWx0czogY2hvaWNlSGlzdG9yeS5vcnBoYW4oKSxcclxuXHRcdFx0XHRcdHBheW91dHM6IHt9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRPYmplY3QpO1xyXG5cdFx0fSlcclxuXHRcdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHQvL0ltcGxlbWVudCBwYXlvZmZzXHJcblx0XHRcdGlmICh1c2VQYXlvZmZzKSB7XHJcblx0XHRcdFx0dmFyIGltcGxpY2l0UGF5b2ZmcyA9IG91dGNvbWVUcmVlR2V0VmFsdWUoXHJcblx0XHRcdFx0XHR0dXJuLnBheW9mZnNJbXBsaWNpdCxcclxuXHRcdFx0XHRcdHJlc3VsdC5yZXN1bHRcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHRcdHZhciBleHBsaWNpdFBheW9mZnMgPSBvdXRjb21lVHJlZUdldFZhbHVlKFxyXG5cdFx0XHRcdFx0dHVybi5wYXlvZmZzRXhwbGljaXQsXHJcblx0XHRcdFx0XHRyZXN1bHQucmVzdWx0XHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0Ly8gRm9yIHRoZSBsb2dcclxuXHRcdFx0XHR2YXIgcGF5b3V0cyA9IHt9O1xyXG5cclxuXHRcdFx0XHRpbXBsaWNpdFBheW9mZnMuZm9yRWFjaChmdW5jdGlvbihwYXlvZmYsIGluZGV4KSB7XHJcblx0XHRcdFx0XHQvLyBEbyBub3RoaW5nIGlmIHBheW9mZiBpcyB6ZXJvLlxyXG5cdFx0XHRcdFx0aWYgKHBheW9mZiA9PSAwKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdFx0Ly8gZmV0Y2ggcGxheWVyIGFuZCBpbmNyZW1lbnQgc2NvcmVcclxuXHRcdFx0XHRcdHZhciBwbGF5ZXIgPSB0dXJuLmNob2ljZXNbaW5kZXhdLnBsYXllcjtcclxuXHRcdFx0XHRcdHBsYXllci5zY29yZSArPSBwYXlvZmY7XHJcblxyXG5cdFx0XHRcdFx0Ly9BbmQgaW5jbHVkZSBpdCBpbiB0aGUgbG9nIGVudHJ5XHJcblx0XHRcdFx0XHRwYXlvdXRzW3BsYXllci5pZF0gPSBOdW1iZXIocGF5b2ZmKTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0Zm9yICh2YXIgcGxheWVyIGluIGV4cGxpY2l0UGF5b2Zmcykge1xyXG5cdFx0XHRcdFx0cmVnaXN0cnkucGxheWVyc1twbGF5ZXJdLnNjb3JlICs9IGV4cGxpY2l0UGF5b2Zmc1twbGF5ZXJdO1xyXG5cclxuXHRcdFx0XHRcdC8vQW5kIGluY2x1ZGUgaXQgaW4gdGhlIGxvZyBlbnRyeVxyXG5cdFx0XHRcdFx0cGF5b3V0c1twbGF5ZXJdID0gTnVtYmVyKGV4cGxpY2l0UGF5b2Zmc1twbGF5ZXJdKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vTG9nIGZvciB0aGUgc2NvcmVzIGxvZ1xyXG5cdFx0XHRcdHZhciBzY29yZUVudHJ5ID0ge1xyXG5cdFx0XHRcdFx0dHVybjogdHVybi5pZCxcclxuXHRcdFx0XHRcdHJlc3VsdDogcmVzdWx0LnJlc3VsdCxcclxuXHRcdFx0XHRcdHBheW91dHM6IHBheW91dHNcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdGhpc3RvcnkuYWRkU2NvcmVzKHNjb3JlRW50cnkpO1xyXG5cclxuXHJcblx0XHRcdFx0Ly8gTG9nIGZvciB0aGUgZ2FtZSBoaXN0b3J5XHJcblx0XHRcdFx0cmVzdWx0Lmhpc3RvcnlFbnRyeS5wYXlvdXRzID0gcGF5b3V0cztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpOyAvL1RPRE86IGFkZCBpbmZvcm1hdGlvbiBtZWNoYW5pc21zXHJcblx0XHR9KTtcclxufTtcclxuXHJcbi8vT3ZlcndyaXRlIGRlZmF1bHQgaGlzdG9yeSBoYW5kbGVyLCBiZWNhdXNlIHdlIGRvbid0IHdhbnQgYSBzZWNvbmQgZW50cnkgaW4gdGhlIHRyZWVcclxuX1R1cm4ucHJvdG90eXBlLmhhbmRsZUhpc3RvcnkgPSBmdW5jdGlvbih7IGhpc3RvcnkgPSBnYW1lSGlzdG9yeSB9ID0ge30sXHJcblx0cmVzdWx0XHJcbikge1xyXG5cdGhpc3RvcnkuYWRkTm9Mb2cocmVzdWx0Lmhpc3RvcnlFbnRyeSk7XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxufTtcclxuXHJcbl9UdXJuLnByb3RvdHlwZS5maW5kTmV4dCA9IGZ1bmN0aW9uKHsgcmVzdWx0IH0gPSB7fSkge1xyXG5cdHJldHVybiBvdXRjb21lVHJlZUdldFZhbHVlKHRoaXMubmV4dCwgcmVzdWx0LnJlc3VsdCk7XHJcbn07XHJcblxyXG5fVHVybi5wcm90b3R5cGUuZ2VuZXJhdGVDaGFpbmluZ0Z1bmN0aW9ucyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBfdHVybiA9IHRoaXM7XHJcblx0dmFyIHR1cm4gPSBfdHVybi5pbnRlcmZhY2U7XHJcblxyXG5cdC8vQ3JlYXRlIHBheW9mZiBzZXR0ZXIvYnJhbmNoIHJvdXRlciBmdW5jdGlvbnMuXHJcblx0Ly9yZWN1cnNlIGFkZHMgYSB3cmFwcGVyIGFyb3VuZCB0aGlzIGZ1bmN0aW9uIHdoaWNoIHN1cHBsaWVzIHRoZSBwYXRoLlxyXG5cdHJlY3Vyc2UoX3R1cm4uY2hvaWNlTWFwLCB0dXJuLCBmdW5jdGlvbihwYXRoLCBwYXlvZmZzKSB7XHJcblx0XHQvL0lmIHVzZXIgc3VwcGxpZWQgcGF5b2ZmcyBpbiBhcnJheSBmb3JtLCB0aGVuIHRyYW5zbGF0ZSB0byBvYmplY3QgYmFzZWQgb24gd2hpY2ggcGxheWVycyBhcmUgaW52b2x2ZWQgaW4gdGhlIGNob2ljZXNcclxuXHRcdGlmIChBcnJheS5pc0FycmF5KHBheW9mZnMpKSB7XHJcblx0XHRcdGlmIChwYXlvZmZzLmxlbmd0aCAhPT0gX3R1cm4uY2hvaWNlcy5sZW5ndGgpIHtcclxuXHRcdFx0XHQvL0lmIGFycmF5IGlzbid0IHJpZ2h0IGxlbmd0aCwgdGhlbiB0aGlzIGlzIHVuaW50ZWxsaWdpYmxlLlxyXG5cdFx0XHRcdGxvZyhcclxuXHRcdFx0XHRcdFwiZXJyb3JcIixcclxuXHRcdFx0XHRcdFwiUGF5b2ZmIGFycmF5IGRvZXMgbm90IG1hdGNoIFR1cm4gZGltZW5zaW9ucywgY2Fubm90IGFzc2lnbiBwYXlvZmZzLlwiXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiUGF5b2ZmIGFycmF5IGlzIG5vdCBjb3JyZWN0IGxlbmd0aFwiKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBvcmlnaW5hbFBheW9mZnMgPSBwYXlvZmZzLnNsaWNlKCk7XHJcblx0XHRcdHBheW9mZnMgPSB7fTtcclxuXHJcblx0XHRcdG91dGNvbWVUcmVlU2V0VmFsdWUoX3R1cm4ucGF5b2Zmc0ltcGxpY2l0LCBwYXRoLCBvcmlnaW5hbFBheW9mZnMpO1xyXG5cdFx0fSBlbHNlIGlmIChpc09iamVjdChwYXlvZmZzKSkge1xyXG5cdFx0XHRwYXlvZmZzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwYXlvZmZzKSk7XHJcblx0XHRcdG91dGNvbWVUcmVlU2V0VmFsdWUoX3R1cm4ucGF5b2Zmc0V4cGxpY2l0LCBwYXRoLCBwYXlvZmZzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoe1xyXG5cdFx0XHRwbGF5YWJsZTogdHVybixcclxuXHRcdFx0cGF0aDogcGF0aFxyXG5cdFx0fSk7XHJcblx0fSk7XHJcbn07XHJcblxyXG5fVHVybi5wcm90b3R5cGUuc2V0QWxsUGF5b2ZmcyA9IGZ1bmN0aW9uKHBheW9mZkFycmF5KSB7XHJcblx0dmFyIHR1cm4gPSB0aGlzO1xyXG5cclxuXHQvL1JlY3Vyc2UgdGhyb3VnaCB0aGUgb3B0aW9ucyBpbiBpbnB1dCwgdG8gY29tZSB1cCB3aXRoIGEgcGF0aCB0byBldmVyeSBjb21iaW5hdGlvbiBvZiBvcHRpb25zIGluIHRoZSBhcnJheSBvZiBhcnJheXMuXHJcblx0ZnVuY3Rpb24gcmVjdXJzZShpbnB1dCwgbnVtUGxheWVycywgcGF5b2ZmcywgcGF0aCA9IFtdLCBjb29yZGluYXRlcyA9IFtdKSB7XHJcblx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUocGF0aCkudGhlbihmdW5jdGlvbihwYXRoKSB7XHJcblx0XHRcdC8vU2luY2Ugd2Ugc2xpY2UgdGhlIGFycmF5IGVhY2ggdGltZSwgaWYgdGhlcmUgYXJlIG5vIG1vcmUgZW50cmllcyBsZWZ0IHRoZW4gd2UncmUgZG9uZSB3aXRoIHRoaXMgYnJhbmNoLlxyXG5cdFx0XHRpZiAoaW5wdXQubGVuZ3RoID09IDApIHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZShwYXRoKTtcclxuXHJcblx0XHRcdC8vQW1vbmcgYWxsIHZhbHVlcyBmcm9tIHRoZSBhcnJheVxyXG5cdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLmFsbChcclxuXHRcdFx0XHRpbnB1dFswXS5tYXAoZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcclxuXHRcdFx0XHRcdHZhciBzcGxpdFBhdGggPSBwYXRoLnNsaWNlKDApLmNvbmNhdChpdGVtKTtcclxuXHRcdFx0XHRcdHZhciBzcGxpdENvb3JkaW5hdGVzID0gY29vcmRpbmF0ZXMuc2xpY2UoMCkuY29uY2F0KGluZGV4KTtcclxuXHRcdFx0XHRcdHZhciBzcGxpdFBheW9mZnMgPSBwYXlvZmZzW2luZGV4XTtcclxuXHJcblx0XHRcdFx0XHQvL0lmIHdlJ3JlIGF0IHRoZSBsYXN0IHBvc2l0aW9uIGluIHRoZSBhcnJheSBvZiBvcHRpb25zLCB0aGVuIHdlIGhhdmUgYSBjb21wbGV0ZSBwYXRoLlxyXG5cdFx0XHRcdFx0aWYgKGlucHV0Lmxlbmd0aCA9PSAxKSB7XHJcblx0XHRcdFx0XHRcdC8qIHlvdSBtaWdodCBuZWVkIHRoZXNlIGxhdGVyXHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcInBhdGggXCIsIHNwbGl0UGF0aCk7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcImNvb3JkaW5hdGVzIFwiLCBzcGxpdENvb3JkaW5hdGVzKVxyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJwYXlvZmYgXCIsc3BsaXRQYXlvZmZzKVxyXG5cdFx0XHRcdFx0Ki9cclxuXHJcblx0XHRcdFx0XHRcdHNwbGl0UGF5b2ZmcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc3BsaXRQYXlvZmZzKSk7XHJcblxyXG5cdFx0XHRcdFx0XHQvL0FsbG93IHRoZSBmaXJzdCBmZXcgYXJyYXkgZWxlbWVudHMgdG8gYmUgaW1wbGljaXQgcGF5b2Zmcy4gQ2hlY2sgdGhhdCB0aGV5IGFyZSBhY3R1YWxseSB0aGVyZSBhbmQgYXJlIG51bWJlcnNcclxuXHRcdFx0XHRcdFx0dmFyIGltcGxpY2l0ID0gc3BsaXRQYXlvZmZzLnNsaWNlKDAsIG51bVBsYXllcnMpO1xyXG5cdFx0XHRcdFx0XHRpZiAoXHJcblx0XHRcdFx0XHRcdFx0aW1wbGljaXQubGVuZ3RoID09IG51bVBsYXllcnMgJiZcclxuXHRcdFx0XHRcdFx0XHRpbXBsaWNpdC5ldmVyeShmdW5jdGlvbihwYXlvZmYpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAhaXNOYU4ocGF5b2ZmKTtcclxuXHRcdFx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdFx0XHQpIHtcclxuXHRcdFx0XHRcdFx0XHRvdXRjb21lVHJlZVNldFZhbHVlKHR1cm4ucGF5b2Zmc0ltcGxpY2l0LCBzcGxpdFBhdGgsIGltcGxpY2l0KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Ly9BbnkgcmVtYWluaW5nIHNob3VsZCBiZSBhc3NpZ25lZCBhcyBleHBsaWNpdCBwYXlvZmZzLCBpZiB0aGV5J3JlIG9iamVjdHMuXHJcblx0XHRcdFx0XHRcdHNwbGl0UGF5b2Zmcy5zbGljZShudW1QbGF5ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKGV4cGxpY2l0KSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGlzT2JqZWN0KGV4cGxpY2l0KSlcclxuXHRcdFx0XHRcdFx0XHRcdG91dGNvbWVUcmVlU2V0VmFsdWUodHVybi5wYXlvZmZzRXhwbGljaXQsIHNwbGl0UGF0aCwgZXhwbGljaXQpO1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvL0lmIHRoZXJlIGFyZSBtb3JlIGl0ZW1zIHRvIGl0ZXJhdGUgb3ZlciwgaW5jbHVkZSB0aGVtIGluIHRoZSBvdXRwdXQgdGhlbiByZWN1cnNlLlxyXG5cdFx0XHRcdFx0cmV0dXJuIHJlY3Vyc2UoXHJcblx0XHRcdFx0XHRcdGlucHV0LnNsaWNlKDEpLFxyXG5cdFx0XHRcdFx0XHRudW1QbGF5ZXJzLFxyXG5cdFx0XHRcdFx0XHRzcGxpdFBheW9mZnMsXHJcblx0XHRcdFx0XHRcdHNwbGl0UGF0aCxcclxuXHRcdFx0XHRcdFx0c3BsaXRDb29yZGluYXRlc1xyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHQpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVjdXJzZSh0dXJuLmNob2ljZU1hcCwgdHVybi5jaG9pY2VzLmxlbmd0aCwgcGF5b2ZmQXJyYXkpLmNhdGNoKFxyXG5cdFx0ZnVuY3Rpb24ocmVhc29uKSB7XHJcblx0XHRcdGxvZyhcImVycm9yXCIsIHJlYXNvbik7XHJcblx0XHR9XHJcblx0KTtcclxufTtcclxuXHJcbi8vIEFkZGluZyBtb3JlIGNvbXBsaWNhdGVkIHN1bW1hcnkgZW50cnlcclxuX1R1cm4ucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSwgZW50cmllcywgc2hvcnRDaXJjdWl0ID0gZmFsc2UpIHtcclxuXHQvLyBGZXRjaCBzdW1tYXJpZXMgZm9yIGVhY2ggY2hvaWNlLlxyXG5cdHN1bW1hcnkuY2hvaWNlcyA9IFtdO1xyXG5cdHRoaXMuY2hvaWNlcy5mb3JFYWNoKGZ1bmN0aW9uKGNob2ljZSwgaW5kZXgpIHtcclxuXHRcdHN1bW1hcnkuY2hvaWNlc1tpbmRleF0gPSBjaG9pY2Uuc3VtbWFyaXplKFxyXG5cdFx0XHRzdW1tYXJ5LmNob2ljZXNbaW5kZXhdLFxyXG5cdFx0XHRlbnRyaWVzLFxyXG5cdFx0XHR0cnVlXHJcblx0XHQpO1xyXG5cdH0pO1xyXG5cclxuXHQvLyBJbmNsdWRlIHBheW9mZnNcclxuXHRzdW1tYXJ5LnBheW9mZnMgPSBKU09OLnBhcnNlKFxyXG5cdFx0SlNPTi5zdHJpbmdpZnkoe1xyXG5cdFx0XHRpbXBsaWNpdDogdGhpcy5wYXlvZmZzSW1wbGljaXQsXHJcblx0XHRcdGV4cGxpY2l0OiB0aGlzLnBheW9mZnNFeHBsaWNpdFxyXG5cdFx0fSlcclxuXHQpO1xyXG5cclxuXHRyZXR1cm4gc3VtbWFyeTtcclxufTtcclxuXHJcbi8vXHJcbl9UdXJuLnByb3RvdHlwZS5zdW1tYXJ5TmV4dCA9IGZ1bmN0aW9uKHN1bW1hcnksIGVudHJpZXMpIHtcclxuXHR2YXIgdHVybiA9IHRoaXM7XHJcblxyXG5cdC8vIENyZWF0ZSBtYXBcclxuXHRzdW1tYXJ5Lm5leHQgPSB7fTtcclxuXHR2YXIgY291bnQgPSAwO1xyXG5cdHJlY3Vyc2UodGhpcy5jaG9pY2VNYXAsIHN1bW1hcnkubmV4dCwgbnVsbCwgZnVuY3Rpb24ocGF0aCkge1xyXG5cdFx0cmV0dXJuIG91dGNvbWVUcmVlR2V0VmFsdWUodHVybi5uZXh0LCBwYXRoKS5tYXAoZnVuY3Rpb24ocGxheWFibGUpIHtcclxuXHRcdFx0Kytjb3VudDtcclxuXHRcdFx0cmV0dXJuIHBsYXlhYmxlLnN1bW1hcml6ZSgpO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblxyXG5cdC8vIElmIHRoZXJlIGlzIG5vIG5leHQsIGRlbGV0ZSB0aGUga2V5LlxyXG5cdGlmIChjb3VudCA9PSAwKSBkZWxldGUgc3VtbWFyeS5uZXh0O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gVHVybihjaG9pY2VzLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHR2YXIgaWQgPSBpZEhhbmRsZXIocGFyYW1ldGVycy5pZCwgXCJ0dXJuXCIpO1xyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIGNob2ljZSBvYmplY3RcclxuXHR2YXIgX3R1cm4gPSBuZXcgX1R1cm4oaWQsIGNob2ljZXMsIHBhcmFtZXRlcnMpO1xyXG5cclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIHR1cm4gPSBQbGF5YWJsZShfdHVybik7XHJcblxyXG5cdF90dXJuLmdlbmVyYXRlQ2hhaW5pbmdGdW5jdGlvbnMoKTtcclxuXHJcblx0Ly9GdW5jdGlvbiB0byBzZXQgYWxsIHBheW9mZnMgYXQgb25jZVxyXG5cdHR1cm4uc2V0QWxsUGF5b2ZmcyA9IGZ1bmN0aW9uKHBheW9mZnMpIHtcclxuXHRcdC8vVE9ETzogSW5jbHVkZSBlcnJvciBoYW5kbGluZyBpZiBhcnJheSBnaXZlbiBpc24ndCBleHBlY3RlZCBkaW1lbnNpb25zLlxyXG5cdFx0X3R1cm4uc2V0QWxsUGF5b2ZmcyhwYXlvZmZzKTtcclxuXHR9O1xyXG5cclxuXHQvL1dheSBmb3IgdXNlciB0byBpbnRlcmFjdCB3aXRoIHBheW9mZnNcclxuXHR0dXJuLnBheW9mZnMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBKU09OLnBhcnNlKFxyXG5cdFx0XHRKU09OLnN0cmluZ2lmeSh7XHJcblx0XHRcdFx0aW1wbGljaXQ6IF90dXJuLnBheW9mZnNJbXBsaWNpdCxcclxuXHRcdFx0XHRleHBsaWNpdDogX3R1cm4ucGF5b2Zmc0V4cGxpY2l0XHJcblx0XHRcdH0pXHJcblx0XHQpO1xyXG5cdH07XHJcblxyXG5cdC8vIFJldHVybnMgdGhlIHBheW9mZnMgaW4gbmVzdGVkIGFycmF5IGZvcm0sIHRvIG1ha2UgY2xvbmluZyBlYXNpZXIsIGllLiB0Mi5zZXRBbGxQYXlvZmZzKHQxLnBheW9mZnNNYXRyaXgoKSlcclxuXHR0dXJuLnBheW9mZnNNYXRyaXggPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHQvLyByZWN1cnNpb24gdG8gY29uc3RydWN0IHBheW9mZiBtYXRyaXhcclxuXHRcdHZhciBtYXBwZXIgPSBmdW5jdGlvbihvYmosIHBhdGggPSBbXSkge1xyXG5cdFx0XHQvL0lmIGl0J3MgYW4gYXJyYXksIHRoZW4gd2UndmUgcmVhY2hlZCB0aGUgcGF5b2Zmc1xyXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcblx0XHRcdFx0dmFyIHBheW9mZiA9IG9iai5zbGljZSgwKVxyXG5cdFx0XHRcdC8vIEFkZCBleHBsaWNpdCBwYXlvZmZzIHRvb1xyXG5cdFx0XHRcdHZhciBleHBsaWNpdCA9IG91dGNvbWVUcmVlR2V0VmFsdWUoX3R1cm4ucGF5b2Zmc0V4cGxpY2l0LCBwYXRoKTtcclxuXHJcblx0XHRcdFx0Ly8gT25seSBhZGQgYW4gZW50cnkgaWYgdGhlIGV4cGxpY2l0IHBheW9mZnMgb2JqZWN0IGlzIG5vdCBlbXB0eVxyXG5cdFx0XHRcdHJldHVybiBPYmplY3Qua2V5cyhleHBsaWNpdCkubGVuZ3RoID4gMCA/IHBheW9mZi5jb25jYXQoW291dGNvbWVUcmVlR2V0VmFsdWUoX3R1cm4ucGF5b2Zmc0V4cGxpY2l0LFxyXG5cdFx0XHRcdFx0cGF0aCldKSA6IHBheW9mZlxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBPdGhlcndpc2UsIGRpZyBpbiBkZWVwZXJcclxuXHRcdFx0ZWxzZSByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24oa2V5KSB7IHJldHVybiBtYXBwZXIob2JqW2tleV0sIHBhdGguc2xpY2UoMCkuY29uY2F0KFtrZXldKSkgfSlcclxuXHRcdH1cclxuXHRcdHJldHVybiBtYXBwZXIoX3R1cm4ucGF5b2Zmc0ltcGxpY2l0KVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHR1cm47XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBfVHVybiwgVHVybiB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKCcuL3N0YXRlJyk7XHJcblxyXG4vL0hlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgaWRIYW5kbGVyIH0gPSByZXF1aXJlKCcuL2hlbHBlckZ1bmN0aW9ucycpKFwic3RhdGVcIik7XHJcbnZhciB7IGNoYWluZXJHZW5lcmF0b3IgfSA9IHJlcXVpcmUoJy4vaGVscGVyRnVuY3Rpb25zJykoXCJwbGF5YWJsZVwiKTtcclxuXHJcbnZhciB7IFVzZXJIaXN0b3J5IH0gPSByZXF1aXJlKCcuL2hpc3RvcnknKTtcclxuXHJcbi8vIFBsdWdpbnNcclxudmFyIFBsdWdpbk1hbmFnZXIgPSByZXF1aXJlKFwiLi9wbHVnaW4tbWFuYWdlclwiKVxyXG5cclxuLy9CYWNrZW5kIGZvciBQbGF5ZXJcclxuZnVuY3Rpb24gX1BsYXllcihpZCwgeyBuYW1lID0gXCJcIiwgYXNzaWduID0gbnVsbCB9ID0ge30pIHtcclxuXHRsb2coJ3NpbGx5JywgJ0NyZWF0aW5nIGludGVyYWwgcGxheWVyIG9iamVjdC4nKTtcclxuXHJcblx0dGhpcy5pZCA9IGlkXHJcblx0dGhpcy5zY29yZSA9IDBcclxuXHR0aGlzLm5hbWUgPSBuYW1lO1xyXG5cclxuXHR0aGlzLmhpc3RvcnkgPSBbXTtcclxuXHJcblx0aWYgKGFzc2lnbikgdGhpcy5hc3NpZ24oYXNzaWduKTtcclxuXHJcblx0dGhpcy5hbGl2ZSA9IHRydWU7XHJcblx0dGhpcy5hdmFpbGFibGUgPSB0cnVlO1xyXG5cclxuXHRyZWdpc3RyeS5wbGF5ZXJzW2lkXSA9IHRoaXM7XHJcbn1cclxuXHJcblxyXG4vL01ha2UgYSBjb3B5IG9mIHRoZSBwbGF5ZXIsIGluIG9yZGVyIHRvIHRha2UgYSBzbmFwc2hvdC4gLy8vL1RPRE8gdHJ5IHRoaXMgYWdhaW4gc29tZXRpbWUuXHJcbi8qXHJcbl9QbGF5ZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKXtcclxuXHQvL01ha2UgbmV3IGNvcHkuIERvbid0IGtlZXAgbW9yZSB0aGFuIG9uZS5cclxuXHRkZWxldGUgdGhpcy5jb3B5XHJcblxyXG5cdHZhciBjbG9uZSA9IG5ldyBfUGxheWVyKHRoaXMuaWQpO1xyXG5cclxuXHQvL0xvb3AgdGhyb3VnaCBwcm9wZXJ0aWVzIGFuZCBhc3NpZ24gdGhlbS5cclxuXHRmb3IgKHZhciBrZXkgaW4gdGhpcyl7XHJcblx0XHRjbG9uZVtrZXldID0gdGhpc1trZXldO1xyXG5cdH1cclxuXHQvL0RvIG5vdCBhZGQgdG8gcmVnaXN0cnkuIFRoaXMgd2lsbCBrZWVwIGR1cGxpY2F0ZXMgb3V0IG9mIHBvcHVsYXRpb24uXHJcblxyXG5cdC8vRG8gYWRkIHJlZmVyZW5jZSBzbyB3ZSBjYW4gZmluZCBpdCBhZ2Fpbi5cclxuXHR0aGlzLmNvcHkgPSBjbG9uZTtcclxuXHJcblx0cmV0dXJuIGNsb25lO1xyXG59O1xyXG4qL1xyXG5cclxuXHJcbi8vQXNzaWduIHN0cmF0ZWd5IHRvIHBsYXllclxyXG5fUGxheWVyLnByb3RvdHlwZS5hc3NpZ24gPSBmdW5jdGlvbihzdHJhdGVneSwgLi4uYXJncykge1xyXG5cclxuXHQvL1RPRE86IHZlcmlmeSBzdHJhdGVneSB0eXBlXHJcblx0aWYgKHJlZ2lzdHJ5LnN0cmF0ZWdpZXNbc3RyYXRlZ3ldKSB7XHJcblx0XHR0aGlzLnN0cmF0ZWd5ID0gbmV3IHJlZ2lzdHJ5LnN0cmF0ZWdpZXNbc3RyYXRlZ3ldKC4uLmFyZ3MpO1xyXG5cdFx0dGhpcy5zdHJhdGVneS5faWQgPSBzdHJhdGVneVxyXG5cdFx0dGhpcy5zdHJhdGVneS5fYXJncyA9IGFyZ3NcclxuXHR9IGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiU3RyYXRlZ3kgJ1wiICsgc3RyYXRlZ3kgKyBcIicgaXMgbm90IGRlZmluZWRcIik7XHJcbn07XHJcblxyXG5cclxuLy9DYWxsIHN0cmF0ZWd5IHRvIG1ha2UgYSBjaG9pY2VcclxuX1BsYXllci5wcm90b3R5cGUuY2hvb3NlID0gZnVuY3Rpb24ob3B0aW9ucywgaW5mb3JtYXRpb24gPSB7fSkgeyAvL1RPRE86IGNoZWNrIHRoYXQgdGhlcmUncyBhIHN0cmF0ZWd5IGFzc2lnbmVkIGJlZm9yZSB0cnlpbmcgdG8gcGxheVxyXG5cdHZhciBwbGF5ZXIgPSB0aGlzO1xyXG5cdGlmIChwbGF5ZXIuc3RyYXRlZ3kpIHtcclxuXHRcdGxldCByZXN1bHQgPSBwbGF5ZXIuc3RyYXRlZ3kuY2hvb3NlKG9wdGlvbnMsIGluZm9ybWF0aW9uKVxyXG5cdFx0aWYgKHJlc3VsdCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQudG9TdHJpbmcoKSk7XHJcblx0XHQvLyBJZiBubyByZXNwb25zZSwgZ2l2ZSB3YXJuaW5nXHJcblx0XHRlbHNlIGxvZyhcIndhcm5pbmdcIiwgXCJObyByZXNwb25zZSBmcm9tIHBsYXllciBcIiArIHBsYXllci5pZCArIFwiLiBVc2luZyBkZWZhdWx0IG9wdGlvbi5cIilcclxuXHR9XHJcblx0Ly8gSWYgbm8gc3RyYXRlZ3ksIGdpdmUgd2FybmluZ1xyXG5cdGVsc2VcclxuXHRcdGxvZyhcIndhcm5pbmdcIiwgXCJObyBzdHJhdGVneSBhc3NpZ25lZCB0byBwbGF5ZXIgXCIgKyBwbGF5ZXIuaWQgKyBcIi4gVXNpbmcgZGVmYXVsdCBvcHRpb24uXCIpO1xyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbn07XHJcblxyXG5cclxuLy9UYWtlcyBhIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoKSkgY29weSBvZiBfcGxheWVyLiBSZXR1cm5zIGEgY2xlYW5lZCB1cCB2ZXJzaW9uXHJcbl9QbGF5ZXIucHJvdG90eXBlLmluZm9DbGVhbiA9IGZ1bmN0aW9uKGluZm9PYmplY3QpIHtcclxuXHRkZWxldGUgaW5mb09iamVjdC5pbnRlcmZhY2U7XHJcblx0aW5mb09iamVjdC5zdHJhdGVneSA9IGluZm9PYmplY3Quc3RyYXRlZ3kgPyBpbmZvT2JqZWN0LnN0cmF0ZWd5Ll9pZCA6IG51bGw7XHJcblxyXG5cdHJldHVybiBpbmZvT2JqZWN0O1xyXG59O1xyXG5cclxuXHJcbi8vS2lsbCBwbGF5ZXIuIFRPRE86IGFkZCBwbGF5ZXIgdG8gc29tZSBzb3J0IG9mIFwiZGVhZFwiIGxpc3QgdG8gYXZvaWQgYmVpbmcgcGlja2VkIHRvIGRvIHRoaW5ncy5cclxuX1BsYXllci5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuYWxpdmUgPSBmYWxzZTtcclxufTtcclxuXHJcblxyXG5cclxuLy9DbGFzcyB0aGF0IGlzIHRoZSByZWZlcmVuY2UgZm9yIHRoZSB1c2VyIHRvIGhvbGQgb250b1xyXG5mdW5jdGlvbiBwbGF5ZXIoKSB7fVxyXG5cclxuXHJcbi8vRnJvbnRlbmQgZm9yIFBsYXllclxyXG5mdW5jdGlvbiBQbGF5ZXIocGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHBhcmFtZXRlcnMuaWQsIFwicGxheWVyXCIpO1xyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIHBsYXllciBvYmplY3RcclxuXHR2YXIgX3BsYXllciA9IG5ldyBfUGxheWVyKGlkLCBwYXJhbWV0ZXJzKTtcclxuXHJcblxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlclxyXG5cdHZhciBwbGF5ZXJJbnRlcmZhY2UgPSBuZXcgcGxheWVyKCk7IC8vUHJvYmFibHkgYWRkIGZ1bmN0aW9uYWxpdHkgaGVyZVxyXG5cclxuXHQvL1RhZy1iYWNrLiBTdG9yZSB0aGUgZnJvbnQtZW5kIG9iamVjdCBpbiB0aGUgYmFjay1lbmQgb2JqZWN0LCBmb3IgcmV0cmlldmFsXHJcblx0X3BsYXllci5pbnRlcmZhY2UgPSBwbGF5ZXJJbnRlcmZhY2U7XHJcblxyXG5cdHBsYXllckludGVyZmFjZS5hbGl2ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHJlZ2lzdHJ5LnBsYXllcnNbaWRdLmFsaXZlO1xyXG5cdH1cclxuXHJcblx0cGxheWVySW50ZXJmYWNlLmFzc2lnbiA9IGZ1bmN0aW9uKHN0cmF0ZWd5LCAuLi5hcmdzKSB7XHJcblx0XHRyZWdpc3RyeS5wbGF5ZXJzW2lkXS5hc3NpZ24oc3RyYXRlZ3ksIC4uLmFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdHBsYXllckludGVyZmFjZS5hdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiByZWdpc3RyeS5wbGF5ZXJzW2lkXS5hdmFpbGFibGVcclxuXHR9O1xyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2UuYnVzeSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmVnaXN0cnkucGxheWVyc1tpZF0uYXZhaWxhYmxlID0gZmFsc2U7XHJcblx0fTtcclxuXHJcblx0cGxheWVySW50ZXJmYWNlLmhpc3RvcnkgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBuZXcgVXNlckhpc3RvcnkocmVnaXN0cnkucGxheWVyc1tpZF0uaGlzdG9yeSk7XHJcblx0fTtcclxuXHJcblx0cGxheWVySW50ZXJmYWNlLmlkID0gZnVuY3Rpb24oKSB7IHJldHVybiBpZDsgfTtcclxuXHJcblx0cGxheWVySW50ZXJmYWNlLmtpbGwgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJlZ2lzdHJ5LnBsYXllcnNbaWRdLmtpbGwoKTtcclxuXHR9XHJcblxyXG5cdHBsYXllckludGVyZmFjZS5yZWxlYXNlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZWdpc3RyeS5wbGF5ZXJzW2lkXS5hdmFpbGFibGUgPSB0cnVlO1xyXG5cdH07XHJcblxyXG5cdHBsYXllckludGVyZmFjZS5yZXNldFNjb3JlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZWdpc3RyeS5wbGF5ZXJzW2lkXS5zY29yZSA9IDA7XHJcblx0fVxyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2Uuc2NvcmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiByZWdpc3RyeS5wbGF5ZXJzW2lkXS5zY29yZTtcclxuXHR9O1xyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2Uuc3RyYXRlZ3kgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiByZWdpc3RyeS5wbGF5ZXJzW2lkXS5zdHJhdGVneS5faWQ7XHJcblx0fTtcclxuXHJcblx0Ly8gUExVR0lOOiBydW4gYWZ0ZXIgcGxheWVyIGNyZWF0aW9uXHJcblx0UGx1Z2luTWFuYWdlci5ydW4oXCJwbGF5ZXItY3JlYXRlXCIsIF9wbGF5ZXIpXHJcblxyXG5cdHJldHVybiBwbGF5ZXJJbnRlcmZhY2VcclxufVxyXG5cclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IF9QbGF5ZXIsIFBsYXllciB9O1xyXG4iLCIvKipcclxuICpcclxuICogQHR5cGUge3t9fVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEFzeW5jQ3R4KGNhbGxiYWNrKSB7XHJcblx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cdHRoaXMuc3luYyA9IHRydWU7XHJcbn1cclxuXHJcbkFzeW5jQ3R4LnByb3RvdHlwZS5hc3luYyA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuc3luYyA9IGZhbHNlO1xyXG5cdHJldHVybiB0aGlzLmNhbGxiYWNrO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgYW4gQVBJIG1lYW50IHRvIGJlIHVzZWQgb25seSBmcm9tIHN5bmNocm9ub3VzXHJcbiAqIGNhbGxiYWNrcyBpbnRvIGFuIGFzeW5jaHJvbm91cyBsaWtlIGhvb2suXHJcbiAqXHJcbiAqIGl0IHJlcHJlc2VudCBjb250aW51aXR5IGZyb20gdGhlIFwic3luYygpXCIgb3IgXCJ3YXRlcmZhbGwoKVwiXHJcbiAqIHBsdWdpbiBtYW5hZ2VtZW50XHJcbiAqL1xyXG5Bc3luY0N0eC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjYWxsYmFjayA9IHRoaXMuYXN5bmMoKTtcclxuXHRjYWxsYmFjayh0cnVlKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXN5bmNDdHg7IiwiLy8gU3RvbGVuIGxpYmVyYWxseSBhbmQgYnJhemVubHkgZnJvbSBcInBvbGl0ZS1wbHVnaW4tbWFuYWdlclwiLlxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbmNvbnN0IHBsdWdpbkRpcmVjdG9yeVBhdGggPSBcIi4uLy4uL3BsdWdpbnMvXCJcclxuLy8gSGFjayB0byBjb21waWxlIEdsb2IgZmlsZXMgZm9yIGJyb3dzZXJpZnkuIERvbsK0dCBjYWxsIHRoaXMgZnVuY3Rpb24hXHJcbmZ1bmN0aW9uICRfRE9OT1RDQUxMKCkge1xyXG5cdHJlcXVpcmUoJy4uLy4uL3BsdWdpbnMvYmFsYW5jZS1zaGVldC1jb21wbGV4LmpzJyk7cmVxdWlyZSgnLi4vLi4vcGx1Z2lucy9iYWxhbmNlLXNoZWV0LmpzJylcclxufVxyXG5cclxuLyoqXHJcbiAqIFBvbGl0ZSBQbHVnaW4gTWFuYWdlclxyXG4gKiByZWdpc3RlciBhbmQgcnVuIGhvb2tzIGdyYW50aW5nIGV4dGVuZGFiaWxpdHlcclxuICpcclxuICovXHJcblxyXG5cclxuLy8gR2xvYmFsIERlcGVuZGVuY2llc1xyXG52YXIgZnMgPSByZXF1aXJlKCdmcycpLFxyXG5cdHBhdGggPSByZXF1aXJlKCdwYXRoJyksXHJcblx0ZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kJyksXHJcblx0YXN5bmMgPSByZXF1aXJlKCdhc3luYycpLFxyXG5cclxuXHQvLyBMb2NhbCBNb2R1bGVzXHJcblx0QXN5bmNDdHggPSByZXF1aXJlKCcuL2FzeW5jLWN0eCcpLFxyXG5cdFdhdGVyZmFsbEN0eCA9IHJlcXVpcmUoJy4vd2F0ZXJmYWxsLWN0eCcpLFxyXG5cdFBsdWdpbk5hbWVFcnJvciA9IHJlcXVpcmUoJy4vcGx1Z2luLW5hbWUtZXJyb3InKSxcclxuXHRQbHVnaW5DYWxsYmFja0Vycm9yID0gcmVxdWlyZSgnLi9wbHVnaW4tY2FsbGJhY2stZXJyb3InKTtcclxuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuLy8gLS0tW1sgICBDIE8gTiBTIFQgUiBVIEMgVCBPIFIgICBBIE4gRCAgIEwgSSBGIEUgQyBZIEMgTCBFICAgVSBUIEkgTCBJIFQgSSBFIFMgICBdXS0tIC8vXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG5cclxudmFyIFBsdWdpbk1hbmFnZXIgPSB7fSxcclxuXHRwYWNrYWdlcyA9IFtdLFxyXG5cdHBhY2thZ2VOYW1lcyA9IFtdLFxyXG5cdGhvb2tzID0ge30sXHJcblx0c2tpcFByb3BzID0gWydtb2R1bGUnLCAnbmFtZScsICdwcmlvcml0eScsICdhY3RpdmUnLCAnaW5pdCcsICdyZXF1aXJlJywgJ3N0b3AnLCAncHVibGljJywgJ3NldHRpbmdzJ107XHJcblxyXG5cclxuXHJcblBsdWdpbk1hbmFnZXIucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuXHRwYWNrYWdlcyA9IFtdO1xyXG5cdHBhY2thZ2VOYW1lcyA9IFtdO1xyXG5cdGhvb2tzID0ge307XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQXBwbHkgcGFja2FnZSBzb3J0aW5nLFxyXG4gKiByZWdpc3RlciBwYWNrYWdlcyBpbnRvIGhvb2tzLFxyXG4gKiBydW4gcGFja2FnZXMgaW5pdCgpIG1ldGhvZFxyXG4gKi9cclxuUGx1Z2luTWFuYWdlci5zdGFydCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblxyXG5cdHZhciBzZWxmID0gdGhpcyxcclxuXHRcdGluaXRzID0gW107XHJcblxyXG5cdC8vIHNvcnQgYnkgcHJpb3JpdGllc1xyXG5cdHBhY2thZ2VzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0cmV0dXJuIGEucHJpb3JpdHkgPiBiLnByaW9yaXR5O1xyXG5cdH0pO1xyXG5cclxuXHQvLyByZWdpc3RlciBpbml0ICYgaG9va3NcclxuXHQvLyBob29rcyBhcmUgYWxsIGZ1bmN0aW9ucyB3aG8gYXJlIG5vdCBzcGVjaWFsIHByb3BlcnRpZXNcclxuXHQvLyBpZGVudGlmaWVkIGJ5IFwic2tpcFByb3BzXCIgbGlzdFxyXG5cdHBhY2thZ2VzLmZvckVhY2goZnVuY3Rpb24ocGtnKSB7XHJcblx0XHRpZiAocGtnLmluaXQpIHtcclxuXHRcdFx0aW5pdHMucHVzaChwa2cuaW5pdCk7XHJcblx0XHR9XHJcblx0XHRmb3IgKHZhciBwcm9wIGluIHBrZykge1xyXG5cdFx0XHRpZiAoc2tpcFByb3BzLmluZGV4T2YocHJvcCkgPT09IC0xICYmIHR5cGVvZiBwa2dbcHJvcF0gPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdFBsdWdpbk1hbmFnZXIucmVnaXN0ZXJIb29rKHByb3AsIHBrZ1twcm9wXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0Ly8gcnVuIGFsbCBwYWNrYWdlLmluaXQoKSBtZXRob2QgaW4gc2VyaWVzIVxyXG5cdGlmIChpbml0cy5sZW5ndGgpIHtcclxuXHRcdGFzeW5jLmVhY2hTZXJpZXMoaW5pdHMsIGZ1bmN0aW9uKGZuLCBkb25lKSB7XHJcblxyXG5cdFx0XHR2YXIgY29udGV4dCA9IG5ldyBBc3luY0N0eChkb25lKSxcclxuXHRcdFx0XHRyZXN1bHQgPSBmbi5hcHBseShjb250ZXh0KTtcclxuXHJcblx0XHRcdC8vIHN5bmMgZmFsc2Ugc3RvcCBpbml0aWFsaXphdGlvbiBjeWNsZSFcclxuXHRcdFx0aWYgKGNvbnRleHQuc3luYykge1xyXG5cdFx0XHRcdGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHNlbGYpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRkb25lKHJlc3VsdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSwgY2FsbGJhY2suYmluZCh0aGlzKSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGNhbGxiYWNrLmNhbGwoc2VsZik7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG4vLyAtLS1bWyAgIEggTyBPIEsgUyAgIEEgUCBJICAgXV0tLS0gLy9cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblxyXG5QbHVnaW5NYW5hZ2VyLnJlZ2lzdGVySG9vayA9IGZ1bmN0aW9uKGhvb2tOYW1lLCBob29rRm4sIGhvb2tQcmlvcml0eSA9IDEwMCkge1xyXG5cdGhvb2tGbi5wcmlvcml0eSA9IGhvb2tQcmlvcml0eTtcclxuXHJcblx0aWYgKCFob29rc1tob29rTmFtZV0pIHtcclxuXHRcdGhvb2tzW2hvb2tOYW1lXSA9IFtdO1xyXG5cdH1cclxuXHJcblx0aG9va3NbaG9va05hbWVdLnB1c2goaG9va0ZuKTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG5QbHVnaW5NYW5hZ2VyLmlzRW1wdHkgPSBmdW5jdGlvbihob29rTmFtZSkge1xyXG5cdGlmIChob29rc1tob29rTmFtZV0gJiYgaG9va3NbaG9va05hbWVdLmxlbmd0aCkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSdW4gcmVnaXN0ZXJlZCBob29rIGNhbGxiYWNrcyBpbiBzZXJpZXNcclxuICogKGl0IHN1cHBvcnRzIGFzeW5jaHJvbm91cyBjYWxsYmFja3MpXHJcbiAqL1xyXG5QbHVnaW5NYW5hZ2VyLnJ1biA9IGZ1bmN0aW9uKGhvb2tOYW1lLCAuLi5hcmdzKSB7XHJcblxyXG5cdC8vIFVzZSB0aGUgcnVuV2l0aENhbGxiYWNrIGJ1dCB3aXRoIGJsYW5rIGNhbGxiYWNrLlxyXG5cdFBsdWdpbk1hbmFnZXIucnVuV2l0aENhbGxiYWNrKGhvb2tOYW1lLCAuLi5hcmdzLCBmdW5jdGlvbigpIHt9KVxyXG59O1xyXG5cclxuLy8gU2FtZSBhcyBhYm92ZSwgYnV0IHVzZSBsYXN0IGFyZ3VtZW50IGFzIGNhbGxiYWNrXHJcblBsdWdpbk1hbmFnZXIucnVuV2l0aENhbGxiYWNrID0gZnVuY3Rpb24oaG9va05hbWUsIC4uLmFyZ3MpIHtcclxuXHJcblx0Ly8gY29sbGVjdCBob29rTmFtZSBwcm9wZXJ0eVxyXG5cdGlmICghaG9va05hbWUpIHRocm93IG5ldyBQbHVnaW5OYW1lRXJyb3IoJ21pc3NpbmcgcGx1Z2luIG5hbWUhJyk7XHJcblxyXG5cdC8vIG9idGFpbiBhc3luYyBjYWxsYmFja1xyXG5cdGlmICghYXJncy5sZW5ndGggfHwgdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0dGhyb3cgbmV3IFBsdWdpbkNhbGxiYWNrRXJyb3IoJ1snICsgaG9va05hbWUgKyAnXSBtaXNzaW5nIGNhbGxiYWNrIGZvciBhc3luYyBwbHVnaW4hJyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XHJcblx0fVxyXG5cclxuXHJcblx0Ly8gY2hlY2sgZm9yIHNvbWUgY2FsbGJhY2tzIGV4aXN0YW5jZVxyXG5cdC8vIFs/Pz9dIG1heSBnaXZlIG91dCBhbiBleGNlcHRpb24gd2hlbiBubyBjYWxsYmFja3Mgd2VyZSBmb3VuZCFcclxuXHRpZiAoIWhvb2tzW2hvb2tOYW1lXSB8fCAhaG9va3NbaG9va05hbWVdLmxlbmd0aCkge1xyXG5cdFx0Y2FsbGJhY2soZmFsc2UpO1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Ly8gU29ydCBob29rcyBieSBwcmlvcml0eVxyXG5cdGhvb2tzW2hvb2tOYW1lXS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdHJldHVybiBhLnByaW9yaXR5ID4gYi5wcmlvcml0eVxyXG5cdH0pXHJcblxyXG5cdC8vIHJ1biBhc3luYyBxdWVxdWVcclxuXHQvLyBOT1RFOiBhIHN0ZXAgZnVuY3Rpb24gc2hvdWxkIHN0b3AgdGhlIHF1ZXF1ZSBieSBkb25lKHRydWUpXHJcblx0YXN5bmMuZWFjaFNlcmllcyhob29rc1tob29rTmFtZV0sIGZ1bmN0aW9uKGZuLCBkb25lKSB7XHJcblx0XHR2YXIgY29udGV4dCA9IG5ldyBBc3luY0N0eChkb25lKSxcclxuXHRcdFx0cmVzdWx0ID0gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblxyXG5cdFx0aWYgKGNvbnRleHQuc3luYykge1xyXG5cdFx0XHRpZiAocmVzdWx0ID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZG9uZShyZXN1bHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSwgY2FsbGJhY2spO1xyXG5cclxuXHRyZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJ1biByZWdpc3RlcmVkIGhvb2sgY2FsbGJhY2tzIGluIHBhcmFsbGVsXHJcbiAqIChpdCBzdXBwb3J0cyBhc3luY2hyb25vdXMgY2FsbGJhY2tzKVxyXG4gKiBAcGFyYW0gaG9va05hbWVcclxuICovXHJcblxyXG5QbHVnaW5NYW5hZ2VyLnBhcmFsbGVsID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHZhciBob29rTmFtZSA9ICcnLFxyXG5cdFx0Y2FsbGJhY2sgPSBudWxsLFxyXG5cdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcblxyXG5cdC8vIGNvbGxlY3QgaG9va05hbWUgcHJvcGVydHlcclxuXHRpZiAoIWFyZ3MubGVuZ3RoKSB7XHJcblx0XHR0aHJvdyBuZXcgUGx1Z2luTmFtZUVycm9yKCdtaXNzaW5nIHBsdWdpbiBuYW1lIScpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRob29rTmFtZSA9IGFyZ3Muc2hpZnQoKTtcclxuXHR9XHJcblxyXG5cdC8vIG9idGFpbiBhc3luYyBjYWxsYmFja1xyXG5cdGlmICghYXJncy5sZW5ndGggfHwgdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0dGhyb3cgbmV3IFBsdWdpbkNhbGxiYWNrRXJyb3IoJ1snICsgaG9va05hbWUgKyAnXSBtaXNzaW5nIGNhbGxiYWNrIGZvciBhc3luYyBwbHVnaW4hJyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGNhbGxiYWNrID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xyXG5cdH1cclxuXHJcblx0Ly8gY2hlY2sgZm9yIHNvbWUgY2FsbGJhY2tzIGV4aXN0YW5jZVxyXG5cdC8vIFs/Pz9dIG1heSBnaXZlIG91dCBhbiBleGNlcHRpb24gd2hlbiBubyBjYWxsYmFja3Mgd2VyZSBmb3VuZCFcclxuXHRpZiAoIWhvb2tzW2hvb2tOYW1lXSB8fCAhaG9va3NbaG9va05hbWVdLmxlbmd0aCkge1xyXG5cdFx0Y2FsbGJhY2soZmFsc2UpO1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Ly8gcnVuIGFzeW5jIGluIHBhcmFsbGVsXHJcblx0Ly8gTk9URTogYSBzdGVwIGZ1bmN0aW9uIHNob3VsZCBzdG9wIHRoZSBxdWVxdWUgYnkgZG9uZSh0cnVlKVxyXG5cdGFzeW5jLmVhY2goaG9va3NbaG9va05hbWVdLCBmdW5jdGlvbihmbiwgZG9uZSkge1xyXG5cdFx0dmFyIGNvbnRleHQgPSBuZXcgQXN5bmNDdHgoZG9uZSksXHJcblx0XHRcdHJlc3VsdCA9IGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG5cclxuXHRcdC8vIGhhbmRsZSBzeW5jIGNhbGxiYWNrc1xyXG5cdFx0aWYgKGNvbnRleHQuc3luYykge1xyXG5cdFx0XHRkb25lKHJlc3VsdCk7XHJcblx0XHR9XHJcblx0fSwgY2FsbGJhY2spO1xyXG5cclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogV0FURVJGQUxMXHJcbiAqIFJ1biBhIGhvb2sgYXMgYSBub3JtYWwgZnVuY3Rpb24gaW4gYSBmdWxseSBzeW5jcm9ub3VzIG1vZGVcclxuICogRWFjaCBob29rRm4gc2hvdWxkIHJldHVybiBhIHZhbHVlIHdobydzIGZvcndhcmQgYXMgZmlyc3QgYXJndW1lbnQgZm9yIHRoZSBuZXh0IG9uZVxyXG4gKiBsYXN0IGhvb2tGbiByZXR1cm4gdmFsdWUgaXMgdGhlIGZpbmFsIG91dHB1dFxyXG4gKi9cclxuUGx1Z2luTWFuYWdlci53YXRlcmZhbGwgPSBmdW5jdGlvbihob29rTmFtZSkge1xyXG5cclxuXHRpZiAoIWhvb2tOYW1lKSB7XHJcblx0XHR0aHJvdyBuZXcgUGx1Z2luTmFtZUVycm9yKCdtaXNzaW5nIHBsdWdpbiBuYW1lIScpO1xyXG5cdH1cclxuXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG5cdGFyZ3Muc2hpZnQoKTtcclxuXHJcblx0aWYgKGhvb2tzW2hvb2tOYW1lXSkge1xyXG5cdFx0Ly8gdXNlIGtub3duIGV4Y2VwdGlvbiB0byBleGl0IGZvckVhY2ggY3ljbGUgaW1wbGVtZW50aW5nIGEgc3RvcHBhYmxlIHdhdGVmYWxsXHJcblx0XHQvLyAoaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNjQxMzQ3L2hvdy10by1zaG9ydC1jaXJjdWl0LWFycmF5LWZvcmVhY2gtbGlrZS1jYWxsaW5nLWJyZWFrP2Fuc3dlcnRhYj12b3RlcyN0YWItdG9wKVxyXG5cdFx0dmFyIFdhdGVyZmFsbEJyZWFrRXhjZXB0aW9uID0ge307XHJcblx0XHR0cnkge1xyXG5cdFx0XHRob29rc1tob29rTmFtZV0uZm9yRWFjaChmdW5jdGlvbihmbikge1xyXG5cdFx0XHRcdHZhciBjb250ZXh0ID0gbmV3IFdhdGVyZmFsbEN0eCgpLFxyXG5cdFx0XHRcdFx0cmVzdWx0ID0gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblxyXG5cdFx0XHRcdGlmIChhcmdzLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0YXJnc1swXSA9IHJlc3VsdDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjb250ZXh0LnN0b3BwZWQpIHtcclxuXHRcdFx0XHRcdHRocm93IFdhdGVyZmFsbEJyZWFrRXhjZXB0aW9uO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0pO1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRpZiAoZSAhPT0gV2F0ZXJmYWxsQnJlYWtFeGNlcHRpb24pIHRocm93IGU7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAoYXJncy5sZW5ndGgpIHtcclxuXHRcdHJldHVybiBhcmdzWzBdO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcbi8vIC0tLVtbICAgUCBBIEMgSyBBIEcgRSBTICAgQSBQIEkgICBdXS0tLSAvL1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHJcbmZ1bmN0aW9uIGdldFBhY2thZ2VCeU5hbWUobmFtZSkge1xyXG5cdHZhciBsaXN0ID0gcGFja2FnZXMuZmlsdGVyKGZ1bmN0aW9uKHBrZykgeyByZXR1cm4gKHBrZy5uYW1lID09PSBuYW1lKSB9KVxyXG5cdGlmIChsaXN0Lmxlbmd0aCA9PSAxKSByZXR1cm4gbGlzdFswXVxyXG5cdGVsc2UgcmV0dXJuIGxpc3Q7XHJcbn1cclxuXHJcbi8vIFBhY2thZ2UgY2xhc3NcclxuZnVuY3Rpb24gUGFja2FnZShtb2R1bGUsIG5hbWUgPSBudWxsLCBjb250ZXh0ID0gbnVsbCkge1xyXG5cdC8vIEJhc2ljIGFzc2lnbm1lbnQgYW5kIGRlZmF1bHQgdmFsdWVzXHJcblx0T2JqZWN0LmFzc2lnbih0aGlzLCB7XHJcblx0XHRtb2R1bGUsXHJcblx0XHRuYW1lLFxyXG5cdFx0cHJpb3JpdHk6IDEwMCxcclxuXHRcdGFjdGl2ZTogZmFsc2UsXHJcblx0XHRpbml0OiBmdW5jdGlvbigpIHt9LFxyXG5cdFx0cmVxdWlyZTogZnVuY3Rpb24oKSB7fSxcclxuXHRcdHN0b3A6IGZ1bmN0aW9uKCkge30sXHJcblx0XHRzZXR0aW5nczogZnVuY3Rpb24oKSB7fSxcclxuXHRcdHB1YmxpYzoge31cclxuXHR9KVxyXG5cdC8vIFBhY2thZ2UtZGVmaW5lZCB2YWx1ZXMgYW5kIGhvb2tzXHJcblx0T2JqZWN0LmFzc2lnbih0aGlzLCBtb2R1bGUoY29udGV4dCB8fCB7fSkpXHJcblxyXG5cdC8vIGFkZCB0byByZWdpc3RyeVxyXG5cdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHRoZSBzYW1lIG1vZHVsZSBiZWluZyBsb2FkZWQgdHdpY2UsIG9yIGRpZmZlcmVudCBtb2R1bGVzIHdpdGggdGhlIHNhbWUgbmFtZVxyXG5cdGlmIChwYWNrYWdlTmFtZXMuaW5jbHVkZXModGhpcy5uYW1lKSkge1xyXG5cdFx0aWYgKHRoaXMubW9kdWxlID09PSBnZXRQYWNrYWdlQnlOYW1lKHRoaXMubmFtZSkubW9kdWxlKSB7XHJcblx0XHRcdC8vIFNhbWUgbW9kdWxlLiBEbyBub3RoaW5nXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBEaWZmZXJlbnQgbW9kdWxlcyB3aXRoIHNhbWUgbmFtZSwgaGFuZGxlIG5hbWUgY29uZmxpY3QuXHJcblx0XHRcdC8vVE9ETzogZmlndXJlIG91dCBob3cgdG8gaGFuZGxlIG5hbWUgY29uZmxpY3QuXHJcblx0XHR9XHJcblx0fVxyXG5cdC8vIE5vIG5hbWUgY29uZmxpY3QsIGFkZCB0byByZWdpc3RyeVxyXG5cdGVsc2Uge1xyXG5cdFx0cGFja2FnZXMucHVzaCh0aGlzKTtcclxuXHRcdHBhY2thZ2VOYW1lcy5wdXNoKHRoaXMubmFtZSlcclxuXHR9XHJcbn1cclxuXHJcblBhY2thZ2UucHJvdG90eXBlLnJlZ2lzdGVySG9va3MgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgcGtnID0gdGhpcztcclxuXHRmb3IgKHZhciBwcm9wIGluIHBrZykge1xyXG5cdFx0aWYgKHNraXBQcm9wcy5pbmRleE9mKHByb3ApID09PSAtMSAmJiB0eXBlb2YgcGtnW3Byb3BdID09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0UGx1Z2luTWFuYWdlci5yZWdpc3Rlckhvb2socHJvcCwgcGtnW3Byb3BdKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbi8vIENyZWF0ZSBpbnRlcmZhY2UgZm9yIHVzZXIgdG8gaW50ZXJhY3Qgd2l0aCBwYWNrYWdlLlxyXG5mdW5jdGlvbiBQYWNrYWdlSW50ZXJmYWNlKHBrZykge1xyXG5cclxuXHQvLyBNZXJnZSBhbnkgcHVibGljIGl0ZW1zIHNwZWNpZmllZCBieSB0aGUgcGFja2FnZSB3aXRoIHRoaXMgaW50ZXJmYWNlIGZvcm1hdFxyXG5cdHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwa2cucHVibGljLCB7XHJcblx0XHRuYW1lOiBmdW5jdGlvbigpIHsgcmV0dXJuIHBrZy5uYW1lIH0sXHJcblx0XHRwcmlvcml0eTogZnVuY3Rpb24oKSB7IHJldHVybiBwa2cucHJpb3JpdHkgfSxcclxuXHRcdGFjdGl2ZTogZnVuY3Rpb24oKSB7IHJldHVybiBwa2cuYWN0aXZlIH0sXHJcblxyXG5cdFx0aW5pdDogZnVuY3Rpb24oLi4uYXJncykge1xyXG5cdFx0XHRwa2cuaW5pdCguLi5hcmdzKTtcclxuXHRcdFx0cGtnLnJlZ2lzdGVySG9va3MoKTtcclxuXHRcdFx0cGtnLmFjdGl2ZSA9IHRydWU7XHJcblx0XHRcdHJldHVybiBPYmplY3QuYXNzaWduKHRoaXMsIHBrZy5wdWJsaWNJZkFjdGl2ZSk7XHJcblx0XHR9LFxyXG5cdFx0cmVxdWlyZTogZnVuY3Rpb24oLi4uYXJncykge1xyXG5cdFx0XHRpZiAocGtnLmFjdGl2ZSkgcGtnLnJlcXVpcmUoLi4uYXJncyk7XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHBrZy5pbml0KC4uLmFyZ3MpO1xyXG5cdFx0XHRcdHBrZy5yZWdpc3Rlckhvb2tzKCk7XHJcblx0XHRcdFx0T2JqZWN0LmFzc2lnbih0aGlzLCBwa2cucHVibGljSWZBY3RpdmUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHBrZy5hY3RpdmUgPSB0cnVlO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9LFxyXG5cdFx0c3RvcDogZnVuY3Rpb24oLi4uYXJncykge1xyXG5cdFx0XHRpZiAocGtnLmFjdGl2ZSkgcGtnLnN0b3AoLi4uYXJncyk7XHJcblx0XHRcdHBrZy5hY3RpdmUgPSBmYWxzZTtcclxuXHRcdH0sXHJcblx0XHRzZXR0aW5nczogZnVuY3Rpb24oLi4uYXJncykge1xyXG5cdFx0XHRyZXR1cm4gcGtnLnNldHRpbmdzKC4uLmFyZ3MpO1xyXG5cdFx0fVxyXG5cclxuXHR9LCBwa2cuYWN0aXZlID8gcGtnLnB1YmxpY0lmQWN0aXZlIDogbnVsbCk7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBMb2FkIGEgcGx1Z2luIHBhY2thZ2UgYnkgZm9sZGVyIHBhdGhcclxuICogQHBhcmFtIHNvdXJjZUZvbGRlclxyXG4gKi9cclxuUGx1Z2luTWFuYWdlci5wYWNrYWdlID0gZnVuY3Rpb24oc291cmNlLCBjb250ZXh0KSB7XHJcblx0aWYgKHBhY2thZ2VOYW1lcy5pbmNsdWRlcyhzb3VyY2UpKSB7XHJcblx0XHQvLyBBbHJlYWR5IGxvYWRlZCBtb2R1bGUsIGp1c3QgcmV0dXJuIGl0XHJcblx0XHRyZXR1cm4gUGFja2FnZUludGVyZmFjZShnZXRQYWNrYWdlQnlOYW1lKHNvdXJjZSkpXHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBuYW1lID0gcGF0aC5iYXNlbmFtZShzb3VyY2UpLFxyXG5cdFx0XHRtb2R1bGUgPSByZXF1aXJlKHBsdWdpbkRpcmVjdG9yeVBhdGggKyBzb3VyY2UgKyAnLmpzJylcclxuXHJcblx0XHQvLyBvYnRhaW4gcGFja2FnZSBpbmZvcm1hdGlvbnMgYW5kIGFwcGx5IHNvbWUgZGVmYXVsdCB2YWx1ZXNcclxuXHRcdHZhciBwa2cgPSBuZXcgUGFja2FnZShtb2R1bGUsIG5hbWUsIGNvbnRleHQpXHJcblx0XHRyZXR1cm4gUGFja2FnZUludGVyZmFjZShwa2cpXHJcblx0fVxyXG59XHJcblxyXG4vKlxyXG5cdFx0XHRsb2FkOiBmdW5jdGlvbihjYWxsYmFjayA9IGZ1bmN0aW9uKCkge30sIC4uLmluaXRBcmdzKSB7XHJcblx0XHRcdFx0dmFyIHNlbGYgPSBwbSxcclxuXHRcdFx0XHRcdGluaXRzID0gW10sXHJcblxyXG5cclxuXHRcdFx0XHRcdC8vIHJlZ2lzdGVyIGluaXQgJiBob29rc1xyXG5cdFx0XHRcdFx0Ly8gaG9va3MgYXJlIGFsbCBmdW5jdGlvbnMgd2hvIGFyZSBub3Qgc3BlY2lhbCBwcm9wZXJ0aWVzXHJcblx0XHRcdFx0XHQvLyBpZGVudGlmaWVkIGJ5IFwic2tpcFByb3BzXCIgbGlzdFxyXG5cclxuXHRcdFx0XHRcdGlmIChwa2cuaW5pdCkge1xyXG5cdFx0XHRcdFx0XHRpbml0cy5wdXNoKHBrZy5pbml0KTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRcdC8vIHJ1biBhbGwgcGFja2FnZS5pbml0KCkgbWV0aG9kIGluIHNlcmllcyEgLy9FRElUOiB3aWxsIG9ubHkgYmUgdGhlIG9uZVxyXG5cdFx0XHRcdGlmIChpbml0cy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdGFzeW5jLmVhY2hTZXJpZXMoaW5pdHMsIGZ1bmN0aW9uKGZuLCBkb25lKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgY29udGV4dCA9IG5ldyBBc3luY0N0eChkb25lKSxcclxuXHRcdFx0XHRcdFx0XHRyZXN1bHQgPSBmbi5hcHBseShjb250ZXh0LCBpbml0QXJncyk7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBzeW5jIGZhbHNlIHN0b3AgaW5pdGlhbGl6YXRpb24gY3ljbGUhXHJcblx0XHRcdFx0XHRcdGlmIChjb250ZXh0LnN5bmMpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAocmVzdWx0ID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2suY2FsbChzZWxmKTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0ZG9uZShyZXN1bHQpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0sIGNhbGxiYWNrLmJpbmQoc2VsZikpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHNlbGYpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHNlbGY7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cdH07XHJcbiovXHJcblxyXG4vKiogVE9ETzogdGhpcyBkb2Vzbid0IHdvcmsgcmlnaHQgbm93XHJcbiAqIExvYWQgYWxsIHBhY2thZ2VzIGZyb20gYSBnaXZlbiBmb2xkZXIgcGF0aFxyXG4gKiAoc3luY3Jvbm91cylcclxuICovXHJcblBsdWdpbk1hbmFnZXIucmVnaXN0ZXJNYW55ID0gZnVuY3Rpb24oc291cmNlRm9sZGVyLCBjb250ZXh0KSB7XHJcblx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuXHRpZiAoZnMuZXhpc3RzU3luYyhzb3VyY2VGb2xkZXIpKSB7XHJcblx0XHRmcy5yZWFkZGlyU3luYyhzb3VyY2VGb2xkZXIpLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG5cdFx0XHR2YXIgaXRlbVBhdGggPSBzb3VyY2VGb2xkZXIgKyAnLycgKyBpdGVtLFxyXG5cdFx0XHRcdGl0ZW1TdGF0ID0gZnMubHN0YXRTeW5jKGl0ZW1QYXRoKTtcclxuXHJcblx0XHRcdGlmIChpdGVtU3RhdC5pc0RpcmVjdG9yeSgpKSB7XHJcblx0XHRcdFx0c2VsZi5sb2FkUGFja2FnZShpdGVtUGF0aCwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBsdWdpbk1hbmFnZXJcclxuIiwiXHJcbmZ1bmN0aW9uIFBsdWdpbkNhbGxiYWNrRXJyb3IobWVzc2FnZSkge1xyXG5cdHRoaXMubmFtZSA9IFwiUGx1Z2luQ2FsbGJhY2tFcnJvclwiO1xyXG5cdHRoaXMubWVzc2FnZSA9IChtZXNzYWdlIHx8IFwiXCIpO1xyXG59XHJcblxyXG5cclxuUGx1Z2luQ2FsbGJhY2tFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcclxuUGx1Z2luQ2FsbGJhY2tFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbHVnaW5DYWxsYmFja0Vycm9yO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQbHVnaW5DYWxsYmFja0Vycm9yOyIsIlxyXG5mdW5jdGlvbiBQbHVnaW5OYW1lRXJyb3IobWVzc2FnZSkge1xyXG5cdHRoaXMubmFtZSA9IFwiUGx1Z2luTmFtZUVycm9yXCI7XHJcblx0dGhpcy5tZXNzYWdlID0gKG1lc3NhZ2UgfHwgXCJcIik7XHJcbn1cclxuXHJcblxyXG5QbHVnaW5OYW1lRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XHJcblBsdWdpbk5hbWVFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbHVnaW5OYW1lRXJyb3I7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBsdWdpbk5hbWVFcnJvcjsiLCIvKipcclxuICpcclxuICogQHR5cGUge3t9fVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIFdhdGVyZmFsbEN0eCgpIHtcclxuXHR0aGlzLnN0b3BwZWQgPSBmYWxzZTtcclxufVxyXG5cclxuV2F0ZXJmYWxsQ3R4LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5zdG9wcGVkID0gdHJ1ZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV2F0ZXJmYWxsQ3R4OyIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpc0Z1bmN0aW9uLCBpc09iamVjdCB9ID0gcmVxdWlyZShcIi4vaGVscGVyRnVuY3Rpb25zXCIpKFwiZ2VuZXJhbFwiKTtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZShcIi4vc3RhdGVcIik7XHJcblxyXG52YXIgeyBfUGxheWVyIH0gPSByZXF1aXJlKFwiLi9wbGF5ZXJcIik7XHJcblxyXG4vL0NsYXNzIFBsYXllckxpc3QgaXMgYSBsaXN0IG9mIHBsYXllcnMgd2hpY2ggaW5jbHVkZXMgc29tZSBleHRyYSBmdW5jdGlvbmFsaXR5LiBVc2VyUGxheWVyTGlzdCB0YWtlcyBhIHBsYXllckxpc3QgYW5kXHJcbi8vc2FuaXRpemVzIGl0IGZvciB0aGUgdXNlciAoaWUgcmV0dXJucyAuaW50ZXJmYWNlIGZvciBlYWNoIHBsYXllcikuXHJcblxyXG5mdW5jdGlvbiBQbGF5ZXJMaXN0KC4uLmFyZ3MpIHtcclxuXHRpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkgYXJncyA9IGFyZ3NbMF0uc2xpY2UoMCk7XHJcblx0aWYgKGFyZ3MgPT0gXCJhbGxcIikgcmV0dXJuIGdhbWVQb3B1bGF0aW9uKCk7XHJcblxyXG5cdC8vIFdlJ2xsIG5lZWQgdG8gcmV0YWluIHRoZSBvcmlnaW5hbCBhcmd1bWVudHMgaW4gb3JkZXIgdG8gY3JlYXRlIHRoZSBnZW5lcmF0b3JcclxuXHR2YXIgb3JpZ2luYWxBcmdzID0gW11cclxuXHJcblx0Ly8gTG9vcCBvdmVyIHRoZSBhcmd1bWVudHMsIHNhdmUgdGhlIG9yaWdpbmFscywgcGFyc2UgdGhlbSB0byBfcGxheWVyc1xyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRvcmlnaW5hbEFyZ3MucHVzaChhcmdzW2ldKTtcclxuXHRcdGlmIChpc0Z1bmN0aW9uKGFyZ3NbaV0uaWQpKSBhcmdzW2ldID0gcmVnaXN0cnkucGxheWVyc1thcmdzW2ldLmlkKCldO1xyXG5cdFx0ZWxzZSBpZiAodHlwZW9mIGFyZ3NbaV0gPT09ICdzdHJpbmcnKSBhcmdzW2ldID0gcmVnaXN0cnkucGxheWVyc1thcmdzW2ldXVxyXG5cdH1cclxuXHJcblx0T2JqZWN0LnNldFByb3RvdHlwZU9mKGFyZ3MsIFBsYXllckxpc3QucHJvdG90eXBlKTtcclxuXHJcblx0Ly8gcmV0dXJucyB0aGUgc2FtZSBwbGF5ZXJsaXN0LCBidXQgdXBkYXRlZCwgdXNpbmcgdGhlIG9yaWdpbmFsIGFyZ3MuXHJcblx0YXJncy5nZW5lcmF0b3IgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBuZXcgUGxheWVyTGlzdChvcmlnaW5hbEFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdHJldHVybiBhcmdzO1xyXG59XHJcblxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXJyYXkucHJvdG90eXBlKTtcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbGF5ZXJMaXN0O1xyXG5cclxuXHJcbi8vIEFzc2lnbiBhIHN0cmF0ZWd5IGVuIG1hc3NlXHJcblBsYXllckxpc3QucHJvdG90eXBlLmFzc2lnbiA9IGZ1bmN0aW9uKHN0cmF0ZWd5TmFtZSkge1xyXG5cdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHBsYXllci5hc3NpZ24oc3RyYXRlZ3lOYW1lKVxyXG5cdH0pXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcblxyXG4vL1JldHVybiBhIFBsYXllckxpc3QgbWludXMgdGhlIHNwZWNpZmllZCBwbGF5ZXJzLlxyXG4vL0FyZ3VtZW50IGNhbiBiZSBfcGxheWVyLCBpbnRlcmZhY2UsIG9yIGEgcGxheWVyJ3MgaWQuXHJcblBsYXllckxpc3QucHJvdG90eXBlLmV4Y2x1ZGUgPSBmdW5jdGlvbihwbGF5ZXJBcmcpIHtcclxuXHRpZiAoQXJyYXkuaXNBcnJheShwbGF5ZXJBcmcpKVxyXG5cdFx0cmV0dXJuIHBsYXllckFyZy5yZWR1Y2UoZnVuY3Rpb24ocnVubmluZywgaXRlbSkge1xyXG5cdFx0XHRyZXR1cm4gcnVubmluZy5leGNsdWRlKGl0ZW0pO1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdHJldHVybiBuZXcgUGxheWVyTGlzdChcclxuXHRcdHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRpZiAoXHJcblx0XHRcdFx0cGxheWVyQXJnID09PSBwbGF5ZXIgfHxcclxuXHRcdFx0XHRwbGF5ZXJBcmcgPT0gcGxheWVyLmludGVyZmFjZSB8fFxyXG5cdFx0XHRcdHBsYXllckFyZyA9PSBwbGF5ZXIuaWQgfHxcclxuXHRcdFx0XHQoaXNPYmplY3QocGxheWVyQXJnKSAmJiBwbGF5ZXJBcmcuaWQgPT0gcGxheWVyLmlkKVxyXG5cdFx0XHQpXHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRlbHNlIHJldHVybiB0cnVlO1xyXG5cdFx0fSlcclxuXHQpO1xyXG59O1xyXG5cclxuXHJcbi8vIFBsYWNlaG9sZGVyIGZvciBnZW5lcmF0b3IgbWV0aG9kLlxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5nZW5lcmF0b3IgPSBmdW5jdGlvbigpIHtcclxuXHQvLyBUaGlzIHdpbGwgZ2V0IHNoYWRvd2VkIHdoZW4gdGhlIGNvbnN0cnVjdG9yIGlzIGNhbGxlZCwgYnV0IGl0IG5lZWRzIHRvIGJlIGhlcmUgc28gdGhhdCB0aGVcclxuXHQvLyBVc2VyUGxheWVyTGlzdCBhbmQgSW5mb1BsYXllckxpc3QgY29uc3RydWN0b3JzIGNhbiBzZWUgaXQuXHJcbn1cclxuXHJcblxyXG4vL0NyZWF0ZSBhbiBJbmZvUGxheWVyTGlzdCBvdXQgb2YgdGhpcyBQbGF5ZXJMaXN0LiBVc2VmdWwgZm9yIGdldHRpbmcgc3VtbWFyeSB2aWV3LlxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBJbmZvUGxheWVyTGlzdCh0aGlzKTtcclxufTtcclxuXHJcblxyXG4vL1JldHVybiBhcnJheSBvZiBpZHMgb2YgZWFjaCBwbGF5ZXIgaW4gdGhlIGxpc3RcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuaWRzID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0cmV0dXJuIHBsYXllci5pZDtcclxuXHR9KTtcclxufTtcclxuXHJcblxyXG4vL0tpbGwgYWxsIHBsYXllcnMgaW4gdGhlIHBsYXllckxpc3RcclxuUGxheWVyTGlzdC5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHBsYXllci5raWxsKCk7XHJcblx0fSk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5cclxuLy9SZXR1cm5zIHRoZSBzaW5nbGUgcGxheWVyIHdpdGggdGhlIGhpZ2hlc3Qgc2NvcmVcclxuUGxheWVyTGlzdC5wcm90b3R5cGUubGVhZGVyID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIHBsYXllcnMgPSB0aGlzLnNsaWNlKCk7XHJcblxyXG5cdHBsYXllcnMuc29ydChmdW5jdGlvbihhLCBiKSB7XHJcblx0XHRyZXR1cm4gYi5zY29yZSAtIGEuc2NvcmU7XHJcblx0fSk7XHJcblxyXG5cdHBsYXllcnMgPSBwbGF5ZXJzLmZpbHRlcihmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHJldHVybiBwbGF5ZXIuc2NvcmUgPT0gcGxheWVyc1swXS5zY29yZVxyXG5cdH0pXHJcblxyXG5cclxuXHRyZXR1cm4gcGxheWVycy5sZW5ndGggPiAxID8gbmV3IFBsYXllckxpc3QocGxheWVycykgOiBwbGF5ZXJzWzBdO1xyXG59O1xyXG5cclxuXHJcblBsYXllckxpc3QucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRwbGF5ZXIuYXZhaWxhYmxlID0gdHJ1ZTtcclxuXHR9KTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG5cclxuLy9SZXR1cm4gYSBwbGF5ZXJMaXN0IHdpdGggb25seSB0aGUgcGxheWVycyB3aG8gYXJlIGF2YWlsYWJsZVxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5vbmx5QWxpdmUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFBsYXllckxpc3QoXHJcblx0XHR0aGlzLmZpbHRlcihmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0cmV0dXJuIHBsYXllci5hbGl2ZTtcclxuXHRcdH0pXHJcblx0KTtcclxufTtcclxuXHJcblxyXG4vL1JldHVybiBhIHBsYXllckxpc3Qgd2l0aCBvbmx5IHRoZSBwbGF5ZXJzIHdobyBhcmUgYXZhaWxhYmxlXHJcblBsYXllckxpc3QucHJvdG90eXBlLm9ubHlBdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFBsYXllckxpc3QoXHJcblx0XHR0aGlzLmZpbHRlcihmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0cmV0dXJuIHBsYXllci5hdmFpbGFibGU7XHJcblx0XHR9KVxyXG5cdCk7XHJcbn07XHJcblxyXG5cclxuLy9SZXR1cm5zIGFuIGFycmF5IG9mIHNjb3JlcyBvZiBlYWNoIHBsYXllciBpbiB0aGUgbGlzdFxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5zY29yZXMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0gW107XHJcblxyXG5cdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHNjb3Jlcy5wdXNoKHBsYXllci5zY29yZSk7IC8vVXNlIHRoZSBpbnRlcmZhY2UgZnVuY3Rpb24gdG8gYXZvaWQgdXNlcnMgcmUtYXNzaWduaW5nIHRoZSByZWZlcmVuY2VcclxuXHR9KTtcclxuXHRyZXR1cm4gc2NvcmVzO1xyXG59O1xyXG5cclxuXHJcbi8vIFJldHVybnMgYW4gb2JqZWN0IHdoZXJlIGVhY2gga2V5IGlzIGEgc3RyYXRlZ3kgYW5kIGVhY2ggdmFsdWUgaXMgYW4gYXJyYXkgb2YgdGhlIHNjb3JlcyBvZiBwbGF5ZXJzIHdpdGggdGhhdCBzdHJhdGVneS5cclxuLy8gVE9ETzogZmluaXNoIC50b3RhbCgpIG1ldGhvZCwgd2hpY2ggd2lsbCBzdW0gdGhlIGFycmF5cyAoZHVwbGljYXRpbmcgLnNjb3Jlc0J5U3RyYXRlZ3lUb3RhbHMpXHJcblBsYXllckxpc3QucHJvdG90eXBlLnNjb3Jlc0J5U3RyYXRlZ3kgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0ge307XHJcblx0dmFyIGxpc3QgPSB0aGlzO1xyXG5cclxuXHRsaXN0LnN0cmF0ZWdpZXMoKS5tYXAoZnVuY3Rpb24oc3RyYXRlZ3kpIHtcclxuXHRcdHNjb3Jlc1tzdHJhdGVneV0gPSBsaXN0LnVzaW5nU3RyYXRlZ3koc3RyYXRlZ3kpLnNjb3JlcygpO1xyXG5cdH0pO1xyXG5cclxuXHRzY29yZXMudG90YWwgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBzY29yZSA9IHt9O1xyXG5cdFx0dmFyIHNjb3JlcyA9IHRoaXM7XHJcblx0XHRPYmplY3Qua2V5cyhzY29yZXMpLmZvckVhY2goZnVuY3Rpb24oc3RyYXRlZ3kpIHtcclxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoc2NvcmVzW3N0cmF0ZWd5XSkpIHNjb3JlW3N0cmF0ZWd5XSA9IHNjb3Jlc1tzdHJhdGVneV0ucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdFx0XHRyZXR1cm4gYSArIGI7XHJcblx0XHRcdH0sIDApO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gc2NvcmU7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIHNjb3JlcztcclxufTtcclxuXHJcbi8vIFJldHVybnMgYW4gb2JqZWN0IHdoZXJlIGVhY2gga2V5IGlzIGEgc3RyYXRlZ3kgYW5kIGVhY2ggdmFsdWUgaXMgdGhlIHN1bSBvZiBzY29yZXMgb2YgYWxsIHBsYXllcnMgd2l0aCB0aGF0IHZhbHVlXHJcblBsYXllckxpc3QucHJvdG90eXBlLnNjb3Jlc0J5U3RyYXRlZ3lUb3RhbHMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0ge307XHJcblx0dmFyIGxpc3QgPSB0aGlzO1xyXG5cclxuXHRsaXN0LnN0cmF0ZWdpZXMoKS5tYXAoZnVuY3Rpb24oc3RyYXRlZ3kpIHtcclxuXHRcdHNjb3Jlc1tzdHJhdGVneV0gPSBsaXN0XHJcblx0XHRcdC51c2luZ1N0cmF0ZWd5KHN0cmF0ZWd5KVxyXG5cdFx0XHQuc2NvcmVzKClcclxuXHRcdFx0LnJlZHVjZShmdW5jdGlvbihhLCBiKSB7XHJcblx0XHRcdFx0cmV0dXJuIGEgKyBiO1xyXG5cdFx0XHR9LCAwKTtcclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIHNjb3JlcztcclxufTtcclxuXHJcbi8vUmV0dXJucyBhbiBvYmplY3Qgd2hlcmUgdGhlIGtleXMgYXJlIHRoZSBwbGF5ZXIgaWRzIGFuZCB0aGUgdmFsdWVzXHJcbi8vYXJlIHRoZSBwbGF5ZXJzJyBzY29yZVxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5zY29yZXNPYmplY3QgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0ge307XHJcblxyXG5cdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHNjb3Jlc1twbGF5ZXIuaWRdID0gcGxheWVyLnNjb3JlO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gc2NvcmVzO1xyXG59O1xyXG5cclxuLy9NZWFuIG9mIHRoZSBzY29yZXNcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuc2NvcmVzTWVhbiA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBzY29yZXMgPSB0aGlzLnNjb3JlcygpO1xyXG5cclxuXHR2YXIgbWVhbiA9XHJcblx0XHRzY29yZXMucmVkdWNlKGZ1bmN0aW9uKHN1bSwgdmFsdWUpIHtcclxuXHRcdFx0cmV0dXJuIHN1bSArIHZhbHVlO1xyXG5cdFx0fSwgMCkgLyBzY29yZXMubGVuZ3RoO1xyXG5cclxuXHRyZXR1cm4gbWVhbjtcclxufTtcclxuXHJcbi8vQXJyYXkgd2l0aCAyIGVudHJpZXMsIHRoZSBsb3dlc3QgYW5kIGhpZ2hlc3Qgc2NvcmVcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuc2NvcmVzUmFuZ2UgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0gdGhpcy5zY29yZXMoKTtcclxuXHJcblx0c2NvcmVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0cmV0dXJuIGEgLSBiO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gW3Njb3Jlc1swXSwgc2NvcmVzW3Njb3Jlcy5sZW5ndGggLSAxXV07XHJcbn07XHJcblxyXG4vL1RoZSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgdGhlIHNjb3Jlc1xyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5zY29yZXNTdGQgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0gdGhpcy5zY29yZXMoKTtcclxuXHR2YXIgbWVhbiA9IHRoaXMuc2NvcmVzTWVhbigpO1xyXG5cclxuXHR2YXIgdmFyaWFuY2UgPVxyXG5cdFx0c2NvcmVzLnJlZHVjZShmdW5jdGlvbihzdW0sIHZhbHVlKSB7XHJcblx0XHRcdHJldHVybiBzdW0gKyBNYXRoLnBvdyh2YWx1ZSAtIG1lYW4sIDIpO1xyXG5cdFx0fSwgMCkgLyBzY29yZXMubGVuZ3RoO1xyXG5cclxuXHR2YXIgc3RkID0gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcclxuXHJcblx0cmV0dXJuIHN0ZDtcclxufTtcclxuXHJcblxyXG4vL1JldHVybiBhbiBhcnJheSBvZiB0aGUgc3RyYXRlZ3kgb2YgZWFjaCBwbGF5ZXIgaW4gdGhlIGxpc3RcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuc3RyYXRlZ2llcyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHJldHVybiBwbGF5ZXIuc3RyYXRlZ3kgPyBwbGF5ZXIuc3RyYXRlZ3kuX2lkIDogXCJcIjtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vUmV0dXJuIGEgUGxheWVyTGlzdCB3aXRoIG9ubHkgcGxheWVycyB1c2luZyBhIGdpdmVuIHN0cmF0ZWd5XHJcblBsYXllckxpc3QucHJvdG90eXBlLnVzaW5nU3RyYXRlZ3kgPSBmdW5jdGlvbihzdHJhdGVneSkge1xyXG5cdHJldHVybiBuZXcgUGxheWVyTGlzdChcclxuXHRcdHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRpZiAoXHJcblx0XHRcdFx0cGxheWVyLnN0cmF0ZWd5ID09IHN0cmF0ZWd5IHx8XHJcblx0XHRcdFx0cGxheWVyLnN0cmF0ZWd5Ll9pZCA9PSBzdHJhdGVneSB8fFxyXG5cdFx0XHRcdChpc0Z1bmN0aW9uKHN0cmF0ZWd5KSAmJiBwbGF5ZXIuc3RyYXRlZ3kgaW5zdGFuY2VvZiBzdHJhdGVneSlcclxuXHRcdFx0KVxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRlbHNlIHJldHVybiBmYWxzZTtcclxuXHRcdH0pXHJcblx0KTtcclxufTtcclxuXHJcbi8qXHJcblxyXG5UT0RPIGZpZ3VyZSBvdXQgaG93IHRvIG1ha2UgdGhpcyB3b3JrXHJcblxyXG4vL1JldHVybnMgYW4gb2JqZWN0IHdoZXJlIHRoZSBrZXlzIGFyZSBzdHJhdGVneSBuYW1lcyBhbmQgdGhlIHZhbHVlcyBhcmUgYXJyYXlzIG9mIHBsYXllcnMuXHJcbi8vVGhpcyBuZWVkcyB0byBiZSBvdmVycmlkZGVuIG9uIHRoZSBVc2VyUGxheWVyTGlzdCBwcm90b3R5cGUsIGJlY2F1c2UgdGhlIG5vcm1hbCB3cmFwcGVyIGxvZ2ljXHJcbi8vZm9yIFVzZXJQbGF5ZXJMaXN0IGNhbm5vdCBzYW5pdGl6ZSB0aGlzLlxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5ieVN0cmF0ZWd5ID0gZnVuY3Rpb24oKXtcclxuXHR2YXIgbGlzdCA9IHRoaXM7XHJcblx0dmFyIGRhdGEgPSB7fTtcclxuXHJcblx0T2JqZWN0LmtleXMocmVnaXN0cnkuc3RyYXRlZ2llcykuZm9yRWFjaChmdW5jdGlvbihzdHJhdGVneSl7XHJcblx0XHRkYXRhW3N0cmF0ZWd5XSA9IGxpc3QudXNpbmdTdHJhdGVneShzdHJhdGVneSk7XHJcblx0fSk7XHJcblxyXG5cdHJldHVybiBkYXRhO1xyXG59O1xyXG4qL1xyXG5cclxuLy9SZXR1cm5zIGFuIG9iamVjdCB3aGVyZSB0aGUga2V5cyBhcmUgZWFjaCBzdHJhdGVneSBhbmQgdGhlIHZhbHVlc1xyXG4vL2FyZSB0aGUgbnVtYmVyIG9mIHBsYXllcnMgaW4gdGhlIGxpc3Qgd2hvIGFyZSB1c2luZyBpdC5cclxuUGxheWVyTGlzdC5wcm90b3R5cGUuc3RyYXRlZ3lEaXN0cmlidXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgY291bnRzID0ge307XHJcblxyXG5cdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHZhciBzID0gcGxheWVyLnN0cmF0ZWd5Ll9pZDtcclxuXHRcdGNvdW50c1tzXSA9IChjb3VudHNbc10gfHwgMCkgKyAxO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gY291bnRzO1xyXG59O1xyXG5cclxuXHJcblxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5yZXNldFNjb3JlcyA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHBsYXllci5zY29yZSA9IDA7XHJcblx0fSk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vL0FjY2VwdCBhIFBsYXllckxpc3QgYW5kIHJldHVybiBvbmUgc3VpdGFibGUgZm9yIHRoZSB1c2VyLCBvciBjcmVhdGUgYSBwbGF5ZXJsaXN0IGFuZCByZXR1cm4gb25lIHN1aXRhYmxlIGZvciB0aGUgdXNlclxyXG5mdW5jdGlvbiBVc2VyUGxheWVyTGlzdCguLi5wbGF5ZXJMaXN0KSB7XHJcblx0aWYgKEFycmF5LmlzQXJyYXkocGxheWVyTGlzdFswXSkpIHBsYXllckxpc3QgPSBwbGF5ZXJMaXN0WzBdO1xyXG5cclxuXHQvLyBJZiB3ZSd2ZSBnb3QgYSBwbGF5ZXJMaXN0LCByZXR1cm4gdGhlIGludGVyZmFjZSBvZiBlYWNoIHBsYXllclxyXG5cdGlmIChwbGF5ZXJMaXN0IGluc3RhbmNlb2YgUGxheWVyTGlzdCkge1xyXG5cdFx0dmFyIHVzZXJQbGF5ZXJMaXN0ID0gcGxheWVyTGlzdC5tYXAoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdHJldHVybiBwbGF5ZXIuaW50ZXJmYWNlO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cdC8vIElmIG5vdCwgZmlyc3QgY3JlYXRlIGEgcGxheWVyTGlzdCwgdGhlbiBjYWxsIHRoaXMgZnVuY3Rpb24gYWdhaW4gdG8gd3JhcCBpdC5cclxuXHRlbHNlIHJldHVybiBuZXcgVXNlclBsYXllckxpc3QobmV3IFBsYXllckxpc3QocGxheWVyTGlzdCkpO1xyXG5cclxuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YodXNlclBsYXllckxpc3QsIFVzZXJQbGF5ZXJMaXN0LnByb3RvdHlwZSk7XHJcblxyXG5cdC8vQXR0YWNoIG1ldGhvZHMgZnJvbSBQbGF5ZXJMaXN0LCB3cmFwcGVkIGluIGEgZnVuY3Rpb24uIElmIHRob3NlIG1ldGhvZHMgcmV0dXJuIGEgcGxheWVyTGlzdCxcclxuXHQvL3RoZW4gdGhlIGZ1bmN0aW9uIHdpbGwgY29udmVydCB0aGF0IHRvIGEgVXNlclBsYXllckxpc3QuXHJcblx0Zm9yICh2YXIgbWV0aG9kIGluIFBsYXllckxpc3QucHJvdG90eXBlKSB7XHJcblx0XHRpZiAoaXNGdW5jdGlvbihwbGF5ZXJMaXN0W21ldGhvZF0pKSB7XHJcblx0XHRcdGlmIChtZXRob2QgIT0gXCJjb25zdHJ1Y3RvclwiKVxyXG5cdFx0XHRcdHVzZXJQbGF5ZXJMaXN0W21ldGhvZF0gPSAoZnVuY3Rpb24obWV0aG9kKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdHZhciByZXN1bHQgPSBwbGF5ZXJMaXN0W21ldGhvZF0uYXBwbHkocGxheWVyTGlzdCwgYXJndW1lbnRzKTtcclxuXHRcdFx0XHRcdFx0aWYgKHJlc3VsdCBpbnN0YW5jZW9mIFBsYXllckxpc3QpIHJldHVybiBuZXcgVXNlclBsYXllckxpc3QocmVzdWx0KTtcclxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAocmVzdWx0IGluc3RhbmNlb2YgX1BsYXllcikgcmV0dXJuIHJlc3VsdC5pbnRlcmZhY2U7XHJcblx0XHRcdFx0XHRcdGVsc2UgcmV0dXJuIHJlc3VsdDtcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fSkobWV0aG9kKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB1c2VyUGxheWVyTGlzdDtcclxufVxyXG5cclxuVXNlclBsYXllckxpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQbGF5ZXJMaXN0LnByb3RvdHlwZSk7XHJcblVzZXJQbGF5ZXJMaXN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVzZXJQbGF5ZXJMaXN0O1xyXG5cclxuLy9BY2NlcHQgYSBQbGF5ZXJMaXN0IGFuZCByZXR1cm4gb25lIHN1aXRhYmxlIGZvciBhIHN0cmF0ZWd5IGluZm9ybWF0aW9uIHNldC5cclxuZnVuY3Rpb24gSW5mb1BsYXllckxpc3QocGxheWVyTGlzdCkge1xyXG5cdHZhciBpbmZvUGxheWVyTGlzdCA9IHBsYXllckxpc3QubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0cmV0dXJuIHBsYXllci5pbmZvQ2xlYW4oSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwbGF5ZXIpKSk7XHJcblx0fSk7XHJcblxyXG5cdE9iamVjdC5zZXRQcm90b3R5cGVPZihpbmZvUGxheWVyTGlzdCwgSW5mb1BsYXllckxpc3QucHJvdG90eXBlKTtcclxuXHJcblx0Ly9BdHRhY2ggc2VsZWN0ZWQgbWV0aG9kcyBmcm9tIFBsYXllckxpc3QsIHdyYXBwZWQgaW4gYSBmdW5jdGlvbi4gSWYgdGhvc2UgbWV0aG9kcyByZXR1cm4gYSBwbGF5ZXJMaXN0LFxyXG5cdC8vdGhlbiB0aGUgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IHRoYXQgdG8gYW4gSW5mb1BsYXllckxpc3QuXHJcblx0dmFyIG1ldGhvZHNUb0luY2x1ZGUgPSBbXHJcblx0XHRcIm9ubHlBbGl2ZVwiLFxyXG5cdFx0XCJvbmx5QXZhaWxhYmxlXCIsXHJcblx0XHRcImlkc1wiLFxyXG5cdFx0XCJleGNsdWRlXCIsXHJcblx0XHRcImdlbmVyYXRvclwiLFxyXG5cdFx0XCJzdHJhdGVnaWVzXCIsXHJcblx0XHRcInVzaW5nU3RyYXRlZ3lcIixcclxuXHRcdFwic3RyYXRlZ3lEaXN0cmlidXRpb25cIixcclxuXHRcdFwic2NvcmVzXCIsXHJcblx0XHRcInNjb3Jlc09iamVjdFwiLFxyXG5cdFx0XCJzY29yZXNNZWFuXCIsXHJcblx0XHRcInNjb3Jlc1JhbmdlXCIsXHJcblx0XHRcInNjb3Jlc1N0ZFwiLFxyXG5cdFx0XCJsZWFkZXJcIlxyXG5cdF07XHJcblxyXG5cdGZvciAodmFyIG1ldGhvZCBpbiBQbGF5ZXJMaXN0LnByb3RvdHlwZSkge1xyXG5cdFx0aWYgKGlzRnVuY3Rpb24ocGxheWVyTGlzdFttZXRob2RdKSkge1xyXG5cdFx0XHRpZiAobWV0aG9kc1RvSW5jbHVkZS5pbmRleE9mKG1ldGhvZCkgPiAtMSlcclxuXHRcdFx0XHRpbmZvUGxheWVyTGlzdFttZXRob2RdID0gKGZ1bmN0aW9uKG1ldGhvZCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gcGxheWVyTGlzdFttZXRob2RdLmFwcGx5KHBsYXllckxpc3QsIGFyZ3VtZW50cyk7XHJcblx0XHRcdFx0XHRcdGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQbGF5ZXJMaXN0KSByZXR1cm4gbmV3IEluZm9QbGF5ZXJMaXN0KHJlc3VsdCk7XHJcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIF9QbGF5ZXIpXHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC5pbmZvQ2xlYW4oSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXN1bHQpKSk7XHJcblx0XHRcdFx0XHRcdGVsc2UgcmV0dXJuIHJlc3VsdDtcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fSkobWV0aG9kKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBpbmZvUGxheWVyTGlzdDtcclxufVxyXG5cclxuSW5mb1BsYXllckxpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBcnJheS5wcm90b3R5cGUpO1xyXG5JbmZvUGxheWVyTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbmZvUGxheWVyTGlzdDtcclxuXHJcbi8vRXh0cmEgbWV0aG9kIHRvIHJldHVybiBhIHNpbmdsZSBwbGF5ZXIgZnJvbSBhbiBpbmZvUGxheWVyTGlzdFxyXG5JbmZvUGxheWVyTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocGxheWVySUQpIHtcclxuXHRyZXR1cm4gdGhpcy5maW5kKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0cmV0dXJuIHBsYXllci5pZCA9PSBwbGF5ZXJJRDtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vR2VuZXJhdGVzIGEgUGxheWVyTGlzdCBjb250YWluaW5nIGFsbCBwbGF5ZXJzLlxyXG52YXIgZ2FtZVBvcHVsYXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgcG9wdWxhdGlvbiA9IFtdO1xyXG5cclxuXHRmb3IgKHZhciBwbGF5ZXIgaW4gcmVnaXN0cnkucGxheWVycykge1xyXG5cdFx0cG9wdWxhdGlvbi5wdXNoKHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyXSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3IFBsYXllckxpc3QocG9wdWxhdGlvbik7XHJcbn07XHJcblxyXG4vL0RvZXMgdGhlIHNhbWUsIGJ1dCBhIFVzZXJQbGF5ZXJMaXN0XHJcbnZhciBQb3B1bGF0aW9uID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBVc2VyUGxheWVyTGlzdChnYW1lUG9wdWxhdGlvbigpKTtcclxufTtcclxuXHJcbi8vRG9lcyB0aGUgc2FtZSwgYnV0IGFuIEluZm9QbGF5ZXJMaXN0XHJcbnZhciBJbmZvUG9wdWxhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgSW5mb1BsYXllckxpc3QoZ2FtZVBvcHVsYXRpb24oKSk7XHJcbn07XHJcblxyXG4vL0Egc2hvcnQtaGFuZCB0byByZXR1cm4gdG90YWwgcG9wdWxhdGlvbiBzaXplIHdpdGhvdXQgY3JlYXRpbmcgYSBQbGF5ZXJMaXN0XHJcblBvcHVsYXRpb24uc2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBPYmplY3Qua2V5cyhyZWdpc3RyeS5wbGF5ZXJzKS5sZW5ndGg7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHRQbGF5ZXJMaXN0LFxyXG5cdFVzZXJQbGF5ZXJMaXN0LFxyXG5cdEluZm9QbGF5ZXJMaXN0LFxyXG5cdGdhbWVQb3B1bGF0aW9uLFxyXG5cdFBvcHVsYXRpb24sXHJcblx0SW5mb1BvcHVsYXRpb25cclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcclxuXHJcbmxvZyhcImRlYnVnXCIsIFwic3RhdGU6IENyZWF0aW5nIGdhbWUgc3RhdGUgdmFyaWFibGVzLlwiKVxyXG5cclxuXHJcbnZhciByZWdpc3RyeSA9IHt9XHJcbnJlZ2lzdHJ5Ll9hZGRUeXBlXyA9IGZ1bmN0aW9uKHR5cGUpe1x0XHJcblx0cmVnaXN0cnlbdHlwZV0gPSB7fTtcclxuXHRsb2coXCJzaWxseVwiLCBcInN0YXRlOiBhZGRpbmcgcmVnaXN0cnkgZW50cnk6IFwiLCB0eXBlKVxyXG59O1xyXG5cclxuXHJcbnZhciBpZENvdW50ZXJzID0ge31cclxuaWRDb3VudGVycy5fYWRkVHlwZV8gPSBmdW5jdGlvbih0eXBlKXtcclxuXHRpZENvdW50ZXJzW3R5cGVdID0gMFxyXG5cdGxvZyhcInNpbGx5XCIsIFwic3RhdGU6IGFkZGluZyBjb3VudGVyIGVudHJ5OiBcIiwgdHlwZSlcclxufTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtyZWdpc3RyeSwgaWRDb3VudGVyc307IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCBuYXNoTmFtZSA9IFwiLi9jb3JlXCI7IC8vQ2hhbmdlIHRoaXMgd2hlbiBwdWJsaXNoZWQsIHByb2JhYmx5IHRvICduYXNoLWpzJ1xyXG5cclxudmFyIGZzID0gcmVxdWlyZShcImZzXCIpO1xyXG5cclxudmFyIHsgcmVnaXN0ZXJTdHJhdGVneSwgcmVnaXN0ZXJTdHJhdGVneU9iamVjdCB9ID0gcmVxdWlyZSgnLi9zdHJhdGVneScpO1xyXG5cclxuLy9DaGVjayB0byBzZWUgaWYgcGFyc2VkIGV4cHJlc3Npb24gaXMgY2FsbCB0byByZXF1aXJlIG9yIGV2YWxcclxuZnVuY3Rpb24gaXNCYW5uZWRDYWxsKG5vZGUpIHtcclxuXHRyZXR1cm4gKG5vZGUudHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJykgJiZcclxuXHRcdChub2RlLmNhbGxlZS50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicpICYmXHJcblx0XHQobm9kZS5jYWxsZWUub2JqZWN0LnR5cGUgPT09ICdJZGVudGlmaWVyJykgJiZcclxuXHRcdCgobm9kZS5jYWxsZWUub2JqZWN0Lm5hbWUgPT09ICdyZXF1aXJlJykgfHwgKG5vZGUuY2FsbGVlLm9iamVjdC5uYW1lID09PSAnZXZhbCcpKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZUNhbGxzKHNvdXJjZSkge1xyXG5cdGNvbnN0IGVudHJpZXMgPSBbXTtcclxuXHRlc3ByaW1hLnBhcnNlU2NyaXB0KHNvdXJjZSwge30sIGZ1bmN0aW9uKG5vZGUsIG1ldGEpIHtcclxuXHRcdGlmIChpc0Jhbm5lZENhbGwobm9kZSkpIHtcclxuXHRcdFx0ZW50cmllcy5wdXNoKHtcclxuXHRcdFx0XHRzdGFydDogbWV0YS5zdGFydC5vZmZzZXQsXHJcblx0XHRcdFx0ZW5kOiBtZXRhLmVuZC5vZmZzZXRcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fSk7XHJcblx0ZW50cmllcy5zb3J0KChhLCBiKSA9PiB7IHJldHVybiBiLmVuZCAtIGEuZW5kIH0pLmZvckVhY2gobiA9PiB7XHJcblx0XHRzb3VyY2UgPSBzb3VyY2Uuc2xpY2UoMCwgbi5zdGFydCkgKyBcIiBudWxsOyBcIiArIHNvdXJjZS5zbGljZShuLmVuZCk7XHJcblx0fSk7XHJcblx0cmV0dXJuIHNvdXJjZTtcclxufVxyXG5cclxuXHJcblxyXG52YXIgbG9hZFN0cmF0ZWd5ID0gZnVuY3Rpb24oZmlsZXBhdGgsIHRydXN0ZWQgPSBmYWxzZSkge1xyXG5cdHZhciBjb21waWxlciA9IHJlcXVpcmUoJ2V4cHJlc3Npb24tc2FuZGJveCcpO1xyXG5cclxuXHR2YXIgc291cmNlID0gZnMucmVhZEZpbGVTeW5jKGZpbGVwYXRoKTtcclxuXHJcblx0aWYgKCF0cnVzdGVkKSB7XHJcblx0XHR2YXIgb3JpZ2luYWxTb3VyY2UgPSBzb3VyY2U7XHJcblx0XHR2YXIgcGFyc2VkU291cmNlID0gcmVtb3ZlQ2FsbHMoc291cmNlKTtcclxuXHJcblx0XHRpZiAob3JpZ2luYWxTb3VyY2UgIT0gcGFyc2VkU291cmNlKSB0aHJvdyBuZXcgRXJyb3IoXCJTdHJhdGVneSBcIiArIGZpbGVwYXRoICsgXCIgdXNlcyByZXF1aXJlIG9yIGV2YWwuXCIpO1xyXG5cdH1cclxuXHJcblx0c291cmNlID0gXCJcXFwidXNlIHN0cmljdFxcXCI7IFxcbiBcIiArIHNvdXJjZTtcclxuXHRjb21waWxlcihzb3VyY2UpKHsgcmVnaXN0ZXJTdHJhdGVneSwgcmVnaXN0ZXJTdHJhdGVneU9iamVjdCB9KTtcclxuXHJcbn07IC8vVE9ETzogY2hhbmdlIHRoaXMgc28gdGhhdCBzdHJhdGVnaWVzIGNhbid0IHJlcXVpcmUgYW55IG1vZHVsZXMuXHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGxvYWRTdHJhdGVneUZvbGRlcihwYXRoLCB0cnVzdGVkID0gZmFsc2UpIHtcclxuXHR2YXIgZmlsZXMgPSBmcy5yZWFkZGlyU3luYyhwYXRoKTtcclxuXHRmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpIHtcclxuXHRcdHZhciBmaWxlUGF0aCA9IHBhdGggKyAnLycgKyBmaWxlO1xyXG5cdFx0bG9hZFN0cmF0ZWd5KGZpbGVwYXRoKTtcclxuXHR9KTtcclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgbG9hZFN0cmF0ZWd5LCBsb2FkU3RyYXRlZ3lGb2xkZXIgfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcclxuXHJcbi8vSmF2YXNjcmlwdCBjb2RlIHBhcnNlclxyXG52YXIgZXNwcmltYSA9IHJlcXVpcmUoJ2VzcHJpbWEnKTtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZSgnLi9zdGF0ZScpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlkSGFuZGxlciB9ID0gcmVxdWlyZSgnLi9oZWxwZXJGdW5jdGlvbnMnKShcInN0YXRlXCIpO1xyXG5cclxuXHJcblxyXG4vL1VzZXIgaW50ZXJmYWNlIHRvIGRlY2xhcmUgc3RyYXRlZ3kgdHlwZS5cclxuZnVuY3Rpb24gcmVnaXN0ZXJTdHJhdGVneShzdHJhdGVneSwgbmFtZSwgZGVzY3JpcHRpb24gPSBcIk5vIGRlc2NyaXB0aW9uIGdpdmVuLlwiLCBwbGF5ZXJOYW1lID0gXCJcIikge1xyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihuYW1lLCBcInN0cmF0ZWd5XCIpO1xyXG5cclxuXHRpZiAoaWQgIT09IG5hbWUpIHtcclxuXHRcdC8vVGhlcmUgd2FzIGFscmVhZHkgYSBzdHJhdGVneSByZWdpc3RlcmVkIHdpdGggdGhpcyBuYW1lLlxyXG5cdFx0Ly9DaGVjayB0byBzZWUgaWYgaXQncyB0aGUgc2FtZSBzdHJhdGVneSBvciBub3QuXHJcblx0XHRpZiAoIXJlZ2lzdHJ5LnN0cmF0ZWdpZXNbaWRdID09PSBzdHJhdGVneSkge1xyXG5cdFx0XHQvL1RoZXkncmUgZGlmZmVyZW50LCBzbyB3ZSBoYXZlIGEgbmFtZSBjb25mbGljdC5cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiU3RyYXRlZ3kgbmFtZSBjb25mbGljdCB3aXRoIFwiICsgbmFtZSk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gVGhleSdyZSB0aGUgc2FtZSwgZG8gbm90aGluZy5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBObyBuYW1lIGNvbmZsaWN0IGFuZCBzdHJhdGVneSBub3QgbG9hZGVkIHlldC4gQWRkIHRvIHJlZ2lzdHJ5LlxyXG5cdGxvZyhcImRlYnVnXCIsIFwiTG9hZGluZyBzdHJhdGVneSAnXCIgKyBpZCArIFwiJ1wiKVxyXG5cdHN0cmF0ZWd5LnBsYXllck5hbWUgPSBwbGF5ZXJOYW1lO1xyXG5cdHN0cmF0ZWd5LmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XHJcblx0cmVnaXN0cnkuc3RyYXRlZ2llc1tpZF0gPSBzdHJhdGVneTtcclxuXHRyZXR1cm4gbmFtZTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVnaXN0ZXJTdHJhdGVneU9iamVjdChzdHJhdGVneU9iamVjdCkge1xyXG5cdC8vIElmIG11bHRpcGxlIHN0cmF0ZWdpZXMsIHNwbGl0IGludG8gaW5kaXZpZHVhbHNcclxuXHRpZiAoQXJyYXkuaXNBcnJheShzdHJhdGVneU9iamVjdCkpIHJldHVybiBzdHJhdGVneU9iamVjdC5tYXAocmVnaXN0ZXJTdHJhdGVneU9iamVjdClcclxuXHJcblx0cmV0dXJuIHJlZ2lzdGVyU3RyYXRlZ3koc3RyYXRlZ3lPYmplY3Quc3RyYXRlZ3ksIHN0cmF0ZWd5T2JqZWN0Lm5hbWUsIHN0cmF0ZWd5T2JqZWN0LmRlc2NyaXB0aW9uLFxyXG5cdFx0c3RyYXRlZ3lPYmplY3QucGxheWVyTmFtZSlcclxufVxyXG5cclxuLy9TdHJpcCBvdXQgcmVxdWlyZXMgYW5kIHN1Y2hcclxuZnVuY3Rpb24gc2FuaXRpemVTdHJhdGVneShzdHJhdGVneSkge1xyXG5cdC8vIGNvbnNvbGUubG9nKHgpIG9yIGNvbnNvbGVbJ2Vycm9yJ10oeSlcclxuXHRmdW5jdGlvbiBpc1JlcXVpcmVDYWxsKG5vZGUpIHtcclxuXHRcdHJldHVybiAobm9kZS50eXBlID09PSAnQ2FsbEV4cHJlc3Npb24nKSAmJlxyXG5cdFx0XHQobm9kZS5jYWxsZWUudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKSAmJlxyXG5cdFx0XHQobm9kZS5jYWxsZWUub2JqZWN0LnR5cGUgPT09ICdJZGVudGlmaWVyJykgJiZcclxuXHRcdFx0KG5vZGUuY2FsbGVlLm9iamVjdC5uYW1lID09PSAncmVxdWlyZScpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVtb3ZlQ2FsbHMoc291cmNlKSB7XHJcblx0XHRjb25zdCBlbnRyaWVzID0gW107XHJcblx0XHRlc3ByaW1hLnBhcnNlU2NyaXB0KHNvdXJjZSwge30sIGZ1bmN0aW9uKG5vZGUsIG1ldGEpIHtcclxuXHRcdFx0aWYgKGlzUmVxdWlyZUNhbGwobm9kZSkpIHtcclxuXHRcdFx0XHRlbnRyaWVzLnB1c2goe1xyXG5cdFx0XHRcdFx0c3RhcnQ6IG1ldGEuc3RhcnQub2Zmc2V0LFxyXG5cdFx0XHRcdFx0ZW5kOiBtZXRhLmVuZC5vZmZzZXRcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRlbnRyaWVzLnNvcnQoKGEsIGIpID0+IHsgcmV0dXJuIGIuZW5kIC0gYS5lbmQgfSkuZm9yRWFjaChuID0+IHtcclxuXHRcdFx0c291cmNlID0gc291cmNlLnNsaWNlKDAsIG4uc3RhcnQpICsgc291cmNlLnNsaWNlKG4uZW5kKTtcclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIHNvdXJjZTtcclxuXHR9XHJcblxyXG5cdHJlbW92ZUNhbGxzKHN0cmF0ZWd5LnRvU3RyaW5nKCkpO1xyXG5cclxufVxyXG5cclxuLy9SZXR1cm5zIHRvIHRoZSB1c2VyIGFuIGFycmF5IG9mIGFsbCByZWdpc3RlcmVkIHN0cmF0ZWdpZXMuIFRPRE86IGhhdmUgdGhpcyBtaXJyb3IgUGxheWVyTGlzdCwgdG8gcHJvdmlkZSBmdW5jdGlvbmFsaXR5IGxpa2Ugb25seUFsaXZlIGFuZCBzY29yZXNPYmplY3QuXHJcbmZ1bmN0aW9uIFN0cmF0ZWdpZXMoKSB7XHJcblx0dmFyIHN0cmF0ZWdpZXMgPSBbXTtcclxuXHRmb3IgKHZhciBzdHJhdGVneSBpbiByZWdpc3RyeS5zdHJhdGVnaWVzKSBzdHJhdGVnaWVzLnB1c2goc3RyYXRlZ3kpO1xyXG5cdHJldHVybiBzdHJhdGVnaWVzO1xyXG59O1xyXG5cclxuLy8gRmV0Y2ggdGhlIGRlc2NyaXB0aW9ucyBvZiB0aGUgc3RyYXRlZ2llcy5cclxuU3RyYXRlZ2llcy5kZXNjcmlwdGlvbnMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc3RyYXRlZ2llcyA9IHt9O1xyXG5cdGZvciAodmFyIHN0cmF0ZWd5IGluIHJlZ2lzdHJ5LnN0cmF0ZWdpZXMpIHN0cmF0ZWdpZXNbc3RyYXRlZ3ldID0gcmVnaXN0cnkuc3RyYXRlZ2llc1tzdHJhdGVneV0uZGVzY3JpcHRpb247XHJcblx0cmV0dXJuIHN0cmF0ZWdpZXM7XHJcbn1cclxuXHJcblxyXG4vLyBBIGJ1aWx0LWluIGRlYnVnZ2luZyBzdHJhdGVneS4gQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIGxvYWRzIHRoZSBzdHJhdGVneS5cclxuLy8gVGhlIHN0cmF0ZWd5IGp1c3QgY2FsbGVzICdkZWJ1Z2dlcicgd2hlbiBhc2tlZCB0byBjaG9vc2UuXHJcblN0cmF0ZWdpZXMuZGVidWdnZXIgPSBmdW5jdGlvbigpIHtcclxuXHRyZWdpc3RlclN0cmF0ZWd5KGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5jaG9vc2UgPSBmdW5jdGlvbihvcHRpb25zLCBpbmZvcm1hdGlvbikge1xyXG5cdFx0XHRkZWJ1Z2dlcjtcclxuXHRcdH1cclxuXHR9LCBcImRlYnVnZ2VyXCIpXHJcblx0cmV0dXJuIFwiZGVidWdnZXJcIlxyXG59XHJcblxyXG5TdHJhdGVnaWVzLmxvZ2dlciA9IGZ1bmN0aW9uKCkge1xyXG5cdHJlZ2lzdGVyU3RyYXRlZ3koZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLmNob29zZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGluZm9ybWF0aW9uKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiT3B0aW9uczogXCIsIG9wdGlvbnMpO1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIkluZm9ybWF0aW9uOiBcIiwgaW5mb3JtYXRpb24pXHJcblx0XHR9XHJcblx0fSwgXCJsb2dnZXJcIilcclxuXHRyZXR1cm4gXCJsb2dnZXJcIlxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgcmVnaXN0ZXJTdHJhdGVneSwgcmVnaXN0ZXJTdHJhdGVneU9iamVjdCwgU3RyYXRlZ2llcyB9O1xyXG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIC9bXFx1MDAxYlxcdTAwOWJdW1soKSM7P10qKD86WzAtOV17MSw0fSg/OjtbMC05XXswLDR9KSopP1swLTlBLVBSWmNmLW5xcnk9PjxdL2c7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhc3NlbWJsZVN0eWxlcyAoKSB7XG5cdHZhciBzdHlsZXMgPSB7XG5cdFx0bW9kaWZpZXJzOiB7XG5cdFx0XHRyZXNldDogWzAsIDBdLFxuXHRcdFx0Ym9sZDogWzEsIDIyXSwgLy8gMjEgaXNuJ3Qgd2lkZWx5IHN1cHBvcnRlZCBhbmQgMjIgZG9lcyB0aGUgc2FtZSB0aGluZ1xuXHRcdFx0ZGltOiBbMiwgMjJdLFxuXHRcdFx0aXRhbGljOiBbMywgMjNdLFxuXHRcdFx0dW5kZXJsaW5lOiBbNCwgMjRdLFxuXHRcdFx0aW52ZXJzZTogWzcsIDI3XSxcblx0XHRcdGhpZGRlbjogWzgsIDI4XSxcblx0XHRcdHN0cmlrZXRocm91Z2g6IFs5LCAyOV1cblx0XHR9LFxuXHRcdGNvbG9yczoge1xuXHRcdFx0YmxhY2s6IFszMCwgMzldLFxuXHRcdFx0cmVkOiBbMzEsIDM5XSxcblx0XHRcdGdyZWVuOiBbMzIsIDM5XSxcblx0XHRcdHllbGxvdzogWzMzLCAzOV0sXG5cdFx0XHRibHVlOiBbMzQsIDM5XSxcblx0XHRcdG1hZ2VudGE6IFszNSwgMzldLFxuXHRcdFx0Y3lhbjogWzM2LCAzOV0sXG5cdFx0XHR3aGl0ZTogWzM3LCAzOV0sXG5cdFx0XHRncmF5OiBbOTAsIDM5XVxuXHRcdH0sXG5cdFx0YmdDb2xvcnM6IHtcblx0XHRcdGJnQmxhY2s6IFs0MCwgNDldLFxuXHRcdFx0YmdSZWQ6IFs0MSwgNDldLFxuXHRcdFx0YmdHcmVlbjogWzQyLCA0OV0sXG5cdFx0XHRiZ1llbGxvdzogWzQzLCA0OV0sXG5cdFx0XHRiZ0JsdWU6IFs0NCwgNDldLFxuXHRcdFx0YmdNYWdlbnRhOiBbNDUsIDQ5XSxcblx0XHRcdGJnQ3lhbjogWzQ2LCA0OV0sXG5cdFx0XHRiZ1doaXRlOiBbNDcsIDQ5XVxuXHRcdH1cblx0fTtcblxuXHQvLyBmaXggaHVtYW5zXG5cdHN0eWxlcy5jb2xvcnMuZ3JleSA9IHN0eWxlcy5jb2xvcnMuZ3JheTtcblxuXHRPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwTmFtZSkge1xuXHRcdHZhciBncm91cCA9IHN0eWxlc1tncm91cE5hbWVdO1xuXG5cdFx0T2JqZWN0LmtleXMoZ3JvdXApLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xuXHRcdFx0dmFyIHN0eWxlID0gZ3JvdXBbc3R5bGVOYW1lXTtcblxuXHRcdFx0c3R5bGVzW3N0eWxlTmFtZV0gPSBncm91cFtzdHlsZU5hbWVdID0ge1xuXHRcdFx0XHRvcGVuOiAnXFx1MDAxYlsnICsgc3R5bGVbMF0gKyAnbScsXG5cdFx0XHRcdGNsb3NlOiAnXFx1MDAxYlsnICsgc3R5bGVbMV0gKyAnbSdcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCBncm91cE5hbWUsIHtcblx0XHRcdHZhbHVlOiBncm91cCxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdFx0fSk7XG5cdH0pO1xuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsICdleHBvcnRzJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGFzc2VtYmxlU3R5bGVzXG59KTtcbiIsIi8qZ2xvYmFsIHNldEltbWVkaWF0ZTogZmFsc2UsIHNldFRpbWVvdXQ6IGZhbHNlLCBjb25zb2xlOiBmYWxzZSAqL1xuKGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBhc3luYyA9IHt9O1xuXG4gICAgLy8gZ2xvYmFsIG9uIHRoZSBzZXJ2ZXIsIHdpbmRvdyBpbiB0aGUgYnJvd3NlclxuICAgIHZhciByb290LCBwcmV2aW91c19hc3luYztcblxuICAgIHJvb3QgPSB0aGlzO1xuICAgIGlmIChyb290ICE9IG51bGwpIHtcbiAgICAgIHByZXZpb3VzX2FzeW5jID0gcm9vdC5hc3luYztcbiAgICB9XG5cbiAgICBhc3luYy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByb290LmFzeW5jID0gcHJldmlvdXNfYXN5bmM7XG4gICAgICAgIHJldHVybiBhc3luYztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb25seV9vbmNlKGZuKSB7XG4gICAgICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGNhbGxlZCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2sgd2FzIGFscmVhZHkgY2FsbGVkLlwiKTtcbiAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBmbi5hcHBseShyb290LCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8vLyBjcm9zcy1icm93c2VyIGNvbXBhdGlibGl0eSBmdW5jdGlvbnMgLy8vL1xuXG4gICAgdmFyIF9lYWNoID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IpIHtcbiAgICAgICAgaWYgKGFyci5mb3JFYWNoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLmZvckVhY2goaXRlcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihhcnJbaV0sIGksIGFycik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIF9tYXAgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvcikge1xuICAgICAgICBpZiAoYXJyLm1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5tYXAoaXRlcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIF9lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGksIGEpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVyYXRvcih4LCBpLCBhKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuXG4gICAgdmFyIF9yZWR1Y2UgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWVtbykge1xuICAgICAgICBpZiAoYXJyLnJlZHVjZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5yZWR1Y2UoaXRlcmF0b3IsIG1lbW8pO1xuICAgICAgICB9XG4gICAgICAgIF9lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGksIGEpIHtcbiAgICAgICAgICAgIG1lbW8gPSBpdGVyYXRvcihtZW1vLCB4LCBpLCBhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG5cbiAgICB2YXIgX2tleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfTtcblxuICAgIC8vLy8gZXhwb3J0ZWQgYXN5bmMgbW9kdWxlIGZ1bmN0aW9ucyAvLy8vXG5cbiAgICAvLy8vIG5leHRUaWNrIGltcGxlbWVudGF0aW9uIHdpdGggYnJvd3Nlci1jb21wYXRpYmxlIGZhbGxiYWNrIC8vLy9cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8ICEocHJvY2Vzcy5uZXh0VGljaykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGEgZGlyZWN0IGFsaWFzIGZvciBJRTEwIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGFzeW5jLm5leHRUaWNrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBwcm9jZXNzLm5leHRUaWNrO1xuICAgICAgICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAvLyBub3QgYSBkaXJlY3QgYWxpYXMgZm9yIElFMTAgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGFzeW5jLm5leHRUaWNrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMuZWFjaCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAoIWFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBvbmx5X29uY2UoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLmZvckVhY2ggPSBhc3luYy5lYWNoO1xuXG4gICAgYXN5bmMuZWFjaFNlcmllcyA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAoIWFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICAgICAgICB2YXIgaXRlcmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGFycltjb21wbGV0ZWRdLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaXRlcmF0ZSgpO1xuICAgIH07XG4gICAgYXN5bmMuZm9yRWFjaFNlcmllcyA9IGFzeW5jLmVhY2hTZXJpZXM7XG5cbiAgICBhc3luYy5lYWNoTGltaXQgPSBmdW5jdGlvbiAoYXJyLCBsaW1pdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBmbiA9IF9lYWNoTGltaXQobGltaXQpO1xuICAgICAgICBmbi5hcHBseShudWxsLCBbYXJyLCBpdGVyYXRvciwgY2FsbGJhY2tdKTtcbiAgICB9O1xuICAgIGFzeW5jLmZvckVhY2hMaW1pdCA9IGFzeW5jLmVhY2hMaW1pdDtcblxuICAgIHZhciBfZWFjaExpbWl0ID0gZnVuY3Rpb24gKGxpbWl0KSB7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgIGlmICghYXJyLmxlbmd0aCB8fCBsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcbiAgICAgICAgICAgIHZhciBzdGFydGVkID0gMDtcbiAgICAgICAgICAgIHZhciBydW5uaW5nID0gMDtcblxuICAgICAgICAgICAgKGZ1bmN0aW9uIHJlcGxlbmlzaCAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdoaWxlIChydW5uaW5nIDwgbGltaXQgJiYgc3RhcnRlZCA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBydW5uaW5nICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yKGFycltzdGFydGVkIC0gMV0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsZW5pc2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH07XG4gICAgfTtcblxuXG4gICAgdmFyIGRvUGFyYWxsZWwgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBbYXN5bmMuZWFjaF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBkb1BhcmFsbGVsTGltaXQgPSBmdW5jdGlvbihsaW1pdCwgZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBbX2VhY2hMaW1pdChsaW1pdCldLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgZG9TZXJpZXMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBbYXN5bmMuZWFjaFNlcmllc10uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG5cbiAgICB2YXIgX2FzeW5jTWFwID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgYXJyID0gX21hcChhcnIsIGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpLCB2YWx1ZTogeH07XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uIChlcnIsIHYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzW3guaW5kZXhdID0gdjtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMubWFwID0gZG9QYXJhbGxlbChfYXN5bmNNYXApO1xuICAgIGFzeW5jLm1hcFNlcmllcyA9IGRvU2VyaWVzKF9hc3luY01hcCk7XG4gICAgYXN5bmMubWFwTGltaXQgPSBmdW5jdGlvbiAoYXJyLCBsaW1pdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfbWFwTGltaXQobGltaXQpKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgdmFyIF9tYXBMaW1pdCA9IGZ1bmN0aW9uKGxpbWl0KSB7XG4gICAgICAgIHJldHVybiBkb1BhcmFsbGVsTGltaXQobGltaXQsIF9hc3luY01hcCk7XG4gICAgfTtcblxuICAgIC8vIHJlZHVjZSBvbmx5IGhhcyBhIHNlcmllcyB2ZXJzaW9uLCBhcyBkb2luZyByZWR1Y2UgaW4gcGFyYWxsZWwgd29uJ3RcbiAgICAvLyB3b3JrIGluIG1hbnkgc2l0dWF0aW9ucy5cbiAgICBhc3luYy5yZWR1Y2UgPSBmdW5jdGlvbiAoYXJyLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IobWVtbywgeCwgZnVuY3Rpb24gKGVyciwgdikge1xuICAgICAgICAgICAgICAgIG1lbW8gPSB2O1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBtZW1vKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBpbmplY3QgYWxpYXNcbiAgICBhc3luYy5pbmplY3QgPSBhc3luYy5yZWR1Y2U7XG4gICAgLy8gZm9sZGwgYWxpYXNcbiAgICBhc3luYy5mb2xkbCA9IGFzeW5jLnJlZHVjZTtcblxuICAgIGFzeW5jLnJlZHVjZVJpZ2h0ID0gZnVuY3Rpb24gKGFyciwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXZlcnNlZCA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0pLnJldmVyc2UoKTtcbiAgICAgICAgYXN5bmMucmVkdWNlKHJldmVyc2VkLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgLy8gZm9sZHIgYWxpYXNcbiAgICBhc3luYy5mb2xkciA9IGFzeW5jLnJlZHVjZVJpZ2h0O1xuXG4gICAgdmFyIF9maWx0ZXIgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGksIHZhbHVlOiB4fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soX21hcChyZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgICAgICAgICB9KSwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5maWx0ZXIgPSBkb1BhcmFsbGVsKF9maWx0ZXIpO1xuICAgIGFzeW5jLmZpbHRlclNlcmllcyA9IGRvU2VyaWVzKF9maWx0ZXIpO1xuICAgIC8vIHNlbGVjdCBhbGlhc1xuICAgIGFzeW5jLnNlbGVjdCA9IGFzeW5jLmZpbHRlcjtcbiAgICBhc3luYy5zZWxlY3RTZXJpZXMgPSBhc3luYy5maWx0ZXJTZXJpZXM7XG5cbiAgICB2YXIgX3JlamVjdCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soX21hcChyZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgICAgICAgICB9KSwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5yZWplY3QgPSBkb1BhcmFsbGVsKF9yZWplY3QpO1xuICAgIGFzeW5jLnJlamVjdFNlcmllcyA9IGRvU2VyaWVzKF9yZWplY3QpO1xuXG4gICAgdmFyIF9kZXRlY3QgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh4KTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbWFpbl9jYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLmRldGVjdCA9IGRvUGFyYWxsZWwoX2RldGVjdCk7XG4gICAgYXN5bmMuZGV0ZWN0U2VyaWVzID0gZG9TZXJpZXMoX2RldGVjdCk7XG5cbiAgICBhc3luYy5zb21lID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIG1haW5fY2FsbGJhY2spIHtcbiAgICAgICAgYXN5bmMuZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbWFpbl9jYWxsYmFjayhmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gYW55IGFsaWFzXG4gICAgYXN5bmMuYW55ID0gYXN5bmMuc29tZTtcblxuICAgIGFzeW5jLmV2ZXJ5ID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIG1haW5fY2FsbGJhY2spIHtcbiAgICAgICAgYXN5bmMuZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBtYWluX2NhbGxiYWNrKHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGFsbCBhbGlhc1xuICAgIGFzeW5jLmFsbCA9IGFzeW5jLmV2ZXJ5O1xuXG4gICAgYXN5bmMuc29ydEJ5ID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLm1hcChhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKGVyciwgY3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7dmFsdWU6IHgsIGNyaXRlcmlhOiBjcml0ZXJpYX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhLCBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIF9tYXAocmVzdWx0cy5zb3J0KGZuKSwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMuYXV0byA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgdmFyIGtleXMgPSBfa2V5cyh0YXNrcyk7XG4gICAgICAgIGlmICgha2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHRzID0ge307XG5cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICAgICAgICB2YXIgYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy51bnNoaWZ0KGZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0gPT09IGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0YXNrQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfZWFjaChsaXN0ZW5lcnMuc2xpY2UoMCksIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBhZGRMaXN0ZW5lcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX2tleXMocmVzdWx0cykubGVuZ3RoID09PSBrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9lYWNoKGtleXMsIGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9ICh0YXNrc1trXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSA/IFt0YXNrc1trXV06IHRhc2tzW2tdO1xuICAgICAgICAgICAgdmFyIHRhc2tDYWxsYmFjayA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhZmVSZXN1bHRzID0ge307XG4gICAgICAgICAgICAgICAgICAgIF9lYWNoKF9rZXlzKHJlc3VsdHMpLCBmdW5jdGlvbihya2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1tya2V5XSA9IHJlc3VsdHNbcmtleV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgc2FmZVJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9wIHN1YnNlcXVlbnQgZXJyb3JzIGhpdHRpbmcgY2FsbGJhY2sgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUodGFza0NvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJlcXVpcmVzID0gdGFzay5zbGljZSgwLCBNYXRoLmFicyh0YXNrLmxlbmd0aCAtIDEpKSB8fCBbXTtcbiAgICAgICAgICAgIHZhciByZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZHVjZShyZXF1aXJlcywgZnVuY3Rpb24gKGEsIHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChhICYmIHJlc3VsdHMuaGFzT3duUHJvcGVydHkoeCkpO1xuICAgICAgICAgICAgICAgIH0sIHRydWUpICYmICFyZXN1bHRzLmhhc093blByb3BlcnR5KGspO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChyZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgdGFza1t0YXNrLmxlbmd0aCAtIDFdKHRhc2tDYWxsYmFjaywgcmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrW3Rhc2subGVuZ3RoIC0gMV0odGFza0NhbGxiYWNrLCByZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMud2F0ZXJmYWxsID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAodGFza3MuY29uc3RydWN0b3IgIT09IEFycmF5KSB7XG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gd2F0ZXJmYWxsIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJyk7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3cmFwSXRlcmF0b3IgPSBmdW5jdGlvbiAoaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh3cmFwSXRlcmF0b3IobmV4dCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHdyYXBJdGVyYXRvcihhc3luYy5pdGVyYXRvcih0YXNrcykpKCk7XG4gICAgfTtcblxuICAgIHZhciBfcGFyYWxsZWwgPSBmdW5jdGlvbihlYWNoZm4sIHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAodGFza3MuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICBlYWNoZm4ubWFwKHRhc2tzLCBmdW5jdGlvbiAoZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwsIGVyciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0ge307XG4gICAgICAgICAgICBlYWNoZm4uZWFjaChfa2V5cyh0YXNrcyksIGZ1bmN0aW9uIChrLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRhc2tzW2tdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLnBhcmFsbGVsID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBfcGFyYWxsZWwoeyBtYXA6IGFzeW5jLm1hcCwgZWFjaDogYXN5bmMuZWFjaCB9LCB0YXNrcywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5wYXJhbGxlbExpbWl0ID0gZnVuY3Rpb24odGFza3MsIGxpbWl0LCBjYWxsYmFjaykge1xuICAgICAgICBfcGFyYWxsZWwoeyBtYXA6IF9tYXBMaW1pdChsaW1pdCksIGVhY2g6IF9lYWNoTGltaXQobGltaXQpIH0sIHRhc2tzLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnNlcmllcyA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKHRhc2tzLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgYXN5bmMubWFwU2VyaWVzKHRhc2tzLCBmdW5jdGlvbiAoZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwsIGVyciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0ge307XG4gICAgICAgICAgICBhc3luYy5lYWNoU2VyaWVzKF9rZXlzKHRhc2tzKSwgZnVuY3Rpb24gKGssIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGFza3Nba10oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuaXRlcmF0b3IgPSBmdW5jdGlvbiAodGFza3MpIHtcbiAgICAgICAgdmFyIG1ha2VDYWxsYmFjayA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFza3NbaW5kZXhdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmbi5uZXh0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm4ubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGluZGV4IDwgdGFza3MubGVuZ3RoIC0gMSkgPyBtYWtlQ2FsbGJhY2soaW5kZXggKyAxKTogbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtYWtlQ2FsbGJhY2soMCk7XG4gICAgfTtcblxuICAgIGFzeW5jLmFwcGx5ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShcbiAgICAgICAgICAgICAgICBudWxsLCBhcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIF9jb25jYXQgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGZuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2IpIHtcbiAgICAgICAgICAgIGZuKHgsIGZ1bmN0aW9uIChlcnIsIHkpIHtcbiAgICAgICAgICAgICAgICByID0gci5jb25jYXQoeSB8fCBbXSk7XG4gICAgICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLmNvbmNhdCA9IGRvUGFyYWxsZWwoX2NvbmNhdCk7XG4gICAgYXN5bmMuY29uY2F0U2VyaWVzID0gZG9TZXJpZXMoX2NvbmNhdCk7XG5cbiAgICBhc3luYy53aGlsc3QgPSBmdW5jdGlvbiAodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0ZXN0KCkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3luYy53aGlsc3QodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5kb1doaWxzdCA9IGZ1bmN0aW9uIChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRlc3QoKSkge1xuICAgICAgICAgICAgICAgIGFzeW5jLmRvV2hpbHN0KGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMudW50aWwgPSBmdW5jdGlvbiAodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGVzdCgpKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXN5bmMudW50aWwodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5kb1VudGlsID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjaykge1xuICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRlc3QoKSkge1xuICAgICAgICAgICAgICAgIGFzeW5jLmRvVW50aWwoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy5xdWV1ZSA9IGZ1bmN0aW9uICh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG4gICAgICAgIGlmIChjb25jdXJyZW5jeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25jdXJyZW5jeSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX2luc2VydChxLCBkYXRhLCBwb3MsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaWYoZGF0YS5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpIHtcbiAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2VhY2goZGF0YSwgZnVuY3Rpb24odGFzaykge1xuICAgICAgICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHRhc2ssXG4gICAgICAgICAgICAgICAgICBjYWxsYmFjazogdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBudWxsXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgIHEudGFza3MudW5zaGlmdChpdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxLnRhc2tzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAocS5zYXR1cmF0ZWQgJiYgcS50YXNrcy5sZW5ndGggPT09IGNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICAgICAgICBxLnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShxLnByb2Nlc3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdvcmtlcnMgPSAwO1xuICAgICAgICB2YXIgcSA9IHtcbiAgICAgICAgICAgIHRhc2tzOiBbXSxcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5OiBjb25jdXJyZW5jeSxcbiAgICAgICAgICAgIHNhdHVyYXRlZDogbnVsbCxcbiAgICAgICAgICAgIGVtcHR5OiBudWxsLFxuICAgICAgICAgICAgZHJhaW46IG51bGwsXG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgX2luc2VydChxLCBkYXRhLCBmYWxzZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc2hpZnQ6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIHRydWUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtlcnMgPCBxLmNvbmN1cnJlbmN5ICYmIHEudGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXNrID0gcS50YXNrcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocS5lbXB0eSAmJiBxLnRhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcS5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcnMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXJzIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFzay5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suY2FsbGJhY2suYXBwbHkodGFzaywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxLmRyYWluICYmIHEudGFza3MubGVuZ3RoICsgd29ya2VycyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHEucHJvY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2IgPSBvbmx5X29uY2UobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcih0YXNrLmRhdGEsIGNiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHEudGFza3MubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bm5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd29ya2VycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfTtcblxuICAgIGFzeW5jLmNhcmdvID0gZnVuY3Rpb24gKHdvcmtlciwgcGF5bG9hZCkge1xuICAgICAgICB2YXIgd29ya2luZyAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIHRhc2tzICAgICAgID0gW107XG5cbiAgICAgICAgdmFyIGNhcmdvID0ge1xuICAgICAgICAgICAgdGFza3M6IHRhc2tzLFxuICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgIHNhdHVyYXRlZDogbnVsbCxcbiAgICAgICAgICAgIGVtcHR5OiBudWxsLFxuICAgICAgICAgICAgZHJhaW46IG51bGwsXG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZihkYXRhLmNvbnN0cnVjdG9yICE9PSBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfZWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXJnby5zYXR1cmF0ZWQgJiYgdGFza3MubGVuZ3RoID09PSBwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJnby5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShjYXJnby5wcm9jZXNzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiBwcm9jZXNzKCkge1xuICAgICAgICAgICAgICAgIGlmICh3b3JraW5nKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZihjYXJnby5kcmFpbikgY2FyZ28uZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0cyA9IHR5cGVvZiBwYXlsb2FkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGFza3Muc3BsaWNlKDAsIHBheWxvYWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0YXNrcy5zcGxpY2UoMCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZHMgPSBfbWFwKHRzLCBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFzay5kYXRhO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYoY2FyZ28uZW1wdHkpIGNhcmdvLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgd29ya2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgd29ya2VyKGRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgX2VhY2godHMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY2FsbGJhY2suYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFza3MubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bm5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd29ya2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhcmdvO1xuICAgIH07XG5cbiAgICB2YXIgX2NvbnNvbGVfZm4gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChbZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnNvbGVbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lYWNoKGFyZ3MsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZVtuYW1lXSh4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGFzeW5jLmxvZyA9IF9jb25zb2xlX2ZuKCdsb2cnKTtcbiAgICBhc3luYy5kaXIgPSBfY29uc29sZV9mbignZGlyJyk7XG4gICAgLyphc3luYy5pbmZvID0gX2NvbnNvbGVfZm4oJ2luZm8nKTtcbiAgICBhc3luYy53YXJuID0gX2NvbnNvbGVfZm4oJ3dhcm4nKTtcbiAgICBhc3luYy5lcnJvciA9IF9jb25zb2xlX2ZuKCdlcnJvcicpOyovXG5cbiAgICBhc3luYy5tZW1vaXplID0gZnVuY3Rpb24gKGZuLCBoYXNoZXIpIHtcbiAgICAgICAgdmFyIG1lbW8gPSB7fTtcbiAgICAgICAgdmFyIHF1ZXVlcyA9IHt9O1xuICAgICAgICBoYXNoZXIgPSBoYXNoZXIgfHwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgdmFyIGtleSA9IGhhc2hlci5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gbWVtbykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIG1lbW9ba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgaW4gcXVldWVzKSB7XG4gICAgICAgICAgICAgICAgcXVldWVzW2tleV0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWV1ZXNba2V5XSA9IFtjYWxsYmFja107XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtb1trZXldID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcXVldWVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBxW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBtZW1vaXplZC5tZW1vID0gbWVtbztcbiAgICAgICAgbWVtb2l6ZWQudW5tZW1vaXplZCA9IGZuO1xuICAgICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfTtcblxuICAgIGFzeW5jLnVubWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChmbi51bm1lbW9pemVkIHx8IGZuKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgYXN5bmMudGltZXMgPSBmdW5jdGlvbiAoY291bnQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgY291bnRlciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ZXIucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN5bmMubWFwKGNvdW50ZXIsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnRpbWVzU2VyaWVzID0gZnVuY3Rpb24gKGNvdW50LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzeW5jLm1hcFNlcmllcyhjb3VudGVyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5jb21wb3NlID0gZnVuY3Rpb24gKC8qIGZ1bmN0aW9ucy4uLiAqLykge1xuICAgICAgICB2YXIgZm5zID0gQXJyYXkucHJvdG90eXBlLnJldmVyc2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIGFzeW5jLnJlZHVjZShmbnMsIGFyZ3MsIGZ1bmN0aW9uIChuZXdhcmdzLCBmbiwgY2IpIHtcbiAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBuZXdhcmdzLmNvbmNhdChbZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICBjYihlcnIsIG5leHRhcmdzKTtcbiAgICAgICAgICAgICAgICB9XSkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoYXQsIFtlcnJdLmNvbmNhdChyZXN1bHRzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIF9hcHBseUVhY2ggPSBmdW5jdGlvbiAoZWFjaGZuLCBmbnMgLyphcmdzLi4uKi8pIHtcbiAgICAgICAgdmFyIGdvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiBlYWNoZm4oZm5zLCBmdW5jdGlvbiAoZm4sIGNiKSB7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncy5jb25jYXQoW2NiXSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgICAgICByZXR1cm4gZ28uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ287XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGFzeW5jLmFwcGx5RWFjaCA9IGRvUGFyYWxsZWwoX2FwcGx5RWFjaCk7XG4gICAgYXN5bmMuYXBwbHlFYWNoU2VyaWVzID0gZG9TZXJpZXMoX2FwcGx5RWFjaCk7XG5cbiAgICBhc3luYy5mb3JldmVyID0gZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICBmdW5jdGlvbiBuZXh0KGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4obmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgIH07XG5cbiAgICAvLyBBTUQgLyBSZXF1aXJlSlNcbiAgICBpZiAodHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3luYztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIE5vZGUuanNcbiAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGFzeW5jO1xuICAgIH1cbiAgICAvLyBpbmNsdWRlZCBkaXJlY3RseSB2aWEgPHNjcmlwdD4gdGFnXG4gICAgZWxzZSB7XG4gICAgICAgIHJvb3QuYXN5bmMgPSBhc3luYztcbiAgICB9XG5cbn0oKSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZXNjYXBlU3RyaW5nUmVnZXhwID0gcmVxdWlyZSgnZXNjYXBlLXN0cmluZy1yZWdleHAnKTtcbnZhciBhbnNpU3R5bGVzID0gcmVxdWlyZSgnYW5zaS1zdHlsZXMnKTtcbnZhciBzdHJpcEFuc2kgPSByZXF1aXJlKCdzdHJpcC1hbnNpJyk7XG52YXIgaGFzQW5zaSA9IHJlcXVpcmUoJ2hhcy1hbnNpJyk7XG52YXIgc3VwcG9ydHNDb2xvciA9IHJlcXVpcmUoJ3N1cHBvcnRzLWNvbG9yJyk7XG52YXIgZGVmaW5lUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBpc1NpbXBsZVdpbmRvd3NUZXJtID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyAmJiAhL154dGVybS9pLnRlc3QocHJvY2Vzcy5lbnYuVEVSTSk7XG5cbmZ1bmN0aW9uIENoYWxrKG9wdGlvbnMpIHtcblx0Ly8gZGV0ZWN0IG1vZGUgaWYgbm90IHNldCBtYW51YWxseVxuXHR0aGlzLmVuYWJsZWQgPSAhb3B0aW9ucyB8fCBvcHRpb25zLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHN1cHBvcnRzQ29sb3IgOiBvcHRpb25zLmVuYWJsZWQ7XG59XG5cbi8vIHVzZSBicmlnaHQgYmx1ZSBvbiBXaW5kb3dzIGFzIHRoZSBub3JtYWwgYmx1ZSBjb2xvciBpcyBpbGxlZ2libGVcbmlmIChpc1NpbXBsZVdpbmRvd3NUZXJtKSB7XG5cdGFuc2lTdHlsZXMuYmx1ZS5vcGVuID0gJ1xcdTAwMWJbOTRtJztcbn1cblxudmFyIHN0eWxlcyA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciByZXQgPSB7fTtcblxuXHRPYmplY3Qua2V5cyhhbnNpU3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRhbnNpU3R5bGVzW2tleV0uY2xvc2VSZSA9IG5ldyBSZWdFeHAoZXNjYXBlU3RyaW5nUmVnZXhwKGFuc2lTdHlsZXNba2V5XS5jbG9zZSksICdnJyk7XG5cblx0XHRyZXRba2V5XSA9IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gYnVpbGQuY2FsbCh0aGlzLCB0aGlzLl9zdHlsZXMuY29uY2F0KGtleSkpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xuXG5cdHJldHVybiByZXQ7XG59KSgpO1xuXG52YXIgcHJvdG8gPSBkZWZpbmVQcm9wcyhmdW5jdGlvbiBjaGFsaygpIHt9LCBzdHlsZXMpO1xuXG5mdW5jdGlvbiBidWlsZChfc3R5bGVzKSB7XG5cdHZhciBidWlsZGVyID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBhcHBseVN0eWxlLmFwcGx5KGJ1aWxkZXIsIGFyZ3VtZW50cyk7XG5cdH07XG5cblx0YnVpbGRlci5fc3R5bGVzID0gX3N0eWxlcztcblx0YnVpbGRlci5lbmFibGVkID0gdGhpcy5lbmFibGVkO1xuXHQvLyBfX3Byb3RvX18gaXMgdXNlZCBiZWNhdXNlIHdlIG11c3QgcmV0dXJuIGEgZnVuY3Rpb24sIGJ1dCB0aGVyZSBpc1xuXHQvLyBubyB3YXkgdG8gY3JlYXRlIGEgZnVuY3Rpb24gd2l0aCBhIGRpZmZlcmVudCBwcm90b3R5cGUuXG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cdGJ1aWxkZXIuX19wcm90b19fID0gcHJvdG87XG5cblx0cmV0dXJuIGJ1aWxkZXI7XG59XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoKSB7XG5cdC8vIHN1cHBvcnQgdmFyYWdzLCBidXQgc2ltcGx5IGNhc3QgdG8gc3RyaW5nIGluIGNhc2UgdGhlcmUncyBvbmx5IG9uZSBhcmdcblx0dmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cdHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG5cdHZhciBzdHIgPSBhcmdzTGVuICE9PSAwICYmIFN0cmluZyhhcmd1bWVudHNbMF0pO1xuXG5cdGlmIChhcmdzTGVuID4gMSkge1xuXHRcdC8vIGRvbid0IHNsaWNlIGBhcmd1bWVudHNgLCBpdCBwcmV2ZW50cyB2OCBvcHRpbWl6YXRpb25zXG5cdFx0Zm9yICh2YXIgYSA9IDE7IGEgPCBhcmdzTGVuOyBhKyspIHtcblx0XHRcdHN0ciArPSAnICcgKyBhcmdzW2FdO1xuXHRcdH1cblx0fVxuXG5cdGlmICghdGhpcy5lbmFibGVkIHx8ICFzdHIpIHtcblx0XHRyZXR1cm4gc3RyO1xuXHR9XG5cblx0dmFyIG5lc3RlZFN0eWxlcyA9IHRoaXMuX3N0eWxlcztcblx0dmFyIGkgPSBuZXN0ZWRTdHlsZXMubGVuZ3RoO1xuXG5cdC8vIFR1cm5zIG91dCB0aGF0IG9uIFdpbmRvd3MgZGltbWVkIGdyYXkgdGV4dCBiZWNvbWVzIGludmlzaWJsZSBpbiBjbWQuZXhlLFxuXHQvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYWxrL2NoYWxrL2lzc3Vlcy81OFxuXHQvLyBJZiB3ZSdyZSBvbiBXaW5kb3dzIGFuZCB3ZSdyZSBkZWFsaW5nIHdpdGggYSBncmF5IGNvbG9yLCB0ZW1wb3JhcmlseSBtYWtlICdkaW0nIGEgbm9vcC5cblx0dmFyIG9yaWdpbmFsRGltID0gYW5zaVN0eWxlcy5kaW0ub3Blbjtcblx0aWYgKGlzU2ltcGxlV2luZG93c1Rlcm0gJiYgKG5lc3RlZFN0eWxlcy5pbmRleE9mKCdncmF5JykgIT09IC0xIHx8IG5lc3RlZFN0eWxlcy5pbmRleE9mKCdncmV5JykgIT09IC0xKSkge1xuXHRcdGFuc2lTdHlsZXMuZGltLm9wZW4gPSAnJztcblx0fVxuXG5cdHdoaWxlIChpLS0pIHtcblx0XHR2YXIgY29kZSA9IGFuc2lTdHlsZXNbbmVzdGVkU3R5bGVzW2ldXTtcblxuXHRcdC8vIFJlcGxhY2UgYW55IGluc3RhbmNlcyBhbHJlYWR5IHByZXNlbnQgd2l0aCBhIHJlLW9wZW5pbmcgY29kZVxuXHRcdC8vIG90aGVyd2lzZSBvbmx5IHRoZSBwYXJ0IG9mIHRoZSBzdHJpbmcgdW50aWwgc2FpZCBjbG9zaW5nIGNvZGVcblx0XHQvLyB3aWxsIGJlIGNvbG9yZWQsIGFuZCB0aGUgcmVzdCB3aWxsIHNpbXBseSBiZSAncGxhaW4nLlxuXHRcdHN0ciA9IGNvZGUub3BlbiArIHN0ci5yZXBsYWNlKGNvZGUuY2xvc2VSZSwgY29kZS5vcGVuKSArIGNvZGUuY2xvc2U7XG5cdH1cblxuXHQvLyBSZXNldCB0aGUgb3JpZ2luYWwgJ2RpbScgaWYgd2UgY2hhbmdlZCBpdCB0byB3b3JrIGFyb3VuZCB0aGUgV2luZG93cyBkaW1tZWQgZ3JheSBpc3N1ZS5cblx0YW5zaVN0eWxlcy5kaW0ub3BlbiA9IG9yaWdpbmFsRGltO1xuXG5cdHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIGluaXQoKSB7XG5cdHZhciByZXQgPSB7fTtcblxuXHRPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXRbbmFtZV0gPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGJ1aWxkLmNhbGwodGhpcywgW25hbWVdKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcblxuXHRyZXR1cm4gcmV0O1xufVxuXG5kZWZpbmVQcm9wcyhDaGFsay5wcm90b3R5cGUsIGluaXQoKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IENoYWxrKCk7XG5tb2R1bGUuZXhwb3J0cy5zdHlsZXMgPSBhbnNpU3R5bGVzO1xubW9kdWxlLmV4cG9ydHMuaGFzQ29sb3IgPSBoYXNBbnNpO1xubW9kdWxlLmV4cG9ydHMuc3RyaXBDb2xvciA9IHN0cmlwQW5zaTtcbm1vZHVsZS5leHBvcnRzLnN1cHBvcnRzQ29sb3IgPSBzdXBwb3J0c0NvbG9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFyZ3YgPSBwcm9jZXNzLmFyZ3Y7XG5cbnZhciB0ZXJtaW5hdG9yID0gYXJndi5pbmRleE9mKCctLScpO1xudmFyIGhhc0ZsYWcgPSBmdW5jdGlvbiAoZmxhZykge1xuXHRmbGFnID0gJy0tJyArIGZsYWc7XG5cdHZhciBwb3MgPSBhcmd2LmluZGV4T2YoZmxhZyk7XG5cdHJldHVybiBwb3MgIT09IC0xICYmICh0ZXJtaW5hdG9yICE9PSAtMSA/IHBvcyA8IHRlcm1pbmF0b3IgOiB0cnVlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcblx0aWYgKCdGT1JDRV9DT0xPUicgaW4gcHJvY2Vzcy5lbnYpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmIChoYXNGbGFnKCduby1jb2xvcicpIHx8XG5cdFx0aGFzRmxhZygnbm8tY29sb3JzJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj1mYWxzZScpKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKGhhc0ZsYWcoJ2NvbG9yJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcnMnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPXRydWUnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPWFsd2F5cycpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAocHJvY2Vzcy5zdGRvdXQgJiYgIXByb2Nlc3Muc3Rkb3V0LmlzVFRZKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICgnQ09MT1JURVJNJyBpbiBwcm9jZXNzLmVudikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKHByb2Nlc3MuZW52LlRFUk0gPT09ICdkdW1iJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICgvXnNjcmVlbnxeeHRlcm18XnZ0MTAwfGNvbG9yfGFuc2l8Y3lnd2lufGxpbnV4L2kudGVzdChwcm9jZXNzLmVudi5URVJNKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufSkoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1hdGNoT3BlcmF0b3JzUmUgPSAvW3xcXFxce30oKVtcXF1eJCsqPy5dL2c7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xuXHR9XG5cblx0cmV0dXJuIHN0ci5yZXBsYWNlKG1hdGNoT3BlcmF0b3JzUmUsICdcXFxcJCYnKTtcbn07XG4iLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImVzcHJpbWFcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiZXNwcmltYVwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdC8qXHJcblx0ICBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzLCBodHRwczovL2pzLmZvdW5kYXRpb24vXHJcblxyXG5cdCAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XHJcblx0ICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuXHJcblx0ICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcclxuXHQgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcblx0ICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcclxuXHQgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXHJcblx0ICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuXHJcblx0ICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxyXG5cdCAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxyXG5cdCAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcclxuXHQgIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcclxuXHQgIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXHJcblx0ICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XHJcblx0ICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcclxuXHQgIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXHJcblx0ICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcclxuXHQgIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcblx0Ki9cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIGNvbW1lbnRfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHR2YXIganN4X3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuXHR2YXIgcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG5cdHZhciB0b2tlbml6ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG5cdGZ1bmN0aW9uIHBhcnNlKGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XHJcblx0ICAgIHZhciBjb21tZW50SGFuZGxlciA9IG51bGw7XHJcblx0ICAgIHZhciBwcm94eURlbGVnYXRlID0gZnVuY3Rpb24gKG5vZGUsIG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICBpZiAoZGVsZWdhdGUpIHtcclxuXHQgICAgICAgICAgICBkZWxlZ2F0ZShub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY29tbWVudEhhbmRsZXIpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50SGFuZGxlci52aXNpdChub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIHZhciBwYXJzZXJEZWxlZ2F0ZSA9ICh0eXBlb2YgZGVsZWdhdGUgPT09ICdmdW5jdGlvbicpID8gcHJveHlEZWxlZ2F0ZSA6IG51bGw7XHJcblx0ICAgIHZhciBjb2xsZWN0Q29tbWVudCA9IGZhbHNlO1xyXG5cdCAgICBpZiAob3B0aW9ucykge1xyXG5cdCAgICAgICAgY29sbGVjdENvbW1lbnQgPSAodHlwZW9mIG9wdGlvbnMuY29tbWVudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMuY29tbWVudCk7XHJcblx0ICAgICAgICB2YXIgYXR0YWNoQ29tbWVudCA9ICh0eXBlb2Ygb3B0aW9ucy5hdHRhY2hDb21tZW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5hdHRhY2hDb21tZW50KTtcclxuXHQgICAgICAgIGlmIChjb2xsZWN0Q29tbWVudCB8fCBhdHRhY2hDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudEhhbmRsZXIgPSBuZXcgY29tbWVudF9oYW5kbGVyXzEuQ29tbWVudEhhbmRsZXIoKTtcclxuXHQgICAgICAgICAgICBjb21tZW50SGFuZGxlci5hdHRhY2ggPSBhdHRhY2hDb21tZW50O1xyXG5cdCAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgcGFyc2VyRGVsZWdhdGUgPSBwcm94eURlbGVnYXRlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICAgIHZhciBpc01vZHVsZSA9IGZhbHNlO1xyXG5cdCAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5zb3VyY2VUeXBlID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgaXNNb2R1bGUgPSAob3B0aW9ucy5zb3VyY2VUeXBlID09PSAnbW9kdWxlJyk7XHJcblx0ICAgIH1cclxuXHQgICAgdmFyIHBhcnNlcjtcclxuXHQgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuanN4ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5qc3gpIHtcclxuXHQgICAgICAgIHBhcnNlciA9IG5ldyBqc3hfcGFyc2VyXzEuSlNYUGFyc2VyKGNvZGUsIG9wdGlvbnMsIHBhcnNlckRlbGVnYXRlKTtcclxuXHQgICAgfVxyXG5cdCAgICBlbHNlIHtcclxuXHQgICAgICAgIHBhcnNlciA9IG5ldyBwYXJzZXJfMS5QYXJzZXIoY29kZSwgb3B0aW9ucywgcGFyc2VyRGVsZWdhdGUpO1xyXG5cdCAgICB9XHJcblx0ICAgIHZhciBwcm9ncmFtID0gaXNNb2R1bGUgPyBwYXJzZXIucGFyc2VNb2R1bGUoKSA6IHBhcnNlci5wYXJzZVNjcmlwdCgpO1xyXG5cdCAgICB2YXIgYXN0ID0gcHJvZ3JhbTtcclxuXHQgICAgaWYgKGNvbGxlY3RDb21tZW50ICYmIGNvbW1lbnRIYW5kbGVyKSB7XHJcblx0ICAgICAgICBhc3QuY29tbWVudHMgPSBjb21tZW50SGFuZGxlci5jb21tZW50cztcclxuXHQgICAgfVxyXG5cdCAgICBpZiAocGFyc2VyLmNvbmZpZy50b2tlbnMpIHtcclxuXHQgICAgICAgIGFzdC50b2tlbnMgPSBwYXJzZXIudG9rZW5zO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmIChwYXJzZXIuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICBhc3QuZXJyb3JzID0gcGFyc2VyLmVycm9ySGFuZGxlci5lcnJvcnM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIGFzdDtcclxuXHR9XHJcblx0ZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xyXG5cdGZ1bmN0aW9uIHBhcnNlTW9kdWxlKGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XHJcblx0ICAgIHZhciBwYXJzaW5nT3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0ICAgIHBhcnNpbmdPcHRpb25zLnNvdXJjZVR5cGUgPSAnbW9kdWxlJztcclxuXHQgICAgcmV0dXJuIHBhcnNlKGNvZGUsIHBhcnNpbmdPcHRpb25zLCBkZWxlZ2F0ZSk7XHJcblx0fVxyXG5cdGV4cG9ydHMucGFyc2VNb2R1bGUgPSBwYXJzZU1vZHVsZTtcclxuXHRmdW5jdGlvbiBwYXJzZVNjcmlwdChjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xyXG5cdCAgICB2YXIgcGFyc2luZ09wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdCAgICBwYXJzaW5nT3B0aW9ucy5zb3VyY2VUeXBlID0gJ3NjcmlwdCc7XHJcblx0ICAgIHJldHVybiBwYXJzZShjb2RlLCBwYXJzaW5nT3B0aW9ucywgZGVsZWdhdGUpO1xyXG5cdH1cclxuXHRleHBvcnRzLnBhcnNlU2NyaXB0ID0gcGFyc2VTY3JpcHQ7XHJcblx0ZnVuY3Rpb24gdG9rZW5pemUoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcclxuXHQgICAgdmFyIHRva2VuaXplciA9IG5ldyB0b2tlbml6ZXJfMS5Ub2tlbml6ZXIoY29kZSwgb3B0aW9ucyk7XHJcblx0ICAgIHZhciB0b2tlbnM7XHJcblx0ICAgIHRva2VucyA9IFtdO1xyXG5cdCAgICB0cnkge1xyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbml6ZXIuZ2V0TmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0b2tlbikge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGRlbGVnYXRlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gZGVsZWdhdGUodG9rZW4pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgY2F0Y2ggKGUpIHtcclxuXHQgICAgICAgIHRva2VuaXplci5lcnJvckhhbmRsZXIudG9sZXJhdGUoZSk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHRva2VuaXplci5lcnJvckhhbmRsZXIudG9sZXJhbnQpIHtcclxuXHQgICAgICAgIHRva2Vucy5lcnJvcnMgPSB0b2tlbml6ZXIuZXJyb3JzKCk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIHRva2VucztcclxuXHR9XHJcblx0ZXhwb3J0cy50b2tlbml6ZSA9IHRva2VuaXplO1xyXG5cdHZhciBzeW50YXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblx0ZXhwb3J0cy5TeW50YXggPSBzeW50YXhfMS5TeW50YXg7XHJcblx0Ly8gU3luYyB3aXRoICouanNvbiBtYW5pZmVzdHMuXHJcblx0ZXhwb3J0cy52ZXJzaW9uID0gJzQuMC4wJztcclxuXG5cbi8qKiovIH0sXG4vKiAxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIHN5bnRheF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHR2YXIgQ29tbWVudEhhbmRsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDb21tZW50SGFuZGxlcigpIHtcclxuXHQgICAgICAgIHRoaXMuYXR0YWNoID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICB0aGlzLnN0YWNrID0gW107XHJcblx0ICAgICAgICB0aGlzLmxlYWRpbmcgPSBbXTtcclxuXHQgICAgICAgIHRoaXMudHJhaWxpbmcgPSBbXTtcclxuXHQgICAgfVxyXG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUuaW5zZXJ0SW5uZXJDb21tZW50cyA9IGZ1bmN0aW9uIChub2RlLCBtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgLy8gIGlubm5lckNvbW1lbnRzIGZvciBwcm9wZXJ0aWVzIGVtcHR5IGJsb2NrXHJcblx0ICAgICAgICAvLyAgYGZ1bmN0aW9uIGEoKSB7LyoqIGNvbW1lbnRzICoqXFwvfWBcclxuXHQgICAgICAgIGlmIChub2RlLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5CbG9ja1N0YXRlbWVudCAmJiBub2RlLmJvZHkubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGlubmVyQ29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5sZWFkaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMubGVhZGluZ1tpXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhLmVuZC5vZmZzZXQgPj0gZW50cnkuc3RhcnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlubmVyQ29tbWVudHMudW5zaGlmdChlbnRyeS5jb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubGVhZGluZy5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWlsaW5nLnNwbGljZShpLCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoaW5uZXJDb21tZW50cy5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgbm9kZS5pbm5lckNvbW1lbnRzID0gaW5uZXJDb21tZW50cztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS5maW5kVHJhaWxpbmdDb21tZW50cyA9IGZ1bmN0aW9uIChtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgdmFyIHRyYWlsaW5nQ29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgIGlmICh0aGlzLnRyYWlsaW5nLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cmFpbGluZy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZW50cnlfMSA9IHRoaXMudHJhaWxpbmdbaV07XHJcblx0ICAgICAgICAgICAgICAgIGlmIChlbnRyeV8xLnN0YXJ0ID49IG1ldGFkYXRhLmVuZC5vZmZzZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMudW5zaGlmdChlbnRyeV8xLmNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMudHJhaWxpbmcubGVuZ3RoID0gMDtcclxuXHQgICAgICAgICAgICByZXR1cm4gdHJhaWxpbmdDb21tZW50cztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcclxuXHQgICAgICAgIGlmIChlbnRyeSAmJiBlbnRyeS5ub2RlLnRyYWlsaW5nQ29tbWVudHMpIHtcclxuXHQgICAgICAgICAgICB2YXIgZmlyc3RDb21tZW50ID0gZW50cnkubm9kZS50cmFpbGluZ0NvbW1lbnRzWzBdO1xyXG5cdCAgICAgICAgICAgIGlmIChmaXJzdENvbW1lbnQgJiYgZmlyc3RDb21tZW50LnJhbmdlWzBdID49IG1ldGFkYXRhLmVuZC5vZmZzZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgdHJhaWxpbmdDb21tZW50cyA9IGVudHJ5Lm5vZGUudHJhaWxpbmdDb21tZW50cztcclxuXHQgICAgICAgICAgICAgICAgZGVsZXRlIGVudHJ5Lm5vZGUudHJhaWxpbmdDb21tZW50cztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdHJhaWxpbmdDb21tZW50cztcclxuXHQgICAgfTtcclxuXHQgICAgQ29tbWVudEhhbmRsZXIucHJvdG90eXBlLmZpbmRMZWFkaW5nQ29tbWVudHMgPSBmdW5jdGlvbiAobWV0YWRhdGEpIHtcclxuXHQgICAgICAgIHZhciBsZWFkaW5nQ29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgIHZhciB0YXJnZXQ7XHJcblx0ICAgICAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xyXG5cdCAgICAgICAgICAgIGlmIChlbnRyeSAmJiBlbnRyeS5zdGFydCA+PSBtZXRhZGF0YS5zdGFydC5vZmZzZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgdGFyZ2V0ID0gZW50cnkubm9kZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0YXJnZXQpIHtcclxuXHQgICAgICAgICAgICB2YXIgY291bnQgPSB0YXJnZXQubGVhZGluZ0NvbW1lbnRzID8gdGFyZ2V0LmxlYWRpbmdDb21tZW50cy5sZW5ndGggOiAwO1xyXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSBjb3VudCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gdGFyZ2V0LmxlYWRpbmdDb21tZW50c1tpXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQucmFuZ2VbMV0gPD0gbWV0YWRhdGEuc3RhcnQub2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWFkaW5nQ29tbWVudHMudW5zaGlmdChjb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRhcmdldC5sZWFkaW5nQ29tbWVudHMuc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICh0YXJnZXQubGVhZGluZ0NvbW1lbnRzICYmIHRhcmdldC5sZWFkaW5nQ29tbWVudHMubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXQubGVhZGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICByZXR1cm4gbGVhZGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVhZGluZy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG5cdCAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMubGVhZGluZ1tpXTtcclxuXHQgICAgICAgICAgICBpZiAoZW50cnkuc3RhcnQgPD0gbWV0YWRhdGEuc3RhcnQub2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgIGxlYWRpbmdDb21tZW50cy51bnNoaWZ0KGVudHJ5LmNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmxlYWRpbmcuc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBsZWFkaW5nQ29tbWVudHM7XHJcblx0ICAgIH07XHJcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS52aXNpdE5vZGUgPSBmdW5jdGlvbiAobm9kZSwgbWV0YWRhdGEpIHtcclxuXHQgICAgICAgIGlmIChub2RlLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5Qcm9ncmFtICYmIG5vZGUuYm9keS5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5pbnNlcnRJbm5lckNvbW1lbnRzKG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIHZhciB0cmFpbGluZ0NvbW1lbnRzID0gdGhpcy5maW5kVHJhaWxpbmdDb21tZW50cyhtZXRhZGF0YSk7XHJcblx0ICAgICAgICB2YXIgbGVhZGluZ0NvbW1lbnRzID0gdGhpcy5maW5kTGVhZGluZ0NvbW1lbnRzKG1ldGFkYXRhKTtcclxuXHQgICAgICAgIGlmIChsZWFkaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzID0gbGVhZGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRyYWlsaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgIG5vZGUudHJhaWxpbmdDb21tZW50cyA9IHRyYWlsaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLnN0YWNrLnB1c2goe1xyXG5cdCAgICAgICAgICAgIG5vZGU6IG5vZGUsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IG1ldGFkYXRhLnN0YXJ0Lm9mZnNldFxyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgIH07XHJcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgbWV0YWRhdGEpIHtcclxuXHQgICAgICAgIHZhciB0eXBlID0gKG5vZGUudHlwZVswXSA9PT0gJ0wnKSA/ICdMaW5lJyA6ICdCbG9jayc7XHJcblx0ICAgICAgICB2YXIgY29tbWVudCA9IHtcclxuXHQgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBub2RlLnZhbHVlXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgaWYgKG5vZGUucmFuZ2UpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50LnJhbmdlID0gbm9kZS5yYW5nZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChub2RlLmxvYykge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnQubG9jID0gbm9kZS5sb2M7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbW1lbnRzLnB1c2goY29tbWVudCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5hdHRhY2gpIHtcclxuXHQgICAgICAgICAgICB2YXIgZW50cnkgPSB7XHJcblx0ICAgICAgICAgICAgICAgIGNvbW1lbnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbm9kZS52YWx1ZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBbbWV0YWRhdGEuc3RhcnQub2Zmc2V0LCBtZXRhZGF0YS5lbmQub2Zmc2V0XVxyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogbWV0YWRhdGEuc3RhcnQub2Zmc2V0XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICBpZiAobm9kZS5sb2MpIHtcclxuXHQgICAgICAgICAgICAgICAgZW50cnkuY29tbWVudC5sb2MgPSBub2RlLmxvYztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgbm9kZS50eXBlID0gdHlwZTtcclxuXHQgICAgICAgICAgICB0aGlzLmxlYWRpbmcucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICAgICAgdGhpcy50cmFpbGluZy5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgQ29tbWVudEhhbmRsZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKG5vZGUsIG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICBpZiAobm9kZS50eXBlID09PSAnTGluZUNvbW1lbnQnKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy52aXNpdENvbW1lbnQobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnQmxvY2tDb21tZW50Jykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmlzaXRDb21tZW50KG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMuYXR0YWNoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy52aXNpdE5vZGUobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gQ29tbWVudEhhbmRsZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNvbW1lbnRIYW5kbGVyID0gQ29tbWVudEhhbmRsZXI7XHJcblxuXG4vKioqLyB9LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdGV4cG9ydHMuU3ludGF4ID0ge1xyXG5cdCAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJyxcclxuXHQgICAgQXNzaWdubWVudFBhdHRlcm46ICdBc3NpZ25tZW50UGF0dGVybicsXHJcblx0ICAgIEFycmF5RXhwcmVzc2lvbjogJ0FycmF5RXhwcmVzc2lvbicsXHJcblx0ICAgIEFycmF5UGF0dGVybjogJ0FycmF5UGF0dGVybicsXHJcblx0ICAgIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiAnQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nLFxyXG5cdCAgICBBd2FpdEV4cHJlc3Npb246ICdBd2FpdEV4cHJlc3Npb24nLFxyXG5cdCAgICBCbG9ja1N0YXRlbWVudDogJ0Jsb2NrU3RhdGVtZW50JyxcclxuXHQgICAgQmluYXJ5RXhwcmVzc2lvbjogJ0JpbmFyeUV4cHJlc3Npb24nLFxyXG5cdCAgICBCcmVha1N0YXRlbWVudDogJ0JyZWFrU3RhdGVtZW50JyxcclxuXHQgICAgQ2FsbEV4cHJlc3Npb246ICdDYWxsRXhwcmVzc2lvbicsXHJcblx0ICAgIENhdGNoQ2xhdXNlOiAnQ2F0Y2hDbGF1c2UnLFxyXG5cdCAgICBDbGFzc0JvZHk6ICdDbGFzc0JvZHknLFxyXG5cdCAgICBDbGFzc0RlY2xhcmF0aW9uOiAnQ2xhc3NEZWNsYXJhdGlvbicsXHJcblx0ICAgIENsYXNzRXhwcmVzc2lvbjogJ0NsYXNzRXhwcmVzc2lvbicsXHJcblx0ICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicsXHJcblx0ICAgIENvbnRpbnVlU3RhdGVtZW50OiAnQ29udGludWVTdGF0ZW1lbnQnLFxyXG5cdCAgICBEb1doaWxlU3RhdGVtZW50OiAnRG9XaGlsZVN0YXRlbWVudCcsXHJcblx0ICAgIERlYnVnZ2VyU3RhdGVtZW50OiAnRGVidWdnZXJTdGF0ZW1lbnQnLFxyXG5cdCAgICBFbXB0eVN0YXRlbWVudDogJ0VtcHR5U3RhdGVtZW50JyxcclxuXHQgICAgRXhwb3J0QWxsRGVjbGFyYXRpb246ICdFeHBvcnRBbGxEZWNsYXJhdGlvbicsXHJcblx0ICAgIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjogJ0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbicsXHJcblx0ICAgIEV4cG9ydE5hbWVkRGVjbGFyYXRpb246ICdFeHBvcnROYW1lZERlY2xhcmF0aW9uJyxcclxuXHQgICAgRXhwb3J0U3BlY2lmaWVyOiAnRXhwb3J0U3BlY2lmaWVyJyxcclxuXHQgICAgRXhwcmVzc2lvblN0YXRlbWVudDogJ0V4cHJlc3Npb25TdGF0ZW1lbnQnLFxyXG5cdCAgICBGb3JTdGF0ZW1lbnQ6ICdGb3JTdGF0ZW1lbnQnLFxyXG5cdCAgICBGb3JPZlN0YXRlbWVudDogJ0Zvck9mU3RhdGVtZW50JyxcclxuXHQgICAgRm9ySW5TdGF0ZW1lbnQ6ICdGb3JJblN0YXRlbWVudCcsXHJcblx0ICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246ICdGdW5jdGlvbkRlY2xhcmF0aW9uJyxcclxuXHQgICAgRnVuY3Rpb25FeHByZXNzaW9uOiAnRnVuY3Rpb25FeHByZXNzaW9uJyxcclxuXHQgICAgSWRlbnRpZmllcjogJ0lkZW50aWZpZXInLFxyXG5cdCAgICBJZlN0YXRlbWVudDogJ0lmU3RhdGVtZW50JyxcclxuXHQgICAgSW1wb3J0RGVjbGFyYXRpb246ICdJbXBvcnREZWNsYXJhdGlvbicsXHJcblx0ICAgIEltcG9ydERlZmF1bHRTcGVjaWZpZXI6ICdJbXBvcnREZWZhdWx0U3BlY2lmaWVyJyxcclxuXHQgICAgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyOiAnSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyJyxcclxuXHQgICAgSW1wb3J0U3BlY2lmaWVyOiAnSW1wb3J0U3BlY2lmaWVyJyxcclxuXHQgICAgTGl0ZXJhbDogJ0xpdGVyYWwnLFxyXG5cdCAgICBMYWJlbGVkU3RhdGVtZW50OiAnTGFiZWxlZFN0YXRlbWVudCcsXHJcblx0ICAgIExvZ2ljYWxFeHByZXNzaW9uOiAnTG9naWNhbEV4cHJlc3Npb24nLFxyXG5cdCAgICBNZW1iZXJFeHByZXNzaW9uOiAnTWVtYmVyRXhwcmVzc2lvbicsXHJcblx0ICAgIE1ldGFQcm9wZXJ0eTogJ01ldGFQcm9wZXJ0eScsXHJcblx0ICAgIE1ldGhvZERlZmluaXRpb246ICdNZXRob2REZWZpbml0aW9uJyxcclxuXHQgICAgTmV3RXhwcmVzc2lvbjogJ05ld0V4cHJlc3Npb24nLFxyXG5cdCAgICBPYmplY3RFeHByZXNzaW9uOiAnT2JqZWN0RXhwcmVzc2lvbicsXHJcblx0ICAgIE9iamVjdFBhdHRlcm46ICdPYmplY3RQYXR0ZXJuJyxcclxuXHQgICAgUHJvZ3JhbTogJ1Byb2dyYW0nLFxyXG5cdCAgICBQcm9wZXJ0eTogJ1Byb3BlcnR5JyxcclxuXHQgICAgUmVzdEVsZW1lbnQ6ICdSZXN0RWxlbWVudCcsXHJcblx0ICAgIFJldHVyblN0YXRlbWVudDogJ1JldHVyblN0YXRlbWVudCcsXHJcblx0ICAgIFNlcXVlbmNlRXhwcmVzc2lvbjogJ1NlcXVlbmNlRXhwcmVzc2lvbicsXHJcblx0ICAgIFNwcmVhZEVsZW1lbnQ6ICdTcHJlYWRFbGVtZW50JyxcclxuXHQgICAgU3VwZXI6ICdTdXBlcicsXHJcblx0ICAgIFN3aXRjaENhc2U6ICdTd2l0Y2hDYXNlJyxcclxuXHQgICAgU3dpdGNoU3RhdGVtZW50OiAnU3dpdGNoU3RhdGVtZW50JyxcclxuXHQgICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOiAnVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uJyxcclxuXHQgICAgVGVtcGxhdGVFbGVtZW50OiAnVGVtcGxhdGVFbGVtZW50JyxcclxuXHQgICAgVGVtcGxhdGVMaXRlcmFsOiAnVGVtcGxhdGVMaXRlcmFsJyxcclxuXHQgICAgVGhpc0V4cHJlc3Npb246ICdUaGlzRXhwcmVzc2lvbicsXHJcblx0ICAgIFRocm93U3RhdGVtZW50OiAnVGhyb3dTdGF0ZW1lbnQnLFxyXG5cdCAgICBUcnlTdGF0ZW1lbnQ6ICdUcnlTdGF0ZW1lbnQnLFxyXG5cdCAgICBVbmFyeUV4cHJlc3Npb246ICdVbmFyeUV4cHJlc3Npb24nLFxyXG5cdCAgICBVcGRhdGVFeHByZXNzaW9uOiAnVXBkYXRlRXhwcmVzc2lvbicsXHJcblx0ICAgIFZhcmlhYmxlRGVjbGFyYXRpb246ICdWYXJpYWJsZURlY2xhcmF0aW9uJyxcclxuXHQgICAgVmFyaWFibGVEZWNsYXJhdG9yOiAnVmFyaWFibGVEZWNsYXJhdG9yJyxcclxuXHQgICAgV2hpbGVTdGF0ZW1lbnQ6ICdXaGlsZVN0YXRlbWVudCcsXHJcblx0ICAgIFdpdGhTdGF0ZW1lbnQ6ICdXaXRoU3RhdGVtZW50JyxcclxuXHQgICAgWWllbGRFeHByZXNzaW9uOiAnWWllbGRFeHByZXNzaW9uJ1xyXG5cdH07XHJcblxuXG4vKioqLyB9LFxuLyogMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdHZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuXHQgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuXHQgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuXHQgICAgfTtcclxuXHR9KSgpO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgY2hhcmFjdGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cdHZhciBKU1hOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHR2YXIganN4X3N5bnRheF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHR2YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcblx0dmFyIHBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuXHR2YXIgdG9rZW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG5cdHZhciB4aHRtbF9lbnRpdGllc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XHJcblx0dG9rZW5fMS5Ub2tlbk5hbWVbMTAwIC8qIElkZW50aWZpZXIgKi9dID0gJ0pTWElkZW50aWZpZXInO1xyXG5cdHRva2VuXzEuVG9rZW5OYW1lWzEwMSAvKiBUZXh0ICovXSA9ICdKU1hUZXh0JztcclxuXHQvLyBGdWxseSBxdWFsaWZpZWQgZWxlbWVudCBuYW1lLCBlLmcuIDxzdmc6cGF0aD4gcmV0dXJucyBcInN2ZzpwYXRoXCJcclxuXHRmdW5jdGlvbiBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShlbGVtZW50TmFtZSkge1xyXG5cdCAgICB2YXIgcXVhbGlmaWVkTmFtZTtcclxuXHQgICAgc3dpdGNoIChlbGVtZW50TmFtZS50eXBlKSB7XHJcblx0ICAgICAgICBjYXNlIGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYSWRlbnRpZmllcjpcclxuXHQgICAgICAgICAgICB2YXIgaWQgPSBlbGVtZW50TmFtZTtcclxuXHQgICAgICAgICAgICBxdWFsaWZpZWROYW1lID0gaWQubmFtZTtcclxuXHQgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIGNhc2UganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hOYW1lc3BhY2VkTmFtZTpcclxuXHQgICAgICAgICAgICB2YXIgbnMgPSBlbGVtZW50TmFtZTtcclxuXHQgICAgICAgICAgICBxdWFsaWZpZWROYW1lID0gZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUobnMubmFtZXNwYWNlKSArICc6JyArXHJcblx0ICAgICAgICAgICAgICAgIGdldFF1YWxpZmllZEVsZW1lbnROYW1lKG5zLm5hbWUpO1xyXG5cdCAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgY2FzZSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWE1lbWJlckV4cHJlc3Npb246XHJcblx0ICAgICAgICAgICAgdmFyIGV4cHIgPSBlbGVtZW50TmFtZTtcclxuXHQgICAgICAgICAgICBxdWFsaWZpZWROYW1lID0gZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUoZXhwci5vYmplY3QpICsgJy4nICtcclxuXHQgICAgICAgICAgICAgICAgZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUoZXhwci5wcm9wZXJ0eSk7XHJcblx0ICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICBicmVhaztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gcXVhbGlmaWVkTmFtZTtcclxuXHR9XHJcblx0dmFyIEpTWFBhcnNlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcblx0ICAgIF9fZXh0ZW5kcyhKU1hQYXJzZXIsIF9zdXBlcik7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWFBhcnNlcihjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB8fCB0aGlzO1xyXG5cdCAgICB9XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VQcmltYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLm1hdGNoKCc8JykgPyB0aGlzLnBhcnNlSlNYUm9vdCgpIDogX3N1cGVyLnByb3RvdHlwZS5wYXJzZVByaW1hcnlFeHByZXNzaW9uLmNhbGwodGhpcyk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuc3RhcnRKU1ggPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAvLyBVbndpbmQgdGhlIHNjYW5uZXIgYmVmb3JlIHRoZSBsb29rYWhlYWQgdG9rZW4uXHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIuaW5kZXggPSB0aGlzLnN0YXJ0TWFya2VyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIgPSB0aGlzLnN0YXJ0TWFya2VyLmxpbmU7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIubGluZVN0YXJ0ID0gdGhpcy5zdGFydE1hcmtlci5pbmRleCAtIHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmZpbmlzaEpTWCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIC8vIFByaW1lIHRoZSBuZXh0IGxvb2thaGVhZC5cclxuXHQgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucmVlbnRlckpTWCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRKU1goKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCd9Jyk7XHJcblx0ICAgICAgICAvLyBQb3AgdGhlIGNsb3NpbmcgJ30nIGFkZGVkIGZyb20gdGhlIGxvb2thaGVhZC5cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy50b2tlbnMpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wb3AoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVKU1hOb2RlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5jb2xsZWN0Q29tbWVudHMoKTtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IHRoaXMuc2Nhbm5lci5pbmRleCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBjb2x1bW46IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnRcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuY3JlYXRlSlNYQ2hpbGROb2RlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBpbmRleDogdGhpcy5zY2FubmVyLmluZGV4LFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5zY2FuWEhUTUxFbnRpdHkgPSBmdW5jdGlvbiAocXVvdGUpIHtcclxuXHQgICAgICAgIHZhciByZXN1bHQgPSAnJic7XHJcblx0ICAgICAgICB2YXIgdmFsaWQgPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIHRlcm1pbmF0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBudW1lcmljID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgaGV4ID0gZmFsc2U7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSAmJiB2YWxpZCAmJiAhdGVybWluYXRlZCkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4XTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09IHF1b3RlKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0ZXJtaW5hdGVkID0gKGNoID09PSAnOycpO1xyXG5cdCAgICAgICAgICAgIHJlc3VsdCArPSBjaDtcclxuXHQgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChyZXN1bHQubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiAnJiMxMjM7J1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyaWMgPSAoY2ggPT09ICcjJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bWVyaWMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiAnJiN4NDE7J1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZXggPSAoY2ggPT09ICd4Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkID0gaGV4IHx8IGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtZXJpYyA9IG51bWVyaWMgJiYgIWhleDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkID0gdmFsaWQgJiYgIShudW1lcmljICYmICFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkID0gdmFsaWQgJiYgIShoZXggJiYgIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0hleERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh2YWxpZCAmJiB0ZXJtaW5hdGVkICYmIHJlc3VsdC5sZW5ndGggPiAyKSB7XHJcblx0ICAgICAgICAgICAgLy8gZS5nLiAnJiN4NDE7JyBiZWNvbWVzIGp1c3QgJyN4NDEnXHJcblx0ICAgICAgICAgICAgdmFyIHN0ciA9IHJlc3VsdC5zdWJzdHIoMSwgcmVzdWx0Lmxlbmd0aCAtIDIpO1xyXG5cdCAgICAgICAgICAgIGlmIChudW1lcmljICYmIHN0ci5sZW5ndGggPiAxKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTApKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoaGV4ICYmIHN0ci5sZW5ndGggPiAyKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoJzAnICsgc3RyLnN1YnN0cigxKSwgMTYpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoIW51bWVyaWMgJiYgIWhleCAmJiB4aHRtbF9lbnRpdGllc18xLlhIVE1MRW50aXRpZXNbc3RyXSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSB4aHRtbF9lbnRpdGllc18xLlhIVE1MRW50aXRpZXNbc3RyXTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBTY2FuIHRoZSBuZXh0IEpTWCB0b2tlbi4gVGhpcyByZXBsYWNlcyBTY2FubmVyI2xleCB3aGVuIGluIEpTWCBtb2RlLlxyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmxleEpTWCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjcCA9IHRoaXMuc2Nhbm5lci5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLnNjYW5uZXIuaW5kZXgpO1xyXG5cdCAgICAgICAgLy8gPCA+IC8gOiA9IHsgfVxyXG5cdCAgICAgICAgaWYgKGNwID09PSA2MCB8fCBjcCA9PT0gNjIgfHwgY3AgPT09IDQ3IHx8IGNwID09PSA1OCB8fCBjcCA9PT0gNjEgfHwgY3AgPT09IDEyMyB8fCBjcCA9PT0gMTI1KSB7XHJcblx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogNyAvKiBQdW5jdHVhdG9yICovLFxyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnNjYW5uZXIuaW5kZXggLSAxLFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuc2Nhbm5lci5pbmRleFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBcIiAnXHJcblx0ICAgICAgICBpZiAoY3AgPT09IDM0IHx8IGNwID09PSAzOSkge1xyXG5cdCAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICB2YXIgcXVvdGUgPSB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICB2YXIgc3RyID0gJyc7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKCF0aGlzLnNjYW5uZXIuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnJicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0ciArPSB0aGlzLnNjYW5YSFRNTEVudGl0eShxdW90ZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogOCAvKiBTdHJpbmdMaXRlcmFsICovLFxyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogc3RyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLnNjYW5uZXIubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIC4uLiBvciAuXHJcblx0ICAgICAgICBpZiAoY3AgPT09IDQ2KSB7XHJcblx0ICAgICAgICAgICAgdmFyIG4xID0gdGhpcy5zY2FubmVyLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuc2Nhbm5lci5pbmRleCArIDEpO1xyXG5cdCAgICAgICAgICAgIHZhciBuMiA9IHRoaXMuc2Nhbm5lci5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLnNjYW5uZXIuaW5kZXggKyAyKTtcclxuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSAobjEgPT09IDQ2ICYmIG4yID09PSA0NikgPyAnLi4uJyA6ICcuJztcclxuXHQgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdGhpcy5zY2FubmVyLmluZGV4ICs9IHZhbHVlLmxlbmd0aDtcclxuXHQgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiA3IC8qIFB1bmN0dWF0b3IgKi8sXHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5zY2FubmVyLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuc2Nhbm5lci5pbmRleFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBgXHJcblx0ICAgICAgICBpZiAoY3AgPT09IDk2KSB7XHJcblx0ICAgICAgICAgICAgLy8gT25seSBwbGFjZWhvbGRlciwgc2luY2UgaXQgd2lsbCBiZSByZXNjYW5uZWQgYXMgYSByZWFsIGFzc2lnbm1lbnQgZXhwcmVzc2lvbi5cclxuXHQgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiAxMCAvKiBUZW1wbGF0ZSAqLyxcclxuXHQgICAgICAgICAgICAgICAgdmFsdWU6ICcnLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLnNjYW5uZXIubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5zY2FubmVyLmluZGV4LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuc2Nhbm5lci5pbmRleFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBJZGVudGlmZXIgY2FuIG5vdCBjb250YWluIGJhY2tzbGFzaCAoY2hhciBjb2RlIDkyKS5cclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQoY3ApICYmIChjcCAhPT0gOTIpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc2Nhbm5lci5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLnNjYW5uZXIuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclBhcnQoY2gpICYmIChjaCAhPT0gOTIpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gNDUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEh5cGhlbiAoY2hhciBjb2RlIDQ1KSBjYW4gYmUgcGFydCBvZiBhbiBpZGVudGlmaWVyLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLnNjYW5uZXIuc291cmNlLnNsaWNlKHN0YXJ0LCB0aGlzLnNjYW5uZXIuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IDEwMCAvKiBJZGVudGlmaWVyICovLFxyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogaWQsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB0aGlzLnNjYW5uZXIuaW5kZXhcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbm5lci5sZXgoKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5uZXh0SlNYVG9rZW4gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmNvbGxlY3RDb21tZW50cygpO1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sZXhKU1goKTtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy50b2tlbnMpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHRoaXMuY29udmVydFRva2VuKHRva2VuKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdG9rZW47XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUubmV4dEpTWFRleHQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgdGV4dCA9ICcnO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLnNjYW5uZXIuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleF07XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAneycgfHwgY2ggPT09ICc8Jykge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdGV4dCArPSBjaDtcclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleF0gPT09ICdcXG4nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIubGluZVN0YXJ0ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHtcclxuXHQgICAgICAgICAgICB0eXBlOiAxMDEgLyogVGV4dCAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogdGV4dCxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgaWYgKCh0ZXh0Lmxlbmd0aCA+IDApICYmIHRoaXMuY29uZmlnLnRva2Vucykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2godGhpcy5jb252ZXJ0VG9rZW4odG9rZW4pKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0b2tlbjtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wZWVrSlNYVG9rZW4gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnNjYW5uZXIuc2F2ZVN0YXRlKCk7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIuc2NhbkNvbW1lbnRzKCk7XHJcblx0ICAgICAgICB2YXIgbmV4dCA9IHRoaXMubGV4SlNYKCk7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIucmVzdG9yZVN0YXRlKHN0YXRlKTtcclxuXHQgICAgICAgIHJldHVybiBuZXh0O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBFeHBlY3QgdGhlIG5leHQgSlNYIHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cclxuXHQgICAgLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuZXhwZWN0SlNYID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRKU1hUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IDcgLyogUHVuY3R1YXRvciAqLyB8fCB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgSlNYIHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLm1hdGNoSlNYID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0ICAgICAgICB2YXIgbmV4dCA9IHRoaXMucGVla0pTWFRva2VuKCk7XHJcblx0ICAgICAgICByZXR1cm4gbmV4dC50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgbmV4dC52YWx1ZSA9PT0gdmFsdWU7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dEpTWFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gMTAwIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWElkZW50aWZpZXIodG9rZW4udmFsdWUpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEVsZW1lbnROYW1lID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHZhciBlbGVtZW50TmFtZSA9IHRoaXMucGFyc2VKU1hJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEpTWCgnOicpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGVsZW1lbnROYW1lO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc6Jyk7XHJcblx0ICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHRoaXMucGFyc2VKU1hJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgZWxlbWVudE5hbWUgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWE5hbWVzcGFjZWROYW1lKG5hbWVzcGFjZSwgbmFtZV8xKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoSlNYKCcuJykpIHtcclxuXHQgICAgICAgICAgICB3aGlsZSAodGhpcy5tYXRjaEpTWCgnLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSBlbGVtZW50TmFtZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJy4nKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZUpTWElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICAgICAgZWxlbWVudE5hbWUgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWE1lbWJlckV4cHJlc3Npb24ob2JqZWN0LCBwcm9wZXJ0eSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBlbGVtZW50TmFtZTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEF0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWU7XHJcblx0ICAgICAgICB2YXIgaWRlbnRpZmllciA9IHRoaXMucGFyc2VKU1hJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEpTWCgnOicpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGlkZW50aWZpZXI7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJzonKTtcclxuXHQgICAgICAgICAgICB2YXIgbmFtZV8yID0gdGhpcy5wYXJzZUpTWElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hOYW1lc3BhY2VkTmFtZShuYW1lc3BhY2UsIG5hbWVfMikpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9IGlkZW50aWZpZXI7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gYXR0cmlidXRlTmFtZTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWFN0cmluZ0xpdGVyYWxBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0SlNYVG9rZW4oKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSA4IC8qIFN0cmluZ0xpdGVyYWwgKi8pIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkxpdGVyYWwodG9rZW4udmFsdWUsIHJhdykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYRXhwcmVzc2lvbkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgneycpO1xyXG5cdCAgICAgICAgdGhpcy5maW5pc2hKU1goKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IoJ0pTWCBhdHRyaWJ1dGVzIG11c3Qgb25seSBiZSBhc3NpZ25lZCBhIG5vbi1lbXB0eSBleHByZXNzaW9uJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdGhpcy5yZWVudGVySlNYKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hFeHByZXNzaW9uQ29udGFpbmVyKGV4cHJlc3Npb24pKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEF0dHJpYnV0ZVZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hKU1goJ3snKSA/IHRoaXMucGFyc2VKU1hFeHByZXNzaW9uQXR0cmlidXRlKCkgOlxyXG5cdCAgICAgICAgICAgIHRoaXMubWF0Y2hKU1goJzwnKSA/IHRoaXMucGFyc2VKU1hFbGVtZW50KCkgOiB0aGlzLnBhcnNlSlNYU3RyaW5nTGl0ZXJhbEF0dHJpYnV0ZSgpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYTmFtZVZhbHVlQXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZUpTWEF0dHJpYnV0ZU5hbWUoKTtcclxuXHQgICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEpTWCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJz0nKTtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VKU1hBdHRyaWJ1dGVWYWx1ZSgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYQXR0cmlidXRlKG5hbWUsIHZhbHVlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hTcHJlYWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJ3snKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCcuLi4nKTtcclxuXHQgICAgICAgIHRoaXMuZmluaXNoSlNYKCk7XHJcblx0ICAgICAgICB2YXIgYXJndW1lbnQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHRoaXMucmVlbnRlckpTWCgpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYU3ByZWFkQXR0cmlidXRlKGFyZ3VtZW50KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaEpTWCgnLycpICYmICF0aGlzLm1hdGNoSlNYKCc+JykpIHtcclxuXHQgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5tYXRjaEpTWCgneycpID8gdGhpcy5wYXJzZUpTWFNwcmVhZEF0dHJpYnV0ZSgpIDpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUpTWE5hbWVWYWx1ZUF0dHJpYnV0ZSgpO1xyXG5cdCAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaChhdHRyaWJ1dGUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hPcGVuaW5nRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPCcpO1xyXG5cdCAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlSlNYRWxlbWVudE5hbWUoKTtcclxuXHQgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5wYXJzZUpTWEF0dHJpYnV0ZXMoKTtcclxuXHQgICAgICAgIHZhciBzZWxmQ2xvc2luZyA9IHRoaXMubWF0Y2hKU1goJy8nKTtcclxuXHQgICAgICAgIGlmIChzZWxmQ2xvc2luZykge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCcvJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPicpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYT3BlbmluZ0VsZW1lbnQobmFtZSwgc2VsZkNsb3NpbmcsIGF0dHJpYnV0ZXMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEJvdW5kYXJ5RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPCcpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hKU1goJy8nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCcvJyk7XHJcblx0ICAgICAgICAgICAgdmFyIG5hbWVfMyA9IHRoaXMucGFyc2VKU1hFbGVtZW50TmFtZSgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc+Jyk7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYQ2xvc2luZ0VsZW1lbnQobmFtZV8zKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VKU1hFbGVtZW50TmFtZSgpO1xyXG5cdCAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLnBhcnNlSlNYQXR0cmlidXRlcygpO1xyXG5cdCAgICAgICAgdmFyIHNlbGZDbG9zaW5nID0gdGhpcy5tYXRjaEpTWCgnLycpO1xyXG5cdCAgICAgICAgaWYgKHNlbGZDbG9zaW5nKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJy8nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc+Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hPcGVuaW5nRWxlbWVudChuYW1lLCBzZWxmQ2xvc2luZywgYXR0cmlidXRlcykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYRW1wdHlFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWENoaWxkTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5jb2xsZWN0Q29tbWVudHMoKTtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWEVtcHR5RXhwcmVzc2lvbigpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEV4cHJlc3Npb25Db250YWluZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJ3snKTtcclxuXHQgICAgICAgIHZhciBleHByZXNzaW9uO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hKU1goJ30nKSkge1xyXG5cdCAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlSlNYRW1wdHlFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJ30nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZmluaXNoSlNYKCk7XHJcblx0ICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIHRoaXMucmVlbnRlckpTWCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYRXhwcmVzc2lvbkNvbnRhaW5lcihleHByZXNzaW9uKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLnNjYW5uZXIuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYQ2hpbGROb2RlKCk7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0SlNYVGV4dCgpO1xyXG5cdCAgICAgICAgICAgIGlmICh0b2tlbi5zdGFydCA8IHRva2VuLmVuZCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYVGV4dCh0b2tlbi52YWx1ZSwgcmF3KSk7XHJcblx0ICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXhdID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMucGFyc2VKU1hFeHByZXNzaW9uQ29udGFpbmVyKCk7XHJcblx0ICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY29udGFpbmVyKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBjaGlsZHJlbjtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvbXBsZXhKU1hFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XHJcblx0ICAgICAgICB2YXIgc3RhY2sgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgZWwuY2hpbGRyZW4gPSBlbC5jaGlsZHJlbi5jb25jYXQodGhpcy5wYXJzZUpTWENoaWxkcmVuKCkpO1xyXG5cdCAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hDaGlsZE5vZGUoKTtcclxuXHQgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VKU1hCb3VuZGFyeUVsZW1lbnQoKTtcclxuXHQgICAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWE9wZW5pbmdFbGVtZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBvcGVuaW5nID0gZWxlbWVudDtcclxuXHQgICAgICAgICAgICAgICAgaWYgKG9wZW5pbmcuc2VsZkNsb3NpbmcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYRWxlbWVudChvcGVuaW5nLCBbXSwgbnVsbCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZWwuY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGVsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVsID0geyBub2RlOiBub2RlLCBvcGVuaW5nOiBvcGVuaW5nLCBjbG9zaW5nOiBudWxsLCBjaGlsZHJlbjogW10gfTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWENsb3NpbmdFbGVtZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgIGVsLmNsb3NpbmcgPSBlbGVtZW50O1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgb3Blbl8xID0gZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUoZWwub3BlbmluZy5uYW1lKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNsb3NlXzEgPSBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShlbC5jbG9zaW5nLm5hbWUpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAob3Blbl8xICE9PSBjbG9zZV8xKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IoJ0V4cGVjdGVkIGNvcnJlc3BvbmRpbmcgSlNYIGNsb3NpbmcgdGFnIGZvciAlMCcsIG9wZW5fMSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuZmluYWxpemUoZWwubm9kZSwgbmV3IEpTWE5vZGUuSlNYRWxlbWVudChlbC5vcGVuaW5nLCBlbC5jaGlsZHJlbiwgZWwuY2xvc2luZykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZWwgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVsLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBlbDtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIG9wZW5pbmcgPSB0aGlzLnBhcnNlSlNYT3BlbmluZ0VsZW1lbnQoKTtcclxuXHQgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xyXG5cdCAgICAgICAgdmFyIGNsb3NpbmcgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKCFvcGVuaW5nLnNlbGZDbG9zaW5nKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5wYXJzZUNvbXBsZXhKU1hFbGVtZW50KHsgbm9kZTogbm9kZSwgb3BlbmluZzogb3BlbmluZywgY2xvc2luZzogY2xvc2luZywgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xyXG5cdCAgICAgICAgICAgIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XHJcblx0ICAgICAgICAgICAgY2xvc2luZyA9IGVsLmNsb3Npbmc7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hFbGVtZW50KG9wZW5pbmcsIGNoaWxkcmVuLCBjbG9zaW5nKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hSb290ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgLy8gUG9wIHRoZSBvcGVuaW5nICc8JyBhZGRlZCBmcm9tIHRoZSBsb29rYWhlYWQuXHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9rZW5zKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucG9wKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0SlNYKCk7XHJcblx0ICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VKU1hFbGVtZW50KCk7XHJcblx0ICAgICAgICB0aGlzLmZpbmlzaEpTWCgpO1xyXG5cdCAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuaXNTdGFydE9mRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmlzU3RhcnRPZkV4cHJlc3Npb24uY2FsbCh0aGlzKSB8fCB0aGlzLm1hdGNoKCc8Jyk7XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBKU1hQYXJzZXI7XHJcblx0fShwYXJzZXJfMS5QYXJzZXIpKTtcclxuXHRleHBvcnRzLkpTWFBhcnNlciA9IEpTWFBhcnNlcjtcclxuXG5cbi8qKiovIH0sXG4vKiA0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0Ly8gU2VlIGFsc28gdG9vbHMvZ2VuZXJhdGUtdW5pY29kZS1yZWdleC5qcy5cclxuXHR2YXIgUmVnZXggPSB7XHJcblx0ICAgIC8vIFVuaWNvZGUgdjguMC4wIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OlxyXG5cdCAgICBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDogL1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCNFxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlCLVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFRlxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRFxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0QVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRlxcdURGRDEtXFx1REZENV18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwXFx1REUxMC1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OFxcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMl18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVERDAzLVxcdUREMjZcXHVERDUwLVxcdURENzJcXHVERDc2XFx1REQ4My1cXHVEREIyXFx1RERDMS1cXHVEREM0XFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMkJcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERURFXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0RcXHVERjUwXFx1REY1RC1cXHVERjYxXXxcXHVEODA1W1xcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERBRVxcdURERDgtXFx1REREQlxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTgwLVxcdURFQUFcXHVERjAwLVxcdURGMTldfFxcdUQ4MDZbXFx1RENBMC1cXHVEQ0RGXFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY0MC1cXHVERjQzXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTBcXHVERjkzLVxcdURGOUZdfFxcdUQ4MkNbXFx1REMwMFxcdURDMDFdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF0vLFxyXG5cdCAgICAvLyBVbmljb2RlIHY4LjAuMCBOb25Bc2NpaUlkZW50aWZpZXJQYXJ0OlxyXG5cdCAgICBOb25Bc2NpaUlkZW50aWZpZXJQYXJ0OiAvW1xceEFBXFx4QjVcXHhCN1xceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODYtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjY5XFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDc0QVxcdTA3NEQtXFx1MDdCMVxcdTA3QzAtXFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MkRcXHUwODQwLVxcdTA4NUJcXHUwOEEwLVxcdTA4QjRcXHUwOEUzLVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTBBMDEtXFx1MEEwM1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkMtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRDBcXHUwQUUwLVxcdTBBRTNcXHUwQUU2LVxcdTBBRUZcXHUwQUY5XFx1MEIwMS1cXHUwQjAzXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0MtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNjYtXFx1MEI2RlxcdTBCNzFcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQwXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDAtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM1OC1cXHUwQzVBXFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MS1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDAxLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNELVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU3XFx1MEQ1Ri1cXHUwRDYzXFx1MEQ2Ni1cXHUwRDZGXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4MlxcdTBEODNcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREU2LVxcdTBERUZcXHUwREYyXFx1MERGM1xcdTBFMDEtXFx1MEUzQVxcdTBFNDAtXFx1MEU0RVxcdTBFNTAtXFx1MEU1OVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUI5XFx1MEVCQi1cXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFQzgtXFx1MEVDRFxcdTBFRDAtXFx1MEVEOVxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjE4XFx1MEYxOVxcdTBGMjAtXFx1MEYyOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0UtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGNzEtXFx1MEY4NFxcdTBGODYtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDAwLVxcdTEwNDlcXHUxMDUwLVxcdTEwOURcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM1RC1cXHUxMzVGXFx1MTM2OS1cXHUxMzcxXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzE0XFx1MTcyMC1cXHUxNzM0XFx1MTc0MC1cXHUxNzUzXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3RDNcXHUxN0Q3XFx1MTdEQ1xcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxODBCLVxcdTE4MERcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5M0JcXHUxOTQ2LVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxOUQwLVxcdTE5REFcXHUxQTAwLVxcdTFBMUJcXHUxQTIwLVxcdTFBNUVcXHUxQTYwLVxcdTFBN0NcXHUxQTdGLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQUE3XFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjRCXFx1MUI1MC1cXHUxQjU5XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQkYzXFx1MUMwMC1cXHUxQzM3XFx1MUM0MC1cXHUxQzQ5XFx1MUM0RC1cXHUxQzdEXFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0Y2XFx1MUNGOFxcdTFDRjlcXHUxRDAwLVxcdTFERjVcXHUxREZDLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAwQ1xcdTIwMERcXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ3Ri1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkRFMC1cXHUyREZGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDJGXFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5OS1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY3Ri1cXHVBNkYxXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FEXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEM0XFx1QThEMC1cXHVBOEQ5XFx1QThFMC1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTAwLVxcdUE5MkRcXHVBOTMwLVxcdUE5NTNcXHVBOTYwLVxcdUE5N0NcXHVBOTgwLVxcdUE5QzBcXHVBOUNGLVxcdUE5RDlcXHVBOUUwLVxcdUE5RkVcXHVBQTAwLVxcdUFBMzZcXHVBQTQwLVxcdUFBNERcXHVBQTUwLVxcdUFBNTlcXHVBQTYwLVxcdUFBNzZcXHVBQTdBLVxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUZcXHVBQUYyLVxcdUFBRjZcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMUQtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGXFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjEwLVxcdUZGMTlcXHVGRjIxLVxcdUZGM0FcXHVGRjNGXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQ0MC1cXHVERDc0XFx1RERGRFxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURFRTBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNEFcXHVERjUwLVxcdURGN0FcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1RENBMC1cXHVEQ0E5XFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMC1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTM4LVxcdURFM0FcXHVERTNGXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU2XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OFxcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMl18XFx1RDgwNFtcXHVEQzAwLVxcdURDNDZcXHVEQzY2LVxcdURDNkZcXHVEQzdGLVxcdURDQkFcXHVEQ0QwLVxcdURDRThcXHVEQ0YwLVxcdURDRjlcXHVERDAwLVxcdUREMzRcXHVERDM2LVxcdUREM0ZcXHVERDUwLVxcdURENzNcXHVERDc2XFx1REQ4MC1cXHVEREM0XFx1RERDQS1cXHVERENDXFx1REREMC1cXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUzN1xcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFRUFcXHVERUYwLVxcdURFRjlcXHVERjAwLVxcdURGMDNcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzQy1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjUwXFx1REY1N1xcdURGNUQtXFx1REY2M1xcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgwNVtcXHVEQzgwLVxcdURDQzVcXHVEQ0M3XFx1RENEMC1cXHVEQ0Q5XFx1REQ4MC1cXHVEREI1XFx1RERCOC1cXHVEREMwXFx1REREOC1cXHVEREREXFx1REUwMC1cXHVERTQwXFx1REU0NFxcdURFNTAtXFx1REU1OVxcdURFODAtXFx1REVCN1xcdURFQzAtXFx1REVDOVxcdURGMDAtXFx1REYxOVxcdURGMUQtXFx1REYyQlxcdURGMzAtXFx1REYzOV18XFx1RDgwNltcXHVEQ0EwLVxcdURDRTlcXHVEQ0ZGXFx1REVDMC1cXHVERUY4XXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERTYwLVxcdURFNjlcXHVERUQwLVxcdURFRURcXHVERUYwLVxcdURFRjRcXHVERjAwLVxcdURGMzZcXHVERjQwLVxcdURGNDNcXHVERjUwLVxcdURGNTlcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MC1cXHVERjdFXFx1REY4Ri1cXHVERjlGXXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OVxcdURDOURcXHVEQzlFXXxcXHVEODM0W1xcdURENjUtXFx1REQ2OVxcdURENkQtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXFx1REZDRS1cXHVERkZGXXxcXHVEODM2W1xcdURFMDAtXFx1REUzNlxcdURFM0ItXFx1REU2Q1xcdURFNzVcXHVERTg0XFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNFxcdURDRDAtXFx1RENENl18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdfFxcdURCNDBbXFx1REQwMC1cXHVEREVGXS9cclxuXHR9O1xyXG5cdGV4cG9ydHMuQ2hhcmFjdGVyID0ge1xyXG5cdCAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1iaXR3aXNlICovXHJcblx0ICAgIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA8IDB4MTAwMDApID8gU3RyaW5nLmZyb21DaGFyQ29kZShjcCkgOlxyXG5cdCAgICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODAwICsgKChjcCAtIDB4MTAwMDApID4+IDEwKSkgK1xyXG5cdCAgICAgICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4REMwMCArICgoY3AgLSAweDEwMDAwKSAmIDEwMjMpKTtcclxuXHQgICAgfSxcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtd2hpdGUtc3BhY2VcclxuXHQgICAgaXNXaGl0ZVNwYWNlOiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPT09IDB4MjApIHx8IChjcCA9PT0gMHgwOSkgfHwgKGNwID09PSAweDBCKSB8fCAoY3AgPT09IDB4MEMpIHx8IChjcCA9PT0gMHhBMCkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHgxNjgwICYmIFsweDE2ODAsIDB4MjAwMCwgMHgyMDAxLCAweDIwMDIsIDB4MjAwMywgMHgyMDA0LCAweDIwMDUsIDB4MjAwNiwgMHgyMDA3LCAweDIwMDgsIDB4MjAwOSwgMHgyMDBBLCAweDIwMkYsIDB4MjA1RiwgMHgzMDAwLCAweEZFRkZdLmluZGV4T2YoY3ApID49IDApO1xyXG5cdCAgICB9LFxyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1saW5lLXRlcm1pbmF0b3JzXHJcblx0ICAgIGlzTGluZVRlcm1pbmF0b3I6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA9PT0gMHgwQSkgfHwgKGNwID09PSAweDBEKSB8fCAoY3AgPT09IDB4MjAyOCkgfHwgKGNwID09PSAweDIwMjkpO1xyXG5cdCAgICB9LFxyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1uYW1lcy1hbmQta2V5d29yZHNcclxuXHQgICAgaXNJZGVudGlmaWVyU3RhcnQ6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA9PT0gMHgyNCkgfHwgKGNwID09PSAweDVGKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDQxICYmIGNwIDw9IDB4NUEpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4NjEgJiYgY3AgPD0gMHg3QSkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPT09IDB4NUMpIHx8XHJcblx0ICAgICAgICAgICAgKChjcCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KGV4cG9ydHMuQ2hhcmFjdGVyLmZyb21Db2RlUG9pbnQoY3ApKSk7XHJcblx0ICAgIH0sXHJcblx0ICAgIGlzSWRlbnRpZmllclBhcnQ6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA9PT0gMHgyNCkgfHwgKGNwID09PSAweDVGKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDQxICYmIGNwIDw9IDB4NUEpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4NjEgJiYgY3AgPD0gMHg3QSkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHgzMCAmJiBjcCA8PSAweDM5KSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA9PT0gMHg1QykgfHxcclxuXHQgICAgICAgICAgICAoKGNwID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclBhcnQudGVzdChleHBvcnRzLkNoYXJhY3Rlci5mcm9tQ29kZVBvaW50KGNwKSkpO1xyXG5cdCAgICB9LFxyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1saXRlcmFscy1udW1lcmljLWxpdGVyYWxzXHJcblx0ICAgIGlzRGVjaW1hbERpZ2l0OiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPj0gMHgzMCAmJiBjcCA8PSAweDM5KTsgLy8gMC4uOVxyXG5cdCAgICB9LFxyXG5cdCAgICBpc0hleERpZ2l0OiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPj0gMHgzMCAmJiBjcCA8PSAweDM5KSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDQxICYmIGNwIDw9IDB4NDYpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4NjEgJiYgY3AgPD0gMHg2Nik7IC8vIGEuLmZcclxuXHQgICAgfSxcclxuXHQgICAgaXNPY3RhbERpZ2l0OiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPj0gMHgzMCAmJiBjcCA8PSAweDM3KTsgLy8gMC4uN1xyXG5cdCAgICB9XHJcblx0fTtcclxuXG5cbi8qKiovIH0sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIGpzeF9zeW50YXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblx0LyogdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cclxuXHR2YXIgSlNYQ2xvc2luZ0VsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hDbG9zaW5nRWxlbWVudChuYW1lKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWENsb3NpbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYQ2xvc2luZ0VsZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWENsb3NpbmdFbGVtZW50ID0gSlNYQ2xvc2luZ0VsZW1lbnQ7XHJcblx0dmFyIEpTWEVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hFbGVtZW50KG9wZW5pbmdFbGVtZW50LCBjaGlsZHJlbiwgY2xvc2luZ0VsZW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMub3BlbmluZ0VsZW1lbnQgPSBvcGVuaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuXHQgICAgICAgIHRoaXMuY2xvc2luZ0VsZW1lbnQgPSBjbG9zaW5nRWxlbWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYRWxlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYRWxlbWVudCA9IEpTWEVsZW1lbnQ7XHJcblx0dmFyIEpTWEVtcHR5RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWEVtcHR5RXhwcmVzc2lvbigpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYRW1wdHlFeHByZXNzaW9uO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hFbXB0eUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWEVtcHR5RXhwcmVzc2lvbiA9IEpTWEVtcHR5RXhwcmVzc2lvbjtcclxuXHR2YXIgSlNYRXhwcmVzc2lvbkNvbnRhaW5lciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWEV4cHJlc3Npb25Db250YWluZXIoZXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hFeHByZXNzaW9uQ29udGFpbmVyO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYRXhwcmVzc2lvbkNvbnRhaW5lcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYRXhwcmVzc2lvbkNvbnRhaW5lciA9IEpTWEV4cHJlc3Npb25Db250YWluZXI7XHJcblx0dmFyIEpTWElkZW50aWZpZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hJZGVudGlmaWVyKG5hbWUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYSWRlbnRpZmllcjtcclxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWElkZW50aWZpZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWElkZW50aWZpZXIgPSBKU1hJZGVudGlmaWVyO1xyXG5cdHZhciBKU1hNZW1iZXJFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYTWVtYmVyRXhwcmVzc2lvbihvYmplY3QsIHByb3BlcnR5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWE1lbWJlckV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHQgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYTWVtYmVyRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYTWVtYmVyRXhwcmVzc2lvbiA9IEpTWE1lbWJlckV4cHJlc3Npb247XHJcblx0dmFyIEpTWEF0dHJpYnV0ZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hBdHRyaWJ1dGU7XHJcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hBdHRyaWJ1dGU7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWEF0dHJpYnV0ZSA9IEpTWEF0dHJpYnV0ZTtcclxuXHR2YXIgSlNYTmFtZXNwYWNlZE5hbWUgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hOYW1lc3BhY2VkTmFtZShuYW1lc3BhY2UsIG5hbWUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYTmFtZXNwYWNlZE5hbWU7XHJcblx0ICAgICAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcclxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWE5hbWVzcGFjZWROYW1lO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hOYW1lc3BhY2VkTmFtZSA9IEpTWE5hbWVzcGFjZWROYW1lO1xyXG5cdHZhciBKU1hPcGVuaW5nRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWE9wZW5pbmdFbGVtZW50KG5hbWUsIHNlbGZDbG9zaW5nLCBhdHRyaWJ1dGVzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWE9wZW5pbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHQgICAgICAgIHRoaXMuc2VsZkNsb3NpbmcgPSBzZWxmQ2xvc2luZztcclxuXHQgICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWE9wZW5pbmdFbGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hPcGVuaW5nRWxlbWVudCA9IEpTWE9wZW5pbmdFbGVtZW50O1xyXG5cdHZhciBKU1hTcHJlYWRBdHRyaWJ1dGUgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hTcHJlYWRBdHRyaWJ1dGUoYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYU3ByZWFkQXR0cmlidXRlO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hTcHJlYWRBdHRyaWJ1dGU7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWFNwcmVhZEF0dHJpYnV0ZSA9IEpTWFNwcmVhZEF0dHJpYnV0ZTtcclxuXHR2YXIgSlNYVGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWFRleHQodmFsdWUsIHJhdykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hUZXh0O1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgdGhpcy5yYXcgPSByYXc7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWFRleHQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWFRleHQgPSBKU1hUZXh0O1xyXG5cblxuLyoqKi8gfSxcbi8qIDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHRleHBvcnRzLkpTWFN5bnRheCA9IHtcclxuXHQgICAgSlNYQXR0cmlidXRlOiAnSlNYQXR0cmlidXRlJyxcclxuXHQgICAgSlNYQ2xvc2luZ0VsZW1lbnQ6ICdKU1hDbG9zaW5nRWxlbWVudCcsXHJcblx0ICAgIEpTWEVsZW1lbnQ6ICdKU1hFbGVtZW50JyxcclxuXHQgICAgSlNYRW1wdHlFeHByZXNzaW9uOiAnSlNYRW1wdHlFeHByZXNzaW9uJyxcclxuXHQgICAgSlNYRXhwcmVzc2lvbkNvbnRhaW5lcjogJ0pTWEV4cHJlc3Npb25Db250YWluZXInLFxyXG5cdCAgICBKU1hJZGVudGlmaWVyOiAnSlNYSWRlbnRpZmllcicsXHJcblx0ICAgIEpTWE1lbWJlckV4cHJlc3Npb246ICdKU1hNZW1iZXJFeHByZXNzaW9uJyxcclxuXHQgICAgSlNYTmFtZXNwYWNlZE5hbWU6ICdKU1hOYW1lc3BhY2VkTmFtZScsXHJcblx0ICAgIEpTWE9wZW5pbmdFbGVtZW50OiAnSlNYT3BlbmluZ0VsZW1lbnQnLFxyXG5cdCAgICBKU1hTcHJlYWRBdHRyaWJ1dGU6ICdKU1hTcHJlYWRBdHRyaWJ1dGUnLFxyXG5cdCAgICBKU1hUZXh0OiAnSlNYVGV4dCdcclxuXHR9O1xyXG5cblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgc3ludGF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cdC8qIHRzbGludDpkaXNhYmxlOm1heC1jbGFzc2VzLXBlci1maWxlICovXHJcblx0dmFyIEFycmF5RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFycmF5RXhwcmVzc2lvbihlbGVtZW50cykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFycmF5RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXJyYXlFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5BcnJheUV4cHJlc3Npb24gPSBBcnJheUV4cHJlc3Npb247XHJcblx0dmFyIEFycmF5UGF0dGVybiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFycmF5UGF0dGVybihlbGVtZW50cykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFycmF5UGF0dGVybjtcclxuXHQgICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXJyYXlQYXR0ZXJuO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5BcnJheVBhdHRlcm4gPSBBcnJheVBhdHRlcm47XHJcblx0dmFyIEFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24ocGFyYW1zLCBib2R5LCBleHByZXNzaW9uKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gbnVsbDtcclxuXHQgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5hc3luYyA9IGZhbHNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR2YXIgQXNzaWdubWVudEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBc3NpZ25tZW50RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcclxuXHQgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFzc2lnbm1lbnRFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Bc3NpZ25tZW50RXhwcmVzc2lvbiA9IEFzc2lnbm1lbnRFeHByZXNzaW9uO1xyXG5cdHZhciBBc3NpZ25tZW50UGF0dGVybiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFzc2lnbm1lbnRQYXR0ZXJuKGxlZnQsIHJpZ2h0KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudFBhdHRlcm47XHJcblx0ICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBc3NpZ25tZW50UGF0dGVybjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXNzaWdubWVudFBhdHRlcm4gPSBBc3NpZ25tZW50UGF0dGVybjtcclxuXHR2YXIgQXN5bmNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24ocGFyYW1zLCBib2R5LCBleHByZXNzaW9uKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gbnVsbDtcclxuXHQgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5hc3luYyA9IHRydWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSBBc3luY0Fycm93RnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdHZhciBBc3luY0Z1bmN0aW9uRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBc3luY0Z1bmN0aW9uRGVjbGFyYXRpb24oaWQsIHBhcmFtcywgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmFzeW5jID0gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Bc3luY0Z1bmN0aW9uRGVjbGFyYXRpb24gPSBBc3luY0Z1bmN0aW9uRGVjbGFyYXRpb247XHJcblx0dmFyIEFzeW5jRnVuY3Rpb25FeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24oaWQsIHBhcmFtcywgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuYXN5bmMgPSB0cnVlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBc3luY0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24gPSBBc3luY0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR2YXIgQXdhaXRFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXdhaXRFeHByZXNzaW9uKGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXdhaXRFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBd2FpdEV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkF3YWl0RXhwcmVzc2lvbiA9IEF3YWl0RXhwcmVzc2lvbjtcclxuXHR2YXIgQmluYXJ5RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XHJcblx0ICAgICAgICB2YXIgbG9naWNhbCA9IChvcGVyYXRvciA9PT0gJ3x8JyB8fCBvcGVyYXRvciA9PT0gJyYmJyk7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBsb2dpY2FsID8gc3ludGF4XzEuU3ludGF4LkxvZ2ljYWxFeHByZXNzaW9uIDogc3ludGF4XzEuU3ludGF4LkJpbmFyeUV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBCaW5hcnlFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5CaW5hcnlFeHByZXNzaW9uID0gQmluYXJ5RXhwcmVzc2lvbjtcclxuXHR2YXIgQmxvY2tTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBCbG9ja1N0YXRlbWVudChib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQmxvY2tTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBCbG9ja1N0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQmxvY2tTdGF0ZW1lbnQgPSBCbG9ja1N0YXRlbWVudDtcclxuXHR2YXIgQnJlYWtTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBCcmVha1N0YXRlbWVudChsYWJlbCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkJyZWFrU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBCcmVha1N0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQnJlYWtTdGF0ZW1lbnQgPSBCcmVha1N0YXRlbWVudDtcclxuXHR2YXIgQ2FsbEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDYWxsRXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5DYWxsRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuY2FsbGVlID0gY2FsbGVlO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudHMgPSBhcmdzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDYWxsRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ2FsbEV4cHJlc3Npb24gPSBDYWxsRXhwcmVzc2lvbjtcclxuXHR2YXIgQ2F0Y2hDbGF1c2UgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDYXRjaENsYXVzZShwYXJhbSwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNhdGNoQ2xhdXNlO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbSA9IHBhcmFtO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ2F0Y2hDbGF1c2U7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNhdGNoQ2xhdXNlID0gQ2F0Y2hDbGF1c2U7XHJcblx0dmFyIENsYXNzQm9keSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENsYXNzQm9keShib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ2xhc3NCb2R5O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ2xhc3NCb2R5O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5DbGFzc0JvZHkgPSBDbGFzc0JvZHk7XHJcblx0dmFyIENsYXNzRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDbGFzc0RlY2xhcmF0aW9uKGlkLCBzdXBlckNsYXNzLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ2xhc3NEZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMuc3VwZXJDbGFzcyA9IHN1cGVyQ2xhc3M7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDbGFzc0RlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5DbGFzc0RlY2xhcmF0aW9uID0gQ2xhc3NEZWNsYXJhdGlvbjtcclxuXHR2YXIgQ2xhc3NFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ2xhc3NFeHByZXNzaW9uKGlkLCBzdXBlckNsYXNzLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ2xhc3NFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5zdXBlckNsYXNzID0gc3VwZXJDbGFzcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENsYXNzRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ2xhc3NFeHByZXNzaW9uID0gQ2xhc3NFeHByZXNzaW9uO1xyXG5cdHZhciBDb21wdXRlZE1lbWJlckV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDb21wdXRlZE1lbWJlckV4cHJlc3Npb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk1lbWJlckV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmNvbXB1dGVkID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDb21wdXRlZE1lbWJlckV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbiA9IENvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbjtcclxuXHR2YXIgQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ29uZGl0aW9uYWxFeHByZXNzaW9uKHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNvbmRpdGlvbmFsRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xyXG5cdCAgICAgICAgdGhpcy5hbHRlcm5hdGUgPSBhbHRlcm5hdGU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENvbmRpdGlvbmFsRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xyXG5cdHZhciBDb250aW51ZVN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENvbnRpbnVlU3RhdGVtZW50KGxhYmVsKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ29udGludWVTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENvbnRpbnVlU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Db250aW51ZVN0YXRlbWVudCA9IENvbnRpbnVlU3RhdGVtZW50O1xyXG5cdHZhciBEZWJ1Z2dlclN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIERlYnVnZ2VyU3RhdGVtZW50KCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkRlYnVnZ2VyU3RhdGVtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBEZWJ1Z2dlclN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRGVidWdnZXJTdGF0ZW1lbnQgPSBEZWJ1Z2dlclN0YXRlbWVudDtcclxuXHR2YXIgRGlyZWN0aXZlID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRGlyZWN0aXZlKGV4cHJlc3Npb24sIGRpcmVjdGl2ZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5kaXJlY3RpdmUgPSBkaXJlY3RpdmU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIERpcmVjdGl2ZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRGlyZWN0aXZlID0gRGlyZWN0aXZlO1xyXG5cdHZhciBEb1doaWxlU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRG9XaGlsZVN0YXRlbWVudChib2R5LCB0ZXN0KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRG9XaGlsZVN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBEb1doaWxlU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Eb1doaWxlU3RhdGVtZW50ID0gRG9XaGlsZVN0YXRlbWVudDtcclxuXHR2YXIgRW1wdHlTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFbXB0eVN0YXRlbWVudCgpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FbXB0eVN0YXRlbWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRW1wdHlTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkVtcHR5U3RhdGVtZW50ID0gRW1wdHlTdGF0ZW1lbnQ7XHJcblx0dmFyIEV4cG9ydEFsbERlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRXhwb3J0QWxsRGVjbGFyYXRpb24oc291cmNlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRXhwb3J0QWxsRGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRXhwb3J0QWxsRGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkV4cG9ydEFsbERlY2xhcmF0aW9uID0gRXhwb3J0QWxsRGVjbGFyYXRpb247XHJcblx0dmFyIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihkZWNsYXJhdGlvbikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24gPSBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb247XHJcblx0dmFyIEV4cG9ydE5hbWVkRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFeHBvcnROYW1lZERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLCBzcGVjaWZpZXJzLCBzb3VyY2UpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FeHBvcnROYW1lZERlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5kZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5zcGVjaWZpZXJzID0gc3BlY2lmaWVycztcclxuXHQgICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBFeHBvcnROYW1lZERlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FeHBvcnROYW1lZERlY2xhcmF0aW9uID0gRXhwb3J0TmFtZWREZWNsYXJhdGlvbjtcclxuXHR2YXIgRXhwb3J0U3BlY2lmaWVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRXhwb3J0U3BlY2lmaWVyKGxvY2FsLCBleHBvcnRlZCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cG9ydFNwZWNpZmllcjtcclxuXHQgICAgICAgIHRoaXMuZXhwb3J0ZWQgPSBleHBvcnRlZDtcclxuXHQgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRXhwb3J0U3BlY2lmaWVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FeHBvcnRTcGVjaWZpZXIgPSBFeHBvcnRTcGVjaWZpZXI7XHJcblx0dmFyIEV4cHJlc3Npb25TdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFeHByZXNzaW9uU3RhdGVtZW50KGV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRXhwcmVzc2lvblN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRXhwcmVzc2lvblN0YXRlbWVudCA9IEV4cHJlc3Npb25TdGF0ZW1lbnQ7XHJcblx0dmFyIEZvckluU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRm9ySW5TdGF0ZW1lbnQobGVmdCwgcmlnaHQsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Gb3JJblN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5lYWNoID0gZmFsc2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEZvckluU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Gb3JJblN0YXRlbWVudCA9IEZvckluU3RhdGVtZW50O1xyXG5cdHZhciBGb3JPZlN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEZvck9mU3RhdGVtZW50KGxlZnQsIHJpZ2h0LCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRm9yT2ZTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRm9yT2ZTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkZvck9mU3RhdGVtZW50ID0gRm9yT2ZTdGF0ZW1lbnQ7XHJcblx0dmFyIEZvclN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEZvclN0YXRlbWVudChpbml0LCB0ZXN0LCB1cGRhdGUsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Gb3JTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmluaXQgPSBpbml0O1xyXG5cdCAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcclxuXHQgICAgICAgIHRoaXMudXBkYXRlID0gdXBkYXRlO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRm9yU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Gb3JTdGF0ZW1lbnQgPSBGb3JTdGF0ZW1lbnQ7XHJcblx0dmFyIEZ1bmN0aW9uRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBGdW5jdGlvbkRlY2xhcmF0aW9uKGlkLCBwYXJhbXMsIGJvZHksIGdlbmVyYXRvcikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGdlbmVyYXRvcjtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5hc3luYyA9IGZhbHNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBGdW5jdGlvbkRlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5GdW5jdGlvbkRlY2xhcmF0aW9uID0gRnVuY3Rpb25EZWNsYXJhdGlvbjtcclxuXHR2YXIgRnVuY3Rpb25FeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRnVuY3Rpb25FeHByZXNzaW9uKGlkLCBwYXJhbXMsIGJvZHksIGdlbmVyYXRvcikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmFzeW5jID0gZmFsc2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEZ1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRnVuY3Rpb25FeHByZXNzaW9uID0gRnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdHZhciBJZGVudGlmaWVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSWRlbnRpZmllcihuYW1lKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcjtcclxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIElkZW50aWZpZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLklkZW50aWZpZXIgPSBJZGVudGlmaWVyO1xyXG5cdHZhciBJZlN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIElmU3RhdGVtZW50KHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LklmU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcclxuXHQgICAgICAgIHRoaXMuY29uc2VxdWVudCA9IGNvbnNlcXVlbnQ7XHJcblx0ICAgICAgICB0aGlzLmFsdGVybmF0ZSA9IGFsdGVybmF0ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSWZTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLklmU3RhdGVtZW50ID0gSWZTdGF0ZW1lbnQ7XHJcblx0dmFyIEltcG9ydERlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSW1wb3J0RGVjbGFyYXRpb24oc3BlY2lmaWVycywgc291cmNlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSW1wb3J0RGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLnNwZWNpZmllcnMgPSBzcGVjaWZpZXJzO1xyXG5cdCAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEltcG9ydERlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5JbXBvcnREZWNsYXJhdGlvbiA9IEltcG9ydERlY2xhcmF0aW9uO1xyXG5cdHZhciBJbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSW1wb3J0RGVmYXVsdFNwZWNpZmllcihsb2NhbCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkltcG9ydERlZmF1bHRTcGVjaWZpZXI7XHJcblx0ICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEltcG9ydERlZmF1bHRTcGVjaWZpZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBJbXBvcnREZWZhdWx0U3BlY2lmaWVyO1xyXG5cdHZhciBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIobG9jYWwpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI7XHJcblx0ICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xyXG5cdHZhciBJbXBvcnRTcGVjaWZpZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBJbXBvcnRTcGVjaWZpZXIobG9jYWwsIGltcG9ydGVkKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSW1wb3J0U3BlY2lmaWVyO1xyXG5cdCAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xyXG5cdCAgICAgICAgdGhpcy5pbXBvcnRlZCA9IGltcG9ydGVkO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBJbXBvcnRTcGVjaWZpZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkltcG9ydFNwZWNpZmllciA9IEltcG9ydFNwZWNpZmllcjtcclxuXHR2YXIgTGFiZWxlZFN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIExhYmVsZWRTdGF0ZW1lbnQobGFiZWwsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5MYWJlbGVkU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gTGFiZWxlZFN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuTGFiZWxlZFN0YXRlbWVudCA9IExhYmVsZWRTdGF0ZW1lbnQ7XHJcblx0dmFyIExpdGVyYWwgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBMaXRlcmFsKHZhbHVlLCByYXcpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5MaXRlcmFsO1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgdGhpcy5yYXcgPSByYXc7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIExpdGVyYWw7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkxpdGVyYWwgPSBMaXRlcmFsO1xyXG5cdHZhciBNZXRhUHJvcGVydHkgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBNZXRhUHJvcGVydHkobWV0YSwgcHJvcGVydHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5NZXRhUHJvcGVydHk7XHJcblx0ICAgICAgICB0aGlzLm1ldGEgPSBtZXRhO1xyXG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBNZXRhUHJvcGVydHk7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLk1ldGFQcm9wZXJ0eSA9IE1ldGFQcm9wZXJ0eTtcclxuXHR2YXIgTWV0aG9kRGVmaW5pdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIE1ldGhvZERlZmluaXRpb24oa2V5LCBjb21wdXRlZCwgdmFsdWUsIGtpbmQsIGlzU3RhdGljKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTWV0aG9kRGVmaW5pdGlvbjtcclxuXHQgICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG5cdCAgICAgICAgdGhpcy5jb21wdXRlZCA9IGNvbXB1dGVkO1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgdGhpcy5raW5kID0ga2luZDtcclxuXHQgICAgICAgIHRoaXMuc3RhdGljID0gaXNTdGF0aWM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIE1ldGhvZERlZmluaXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLk1ldGhvZERlZmluaXRpb24gPSBNZXRob2REZWZpbml0aW9uO1xyXG5cdHZhciBNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBNb2R1bGUoYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlByb2dyYW07XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5zb3VyY2VUeXBlID0gJ21vZHVsZSc7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIE1vZHVsZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuTW9kdWxlID0gTW9kdWxlO1xyXG5cdHZhciBOZXdFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gTmV3RXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5OZXdFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5jYWxsZWUgPSBjYWxsZWU7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3M7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIE5ld0V4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLk5ld0V4cHJlc3Npb24gPSBOZXdFeHByZXNzaW9uO1xyXG5cdHZhciBPYmplY3RFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gT2JqZWN0RXhwcmVzc2lvbihwcm9wZXJ0aWVzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguT2JqZWN0RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIE9iamVjdEV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLk9iamVjdEV4cHJlc3Npb24gPSBPYmplY3RFeHByZXNzaW9uO1xyXG5cdHZhciBPYmplY3RQYXR0ZXJuID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gT2JqZWN0UGF0dGVybihwcm9wZXJ0aWVzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguT2JqZWN0UGF0dGVybjtcclxuXHQgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIE9iamVjdFBhdHRlcm47XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLk9iamVjdFBhdHRlcm4gPSBPYmplY3RQYXR0ZXJuO1xyXG5cdHZhciBQcm9wZXJ0eSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFByb3BlcnR5KGtpbmQsIGtleSwgY29tcHV0ZWQsIHZhbHVlLCBtZXRob2QsIHNob3J0aGFuZCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlByb3BlcnR5O1xyXG5cdCAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcblx0ICAgICAgICB0aGlzLmNvbXB1dGVkID0gY29tcHV0ZWQ7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xyXG5cdCAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XHJcblx0ICAgICAgICB0aGlzLnNob3J0aGFuZCA9IHNob3J0aGFuZDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gUHJvcGVydHk7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlByb3BlcnR5ID0gUHJvcGVydHk7XHJcblx0dmFyIFJlZ2V4TGl0ZXJhbCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFJlZ2V4TGl0ZXJhbCh2YWx1ZSwgcmF3LCBwYXR0ZXJuLCBmbGFncykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkxpdGVyYWw7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgICAgICB0aGlzLnJhdyA9IHJhdztcclxuXHQgICAgICAgIHRoaXMucmVnZXggPSB7IHBhdHRlcm46IHBhdHRlcm4sIGZsYWdzOiBmbGFncyB9O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBSZWdleExpdGVyYWw7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlJlZ2V4TGl0ZXJhbCA9IFJlZ2V4TGl0ZXJhbDtcclxuXHR2YXIgUmVzdEVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBSZXN0RWxlbWVudChhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlJlc3RFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBSZXN0RWxlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuUmVzdEVsZW1lbnQgPSBSZXN0RWxlbWVudDtcclxuXHR2YXIgUmV0dXJuU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gUmV0dXJuU3RhdGVtZW50KGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguUmV0dXJuU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBSZXR1cm5TdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlJldHVyblN0YXRlbWVudCA9IFJldHVyblN0YXRlbWVudDtcclxuXHR2YXIgU2NyaXB0ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU2NyaXB0KGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Qcm9ncmFtO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuc291cmNlVHlwZSA9ICdzY3JpcHQnO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTY3JpcHQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlNjcmlwdCA9IFNjcmlwdDtcclxuXHR2YXIgU2VxdWVuY2VFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU2VxdWVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb25zKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguU2VxdWVuY2VFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTZXF1ZW5jZUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlNlcXVlbmNlRXhwcmVzc2lvbiA9IFNlcXVlbmNlRXhwcmVzc2lvbjtcclxuXHR2YXIgU3ByZWFkRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFNwcmVhZEVsZW1lbnQoYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5TcHJlYWRFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTcHJlYWRFbGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5TcHJlYWRFbGVtZW50ID0gU3ByZWFkRWxlbWVudDtcclxuXHR2YXIgU3RhdGljTWVtYmVyRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFN0YXRpY01lbWJlckV4cHJlc3Npb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk1lbWJlckV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmNvbXB1dGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHQgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU3RhdGljTWVtYmVyRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU3RhdGljTWVtYmVyRXhwcmVzc2lvbiA9IFN0YXRpY01lbWJlckV4cHJlc3Npb247XHJcblx0dmFyIFN1cGVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU3VwZXIoKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguU3VwZXI7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFN1cGVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5TdXBlciA9IFN1cGVyO1xyXG5cdHZhciBTd2l0Y2hDYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU3dpdGNoQ2FzZSh0ZXN0LCBjb25zZXF1ZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguU3dpdGNoQ2FzZTtcclxuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTd2l0Y2hDYXNlO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Td2l0Y2hDYXNlID0gU3dpdGNoQ2FzZTtcclxuXHR2YXIgU3dpdGNoU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU3dpdGNoU3RhdGVtZW50KGRpc2NyaW1pbmFudCwgY2FzZXMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Td2l0Y2hTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmRpc2NyaW1pbmFudCA9IGRpc2NyaW1pbmFudDtcclxuXHQgICAgICAgIHRoaXMuY2FzZXMgPSBjYXNlcztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU3dpdGNoU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Td2l0Y2hTdGF0ZW1lbnQgPSBTd2l0Y2hTdGF0ZW1lbnQ7XHJcblx0dmFyIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbih0YWcsIHF1YXNpKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy50YWcgPSB0YWc7XHJcblx0ICAgICAgICB0aGlzLnF1YXNpID0gcXVhc2k7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uID0gVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xyXG5cdHZhciBUZW1wbGF0ZUVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUZW1wbGF0ZUVsZW1lbnQodmFsdWUsIHRhaWwpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5UZW1wbGF0ZUVsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgICAgICB0aGlzLnRhaWwgPSB0YWlsO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBUZW1wbGF0ZUVsZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRlbXBsYXRlRWxlbWVudCA9IFRlbXBsYXRlRWxlbWVudDtcclxuXHR2YXIgVGVtcGxhdGVMaXRlcmFsID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVGVtcGxhdGVMaXRlcmFsKHF1YXNpcywgZXhwcmVzc2lvbnMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5UZW1wbGF0ZUxpdGVyYWw7XHJcblx0ICAgICAgICB0aGlzLnF1YXNpcyA9IHF1YXNpcztcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVGVtcGxhdGVMaXRlcmFsO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWwgPSBUZW1wbGF0ZUxpdGVyYWw7XHJcblx0dmFyIFRoaXNFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVGhpc0V4cHJlc3Npb24oKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVGhpc0V4cHJlc3Npb247XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFRoaXNFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5UaGlzRXhwcmVzc2lvbiA9IFRoaXNFeHByZXNzaW9uO1xyXG5cdHZhciBUaHJvd1N0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRocm93U3RhdGVtZW50KGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVGhyb3dTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFRocm93U3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5UaHJvd1N0YXRlbWVudCA9IFRocm93U3RhdGVtZW50O1xyXG5cdHZhciBUcnlTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUcnlTdGF0ZW1lbnQoYmxvY2ssIGhhbmRsZXIsIGZpbmFsaXplcikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlRyeVN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcclxuXHQgICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XHJcblx0ICAgICAgICB0aGlzLmZpbmFsaXplciA9IGZpbmFsaXplcjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVHJ5U3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5UcnlTdGF0ZW1lbnQgPSBUcnlTdGF0ZW1lbnQ7XHJcblx0dmFyIFVuYXJ5RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFVuYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5VbmFyeUV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLnByZWZpeCA9IHRydWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFVuYXJ5RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVW5hcnlFeHByZXNzaW9uID0gVW5hcnlFeHByZXNzaW9uO1xyXG5cdHZhciBVcGRhdGVFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVXBkYXRlRXhwcmVzc2lvbihvcGVyYXRvciwgYXJndW1lbnQsIHByZWZpeCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlVwZGF0ZUV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVXBkYXRlRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVXBkYXRlRXhwcmVzc2lvbiA9IFVwZGF0ZUV4cHJlc3Npb247XHJcblx0dmFyIFZhcmlhYmxlRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBWYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmRlY2xhcmF0aW9ucyA9IGRlY2xhcmF0aW9ucztcclxuXHQgICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFZhcmlhYmxlRGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlZhcmlhYmxlRGVjbGFyYXRpb24gPSBWYXJpYWJsZURlY2xhcmF0aW9uO1xyXG5cdHZhciBWYXJpYWJsZURlY2xhcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBWYXJpYWJsZURlY2xhcmF0b3IoaWQsIGluaXQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLmluaXQgPSBpbml0O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBWYXJpYWJsZURlY2xhcmF0b3I7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlZhcmlhYmxlRGVjbGFyYXRvciA9IFZhcmlhYmxlRGVjbGFyYXRvcjtcclxuXHR2YXIgV2hpbGVTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBXaGlsZVN0YXRlbWVudCh0ZXN0LCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguV2hpbGVTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gV2hpbGVTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLldoaWxlU3RhdGVtZW50ID0gV2hpbGVTdGF0ZW1lbnQ7XHJcblx0dmFyIFdpdGhTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBXaXRoU3RhdGVtZW50KG9iamVjdCwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LldpdGhTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFdpdGhTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLldpdGhTdGF0ZW1lbnQgPSBXaXRoU3RhdGVtZW50O1xyXG5cdHZhciBZaWVsZEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBZaWVsZEV4cHJlc3Npb24oYXJndW1lbnQsIGRlbGVnYXRlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguWWllbGRFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBZaWVsZEV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLllpZWxkRXhwcmVzc2lvbiA9IFlpZWxkRXhwcmVzc2lvbjtcclxuXG5cbi8qKiovIH0sXG4vKiA4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIGFzc2VydF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxuXHR2YXIgZXJyb3JfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcblx0dmFyIG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxuXHR2YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcblx0dmFyIHNjYW5uZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG5cdHZhciBzeW50YXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblx0dmFyIHRva2VuXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxuXHR2YXIgQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlciA9ICdBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyJztcclxuXHR2YXIgUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gUGFyc2VyKGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XHJcblx0ICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG5cdCAgICAgICAgdGhpcy5jb25maWcgPSB7XHJcblx0ICAgICAgICAgICAgcmFuZ2U6ICh0eXBlb2Ygb3B0aW9ucy5yYW5nZSA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnJhbmdlLFxyXG5cdCAgICAgICAgICAgIGxvYzogKHR5cGVvZiBvcHRpb25zLmxvYyA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLmxvYyxcclxuXHQgICAgICAgICAgICBzb3VyY2U6IG51bGwsXHJcblx0ICAgICAgICAgICAgdG9rZW5zOiAodHlwZW9mIG9wdGlvbnMudG9rZW5zID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMudG9rZW5zLFxyXG5cdCAgICAgICAgICAgIGNvbW1lbnQ6ICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMuY29tbWVudCxcclxuXHQgICAgICAgICAgICB0b2xlcmFudDogKHR5cGVvZiBvcHRpb25zLnRvbGVyYW50ID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMudG9sZXJhbnRcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcubG9jICYmIG9wdGlvbnMuc291cmNlICYmIG9wdGlvbnMuc291cmNlICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb25maWcuc291cmNlID0gU3RyaW5nKG9wdGlvbnMuc291cmNlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gbmV3IGVycm9yX2hhbmRsZXJfMS5FcnJvckhhbmRsZXIoKTtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLnRvbGVyYW50ID0gdGhpcy5jb25maWcudG9sZXJhbnQ7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIgPSBuZXcgc2Nhbm5lcl8xLlNjYW5uZXIoY29kZSwgdGhpcy5lcnJvckhhbmRsZXIpO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLnRyYWNrQ29tbWVudCA9IHRoaXMuY29uZmlnLmNvbW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLm9wZXJhdG9yUHJlY2VkZW5jZSA9IHtcclxuXHQgICAgICAgICAgICAnKSc6IDAsXHJcblx0ICAgICAgICAgICAgJzsnOiAwLFxyXG5cdCAgICAgICAgICAgICcsJzogMCxcclxuXHQgICAgICAgICAgICAnPSc6IDAsXHJcblx0ICAgICAgICAgICAgJ10nOiAwLFxyXG5cdCAgICAgICAgICAgICd8fCc6IDEsXHJcblx0ICAgICAgICAgICAgJyYmJzogMixcclxuXHQgICAgICAgICAgICAnfCc6IDMsXHJcblx0ICAgICAgICAgICAgJ14nOiA0LFxyXG5cdCAgICAgICAgICAgICcmJzogNSxcclxuXHQgICAgICAgICAgICAnPT0nOiA2LFxyXG5cdCAgICAgICAgICAgICchPSc6IDYsXHJcblx0ICAgICAgICAgICAgJz09PSc6IDYsXHJcblx0ICAgICAgICAgICAgJyE9PSc6IDYsXHJcblx0ICAgICAgICAgICAgJzwnOiA3LFxyXG5cdCAgICAgICAgICAgICc+JzogNyxcclxuXHQgICAgICAgICAgICAnPD0nOiA3LFxyXG5cdCAgICAgICAgICAgICc+PSc6IDcsXHJcblx0ICAgICAgICAgICAgJzw8JzogOCxcclxuXHQgICAgICAgICAgICAnPj4nOiA4LFxyXG5cdCAgICAgICAgICAgICc+Pj4nOiA4LFxyXG5cdCAgICAgICAgICAgICcrJzogOSxcclxuXHQgICAgICAgICAgICAnLSc6IDksXHJcblx0ICAgICAgICAgICAgJyonOiAxMSxcclxuXHQgICAgICAgICAgICAnLyc6IDExLFxyXG5cdCAgICAgICAgICAgICclJzogMTFcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICB0aGlzLmxvb2thaGVhZCA9IHtcclxuXHQgICAgICAgICAgICB0eXBlOiAyIC8qIEVPRiAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogJycsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiAwLFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiAwLFxyXG5cdCAgICAgICAgICAgIGVuZDogMFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIHRoaXMuaGFzTGluZVRlcm1pbmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dCA9IHtcclxuXHQgICAgICAgICAgICBpc01vZHVsZTogZmFsc2UsXHJcblx0ICAgICAgICAgICAgYXdhaXQ6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGFsbG93SW46IHRydWUsXHJcblx0ICAgICAgICAgICAgYWxsb3dTdHJpY3REaXJlY3RpdmU6IHRydWUsXHJcblx0ICAgICAgICAgICAgYWxsb3dZaWVsZDogdHJ1ZSxcclxuXHQgICAgICAgICAgICBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I6IG51bGwsXHJcblx0ICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0OiBmYWxzZSxcclxuXHQgICAgICAgICAgICBpc0JpbmRpbmdFbGVtZW50OiBmYWxzZSxcclxuXHQgICAgICAgICAgICBpbkZ1bmN0aW9uQm9keTogZmFsc2UsXHJcblx0ICAgICAgICAgICAgaW5JdGVyYXRpb246IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGluU3dpdGNoOiBmYWxzZSxcclxuXHQgICAgICAgICAgICBsYWJlbFNldDoge30sXHJcblx0ICAgICAgICAgICAgc3RyaWN0OiBmYWxzZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIHRoaXMudG9rZW5zID0gW107XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyID0ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiAwLFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogMFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlciA9IHtcclxuXHQgICAgICAgICAgICBpbmRleDogMCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBjb2x1bW46IDBcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyID0ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiB0aGlzLnNjYW5uZXIuaW5kZXgsXHJcblx0ICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUudGhyb3dFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlRm9ybWF0KSB7XHJcblx0ICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG5cdCAgICAgICAgICAgIHZhbHVlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHQgICAgICAgIHZhciBtc2cgPSBtZXNzYWdlRm9ybWF0LnJlcGxhY2UoLyUoXFxkKS9nLCBmdW5jdGlvbiAod2hvbGUsIGlkeCkge1xyXG5cdCAgICAgICAgICAgIGFzc2VydF8xLmFzc2VydChpZHggPCBhcmdzLmxlbmd0aCwgJ01lc3NhZ2UgcmVmZXJlbmNlIG11c3QgYmUgaW4gcmFuZ2UnKTtcclxuXHQgICAgICAgICAgICByZXR1cm4gYXJnc1tpZHhdO1xyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxhc3RNYXJrZXIuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgbGluZSA9IHRoaXMubGFzdE1hcmtlci5saW5lO1xyXG5cdCAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubGFzdE1hcmtlci5jb2x1bW4gKyAxO1xyXG5cdCAgICAgICAgdGhyb3cgdGhpcy5lcnJvckhhbmRsZXIuY3JlYXRlRXJyb3IoaW5kZXgsIGxpbmUsIGNvbHVtbiwgbXNnKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS50b2xlcmF0ZUVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2VGb3JtYXQpIHtcclxuXHQgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuXHQgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcblx0ICAgICAgICAgICAgdmFsdWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cdCAgICAgICAgdmFyIG1zZyA9IG1lc3NhZ2VGb3JtYXQucmVwbGFjZSgvJShcXGQpL2csIGZ1bmN0aW9uICh3aG9sZSwgaWR4KSB7XHJcblx0ICAgICAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KGlkeCA8IGFyZ3MubGVuZ3RoLCAnTWVzc2FnZSByZWZlcmVuY2UgbXVzdCBiZSBpbiByYW5nZScpO1xyXG5cdCAgICAgICAgICAgIHJldHVybiBhcmdzW2lkeF07XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgICAgIHZhciBpbmRleCA9IHRoaXMubGFzdE1hcmtlci5pbmRleDtcclxuXHQgICAgICAgIHZhciBsaW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5sYXN0TWFya2VyLmNvbHVtbiArIDE7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlci50b2xlcmF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2x1bW4sIG1zZyk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIG9mIHRoZSB0b2tlbi5cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS51bmV4cGVjdGVkVG9rZW5FcnJvciA9IGZ1bmN0aW9uICh0b2tlbiwgbWVzc2FnZSkge1xyXG5cdCAgICAgICAgdmFyIG1zZyA9IG1lc3NhZ2UgfHwgbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW47XHJcblx0ICAgICAgICB2YXIgdmFsdWU7XHJcblx0ICAgICAgICBpZiAodG9rZW4pIHtcclxuXHQgICAgICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcclxuXHQgICAgICAgICAgICAgICAgbXNnID0gKHRva2VuLnR5cGUgPT09IDIgLyogRU9GICovKSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZEVPUyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZElkZW50aWZpZXIgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSA2IC8qIE51bWVyaWNMaXRlcmFsICovKSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZE51bWJlciA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSA4IC8qIFN0cmluZ0xpdGVyYWwgKi8pID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkU3RyaW5nIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSAxMCAvKiBUZW1wbGF0ZSAqLykgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUZW1wbGF0ZSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW47XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNGdXR1cmVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbXNnID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkUmVzZXJ2ZWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbXNnID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0b2tlbi52YWx1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gJ0lMTEVHQUwnO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgbXNnID0gbXNnLnJlcGxhY2UoJyUwJywgdmFsdWUpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuICYmIHR5cGVvZiB0b2tlbi5saW5lTnVtYmVyID09PSAnbnVtYmVyJykge1xyXG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IHRva2VuLnN0YXJ0O1xyXG5cdCAgICAgICAgICAgIHZhciBsaW5lID0gdG9rZW4ubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICB2YXIgbGFzdE1hcmtlckxpbmVTdGFydCA9IHRoaXMubGFzdE1hcmtlci5pbmRleCAtIHRoaXMubGFzdE1hcmtlci5jb2x1bW47XHJcblx0ICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHRva2VuLnN0YXJ0IC0gbGFzdE1hcmtlckxpbmVTdGFydCArIDE7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JIYW5kbGVyLmNyZWF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2x1bW4sIG1zZyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxhc3RNYXJrZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxhc3RNYXJrZXIubGluZTtcclxuXHQgICAgICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5sYXN0TWFya2VyLmNvbHVtbiArIDE7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JIYW5kbGVyLmNyZWF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2x1bW4sIG1zZyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUudGhyb3dVbmV4cGVjdGVkVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4sIG1lc3NhZ2UpIHtcclxuXHQgICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZFRva2VuRXJyb3IodG9rZW4sIG1lc3NhZ2UpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuID0gZnVuY3Rpb24gKHRva2VuLCBtZXNzYWdlKSB7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlci50b2xlcmF0ZSh0aGlzLnVuZXhwZWN0ZWRUb2tlbkVycm9yKHRva2VuLCBtZXNzYWdlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuY29sbGVjdENvbW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5jb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5zY2FubmVyLnNjYW5Db21tZW50cygpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNvbW1lbnRzID0gdGhpcy5zY2FubmVyLnNjYW5Db21tZW50cygpO1xyXG5cdCAgICAgICAgICAgIGlmIChjb21tZW50cy5sZW5ndGggPiAwICYmIHRoaXMuZGVsZWdhdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tZW50cy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBjb21tZW50c1tpXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gdm9pZCAwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBlLm11bHRpTGluZSA/ICdCbG9ja0NvbW1lbnQnIDogJ0xpbmVDb21tZW50JyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zY2FubmVyLnNvdXJjZS5zbGljZShlLnNsaWNlWzBdLCBlLnNsaWNlWzFdKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5yYW5nZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmFuZ2UgPSBlLnJhbmdlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubG9jID0gZS5sb2M7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogZS5sb2Muc3RhcnQubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBlLmxvYy5zdGFydC5jb2x1bW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogZS5yYW5nZVswXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGUubG9jLmVuZC5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGUubG9jLmVuZC5jb2x1bW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogZS5yYW5nZVsxXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlKG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLy8gRnJvbSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiB0byBhbiBleHRlcm5hbCBzdHJ1Y3R1cmVcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5nZXRUb2tlblJhdyA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbm5lci5zb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQsIHRva2VuLmVuZCk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuY29udmVydFRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICB2YXIgdCA9IHtcclxuXHQgICAgICAgICAgICB0eXBlOiB0b2tlbl8xLlRva2VuTmFtZVt0b2tlbi50eXBlXSxcclxuXHQgICAgICAgICAgICB2YWx1ZTogdGhpcy5nZXRUb2tlblJhdyh0b2tlbilcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcucmFuZ2UpIHtcclxuXHQgICAgICAgICAgICB0LnJhbmdlID0gW3Rva2VuLnN0YXJ0LCB0b2tlbi5lbmRdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvYykge1xyXG5cdCAgICAgICAgICAgIHQubG9jID0ge1xyXG5cdCAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5zdGFydE1hcmtlci5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDkgLyogUmVndWxhckV4cHJlc3Npb24gKi8pIHtcclxuXHQgICAgICAgICAgICB2YXIgcGF0dGVybiA9IHRva2VuLnBhdHRlcm47XHJcblx0ICAgICAgICAgICAgdmFyIGZsYWdzID0gdG9rZW4uZmxhZ3M7XHJcblx0ICAgICAgICAgICAgdC5yZWdleCA9IHsgcGF0dGVybjogcGF0dGVybiwgZmxhZ3M6IGZsYWdzIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5uZXh0VG9rZW4gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIHRoaXMuY29sbGVjdENvbW1lbnRzKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5zY2FubmVyLmluZGV4ICE9PSB0aGlzLnN0YXJ0TWFya2VyLmluZGV4KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5zdGFydE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbmV4dCA9IHRoaXMuc2Nhbm5lci5sZXgoKTtcclxuXHQgICAgICAgIHRoaXMuaGFzTGluZVRlcm1pbmF0b3IgPSAodG9rZW4ubGluZU51bWJlciAhPT0gbmV4dC5saW5lTnVtYmVyKTtcclxuXHQgICAgICAgIGlmIChuZXh0ICYmIHRoaXMuY29udGV4dC5zdHJpY3QgJiYgbmV4dC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChuZXh0LnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICBuZXh0LnR5cGUgPSA0IC8qIEtleXdvcmQgKi87XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5sb29rYWhlYWQgPSBuZXh0O1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRva2VucyAmJiBuZXh0LnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0aGlzLmNvbnZlcnRUb2tlbihuZXh0KSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdG9rZW47XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubmV4dFJlZ2V4VG9rZW4gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmNvbGxlY3RDb21tZW50cygpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5zY2FubmVyLnNjYW5SZWdFeHAoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy50b2tlbnMpIHtcclxuXHQgICAgICAgICAgICAvLyBQb3AgdGhlIHByZXZpb3VzIHRva2VuLCAnLycgb3IgJy89J1xyXG5cdCAgICAgICAgICAgIC8vIFRoaXMgaXMgYWRkZWQgZnJvbSB0aGUgbG9va2FoZWFkIHRva2VuLlxyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnBvcCgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2godGhpcy5jb252ZXJ0VG9rZW4odG9rZW4pKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFByaW1lIHRoZSBuZXh0IGxvb2thaGVhZC5cclxuXHQgICAgICAgIHRoaXMubG9va2FoZWFkID0gdG9rZW47XHJcblx0ICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRva2VuO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmNyZWF0ZU5vZGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiB0aGlzLnN0YXJ0TWFya2VyLmluZGV4LFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc3RhcnRNYXJrZXIubGluZSxcclxuXHQgICAgICAgICAgICBjb2x1bW46IHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnN0YXJ0Tm9kZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBpbmRleDogdG9rZW4uc3RhcnQsXHJcblx0ICAgICAgICAgICAgbGluZTogdG9rZW4ubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBjb2x1bW46IHRva2VuLnN0YXJ0IC0gdG9rZW4ubGluZVN0YXJ0XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKG1hcmtlciwgbm9kZSkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnJhbmdlKSB7XHJcblx0ICAgICAgICAgICAgbm9kZS5yYW5nZSA9IFttYXJrZXIuaW5kZXgsIHRoaXMubGFzdE1hcmtlci5pbmRleF07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcubG9jKSB7XHJcblx0ICAgICAgICAgICAgbm9kZS5sb2MgPSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiBtYXJrZXIubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogbWFya2VyLmNvbHVtbixcclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxhc3RNYXJrZXIubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5sYXN0TWFya2VyLmNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb25maWcuc291cmNlKSB7XHJcblx0ICAgICAgICAgICAgICAgIG5vZGUubG9jLnNvdXJjZSA9IHRoaXMuY29uZmlnLnNvdXJjZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHtcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IG1hcmtlci5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBtYXJrZXIuY29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBtYXJrZXIuaW5kZXhcclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxhc3RNYXJrZXIubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5sYXN0TWFya2VyLmNvbHVtbixcclxuXHQgICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5sYXN0TWFya2VyLmluZGV4XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIG5vZGU7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIEV4cGVjdCB0aGUgbmV4dCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXHJcblx0ICAgIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmV4cGVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSA3IC8qIFB1bmN0dWF0b3IgKi8gfHwgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFF1aWV0bHkgZXhwZWN0IGEgY29tbWEgd2hlbiBpbiB0b2xlcmFudCBtb2RlLCBvdGhlcndpc2UgZGVsZWdhdGVzIHRvIGV4cGVjdCgpLlxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmV4cGVjdENvbW1hU2VwYXJhdG9yID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJywnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJzsnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIEV4cGVjdCB0aGUgbmV4dCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIGtleXdvcmQuXHJcblx0ICAgIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmV4cGVjdEtleXdvcmQgPSBmdW5jdGlvbiAoa2V5d29yZCkge1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSA0IC8qIEtleXdvcmQgKi8gfHwgdG9rZW4udmFsdWUgIT09IGtleXdvcmQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmxvb2thaGVhZC50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgdGhpcy5sb29rYWhlYWQudmFsdWUgPT09IHZhbHVlO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQga2V5d29yZFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm1hdGNoS2V5d29yZCA9IGZ1bmN0aW9uIChrZXl3b3JkKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5sb29rYWhlYWQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSBrZXl3b3JkO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgY29udGV4dHVhbCBrZXl3b3JkXHJcblx0ICAgIC8vICh3aGVyZSBhbiBpZGVudGlmaWVyIGlzIHNvbWV0aW1lcyBhIGtleXdvcmQgZGVwZW5kaW5nIG9uIHRoZSBjb250ZXh0KVxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm1hdGNoQ29udGV4dHVhbEtleXdvcmQgPSBmdW5jdGlvbiAoa2V5d29yZCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiB0aGlzLmxvb2thaGVhZC52YWx1ZSA9PT0ga2V5d29yZDtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gaXMgYW4gYXNzaWdubWVudCBvcGVyYXRvclxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm1hdGNoQXNzaWduID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDcgLyogUHVuY3R1YXRvciAqLykge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBvcCA9IHRoaXMubG9va2FoZWFkLnZhbHVlO1xyXG5cdCAgICAgICAgcmV0dXJuIG9wID09PSAnPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJyo9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnKio9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnLz0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICclPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJys9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnLT0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICc8PD0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICc+Pj0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICc+Pj49JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnJj0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICdePScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJ3w9JztcclxuXHQgICAgfTtcclxuXHQgICAgLy8gQ292ZXIgZ3JhbW1hciBzdXBwb3J0LlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyBXaGVuIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiBwb3NpdGlvbiBzdGFydHMgd2l0aCBhbiBsZWZ0IHBhcmVudGhlc2lzLCB0aGUgZGV0ZXJtaW5hdGlvbiBvZiB0aGUgdHlwZVxyXG5cdCAgICAvLyBvZiB0aGUgc3ludGF4IGlzIHRvIGJlIGRlZmVycmVkIGFyYml0cmFyaWx5IGxvbmcgdW50aWwgdGhlIGVuZCBvZiB0aGUgcGFyZW50aGVzZXMgcGFpciAocGx1cyBhIGxvb2thaGVhZClcclxuXHQgICAgLy8gb3IgdGhlIGZpcnN0IGNvbW1hLiBUaGlzIHNpdHVhdGlvbiBhbHNvIGRlZmVycyB0aGUgZGV0ZXJtaW5hdGlvbiBvZiBhbGwgdGhlIGV4cHJlc3Npb25zIG5lc3RlZCBpbiB0aGUgcGFpci5cclxuXHQgICAgLy9cclxuXHQgICAgLy8gVGhlcmUgYXJlIHRocmVlIHByb2R1Y3Rpb25zIHRoYXQgY2FuIGJlIHBhcnNlZCBpbiBhIHBhcmVudGhlc2VzIHBhaXIgdGhhdCBuZWVkcyB0byBiZSBkZXRlcm1pbmVkXHJcblx0ICAgIC8vIGFmdGVyIHRoZSBvdXRlcm1vc3QgcGFpciBpcyBjbG9zZWQuIFRoZXkgYXJlOlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyAgIDEuIEFzc2lnbm1lbnRFeHByZXNzaW9uXHJcblx0ICAgIC8vICAgMi4gQmluZGluZ0VsZW1lbnRzXHJcblx0ICAgIC8vICAgMy4gQXNzaWdubWVudFRhcmdldHNcclxuXHQgICAgLy9cclxuXHQgICAgLy8gSW4gb3JkZXIgdG8gYXZvaWQgZXhwb25lbnRpYWwgYmFja3RyYWNraW5nLCB3ZSB1c2UgdHdvIGZsYWdzIHRvIGRlbm90ZSBpZiB0aGUgcHJvZHVjdGlvbiBjYW4gYmVcclxuXHQgICAgLy8gYmluZGluZyBlbGVtZW50IG9yIGFzc2lnbm1lbnQgdGFyZ2V0LlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyBUaGUgdGhyZWUgcHJvZHVjdGlvbnMgaGF2ZSB0aGUgcmVsYXRpb25zaGlwOlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyAgIEJpbmRpbmdFbGVtZW50cyDiioYgQXNzaWdubWVudFRhcmdldHMg4oqGIEFzc2lnbm1lbnRFeHByZXNzaW9uXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIHdpdGggYSBzaW5nbGUgZXhjZXB0aW9uIHRoYXQgQ292ZXJJbml0aWFsaXplZE5hbWUgd2hlbiB1c2VkIGRpcmVjdGx5IGluIGFuIEV4cHJlc3Npb24sIGdlbmVyYXRlc1xyXG5cdCAgICAvLyBhbiBlYXJseSBlcnJvci4gVGhlcmVmb3JlLCB3ZSBuZWVkIHRoZSB0aGlyZCBzdGF0ZSwgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yLCB0byB0cmFjayB0aGVcclxuXHQgICAgLy8gZmlyc3QgdXNhZ2Ugb2YgQ292ZXJJbml0aWFsaXplZE5hbWUgYW5kIHJlcG9ydCBpdCB3aGVuIHdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgcGFyZW50aGVzZXMgcGFpci5cclxuXHQgICAgLy9cclxuXHQgICAgLy8gaXNvbGF0ZUNvdmVyR3JhbW1hciBmdW5jdGlvbiBydW5zIHRoZSBnaXZlbiBwYXJzZXIgZnVuY3Rpb24gd2l0aCBhIG5ldyBjb3ZlciBncmFtbWFyIGNvbnRleHQsIGFuZCBpdCBkb2VzIG5vdFxyXG5cdCAgICAvLyBlZmZlY3QgdGhlIGN1cnJlbnQgZmxhZ3MuIFRoaXMgbWVhbnMgdGhlIHByb2R1Y3Rpb24gdGhlIHBhcnNlciBwYXJzZXMgaXMgb25seSB1c2VkIGFzIGFuIGV4cHJlc3Npb24uIFRoZXJlZm9yZVxyXG5cdCAgICAvLyB0aGUgQ292ZXJJbml0aWFsaXplZE5hbWUgY2hlY2sgaXMgY29uZHVjdGVkLlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyBpbmhlcml0Q292ZXJHcmFtbWFyIGZ1bmN0aW9uIHJ1bnMgdGhlIGdpdmVuIHBhcnNlIGZ1bmN0aW9uIHdpdGggYSBuZXcgY292ZXIgZ3JhbW1hciBjb250ZXh0LCBhbmQgaXQgcHJvcGFnYXRlc1xyXG5cdCAgICAvLyB0aGUgZmxhZ3Mgb3V0c2lkZSBvZiB0aGUgcGFyc2VyLiBUaGlzIG1lYW5zIHRoZSBwcm9kdWN0aW9uIHRoZSBwYXJzZXIgcGFyc2VzIGlzIHVzZWQgYXMgYSBwYXJ0IG9mIGEgcG90ZW50aWFsXHJcblx0ICAgIC8vIHBhdHRlcm4uIFRoZSBDb3ZlckluaXRpYWxpemVkTmFtZSBjaGVjayBpcyBkZWZlcnJlZC5cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5pc29sYXRlQ292ZXJHcmFtbWFyID0gZnVuY3Rpb24gKHBhcnNlRnVuY3Rpb24pIHtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0lzQmluZGluZ0VsZW1lbnQgPSB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0lzQXNzaWdubWVudFRhcmdldCA9IHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcclxuXHQgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUZ1bmN0aW9uLmNhbGwodGhpcyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IHByZXZpb3VzSXNCaW5kaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBwcmV2aW91c0lzQXNzaWdubWVudFRhcmdldDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBwcmV2aW91c0ZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcjtcclxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuaW5oZXJpdENvdmVyR3JhbW1hciA9IGZ1bmN0aW9uIChwYXJzZUZ1bmN0aW9uKSB7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJc0JpbmRpbmdFbGVtZW50ID0gdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJc0Fzc2lnbm1lbnRUYXJnZXQgPSB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcjtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VGdW5jdGlvbi5jYWxsKHRoaXMpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCAmJiBwcmV2aW91c0lzQmluZGluZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCAmJiBwcmV2aW91c0lzQXNzaWdubWVudFRhcmdldDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBwcmV2aW91c0ZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciB8fCB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xyXG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5jb25zdW1lU2VtaWNvbG9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJzsnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICghdGhpcy5oYXNMaW5lVGVybWluYXRvcikge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLyAmJiAhdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmxhc3RNYXJrZXIuaW5kZXggPSB0aGlzLnN0YXJ0TWFya2VyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHRoaXMubGFzdE1hcmtlci5saW5lID0gdGhpcy5zdGFydE1hcmtlci5saW5lO1xyXG5cdCAgICAgICAgICAgIHRoaXMubGFzdE1hcmtlci5jb2x1bW4gPSB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtbjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHJpbWFyeS1leHByZXNzaW9uXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQcmltYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIHZhciB0b2tlbiwgcmF3O1xyXG5cdCAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAzIC8qIElkZW50aWZpZXIgKi86XHJcblx0ICAgICAgICAgICAgICAgIGlmICgodGhpcy5jb250ZXh0LmlzTW9kdWxlIHx8IHRoaXMuY29udGV4dC5hd2FpdCkgJiYgdGhpcy5sb29rYWhlYWQudmFsdWUgPT09ICdhd2FpdCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLm1hdGNoQXN5bmNGdW5jdGlvbigpID8gdGhpcy5wYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbigpIDogdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKHRoaXMubmV4dFRva2VuKCkudmFsdWUpKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA2IC8qIE51bWVyaWNMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgOCAvKiBTdHJpbmdMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLmxvb2thaGVhZC5vY3RhbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTGl0ZXJhbCh0b2tlbi52YWx1ZSwgcmF3KSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgMSAvKiBCb29sZWFuTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5MaXRlcmFsKHRva2VuLnZhbHVlID09PSAndHJ1ZScsIHJhdykpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDUgLyogTnVsbExpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTGl0ZXJhbChudWxsLCByYXcpKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAxMCAvKiBUZW1wbGF0ZSAqLzpcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VUZW1wbGF0ZUxpdGVyYWwoKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA3IC8qIFB1bmN0dWF0b3IgKi86XHJcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJygnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlR3JvdXBFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1snOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFycmF5SW5pdGlhbGl6ZXIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAneyc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlT2JqZWN0SW5pdGlhbGl6ZXIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnLyc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICcvPSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLmluZGV4ID0gdGhpcy5zdGFydE1hcmtlci5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFJlZ2V4VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5SZWdleExpdGVyYWwodG9rZW4ucmVnZXgsIHJhdywgdG9rZW4ucGF0dGVybiwgdG9rZW4uZmxhZ3MpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA0IC8qIEtleXdvcmQgKi86XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCAmJiB0aGlzLm1hdGNoS2V5d29yZCgneWllbGQnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMubWF0Y2hLZXl3b3JkKCdsZXQnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0aGlzLm5leHRUb2tlbigpLnZhbHVlKSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdmdW5jdGlvbicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCd0aGlzJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRoaXNFeHByZXNzaW9uKCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2NsYXNzJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZUNsYXNzRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXktaW5pdGlhbGl6ZXJcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNwcmVhZEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJy4uLicpO1xyXG5cdCAgICAgICAgdmFyIGFyZyA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuU3ByZWFkRWxlbWVudChhcmcpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFycmF5SW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnWycpO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCddJykpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobnVsbCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJy4uLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wYXJzZVNwcmVhZEVsZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCddJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCddJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnXScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXJyYXlFeHByZXNzaW9uKGVsZW1lbnRzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC1pbml0aWFsaXplclxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJvcGVydHlNZXRob2QgPSBmdW5jdGlvbiAocGFyYW1zKSB7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0ID0gdGhpcy5jb250ZXh0LnN0cmljdDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlID0gdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gcGFyYW1zLnNpbXBsZTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHBhcmFtcy5maXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHBhcmFtcy5maXJzdFJlc3RyaWN0ZWQsIHBhcmFtcy5tZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHBhcmFtcy5zdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4ocGFyYW1zLnN0cmljdGVkLCBwYXJhbXMubWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgcmV0dXJuIGJvZHk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQcm9wZXJ0eU1ldGhvZEZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycygpO1xyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZChwYXJhbXMpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5GdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgcGFyYW1zLnBhcmFtcywgbWV0aG9kLCBpc0dlbmVyYXRvcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJvcGVydHlNZXRob2RBc3luY0Z1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0F3YWl0ID0gdGhpcy5jb250ZXh0LmF3YWl0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoKTtcclxuXHQgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2QocGFyYW1zKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gcHJldmlvdXNBd2FpdDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFzeW5jRnVuY3Rpb25FeHByZXNzaW9uKG51bGwsIHBhcmFtcy5wYXJhbXMsIG1ldGhvZCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHZhciBrZXk7XHJcblx0ICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIDggLyogU3RyaW5nTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDYgLyogTnVtZXJpY0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRva2VuLm9jdGFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdmFyIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkxpdGVyYWwodG9rZW4udmFsdWUsIHJhdykpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDMgLyogSWRlbnRpZmllciAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDEgLyogQm9vbGVhbkxpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA1IC8qIE51bGxMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNCAvKiBLZXl3b3JkICovOlxyXG5cdCAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIodG9rZW4udmFsdWUpKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA3IC8qIFB1bmN0dWF0b3IgKi86XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ1snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCddJyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBrZXk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuaXNQcm9wZXJ0eUtleSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGtleS50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllciAmJiBrZXkubmFtZSA9PT0gdmFsdWUpIHx8XHJcblx0ICAgICAgICAgICAgKGtleS50eXBlID09PSBzeW50YXhfMS5TeW50YXguTGl0ZXJhbCAmJiBrZXkudmFsdWUgPT09IHZhbHVlKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9iamVjdFByb3BlcnR5ID0gZnVuY3Rpb24gKGhhc1Byb3RvKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIga2luZDtcclxuXHQgICAgICAgIHZhciBrZXkgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBjb21wdXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHNob3J0aGFuZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGlzQXN5bmMgPSBmYWxzZTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICB2YXIgaWQgPSB0b2tlbi52YWx1ZTtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGlzQXN5bmMgPSAhdGhpcy5oYXNMaW5lVGVybWluYXRvciAmJiAoaWQgPT09ICdhc3luYycpICYmXHJcblx0ICAgICAgICAgICAgICAgICF0aGlzLm1hdGNoKCc6JykgJiYgIXRoaXMubWF0Y2goJygnKSAmJiAhdGhpcy5tYXRjaCgnKicpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IGlzQXN5bmMgPyB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKSA6IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcihpZCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnKicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGxvb2thaGVhZFByb3BlcnR5S2V5ID0gdGhpcy5xdWFsaWZpZWRQcm9wZXJ0eU5hbWUodGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiAhaXNBc3luYyAmJiB0b2tlbi52YWx1ZSA9PT0gJ2dldCcgJiYgbG9va2FoZWFkUHJvcGVydHlLZXkpIHtcclxuXHQgICAgICAgICAgICBraW5kID0gJ2dldCc7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VHZXR0ZXJNZXRob2QoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiAhaXNBc3luYyAmJiB0b2tlbi52YWx1ZSA9PT0gJ3NldCcgJiYgbG9va2FoZWFkUHJvcGVydHlLZXkpIHtcclxuXHQgICAgICAgICAgICBraW5kID0gJ3NldCc7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlU2V0dGVyTWV0aG9kKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgdG9rZW4udmFsdWUgPT09ICcqJyAmJiBsb29rYWhlYWRQcm9wZXJ0eUtleSkge1xyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnaW5pdCc7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlR2VuZXJhdG9yTWV0aG9kKCk7XHJcblx0ICAgICAgICAgICAgbWV0aG9kID0gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGlmICgha2V5KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBraW5kID0gJ2luaXQnO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc6JykgJiYgIWlzQXN5bmMpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCFjb21wdXRlZCAmJiB0aGlzLmlzUHJvcGVydHlLZXkoa2V5LCAnX19wcm90b19fJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChoYXNQcm90by52YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkR1cGxpY2F0ZVByb3RvUHJvcGVydHkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaGFzUHJvdG8udmFsdWUgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJygnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IGlzQXN5bmMgPyB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2RBc3luY0Z1bmN0aW9uKCkgOiB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2RGdW5jdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICBtZXRob2QgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKHRva2VuLnZhbHVlKSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzaG9ydGhhbmQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGluaXQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Bc3NpZ25tZW50UGF0dGVybihpZCwgaW5pdCkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2hvcnRoYW5kID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaWQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuUHJvcGVydHkoa2luZCwga2V5LCBjb21wdXRlZCwgdmFsdWUsIG1ldGhvZCwgc2hvcnRoYW5kKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VPYmplY3RJbml0aWFsaXplciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBoYXNQcm90byA9IHsgdmFsdWU6IGZhbHNlIH07XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaCh0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHkoaGFzUHJvdG8pKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENvbW1hU2VwYXJhdG9yKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLk9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10ZW1wbGF0ZS1saXRlcmFsc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGVtcGxhdGVIZWFkID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KHRoaXMubG9va2FoZWFkLmhlYWQsICdUZW1wbGF0ZSBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIHRlbXBsYXRlIGhlYWQnKTtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdmFyIHJhdyA9IHRva2VuLnZhbHVlO1xyXG5cdCAgICAgICAgdmFyIGNvb2tlZCA9IHRva2VuLmNvb2tlZDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRlbXBsYXRlRWxlbWVudCh7IHJhdzogcmF3LCBjb29rZWQ6IGNvb2tlZCB9LCB0b2tlbi50YWlsKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VUZW1wbGF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMTAgLyogVGVtcGxhdGUgKi8pIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHZhciByYXcgPSB0b2tlbi52YWx1ZTtcclxuXHQgICAgICAgIHZhciBjb29rZWQgPSB0b2tlbi5jb29rZWQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UZW1wbGF0ZUVsZW1lbnQoeyByYXc6IHJhdywgY29va2VkOiBjb29rZWQgfSwgdG9rZW4udGFpbCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGVtcGxhdGVMaXRlcmFsID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHF1YXNpcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlSGVhZCgpO1xyXG5cdCAgICAgICAgcXVhc2lzLnB1c2gocXVhc2kpO1xyXG5cdCAgICAgICAgd2hpbGUgKCFxdWFzaS50YWlsKSB7XHJcblx0ICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlRXhwcmVzc2lvbigpKTtcclxuXHQgICAgICAgICAgICBxdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoKTtcclxuXHQgICAgICAgICAgICBxdWFzaXMucHVzaChxdWFzaSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UZW1wbGF0ZUxpdGVyYWwocXVhc2lzLCBleHByZXNzaW9ucykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1ncm91cGluZy1vcGVyYXRvclxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybiA9IGZ1bmN0aW9uIChleHByKSB7XHJcblx0ICAgICAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXI6XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguTWVtYmVyRXhwcmVzc2lvbjpcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5SZXN0RWxlbWVudDpcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjpcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguU3ByZWFkRWxlbWVudDpcclxuXHQgICAgICAgICAgICAgICAgZXhwci50eXBlID0gc3ludGF4XzEuU3ludGF4LlJlc3RFbGVtZW50O1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmFyZ3VtZW50KTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguQXJyYXlFeHByZXNzaW9uOlxyXG5cdCAgICAgICAgICAgICAgICBleHByLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXJyYXlQYXR0ZXJuO1xyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHIuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChleHByLmVsZW1lbnRzW2ldICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5lbGVtZW50c1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguT2JqZWN0RXhwcmVzc2lvbjpcclxuXHQgICAgICAgICAgICAgICAgZXhwci50eXBlID0gc3ludGF4XzEuU3ludGF4Lk9iamVjdFBhdHRlcm47XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwci5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLnByb3BlcnRpZXNbaV0udmFsdWUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uOlxyXG5cdCAgICAgICAgICAgICAgICBleHByLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudFBhdHRlcm47XHJcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSBleHByLm9wZXJhdG9yO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmxlZnQpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAvLyBBbGxvdyBvdGhlciBub2RlIHR5cGUgZm9yIHRvbGVyYW50IHBhcnNpbmcuXHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlR3JvdXBFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCc9PicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc9PicpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICBwYXJhbXM6IFtdLFxyXG5cdCAgICAgICAgICAgICAgICBhc3luYzogZmFsc2VcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICB2YXIgcGFyYW1zID0gW107XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJy4uLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlUmVzdEVsZW1lbnQocGFyYW1zKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCc9PicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnPT4nKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgIHBhcmFtczogW2V4cHJdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgYXJyb3cgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChleHByKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwcmVzc2lvbnNbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycm93ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IGV4cHJlc3Npb25zLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJy4uLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZVJlc3RFbGVtZW50KHBhcmFtcykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJz0+JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc9PicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHJlc3Npb25zW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdyA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBleHByZXNzaW9ucyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWFycm93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLlNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICghYXJyb3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnPT4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyICYmIGV4cHIubmFtZSA9PT0gJ3lpZWxkJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdyA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbZXhwcl0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnJvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguU2VxdWVuY2VFeHByZXNzaW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHIuZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmV4cHJlc3Npb25zW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJzID0gKGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LlNlcXVlbmNlRXhwcmVzc2lvbiA/IGV4cHIuZXhwcmVzc2lvbnMgOiBbZXhwcl0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1ldGVycyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGVmdC1oYW5kLXNpZGUtZXhwcmVzc2lvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFyZ3VtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZXhwciA9IHRoaXMubWF0Y2goJy4uLicpID8gdGhpcy5wYXJzZVNwcmVhZEVsZW1lbnQoKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHIpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENvbW1hU2VwYXJhdG9yKCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgIHJldHVybiBhcmdzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmlzSWRlbnRpZmllck5hbWUgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIHJldHVybiB0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gfHxcclxuXHQgICAgICAgICAgICB0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8gfHxcclxuXHQgICAgICAgICAgICB0b2tlbi50eXBlID09PSAxIC8qIEJvb2xlYW5MaXRlcmFsICovIHx8XHJcblx0ICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gNSAvKiBOdWxsTGl0ZXJhbCAqLztcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUlkZW50aWZpZXJOYW1lID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMuaXNJZGVudGlmaWVyTmFtZSh0b2tlbikpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIodG9rZW4udmFsdWUpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU5ld0V4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQoaWQubmFtZSA9PT0gJ25ldycsICdOZXcgZXhwcmVzc2lvbiBtdXN0IHN0YXJ0IHdpdGggYG5ld2AnKTtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJy4nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkgJiYgdGhpcy5sb29rYWhlYWQudmFsdWUgPT09ICd0YXJnZXQnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gbmV3IE5vZGUuTWV0YVByb3BlcnR5KGlkLCBwcm9wZXJ0eSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YXIgY2FsbGVlID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICB2YXIgYXJncyA9IHRoaXMubWF0Y2goJygnKSA/IHRoaXMucGFyc2VBcmd1bWVudHMoKSA6IFtdO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSBuZXcgTm9kZS5OZXdFeHByZXNzaW9uKGNhbGxlZSwgYXJncyk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBleHByKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFzeW5jQXJndW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgYXJnID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcclxuXHQgICAgICAgIHJldHVybiBhcmc7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBc3luY0FyZ3VtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZXhwciA9IHRoaXMubWF0Y2goJy4uLicpID8gdGhpcy5wYXJzZVNwcmVhZEVsZW1lbnQoKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzeW5jQXJndW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICBhcmdzLnB1c2goZXhwcik7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q29tbWFTZXBhcmF0b3IoKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgcmV0dXJuIGFyZ3M7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBtYXliZUFzeW5jID0gdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhc3luYycpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dJbiA9IHRoaXMuY29udGV4dC5hbGxvd0luO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ3N1cGVyJykgJiYgdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5KSB7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUoZXhwciwgbmV3IE5vZGUuU3VwZXIoKSk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcoJykgJiYgIXRoaXMubWF0Y2goJy4nKSAmJiAhdGhpcy5tYXRjaCgnWycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5tYXRjaEtleXdvcmQoJ25ldycpID8gdGhpcy5wYXJzZU5ld0V4cHJlc3Npb24gOiB0aGlzLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLicpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLlN0YXRpY01lbWJlckV4cHJlc3Npb24oZXhwciwgcHJvcGVydHkpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnKCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBhc3luY0Fycm93ID0gbWF5YmVBc3luYyAmJiAoc3RhcnRUb2tlbi5saW5lTnVtYmVyID09PSB0aGlzLmxvb2thaGVhZC5saW5lTnVtYmVyKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFzeW5jQXJyb3cgPyB0aGlzLnBhcnNlQXN5bmNBcmd1bWVudHMoKSA6IHRoaXMucGFyc2VBcmd1bWVudHMoKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLkNhbGxFeHByZXNzaW9uKGV4cHIsIGFyZ3MpKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGFzeW5jQXJyb3cgJiYgdGhpcy5tYXRjaCgnPT4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oYXJnc1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBhcmdzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJ1snKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJ1snKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJ10nKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLkNvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbihleHByLCBwcm9wZXJ0eSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAxMCAvKiBUZW1wbGF0ZSAqLyAmJiB0aGlzLmxvb2thaGVhZC5oZWFkKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBxdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZUxpdGVyYWwoKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihleHByLCBxdWFzaSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN1cGVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnc3VwZXInKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnWycpICYmICF0aGlzLm1hdGNoKCcuJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlN1cGVyKCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydCh0aGlzLmNvbnRleHQuYWxsb3dJbiwgJ2NhbGxlZSBvZiBuZXcgZXhwcmVzc2lvbiBhbHdheXMgYWxsb3cgaW4ga2V5d29yZC4nKTtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUodGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSAodGhpcy5tYXRjaEtleXdvcmQoJ3N1cGVyJykgJiYgdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5KSA/IHRoaXMucGFyc2VTdXBlcigpIDpcclxuXHQgICAgICAgICAgICB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5tYXRjaEtleXdvcmQoJ25ldycpID8gdGhpcy5wYXJzZU5ld0V4cHJlc3Npb24gOiB0aGlzLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnWycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnWycpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnXScpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Db21wdXRlZE1lbWJlckV4cHJlc3Npb24oZXhwciwgcHJvcGVydHkpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLicpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuU3RhdGljTWVtYmVyRXhwcmVzc2lvbihleHByLCBwcm9wZXJ0eSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAxMCAvKiBUZW1wbGF0ZSAqLyAmJiB0aGlzLmxvb2thaGVhZC5oZWFkKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBxdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZUxpdGVyYWwoKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKGV4cHIsIHF1YXNpKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdXBkYXRlLWV4cHJlc3Npb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VVcGRhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJysrJykgfHwgdGhpcy5tYXRjaCgnLS0nKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbik7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VVbmFyeUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIgJiYgdGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQoZXhwci5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RMSFNQcmVmaXgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZExIU0luQXNzaWdubWVudCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHZhciBwcmVmaXggPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlVwZGF0ZUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIsIHByZWZpeCkpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yICYmIHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKysnKSB8fCB0aGlzLm1hdGNoKCctLScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyICYmIHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKGV4cHIubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RMSFNQb3N0Zml4KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHRoaXMubmV4dFRva2VuKCkudmFsdWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuVXBkYXRlRXhwcmVzc2lvbihvcGVyYXRvciwgZXhwciwgcHJlZml4KSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdW5hcnktb3BlcmF0b3JzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBd2FpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHZhciBhcmd1bWVudCA9IHRoaXMucGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkF3YWl0RXhwcmVzc2lvbihhcmd1bWVudCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVW5hcnlFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnKycpIHx8IHRoaXMubWF0Y2goJy0nKSB8fCB0aGlzLm1hdGNoKCd+JykgfHwgdGhpcy5tYXRjaCgnIScpIHx8XHJcblx0ICAgICAgICAgICAgdGhpcy5tYXRjaEtleXdvcmQoJ2RlbGV0ZScpIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCd2b2lkJykgfHwgdGhpcy5tYXRjaEtleXdvcmQoJ3R5cGVvZicpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VVbmFyeUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlVuYXJ5RXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwcikpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGV4cHIub3BlcmF0b3IgPT09ICdkZWxldGUnICYmIGV4cHIuYXJndW1lbnQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RGVsZXRlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRleHQuYXdhaXQgJiYgdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhd2FpdCcpKSB7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VBd2FpdEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlVXBkYXRlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VFeHBvbmVudGlhdGlvbkV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZVVuYXJ5RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICBpZiAoZXhwci50eXBlICE9PSBzeW50YXhfMS5TeW50YXguVW5hcnlFeHByZXNzaW9uICYmIHRoaXMubWF0Y2goJyoqJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHZhciBsZWZ0ID0gZXhwcjtcclxuXHQgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUV4cG9uZW50aWF0aW9uRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLkJpbmFyeUV4cHJlc3Npb24oJyoqJywgbGVmdCwgcmlnaHQpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1leHAtb3BlcmF0b3JcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbXVsdGlwbGljYXRpdmUtb3BlcmF0b3JzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFkZGl0aXZlLW9wZXJhdG9yc1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1iaXR3aXNlLXNoaWZ0LW9wZXJhdG9yc1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWxhdGlvbmFsLW9wZXJhdG9yc1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lcXVhbGl0eS1vcGVyYXRvcnNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYmluYXJ5LWJpdHdpc2Utb3BlcmF0b3JzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWJpbmFyeS1sb2dpY2FsLW9wZXJhdG9yc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmJpbmFyeVByZWNlZGVuY2UgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIHZhciBvcCA9IHRva2VuLnZhbHVlO1xyXG5cdCAgICAgICAgdmFyIHByZWNlZGVuY2U7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovKSB7XHJcblx0ICAgICAgICAgICAgcHJlY2VkZW5jZSA9IHRoaXMub3BlcmF0b3JQcmVjZWRlbmNlW29wXSB8fCAwO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gNCAvKiBLZXl3b3JkICovKSB7XHJcblx0ICAgICAgICAgICAgcHJlY2VkZW5jZSA9IChvcCA9PT0gJ2luc3RhbmNlb2YnIHx8ICh0aGlzLmNvbnRleHQuYWxsb3dJbiAmJiBvcCA9PT0gJ2luJykpID8gNyA6IDA7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBwcmVjZWRlbmNlID0gMDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBwcmVjZWRlbmNlO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQmluYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlRXhwb25lbnRpYXRpb25FeHByZXNzaW9uKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIHByZWMgPSB0aGlzLmJpbmFyeVByZWNlZGVuY2UodG9rZW4pO1xyXG5cdCAgICAgICAgaWYgKHByZWMgPiAwKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB2YXIgbWFya2VycyA9IFtzdGFydFRva2VuLCB0aGlzLmxvb2thaGVhZF07XHJcblx0ICAgICAgICAgICAgdmFyIGxlZnQgPSBleHByO1xyXG5cdCAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlRXhwb25lbnRpYXRpb25FeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICB2YXIgc3RhY2sgPSBbbGVmdCwgdG9rZW4udmFsdWUsIHJpZ2h0XTtcclxuXHQgICAgICAgICAgICB2YXIgcHJlY2VkZW5jZXMgPSBbcHJlY107XHJcblx0ICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICAgICAgcHJlYyA9IHRoaXMuYmluYXJ5UHJlY2VkZW5jZSh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChwcmVjIDw9IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIC8vIFJlZHVjZTogbWFrZSBhIGJpbmFyeSBleHByZXNzaW9uIGZyb20gdGhlIHRocmVlIHRvcG1vc3QgZW50cmllcy5cclxuXHQgICAgICAgICAgICAgICAgd2hpbGUgKChzdGFjay5sZW5ndGggPiAyKSAmJiAocHJlYyA8PSBwcmVjZWRlbmNlc1twcmVjZWRlbmNlcy5sZW5ndGggLSAxXSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gc3RhY2sucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBzdGFjay5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2VzLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbWFya2Vycy5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUobWFya2Vyc1ttYXJrZXJzLmxlbmd0aCAtIDFdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5CaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkpKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAvLyBTaGlmdC5cclxuXHQgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzLm5leHRUb2tlbigpLnZhbHVlKTtcclxuXHQgICAgICAgICAgICAgICAgcHJlY2VkZW5jZXMucHVzaChwcmVjKTtcclxuXHQgICAgICAgICAgICAgICAgbWFya2Vycy5wdXNoKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUV4cG9uZW50aWF0aW9uRXhwcmVzc2lvbikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAvLyBGaW5hbCByZWR1Y2UgdG8gY2xlYW4tdXAgdGhlIHN0YWNrLlxyXG5cdCAgICAgICAgICAgIHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTtcclxuXHQgICAgICAgICAgICBleHByID0gc3RhY2tbaV07XHJcblx0ICAgICAgICAgICAgbWFya2Vycy5wb3AoKTtcclxuXHQgICAgICAgICAgICB3aGlsZSAoaSA+IDEpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZShtYXJrZXJzLnBvcCgpKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gc3RhY2tbaSAtIDFdO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5CaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBzdGFja1tpIC0gMl0sIGV4cHIpKTtcclxuXHQgICAgICAgICAgICAgICAgaSAtPSAyO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jb25kaXRpb25hbC1vcGVyYXRvclxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VCaW5hcnlFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCc/JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93SW4gPSB0aGlzLmNvbnRleHQuYWxsb3dJbjtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHRydWU7XHJcblx0ICAgICAgICAgICAgdmFyIGNvbnNlcXVlbnQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOicpO1xyXG5cdCAgICAgICAgICAgIHZhciBhbHRlcm5hdGUgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQ29uZGl0aW9uYWxFeHByZXNzaW9uKGV4cHIsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFzc2lnbm1lbnQtb3BlcmF0b3JzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuY2hlY2tQYXR0ZXJuUGFyYW0gPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyYW0pIHtcclxuXHQgICAgICAgIHN3aXRjaCAocGFyYW0udHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXI6XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVQYXJhbShvcHRpb25zLCBwYXJhbSwgcGFyYW0ubmFtZSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LlJlc3RFbGVtZW50OlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLmFyZ3VtZW50KTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudFBhdHRlcm46XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0ubGVmdCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LkFycmF5UGF0dGVybjpcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbS5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtLmVsZW1lbnRzW2ldICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbS5lbGVtZW50c1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguT2JqZWN0UGF0dGVybjpcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLnByb3BlcnRpZXNbaV0udmFsdWUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgb3B0aW9ucy5zaW1wbGUgPSBvcHRpb25zLnNpbXBsZSAmJiAocGFyYW0gaW5zdGFuY2VvZiBOb2RlLklkZW50aWZpZXIpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnJlaW50ZXJwcmV0QXNDb3ZlckZvcm1hbHNMaXN0ID0gZnVuY3Rpb24gKGV4cHIpIHtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBbZXhwcl07XHJcblx0ICAgICAgICB2YXIgb3B0aW9ucztcclxuXHQgICAgICAgIHZhciBhc3luY0Fycm93ID0gZmFsc2U7XHJcblx0ICAgICAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXI6XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcjpcclxuXHQgICAgICAgICAgICAgICAgcGFyYW1zID0gZXhwci5wYXJhbXM7XHJcblx0ICAgICAgICAgICAgICAgIGFzeW5jQXJyb3cgPSBleHByLmFzeW5jO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIG9wdGlvbnMgPSB7XHJcblx0ICAgICAgICAgICAgc2ltcGxlOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIHBhcmFtU2V0OiB7fVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zW2ldO1xyXG5cdCAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudFBhdHRlcm4pIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnJpZ2h0LnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5ZaWVsZEV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbS5yaWdodC5hcmd1bWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyYW0ucmlnaHQudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyYW0ucmlnaHQubmFtZSA9ICd5aWVsZCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW0ucmlnaHQuYXJndW1lbnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW0ucmlnaHQuZGVsZWdhdGU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoYXN5bmNBcnJvdyAmJiBwYXJhbS50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllciAmJiBwYXJhbS5uYW1lID09PSAnYXdhaXQnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtKTtcclxuXHQgICAgICAgICAgICBwYXJhbXNbaV0gPSBwYXJhbTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0IHx8ICF0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCkge1xyXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1tpXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5ZaWVsZEV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKG9wdGlvbnMubWVzc2FnZSA9PT0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGUpIHtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmNvbnRleHQuc3RyaWN0ID8gb3B0aW9ucy5zdHJpY3RlZCA6IG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkO1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG9wdGlvbnMubWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHNpbXBsZTogb3B0aW9ucy5zaW1wbGUsXHJcblx0ICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXHJcblx0ICAgICAgICAgICAgc3RyaWN0ZWQ6IG9wdGlvbnMuc3RyaWN0ZWQsXHJcblx0ICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCxcclxuXHQgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2VcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCAmJiB0aGlzLm1hdGNoS2V5d29yZCgneWllbGQnKSkge1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlWWllbGRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHN0YXJ0VG9rZW47XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmICh0b2tlbi5saW5lTnVtYmVyID09PSB0aGlzLmxvb2thaGVhZC5saW5lTnVtYmVyKSAmJiB0b2tlbi52YWx1ZSA9PT0gJ2FzeW5jJykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCd5aWVsZCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gdGhpcy5wYXJzZVByaW1hcnlFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihhcmcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogW2FyZ10sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlciB8fCB0aGlzLm1hdGNoKCc9PicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycm93LWZ1bmN0aW9uLWRlZmluaXRpb25zXHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGlzQXN5bmMgPSBleHByLmFzeW5jO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IHRoaXMucmVpbnRlcnByZXRBc0NvdmVyRm9ybWFsc0xpc3QoZXhwcik7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChsaXN0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNMaW5lVGVybWluYXRvcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QgPSB0aGlzLmNvbnRleHQuc3RyaWN0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmUgPSB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBsaXN0LnNpbXBsZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0F3YWl0ID0gdGhpcy5jb250ZXh0LmF3YWl0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gaXNBc3luYztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnPT4nKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gdm9pZCAwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ3snKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93SW4gPSB0aGlzLmNvbnRleHQuYWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGJvZHkudHlwZSAhPT0gc3ludGF4XzEuU3ludGF4LkJsb2NrU3RhdGVtZW50O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgbGlzdC5maXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKGxpc3QuZmlyc3RSZXN0cmljdGVkLCBsaXN0Lm1lc3NhZ2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgbGlzdC5zdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4obGlzdC5zdHJpY3RlZCwgbGlzdC5tZXNzYWdlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSBpc0FzeW5jID8gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Bc3luY0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKGxpc3QucGFyYW1zLCBib2R5LCBleHByZXNzaW9uKSkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24obGlzdC5wYXJhbXMsIGJvZHksIGV4cHJlc3Npb24pKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IHByZXZpb3VzQXdhaXQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoQXNzaWduKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGV4cHI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKGlkLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0TEhTQXNzaWdubWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKGlkLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB0b2tlbi52YWx1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLkFzc2lnbm1lbnRFeHByZXNzaW9uKG9wZXJhdG9yLCBleHByLCByaWdodCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY29tbWEtb3BlcmF0b3JcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcclxuXHQgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGV4cHIpO1xyXG5cdCAgICAgICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5TZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1ibG9ja1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovKSB7XHJcblx0ICAgICAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC52YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdleHBvcnQnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNNb2R1bGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkLCBtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxFeHBvcnREZWNsYXJhdGlvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdpbXBvcnQnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNNb2R1bGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkLCBtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxJbXBvcnREZWNsYXJhdGlvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlSW1wb3J0RGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdjb25zdCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlTGV4aWNhbERlY2xhcmF0aW9uKHsgaW5Gb3I6IGZhbHNlIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnY2xhc3MnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUNsYXNzRGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdsZXQnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5pc0xleGljYWxEZWNsYXJhdGlvbigpID8gdGhpcy5wYXJzZUxleGljYWxEZWNsYXJhdGlvbih7IGluRm9yOiBmYWxzZSB9KSA6IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHN0YXRlbWVudDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJsb2NrID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB2YXIgYmxvY2sgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgYmxvY2sucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQmxvY2tTdGF0ZW1lbnQoYmxvY2spKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGV0LWFuZC1jb25zdC1kZWNsYXJhdGlvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxleGljYWxCaW5kaW5nID0gZnVuY3Rpb24gKGtpbmQsIG9wdGlvbnMpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gW107XHJcblx0ICAgICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgaWQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQoaWQubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0VmFyTmFtZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKGtpbmQgPT09ICdjb25zdCcpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hLZXl3b3JkKCdpbicpICYmICF0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ29mJykpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkRlY2xhcmF0aW9uTWlzc2luZ0luaXRpYWxpemVyLCAnY29uc3QnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKCghb3B0aW9ucy5pbkZvciAmJiBpZC50eXBlICE9PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikgfHwgdGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0nKTtcclxuXHQgICAgICAgICAgICBpbml0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0b3IoaWQsIGluaXQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJpbmRpbmdMaXN0ID0gZnVuY3Rpb24gKGtpbmQsIG9wdGlvbnMpIHtcclxuXHQgICAgICAgIHZhciBsaXN0ID0gW3RoaXMucGFyc2VMZXhpY2FsQmluZGluZyhraW5kLCBvcHRpb25zKV07XHJcblx0ICAgICAgICB3aGlsZSAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBsaXN0LnB1c2godGhpcy5wYXJzZUxleGljYWxCaW5kaW5nKGtpbmQsIG9wdGlvbnMpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBsaXN0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmlzTGV4aWNhbERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zY2FubmVyLnNhdmVTdGF0ZSgpO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLnNjYW5Db21tZW50cygpO1xyXG5cdCAgICAgICAgdmFyIG5leHQgPSB0aGlzLnNjYW5uZXIubGV4KCk7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIucmVzdG9yZVN0YXRlKHN0YXRlKTtcclxuXHQgICAgICAgIHJldHVybiAobmV4dC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHx8XHJcblx0ICAgICAgICAgICAgKG5leHQudHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIG5leHQudmFsdWUgPT09ICdbJykgfHxcclxuXHQgICAgICAgICAgICAobmV4dC50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgbmV4dC52YWx1ZSA9PT0gJ3snKSB8fFxyXG5cdCAgICAgICAgICAgIChuZXh0LnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyAmJiBuZXh0LnZhbHVlID09PSAnbGV0JykgfHxcclxuXHQgICAgICAgICAgICAobmV4dC50eXBlID09PSA0IC8qIEtleXdvcmQgKi8gJiYgbmV4dC52YWx1ZSA9PT0gJ3lpZWxkJyk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VMZXhpY2FsRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBraW5kID0gdGhpcy5uZXh0VG9rZW4oKS52YWx1ZTtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydChraW5kID09PSAnbGV0JyB8fCBraW5kID09PSAnY29uc3QnLCAnTGV4aWNhbCBkZWNsYXJhdGlvbiBtdXN0IGJlIGVpdGhlciBsZXQgb3IgY29uc3QnKTtcclxuXHQgICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3Qoa2luZCwgb3B0aW9ucyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWRlc3RydWN0dXJpbmctYmluZGluZy1wYXR0ZXJuc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQmluZGluZ1Jlc3RFbGVtZW50ID0gZnVuY3Rpb24gKHBhcmFtcywga2luZCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcuLi4nKTtcclxuXHQgICAgICAgIHZhciBhcmcgPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuUmVzdEVsZW1lbnQoYXJnKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBcnJheVBhdHRlcm4gPSBmdW5jdGlvbiAocGFyYW1zLCBraW5kKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ1snKTtcclxuXHQgICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCddJykpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobnVsbCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLi4uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2godGhpcy5wYXJzZUJpbmRpbmdSZXN0RWxlbWVudChwYXJhbXMsIGtpbmQpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzLnBhcnNlUGF0dGVybldpdGhEZWZhdWx0KHBhcmFtcywga2luZCkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnXScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ10nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFycmF5UGF0dGVybihlbGVtZW50cykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJvcGVydHlQYXR0ZXJuID0gZnVuY3Rpb24gKHBhcmFtcywga2luZCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBjb21wdXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHNob3J0aGFuZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGtleTtcclxuXHQgICAgICAgIHZhciB2YWx1ZTtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICB2YXIga2V5VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgdmFyIGluaXQgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIoa2V5VG9rZW4udmFsdWUpKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGtleVRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgc2hvcnRoYW5kID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKGtleVRva2VuKSwgbmV3IE5vZGUuQXNzaWdubWVudFBhdHRlcm4oaW5pdCwgZXhwcikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5tYXRjaCgnOicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGtleVRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgc2hvcnRoYW5kID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBpbml0O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJzonKTtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlUGF0dGVybldpdGhEZWZhdWx0KHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJzonKTtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlByb3BlcnR5KCdpbml0Jywga2V5LCBjb21wdXRlZCwgdmFsdWUsIG1ldGhvZCwgc2hvcnRoYW5kKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VPYmplY3RQYXR0ZXJuID0gZnVuY3Rpb24gKHBhcmFtcywga2luZCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gW107XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2godGhpcy5wYXJzZVByb3BlcnR5UGF0dGVybihwYXJhbXMsIGtpbmQpKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5PYmplY3RQYXR0ZXJuKHByb3BlcnRpZXMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVBhdHRlcm4gPSBmdW5jdGlvbiAocGFyYW1zLCBraW5kKSB7XHJcblx0ICAgICAgICB2YXIgcGF0dGVybjtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCdbJykpIHtcclxuXHQgICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5wYXJzZUFycmF5UGF0dGVybihwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgneycpKSB7XHJcblx0ICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMucGFyc2VPYmplY3RQYXR0ZXJuKHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2xldCcpICYmIChraW5kID09PSAnY29uc3QnIHx8IGtpbmQgPT09ICdsZXQnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkLCBtZXNzYWdlc18xLk1lc3NhZ2VzLkxldEluTGV4aWNhbEJpbmRpbmcpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBwYXJhbXMucHVzaCh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoa2luZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gcGF0dGVybjtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVBhdHRlcm5XaXRoRGVmYXVsdCA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgcGF0dGVybiA9IHRoaXMucGFyc2VQYXR0ZXJuKHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5Bc3NpZ25tZW50UGF0dGVybihwYXR0ZXJuLCByaWdodCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHBhdHRlcm47XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXZhcmlhYmxlLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyID0gZnVuY3Rpb24gKGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJ3lpZWxkJykge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29udGV4dC5hbGxvd1lpZWxkKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgIT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRva2VuLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyAmJiB0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCB8fCB0b2tlbi52YWx1ZSAhPT0gJ2xldCcgfHwga2luZCAhPT0gJ3ZhcicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoKHRoaXMuY29udGV4dC5pc01vZHVsZSB8fCB0aGlzLmNvbnRleHQuYXdhaXQpICYmIHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJ2F3YWl0Jykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0b2tlbi52YWx1ZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZVBhdHRlcm4ocGFyYW1zLCAndmFyJyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBpZC50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RWYXJOYW1lKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBpbml0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmIChpZC50eXBlICE9PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllciAmJiAhb3B0aW9ucy5pbkZvcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc9Jyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0b3IoaWQsIGluaXQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHQgICAgICAgIHZhciBvcHQgPSB7IGluRm9yOiBvcHRpb25zLmluRm9yIH07XHJcblx0ICAgICAgICB2YXIgbGlzdCA9IFtdO1xyXG5cdCAgICAgICAgbGlzdC5wdXNoKHRoaXMucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uKG9wdCkpO1xyXG5cdCAgICAgICAgd2hpbGUgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgbGlzdC5wdXNoKHRoaXMucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uKG9wdCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGxpc3Q7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VWYXJpYWJsZVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3ZhcicpO1xyXG5cdCAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCh7IGluRm9yOiBmYWxzZSB9KTtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsICd2YXInKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVtcHR5LXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRW1wdHlTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJzsnKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkVtcHR5U3RhdGVtZW50KCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1leHByZXNzaW9uLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pZi1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUlmQ2xhdXNlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSWZTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGNvbnNlcXVlbnQ7XHJcblx0ICAgICAgICB2YXIgYWx0ZXJuYXRlID0gbnVsbDtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnaWYnKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgdGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSAmJiB0aGlzLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgY29uc2VxdWVudCA9IHRoaXMuZmluYWxpemUodGhpcy5jcmVhdGVOb2RlKCksIG5ldyBOb2RlLkVtcHR5U3RhdGVtZW50KCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICBjb25zZXF1ZW50ID0gdGhpcy5wYXJzZUlmQ2xhdXNlKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdlbHNlJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgYWx0ZXJuYXRlID0gdGhpcy5wYXJzZUlmQ2xhdXNlKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWZTdGF0ZW1lbnQodGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWRvLXdoaWxlLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRG9XaGlsZVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2RvJyk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJbkl0ZXJhdGlvbiA9IHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHByZXZpb3VzSW5JdGVyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3doaWxlJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIHRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykgJiYgdGhpcy5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnOycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRG9XaGlsZVN0YXRlbWVudChib2R5LCB0ZXN0KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXdoaWxlLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlV2hpbGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3doaWxlJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIHRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykgJiYgdGhpcy5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIGJvZHkgPSB0aGlzLmZpbmFsaXplKHRoaXMuY3JlYXRlTm9kZSgpLCBuZXcgTm9kZS5FbXB0eVN0YXRlbWVudCgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzSW5JdGVyYXRpb24gPSB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb247XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHByZXZpb3VzSW5JdGVyYXRpb247XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5XaGlsZVN0YXRlbWVudCh0ZXN0LCBib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWZvci1zdGF0ZW1lbnRcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZm9yLWluLWFuZC1mb3Itb2Ytc3RhdGVtZW50c1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRm9yU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIHRlc3QgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIHVwZGF0ZSA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgZm9ySW4gPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIGxlZnQsIHJpZ2h0O1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZm9yJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJzsnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ3ZhcicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dJbiA9IHRoaXMuY29udGV4dC5hbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdGhpcy5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KHsgaW5Gb3I6IHRydWUgfSk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiB0aGlzLm1hdGNoS2V5d29yZCgnaW4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2wgPSBkZWNsYXJhdGlvbnNbMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGVjbC5pbml0ICYmIChkZWNsLmlkLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5BcnJheVBhdHRlcm4gfHwgZGVjbC5pZC50eXBlID09PSBzeW50YXhfMS5TeW50YXguT2JqZWN0UGF0dGVybiB8fCB0aGlzLmNvbnRleHQuc3RyaWN0KSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkZvckluT2ZMb29wSW5pdGlhbGl6ZXIsICdmb3ItaW4nKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCAndmFyJykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiBkZWNsYXJhdGlvbnNbMF0uaW5pdCA9PT0gbnVsbCAmJiB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ29mJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCAndmFyJykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9ySW4gPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCAndmFyJykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJzsnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnY29uc3QnKSB8fCB0aGlzLm1hdGNoS2V5d29yZCgnbGV0JykpIHtcclxuXHQgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIga2luZCA9IHRoaXMubmV4dFRva2VuKCkudmFsdWU7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLmxvb2thaGVhZC52YWx1ZSA9PT0gJ2luJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuSWRlbnRpZmllcihraW5kKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93SW4gPSB0aGlzLmNvbnRleHQuYWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KGtpbmQsIHsgaW5Gb3I6IHRydWUgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIGRlY2xhcmF0aW9uc1swXS5pbml0ID09PSBudWxsICYmIHRoaXMubWF0Y2hLZXl3b3JkKCdpbicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgZGVjbGFyYXRpb25zWzBdLmluaXQgPT09IG51bGwgJiYgdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdvZicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9ySW4gPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBpbml0U3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnaW4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0IHx8IGluaXQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZExIU0luRm9ySW4pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGluaXQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ29mJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCB8fCBpbml0LnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRMSFNJbkZvckxvb3ApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGluaXQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3JJbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbml0U2VxID0gW2luaXRdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdFNlcS5wdXNoKHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoaW5pdFN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5TZXF1ZW5jZUV4cHJlc3Npb24oaW5pdFNlcSkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJzsnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJzsnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJzsnKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICB1cGRhdGUgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBib2R5O1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykgJiYgdGhpcy5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIGJvZHkgPSB0aGlzLmZpbmFsaXplKHRoaXMuY3JlYXRlTm9kZSgpLCBuZXcgTm9kZS5FbXB0eVN0YXRlbWVudCgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzSW5JdGVyYXRpb24gPSB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb247XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VTdGF0ZW1lbnQpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHByZXZpb3VzSW5JdGVyYXRpb247XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gKHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJykgP1xyXG5cdCAgICAgICAgICAgIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRm9yU3RhdGVtZW50KGluaXQsIHRlc3QsIHVwZGF0ZSwgYm9keSkpIDpcclxuXHQgICAgICAgICAgICBmb3JJbiA/IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRm9ySW5TdGF0ZW1lbnQobGVmdCwgcmlnaHQsIGJvZHkpKSA6XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRm9yT2ZTdGF0ZW1lbnQobGVmdCwgcmlnaHQsIGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY29udGludWUtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDb250aW51ZVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2NvbnRpbnVlJyk7XHJcblx0ICAgICAgICB2YXIgbGFiZWwgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiAhdGhpcy5oYXNMaW5lVGVybWluYXRvcikge1xyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICBsYWJlbCA9IGlkO1xyXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSAnJCcgKyBpZC5uYW1lO1xyXG5cdCAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29udGV4dC5sYWJlbFNldCwga2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5Vbmtub3duTGFiZWwsIGlkLm5hbWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgaWYgKGxhYmVsID09PSBudWxsICYmICF0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24pIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsQ29udGludWUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQ29udGludWVTdGF0ZW1lbnQobGFiZWwpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYnJlYWstc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VCcmVha1N0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2JyZWFrJyk7XHJcblx0ICAgICAgICB2YXIgbGFiZWwgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiAhdGhpcy5oYXNMaW5lVGVybWluYXRvcikge1xyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB2YXIga2V5ID0gJyQnICsgaWQubmFtZTtcclxuXHQgICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNvbnRleHQubGFiZWxTZXQsIGtleSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5rbm93bkxhYmVsLCBpZC5uYW1lKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgbGFiZWwgPSBpZDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgaWYgKGxhYmVsID09PSBudWxsICYmICF0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gJiYgIXRoaXMuY29udGV4dC5pblN3aXRjaCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxCcmVhayk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5CcmVha1N0YXRlbWVudChsYWJlbCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZXR1cm4tc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VSZXR1cm5TdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxSZXR1cm4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgncmV0dXJuJyk7XHJcblx0ICAgICAgICB2YXIgaGFzQXJndW1lbnQgPSAhdGhpcy5tYXRjaCgnOycpICYmICF0aGlzLm1hdGNoKCd9JykgJiZcclxuXHQgICAgICAgICAgICAhdGhpcy5oYXNMaW5lVGVybWluYXRvciAmJiB0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLztcclxuXHQgICAgICAgIHZhciBhcmd1bWVudCA9IGhhc0FyZ3VtZW50ID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IG51bGw7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlJldHVyblN0YXRlbWVudChhcmd1bWVudCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy13aXRoLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlV2l0aFN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0TW9kZVdpdGgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd3aXRoJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIG9iamVjdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSAmJiB0aGlzLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgYm9keSA9IHRoaXMuZmluYWxpemUodGhpcy5jcmVhdGVOb2RlKCksIG5ldyBOb2RlLkVtcHR5U3RhdGVtZW50KCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuV2l0aFN0YXRlbWVudChvYmplY3QsIGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3dpdGNoLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3dpdGNoQ2FzZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdGVzdDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZGVmYXVsdCcpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB0ZXN0ID0gbnVsbDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnY2FzZScpO1xyXG5cdCAgICAgICAgICAgIHRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJzonKTtcclxuXHQgICAgICAgIHZhciBjb25zZXF1ZW50ID0gW107XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCd9JykgfHwgdGhpcy5tYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSB8fCB0aGlzLm1hdGNoS2V5d29yZCgnY2FzZScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBjb25zZXF1ZW50LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuU3dpdGNoQ2FzZSh0ZXN0LCBjb25zZXF1ZW50KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTd2l0Y2hTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdzd2l0Y2gnKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgZGlzY3JpbWluYW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJblN3aXRjaCA9IHRoaXMuY29udGV4dC5pblN3aXRjaDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pblN3aXRjaCA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgY2FzZXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBkZWZhdWx0Rm91bmQgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHZhciBjbGF1c2UgPSB0aGlzLnBhcnNlU3dpdGNoQ2FzZSgpO1xyXG5cdCAgICAgICAgICAgIGlmIChjbGF1c2UudGVzdCA9PT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdEZvdW5kKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5NdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2gpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHRGb3VuZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGNhc2VzLnB1c2goY2xhdXNlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5Td2l0Y2ggPSBwcmV2aW91c0luU3dpdGNoO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuU3dpdGNoU3RhdGVtZW50KGRpc2NyaW1pbmFudCwgY2FzZXMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGFiZWxsZWQtc3RhdGVtZW50c1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTGFiZWxsZWRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdmFyIHN0YXRlbWVudDtcclxuXHQgICAgICAgIGlmICgoZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikgJiYgdGhpcy5tYXRjaCgnOicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB2YXIgaWQgPSBleHByO1xyXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSAnJCcgKyBpZC5uYW1lO1xyXG5cdCAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb250ZXh0LmxhYmVsU2V0LCBrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlJlZGVjbGFyYXRpb24sICdMYWJlbCcsIGlkLm5hbWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQubGFiZWxTZXRba2V5XSA9IHRydWU7XHJcblx0ICAgICAgICAgICAgdmFyIGJvZHkgPSB2b2lkIDA7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdjbGFzcycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZUNsYXNzRGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWNsYXJhdGlvbi5nZW5lcmF0b3IpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuR2VuZXJhdG9ySW5MZWdhY3lDb250ZXh0KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBib2R5ID0gZGVjbGFyYXRpb247XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBkZWxldGUgdGhpcy5jb250ZXh0LmxhYmVsU2V0W2tleV07XHJcblx0ICAgICAgICAgICAgc3RhdGVtZW50ID0gbmV3IE5vZGUuTGFiZWxlZFN0YXRlbWVudChpZCwgYm9keSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgICAgICBzdGF0ZW1lbnQgPSBuZXcgTm9kZS5FeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgc3RhdGVtZW50KTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdGhyb3ctc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VUaHJvd1N0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3Rocm93Jyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5oYXNMaW5lVGVybWluYXRvcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLk5ld2xpbmVBZnRlclRocm93KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBhcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRocm93U3RhdGVtZW50KGFyZ3VtZW50KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRyeS1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNhdGNoQ2xhdXNlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnY2F0Y2gnKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gW107XHJcblx0ICAgICAgICB2YXIgcGFyYW0gPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMpO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtTWFwID0ge307XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSAnJCcgKyBwYXJhbXNbaV0udmFsdWU7XHJcblx0ICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbU1hcCwga2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5EdXBsaWNhdGVCaW5kaW5nLCBwYXJhbXNbaV0udmFsdWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBwYXJhbU1hcFtrZXldID0gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHBhcmFtLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKHBhcmFtLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdENhdGNoVmFyaWFibGUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VCbG9jaygpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQ2F0Y2hDbGF1c2UocGFyYW0sIGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZpbmFsbHlDbGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2ZpbmFsbHknKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmxvY2soKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRyeVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3RyeScpO1xyXG5cdCAgICAgICAgdmFyIGJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XHJcblx0ICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMubWF0Y2hLZXl3b3JkKCdjYXRjaCcpID8gdGhpcy5wYXJzZUNhdGNoQ2xhdXNlKCkgOiBudWxsO1xyXG5cdCAgICAgICAgdmFyIGZpbmFsaXplciA9IHRoaXMubWF0Y2hLZXl3b3JkKCdmaW5hbGx5JykgPyB0aGlzLnBhcnNlRmluYWxseUNsYXVzZSgpIDogbnVsbDtcclxuXHQgICAgICAgIGlmICghaGFuZGxlciAmJiAhZmluYWxpemVyKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuTm9DYXRjaE9yRmluYWxseSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UcnlTdGF0ZW1lbnQoYmxvY2ssIGhhbmRsZXIsIGZpbmFsaXplcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1kZWJ1Z2dlci1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZURlYnVnZ2VyU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZGVidWdnZXInKTtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRGVidWdnZXJTdGF0ZW1lbnQoKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2Utc3RhdGVtZW50cy1hbmQtZGVjbGFyYXRpb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhdGVtZW50O1xyXG5cdCAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAxIC8qIEJvb2xlYW5MaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNSAvKiBOdWxsTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDYgLyogTnVtZXJpY0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA4IC8qIFN0cmluZ0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSAxMCAvKiBUZW1wbGF0ZSAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDkgLyogUmVndWxhckV4cHJlc3Npb24gKi86XHJcblx0ICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNyAvKiBQdW5jdHVhdG9yICovOlxyXG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmxvb2thaGVhZC52YWx1ZTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VCbG9jaygpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSAnKCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09ICc7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUVtcHR5U3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgMyAvKiBJZGVudGlmaWVyICovOlxyXG5cdCAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLm1hdGNoQXN5bmNGdW5jdGlvbigpID8gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKSA6IHRoaXMucGFyc2VMYWJlbGxlZFN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDQgLyogS2V5d29yZCAqLzpcclxuXHQgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC52YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnYnJlYWsnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VCcmVha1N0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29udGludWUnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VDb250aW51ZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVidWdnZXInOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VEZWJ1Z2dlclN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnZG8nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VEb1doaWxlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdmb3InOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VGb3JTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnaWYnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VJZlN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAncmV0dXJuJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlUmV0dXJuU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdzd2l0Y2gnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VTd2l0Y2hTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Rocm93JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlVGhyb3dTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RyeSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVRyeVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAndmFyJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlVmFyaWFibGVTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3doaWxlJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlV2hpbGVTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dpdGgnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VXaXRoU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gc3RhdGVtZW50O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mdW5jdGlvbi1kZWZpbml0aW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRGlyZWN0aXZlUHJvbG9ndWVzKCk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNMYWJlbFNldCA9IHRoaXMuY29udGV4dC5sYWJlbFNldDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0luSXRlcmF0aW9uID0gdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSW5Td2l0Y2ggPSB0aGlzLmNvbnRleHQuaW5Td2l0Y2g7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJbkZ1bmN0aW9uQm9keSA9IHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5sYWJlbFNldCA9IHt9O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5Td2l0Y2ggPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSA9IHRydWU7XHJcblx0ICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBib2R5LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5sYWJlbFNldCA9IHByZXZpb3VzTGFiZWxTZXQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSBwcmV2aW91c0luSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluU3dpdGNoID0gcHJldmlvdXNJblN3aXRjaDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSA9IHByZXZpb3VzSW5GdW5jdGlvbkJvZHk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5CbG9ja1N0YXRlbWVudChib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUudmFsaWRhdGVQYXJhbSA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJhbSwgbmFtZSkge1xyXG5cdCAgICAgICAgdmFyIGtleSA9ICckJyArIG5hbWU7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChuYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLnN0cmljdGVkID0gcGFyYW07XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UGFyYW1OYW1lO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMucGFyYW1TZXQsIGtleSkpIHtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3RlZCA9IHBhcmFtO1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICghb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQobmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQgPSBwYXJhbTtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQobmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQgPSBwYXJhbTtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLnBhcmFtU2V0LCBrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RyaWN0ZWQgPSBwYXJhbTtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdGlvbnMucGFyYW1TZXQsIGtleSwgeyB2YWx1ZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIG9wdGlvbnMucGFyYW1TZXRba2V5XSA9IHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VSZXN0RWxlbWVudCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnLi4uJyk7XHJcblx0ICAgICAgICB2YXIgYXJnID0gdGhpcy5wYXJzZVBhdHRlcm4ocGFyYW1zKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5EZWZhdWx0UmVzdFBhcmFtZXRlcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlBhcmFtZXRlckFmdGVyUmVzdFBhcmFtZXRlcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5SZXN0RWxlbWVudChhcmcpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZvcm1hbFBhcmFtZXRlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gW107XHJcblx0ICAgICAgICB2YXIgcGFyYW0gPSB0aGlzLm1hdGNoKCcuLi4nKSA/IHRoaXMucGFyc2VSZXN0RWxlbWVudChwYXJhbXMpIDogdGhpcy5wYXJzZVBhdHRlcm5XaXRoRGVmYXVsdChwYXJhbXMpO1xyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGFyYW0ob3B0aW9ucywgcGFyYW1zW2ldLCBwYXJhbXNbaV0udmFsdWUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgb3B0aW9ucy5zaW1wbGUgPSBvcHRpb25zLnNpbXBsZSAmJiAocGFyYW0gaW5zdGFuY2VvZiBOb2RlLklkZW50aWZpZXIpO1xyXG5cdCAgICAgICAgb3B0aW9ucy5wYXJhbXMucHVzaChwYXJhbSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGb3JtYWxQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKGZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgdmFyIG9wdGlvbnM7XHJcblx0ICAgICAgICBvcHRpb25zID0ge1xyXG5cdCAgICAgICAgICAgIHNpbXBsZTogdHJ1ZSxcclxuXHQgICAgICAgICAgICBwYXJhbXM6IFtdLFxyXG5cdCAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZDogZmlyc3RSZXN0cmljdGVkXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgb3B0aW9ucy5wYXJhbVNldCA9IHt9O1xyXG5cdCAgICAgICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVyKG9wdGlvbnMpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHNpbXBsZTogb3B0aW9ucy5zaW1wbGUsXHJcblx0ICAgICAgICAgICAgcGFyYW1zOiBvcHRpb25zLnBhcmFtcyxcclxuXHQgICAgICAgICAgICBzdHJpY3RlZDogb3B0aW9ucy5zdHJpY3RlZCxcclxuXHQgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQ6IG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkLFxyXG5cdCAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5tYXRjaEFzeW5jRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbWF0Y2ggPSB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzeW5jJyk7XHJcblx0ICAgICAgICBpZiAobWF0Y2gpIHtcclxuXHQgICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnNjYW5uZXIuc2F2ZVN0YXRlKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5zY2FubmVyLnNjYW5Db21tZW50cygpO1xyXG5cdCAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5zY2FubmVyLmxleCgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5yZXN0b3JlU3RhdGUoc3RhdGUpO1xyXG5cdCAgICAgICAgICAgIG1hdGNoID0gKHN0YXRlLmxpbmVOdW1iZXIgPT09IG5leHQubGluZU51bWJlcikgJiYgKG5leHQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovKSAmJiAobmV4dC52YWx1ZSA9PT0gJ2Z1bmN0aW9uJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gbWF0Y2g7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uID0gZnVuY3Rpb24gKGlkZW50aWZpZXJJc09wdGlvbmFsKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGlzQXN5bmMgPSB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzeW5jJyk7XHJcblx0ICAgICAgICBpZiAoaXNBc3luYykge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2Z1bmN0aW9uJyk7XHJcblx0ICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSBpc0FzeW5jID8gZmFsc2UgOiB0aGlzLm1hdGNoKCcqJyk7XHJcblx0ICAgICAgICBpZiAoaXNHZW5lcmF0b3IpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG1lc3NhZ2U7XHJcblx0ICAgICAgICB2YXIgaWQgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGZpcnN0UmVzdHJpY3RlZCA9IG51bGw7XHJcblx0ICAgICAgICBpZiAoIWlkZW50aWZpZXJJc09wdGlvbmFsIHx8ICF0aGlzLm1hdGNoKCcoJykpIHtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICBpZCA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93QXdhaXQgPSB0aGlzLmNvbnRleHQuYXdhaXQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBpc0FzeW5jO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSAhaXNHZW5lcmF0b3I7XHJcblx0ICAgICAgICB2YXIgZm9ybWFsUGFyYW1ldGVycyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKGZpcnN0UmVzdHJpY3RlZCk7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gZm9ybWFsUGFyYW1ldGVycy5wYXJhbXM7XHJcblx0ICAgICAgICB2YXIgc3RyaWN0ZWQgPSBmb3JtYWxQYXJhbWV0ZXJzLnN0cmljdGVkO1xyXG5cdCAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gZm9ybWFsUGFyYW1ldGVycy5maXJzdFJlc3RyaWN0ZWQ7XHJcblx0ICAgICAgICBpZiAoZm9ybWFsUGFyYW1ldGVycy5tZXNzYWdlKSB7XHJcblx0ICAgICAgICAgICAgbWVzc2FnZSA9IGZvcm1hbFBhcmFtZXRlcnMubWVzc2FnZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZSA9IHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IGZvcm1hbFBhcmFtZXRlcnMuc2ltcGxlO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHN0cmljdGVkLCBtZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBwcmV2aW91c0FsbG93QXdhaXQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHJldHVybiBpc0FzeW5jID8gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Bc3luY0Z1bmN0aW9uRGVjbGFyYXRpb24oaWQsIHBhcmFtcywgYm9keSkpIDpcclxuXHQgICAgICAgICAgICB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRGVjbGFyYXRpb24oaWQsIHBhcmFtcywgYm9keSwgaXNHZW5lcmF0b3IpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaXNBc3luYyA9IHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXN5bmMnKTtcclxuXHQgICAgICAgIGlmIChpc0FzeW5jKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZnVuY3Rpb24nKTtcclxuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IGlzQXN5bmMgPyBmYWxzZSA6IHRoaXMubWF0Y2goJyonKTtcclxuXHQgICAgICAgIGlmIChpc0dlbmVyYXRvcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbWVzc2FnZTtcclxuXHQgICAgICAgIHZhciBpZCA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgZmlyc3RSZXN0cmljdGVkO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dBd2FpdCA9IHRoaXMuY29udGV4dC5hd2FpdDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IGlzQXN5bmM7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9ICFpc0dlbmVyYXRvcjtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKCcpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgaWQgPSAoIXRoaXMuY29udGV4dC5zdHJpY3QgJiYgIWlzR2VuZXJhdG9yICYmIHRoaXMubWF0Y2hLZXl3b3JkKCd5aWVsZCcpKSA/IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpIDogdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0KSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XHJcblx0ICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGZvcm1hbFBhcmFtZXRlcnMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycyhmaXJzdFJlc3RyaWN0ZWQpO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zO1xyXG5cdCAgICAgICAgdmFyIHN0cmljdGVkID0gZm9ybWFsUGFyYW1ldGVycy5zdHJpY3RlZDtcclxuXHQgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IGZvcm1hbFBhcmFtZXRlcnMuZmlyc3RSZXN0cmljdGVkO1xyXG5cdCAgICAgICAgaWYgKGZvcm1hbFBhcmFtZXRlcnMubWVzc2FnZSkge1xyXG5cdCAgICAgICAgICAgIG1lc3NhZ2UgPSBmb3JtYWxQYXJhbWV0ZXJzLm1lc3NhZ2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QgPSB0aGlzLmNvbnRleHQuc3RyaWN0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmUgPSB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBmb3JtYWxQYXJhbWV0ZXJzLnNpbXBsZTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihzdHJpY3RlZCwgbWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gcHJldmlvdXNBbGxvd0F3YWl0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICByZXR1cm4gaXNBc3luYyA/IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24oaWQsIHBhcmFtcywgYm9keSkpIDpcclxuXHQgICAgICAgICAgICB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRXhwcmVzc2lvbihpZCwgcGFyYW1zLCBib2R5LCBpc0dlbmVyYXRvcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1kaXJlY3RpdmUtcHJvbG9ndWVzLWFuZC10aGUtdXNlLXN0cmljdC1kaXJlY3RpdmVcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZURpcmVjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHZhciBkaXJlY3RpdmUgPSAoZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguTGl0ZXJhbCkgPyB0aGlzLmdldFRva2VuUmF3KHRva2VuKS5zbGljZSgxLCAtMSkgOiBudWxsO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBkaXJlY3RpdmUgPyBuZXcgTm9kZS5EaXJlY3RpdmUoZXhwciwgZGlyZWN0aXZlKSA6IG5ldyBOb2RlLkV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRGlyZWN0aXZlUHJvbG9ndWVzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGZpcnN0UmVzdHJpY3RlZCA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gOCAvKiBTdHJpbmdMaXRlcmFsICovKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB2YXIgc3RhdGVtZW50ID0gdGhpcy5wYXJzZURpcmVjdGl2ZSgpO1xyXG5cdCAgICAgICAgICAgIGJvZHkucHVzaChzdGF0ZW1lbnQpO1xyXG5cdCAgICAgICAgICAgIHZhciBkaXJlY3RpdmUgPSBzdGF0ZW1lbnQuZGlyZWN0aXZlO1xyXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgZGlyZWN0aXZlICE9PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZSA9PT0gJ3VzZSBzdHJpY3QnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxMYW5ndWFnZU1vZGVEaXJlY3RpdmUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIWZpcnN0UmVzdHJpY3RlZCAmJiB0b2tlbi5vY3RhbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gYm9keTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbWV0aG9kLWRlZmluaXRpb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucXVhbGlmaWVkUHJvcGVydHlOYW1lID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIDMgLyogSWRlbnRpZmllciAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDggLyogU3RyaW5nTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDEgLyogQm9vbGVhbkxpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA1IC8qIE51bGxMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNiAvKiBOdW1lcmljTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDQgLyogS2V5d29yZCAqLzpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgY2FzZSA3IC8qIFB1bmN0dWF0b3IgKi86XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbi52YWx1ZSA9PT0gJ1snO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlR2V0dGVyTWV0aG9kID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBmb3JtYWxQYXJhbWV0ZXJzID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoKTtcclxuXHQgICAgICAgIGlmIChmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtcy5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuQmFkR2V0dGVyQXJpdHkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZChmb3JtYWxQYXJhbWV0ZXJzKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRnVuY3Rpb25FeHByZXNzaW9uKG51bGwsIGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zLCBtZXRob2QsIGlzR2VuZXJhdG9yKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTZXR0ZXJNZXRob2QgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGZvcm1hbFBhcmFtZXRlcnMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycygpO1xyXG5cdCAgICAgICAgaWYgKGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zLmxlbmd0aCAhPT0gMSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkJhZFNldHRlckFyaXR5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zWzBdIGluc3RhbmNlb2YgTm9kZS5SZXN0RWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkJhZFNldHRlclJlc3RQYXJhbWV0ZXIpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZChmb3JtYWxQYXJhbWV0ZXJzKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRnVuY3Rpb25FeHByZXNzaW9uKG51bGwsIGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zLCBtZXRob2QsIGlzR2VuZXJhdG9yKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VHZW5lcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycygpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2QocGFyYW1zKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRnVuY3Rpb25FeHByZXNzaW9uKG51bGwsIHBhcmFtcy5wYXJhbXMsIG1ldGhvZCwgaXNHZW5lcmF0b3IpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2VuZXJhdG9yLWZ1bmN0aW9uLWRlZmluaXRpb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuaXNTdGFydE9mRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmxvb2thaGVhZC52YWx1ZTtcclxuXHQgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgNyAvKiBQdW5jdHVhdG9yICovOlxyXG5cdCAgICAgICAgICAgICAgICBzdGFydCA9ICh2YWx1ZSA9PT0gJ1snKSB8fCAodmFsdWUgPT09ICcoJykgfHwgKHZhbHVlID09PSAneycpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICcrJykgfHwgKHZhbHVlID09PSAnLScpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICchJykgfHwgKHZhbHVlID09PSAnficpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICcrKycpIHx8ICh2YWx1ZSA9PT0gJy0tJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJy8nKSB8fCAodmFsdWUgPT09ICcvPScpOyAvLyByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbFxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDQgLyogS2V5d29yZCAqLzpcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQgPSAodmFsdWUgPT09ICdjbGFzcycpIHx8ICh2YWx1ZSA9PT0gJ2RlbGV0ZScpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICdmdW5jdGlvbicpIHx8ICh2YWx1ZSA9PT0gJ2xldCcpIHx8ICh2YWx1ZSA9PT0gJ25ldycpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICdzdXBlcicpIHx8ICh2YWx1ZSA9PT0gJ3RoaXMnKSB8fCAodmFsdWUgPT09ICd0eXBlb2YnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAndm9pZCcpIHx8ICh2YWx1ZSA9PT0gJ3lpZWxkJyk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHN0YXJ0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlWWllbGRFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgneWllbGQnKTtcclxuXHQgICAgICAgIHZhciBhcmd1bWVudCA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgZGVsZWdhdGUgPSBmYWxzZTtcclxuXHQgICAgICAgIGlmICghdGhpcy5oYXNMaW5lVGVybWluYXRvcikge1xyXG5cdCAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIGRlbGVnYXRlID0gdGhpcy5tYXRjaCgnKicpO1xyXG5cdCAgICAgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBhcmd1bWVudCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzU3RhcnRPZkV4cHJlc3Npb24oKSkge1xyXG5cdCAgICAgICAgICAgICAgICBhcmd1bWVudCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLllpZWxkRXhwcmVzc2lvbihhcmd1bWVudCwgZGVsZWdhdGUpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY2xhc3MtZGVmaW5pdGlvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRWxlbWVudCA9IGZ1bmN0aW9uIChoYXNDb25zdHJ1Y3Rvcikge1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGtpbmQgPSAnJztcclxuXHQgICAgICAgIHZhciBrZXkgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBjb21wdXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGlzU3RhdGljID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgaXNBc3luYyA9IGZhbHNlO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJyonKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICB2YXIgaWQgPSBrZXk7XHJcblx0ICAgICAgICAgICAgaWYgKGlkLm5hbWUgPT09ICdzdGF0aWMnICYmICh0aGlzLnF1YWxpZmllZFByb3BlcnR5TmFtZSh0aGlzLmxvb2thaGVhZCkgfHwgdGhpcy5tYXRjaCgnKicpKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgICAgICBpc1N0YXRpYyA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKCh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pICYmICF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yICYmICh0b2tlbi52YWx1ZSA9PT0gJ2FzeW5jJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHB1bmN0dWF0b3IgPSB0aGlzLmxvb2thaGVhZC52YWx1ZTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHB1bmN0dWF0b3IgIT09ICc6JyAmJiBwdW5jdHVhdG9yICE9PSAnKCcgJiYgcHVuY3R1YXRvciAhPT0gJyonKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdnZXQnIHx8IHRva2VuLnZhbHVlID09PSAnc2V0Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICdjb25zdHJ1Y3RvcicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5Db25zdHJ1Y3RvcklzQXN5bmMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBsb29rYWhlYWRQcm9wZXJ0eUtleSA9IHRoaXMucXVhbGlmaWVkUHJvcGVydHlOYW1lKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdnZXQnICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XHJcblx0ICAgICAgICAgICAgICAgIGtpbmQgPSAnZ2V0JztcclxuXHQgICAgICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VHZXR0ZXJNZXRob2QoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICdzZXQnICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XHJcblx0ICAgICAgICAgICAgICAgIGtpbmQgPSAnc2V0JztcclxuXHQgICAgICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VTZXR0ZXJNZXRob2QoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgdG9rZW4udmFsdWUgPT09ICcqJyAmJiBsb29rYWhlYWRQcm9wZXJ0eUtleSkge1xyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnaW5pdCc7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlR2VuZXJhdG9yTWV0aG9kKCk7XHJcblx0ICAgICAgICAgICAgbWV0aG9kID0gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICgha2luZCAmJiBrZXkgJiYgdGhpcy5tYXRjaCgnKCcpKSB7XHJcblx0ICAgICAgICAgICAga2luZCA9ICdpbml0JztcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IGlzQXN5bmMgPyB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2RBc3luY0Z1bmN0aW9uKCkgOiB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2RGdW5jdGlvbigpO1xyXG5cdCAgICAgICAgICAgIG1ldGhvZCA9IHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIWtpbmQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChraW5kID09PSAnaW5pdCcpIHtcclxuXHQgICAgICAgICAgICBraW5kID0gJ21ldGhvZCc7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIWNvbXB1dGVkKSB7XHJcblx0ICAgICAgICAgICAgaWYgKGlzU3RhdGljICYmIHRoaXMuaXNQcm9wZXJ0eUtleShrZXksICdwcm90b3R5cGUnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0YXRpY1Byb3RvdHlwZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICghaXNTdGF0aWMgJiYgdGhpcy5pc1Byb3BlcnR5S2V5KGtleSwgJ2NvbnN0cnVjdG9yJykpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGtpbmQgIT09ICdtZXRob2QnIHx8ICFtZXRob2QgfHwgKHZhbHVlICYmIHZhbHVlLmdlbmVyYXRvcikpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuQ29uc3RydWN0b3JTcGVjaWFsTWV0aG9kKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoaGFzQ29uc3RydWN0b3IudmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuRHVwbGljYXRlQ29uc3RydWN0b3IpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaGFzQ29uc3RydWN0b3IudmFsdWUgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGtpbmQgPSAnY29uc3RydWN0b3InO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLk1ldGhvZERlZmluaXRpb24oa2V5LCBjb21wdXRlZCwgdmFsdWUsIGtpbmQsIGlzU3RhdGljKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0VsZW1lbnRMaXN0ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSBbXTtcclxuXHQgICAgICAgIHZhciBoYXNDb25zdHJ1Y3RvciA9IHsgdmFsdWU6IGZhbHNlIH07XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnOycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBib2R5LnB1c2godGhpcy5wYXJzZUNsYXNzRWxlbWVudChoYXNDb25zdHJ1Y3RvcikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICByZXR1cm4gYm9keTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzQm9keSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZWxlbWVudExpc3QgPSB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TGlzdCgpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQ2xhc3NCb2R5KGVsZW1lbnRMaXN0KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0RlY2xhcmF0aW9uID0gZnVuY3Rpb24gKGlkZW50aWZpZXJJc09wdGlvbmFsKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0ID0gdGhpcy5jb250ZXh0LnN0cmljdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdjbGFzcycpO1xyXG5cdCAgICAgICAgdmFyIGlkID0gKGlkZW50aWZpZXJJc09wdGlvbmFsICYmICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAzIC8qIElkZW50aWZpZXIgKi8pKSA/IG51bGwgOiB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICB2YXIgc3VwZXJDbGFzcyA9IG51bGw7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2V4dGVuZHMnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgc3VwZXJDbGFzcyA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgY2xhc3NCb2R5ID0gdGhpcy5wYXJzZUNsYXNzQm9keSgpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQ2xhc3NEZWNsYXJhdGlvbihpZCwgc3VwZXJDbGFzcywgY2xhc3NCb2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0V4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0ID0gdGhpcy5jb250ZXh0LnN0cmljdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdjbGFzcycpO1xyXG5cdCAgICAgICAgdmFyIGlkID0gKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykgPyB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCkgOiBudWxsO1xyXG5cdCAgICAgICAgdmFyIHN1cGVyQ2xhc3MgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdleHRlbmRzJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHN1cGVyQ2xhc3MgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGNsYXNzQm9keSA9IHRoaXMucGFyc2VDbGFzc0JvZHkoKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNsYXNzRXhwcmVzc2lvbihpZCwgc3VwZXJDbGFzcywgY2xhc3NCb2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXNjcmlwdHNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbW9kdWxlc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTW9kdWxlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNNb2R1bGUgPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZURpcmVjdGl2ZVByb2xvZ3VlcygpO1xyXG5cdCAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgYm9keS5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLk1vZHVsZShib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTY3JpcHQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRGlyZWN0aXZlUHJvbG9ndWVzKCk7XHJcblx0ICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICBib2R5LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuU2NyaXB0KGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaW1wb3J0c1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTW9kdWxlU3BlY2lmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSA4IC8qIFN0cmluZ0xpdGVyYWwgKi8pIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkTW9kdWxlU3BlY2lmaWVyKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB2YXIgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5MaXRlcmFsKHRva2VuLnZhbHVlLCByYXcpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaW1wb3J0IHs8Zm9vIGFzIGJhcj59IC4uLjtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUltcG9ydFNwZWNpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaW1wb3J0ZWQ7XHJcblx0ICAgICAgICB2YXIgbG9jYWw7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgaW1wb3J0ZWQgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgbG9jYWwgPSBpbXBvcnRlZDtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGxvY2FsID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGltcG9ydGVkID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICAgICAgbG9jYWwgPSBpbXBvcnRlZDtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGxvY2FsID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JbXBvcnRTcGVjaWZpZXIobG9jYWwsIGltcG9ydGVkKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIHtmb28sIGJhciBhcyBiYXN9XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VOYW1lZEltcG9ydHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgdmFyIHNwZWNpZmllcnMgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXIoKSk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHNwZWNpZmllcnM7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGltcG9ydCA8Zm9vPiAuLi47XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBsb2NhbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSW1wb3J0RGVmYXVsdFNwZWNpZmllcihsb2NhbCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBpbXBvcnQgPCogYXMgZm9vPiAuLi47XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJyonKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuTm9Bc0FmdGVySW1wb3J0TmFtZXNwYWNlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB2YXIgbG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkltcG9ydE5hbWVzcGFjZVNwZWNpZmllcihsb2NhbCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSW1wb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbEltcG9ydERlY2xhcmF0aW9uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2ltcG9ydCcpO1xyXG5cdCAgICAgICAgdmFyIHNyYztcclxuXHQgICAgICAgIHZhciBzcGVjaWZpZXJzID0gW107XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gOCAvKiBTdHJpbmdMaXRlcmFsICovKSB7XHJcblx0ICAgICAgICAgICAgLy8gaW1wb3J0ICdmb28nO1xyXG5cdCAgICAgICAgICAgIHNyYyA9IHRoaXMucGFyc2VNb2R1bGVTcGVjaWZpZXIoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCd7JykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gaW1wb3J0IHtiYXJ9XHJcblx0ICAgICAgICAgICAgICAgIHNwZWNpZmllcnMgPSBzcGVjaWZpZXJzLmNvbmNhdCh0aGlzLnBhcnNlTmFtZWRJbXBvcnRzKCkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcqJykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gaW1wb3J0ICogYXMgZm9vXHJcblx0ICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh0aGlzLnBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKCkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzSWRlbnRpZmllck5hbWUodGhpcy5sb29rYWhlYWQpICYmICF0aGlzLm1hdGNoS2V5d29yZCgnZGVmYXVsdCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGltcG9ydCBmb29cclxuXHQgICAgICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHRoaXMucGFyc2VJbXBvcnREZWZhdWx0U3BlY2lmaWVyKCkpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyonKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltcG9ydCBmb28sICogYXMgZm9vXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHRoaXMucGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCd7JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbXBvcnQgZm9vLCB7YmFyfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZmllcnMgPSBzcGVjaWZpZXJzLmNvbmNhdCh0aGlzLnBhcnNlTmFtZWRJbXBvcnRzKCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLmxvb2thaGVhZC52YWx1ZSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuIDogbWVzc2FnZXNfMS5NZXNzYWdlcy5NaXNzaW5nRnJvbUNsYXVzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIHRoaXMubG9va2FoZWFkLnZhbHVlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBzcmMgPSB0aGlzLnBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkltcG9ydERlY2xhcmF0aW9uKHNwZWNpZmllcnMsIHNyYykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1leHBvcnRzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VFeHBvcnRTcGVjaWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICB2YXIgZXhwb3J0ZWQgPSBsb2NhbDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGV4cG9ydGVkID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnRTcGVjaWZpZXIobG9jYWwsIGV4cG9ydGVkKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VFeHBvcnREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsRXhwb3J0RGVjbGFyYXRpb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZXhwb3J0Jyk7XHJcblx0ICAgICAgICB2YXIgZXhwb3J0RGVjbGFyYXRpb247XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xyXG5cdCAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IC4uLlxyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdmdW5jdGlvbicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvbyAoKSB7fVxyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7fVxyXG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbih0cnVlKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihkZWNsYXJhdGlvbikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnY2xhc3MnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBjbGFzcyBmb28ge31cclxuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUNsYXNzRGVjbGFyYXRpb24odHJ1ZSk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhc3luYycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGYgKCkge31cclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gKCkge31cclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgYXN5bmMgeCA9PiB4XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMubWF0Y2hBc3luY0Z1bmN0aW9uKCkgPyB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbih0cnVlKSA6IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgdGhpcy5sb29rYWhlYWQudmFsdWUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IHt9O1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBbXTtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgKDEgKyAyKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5tYXRjaCgneycpID8gdGhpcy5wYXJzZU9iamVjdEluaXRpYWxpemVyKCkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaCgnWycpID8gdGhpcy5wYXJzZUFycmF5SW5pdGlhbGl6ZXIoKSA6IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihkZWNsYXJhdGlvbikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJyonKSkge1xyXG5cdCAgICAgICAgICAgIC8vIGV4cG9ydCAqIGZyb20gJ2Zvbyc7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnZnJvbScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5sb29rYWhlYWQudmFsdWUgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiA6IG1lc3NhZ2VzXzEuTWVzc2FnZXMuTWlzc2luZ0Zyb21DbGF1c2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCB0aGlzLmxvb2thaGVhZC52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdmFyIHNyYyA9IHRoaXMucGFyc2VNb2R1bGVTcGVjaWZpZXIoKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0QWxsRGVjbGFyYXRpb24oc3JjKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pIHtcclxuXHQgICAgICAgICAgICAvLyBleHBvcnQgdmFyIGYgPSAxO1xyXG5cdCAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHZvaWQgMDtcclxuXHQgICAgICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2xldCc6XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2NvbnN0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUxleGljYWxEZWNsYXJhdGlvbih7IGluRm9yOiBmYWxzZSB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICd2YXInOlxyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdjbGFzcyc6XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0TmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwgW10sIG51bGwpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hBc3luY0Z1bmN0aW9uKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnROYW1lZERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLCBbXSwgbnVsbCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFyIHNwZWNpZmllcnMgPSBbXTtcclxuXHQgICAgICAgICAgICB2YXIgc291cmNlID0gbnVsbDtcclxuXHQgICAgICAgICAgICB2YXIgaXNFeHBvcnRGcm9tSWRlbnRpZmllciA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgaXNFeHBvcnRGcm9tSWRlbnRpZmllciA9IGlzRXhwb3J0RnJvbUlkZW50aWZpZXIgfHwgdGhpcy5tYXRjaEtleXdvcmQoJ2RlZmF1bHQnKTtcclxuXHQgICAgICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXIoKSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnZnJvbScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCB7ZGVmYXVsdH0gZnJvbSAnZm9vJztcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IHtmb299IGZyb20gJ2Zvbyc7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMucGFyc2VNb2R1bGVTcGVjaWZpZXIoKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGlzRXhwb3J0RnJvbUlkZW50aWZpZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IHtkZWZhdWx0fTsgLy8gbWlzc2luZyBmcm9tQ2xhdXNlXHJcblx0ICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5sb29rYWhlYWQudmFsdWUgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiA6IG1lc3NhZ2VzXzEuTWVzc2FnZXMuTWlzc2luZ0Zyb21DbGF1c2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCB0aGlzLmxvb2thaGVhZC52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQge2Zvb307XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0TmFtZWREZWNsYXJhdGlvbihudWxsLCBzcGVjaWZpZXJzLCBzb3VyY2UpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHBvcnREZWNsYXJhdGlvbjtcclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIFBhcnNlcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xyXG5cblxuLyoqKi8gfSxcbi8qIDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdC8vIEVuc3VyZSB0aGUgY29uZGl0aW9uIGlzIHRydWUsIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvci5cclxuXHQvLyBUaGlzIGlzIG9ubHkgdG8gaGF2ZSBhIGJldHRlciBjb250cmFjdCBzZW1hbnRpYywgaS5lLiBhbm90aGVyIHNhZmV0eSBuZXRcclxuXHQvLyB0byBjYXRjaCBhIGxvZ2ljIGVycm9yLiBUaGUgY29uZGl0aW9uIHNoYWxsIGJlIGZ1bGZpbGxlZCBpbiBub3JtYWwgY2FzZS5cclxuXHQvLyBEbyBOT1QgdXNlIHRoaXMgdG8gZW5mb3JjZSBhIGNlcnRhaW4gY29uZGl0aW9uIG9uIGFueSB1c2VyIGlucHV0LlxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHRmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XHJcblx0ICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG5cdCAgICBpZiAoIWNvbmRpdGlvbikge1xyXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBU1NFUlQ6ICcgKyBtZXNzYWdlKTtcclxuXHQgICAgfVxyXG5cdH1cclxuXHRleHBvcnRzLmFzc2VydCA9IGFzc2VydDtcclxuXG5cbi8qKiovIH0sXG4vKiAxMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0LyogdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIEVycm9ySGFuZGxlciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEVycm9ySGFuZGxlcigpIHtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JzID0gW107XHJcblx0ICAgICAgICB0aGlzLnRvbGVyYW50ID0gZmFsc2U7XHJcblx0ICAgIH1cclxuXHQgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5yZWNvcmRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG5cdCAgICAgICAgdGhpcy5lcnJvcnMucHVzaChlcnJvcik7XHJcblx0ICAgIH07XHJcblx0ICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUudG9sZXJhdGUgPSBmdW5jdGlvbiAoZXJyb3IpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5yZWNvcmRFcnJvcihlcnJvcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RFcnJvciA9IGZ1bmN0aW9uIChtc2csIGNvbHVtbikge1xyXG5cdCAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1zZyk7XHJcblx0ICAgICAgICB0cnkge1xyXG5cdCAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgY2F0Y2ggKGJhc2UpIHtcclxuXHQgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG5cdCAgICAgICAgICAgIGlmIChPYmplY3QuY3JlYXRlICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xyXG5cdCAgICAgICAgICAgICAgICBlcnJvciA9IE9iamVjdC5jcmVhdGUoYmFzZSk7XHJcblx0ICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvciwgJ2NvbHVtbicsIHsgdmFsdWU6IGNvbHVtbiB9KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgICAgICAgcmV0dXJuIGVycm9yO1xyXG5cdCAgICB9O1xyXG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUVycm9yID0gZnVuY3Rpb24gKGluZGV4LCBsaW5lLCBjb2wsIGRlc2NyaXB0aW9uKSB7XHJcblx0ICAgICAgICB2YXIgbXNnID0gJ0xpbmUgJyArIGxpbmUgKyAnOiAnICsgZGVzY3JpcHRpb247XHJcblx0ICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLmNvbnN0cnVjdEVycm9yKG1zZywgY29sKTtcclxuXHQgICAgICAgIGVycm9yLmluZGV4ID0gaW5kZXg7XHJcblx0ICAgICAgICBlcnJvci5saW5lTnVtYmVyID0gbGluZTtcclxuXHQgICAgICAgIGVycm9yLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XHJcblx0ICAgICAgICByZXR1cm4gZXJyb3I7XHJcblx0ICAgIH07XHJcblx0ICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUudGhyb3dFcnJvciA9IGZ1bmN0aW9uIChpbmRleCwgbGluZSwgY29sLCBkZXNjcmlwdGlvbikge1xyXG5cdCAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFcnJvcihpbmRleCwgbGluZSwgY29sLCBkZXNjcmlwdGlvbik7XHJcblx0ICAgIH07XHJcblx0ICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUudG9sZXJhdGVFcnJvciA9IGZ1bmN0aW9uIChpbmRleCwgbGluZSwgY29sLCBkZXNjcmlwdGlvbikge1xyXG5cdCAgICAgICAgdmFyIGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihpbmRleCwgbGluZSwgY29sLCBkZXNjcmlwdGlvbik7XHJcblx0ICAgICAgICBpZiAodGhpcy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMucmVjb3JkRXJyb3IoZXJyb3IpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBFcnJvckhhbmRsZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkVycm9ySGFuZGxlciA9IEVycm9ySGFuZGxlcjtcclxuXG5cbi8qKiovIH0sXG4vKiAxMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdC8vIEVycm9yIG1lc3NhZ2VzIHNob3VsZCBiZSBpZGVudGljYWwgdG8gVjguXHJcblx0ZXhwb3J0cy5NZXNzYWdlcyA9IHtcclxuXHQgICAgQmFkR2V0dGVyQXJpdHk6ICdHZXR0ZXIgbXVzdCBub3QgaGF2ZSBhbnkgZm9ybWFsIHBhcmFtZXRlcnMnLFxyXG5cdCAgICBCYWRTZXR0ZXJBcml0eTogJ1NldHRlciBtdXN0IGhhdmUgZXhhY3RseSBvbmUgZm9ybWFsIHBhcmFtZXRlcicsXHJcblx0ICAgIEJhZFNldHRlclJlc3RQYXJhbWV0ZXI6ICdTZXR0ZXIgZnVuY3Rpb24gYXJndW1lbnQgbXVzdCBub3QgYmUgYSByZXN0IHBhcmFtZXRlcicsXHJcblx0ICAgIENvbnN0cnVjdG9ySXNBc3luYzogJ0NsYXNzIGNvbnN0cnVjdG9yIG1heSBub3QgYmUgYW4gYXN5bmMgbWV0aG9kJyxcclxuXHQgICAgQ29uc3RydWN0b3JTcGVjaWFsTWV0aG9kOiAnQ2xhc3MgY29uc3RydWN0b3IgbWF5IG5vdCBiZSBhbiBhY2Nlc3NvcicsXHJcblx0ICAgIERlY2xhcmF0aW9uTWlzc2luZ0luaXRpYWxpemVyOiAnTWlzc2luZyBpbml0aWFsaXplciBpbiAlMCBkZWNsYXJhdGlvbicsXHJcblx0ICAgIERlZmF1bHRSZXN0UGFyYW1ldGVyOiAnVW5leHBlY3RlZCB0b2tlbiA9JyxcclxuXHQgICAgRHVwbGljYXRlQmluZGluZzogJ0R1cGxpY2F0ZSBiaW5kaW5nICUwJyxcclxuXHQgICAgRHVwbGljYXRlQ29uc3RydWN0b3I6ICdBIGNsYXNzIG1heSBvbmx5IGhhdmUgb25lIGNvbnN0cnVjdG9yJyxcclxuXHQgICAgRHVwbGljYXRlUHJvdG9Qcm9wZXJ0eTogJ0R1cGxpY2F0ZSBfX3Byb3RvX18gZmllbGRzIGFyZSBub3QgYWxsb3dlZCBpbiBvYmplY3QgbGl0ZXJhbHMnLFxyXG5cdCAgICBGb3JJbk9mTG9vcEluaXRpYWxpemVyOiAnJTAgbG9vcCB2YXJpYWJsZSBkZWNsYXJhdGlvbiBtYXkgbm90IGhhdmUgYW4gaW5pdGlhbGl6ZXInLFxyXG5cdCAgICBHZW5lcmF0b3JJbkxlZ2FjeUNvbnRleHQ6ICdHZW5lcmF0b3IgZGVjbGFyYXRpb25zIGFyZSBub3QgYWxsb3dlZCBpbiBsZWdhY3kgY29udGV4dHMnLFxyXG5cdCAgICBJbGxlZ2FsQnJlYWs6ICdJbGxlZ2FsIGJyZWFrIHN0YXRlbWVudCcsXHJcblx0ICAgIElsbGVnYWxDb250aW51ZTogJ0lsbGVnYWwgY29udGludWUgc3RhdGVtZW50JyxcclxuXHQgICAgSWxsZWdhbEV4cG9ydERlY2xhcmF0aW9uOiAnVW5leHBlY3RlZCB0b2tlbicsXHJcblx0ICAgIElsbGVnYWxJbXBvcnREZWNsYXJhdGlvbjogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxyXG5cdCAgICBJbGxlZ2FsTGFuZ3VhZ2VNb2RlRGlyZWN0aXZlOiAnSWxsZWdhbCBcXCd1c2Ugc3RyaWN0XFwnIGRpcmVjdGl2ZSBpbiBmdW5jdGlvbiB3aXRoIG5vbi1zaW1wbGUgcGFyYW1ldGVyIGxpc3QnLFxyXG5cdCAgICBJbGxlZ2FsUmV0dXJuOiAnSWxsZWdhbCByZXR1cm4gc3RhdGVtZW50JyxcclxuXHQgICAgSW52YWxpZEVzY2FwZWRSZXNlcnZlZFdvcmQ6ICdLZXl3b3JkIG11c3Qgbm90IGNvbnRhaW4gZXNjYXBlZCBjaGFyYWN0ZXJzJyxcclxuXHQgICAgSW52YWxpZEhleEVzY2FwZVNlcXVlbmNlOiAnSW52YWxpZCBoZXhhZGVjaW1hbCBlc2NhcGUgc2VxdWVuY2UnLFxyXG5cdCAgICBJbnZhbGlkTEhTSW5Bc3NpZ25tZW50OiAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBhc3NpZ25tZW50JyxcclxuXHQgICAgSW52YWxpZExIU0luRm9ySW46ICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci1pbicsXHJcblx0ICAgIEludmFsaWRMSFNJbkZvckxvb3A6ICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci1sb29wJyxcclxuXHQgICAgSW52YWxpZE1vZHVsZVNwZWNpZmllcjogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxyXG5cdCAgICBJbnZhbGlkUmVnRXhwOiAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24nLFxyXG5cdCAgICBMZXRJbkxleGljYWxCaW5kaW5nOiAnbGV0IGlzIGRpc2FsbG93ZWQgYXMgYSBsZXhpY2FsbHkgYm91bmQgbmFtZScsXHJcblx0ICAgIE1pc3NpbmdGcm9tQ2xhdXNlOiAnVW5leHBlY3RlZCB0b2tlbicsXHJcblx0ICAgIE11bHRpcGxlRGVmYXVsdHNJblN3aXRjaDogJ01vcmUgdGhhbiBvbmUgZGVmYXVsdCBjbGF1c2UgaW4gc3dpdGNoIHN0YXRlbWVudCcsXHJcblx0ICAgIE5ld2xpbmVBZnRlclRocm93OiAnSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93JyxcclxuXHQgICAgTm9Bc0FmdGVySW1wb3J0TmFtZXNwYWNlOiAnVW5leHBlY3RlZCB0b2tlbicsXHJcblx0ICAgIE5vQ2F0Y2hPckZpbmFsbHk6ICdNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgYWZ0ZXIgdHJ5JyxcclxuXHQgICAgUGFyYW1ldGVyQWZ0ZXJSZXN0UGFyYW1ldGVyOiAnUmVzdCBwYXJhbWV0ZXIgbXVzdCBiZSBsYXN0IGZvcm1hbCBwYXJhbWV0ZXInLFxyXG5cdCAgICBSZWRlY2xhcmF0aW9uOiAnJTAgXFwnJTFcXCcgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZCcsXHJcblx0ICAgIFN0YXRpY1Byb3RvdHlwZTogJ0NsYXNzZXMgbWF5IG5vdCBoYXZlIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGUnLFxyXG5cdCAgICBTdHJpY3RDYXRjaFZhcmlhYmxlOiAnQ2F0Y2ggdmFyaWFibGUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdERlbGV0ZTogJ0RlbGV0ZSBvZiBhbiB1bnF1YWxpZmllZCBpZGVudGlmaWVyIGluIHN0cmljdCBtb2RlLicsXHJcblx0ICAgIFN0cmljdEZ1bmN0aW9uOiAnSW4gc3RyaWN0IG1vZGUgY29kZSwgZnVuY3Rpb25zIGNhbiBvbmx5IGJlIGRlY2xhcmVkIGF0IHRvcCBsZXZlbCBvciBpbnNpZGUgYSBibG9jaycsXHJcblx0ICAgIFN0cmljdEZ1bmN0aW9uTmFtZTogJ0Z1bmN0aW9uIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdExIU0Fzc2lnbm1lbnQ6ICdBc3NpZ25tZW50IHRvIGV2YWwgb3IgYXJndW1lbnRzIGlzIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0TEhTUG9zdGZpeDogJ1Bvc3RmaXggaW5jcmVtZW50L2RlY3JlbWVudCBtYXkgbm90IGhhdmUgZXZhbCBvciBhcmd1bWVudHMgb3BlcmFuZCBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdExIU1ByZWZpeDogJ1ByZWZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0TW9kZVdpdGg6ICdTdHJpY3QgbW9kZSBjb2RlIG1heSBub3QgaW5jbHVkZSBhIHdpdGggc3RhdGVtZW50JyxcclxuXHQgICAgU3RyaWN0T2N0YWxMaXRlcmFsOiAnT2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlLicsXHJcblx0ICAgIFN0cmljdFBhcmFtRHVwZTogJ1N0cmljdCBtb2RlIGZ1bmN0aW9uIG1heSBub3QgaGF2ZSBkdXBsaWNhdGUgcGFyYW1ldGVyIG5hbWVzJyxcclxuXHQgICAgU3RyaWN0UGFyYW1OYW1lOiAnUGFyYW1ldGVyIG5hbWUgZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3RSZXNlcnZlZFdvcmQ6ICdVc2Ugb2YgZnV0dXJlIHJlc2VydmVkIHdvcmQgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3RWYXJOYW1lOiAnVmFyaWFibGUgbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgVGVtcGxhdGVPY3RhbExpdGVyYWw6ICdPY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gdGVtcGxhdGUgc3RyaW5ncy4nLFxyXG5cdCAgICBVbmV4cGVjdGVkRU9TOiAnVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnLFxyXG5cdCAgICBVbmV4cGVjdGVkSWRlbnRpZmllcjogJ1VuZXhwZWN0ZWQgaWRlbnRpZmllcicsXHJcblx0ICAgIFVuZXhwZWN0ZWROdW1iZXI6ICdVbmV4cGVjdGVkIG51bWJlcicsXHJcblx0ICAgIFVuZXhwZWN0ZWRSZXNlcnZlZDogJ1VuZXhwZWN0ZWQgcmVzZXJ2ZWQgd29yZCcsXHJcblx0ICAgIFVuZXhwZWN0ZWRTdHJpbmc6ICdVbmV4cGVjdGVkIHN0cmluZycsXHJcblx0ICAgIFVuZXhwZWN0ZWRUZW1wbGF0ZTogJ1VuZXhwZWN0ZWQgcXVhc2kgJTAnLFxyXG5cdCAgICBVbmV4cGVjdGVkVG9rZW46ICdVbmV4cGVjdGVkIHRva2VuICUwJyxcclxuXHQgICAgVW5leHBlY3RlZFRva2VuSWxsZWdhbDogJ1VuZXhwZWN0ZWQgdG9rZW4gSUxMRUdBTCcsXHJcblx0ICAgIFVua25vd25MYWJlbDogJ1VuZGVmaW5lZCBsYWJlbCBcXCclMFxcJycsXHJcblx0ICAgIFVudGVybWluYXRlZFJlZ0V4cDogJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiBtaXNzaW5nIC8nXHJcblx0fTtcclxuXG5cbi8qKiovIH0sXG4vKiAxMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBhc3NlcnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcblx0dmFyIGNoYXJhY3Rlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHR2YXIgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG5cdGZ1bmN0aW9uIGhleFZhbHVlKGNoKSB7XHJcblx0ICAgIHJldHVybiAnMDEyMzQ1Njc4OWFiY2RlZicuaW5kZXhPZihjaC50b0xvd2VyQ2FzZSgpKTtcclxuXHR9XHJcblx0ZnVuY3Rpb24gb2N0YWxWYWx1ZShjaCkge1xyXG5cdCAgICByZXR1cm4gJzAxMjM0NTY3Jy5pbmRleE9mKGNoKTtcclxuXHR9XHJcblx0dmFyIFNjYW5uZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTY2FubmVyKGNvZGUsIGhhbmRsZXIpIHtcclxuXHQgICAgICAgIHRoaXMuc291cmNlID0gY29kZTtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gaGFuZGxlcjtcclxuXHQgICAgICAgIHRoaXMudHJhY2tDb21tZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmxlbmd0aCA9IGNvZGUubGVuZ3RoO1xyXG5cdCAgICAgICAgdGhpcy5pbmRleCA9IDA7XHJcblx0ICAgICAgICB0aGlzLmxpbmVOdW1iZXIgPSAoY29kZS5sZW5ndGggPiAwKSA/IDEgOiAwO1xyXG5cdCAgICAgICAgdGhpcy5saW5lU3RhcnQgPSAwO1xyXG5cdCAgICAgICAgdGhpcy5jdXJseVN0YWNrID0gW107XHJcblx0ICAgIH1cclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2F2ZVN0YXRlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUucmVzdG9yZVN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcblx0ICAgICAgICB0aGlzLmluZGV4ID0gc3RhdGUuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLmxpbmVOdW1iZXIgPSBzdGF0ZS5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5saW5lU3RhcnQgPSBzdGF0ZS5saW5lU3RhcnQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmVvZiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmluZGV4ID49IHRoaXMubGVuZ3RoO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS50aHJvd1VuZXhwZWN0ZWRUb2tlbiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcblx0ICAgICAgICBpZiAobWVzc2FnZSA9PT0gdm9pZCAwKSB7IG1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbklsbGVnYWw7IH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmVycm9ySGFuZGxlci50aHJvd0Vycm9yKHRoaXMuaW5kZXgsIHRoaXMubGluZU51bWJlciwgdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0ICsgMSwgbWVzc2FnZSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuXHQgICAgICAgIGlmIChtZXNzYWdlID09PSB2b2lkIDApIHsgbWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuSWxsZWdhbDsgfVxyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIudG9sZXJhdGVFcnJvcih0aGlzLmluZGV4LCB0aGlzLmxpbmVOdW1iZXIsIHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydCArIDEsIG1lc3NhZ2UpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jb21tZW50c1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5za2lwU2luZ2xlTGluZUNvbW1lbnQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0ICAgICAgICB2YXIgY29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgIHZhciBzdGFydCwgbG9jO1xyXG5cdCAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgICAgICBzdGFydCA9IHRoaXMuaW5kZXggLSBvZmZzZXQ7XHJcblx0ICAgICAgICAgICAgbG9jID0ge1xyXG5cdCAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnQgLSBvZmZzZXRcclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB7fVxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbG9jLmVuZCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnQgLSAxXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpTGluZTogZmFsc2UsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2U6IFtzdGFydCArIG9mZnNldCwgdGhpcy5pbmRleCAtIDFdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIHRoaXMuaW5kZXggLSAxXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IGxvY1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMTMgJiYgdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSA9PT0gMTApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY29tbWVudHM7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgbG9jLmVuZCA9IHtcclxuXHQgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG5cdCAgICAgICAgICAgICAgICBtdWx0aUxpbmU6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgICAgICBzbGljZTogW3N0YXJ0ICsgb2Zmc2V0LCB0aGlzLmluZGV4XSxcclxuXHQgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgdGhpcy5pbmRleF0sXHJcblx0ICAgICAgICAgICAgICAgIGxvYzogbG9jXHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICBjb21tZW50cy5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBjb21tZW50cztcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2tpcE11bHRpTGluZUNvbW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgIHZhciBzdGFydCwgbG9jO1xyXG5cdCAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgICAgICBzdGFydCA9IHRoaXMuaW5kZXggLSAyO1xyXG5cdCAgICAgICAgICAgIGxvYyA9IHtcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0IC0gMlxyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHt9XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MEQgJiYgdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSkgPT09IDB4MEEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAweDJBKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIEJsb2NrIGNvbW1lbnQgZW5kcyB3aXRoICcqLycuXHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAxKSA9PT0gMHgyRikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9jLmVuZCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aUxpbmU6IHRydWUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlOiBbc3RhcnQgKyAyLCB0aGlzLmluZGV4IC0gMl0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIHRoaXMuaW5kZXhdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IGxvY1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tbWVudHM7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFJhbiBvZmYgdGhlIGVuZCBvZiB0aGUgZmlsZSAtIHRoZSB3aG9sZSB0aGluZyBpcyBhIGNvbW1lbnRcclxuXHQgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIGxvYy5lbmQgPSB7XHJcblx0ICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnRcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcclxuXHQgICAgICAgICAgICAgICAgbXVsdGlMaW5lOiB0cnVlLFxyXG5cdCAgICAgICAgICAgICAgICBzbGljZTogW3N0YXJ0ICsgMiwgdGhpcy5pbmRleF0sXHJcblx0ICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIHRoaXMuaW5kZXhdLFxyXG5cdCAgICAgICAgICAgICAgICBsb2M6IGxvY1xyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgY29tbWVudHMucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICByZXR1cm4gY29tbWVudHM7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5Db21tZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjb21tZW50cztcclxuXHQgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSAodGhpcy5pbmRleCA9PT0gMCk7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNXaGl0ZVNwYWNlKGNoKSkge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgwRCAmJiB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpID09PSAweDBBKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gMHgyRikge1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MkYpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gdGhpcy5za2lwU2luZ2xlTGluZUNvbW1lbnQoMik7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cyA9IGNvbW1lbnRzLmNvbmNhdChjb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gMHgyQSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLnNraXBNdWx0aUxpbmVDb21tZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cyA9IGNvbW1lbnRzLmNvbmNhdChjb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0ICYmIGNoID09PSAweDJEKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIFUrMDAzRSBpcyAnPidcclxuXHQgICAgICAgICAgICAgICAgaWYgKCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAxKSA9PT0gMHgyRCkgJiYgKHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDIpID09PSAweDNFKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gJy0tPicgaXMgYSBzaW5nbGUtbGluZSBjb21tZW50XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMuc2tpcFNpbmdsZUxpbmVDb21tZW50KDMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5jb25jYXQoY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gMHgzQykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2Uuc2xpY2UodGhpcy5pbmRleCArIDEsIHRoaXMuaW5kZXggKyA0KSA9PT0gJyEtLScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gNDsgLy8gYDwhLS1gXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMuc2tpcFNpbmdsZUxpbmVDb21tZW50KDQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5jb25jYXQoY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGNvbW1lbnRzO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mdXR1cmUtcmVzZXJ2ZWQtd29yZHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuaXNGdXR1cmVSZXNlcnZlZFdvcmQgPSBmdW5jdGlvbiAoaWQpIHtcclxuXHQgICAgICAgIHN3aXRjaCAoaWQpIHtcclxuXHQgICAgICAgICAgICBjYXNlICdlbnVtJzpcclxuXHQgICAgICAgICAgICBjYXNlICdleHBvcnQnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ2ltcG9ydCc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnc3VwZXInOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCA9IGZ1bmN0aW9uIChpZCkge1xyXG5cdCAgICAgICAgc3dpdGNoIChpZCkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ2ludGVyZmFjZSc6XHJcblx0ICAgICAgICAgICAgY2FzZSAncGFja2FnZSc6XHJcblx0ICAgICAgICAgICAgY2FzZSAncHJpdmF0ZSc6XHJcblx0ICAgICAgICAgICAgY2FzZSAncHJvdGVjdGVkJzpcclxuXHQgICAgICAgICAgICBjYXNlICdwdWJsaWMnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3N0YXRpYyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAneWllbGQnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ2xldCc6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuaXNSZXN0cmljdGVkV29yZCA9IGZ1bmN0aW9uIChpZCkge1xyXG5cdCAgICAgICAgcmV0dXJuIGlkID09PSAnZXZhbCcgfHwgaWQgPT09ICdhcmd1bWVudHMnO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1rZXl3b3Jkc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5pc0tleXdvcmQgPSBmdW5jdGlvbiAoaWQpIHtcclxuXHQgICAgICAgIHN3aXRjaCAoaWQubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAyOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAnaWYnKSB8fCAoaWQgPT09ICdpbicpIHx8IChpZCA9PT0gJ2RvJyk7XHJcblx0ICAgICAgICAgICAgY2FzZSAzOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAndmFyJykgfHwgKGlkID09PSAnZm9yJykgfHwgKGlkID09PSAnbmV3JykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgIChpZCA9PT0gJ3RyeScpIHx8IChpZCA9PT0gJ2xldCcpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNDpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3RoaXMnKSB8fCAoaWQgPT09ICdlbHNlJykgfHwgKGlkID09PSAnY2FzZScpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAoaWQgPT09ICd2b2lkJykgfHwgKGlkID09PSAnd2l0aCcpIHx8IChpZCA9PT0gJ2VudW0nKTtcclxuXHQgICAgICAgICAgICBjYXNlIDU6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd3aGlsZScpIHx8IChpZCA9PT0gJ2JyZWFrJykgfHwgKGlkID09PSAnY2F0Y2gnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKGlkID09PSAndGhyb3cnKSB8fCAoaWQgPT09ICdjb25zdCcpIHx8IChpZCA9PT0gJ3lpZWxkJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgIChpZCA9PT0gJ2NsYXNzJykgfHwgKGlkID09PSAnc3VwZXInKTtcclxuXHQgICAgICAgICAgICBjYXNlIDY6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdyZXR1cm4nKSB8fCAoaWQgPT09ICd0eXBlb2YnKSB8fCAoaWQgPT09ICdkZWxldGUnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKGlkID09PSAnc3dpdGNoJykgfHwgKGlkID09PSAnZXhwb3J0JykgfHwgKGlkID09PSAnaW1wb3J0Jyk7XHJcblx0ICAgICAgICAgICAgY2FzZSA3OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAnZGVmYXVsdCcpIHx8IChpZCA9PT0gJ2ZpbmFsbHknKSB8fCAoaWQgPT09ICdleHRlbmRzJyk7XHJcblx0ICAgICAgICAgICAgY2FzZSA4OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAnZnVuY3Rpb24nKSB8fCAoaWQgPT09ICdjb250aW51ZScpIHx8IChpZCA9PT0gJ2RlYnVnZ2VyJyk7XHJcblx0ICAgICAgICAgICAgY2FzZSAxMDpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2luc3RhbmNlb2YnKTtcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmNvZGVQb2ludEF0ID0gZnVuY3Rpb24gKGkpIHtcclxuXHQgICAgICAgIHZhciBjcCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQoaSk7XHJcblx0ICAgICAgICBpZiAoY3AgPj0gMHhEODAwICYmIGNwIDw9IDB4REJGRikge1xyXG5cdCAgICAgICAgICAgIHZhciBzZWNvbmQgPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KGkgKyAxKTtcclxuXHQgICAgICAgICAgICBpZiAoc2Vjb25kID49IDB4REMwMCAmJiBzZWNvbmQgPD0gMHhERkZGKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IGNwO1xyXG5cdCAgICAgICAgICAgICAgICBjcCA9IChmaXJzdCAtIDB4RDgwMCkgKiAweDQwMCArIHNlY29uZCAtIDB4REMwMCArIDB4MTAwMDA7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGNwO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuSGV4RXNjYXBlID0gZnVuY3Rpb24gKHByZWZpeCkge1xyXG5cdCAgICAgICAgdmFyIGxlbiA9IChwcmVmaXggPT09ICd1JykgPyA0IDogMjtcclxuXHQgICAgICAgIHZhciBjb2RlID0gMDtcclxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZW9mKCkgJiYgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSGV4RGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiAxNiArIGhleFZhbHVlKHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK10pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICB2YXIgY29kZSA9IDA7XHJcblx0ICAgICAgICAvLyBBdCBsZWFzdCwgb25lIGhleCBkaWdpdCBpcyByZXF1aXJlZC5cclxuXHQgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSGV4RGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGNvZGUgPSBjb2RlICogMTYgKyBoZXhWYWx1ZShjaCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY29kZSA+IDB4MTBGRkZGIHx8IGNoICE9PSAnfScpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmZyb21Db2RlUG9pbnQoY29kZSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmdldElkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4Kys7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gMHg1Qykge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBCbGFja3NsYXNoIChVKzAwNUMpIG1hcmtzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gc3RhcnQ7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbXBsZXhJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID49IDB4RDgwMCAmJiBjaCA8IDB4REZGRikge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGhhbmRsZSBzdXJyb2dhdGUgcGFpcnMuXHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBzdGFydDtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcGxleElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc2xpY2Uoc3RhcnQsIHRoaXMuaW5kZXgpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5nZXRDb21wbGV4SWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjcCA9IHRoaXMuY29kZVBvaW50QXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICB2YXIgaWQgPSBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuZnJvbUNvZGVQb2ludChjcCk7XHJcblx0ICAgICAgICB0aGlzLmluZGV4ICs9IGlkLmxlbmd0aDtcclxuXHQgICAgICAgIC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cclxuXHQgICAgICAgIHZhciBjaDtcclxuXHQgICAgICAgIGlmIChjcCA9PT0gMHg1Qykge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpICE9PSAweDc1KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc2NhbkhleEVzY2FwZSgndScpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IG51bGwgfHwgY2ggPT09ICdcXFxcJyB8fCAhY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWQgPSBjaDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGNwID0gdGhpcy5jb2RlUG9pbnRBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJQYXJ0KGNwKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgY2ggPSBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuZnJvbUNvZGVQb2ludChjcCk7XHJcblx0ICAgICAgICAgICAgaWQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgdGhpcy5pbmRleCArPSBjaC5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxyXG5cdCAgICAgICAgICAgIGlmIChjcCA9PT0gMHg1Qykge1xyXG5cdCAgICAgICAgICAgICAgICBpZCA9IGlkLnN1YnN0cigwLCBpZC5sZW5ndGggLSAxKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkgIT09IDB4NzUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zY2FuSGV4RXNjYXBlKCd1Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IG51bGwgfHwgY2ggPT09ICdcXFxcJyB8fCAhY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGlkO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5vY3RhbFRvRGVjaW1hbCA9IGZ1bmN0aW9uIChjaCkge1xyXG5cdCAgICAgICAgLy8gXFwwIGlzIG5vdCBvY3RhbCBlc2NhcGUgc2VxdWVuY2VcclxuXHQgICAgICAgIHZhciBvY3RhbCA9IChjaCAhPT0gJzAnKTtcclxuXHQgICAgICAgIHZhciBjb2RlID0gb2N0YWxWYWx1ZShjaCk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMuZW9mKCkgJiYgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyBvY3RhbFZhbHVlKHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK10pO1xyXG5cdCAgICAgICAgICAgIC8vIDMgZGlnaXRzIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiBzdHJpbmcgc3RhcnRzXHJcblx0ICAgICAgICAgICAgLy8gd2l0aCAwLCAxLCAyLCAzXHJcblx0ICAgICAgICAgICAgaWYgKCcwMTIzJy5pbmRleE9mKGNoKSA+PSAwICYmICF0aGlzLmVvZigpICYmIGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgb2N0YWxWYWx1ZSh0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGNvZGU6IGNvZGUsXHJcblx0ICAgICAgICAgICAgb2N0YWw6IG9jdGFsXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1uYW1lcy1hbmQta2V5d29yZHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbklkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgdHlwZTtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAvLyBCYWNrc2xhc2ggKFUrMDA1Qykgc3RhcnRzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxyXG5cdCAgICAgICAgdmFyIGlkID0gKHRoaXMuc291cmNlLmNoYXJDb2RlQXQoc3RhcnQpID09PSAweDVDKSA/IHRoaXMuZ2V0Q29tcGxleElkZW50aWZpZXIoKSA6IHRoaXMuZ2V0SWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgLy8gVGhlcmUgaXMgbm8ga2V5d29yZCBvciBsaXRlcmFsIHdpdGggb25seSBvbmUgY2hhcmFjdGVyLlxyXG5cdCAgICAgICAgLy8gVGh1cywgaXQgbXVzdCBiZSBhbiBpZGVudGlmaWVyLlxyXG5cdCAgICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gMSkge1xyXG5cdCAgICAgICAgICAgIHR5cGUgPSAzIC8qIElkZW50aWZpZXIgKi87XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLmlzS2V5d29yZChpZCkpIHtcclxuXHQgICAgICAgICAgICB0eXBlID0gNCAvKiBLZXl3b3JkICovO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoaWQgPT09ICdudWxsJykge1xyXG5cdCAgICAgICAgICAgIHR5cGUgPSA1IC8qIE51bGxMaXRlcmFsICovO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoaWQgPT09ICd0cnVlJyB8fCBpZCA9PT0gJ2ZhbHNlJykge1xyXG5cdCAgICAgICAgICAgIHR5cGUgPSAxIC8qIEJvb2xlYW5MaXRlcmFsICovO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdHlwZSA9IDMgLyogSWRlbnRpZmllciAqLztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0eXBlICE9PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgKHN0YXJ0ICsgaWQubGVuZ3RoICE9PSB0aGlzLmluZGV4KSkge1xyXG5cdCAgICAgICAgICAgIHZhciByZXN0b3JlID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICB0aGlzLmluZGV4ID0gc3RhcnQ7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRFc2NhcGVkUmVzZXJ2ZWRXb3JkKTtcclxuXHQgICAgICAgICAgICB0aGlzLmluZGV4ID0gcmVzdG9yZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuXHQgICAgICAgICAgICB2YWx1ZTogaWQsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHVuY3R1YXRvcnNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblB1bmN0dWF0b3IgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgLy8gQ2hlY2sgZm9yIG1vc3QgY29tbW9uIHNpbmdsZS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXHJcblx0ICAgICAgICB2YXIgc3RyID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICBzd2l0Y2ggKHN0cikge1xyXG5cdCAgICAgICAgICAgIGNhc2UgJygnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3snOlxyXG5cdCAgICAgICAgICAgICAgICBpZiAoc3RyID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VybHlTdGFjay5wdXNoKCd7Jyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlICcuJzpcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICcuJyAmJiB0aGlzLnNvdXJjZVt0aGlzLmluZGV4ICsgMV0gPT09ICcuJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU3ByZWFkIG9wZXJhdG9yOiAuLi5cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0ciA9ICcuLi4nO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgJ30nOlxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY3VybHlTdGFjay5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAnKSc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnOyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnLCc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnWyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnXSc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnOic6XHJcblx0ICAgICAgICAgICAgY2FzZSAnPyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnfic6XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgLy8gNC1jaGFyYWN0ZXIgcHVuY3R1YXRvci5cclxuXHQgICAgICAgICAgICAgICAgc3RyID0gdGhpcy5zb3VyY2Uuc3Vic3RyKHRoaXMuaW5kZXgsIDQpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoc3RyID09PSAnPj4+PScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gNDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIDMtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigwLCAzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdHIgPT09ICc9PT0nIHx8IHN0ciA9PT0gJyE9PScgfHwgc3RyID09PSAnPj4+JyB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJzw8PScgfHwgc3RyID09PSAnPj49JyB8fCBzdHIgPT09ICcqKj0nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gMi1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigwLCAyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyID09PSAnJiYnIHx8IHN0ciA9PT0gJ3x8JyB8fCBzdHIgPT09ICc9PScgfHwgc3RyID09PSAnIT0nIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJys9JyB8fCBzdHIgPT09ICctPScgfHwgc3RyID09PSAnKj0nIHx8IHN0ciA9PT0gJy89JyB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICcrKycgfHwgc3RyID09PSAnLS0nIHx8IHN0ciA9PT0gJzw8JyB8fCBzdHIgPT09ICc+PicgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnJj0nIHx8IHN0ciA9PT0gJ3w9JyB8fCBzdHIgPT09ICdePScgfHwgc3RyID09PSAnJT0nIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJzw9JyB8fCBzdHIgPT09ICc+PScgfHwgc3RyID09PSAnPT4nIHx8IHN0ciA9PT0gJyoqJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnPD49ISstKiUmfF4vJy5pbmRleE9mKHN0cikgPj0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gc3RhcnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDcgLyogUHVuY3R1YXRvciAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogc3RyLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxpdGVyYWxzLW51bWVyaWMtbGl0ZXJhbHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbkhleExpdGVyYWwgPSBmdW5jdGlvbiAoc3RhcnQpIHtcclxuXHQgICAgICAgIHZhciBudW0gPSAnJztcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSGV4RGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKG51bS5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA2IC8qIE51bWVyaWNMaXRlcmFsICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludCgnMHgnICsgbnVtLCAxNiksXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbkJpbmFyeUxpdGVyYWwgPSBmdW5jdGlvbiAoc3RhcnQpIHtcclxuXHQgICAgICAgIHZhciBudW0gPSAnJztcclxuXHQgICAgICAgIHZhciBjaDtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICAgICAgaWYgKGNoICE9PSAnMCcgJiYgY2ggIT09ICcxJykge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAobnVtLmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgIC8vIG9ubHkgMGIgb3IgMEJcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KGNoKSB8fCBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQoY2gpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDYgLyogTnVtZXJpY0xpdGVyYWwgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHBhcnNlSW50KG51bSwgMiksXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbk9jdGFsTGl0ZXJhbCA9IGZ1bmN0aW9uIChwcmVmaXgsIHN0YXJ0KSB7XHJcblx0ICAgICAgICB2YXIgbnVtID0gJyc7XHJcblx0ICAgICAgICB2YXIgb2N0YWwgPSBmYWxzZTtcclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KHByZWZpeC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICBudW0gPSAnMCcgKyB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghb2N0YWwgJiYgbnVtLmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgIC8vIG9ubHkgMG8gb3IgME9cclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpIHx8IGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogNiAvKiBOdW1lcmljTGl0ZXJhbCAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQobnVtLCA4KSxcclxuXHQgICAgICAgICAgICBvY3RhbDogb2N0YWwsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuaXNJbXBsaWNpdE9jdGFsTGl0ZXJhbCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIC8vIEltcGxpY2l0IG9jdGFsLCB1bmxlc3MgdGhlcmUgaXMgYSBub24tb2N0YWwgZGlnaXQuXHJcblx0ICAgICAgICAvLyAoQW5uZXggQi4xLjEgb24gTnVtZXJpYyBMaXRlcmFscylcclxuXHQgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmluZGV4ICsgMTsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVtpXTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09ICc4JyB8fCBjaCA9PT0gJzknKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuTnVtZXJpY0xpdGVyYWwgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2Vbc3RhcnRdO1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSB8fCAoY2ggPT09ICcuJyksICdOdW1lcmljIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgZGVjaW1hbCBkaWdpdCBvciBhIGRlY2ltYWwgcG9pbnQnKTtcclxuXHQgICAgICAgIHZhciBudW0gPSAnJztcclxuXHQgICAgICAgIGlmIChjaCAhPT0gJy4nKSB7XHJcblx0ICAgICAgICAgICAgbnVtID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgIC8vIEhleCBudW1iZXIgc3RhcnRzIHdpdGggJzB4Jy5cclxuXHQgICAgICAgICAgICAvLyBPY3RhbCBudW1iZXIgc3RhcnRzIHdpdGggJzAnLlxyXG5cdCAgICAgICAgICAgIC8vIE9jdGFsIG51bWJlciBpbiBFUzYgc3RhcnRzIHdpdGggJzBvJy5cclxuXHQgICAgICAgICAgICAvLyBCaW5hcnkgbnVtYmVyIGluIEVTNiBzdGFydHMgd2l0aCAnMGInLlxyXG5cdCAgICAgICAgICAgIGlmIChudW0gPT09ICcwJykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd4JyB8fCBjaCA9PT0gJ1gnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuSGV4TGl0ZXJhbChzdGFydCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnYicgfHwgY2ggPT09ICdCJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkJpbmFyeUxpdGVyYWwoc3RhcnQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ28nIHx8IGNoID09PSAnTycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5PY3RhbExpdGVyYWwoY2gsIHN0YXJ0KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggJiYgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbXBsaWNpdE9jdGFsTGl0ZXJhbCgpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk9jdGFsTGl0ZXJhbChjaCwgc3RhcnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHdoaWxlIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY2ggPT09ICcuJykge1xyXG5cdCAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIHdoaWxlIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XHJcblx0ICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09ICcrJyB8fCBjaCA9PT0gJy0nKSB7XHJcblx0ICAgICAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogNiAvKiBOdW1lcmljTGl0ZXJhbCAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW0pLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxpdGVyYWxzLXN0cmluZy1saXRlcmFsc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuU3RyaW5nTGl0ZXJhbCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgcXVvdGUgPSB0aGlzLnNvdXJjZVtzdGFydF07XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQoKHF1b3RlID09PSAnXFwnJyB8fCBxdW90ZSA9PT0gJ1wiJyksICdTdHJpbmcgbGl0ZXJhbCBtdXN0IHN0YXJ0cyB3aXRoIGEgcXVvdGUnKTtcclxuXHQgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgIHZhciBvY3RhbCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHN0ciA9ICcnO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09IHF1b3RlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHF1b3RlID0gJyc7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCFjaCB8fCAhY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSB0aGlzLnNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5lc2NhcGVkXzEgPSB0aGlzLnNjYW5IZXhFc2NhcGUoY2gpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZF8xID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHVuZXNjYXBlZF8xO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5lc2NhcGVkID0gdGhpcy5zY2FuSGV4RXNjYXBlKGNoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZCA9PT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRIZXhFc2NhcGVTZXF1ZW5jZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHVuZXNjYXBlZDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxuJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxyJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFx0JztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxiJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxmJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFx4MEInO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc4JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc5JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCAmJiBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2N0VG9EZWMgPSB0aGlzLm9jdGFsVG9EZWNpbWFsKGNoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gb2N0VG9EZWMub2N0YWwgfHwgb2N0YWw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShvY3RUb0RlYy5jb2RlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ1xcbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHF1b3RlICE9PSAnJykge1xyXG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXggPSBzdGFydDtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDggLyogU3RyaW5nTGl0ZXJhbCAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogc3RyLFxyXG5cdCAgICAgICAgICAgIG9jdGFsOiBvY3RhbCxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50c1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuVGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY29va2VkID0gJyc7XHJcblx0ICAgICAgICB2YXIgdGVybWluYXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgIHZhciBoZWFkID0gKHRoaXMuc291cmNlW3N0YXJ0XSA9PT0gJ2AnKTtcclxuXHQgICAgICAgIHZhciB0YWlsID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgcmF3T2Zmc2V0ID0gMjtcclxuXHQgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAnYCcpIHtcclxuXHQgICAgICAgICAgICAgICAgcmF3T2Zmc2V0ID0gMTtcclxuXHQgICAgICAgICAgICAgICAgdGFpbCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICckJykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJseVN0YWNrLnB1c2goJyR7Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGNvb2tlZCArPSBjaDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXG4nO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXHInO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXHQnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSB0aGlzLnNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdG9yZSA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5lc2NhcGVkXzIgPSB0aGlzLnNjYW5IZXhFc2NhcGUoY2gpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZF8yICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IHVuZXNjYXBlZF8yO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHJlc3RvcmU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5lc2NhcGVkID0gdGhpcy5zY2FuSGV4RXNjYXBlKGNoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZCA9PT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRIZXhFc2NhcGVTZXF1ZW5jZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IHVuZXNjYXBlZDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxiJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxmJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFx2JztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnMCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsOiBcXDAxIFxcMDIgYW5kIHNvIG9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLlRlbXBsYXRlT2N0YWxMaXRlcmFsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFwwJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsOiBcXDEgXFwyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVGVtcGxhdGVPY3RhbExpdGVyYWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAnXFxuJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ1xcbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxuJztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGNvb2tlZCArPSBjaDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIWhlYWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmN1cmx5U3RhY2sucG9wKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDEwIC8qIFRlbXBsYXRlICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNvdXJjZS5zbGljZShzdGFydCArIDEsIHRoaXMuaW5kZXggLSByYXdPZmZzZXQpLFxyXG5cdCAgICAgICAgICAgIGNvb2tlZDogY29va2VkLFxyXG5cdCAgICAgICAgICAgIGhlYWQ6IGhlYWQsXHJcblx0ICAgICAgICAgICAgdGFpbDogdGFpbCxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1saXRlcmFscy1yZWd1bGFyLWV4cHJlc3Npb24tbGl0ZXJhbHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUudGVzdFJlZ0V4cCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBmbGFncykge1xyXG5cdCAgICAgICAgLy8gVGhlIEJNUCBjaGFyYWN0ZXIgdG8gdXNlIGFzIGEgcmVwbGFjZW1lbnQgZm9yIGFzdHJhbCBzeW1ib2xzIHdoZW5cclxuXHQgICAgICAgIC8vIHRyYW5zbGF0aW5nIGFuIEVTNiBcInVcIi1mbGFnZ2VkIHBhdHRlcm4gdG8gYW4gRVM1LWNvbXBhdGlibGVcclxuXHQgICAgICAgIC8vIGFwcHJveGltYXRpb24uXHJcblx0ICAgICAgICAvLyBOb3RlOiByZXBsYWNpbmcgd2l0aCAnXFx1RkZGRicgZW5hYmxlcyBmYWxzZSBwb3NpdGl2ZXMgaW4gdW5saWtlbHlcclxuXHQgICAgICAgIC8vIHNjZW5hcmlvcy4gRm9yIGV4YW1wbGUsIGBbXFx1ezEwNDRmfS1cXHV7MTA0NDB9XWAgaXMgYW4gaW52YWxpZFxyXG5cdCAgICAgICAgLy8gcGF0dGVybiB0aGF0IHdvdWxkIG5vdCBiZSBkZXRlY3RlZCBieSB0aGlzIHN1YnN0aXR1dGlvbi5cclxuXHQgICAgICAgIHZhciBhc3RyYWxTdWJzdGl0dXRlID0gJ1xcdUZGRkYnO1xyXG5cdCAgICAgICAgdmFyIHRtcCA9IHBhdHRlcm47XHJcblx0ICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblx0ICAgICAgICBpZiAoZmxhZ3MuaW5kZXhPZigndScpID49IDApIHtcclxuXHQgICAgICAgICAgICB0bXAgPSB0bXBcclxuXHQgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFx1XFx7KFswLTlhLWZBLUZdKylcXH18XFxcXHUoW2EtZkEtRjAtOV17NH0pL2csIGZ1bmN0aW9uICgkMCwgJDEsICQyKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBwYXJzZUludCgkMSB8fCAkMiwgMTYpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY29kZVBvaW50ID4gMHgxMEZGRkYpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHNlbGYudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkUmVnRXhwKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4RkZGRikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYXN0cmFsU3Vic3RpdHV0ZTtcclxuXHQgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nLCBhc3RyYWxTdWJzdGl0dXRlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIEZpcnN0LCBkZXRlY3QgaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb25zLlxyXG5cdCAgICAgICAgdHJ5IHtcclxuXHQgICAgICAgICAgICBSZWdFeHAodG1wKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGNhdGNoIChlKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRSZWdFeHApO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gUmV0dXJuIGEgcmVndWxhciBleHByZXNzaW9uIG9iamVjdCBmb3IgdGhpcyBwYXR0ZXJuLWZsYWcgcGFpciwgb3JcclxuXHQgICAgICAgIC8vIGBudWxsYCBpbiBjYXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZmxhZ3MgaXRcclxuXHQgICAgICAgIC8vIHVzZXMuXHJcblx0ICAgICAgICB0cnkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGNhdGNoIChleGNlcHRpb24pIHtcclxuXHQgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuUmVnRXhwQm9keSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KGNoID09PSAnLycsICdSZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBzbGFzaCcpO1xyXG5cdCAgICAgICAgdmFyIHN0ciA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICB2YXIgY2xhc3NNYXJrZXIgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciB0ZXJtaW5hdGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGl0ZXJhbHMtcmVndWxhci1leHByZXNzaW9uLWxpdGVyYWxzXHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2xhc3NNYXJrZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNsYXNzTWFya2VyID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJy8nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnWycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNsYXNzTWFya2VyID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghdGVybWluYXRlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gRXhjbHVkZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cclxuXHQgICAgICAgIHJldHVybiBzdHIuc3Vic3RyKDEsIHN0ci5sZW5ndGggLSAyKTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblJlZ0V4cEZsYWdzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0ciA9ICcnO1xyXG5cdCAgICAgICAgdmFyIGZsYWdzID0gJyc7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcgJiYgIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXN0b3JlID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGFyID0gdGhpcy5zY2FuSGV4RXNjYXBlKCd1Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2hhciAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICs9IGNoYXI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChzdHIgKz0gJ1xcXFx1JzsgcmVzdG9yZSA8IHRoaXMuaW5kZXg7ICsrcmVzdG9yZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdGhpcy5zb3VyY2VbcmVzdG9yZV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHJlc3RvcmU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gJ3UnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXHUnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcJztcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgZmxhZ3MgKz0gY2g7XHJcblx0ICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZmxhZ3M7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5SZWdFeHAgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIHBhdHRlcm4gPSB0aGlzLnNjYW5SZWdFeHBCb2R5KCk7XHJcblx0ICAgICAgICB2YXIgZmxhZ3MgPSB0aGlzLnNjYW5SZWdFeHBGbGFncygpO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlID0gdGhpcy50ZXN0UmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogOSAvKiBSZWd1bGFyRXhwcmVzc2lvbiAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogJycsXHJcblx0ICAgICAgICAgICAgcGF0dGVybjogcGF0dGVybixcclxuXHQgICAgICAgICAgICBmbGFnczogZmxhZ3MsXHJcblx0ICAgICAgICAgICAgcmVnZXg6IHZhbHVlLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmxleCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogMiAvKiBFT0YgKi8sXHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiAnJyxcclxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5pbmRleCxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBjcCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KGNwKSkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5JZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBWZXJ5IGNvbW1vbjogKCBhbmQgKSBhbmQgO1xyXG5cdCAgICAgICAgaWYgKGNwID09PSAweDI4IHx8IGNwID09PSAweDI5IHx8IGNwID09PSAweDNCKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblB1bmN0dWF0b3IoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFN0cmluZyBsaXRlcmFsIHN0YXJ0cyB3aXRoIHNpbmdsZSBxdW90ZSAoVSswMDI3KSBvciBkb3VibGUgcXVvdGUgKFUrMDAyMikuXHJcblx0ICAgICAgICBpZiAoY3AgPT09IDB4MjcgfHwgY3AgPT09IDB4MjIpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuU3RyaW5nTGl0ZXJhbCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gRG90ICguKSBVKzAwMkUgY2FuIGFsc28gc3RhcnQgYSBmbG9hdGluZy1wb2ludCBudW1iZXIsIGhlbmNlIHRoZSBuZWVkXHJcblx0ICAgICAgICAvLyB0byBjaGVjayB0aGUgbmV4dCBjaGFyYWN0ZXIuXHJcblx0ICAgICAgICBpZiAoY3AgPT09IDB4MkUpIHtcclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuTnVtZXJpY0xpdGVyYWwoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblB1bmN0dWF0b3IoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQoY3ApKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk51bWVyaWNMaXRlcmFsKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBUZW1wbGF0ZSBsaXRlcmFscyBzdGFydCB3aXRoIGAgKFUrMDA2MCkgZm9yIHRlbXBsYXRlIGhlYWRcclxuXHQgICAgICAgIC8vIG9yIH0gKFUrMDA3RCkgZm9yIHRlbXBsYXRlIG1pZGRsZSBvciB0ZW1wbGF0ZSB0YWlsLlxyXG5cdCAgICAgICAgaWYgKGNwID09PSAweDYwIHx8IChjcCA9PT0gMHg3RCAmJiB0aGlzLmN1cmx5U3RhY2tbdGhpcy5jdXJseVN0YWNrLmxlbmd0aCAtIDFdID09PSAnJHsnKSkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5UZW1wbGF0ZSgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gUG9zc2libGUgaWRlbnRpZmllciBzdGFydCBpbiBhIHN1cnJvZ2F0ZSBwYWlyLlxyXG5cdCAgICAgICAgaWYgKGNwID49IDB4RDgwMCAmJiBjcCA8IDB4REZGRikge1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQodGhpcy5jb2RlUG9pbnRBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbklkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5zY2FuUHVuY3R1YXRvcigpO1xyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gU2Nhbm5lcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU2Nhbm5lciA9IFNjYW5uZXI7XHJcblxuXG4vKioqLyB9LFxuLyogMTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHRleHBvcnRzLlRva2VuTmFtZSA9IHt9O1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzEgLyogQm9vbGVhbkxpdGVyYWwgKi9dID0gJ0Jvb2xlYW4nO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzIgLyogRU9GICovXSA9ICc8ZW5kPic7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbMyAvKiBJZGVudGlmaWVyICovXSA9ICdJZGVudGlmaWVyJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVs0IC8qIEtleXdvcmQgKi9dID0gJ0tleXdvcmQnO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzUgLyogTnVsbExpdGVyYWwgKi9dID0gJ051bGwnO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzYgLyogTnVtZXJpY0xpdGVyYWwgKi9dID0gJ051bWVyaWMnO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzcgLyogUHVuY3R1YXRvciAqL10gPSAnUHVuY3R1YXRvcic7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbOCAvKiBTdHJpbmdMaXRlcmFsICovXSA9ICdTdHJpbmcnO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzkgLyogUmVndWxhckV4cHJlc3Npb24gKi9dID0gJ1JlZ3VsYXJFeHByZXNzaW9uJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVsxMCAvKiBUZW1wbGF0ZSAqL10gPSAnVGVtcGxhdGUnO1xyXG5cblxuLyoqKi8gfSxcbi8qIDE0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHQvLyBHZW5lcmF0ZWQgYnkgZ2VuZXJhdGUteGh0bWwtZW50aXRpZXMuanMuIERPIE5PVCBNT0RJRlkhXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdGV4cG9ydHMuWEhUTUxFbnRpdGllcyA9IHtcclxuXHQgICAgcXVvdDogJ1xcdTAwMjInLFxyXG5cdCAgICBhbXA6ICdcXHUwMDI2JyxcclxuXHQgICAgYXBvczogJ1xcdTAwMjcnLFxyXG5cdCAgICBndDogJ1xcdTAwM0UnLFxyXG5cdCAgICBuYnNwOiAnXFx1MDBBMCcsXHJcblx0ICAgIGlleGNsOiAnXFx1MDBBMScsXHJcblx0ICAgIGNlbnQ6ICdcXHUwMEEyJyxcclxuXHQgICAgcG91bmQ6ICdcXHUwMEEzJyxcclxuXHQgICAgY3VycmVuOiAnXFx1MDBBNCcsXHJcblx0ICAgIHllbjogJ1xcdTAwQTUnLFxyXG5cdCAgICBicnZiYXI6ICdcXHUwMEE2JyxcclxuXHQgICAgc2VjdDogJ1xcdTAwQTcnLFxyXG5cdCAgICB1bWw6ICdcXHUwMEE4JyxcclxuXHQgICAgY29weTogJ1xcdTAwQTknLFxyXG5cdCAgICBvcmRmOiAnXFx1MDBBQScsXHJcblx0ICAgIGxhcXVvOiAnXFx1MDBBQicsXHJcblx0ICAgIG5vdDogJ1xcdTAwQUMnLFxyXG5cdCAgICBzaHk6ICdcXHUwMEFEJyxcclxuXHQgICAgcmVnOiAnXFx1MDBBRScsXHJcblx0ICAgIG1hY3I6ICdcXHUwMEFGJyxcclxuXHQgICAgZGVnOiAnXFx1MDBCMCcsXHJcblx0ICAgIHBsdXNtbjogJ1xcdTAwQjEnLFxyXG5cdCAgICBzdXAyOiAnXFx1MDBCMicsXHJcblx0ICAgIHN1cDM6ICdcXHUwMEIzJyxcclxuXHQgICAgYWN1dGU6ICdcXHUwMEI0JyxcclxuXHQgICAgbWljcm86ICdcXHUwMEI1JyxcclxuXHQgICAgcGFyYTogJ1xcdTAwQjYnLFxyXG5cdCAgICBtaWRkb3Q6ICdcXHUwMEI3JyxcclxuXHQgICAgY2VkaWw6ICdcXHUwMEI4JyxcclxuXHQgICAgc3VwMTogJ1xcdTAwQjknLFxyXG5cdCAgICBvcmRtOiAnXFx1MDBCQScsXHJcblx0ICAgIHJhcXVvOiAnXFx1MDBCQicsXHJcblx0ICAgIGZyYWMxNDogJ1xcdTAwQkMnLFxyXG5cdCAgICBmcmFjMTI6ICdcXHUwMEJEJyxcclxuXHQgICAgZnJhYzM0OiAnXFx1MDBCRScsXHJcblx0ICAgIGlxdWVzdDogJ1xcdTAwQkYnLFxyXG5cdCAgICBBZ3JhdmU6ICdcXHUwMEMwJyxcclxuXHQgICAgQWFjdXRlOiAnXFx1MDBDMScsXHJcblx0ICAgIEFjaXJjOiAnXFx1MDBDMicsXHJcblx0ICAgIEF0aWxkZTogJ1xcdTAwQzMnLFxyXG5cdCAgICBBdW1sOiAnXFx1MDBDNCcsXHJcblx0ICAgIEFyaW5nOiAnXFx1MDBDNScsXHJcblx0ICAgIEFFbGlnOiAnXFx1MDBDNicsXHJcblx0ICAgIENjZWRpbDogJ1xcdTAwQzcnLFxyXG5cdCAgICBFZ3JhdmU6ICdcXHUwMEM4JyxcclxuXHQgICAgRWFjdXRlOiAnXFx1MDBDOScsXHJcblx0ICAgIEVjaXJjOiAnXFx1MDBDQScsXHJcblx0ICAgIEV1bWw6ICdcXHUwMENCJyxcclxuXHQgICAgSWdyYXZlOiAnXFx1MDBDQycsXHJcblx0ICAgIElhY3V0ZTogJ1xcdTAwQ0QnLFxyXG5cdCAgICBJY2lyYzogJ1xcdTAwQ0UnLFxyXG5cdCAgICBJdW1sOiAnXFx1MDBDRicsXHJcblx0ICAgIEVUSDogJ1xcdTAwRDAnLFxyXG5cdCAgICBOdGlsZGU6ICdcXHUwMEQxJyxcclxuXHQgICAgT2dyYXZlOiAnXFx1MDBEMicsXHJcblx0ICAgIE9hY3V0ZTogJ1xcdTAwRDMnLFxyXG5cdCAgICBPY2lyYzogJ1xcdTAwRDQnLFxyXG5cdCAgICBPdGlsZGU6ICdcXHUwMEQ1JyxcclxuXHQgICAgT3VtbDogJ1xcdTAwRDYnLFxyXG5cdCAgICB0aW1lczogJ1xcdTAwRDcnLFxyXG5cdCAgICBPc2xhc2g6ICdcXHUwMEQ4JyxcclxuXHQgICAgVWdyYXZlOiAnXFx1MDBEOScsXHJcblx0ICAgIFVhY3V0ZTogJ1xcdTAwREEnLFxyXG5cdCAgICBVY2lyYzogJ1xcdTAwREInLFxyXG5cdCAgICBVdW1sOiAnXFx1MDBEQycsXHJcblx0ICAgIFlhY3V0ZTogJ1xcdTAwREQnLFxyXG5cdCAgICBUSE9STjogJ1xcdTAwREUnLFxyXG5cdCAgICBzemxpZzogJ1xcdTAwREYnLFxyXG5cdCAgICBhZ3JhdmU6ICdcXHUwMEUwJyxcclxuXHQgICAgYWFjdXRlOiAnXFx1MDBFMScsXHJcblx0ICAgIGFjaXJjOiAnXFx1MDBFMicsXHJcblx0ICAgIGF0aWxkZTogJ1xcdTAwRTMnLFxyXG5cdCAgICBhdW1sOiAnXFx1MDBFNCcsXHJcblx0ICAgIGFyaW5nOiAnXFx1MDBFNScsXHJcblx0ICAgIGFlbGlnOiAnXFx1MDBFNicsXHJcblx0ICAgIGNjZWRpbDogJ1xcdTAwRTcnLFxyXG5cdCAgICBlZ3JhdmU6ICdcXHUwMEU4JyxcclxuXHQgICAgZWFjdXRlOiAnXFx1MDBFOScsXHJcblx0ICAgIGVjaXJjOiAnXFx1MDBFQScsXHJcblx0ICAgIGV1bWw6ICdcXHUwMEVCJyxcclxuXHQgICAgaWdyYXZlOiAnXFx1MDBFQycsXHJcblx0ICAgIGlhY3V0ZTogJ1xcdTAwRUQnLFxyXG5cdCAgICBpY2lyYzogJ1xcdTAwRUUnLFxyXG5cdCAgICBpdW1sOiAnXFx1MDBFRicsXHJcblx0ICAgIGV0aDogJ1xcdTAwRjAnLFxyXG5cdCAgICBudGlsZGU6ICdcXHUwMEYxJyxcclxuXHQgICAgb2dyYXZlOiAnXFx1MDBGMicsXHJcblx0ICAgIG9hY3V0ZTogJ1xcdTAwRjMnLFxyXG5cdCAgICBvY2lyYzogJ1xcdTAwRjQnLFxyXG5cdCAgICBvdGlsZGU6ICdcXHUwMEY1JyxcclxuXHQgICAgb3VtbDogJ1xcdTAwRjYnLFxyXG5cdCAgICBkaXZpZGU6ICdcXHUwMEY3JyxcclxuXHQgICAgb3NsYXNoOiAnXFx1MDBGOCcsXHJcblx0ICAgIHVncmF2ZTogJ1xcdTAwRjknLFxyXG5cdCAgICB1YWN1dGU6ICdcXHUwMEZBJyxcclxuXHQgICAgdWNpcmM6ICdcXHUwMEZCJyxcclxuXHQgICAgdXVtbDogJ1xcdTAwRkMnLFxyXG5cdCAgICB5YWN1dGU6ICdcXHUwMEZEJyxcclxuXHQgICAgdGhvcm46ICdcXHUwMEZFJyxcclxuXHQgICAgeXVtbDogJ1xcdTAwRkYnLFxyXG5cdCAgICBPRWxpZzogJ1xcdTAxNTInLFxyXG5cdCAgICBvZWxpZzogJ1xcdTAxNTMnLFxyXG5cdCAgICBTY2Fyb246ICdcXHUwMTYwJyxcclxuXHQgICAgc2Nhcm9uOiAnXFx1MDE2MScsXHJcblx0ICAgIFl1bWw6ICdcXHUwMTc4JyxcclxuXHQgICAgZm5vZjogJ1xcdTAxOTInLFxyXG5cdCAgICBjaXJjOiAnXFx1MDJDNicsXHJcblx0ICAgIHRpbGRlOiAnXFx1MDJEQycsXHJcblx0ICAgIEFscGhhOiAnXFx1MDM5MScsXHJcblx0ICAgIEJldGE6ICdcXHUwMzkyJyxcclxuXHQgICAgR2FtbWE6ICdcXHUwMzkzJyxcclxuXHQgICAgRGVsdGE6ICdcXHUwMzk0JyxcclxuXHQgICAgRXBzaWxvbjogJ1xcdTAzOTUnLFxyXG5cdCAgICBaZXRhOiAnXFx1MDM5NicsXHJcblx0ICAgIEV0YTogJ1xcdTAzOTcnLFxyXG5cdCAgICBUaGV0YTogJ1xcdTAzOTgnLFxyXG5cdCAgICBJb3RhOiAnXFx1MDM5OScsXHJcblx0ICAgIEthcHBhOiAnXFx1MDM5QScsXHJcblx0ICAgIExhbWJkYTogJ1xcdTAzOUInLFxyXG5cdCAgICBNdTogJ1xcdTAzOUMnLFxyXG5cdCAgICBOdTogJ1xcdTAzOUQnLFxyXG5cdCAgICBYaTogJ1xcdTAzOUUnLFxyXG5cdCAgICBPbWljcm9uOiAnXFx1MDM5RicsXHJcblx0ICAgIFBpOiAnXFx1MDNBMCcsXHJcblx0ICAgIFJobzogJ1xcdTAzQTEnLFxyXG5cdCAgICBTaWdtYTogJ1xcdTAzQTMnLFxyXG5cdCAgICBUYXU6ICdcXHUwM0E0JyxcclxuXHQgICAgVXBzaWxvbjogJ1xcdTAzQTUnLFxyXG5cdCAgICBQaGk6ICdcXHUwM0E2JyxcclxuXHQgICAgQ2hpOiAnXFx1MDNBNycsXHJcblx0ICAgIFBzaTogJ1xcdTAzQTgnLFxyXG5cdCAgICBPbWVnYTogJ1xcdTAzQTknLFxyXG5cdCAgICBhbHBoYTogJ1xcdTAzQjEnLFxyXG5cdCAgICBiZXRhOiAnXFx1MDNCMicsXHJcblx0ICAgIGdhbW1hOiAnXFx1MDNCMycsXHJcblx0ICAgIGRlbHRhOiAnXFx1MDNCNCcsXHJcblx0ICAgIGVwc2lsb246ICdcXHUwM0I1JyxcclxuXHQgICAgemV0YTogJ1xcdTAzQjYnLFxyXG5cdCAgICBldGE6ICdcXHUwM0I3JyxcclxuXHQgICAgdGhldGE6ICdcXHUwM0I4JyxcclxuXHQgICAgaW90YTogJ1xcdTAzQjknLFxyXG5cdCAgICBrYXBwYTogJ1xcdTAzQkEnLFxyXG5cdCAgICBsYW1iZGE6ICdcXHUwM0JCJyxcclxuXHQgICAgbXU6ICdcXHUwM0JDJyxcclxuXHQgICAgbnU6ICdcXHUwM0JEJyxcclxuXHQgICAgeGk6ICdcXHUwM0JFJyxcclxuXHQgICAgb21pY3JvbjogJ1xcdTAzQkYnLFxyXG5cdCAgICBwaTogJ1xcdTAzQzAnLFxyXG5cdCAgICByaG86ICdcXHUwM0MxJyxcclxuXHQgICAgc2lnbWFmOiAnXFx1MDNDMicsXHJcblx0ICAgIHNpZ21hOiAnXFx1MDNDMycsXHJcblx0ICAgIHRhdTogJ1xcdTAzQzQnLFxyXG5cdCAgICB1cHNpbG9uOiAnXFx1MDNDNScsXHJcblx0ICAgIHBoaTogJ1xcdTAzQzYnLFxyXG5cdCAgICBjaGk6ICdcXHUwM0M3JyxcclxuXHQgICAgcHNpOiAnXFx1MDNDOCcsXHJcblx0ICAgIG9tZWdhOiAnXFx1MDNDOScsXHJcblx0ICAgIHRoZXRhc3ltOiAnXFx1MDNEMScsXHJcblx0ICAgIHVwc2loOiAnXFx1MDNEMicsXHJcblx0ICAgIHBpdjogJ1xcdTAzRDYnLFxyXG5cdCAgICBlbnNwOiAnXFx1MjAwMicsXHJcblx0ICAgIGVtc3A6ICdcXHUyMDAzJyxcclxuXHQgICAgdGhpbnNwOiAnXFx1MjAwOScsXHJcblx0ICAgIHp3bmo6ICdcXHUyMDBDJyxcclxuXHQgICAgendqOiAnXFx1MjAwRCcsXHJcblx0ICAgIGxybTogJ1xcdTIwMEUnLFxyXG5cdCAgICBybG06ICdcXHUyMDBGJyxcclxuXHQgICAgbmRhc2g6ICdcXHUyMDEzJyxcclxuXHQgICAgbWRhc2g6ICdcXHUyMDE0JyxcclxuXHQgICAgbHNxdW86ICdcXHUyMDE4JyxcclxuXHQgICAgcnNxdW86ICdcXHUyMDE5JyxcclxuXHQgICAgc2JxdW86ICdcXHUyMDFBJyxcclxuXHQgICAgbGRxdW86ICdcXHUyMDFDJyxcclxuXHQgICAgcmRxdW86ICdcXHUyMDFEJyxcclxuXHQgICAgYmRxdW86ICdcXHUyMDFFJyxcclxuXHQgICAgZGFnZ2VyOiAnXFx1MjAyMCcsXHJcblx0ICAgIERhZ2dlcjogJ1xcdTIwMjEnLFxyXG5cdCAgICBidWxsOiAnXFx1MjAyMicsXHJcblx0ICAgIGhlbGxpcDogJ1xcdTIwMjYnLFxyXG5cdCAgICBwZXJtaWw6ICdcXHUyMDMwJyxcclxuXHQgICAgcHJpbWU6ICdcXHUyMDMyJyxcclxuXHQgICAgUHJpbWU6ICdcXHUyMDMzJyxcclxuXHQgICAgbHNhcXVvOiAnXFx1MjAzOScsXHJcblx0ICAgIHJzYXF1bzogJ1xcdTIwM0EnLFxyXG5cdCAgICBvbGluZTogJ1xcdTIwM0UnLFxyXG5cdCAgICBmcmFzbDogJ1xcdTIwNDQnLFxyXG5cdCAgICBldXJvOiAnXFx1MjBBQycsXHJcblx0ICAgIGltYWdlOiAnXFx1MjExMScsXHJcblx0ICAgIHdlaWVycDogJ1xcdTIxMTgnLFxyXG5cdCAgICByZWFsOiAnXFx1MjExQycsXHJcblx0ICAgIHRyYWRlOiAnXFx1MjEyMicsXHJcblx0ICAgIGFsZWZzeW06ICdcXHUyMTM1JyxcclxuXHQgICAgbGFycjogJ1xcdTIxOTAnLFxyXG5cdCAgICB1YXJyOiAnXFx1MjE5MScsXHJcblx0ICAgIHJhcnI6ICdcXHUyMTkyJyxcclxuXHQgICAgZGFycjogJ1xcdTIxOTMnLFxyXG5cdCAgICBoYXJyOiAnXFx1MjE5NCcsXHJcblx0ICAgIGNyYXJyOiAnXFx1MjFCNScsXHJcblx0ICAgIGxBcnI6ICdcXHUyMUQwJyxcclxuXHQgICAgdUFycjogJ1xcdTIxRDEnLFxyXG5cdCAgICByQXJyOiAnXFx1MjFEMicsXHJcblx0ICAgIGRBcnI6ICdcXHUyMUQzJyxcclxuXHQgICAgaEFycjogJ1xcdTIxRDQnLFxyXG5cdCAgICBmb3JhbGw6ICdcXHUyMjAwJyxcclxuXHQgICAgcGFydDogJ1xcdTIyMDInLFxyXG5cdCAgICBleGlzdDogJ1xcdTIyMDMnLFxyXG5cdCAgICBlbXB0eTogJ1xcdTIyMDUnLFxyXG5cdCAgICBuYWJsYTogJ1xcdTIyMDcnLFxyXG5cdCAgICBpc2luOiAnXFx1MjIwOCcsXHJcblx0ICAgIG5vdGluOiAnXFx1MjIwOScsXHJcblx0ICAgIG5pOiAnXFx1MjIwQicsXHJcblx0ICAgIHByb2Q6ICdcXHUyMjBGJyxcclxuXHQgICAgc3VtOiAnXFx1MjIxMScsXHJcblx0ICAgIG1pbnVzOiAnXFx1MjIxMicsXHJcblx0ICAgIGxvd2FzdDogJ1xcdTIyMTcnLFxyXG5cdCAgICByYWRpYzogJ1xcdTIyMUEnLFxyXG5cdCAgICBwcm9wOiAnXFx1MjIxRCcsXHJcblx0ICAgIGluZmluOiAnXFx1MjIxRScsXHJcblx0ICAgIGFuZzogJ1xcdTIyMjAnLFxyXG5cdCAgICBhbmQ6ICdcXHUyMjI3JyxcclxuXHQgICAgb3I6ICdcXHUyMjI4JyxcclxuXHQgICAgY2FwOiAnXFx1MjIyOScsXHJcblx0ICAgIGN1cDogJ1xcdTIyMkEnLFxyXG5cdCAgICBpbnQ6ICdcXHUyMjJCJyxcclxuXHQgICAgdGhlcmU0OiAnXFx1MjIzNCcsXHJcblx0ICAgIHNpbTogJ1xcdTIyM0MnLFxyXG5cdCAgICBjb25nOiAnXFx1MjI0NScsXHJcblx0ICAgIGFzeW1wOiAnXFx1MjI0OCcsXHJcblx0ICAgIG5lOiAnXFx1MjI2MCcsXHJcblx0ICAgIGVxdWl2OiAnXFx1MjI2MScsXHJcblx0ICAgIGxlOiAnXFx1MjI2NCcsXHJcblx0ICAgIGdlOiAnXFx1MjI2NScsXHJcblx0ICAgIHN1YjogJ1xcdTIyODInLFxyXG5cdCAgICBzdXA6ICdcXHUyMjgzJyxcclxuXHQgICAgbnN1YjogJ1xcdTIyODQnLFxyXG5cdCAgICBzdWJlOiAnXFx1MjI4NicsXHJcblx0ICAgIHN1cGU6ICdcXHUyMjg3JyxcclxuXHQgICAgb3BsdXM6ICdcXHUyMjk1JyxcclxuXHQgICAgb3RpbWVzOiAnXFx1MjI5NycsXHJcblx0ICAgIHBlcnA6ICdcXHUyMkE1JyxcclxuXHQgICAgc2RvdDogJ1xcdTIyQzUnLFxyXG5cdCAgICBsY2VpbDogJ1xcdTIzMDgnLFxyXG5cdCAgICByY2VpbDogJ1xcdTIzMDknLFxyXG5cdCAgICBsZmxvb3I6ICdcXHUyMzBBJyxcclxuXHQgICAgcmZsb29yOiAnXFx1MjMwQicsXHJcblx0ICAgIGxvejogJ1xcdTI1Q0EnLFxyXG5cdCAgICBzcGFkZXM6ICdcXHUyNjYwJyxcclxuXHQgICAgY2x1YnM6ICdcXHUyNjYzJyxcclxuXHQgICAgaGVhcnRzOiAnXFx1MjY2NScsXHJcblx0ICAgIGRpYW1zOiAnXFx1MjY2NicsXHJcblx0ICAgIGxhbmc6ICdcXHUyN0U4JyxcclxuXHQgICAgcmFuZzogJ1xcdTI3RTknXHJcblx0fTtcclxuXG5cbi8qKiovIH0sXG4vKiAxNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBlcnJvcl9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxuXHR2YXIgc2Nhbm5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcblx0dmFyIHRva2VuXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxuXHR2YXIgUmVhZGVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gUmVhZGVyKCkge1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZXMgPSBbXTtcclxuXHQgICAgICAgIHRoaXMuY3VybHkgPSB0aGlzLnBhcmVuID0gLTE7XHJcblx0ICAgIH1cclxuXHQgICAgLy8gQSBmdW5jdGlvbiBmb2xsb3dpbmcgb25lIG9mIHRob3NlIHRva2VucyBpcyBhbiBleHByZXNzaW9uLlxyXG5cdCAgICBSZWFkZXIucHJvdG90eXBlLmJlZm9yZUZ1bmN0aW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh0KSB7XHJcblx0ICAgICAgICByZXR1cm4gWycoJywgJ3snLCAnWycsICdpbicsICd0eXBlb2YnLCAnaW5zdGFuY2VvZicsICduZXcnLFxyXG5cdCAgICAgICAgICAgICdyZXR1cm4nLCAnY2FzZScsICdkZWxldGUnLCAndGhyb3cnLCAndm9pZCcsXHJcblx0ICAgICAgICAgICAgLy8gYXNzaWdubWVudCBvcGVyYXRvcnNcclxuXHQgICAgICAgICAgICAnPScsICcrPScsICctPScsICcqPScsICcqKj0nLCAnLz0nLCAnJT0nLCAnPDw9JywgJz4+PScsICc+Pj49JyxcclxuXHQgICAgICAgICAgICAnJj0nLCAnfD0nLCAnXj0nLCAnLCcsXHJcblx0ICAgICAgICAgICAgLy8gYmluYXJ5L3VuYXJ5IG9wZXJhdG9yc1xyXG5cdCAgICAgICAgICAgICcrJywgJy0nLCAnKicsICcqKicsICcvJywgJyUnLCAnKysnLCAnLS0nLCAnPDwnLCAnPj4nLCAnPj4+JywgJyYnLFxyXG5cdCAgICAgICAgICAgICd8JywgJ14nLCAnIScsICd+JywgJyYmJywgJ3x8JywgJz8nLCAnOicsICc9PT0nLCAnPT0nLCAnPj0nLFxyXG5cdCAgICAgICAgICAgICc8PScsICc8JywgJz4nLCAnIT0nLCAnIT09J10uaW5kZXhPZih0KSA+PSAwO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBEZXRlcm1pbmUgaWYgZm9yd2FyZCBzbGFzaCAoLykgaXMgYW4gb3BlcmF0b3Igb3IgcGFydCBvZiBhIHJlZ3VsYXIgZXhwcmVzc2lvblxyXG5cdCAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zd2VldC5qcy93aWtpL2Rlc2lnblxyXG5cdCAgICBSZWFkZXIucHJvdG90eXBlLmlzUmVnZXhTdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMudmFsdWVzW3RoaXMudmFsdWVzLmxlbmd0aCAtIDFdO1xyXG5cdCAgICAgICAgdmFyIHJlZ2V4ID0gKHByZXZpb3VzICE9PSBudWxsKTtcclxuXHQgICAgICAgIHN3aXRjaCAocHJldmlvdXMpIHtcclxuXHQgICAgICAgICAgICBjYXNlICd0aGlzJzpcclxuXHQgICAgICAgICAgICBjYXNlICddJzpcclxuXHQgICAgICAgICAgICAgICAgcmVnZXggPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAnKSc6XHJcblx0ICAgICAgICAgICAgICAgIHZhciBrZXl3b3JkID0gdGhpcy52YWx1ZXNbdGhpcy5wYXJlbiAtIDFdO1xyXG5cdCAgICAgICAgICAgICAgICByZWdleCA9IChrZXl3b3JkID09PSAnaWYnIHx8IGtleXdvcmQgPT09ICd3aGlsZScgfHwga2V5d29yZCA9PT0gJ2ZvcicgfHwga2V5d29yZCA9PT0gJ3dpdGgnKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAnfSc6XHJcblx0ICAgICAgICAgICAgICAgIC8vIERpdmlkaW5nIGEgZnVuY3Rpb24gYnkgYW55dGhpbmcgbWFrZXMgbGl0dGxlIHNlbnNlLFxyXG5cdCAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSB0byBjaGVjayBmb3IgdGhhdC5cclxuXHQgICAgICAgICAgICAgICAgcmVnZXggPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVzW3RoaXMuY3VybHkgLSAzXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQW5vbnltb3VzIGZ1bmN0aW9uLCBlLmcuIGZ1bmN0aW9uKCl7fSAvNDJcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGVjayA9IHRoaXMudmFsdWVzW3RoaXMuY3VybHkgLSA0XTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJlZ2V4ID0gY2hlY2sgPyAhdGhpcy5iZWZvcmVGdW5jdGlvbkV4cHJlc3Npb24oY2hlY2spIDogZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy52YWx1ZXNbdGhpcy5jdXJseSAtIDRdID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBOYW1lZCBmdW5jdGlvbiwgZS5nLiBmdW5jdGlvbiBmKCl7fSAvNDIvXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2sgPSB0aGlzLnZhbHVlc1t0aGlzLmN1cmx5IC0gNV07XHJcblx0ICAgICAgICAgICAgICAgICAgICByZWdleCA9IGNoZWNrID8gIXRoaXMuYmVmb3JlRnVuY3Rpb25FeHByZXNzaW9uKGNoZWNrKSA6IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gcmVnZXg7XHJcblx0ICAgIH07XHJcblx0ICAgIFJlYWRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyB8fCB0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pIHtcclxuXHQgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmN1cmx5ID0gdGhpcy52YWx1ZXMubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0b2tlbi52YWx1ZSA9PT0gJygnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMucGFyZW4gPSB0aGlzLnZhbHVlcy5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMudmFsdWVzLnB1c2godG9rZW4udmFsdWUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy52YWx1ZXMucHVzaChudWxsKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIFJlYWRlcjtcclxuXHR9KCkpO1xyXG5cdHZhciBUb2tlbml6ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUb2tlbml6ZXIoY29kZSwgY29uZmlnKSB7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlciA9IG5ldyBlcnJvcl9oYW5kbGVyXzEuRXJyb3JIYW5kbGVyKCk7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlci50b2xlcmFudCA9IGNvbmZpZyA/ICh0eXBlb2YgY29uZmlnLnRvbGVyYW50ID09PSAnYm9vbGVhbicgJiYgY29uZmlnLnRvbGVyYW50KSA6IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyID0gbmV3IHNjYW5uZXJfMS5TY2FubmVyKGNvZGUsIHRoaXMuZXJyb3JIYW5kbGVyKTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci50cmFja0NvbW1lbnQgPSBjb25maWcgPyAodHlwZW9mIGNvbmZpZy5jb21tZW50ID09PSAnYm9vbGVhbicgJiYgY29uZmlnLmNvbW1lbnQpIDogZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLnRyYWNrUmFuZ2UgPSBjb25maWcgPyAodHlwZW9mIGNvbmZpZy5yYW5nZSA9PT0gJ2Jvb2xlYW4nICYmIGNvbmZpZy5yYW5nZSkgOiBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMudHJhY2tMb2MgPSBjb25maWcgPyAodHlwZW9mIGNvbmZpZy5sb2MgPT09ICdib29sZWFuJyAmJiBjb25maWcubG9jKSA6IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcclxuXHQgICAgICAgIHRoaXMucmVhZGVyID0gbmV3IFJlYWRlcigpO1xyXG5cdCAgICB9XHJcblx0ICAgIFRva2VuaXplci5wcm90b3R5cGUuZXJyb3JzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JIYW5kbGVyLmVycm9ycztcclxuXHQgICAgfTtcclxuXHQgICAgVG9rZW5pemVyLnByb3RvdHlwZS5nZXROZXh0VG9rZW4gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNvbW1lbnRzID0gdGhpcy5zY2FubmVyLnNjYW5Db21tZW50cygpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWVudHMubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlID0gY29tbWVudHNbaV07XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnNjYW5uZXIuc291cmNlLnNsaWNlKGUuc2xpY2VbMF0sIGUuc2xpY2VbMV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZS5tdWx0aUxpbmUgPyAnQmxvY2tDb21tZW50JyA6ICdMaW5lQ29tbWVudCcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tSYW5nZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQucmFuZ2UgPSBlLnJhbmdlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tMb2MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50LmxvYyA9IGUubG9jO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChjb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuc2Nhbm5lci5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbG9jID0gdm9pZCAwO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0xvYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbG9jID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVuZDoge31cclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdmFyIHN0YXJ0UmVnZXggPSAodGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXhdID09PSAnLycpICYmIHRoaXMucmVhZGVyLmlzUmVnZXhTdGFydCgpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBzdGFydFJlZ2V4ID8gdGhpcy5zY2FubmVyLnNjYW5SZWdFeHAoKSA6IHRoaXMuc2Nhbm5lci5sZXgoKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5yZWFkZXIucHVzaCh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHR5cGU6IHRva2VuXzEuVG9rZW5OYW1lW3Rva2VuLnR5cGVdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc2Nhbm5lci5zb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQsIHRva2VuLmVuZClcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tSYW5nZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZW50cnkucmFuZ2UgPSBbdG9rZW4uc3RhcnQsIHRva2VuLmVuZF07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tMb2MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZW50cnkubG9jID0gbG9jO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA5IC8qIFJlZ3VsYXJFeHByZXNzaW9uICovKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IHRva2VuLnBhdHRlcm47XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZmxhZ3MgPSB0b2tlbi5mbGFncztcclxuXHQgICAgICAgICAgICAgICAgICAgIGVudHJ5LnJlZ2V4ID0geyBwYXR0ZXJuOiBwYXR0ZXJuLCBmbGFnczogZmxhZ3MgfTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc2hpZnQoKTtcclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIFRva2VuaXplcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVG9rZW5pemVyID0gVG9rZW5pemVyO1xyXG5cblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuOyIsIid1c2Ugc3RyaWN0J1xudmFyIHJlYWRvbmx5UHJveGllcyA9IG5ldyBXZWFrTWFwXG52YXIgY3VycmVudFNhbmRib3ggPSB1bmRlZmluZWRcbnZhciBHTE9CQUwgPSBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKVxudmFyIHVuc2NvcGFibGVzU3ltYm9sID0gU3ltYm9sLnVuc2NvcGFibGVzXG52YXIgRnVuY3Rpb25Db25zdHJ1Y3RvciA9IDAuLmNvbnN0cnVjdG9yLmNvbnN0cnVjdG9yXG5cbmZ1bmN0aW9uIGNvbXBpbGVFeHByZXNzaW9uKHNyYykge1xuXHRpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhIHN0cmluZy4nKVxuXHR9XG5cdFxuXHRuZXcgRnVuY3Rpb25Db25zdHJ1Y3RvcignXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAnICsgc3JjKSAvLyBUZXN0cyBmb3Igc3ludGF4IGVycm9ycyB3aXRob3V0IHJ1bm5pbmcgdGhlIGNvZGVcblx0dmFyIGNvZGUgPSBuZXcgRnVuY3Rpb25Db25zdHJ1Y3Rvcignc2FuZGJveCcsICd3aXRoIChzYW5kYm94KSB7cmV0dXJuIChmdW5jdGlvbiAoKSB7XCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAnICsgc3JjICsgJ30pLmNhbGwodGhpcyl9Jylcblx0XG5cdHJldHVybiBmdW5jdGlvbiAoc2FuZGJveCkge1xuXHRcdGlmICghaXNPYmplY3Qoc2FuZGJveCkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCBvciBmdW5jdGlvbi4nKVxuXHRcdH1cblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCBydW4gc2FuZGJveGVkIGNvZGUgaW5zaWRlIGFuIGFscmVhZHktcnVubmluZyBzYW5kYm94LicpXG5cdFx0fVxuXHRcdHZhciBzYW5kYm94UHJveHkgPSBnZXRQcm94eShzYW5kYm94KVxuXHRcdHZhciByZXN1bHQsIGVycm9yXG5cdFx0XG5cdFx0Y3VycmVudFNhbmRib3ggPSBzYW5kYm94XG5cdFx0dHJ5IHtcblx0XHRcdHJlc3VsdCA9IGNvZGUuY2FsbChzYW5kYm94UHJveHksIHNhbmRib3hQcm94eSlcblx0XHRcdGN1cnJlbnRTYW5kYm94ID0gdW5kZWZpbmVkXG5cdFx0fSBjYXRjaCAoZXgpIHtcblx0XHRcdGN1cnJlbnRTYW5kYm94ID0gdW5kZWZpbmVkXG5cdFx0XHRpZiAoZXggaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0XHRlcnJvciA9IG5ldyBleC5jb25zdHJ1Y3RvcignJyArIGV4Lm1lc3NhZ2UpXG5cdFx0XHRcdGVycm9yLnN0YWNrID0gJycgKyBleC5zdGFja1xuXHRcdFx0XHR0aHJvdyBlcnJvclxuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFN0cmluZyhleCkpXG5cdFx0fVxuXHRcdGlmIChpc09iamVjdChyZXN1bHQpKSB7XG5cdFx0XHR0aHJvdyBUeXBlRXJyb3IoJ1NhbmRib3hlcyBhcmUgb25seSBhbGxvd2VkIHRvIHJldHVybiBwcmltaXRpdmUgdmFsdWVzLicpXG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHRcblx0fVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlRXhwcmVzc2lvblxuXG52YXIgdHJhcHMgPSB7XG5cdGdldDogZnVuY3Rpb24gKHRhcmdldCwga2V5LCByZWNlaXZlcikge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0aWYgKGtleSA9PT0gdW5zY29wYWJsZXNTeW1ib2wgJiYgdGFyZ2V0ID09PSBjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0XHRpZiAoIW5vdFByaXZhdGUoa2V5KSkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZ2V0UHJveHlPclByaW1pdGl2ZShSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpKVxuXHRcdH1cblx0XHRyZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKVxuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgY2Fubm90IHNldCBwcm9wZXJ0aWVzIG9uIGEgc2FuZGJveGVkIG9iamVjdC4nKVxuXHRcdH1cblx0XHRyZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcilcblx0fSxcblx0aGFzOiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdGlmICh0YXJnZXQgPT09IGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0XHRpZiAoIW5vdFByaXZhdGUoa2V5KSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHRcdH1cblx0XHRcdHJldHVybiBnZXRQcm94eU9yUHJpbWl0aXZlKFJlZmxlY3QuaGFzKHRhcmdldCwga2V5KSlcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwga2V5KVxuXHR9LFxuXHRnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0cmV0dXJuIGdldFByb3h5T3JQcmltaXRpdmUoUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpKVxuXHRcdH1cblx0XHRyZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpXG5cdH0sXG5cdHNldFByb3RvdHlwZU9mOiBmdW5jdGlvbiAodGFyZ2V0LCBwcm90bykge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbm5vdCBzZXQgdGhlIHByb3RvdHlwZSBvZiBhIHNhbmRib3hlZCBvYmplY3QuJylcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcblx0fSxcblx0aXNFeHRlbnNpYmxlOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHRyZXR1cm4gZ2V0UHJveHlPclByaW1pdGl2ZShSZWZsZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpKVxuXHRcdH1cblx0XHRyZXR1cm4gUmVmbGVjdC5pc0V4dGVuc2libGUodGFyZ2V0KVxuXHR9LFxuXHRwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbm5vdCBjaGFuZ2UgdGhlIGV4dGVuc2liaWxpdHkgb2YgYSBzYW5kYm94ZWQgb2JqZWN0LicpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zKHRhcmdldClcblx0fSxcblx0Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdGlmIChrZXkgPT09IFN5bWJvbC51bnNjb3BhYmxlcyAmJiB0YXJnZXQgPT09IGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWRcblx0XHRcdH1cblx0XHRcdGlmICghbm90UHJpdmF0ZShrZXkpKSB7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWRcblx0XHRcdH1cblx0XHRcdHJldHVybiBnZXRQcm94eU9yUHJpbWl0aXZlKFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSlcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KVxuXHR9LFxuXHRkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgY2Fubm90IGRlZmluZSBwcm9wZXJ0aWVzIG9uIGEgc2FuZGJveGVkIG9iamVjdC4nKVxuXHRcdH1cblx0XHRyZXR1cm4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcilcblx0fSxcblx0ZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbm5vdCBkZWxldGUgcHJvcGVydGllcyBvbiBhIHNhbmRib3hlZCBvYmplY3QuJylcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpXG5cdH0sXG5cdG93bktleXM6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdHJldHVybiBnZXRQcm94eU9yUHJpbWl0aXZlKFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpLmZpbHRlcihub3RQcml2YXRlKSlcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG5cdH0sXG5cdGFwcGx5OiBmdW5jdGlvbiAodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSB7XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHRpZiAodGFyZ2V0ID09PSBGdW5jdGlvbkNvbnN0cnVjdG9yIHx8IHRhcmdldCA9PT0gRnVuY3Rpb25Db25zdHJ1Y3RvclByb3h5KSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBjYW5ub3QgdXNlIHRoZSBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpbiBhIHNhbmRib3hlZCBjb250ZXh0LicpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZ2V0UHJveHlPclByaW1pdGl2ZShSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdClcblx0fSxcblx0Y29uc3RydWN0OiBmdW5jdGlvbiAodGFyZ2V0LCBhcmd1bWVudHNMaXN0LCBuZXdUYXJnZXQpIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdGlmICh0YXJnZXQgPT09IEZ1bmN0aW9uQ29uc3RydWN0b3IgfHwgdGFyZ2V0ID09PSBGdW5jdGlvbkNvbnN0cnVjdG9yUHJveHkpIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbm5vdCB1c2UgdGhlIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGluIGEgc2FuZGJveGVkIGNvbnRleHQuJylcblx0XHRcdH1cblx0XHRcdHJldHVybiBnZXRQcm94eU9yUHJpbWl0aXZlKFJlZmxlY3QuY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCwgbmV3VGFyZ2V0KSlcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3QuY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCwgbmV3VGFyZ2V0KVxuXHR9XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpXG59XG5cbmZ1bmN0aW9uIGdldFByb3h5T3JQcmltaXRpdmUodmFsdWUpIHtcblx0aWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuXHRcdHJldHVybiBzYWZlT2JqZWN0cy5pbmRleE9mKHZhbHVlKSA+PSAwID8gdmFsdWUgOiBnZXRQcm94eSh2YWx1ZSlcblx0fVxuXHRyZXR1cm4gdmFsdWVcbn1cblxuZnVuY3Rpb24gZ2V0UHJveHkob2JqZWN0LCBoaWRlT3JpZ2luYWwpIHtcblx0aWYgKG9iamVjdCA9PT0gR0xPQkFMKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGdsb2JhbCBvYmplY3QgaXMgZm9yYmlkZGVuIGZyb20gZW50ZXJpbmcgYSBzYW5kYm94ZWQgY29udGV4dC4nKVxuXHR9XG5cdGlmIChvYmplY3QgPT09IGV2YWxGdW5jdGlvbikge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBldmFsIGZ1bmN0aW9uIGlzIGZvcmJpZGRlbiBmcm9tIGVudGVyaW5nIGEgc2FuZGJveGVkIGNvbnRleHQuJylcblx0fVxuXHR2YXIgcHJveHkgPSByZWFkb25seVByb3hpZXMuZ2V0KG9iamVjdClcblx0aWYgKHR5cGVvZiBwcm94eSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRwcm94eSA9IG5ldyBQcm94eShvYmplY3QsIHRyYXBzKVxuXHRcdHJlYWRvbmx5UHJveGllcy5zZXQoaGlkZU9yaWdpbmFsID8gcHJveHkgOiBvYmplY3QsIHByb3h5KVxuXHR9XG5cdHJldHVybiBwcm94eVxufVxuXG5mdW5jdGlvbiBub3RQcml2YXRlKGtleSkge1xuXHRyZXR1cm4gdHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwga2V5WzBdICE9PSAnXydcbn1cblxuLy8gRnJlZXplIGFuZCBwcm94eSBhbnl0aGluZyB0aGF0IGlzIGFjY2Vzc2libGUgdGhyb3VnaCBKYXZhU2NyaXB0IHN5bnRheCBhbG9uZVxuLy8gVGhpcyBzaG91bGQgaW5jbHVkZSBhbnkgdmFsdWUgdGhhdCB5b3UgY2FuIGdldCBmcm9tIEphdmFTY3JpcHQgc3ludGF4IGl0c2VsZi5cbi8vIEZvciBleGFtcGxlOlxuLy8gICAgIFwibXkgc3RyaW5nXCIuZm9vYmFyXG4vLyAgICAgdHJ5IHt0aHJvdyAxfSBjYXRjaCAoZXJyKSB7ZXJyLmZvb2Jhcn1cbi8vIFN5bWJvbHMgYXJlIGluY2x1ZGVkIGhlcmUgYmVjYXVzZSB0aGV5IGFyZSBub3QgcHJvdGVjdGVkIGJ5IG91ciBwcm94eWluZ1xuLy8gYmVjYXVzZSB0aGV5IGFyZSBwcmltaXRpdmVzLlxudmFyIHNhZmVPYmplY3RzID0gcmVxdWlyZSgnLi9saWIvbWFrZS1zYWZlJykoW1xuXHRCb29sZWFuLnByb3RvdHlwZSxcblx0TnVtYmVyLnByb3RvdHlwZSxcblx0U3RyaW5nLnByb3RvdHlwZSxcblx0U3ltYm9sLnByb3RvdHlwZSxcblx0RnVuY3Rpb24ucHJvdG90eXBlLFxuXHRPYmplY3QucHJvdG90eXBlLFxuXHRBcnJheS5wcm90b3R5cGUsXG5cdFJlZ0V4cC5wcm90b3R5cGUsXG5cdEVycm9yLnByb3RvdHlwZSxcblx0RXZhbEVycm9yLnByb3RvdHlwZSxcblx0UmFuZ2VFcnJvci5wcm90b3R5cGUsXG5cdFJlZmVyZW5jZUVycm9yLnByb3RvdHlwZSxcblx0U3ludGF4RXJyb3IucHJvdG90eXBlLFxuXHRUeXBlRXJyb3IucHJvdG90eXBlLFxuXHRVUklFcnJvci5wcm90b3R5cGUsXG5cdFByb21pc2UucHJvdG90eXBlLFxuXHRPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnVuY3Rpb24qKCl7fSksXG5cdE9iamVjdC5nZXRQcm90b3R5cGVPZihmdW5jdGlvbiooKXt9KCkpXG5dLCBpc09iamVjdCwgZ2V0UHJveHksIEdMT0JBTClcblxudmFyIGV2YWxGdW5jdGlvbiA9IEdMT0JBTC5ldmFsXG52YXIgRnVuY3Rpb25Db25zdHJ1Y3RvclByb3h5ID0gMC4uY29uc3RydWN0b3IuY29uc3RydWN0b3JcblxubW9kdWxlLmV4cG9ydHMuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcblx0cmV0dXJuIGEgPT09IGIgfHwgKHJlYWRvbmx5UHJveGllcy5nZXQoYSkgfHwgYSkgPT09IChyZWFkb25seVByb3hpZXMuZ2V0KGIpIHx8IGIpXG59XG5cblxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVuc2FmZU9iamVjdHMsIGlzT2JqZWN0LCBnZXRQcm94eSwgR0xPQkFMKSB7XG5cdHZhciBwcm94aWVzID0gW11cblx0dmFyIHNhZmVPYmplY3RzID0gW11cblx0dmFyIHJldHVybnNTYWZlVmFsdWVzID0gW1xuXHRcdEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdXG5cdF1cblx0dmFyIGdsb2JhbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhHTE9CQUwpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gJ3Jvb3QnICYmIGtleSAhPT0gJ0dMT0JBTCcgJiYga2V5ICE9PSAnZ2xvYmFsJyAmJiBrZXkgIT09ICd3aW5kb3cnICYmIGtleSAhPT0gJ3NlbGYnfSlcblx0dmFyIGdsb2JhbFZhbHVlcyA9IGdsb2JhbEtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4gdGhpc1trZXldfSwgR0xPQkFMKVxuXHRcblx0d2hpbGUgKHVuc2FmZU9iamVjdHMubGVuZ3RoKSB7XG5cdFx0bWFrZVNhZmUodW5zYWZlT2JqZWN0cy5zaGlmdCgpKVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBtYWtlU2FmZShvYmplY3QpIHtcblx0XHRpZiAoaXNTYWZlKG9iamVjdCkpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHR2YXIgcmVhY2hhYmxlID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KVxuXHRcdFx0LmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCkpXG5cdFx0XG5cdFx0aWYgKG9iamVjdCA9PT0gRnVuY3Rpb24ucHJvdG90eXBlKSB7XG5cdFx0XHRyZWFjaGFibGUgPSByZWFjaGFibGUuZmlsdGVyKGlnbm9yZWRLZXlzKVxuXHRcdH1cblx0XHRcblx0XHRyZWFjaGFibGUuZm9yRWFjaChyZXBsYWNlV2l0aFByb3h5LCBvYmplY3QpXG5cdFx0T2JqZWN0LmZyZWV6ZShvYmplY3QpXG5cdFx0c2FmZU9iamVjdHMucHVzaChvYmplY3QpXG5cdFx0XG5cdFx0dW5zYWZlT2JqZWN0cy5wdXNoKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpKVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBpZ25vcmVkS2V5cyhrZXkpIHtcblx0XHRyZXR1cm4ga2V5ICE9PSAnY2FsbGVyJyAmJiBrZXkgIT09ICdhcmd1bWVudHMnXG5cdH1cblx0XG5cdGZ1bmN0aW9uIGlzU2FmZSh2YWx1ZSkge1xuXHRcdHJldHVybiAhaXNPYmplY3QodmFsdWUpIHx8IHByb3hpZXMuaW5kZXhPZih2YWx1ZSkgPj0gMCB8fCBzYWZlT2JqZWN0cy5pbmRleE9mKHZhbHVlKSA+PSAwXG5cdH1cblx0XG5cdGZ1bmN0aW9uIHJlcGxhY2VXaXRoUHJveHkoa2V5KSB7XG5cdFx0dmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsIGtleSlcblx0XHRpZiAoISgndmFsdWUnIGluIGQpKSB7XG5cdFx0XHRpZiAoa2V5ID09PSAnX19wcm90b19fJyAmJiBpc1NhZmUodGhpc1trZXldKSkge1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGlmICghZC5jb25maWd1cmFibGUpIHtcblx0XHRcdFx0ZC5nZXQgJiYgdW5zYWZlT2JqZWN0cy5wdXNoKGQuZ2V0KVxuXHRcdFx0XHRkLnNldCAmJiB1bnNhZmVPYmplY3RzLnB1c2goZC5zZXQpXG5cdFx0XHRcdC8vIFRoaXMgZ2V0dGVyL3NldHRlciBjb3VsZCBwb3RlbnRpYWxseSByZXR1cm4gYSBub24tcHJveGllZCBvYmplY3Rcblx0XHRcdFx0Y29uc29sZS53YXJuKCdQb3RlbnRpYWxseSB2dWxuZXJhYmxlIGdldHRlci9zZXR0ZXIgYXQgJXMgaW4gJXMnLCBrZXksIHRoaXMpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0dmFyIGdldHRlciA9IGQuZ2V0ICYmIGdldFByb3h5KGQuZ2V0LCB0cnVlKVxuXHRcdFx0dmFyIHNldHRlciA9IGQuc2V0ICYmIGdldFByb3h5KGQuc2V0LCB0cnVlKVxuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuXHRcdFx0XHRnZXQ6IGdldHRlcixcblx0XHRcdFx0c2V0OiBzZXR0ZXIsXG5cdFx0XHRcdGVudW1lcmFibGU6IGQuZW51bWVyYWJsZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZVxuXHRcdFx0fSlcblx0XHRcdGdldHRlciAmJiBwcm94aWVzLnB1c2goZ2V0dGVyKVxuXHRcdFx0c2V0dGVyICYmIHByb3hpZXMucHVzaChzZXR0ZXIpXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0XG5cdFx0dmFyIHZhbHVlID0gdGhpc1trZXldXG5cdFx0aWYgKGlzU2FmZSh2YWx1ZSkpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHRpZiAoZC53cml0YWJsZSkge1xuXHRcdFx0dmFyIHByb3h5ID0gZ2V0UHJveHkodmFsdWUsIHRydWUpXG5cdFx0XHRwcm94aWVzLnB1c2godGhpc1trZXldID0gcHJveHkpXG5cdFx0XHRyZXBsYWNlSW5HbG9iYWwodmFsdWUsIHByb3h5KVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdFxuXHRcdGlmIChkLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0dmFyIHByb3h5ID0gZ2V0UHJveHkodmFsdWUsIHRydWUpXG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG5cdFx0XHRcdHZhbHVlOiBwcm94eSxcblx0XHRcdFx0d3JpdGFibGU6IGZhbHNlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiBkLmVudW1lcmFibGUsXG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2Vcblx0XHRcdH0pXG5cdFx0XHRyZXBsYWNlSW5HbG9iYWwodmFsdWUsIHByb3h5KVxuXHRcdFx0cHJveGllcy5wdXNoKHByb3h5KVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdFxuXHRcdHVuc2FmZU9iamVjdHMucHVzaCh2YWx1ZSlcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIHJldHVybnNTYWZlVmFsdWVzLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuXHRcdFx0Ly8gVGhpcyBmdW5jdGlvbiBjb3VsZCBwb3RlbnRpYWxseSByZXR1cm4gYSBub24tcHJveGllZCBvYmplY3Rcblx0XHRcdGNvbnNvbGUud2FybignUG90ZW50aWFsbHkgdnVsbmVyYWJsZSBmdW5jdGlvbiBhdCAlcyBpbiAlcycsIGtleSwgdGhpcylcblx0XHR9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHJlcGxhY2VJbkdsb2JhbCh2YWx1ZSwgcHJveHkpIHtcblx0XHR2YXIgaW5kZXggPSBnbG9iYWxWYWx1ZXMuaW5kZXhPZih2YWx1ZSlcblx0XHRpZiAoaW5kZXggPj0gMCkge1xuXHRcdFx0dmFyIGtleSA9IGdsb2JhbEtleXNbaW5kZXhdXG5cdFx0XHR2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoR0xPQkFMLCBrZXkpXG5cdFx0XHRpZiAoZC53cml0YWJsZSkge1xuXHRcdFx0XHRHTE9CQUxba2V5XSA9IHByb3h5XG5cdFx0XHR9IGVsc2UgaWYgKGQuY29uZmlndXJhYmxlKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHTE9CQUwsIGtleSwge1xuXHRcdFx0XHRcdHZhbHVlOiBwcm94eSxcblx0XHRcdFx0XHR3cml0YWJsZTogZmFsc2UsXG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogZC5lbnVtZXJhYmxlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2Vcblx0XHRcdFx0fSlcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignV2FzIG5vdCBhYmxlIHRvIHJlcGxhY2UgJXMgaW4gZ2xvYmFsIG9iamVjdCcsIGtleSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdHJldHVybiBzYWZlT2JqZWN0c1xufVxuIiwidmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuXHRpZiAoIW9iaiB8fCB0b1N0cmluZy5jYWxsKG9iaikgIT09ICdbb2JqZWN0IE9iamVjdF0nIHx8IG9iai5ub2RlVHlwZSB8fCBvYmouc2V0SW50ZXJ2YWwpXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdHZhciBoYXNfb3duX2NvbnN0cnVjdG9yID0gaGFzT3duLmNhbGwob2JqLCAnY29uc3RydWN0b3InKTtcblx0dmFyIGhhc19pc19wcm9wZXJ0eV9vZl9tZXRob2QgPSBoYXNPd24uY2FsbChvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCAnaXNQcm90b3R5cGVPZicpO1xuXHQvLyBOb3Qgb3duIGNvbnN0cnVjdG9yIHByb3BlcnR5IG11c3QgYmUgT2JqZWN0XG5cdGlmIChvYmouY29uc3RydWN0b3IgJiYgIWhhc19vd25fY29uc3RydWN0b3IgJiYgIWhhc19pc19wcm9wZXJ0eV9vZl9tZXRob2QpXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdC8vIE93biBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhdGVkIGZpcnN0bHksIHNvIHRvIHNwZWVkIHVwLFxuXHQvLyBpZiBsYXN0IG9uZSBpcyBvd24sIHRoZW4gYWxsIHByb3BlcnRpZXMgYXJlIG93bi5cblx0dmFyIGtleTtcblx0Zm9yICgga2V5IGluIG9iaiApIHt9XG5cblx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkIHx8IGhhc093bi5jYWxsKCBvYmosIGtleSApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHRlbmQoKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0ICAgIHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcblx0ICAgIGkgPSAxLFxuXHQgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0ICAgIGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMV0gfHwge307XG5cdFx0Ly8gc2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdGkgPSAyO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdGFyZ2V0ICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoIChvcHRpb25zID0gYXJndW1lbnRzWyBpIF0pICE9IG51bGwgKSB7XG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBpc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY29weSkpICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSApIHtcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBBcnJheS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBpc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4Jyk7XG52YXIgcmUgPSBuZXcgUmVnRXhwKGFuc2lSZWdleCgpLnNvdXJjZSk7IC8vIHJlbW92ZSB0aGUgYGdgIGZsYWdcbm1vZHVsZS5leHBvcnRzID0gcmUudGVzdC5iaW5kKHJlKTtcbiIsIi8qKlxuICogwqkgQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDE3IEFsbCBSaWdodHMgUmVzZXJ2ZWRcbiAqICAgUHJvamVjdCBuYW1lOiBKU09OYXRhXG4gKiAgIFRoaXMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UsIHNlZSBMSUNFTlNFXG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIEpTT05hdGFcbiAqIEBkZXNjcmlwdGlvbiBKU09OIHF1ZXJ5IGFuZCB0cmFuc2Zvcm1hdGlvbiBsYW5ndWFnZVxuICovXG5cbi8qKlxuICoganNvbmF0YVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICogQHJldHVybnMge3tldmFsdWF0ZTogZXZhbHVhdGUsIGFzc2lnbjogYXNzaWdufX0gRXZhbHVhdGVkIGV4cHJlc3Npb25cbiAqL1xudmFyIGpzb25hdGEgPSAoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG9wZXJhdG9ycyA9IHtcbiAgICAgICAgJy4nOiA3NSxcbiAgICAgICAgJ1snOiA4MCxcbiAgICAgICAgJ10nOiAwLFxuICAgICAgICAneyc6IDcwLFxuICAgICAgICAnfSc6IDAsXG4gICAgICAgICcoJzogODAsXG4gICAgICAgICcpJzogMCxcbiAgICAgICAgJywnOiAwLFxuICAgICAgICAnQCc6IDc1LFxuICAgICAgICAnIyc6IDcwLFxuICAgICAgICAnOyc6IDgwLFxuICAgICAgICAnOic6IDgwLFxuICAgICAgICAnPyc6IDIwLFxuICAgICAgICAnKyc6IDUwLFxuICAgICAgICAnLSc6IDUwLFxuICAgICAgICAnKic6IDYwLFxuICAgICAgICAnLyc6IDYwLFxuICAgICAgICAnJSc6IDYwLFxuICAgICAgICAnfCc6IDIwLFxuICAgICAgICAnPSc6IDQwLFxuICAgICAgICAnPCc6IDQwLFxuICAgICAgICAnPic6IDQwLFxuICAgICAgICAnXic6IDQwLFxuICAgICAgICAnKionOiA2MCxcbiAgICAgICAgJy4uJzogMjAsXG4gICAgICAgICc6PSc6IDEwLFxuICAgICAgICAnIT0nOiA0MCxcbiAgICAgICAgJzw9JzogNDAsXG4gICAgICAgICc+PSc6IDQwLFxuICAgICAgICAnfj4nOiA0MCxcbiAgICAgICAgJ2FuZCc6IDMwLFxuICAgICAgICAnb3InOiAyNSxcbiAgICAgICAgJ2luJzogNDAsXG4gICAgICAgICcmJzogNTAsXG4gICAgICAgICchJzogMCwgICAvLyBub3QgYW4gb3BlcmF0b3IsIGJ1dCBuZWVkZWQgYXMgYSBzdG9wIGNoYXJhY3RlciBmb3IgbmFtZSB0b2tlbnNcbiAgICAgICAgJ34nOiAwICAgLy8gbm90IGFuIG9wZXJhdG9yLCBidXQgbmVlZGVkIGFzIGEgc3RvcCBjaGFyYWN0ZXIgZm9yIG5hbWUgdG9rZW5zXG4gICAgfTtcblxuICAgIHZhciBlc2NhcGVzID0geyAgLy8gSlNPTiBzdHJpbmcgZXNjYXBlIHNlcXVlbmNlcyAtIHNlZSBqc29uLm9yZ1xuICAgICAgICAnXCInOiAnXCInLFxuICAgICAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAgICAgJy8nOiAnLycsXG4gICAgICAgICdiJzogJ1xcYicsXG4gICAgICAgICdmJzogJ1xcZicsXG4gICAgICAgICduJzogJ1xcbicsXG4gICAgICAgICdyJzogJ1xccicsXG4gICAgICAgICd0JzogJ1xcdCdcbiAgICB9O1xuXG4gICAgLy8gVG9rZW5pemVyIChsZXhlcikgLSBpbnZva2VkIGJ5IHRoZSBwYXJzZXIgdG8gcmV0dXJuIG9uZSB0b2tlbiBhdCBhIHRpbWVcbiAgICB2YXIgdG9rZW5pemVyID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gMDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICAgIHZhciBjcmVhdGUgPSBmdW5jdGlvbiAodHlwZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSB7dHlwZTogdHlwZSwgdmFsdWU6IHZhbHVlLCBwb3NpdGlvbjogcG9zaXRpb259O1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc2NhblJlZ2V4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyB0aGUgcHJlZml4ICcvJyB3aWxsIGhhdmUgYmVlbiBwcmV2aW91c2x5IHNjYW5uZWQuIEZpbmQgdGhlIGVuZCBvZiB0aGUgcmVnZXguXG4gICAgICAgICAgICAvLyBzZWFyY2ggZm9yIGNsb3NpbmcgJy8nIGlnbm9yaW5nIGFueSB0aGF0IGFyZSBlc2NhcGVkLCBvciB3aXRoaW4gYnJhY2tldHNcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIGRlcHRoID0gMDtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuO1xuICAgICAgICAgICAgdmFyIGZsYWdzO1xuICAgICAgICAgICAgd2hpbGUocG9zaXRpb24gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudENoYXIgPSBwYXRoLmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYoY3VycmVudENoYXIgPT09ICcvJyAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiAtIDEpICE9PSAnXFxcXCcgJiYgZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5kIG9mIHJlZ2V4IGZvdW5kXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBwYXRoLnN1YnN0cmluZyhzdGFydCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZihwYXR0ZXJuID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAzMDFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYXIgPSBwYXRoLmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZsYWdzXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGN1cnJlbnRDaGFyID09PSAnaScgfHwgY3VycmVudENoYXIgPT09ICdtJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFyID0gcGF0aC5jaGFyQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzID0gcGF0aC5zdWJzdHJpbmcoc3RhcnQsIHBvc2l0aW9uKSArICdnJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZigoY3VycmVudENoYXIgPT09ICcoJyB8fCBjdXJyZW50Q2hhciA9PT0gJ1snIHx8IGN1cnJlbnRDaGFyID09PSAneycpICYmIHBhdGguY2hhckF0KHBvc2l0aW9uIC0gMSkgIT09ICdcXFxcJyApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoKGN1cnJlbnRDaGFyID09PSAnKScgfHwgY3VycmVudENoYXIgPT09ICddJyB8fCBjdXJyZW50Q2hhciA9PT0gJ30nKSAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiAtIDEpICE9PSAnXFxcXCcgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMzAyXCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID49IGxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgY3VycmVudENoYXIgPSBwYXRoLmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICAvLyBza2lwIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCAmJiAnIFxcdFxcblxcclxcdicuaW5kZXhPZihjdXJyZW50Q2hhcikgPiAtMSkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgY3VycmVudENoYXIgPSBwYXRoLmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IGZvciByZWdleFxuICAgICAgICAgICAgaWYgKHByZWZpeCAhPT0gdHJ1ZSAmJiBjdXJyZW50Q2hhciA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdyZWdleCcsIHNjYW5SZWdleCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhbmRsZSBkb3VibGUtY2hhciBvcGVyYXRvcnNcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJy4nICYmIHBhdGguY2hhckF0KHBvc2l0aW9uICsgMSkgPT09ICcuJykge1xuICAgICAgICAgICAgICAgIC8vIGRvdWJsZS1kb3QgLi4gcmFuZ2Ugb3BlcmF0b3JcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ29wZXJhdG9yJywgJy4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICc6JyAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiArIDEpID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICAvLyA6PSBhc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdvcGVyYXRvcicsICc6PScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnIScgJiYgcGF0aC5jaGFyQXQocG9zaXRpb24gKyAxKSA9PT0gJz0nKSB7XG4gICAgICAgICAgICAgICAgLy8gIT1cbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ29wZXJhdG9yJywgJyE9Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICc+JyAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiArIDEpID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICAvLyA+PVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgnb3BlcmF0b3InLCAnPj0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJzwnICYmIHBhdGguY2hhckF0KHBvc2l0aW9uICsgMSkgPT09ICc9Jykge1xuICAgICAgICAgICAgICAgIC8vIDw9XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdvcGVyYXRvcicsICc8PScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnKicgJiYgcGF0aC5jaGFyQXQocG9zaXRpb24gKyAxKSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgLy8gKiogIGRlc2NlbmRhbnQgd2lsZGNhcmRcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ29wZXJhdG9yJywgJyoqJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICd+JyAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiArIDEpID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICAvLyB+PiAgY2hhaW4gZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ29wZXJhdG9yJywgJ34+Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IGZvciBzaW5nbGUgY2hhciBvcGVyYXRvcnNcbiAgICAgICAgICAgIGlmIChvcGVyYXRvcnMuaGFzT3duUHJvcGVydHkoY3VycmVudENoYXIpKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdvcGVyYXRvcicsIGN1cnJlbnRDaGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgZm9yIHN0cmluZyBsaXRlcmFsc1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnXCInIHx8IGN1cnJlbnRDaGFyID09PSBcIidcIikge1xuICAgICAgICAgICAgICAgIHZhciBxdW90ZVR5cGUgPSBjdXJyZW50Q2hhcjtcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUgcXVvdGVkIHN0cmluZyBsaXRlcmFsIC0gZmluZCBlbmQgb2Ygc3RyaW5nXG4gICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICB2YXIgcXN0ciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFyID0gcGF0aC5jaGFyQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICdcXFxcJykgeyAvLyBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhciA9IHBhdGguY2hhckF0KHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlc2NhcGVzLmhhc093blByb3BlcnR5KGN1cnJlbnRDaGFyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFzdHIgKz0gZXNjYXBlc1tjdXJyZW50Q2hhcl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDaGFyID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcXHUgc2hvdWxkIGJlIGZvbGxvd2VkIGJ5IDQgaGV4IGRpZ2l0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvY3RldHMgPSBwYXRoLnN1YnN0cihwb3NpdGlvbiArIDEsIDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXlswLTlhLWZBLUZdKyQvLnRlc3Qob2N0ZXRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kZXBvaW50ID0gcGFyc2VJbnQob2N0ZXRzLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAxMDRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbGxlZ2FsIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDEwM1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogY3VycmVudENoYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENoYXIgPT09IHF1b3RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ3N0cmluZycsIHFzdHIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXN0ciArPSBjdXJyZW50Q2hhcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAxMDFcIixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IGZvciBudW1iZXJzXG4gICAgICAgICAgICB2YXIgbnVtcmVnZXggPSAvXi0/KDB8KFsxLTldWzAtOV0qKSkoXFwuWzAtOV0rKT8oW0VlXVstK10/WzAtOV0rKT8vO1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gbnVtcmVnZXguZXhlYyhwYXRoLnN1YnN0cmluZyhwb3NpdGlvbikpO1xuICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG51bSA9IHBhcnNlRmxvYXQobWF0Y2hbMF0pO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4obnVtKSAmJiBpc0Zpbml0ZShudW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgnbnVtYmVyJywgbnVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMTAyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBtYXRjaFswXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgZm9yIHF1b3RlZCBuYW1lcyAoYmFja3RpY2tzKVxuICAgICAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgICAgICBpZihjdXJyZW50Q2hhciA9PT0gJ2AnKSB7XG4gICAgICAgICAgICAgICAgLy8gc2NhbiBmb3IgY2xvc2luZyBxdW90ZVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IHBhdGguaW5kZXhPZignYCcsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZihlbmQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBwYXRoLnN1YnN0cmluZyhwb3NpdGlvbiwgZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBlbmQgKyAxO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCduYW1lJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gbGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDEwNVwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgZm9yIG5hbWVzXG4gICAgICAgICAgICB2YXIgaSA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIGNoO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGNoID0gcGF0aC5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGxlbmd0aCB8fCAnIFxcdFxcblxcclxcdicuaW5kZXhPZihjaCkgPiAtMSB8fCBvcGVyYXRvcnMuaGFzT3duUHJvcGVydHkoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoLmNoYXJBdChwb3NpdGlvbikgPT09ICckJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyaWFibGUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gcGF0aC5zdWJzdHJpbmcocG9zaXRpb24gKyAxLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ3ZhcmlhYmxlJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gcGF0aC5zdWJzdHJpbmcocG9zaXRpb24sIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnb3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2luJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhbmQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdvcGVyYXRvcicsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RydWUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCd2YWx1ZScsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhbHNlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgndmFsdWUnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ3ZhbHVlJywgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSBsZW5ndGggJiYgbmFtZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaXRlc3BhY2UgYXQgZW5kIG9mIGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCduYW1lJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBmdW5jdGlvbiBzaWduYXR1cmUgZGVmaW5pdGlvbiBhbmQgcmV0dXJucyBhIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlIC0gdGhlIHNpZ25hdHVyZSBiZXR3ZWVuIHRoZSA8YW5nbGUgYnJhY2tldHM+XG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIFJlZ2V4IHRoYXQgcmVwcmVzZW50cyB0aGlzIHNpZ25hdHVyZSBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB3aGVuIGludm9rZWQsXG4gICAgICAgIC8vIHJldHVybnMgdGhlIHZhbGlkYXRlZCAocG9zc2libHkgZml4ZWQtdXApIGFyZ3VtZW50cywgb3IgdGhyb3dzIGEgdmFsaWRhdGlvbiBlcnJvclxuICAgICAgICAvLyBzdGVwIHRocm91Z2ggdGhlIHNpZ25hdHVyZSwgb25lIHN5bWJvbCBhdCBhIHRpbWVcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gMTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICB2YXIgcGFyYW0gPSB7fTtcbiAgICAgICAgdmFyIHByZXZQYXJhbSA9IHBhcmFtO1xuICAgICAgICB3aGlsZSAocG9zaXRpb24gPCBzaWduYXR1cmUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc3ltYm9sID0gc2lnbmF0dXJlLmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICBpZihzeW1ib2wgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gZmlndXJlIG91dCB3aGF0IHRvIGRvIHdpdGggdGhlIHJldHVybiB0eXBlXG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIGl0IGZvciBub3dcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgcHJldlBhcmFtID0gcGFyYW07XG4gICAgICAgICAgICAgICAgcGFyYW0gPSB7fTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBmaW5kQ2xvc2luZ0JyYWNrZXQgPSBmdW5jdGlvbihzdHIsIHN0YXJ0LCBvcGVuU3ltYm9sLCBjbG9zZVN5bWJvbCkge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjbG9zaW5nIHN5bWJvbCAoZS5nLiBicmFja2V0KSBpbiBhIHN0cmluZ1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgYmFsYW5jZXMgdGhlIG9wZW5pbmcgc3ltYm9sIGF0IHBvc2l0aW9uIHN0YXJ0XG4gICAgICAgICAgICAgICAgdmFyIGRlcHRoID0gMTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBzdGFydDtcbiAgICAgICAgICAgICAgICB3aGlsZShwb3NpdGlvbiA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gc3RyLmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbCA9PT0gY2xvc2VTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gb3V0IG9mIHdoaWxlIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHN5bWJvbCA9PT0gb3BlblN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHN5bWJvbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOiAvLyBzdHJpbmdcbiAgICAgICAgICAgICAgICBjYXNlICduJzogLy8gbnVtYmVyXG4gICAgICAgICAgICAgICAgY2FzZSAnYic6IC8vIGJvb2xlYW5cbiAgICAgICAgICAgICAgICBjYXNlICdsJzogLy8gbm90IHNvIHN1cmUgYWJvdXQgZXhwZWN0aW5nIG51bGw/XG4gICAgICAgICAgICAgICAgY2FzZSAnbyc6IC8vIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBwYXJhbS5yZWdleCA9ICdbJyArIHN5bWJvbCArICdtXSc7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnR5cGUgPSBzeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYSc6IC8vIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIC8vICBub3JtYWxseSB0cmVhdCBhbnkgdmFsdWUgYXMgc2luZ2xldG9uIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnJlZ2V4ID0gJ1thc25ibGZvbV0nO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbS50eXBlID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbS5hcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZic6IC8vIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnJlZ2V4ID0gJ2YnO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbS50eXBlID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2onOiAvLyBhbnkgSlNPTiB0eXBlXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnJlZ2V4ID0gJ1thc25ibG9tXSc7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnR5cGUgPSBzeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAneCc6IC8vIGFueSB0eXBlXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnJlZ2V4ID0gJ1thc25ibGZvbV0nO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbS50eXBlID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJy0nOiAvLyB1c2UgY29udGV4dCBpZiBwYXJhbSBub3Qgc3VwcGxpZWRcbiAgICAgICAgICAgICAgICAgICAgcHJldlBhcmFtLmNvbnRleHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwcmV2UGFyYW0uY29udGV4dFJlZ2V4ID0gbmV3IFJlZ0V4cChwcmV2UGFyYW0ucmVnZXgpOyAvLyBwcmUtY29tcGlsZWQgdG8gdGVzdCB0aGUgY29udGV4dCB0eXBlIGF0IHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAgICAgcHJldlBhcmFtLnJlZ2V4ICs9ICc/JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnPyc6IC8vIG9wdGlvbmFsIHBhcmFtXG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6IC8vIG9uZSBvciBtb3JlXG4gICAgICAgICAgICAgICAgICAgIHByZXZQYXJhbS5yZWdleCArPSBzeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJygnOiAvLyBjaG9pY2Ugb2YgdHlwZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VhcmNoIGZvcndhcmQgZm9yIG1hdGNoaW5nICcpJ1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kUGFyZW4gPSBmaW5kQ2xvc2luZ0JyYWNrZXQoc2lnbmF0dXJlLCBwb3NpdGlvbiwgJygnLCAnKScpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hvaWNlID0gc2lnbmF0dXJlLnN1YnN0cmluZyhwb3NpdGlvbiArIDEsIGVuZFBhcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoY2hvaWNlLmluZGV4T2YoJzwnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIHBhcmFtZXRlcml6ZWQgdHlwZXMsIHNpbXBsZSByZWdleFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0ucmVnZXggPSAnWycgKyBjaG9pY2UgKyAnbV0nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBoYXJkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwNDAyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNob2ljZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLnR5cGUgPSAnKCcgKyBjaG9pY2UgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gZW5kUGFyZW47XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnPCc6IC8vIHR5cGUgcGFyYW1ldGVyIC0gY2FuIG9ubHkgYmUgYXBwbGllZCB0byAnYScgYW5kICdmJ1xuICAgICAgICAgICAgICAgICAgICBpZihwcmV2UGFyYW0udHlwZSA9PT0gJ2EnIHx8IHByZXZQYXJhbS50eXBlID09PSAnZicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBmb3J3YXJkIGZvciBtYXRjaGluZyAnPidcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRQb3MgPSBmaW5kQ2xvc2luZ0JyYWNrZXQoc2lnbmF0dXJlLCBwb3NpdGlvbiwgJzwnLCAnPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldlBhcmFtLnN1YnR5cGUgPSBzaWduYXR1cmUuc3Vic3RyaW5nKHBvc2l0aW9uICsgMSwgZW5kUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gZW5kUG9zO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzA0MDFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcHJldlBhcmFtLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZ2V4U3RyID0gJ14nICtcbiAgICAgICAgICBwYXJhbXMubWFwKGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnKCcgKyBwYXJhbS5yZWdleCArICcpJztcbiAgICAgICAgICB9KS5qb2luKCcnKSArXG4gICAgICAgICAgJyQnO1xuICAgICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4U3RyKTtcbiAgICAgICAgdmFyIGdldFN5bWJvbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgc3ltYm9sO1xuICAgICAgICAgICAgaWYoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSAnZic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gJ3MnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSAnbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSAnYic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9ICdsJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSAnYSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9ICdvJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW55IHZhbHVlIGNhbiBiZSB1bmRlZmluZWQsIGJ1dCBzaG91bGQgYmUgYWxsb3dlZCB0byBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gJ20nOyAvLyBtIGZvciBtaXNzaW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdGhyb3dWYWxpZGF0aW9uRXJyb3IgPSBmdW5jdGlvbihiYWRBcmdzLCBiYWRTaWcpIHtcbiAgICAgICAgICAgIC8vIHRvIGZpZ3VyZSBvdXQgd2hlcmUgdGhpcyB3ZW50IHdyb25nIHdlIG5lZWQgYXBwbHkgZWFjaCBjb21wb25lbnQgb2YgdGhlXG4gICAgICAgICAgICAvLyByZWdleCB0byBlYWNoIGFyZ3VtZW50IHVudGlsIHdlIGdldCB0byB0aGUgb25lIHRoYXQgZmFpbHMgdG8gbWF0Y2hcbiAgICAgICAgICAgIHZhciBwYXJ0aWFsUGF0dGVybiA9ICdeJztcbiAgICAgICAgICAgIHZhciBnb29kVG8gPSAwO1xuICAgICAgICAgICAgZm9yKHZhciBpbmRleCA9IDA7IGluZGV4IDwgcGFyYW1zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHBhcnRpYWxQYXR0ZXJuICs9IHBhcmFtc1tpbmRleF0ucmVnZXg7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gYmFkU2lnLm1hdGNoKHBhcnRpYWxQYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBpZihtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmYWlsZWQgaGVyZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQwNDEwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBiYWRBcmdzW2dvb2RUb10sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogZ29vZFRvICsgMVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnb29kVG8gPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBpdCBnb3QgdGhpcyBmYXIsIGl0J3MgcHJvYmFibHkgYmVjYXVzZSBvZiBleHRyYW5lb3VzIGFyZ3VtZW50cyAod2VcbiAgICAgICAgICAgIC8vIGhhdmVuJ3QgYWRkZWQgdGhlIHRyYWlsaW5nICckJyBpbiB0aGUgcmVnZXggeWV0LlxuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiVDA0MTBcIixcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYmFkQXJnc1tnb29kVG9dLFxuICAgICAgICAgICAgICAgIGluZGV4OiBnb29kVG8gKyAxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWZpbml0aW9uOiBzaWduYXR1cmUsXG4gICAgICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24oYXJncywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBzdXBwbGllZFNpZyA9ICcnO1xuICAgICAgICAgICAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwcGxpZWRTaWcgKz0gZ2V0U3ltYm9sKGFyZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGlzVmFsaWQgPSByZWdleC5leGVjKHN1cHBsaWVkU2lnKTtcbiAgICAgICAgICAgICAgICBpZihpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZGF0ZWRBcmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3NbYXJnSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gaXNWYWxpZFtpbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobWF0Y2ggPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Vic3RpdHV0ZSBjb250ZXh0IHZhbHVlIGZvciBtaXNzaW5nIGFyZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdCBjaGVjayB0aGF0IHRoZSBjb250ZXh0IHZhbHVlIGlzIHRoZSByaWdodCB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0VHlwZSA9IGdldFN5bWJvbChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGVzdCBjb250ZXh0VHlwZSBhZ2FpbnN0IHRoZSByZWdleCBmb3IgdGhpcyBhcmcgKHdpdGhvdXQgdGhlIHRyYWlsaW5nID8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHBhcmFtLmNvbnRleHRSZWdleC50ZXN0KGNvbnRleHRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVkQXJncy5wdXNoKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGV4dCB2YWx1ZSBub3QgY29tcGF0aWJsZSB3aXRoIHRoaXMgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQwNDExXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGFyZ0luZGV4ICsgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlZEFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF5IGhhdmUgbWF0Y2hlZCBtdWx0aXBsZSBhcmdzIChpZiB0aGUgcmVnZXggZW5kcyB3aXRoIGEgJysnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BsaXQgaW50byBzaW5nbGUgdG9rZW5zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2guc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24oc2luZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSAnYScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaW5nbGUgPT09ICdtJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pc3NpbmcgKHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3NbYXJnSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcnJheU9LID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyB0aGVyZSB0eXBlIGluZm9ybWF0aW9uIG9uIHRoZSBjb250ZW50cyBvZiB0aGUgYXJyYXk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbS5zdWJ0eXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2luZ2xlICE9PSAnYScgJiYgbWF0Y2ggIT09IHBhcmFtLnN1YnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5T0sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzaW5nbGUgPT09ICdhJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1UeXBlID0gZ2V0U3ltYm9sKGFyZ1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1UeXBlICE9PSBwYXJhbS5zdWJ0eXBlLmNoYXJBdCgwKSkgeyAvLyBUT0RPIHJlY3Vyc2UgZnVydGhlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheU9LID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGV2ZXJ5IGl0ZW0gaW4gdGhlIGFycmF5IGlzIHRoaXMgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZmVyZW50SXRlbXMgPSBhcmcuZmlsdGVyKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZ2V0U3ltYm9sKHZhbCkgIT09IGl0ZW1UeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5T0sgPSAoZGlmZmVyZW50SXRlbXMubGVuZ3RoID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnJheU9LKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDA0MTJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGFyZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBhcmdJbmRleCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBwYXJhbS5zdWJ0eXBlIC8vIFRPRE8gdHJhbnNsYXRlIHN5bWJvbCB0byB0eXBlIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZ1bmN0aW9uIGV4cGVjdHMgYW4gYXJyYXkuIElmIGl0J3Mgbm90IG9uZSwgbWFrZSBpdCBzb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaW5nbGUgIT09ICdhJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBbYXJnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZWRBcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ0luZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZWRBcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ0luZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZWRBcmdzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvd1ZhbGlkYXRpb25FcnJvcihhcmdzLCBzdXBwbGllZFNpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBwYXJzZXIgaW1wbGVtZW50cyB0aGUgJ1RvcCBkb3duIG9wZXJhdG9yIHByZWNlZGVuY2UnIGFsZ29yaXRobSBkZXZlbG9wZWQgYnkgVmF1Z2hhbiBSIFByYXR0OyBodHRwOi8vZGwuYWNtLm9yZy9jaXRhdGlvbi5jZm0/aWQ9NTEyOTMxLlxuICAgIC8vIGFuZCBidWlsZHMgb24gdGhlIEphdmFzY3JpcHQgZnJhbWV3b3JrIGRlc2NyaWJlZCBieSBEb3VnbGFzIENyb2NrZm9yZCBhdCBodHRwOi8vamF2YXNjcmlwdC5jcm9ja2ZvcmQuY29tL3Rkb3AvdGRvcC5odG1sXG4gICAgLy8gYW5kIGluICdCZWF1dGlmdWwgQ29kZScsIGVkaXRlZCBieSBBbmR5IE9yYW0gYW5kIEdyZWcgV2lsc29uLCBDb3B5cmlnaHQgMjAwNyBPJ1JlaWxseSBNZWRpYSwgSW5jLiA3OTgtMC01OTYtNTEwMDQtNlxuXG4gICAgdmFyIHBhcnNlciA9IGZ1bmN0aW9uIChzb3VyY2UsIHJlY292ZXIpIHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHZhciBsZXhlcjtcblxuICAgICAgICB2YXIgc3ltYm9sX3RhYmxlID0ge307XG4gICAgICAgIHZhciBlcnJvcnMgPSBbXTtcblxuICAgICAgICB2YXIgcmVtYWluaW5nVG9rZW5zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gW107XG4gICAgICAgICAgICBpZihub2RlLmlkICE9PSAnKGVuZCknKSB7XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nLnB1c2goe3R5cGU6IG5vZGUudHlwZSwgdmFsdWU6IG5vZGUudmFsdWUsIHBvc2l0aW9uOiBub2RlLnBvc2l0aW9ufSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbnh0ID0gbGV4ZXIoKTtcbiAgICAgICAgICAgIHdoaWxlKG54dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZy5wdXNoKG54dCk7XG4gICAgICAgICAgICAgICAgbnh0ID0gbGV4ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZW1haW5pbmc7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGJhc2Vfc3ltYm9sID0ge1xuICAgICAgICAgICAgbnVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gZXJyb3IgLSBzeW1ib2wgaGFzIGJlZW4gaW52b2tlZCBhcyBhIHVuYXJ5IG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogJ1MwMjExJyxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IHRoaXMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmKHJlY292ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyLnJlbWFpbmluZyA9IHJlbWFpbmluZ1Rva2VucygpO1xuICAgICAgICAgICAgICAgICAgICBlcnIudHlwZSA9ICdlcnJvcic7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc3ltYm9sID0gZnVuY3Rpb24gKGlkLCBicCkge1xuICAgICAgICAgICAgdmFyIHMgPSBzeW1ib2xfdGFibGVbaWRdO1xuICAgICAgICAgICAgYnAgPSBicCB8fCAwO1xuICAgICAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnAgPj0gcy5sYnApIHtcbiAgICAgICAgICAgICAgICAgICAgcy5sYnAgPSBicDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgPSBPYmplY3QuY3JlYXRlKGJhc2Vfc3ltYm9sKTtcbiAgICAgICAgICAgICAgICBzLmlkID0gcy52YWx1ZSA9IGlkO1xuICAgICAgICAgICAgICAgIHMubGJwID0gYnA7XG4gICAgICAgICAgICAgICAgc3ltYm9sX3RhYmxlW2lkXSA9IHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaGFuZGxlRXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmKHJlY292ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyB0b2tlbml6ZSB0aGUgcmVzdCBvZiB0aGUgYnVmZmVyIGFuZCBhZGQgaXQgdG8gYW4gZXJyb3IgdG9rZW5cbiAgICAgICAgICAgICAgICBlcnIucmVtYWluaW5nID0gcmVtYWluaW5nVG9rZW5zKCk7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gc3ltYm9sX3RhYmxlW1wiKGVycm9yKVwiXTtcbiAgICAgICAgICAgICAgICBub2RlID0gT2JqZWN0LmNyZWF0ZShzeW1ib2wpO1xuICAgICAgICAgICAgICAgIG5vZGUuZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgbm9kZS50eXBlID0gXCIoZXJyb3IpXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVyci5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhZHZhbmNlID0gZnVuY3Rpb24gKGlkLCBpbmZpeCkge1xuICAgICAgICAgICAgaWYgKGlkICYmIG5vZGUuaWQgIT09IGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGU7XG4gICAgICAgICAgICAgICAgaWYobm9kZS5pZCA9PT0gJyhlbmQpJykge1xuICAgICAgICAgICAgICAgICAgICAvLyB1bmV4cGVjdGVkIGVuZCBvZiBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IFwiUzAyMDNcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2RlID0gXCJTMDIwMlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZXJyID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogbm9kZS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IG5vZGUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV4dF90b2tlbiA9IGxleGVyKGluZml4KTtcbiAgICAgICAgICAgIGlmIChuZXh0X3Rva2VuID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHN5bWJvbF90YWJsZVtcIihlbmQpXCJdO1xuICAgICAgICAgICAgICAgIG5vZGUucG9zaXRpb24gPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gbmV4dF90b2tlbi52YWx1ZTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gbmV4dF90b2tlbi50eXBlO1xuICAgICAgICAgICAgdmFyIHN5bWJvbDtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3ZhcmlhYmxlJzpcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gc3ltYm9sX3RhYmxlW1wiKG5hbWUpXCJdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdvcGVyYXRvcic6XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbF90YWJsZVt2YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMjA0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG5leHRfdG9rZW4ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJsaXRlcmFsXCI7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbF90YWJsZVtcIihsaXRlcmFsKVwiXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmVnZXgnOlxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJyZWdleFwiO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2xfdGFibGVbXCIocmVnZXgpXCJdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAyMDVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG5leHRfdG9rZW4ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSBPYmplY3QuY3JlYXRlKHN5bWJvbCk7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBub2RlLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgbm9kZS5wb3NpdGlvbiA9IG5leHRfdG9rZW4ucG9zaXRpb247XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQcmF0dCdzIGFsZ29yaXRobVxuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChyYnApIHtcbiAgICAgICAgICAgIHZhciBsZWZ0O1xuICAgICAgICAgICAgdmFyIHQgPSBub2RlO1xuICAgICAgICAgICAgYWR2YW5jZShudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIGxlZnQgPSB0Lm51ZCgpO1xuICAgICAgICAgICAgd2hpbGUgKHJicCA8IG5vZGUubGJwKSB7XG4gICAgICAgICAgICAgICAgdCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSB0LmxlZChsZWZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB0ZXJtaW5hbCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHN5bWJvbChpZCwgMCk7XG4gICAgICAgICAgICBzLm51ZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBtYXRjaCBpbmZpeCBvcGVyYXRvcnNcbiAgICAgICAgLy8gPGV4cHJlc3Npb24+IDxvcGVyYXRvcj4gPGV4cHJlc3Npb24+XG4gICAgICAgIC8vIGxlZnQgYXNzb2NpYXRpdmVcbiAgICAgICAgdmFyIGluZml4ID0gZnVuY3Rpb24gKGlkLCBicCwgbGVkKSB7XG4gICAgICAgICAgICB2YXIgYmluZGluZ1Bvd2VyID0gYnAgfHwgb3BlcmF0b3JzW2lkXTtcbiAgICAgICAgICAgIHZhciBzID0gc3ltYm9sKGlkLCBiaW5kaW5nUG93ZXIpO1xuICAgICAgICAgICAgcy5sZWQgPSBsZWQgfHwgZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxocyA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yaHMgPSBleHByZXNzaW9uKGJpbmRpbmdQb3dlcik7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJiaW5hcnlcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBtYXRjaCBpbmZpeCBvcGVyYXRvcnNcbiAgICAgICAgLy8gPGV4cHJlc3Npb24+IDxvcGVyYXRvcj4gPGV4cHJlc3Npb24+XG4gICAgICAgIC8vIHJpZ2h0IGFzc29jaWF0aXZlXG4gICAgICAgIHZhciBpbmZpeHIgPSBmdW5jdGlvbiAoaWQsIGJwLCBsZWQpIHtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nUG93ZXIgPSBicCB8fCBvcGVyYXRvcnNbaWRdO1xuICAgICAgICAgICAgdmFyIHMgPSBzeW1ib2woaWQsIGJpbmRpbmdQb3dlcik7XG4gICAgICAgICAgICBzLmxlZCA9IGxlZCB8fCBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGhzID0gbGVmdDtcbiAgICAgICAgICAgICAgICB0aGlzLnJocyA9IGV4cHJlc3Npb24oYmluZGluZ1Bvd2VyIC0gMSk7IC8vIHN1YnRyYWN0IDEgZnJvbSBiaW5kaW5nUG93ZXIgZm9yIHJpZ2h0IGFzc29jaWF0aXZlIG9wZXJhdG9yc1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiYmluYXJ5XCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbWF0Y2ggcHJlZml4IG9wZXJhdG9yc1xuICAgICAgICAvLyA8b3BlcmF0b3I+IDxleHByZXNzaW9uPlxuICAgICAgICB2YXIgcHJlZml4ID0gZnVuY3Rpb24gKGlkLCBudWQpIHtcbiAgICAgICAgICAgIHZhciBzID0gc3ltYm9sKGlkKTtcbiAgICAgICAgICAgIHMubnVkID0gbnVkIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uKDcwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcInVuYXJ5XCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGVybWluYWwoXCIoZW5kKVwiKTtcbiAgICAgICAgdGVybWluYWwoXCIobmFtZSlcIik7XG4gICAgICAgIHRlcm1pbmFsKFwiKGxpdGVyYWwpXCIpO1xuICAgICAgICB0ZXJtaW5hbChcIihyZWdleClcIik7XG4gICAgICAgIHN5bWJvbChcIjpcIik7XG4gICAgICAgIHN5bWJvbChcIjtcIik7XG4gICAgICAgIHN5bWJvbChcIixcIik7XG4gICAgICAgIHN5bWJvbChcIilcIik7XG4gICAgICAgIHN5bWJvbChcIl1cIik7XG4gICAgICAgIHN5bWJvbChcIn1cIik7XG4gICAgICAgIHN5bWJvbChcIi4uXCIpOyAvLyByYW5nZSBvcGVyYXRvclxuICAgICAgICBpbmZpeChcIi5cIik7IC8vIGZpZWxkIHJlZmVyZW5jZVxuICAgICAgICBpbmZpeChcIitcIik7IC8vIG51bWVyaWMgYWRkaXRpb25cbiAgICAgICAgaW5maXgoXCItXCIpOyAvLyBudW1lcmljIHN1YnRyYWN0aW9uXG4gICAgICAgIGluZml4KFwiKlwiKTsgLy8gbnVtZXJpYyBtdWx0aXBsaWNhdGlvblxuICAgICAgICBpbmZpeChcIi9cIik7IC8vIG51bWVyaWMgZGl2aXNpb25cbiAgICAgICAgaW5maXgoXCIlXCIpOyAvLyBudW1lcmljIG1vZHVsdXNcbiAgICAgICAgaW5maXgoXCI9XCIpOyAvLyBlcXVhbGl0eVxuICAgICAgICBpbmZpeChcIjxcIik7IC8vIGxlc3MgdGhhblxuICAgICAgICBpbmZpeChcIj5cIik7IC8vIGdyZWF0ZXIgdGhhblxuICAgICAgICBpbmZpeChcIiE9XCIpOyAvLyBub3QgZXF1YWwgdG9cbiAgICAgICAgaW5maXgoXCI8PVwiKTsgLy8gbGVzcyB0aGFuIG9yIGVxdWFsXG4gICAgICAgIGluZml4KFwiPj1cIik7IC8vIGdyZWF0ZXIgdGhhbiBvciBlcXVhbFxuICAgICAgICBpbmZpeChcIiZcIik7IC8vIHN0cmluZyBjb25jYXRlbmF0aW9uXG4gICAgICAgIGluZml4KFwiYW5kXCIpOyAvLyBCb29sZWFuIEFORFxuICAgICAgICBpbmZpeChcIm9yXCIpOyAvLyBCb29sZWFuIE9SXG4gICAgICAgIGluZml4KFwiaW5cIik7IC8vIGlzIG1lbWJlciBvZiBhcnJheVxuICAgICAgICB0ZXJtaW5hbChcImFuZFwiKTsgLy8gdGhlICdrZXl3b3JkcycgY2FuIGFsc28gYmUgdXNlZCBhcyB0ZXJtaW5hbHMgKGZpZWxkIG5hbWVzKVxuICAgICAgICB0ZXJtaW5hbChcIm9yXCIpOyAvL1xuICAgICAgICB0ZXJtaW5hbChcImluXCIpOyAvL1xuICAgICAgICBpbmZpeHIoXCI6PVwiKTsgLy8gYmluZCB2YXJpYWJsZVxuICAgICAgICBwcmVmaXgoXCItXCIpOyAvLyB1bmFyeSBudW1lcmljIG5lZ2F0aW9uXG4gICAgICAgIGluZml4KFwifj5cIik7IC8vIGZ1bmN0aW9uIGFwcGxpY2F0aW9uXG5cbiAgICAgICAgaW5maXhyKFwiKGVycm9yKVwiLCAxMCwgZnVuY3Rpb24obGVmdCkge1xuICAgICAgICAgICAgdGhpcy5saHMgPSBsZWZ0O1xuXG4gICAgICAgICAgICB0aGlzLmVycm9yID0gbm9kZS5lcnJvcjtcbiAgICAgICAgICAgIHRoaXMucmVtYWluaW5nID0gcmVtYWluaW5nVG9rZW5zKCk7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAnZXJyb3InO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGZpZWxkIHdpbGRjYXJkIChzaW5nbGUgbGV2ZWwpXG4gICAgICAgIHByZWZpeCgnKicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFwid2lsZGNhcmRcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBkZXNjZW5kYW50IHdpbGRjYXJkIChtdWx0aS1sZXZlbClcbiAgICAgICAgcHJlZml4KCcqKicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiZGVzY2VuZGFudFwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGZ1bmN0aW9uIGludm9jYXRpb25cbiAgICAgICAgaW5maXgoXCIoXCIsIG9wZXJhdG9yc1snKCddLCBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICAgICAgLy8gbGVmdCBpcyBpcyB3aGF0IHdlIGFyZSB0cnlpbmcgdG8gaW52b2tlXG4gICAgICAgICAgICB0aGlzLnByb2NlZHVyZSA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAnZnVuY3Rpb24nO1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChub2RlLmlkICE9PSAnKScpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdvcGVyYXRvcicgJiYgbm9kZS5pZCA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJ0aWFsIGZ1bmN0aW9uIGFwcGxpY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAncGFydGlhbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ3VtZW50cy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgnPycpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmd1bWVudHMucHVzaChleHByZXNzaW9uKDApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCAhPT0gJywnKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgnLCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoXCIpXCIsIHRydWUpO1xuICAgICAgICAgICAgLy8gaWYgdGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIGlzICdmdW5jdGlvbicgb3IgzrssIHRoZW4gdGhpcyBpcyBmdW5jdGlvbiBkZWZpbml0aW9uIChsYW1iZGEgZnVuY3Rpb24pXG4gICAgICAgICAgICBpZiAobGVmdC50eXBlID09PSAnbmFtZScgJiYgKGxlZnQudmFsdWUgPT09ICdmdW5jdGlvbicgfHwgbGVmdC52YWx1ZSA9PT0gJ1xcdTAzQkInKSkge1xuICAgICAgICAgICAgICAgIC8vIGFsbCBvZiB0aGUgYXJncyBtdXN0IGJlIFZBUklBQkxFIHRva2Vuc1xuICAgICAgICAgICAgICAgIHRoaXMuYXJndW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGFyZywgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy50eXBlICE9PSAndmFyaWFibGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMjA4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGFyZy5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogYXJnLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbmRleCArIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ2xhbWJkYSc7XG4gICAgICAgICAgICAgICAgLy8gaXMgdGhlIG5leHQgdG9rZW4gYSAnPCcgLSBpZiBzbywgcGFyc2UgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgIGlmKG5vZGUuaWQgPT09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2lnUG9zID0gbm9kZS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcHRoID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZyA9ICc8JztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoZGVwdGggPiAwICYmIG5vZGUuaWQgIT09ICd7JyAmJiBub2RlLmlkICE9PSAnKGVuZCknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9rID0gYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodG9rLmlkID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHRvay5pZCA9PT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZyArPSB0b2sudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgnPicpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWduYXR1cmUgPSBwYXJzZVNpZ25hdHVyZShzaWcpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBwb3NpdGlvbiBpbnRvIHRoaXMgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5wb3NpdGlvbiA9IHNpZ1BvcyArIGVyci5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXJyb3IoIGVyciApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHBhcnNlIHRoZSBmdW5jdGlvbiBib2R5XG4gICAgICAgICAgICAgICAgYWR2YW5jZSgneycpO1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keSA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgICAgYWR2YW5jZSgnfScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHBhcmVudGhlc2lzIC0gYmxvY2sgZXhwcmVzc2lvblxuICAgICAgICBwcmVmaXgoXCIoXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUuaWQgIT09IFwiKVwiKSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKDApKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCAhPT0gXCI7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkdmFuY2UoXCI7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShcIilcIiwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAnYmxvY2snO1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFycmF5IGNvbnN0cnVjdG9yXG4gICAgICAgIHByZWZpeChcIltcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICAgIGlmIChub2RlLmlkICE9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBleHByZXNzaW9uKDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCA9PT0gXCIuLlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByYW5nZSBvcGVyYXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0ge3R5cGU6IFwiYmluYXJ5XCIsIHZhbHVlOiBcIi4uXCIsIHBvc2l0aW9uOiBub2RlLnBvc2l0aW9uLCBsaHM6IGl0ZW19O1xuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShcIi4uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UucmhzID0gZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSByYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmlkICE9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShcIixcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShcIl1cIiwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gYTtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFwidW5hcnlcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBmaWx0ZXIgLSBwcmVkaWNhdGUgb3IgYXJyYXkgaW5kZXhcbiAgICAgICAgaW5maXgoXCJbXCIsIG9wZXJhdG9yc1snWyddLCBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICAgICAgaWYobm9kZS5pZCA9PT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBwcmVkaWNhdGUgbWVhbnMgbWFpbnRhaW4gc2luZ2xldG9uIGFycmF5cyBpbiB0aGUgb3V0cHV0XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXAgPSBsZWZ0O1xuICAgICAgICAgICAgICAgIHdoaWxlKHN0ZXAgJiYgc3RlcC50eXBlID09PSAnYmluYXJ5JyAmJiBzdGVwLnZhbHVlID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcCA9IHN0ZXAubGhzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGVwLmtlZXBBcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWR2YW5jZShcIl1cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGhzID0gbGVmdDtcbiAgICAgICAgICAgICAgICB0aGlzLnJocyA9IGV4cHJlc3Npb24ob3BlcmF0b3JzWyddJ10pO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdiaW5hcnknO1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoXCJdXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBvcmRlci1ieVxuICAgICAgICBpbmZpeChcIl5cIiwgb3BlcmF0b3JzWydeJ10sIGZ1bmN0aW9uIChsZWZ0KSB7XG4gICAgICAgICAgICBhZHZhbmNlKFwiKFwiKTtcbiAgICAgICAgICAgIHZhciB0ZXJtcyA9IFtdO1xuICAgICAgICAgICAgZm9yKDs7KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlcm0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NlbmRpbmc6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCA9PT0gXCI8XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXNjZW5kaW5nIHNvcnRcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShcIjxcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmlkID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZXNjZW5kaW5nIHNvcnRcbiAgICAgICAgICAgICAgICAgICAgdGVybS5kZXNjZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShcIj5cIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy91bnNwZWNpZmllZCAtIGRlZmF1bHQgdG8gYXNjZW5kaW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRlcm0uZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgICAgdGVybXMucHVzaCh0ZXJtKTtcbiAgICAgICAgICAgICAgICBpZihub2RlLmlkICE9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWR2YW5jZShcIixcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZHZhbmNlKFwiKVwiKTtcbiAgICAgICAgICAgIHRoaXMubGhzID0gbGVmdDtcbiAgICAgICAgICAgIHRoaXMucmhzID0gdGVybXM7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAnYmluYXJ5JztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgb2JqZWN0UGFyc2VyID0gZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICBpZiAobm9kZS5pZCAhPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShcIjpcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKFtuLCB2XSk7IC8vIGhvbGRzIGFuIGFycmF5IG9mIG5hbWUvdmFsdWUgZXhwcmVzc2lvbiBwYWlyc1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCAhPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoXCIsXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoXCJ9XCIsIHRydWUpO1xuICAgICAgICAgICAgaWYodHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gTlVEIC0gdW5hcnkgcHJlZml4IGZvcm1cbiAgICAgICAgICAgICAgICB0aGlzLmxocyA9IGE7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJ1bmFyeVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMRUQgLSBiaW5hcnkgaW5maXggZm9ybVxuICAgICAgICAgICAgICAgIHRoaXMubGhzID0gbGVmdDtcbiAgICAgICAgICAgICAgICB0aGlzLnJocyA9IGE7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ2JpbmFyeSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0b3JcbiAgICAgICAgcHJlZml4KFwie1wiLCBvYmplY3RQYXJzZXIpO1xuXG4gICAgICAgIC8vIG9iamVjdCBncm91cGluZ1xuICAgICAgICBpbmZpeChcIntcIiwgb3BlcmF0b3JzWyd7J10sIG9iamVjdFBhcnNlcik7XG5cbiAgICAgICAgLy8gaWYvdGhlbi9lbHNlIHRlcm5hcnkgb3BlcmF0b3IgPzpcbiAgICAgICAgaW5maXgoXCI/XCIsIG9wZXJhdG9yc1snPyddLCBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ2NvbmRpdGlvbic7XG4gICAgICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnRoZW4gPSBleHByZXNzaW9uKDApO1xuICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgIC8vIGVsc2UgY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgYWR2YW5jZShcIjpcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5lbHNlID0gZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBvYmplY3QgdHJhbnNmb3JtZXJcbiAgICAgICAgcHJlZml4KFwifFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAndHJhbnNmb3JtJztcbiAgICAgICAgICAgIHRoaXMucGF0dGVybiA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICBhZHZhbmNlKCd8Jyk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICBpZihub2RlLmlkID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlKCcsJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGUgPSBleHByZXNzaW9uKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZSgnfCcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRhaWwgY2FsbCBvcHRpbWl6YXRpb25cbiAgICAgICAgLy8gdGhpcyBpcyBpbnZva2VkIGJ5IHRoZSBwb3N0IHBhcnNlciB0byBhbmFseXNlIGxhbWJkYSBmdW5jdGlvbnMgdG8gc2VlXG4gICAgICAgIC8vIGlmIHRoZXkgbWFrZSBhIHRhaWwgY2FsbC4gIElmIHNvLCBpdCBpcyByZXBsYWNlZCBieSBhIHRodW5rIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgaW52b2tlZCBieSB0aGUgdHJhbXBvbGluZSBsb29wIGR1cmluZyBmdW5jdGlvbiBhcHBsaWNhdGlvbi5cbiAgICAgICAgLy8gVGhpcyBlbmFibGVzIHRhaWwtcmVjdXJzaXZlIGZ1bmN0aW9ucyB0byBiZSB3cml0dGVuIHdpdGhvdXQgZ3Jvd2luZyB0aGUgc3RhY2tcbiAgICAgICAgdmFyIHRhaWxfY2FsbF9vcHRpbWl6ZSA9IGZ1bmN0aW9uKGV4cHIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZihleHByLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGh1bmsgPSB7dHlwZTogJ2xhbWJkYScsIHRodW5rOiB0cnVlLCBhcmd1bWVudHM6IFtdLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgdGh1bmsuYm9keSA9IGV4cHI7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGh1bms7XG4gICAgICAgICAgICB9IGVsc2UgaWYoZXhwci50eXBlID09PSAnY29uZGl0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIGFuYWx5c2UgYm90aCBicmFuY2hlc1xuICAgICAgICAgICAgICAgIGV4cHIudGhlbiA9IHRhaWxfY2FsbF9vcHRpbWl6ZShleHByLnRoZW4pO1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBleHByLmVsc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cHIuZWxzZSA9IHRhaWxfY2FsbF9vcHRpbWl6ZShleHByLmVsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBleHByO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGV4cHIudHlwZSA9PT0gJ2Jsb2NrJykge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgdGhlIGxhc3QgZXhwcmVzc2lvbiBpbiB0aGUgYmxvY2tcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gZXhwci5leHByZXNzaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBleHByLmV4cHJlc3Npb25zW2xlbmd0aCAtIDFdID0gdGFpbF9jYWxsX29wdGltaXplKGV4cHIuZXhwcmVzc2lvbnNbbGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBleHByO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBleHByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBwb3N0LXBhcnNlIHN0YWdlXG4gICAgICAgIC8vIHRoZSBwdXJwb3NlIG9mIHRoaXMgaXMgZmxhdHRlbiB0aGUgcGFydHMgb2YgdGhlIEFTVCByZXByZXNlbnRpbmcgbG9jYXRpb24gcGF0aHMsXG4gICAgICAgIC8vIGNvbnZlcnRpbmcgdGhlbSB0byBhcnJheXMgb2Ygc3RlcHMgd2hpY2ggaW4gdHVybiBtYXkgY29udGFpbiBhcnJheXMgb2YgcHJlZGljYXRlcy5cbiAgICAgICAgLy8gZm9sbG93aW5nIHRoaXMsIG5vZGVzIGNvbnRhaW5pbmcgJy4nIGFuZCAnWycgc2hvdWxkIGJlIGVsaW1pbmF0ZWQgZnJvbSB0aGUgQVNULlxuICAgICAgICB2YXIgYXN0X29wdGltaXplID0gZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXhwci52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxzdGVwID0gYXN0X29wdGltaXplKGV4cHIubGhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogJ3BhdGgnLCBzdGVwczogW119O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsc3RlcC50eXBlID09PSAncGF0aCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocmVzdWx0LnN0ZXBzLCBsc3RlcC5zdGVwcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0ZXBzID0gW2xzdGVwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3QgPSBhc3Rfb3B0aW1pemUoZXhwci5yaHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3QudHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdC5wcm9jZWR1cmUudHlwZSA9PT0gJ3BhdGgnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0LnByb2NlZHVyZS5zdGVwcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3QucHJvY2VkdXJlLnN0ZXBzWzBdLnR5cGUgPT09ICduYW1lJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0ZXBzW3Jlc3VsdC5zdGVwcy5sZW5ndGgtMV0udHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGZ1bmN0aW9uIGluIGNoYWluIG9mIGZ1bmN0aW9ucyAtIHdpbGwgb3ZlcnJpZGUgYSB0aGVuYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RlcHNbcmVzdWx0LnN0ZXBzLmxlbmd0aC0xXS5uZXh0RnVuY3Rpb24gPSByZXN0LnByb2NlZHVyZS5zdGVwc1swXS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzdC50eXBlICE9PSAncGF0aCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdCA9IHt0eXBlOiAncGF0aCcsIHN0ZXBzOiBbcmVzdF19O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShyZXN1bHQuc3RlcHMsIHJlc3Quc3RlcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFueSBzdGVwcyB3aXRoaW4gYSBwYXRoIHRoYXQgYXJlIGxpdGVyYWxzLCBzaG91bGQgYmUgY2hhbmdlZCB0byAnbmFtZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RlcHMuZmlsdGVyKGZ1bmN0aW9uKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0ZXAudHlwZSA9PT0gJ2xpdGVyYWwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24obGl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpdC50eXBlID0gJ25hbWUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFueSBzdGVwIHRoYXQgc2lnbmFscyBrZWVwaW5nIGEgc2luZ2xldG9uIGFycmF5LCBzaG91bGQgYmUgZmxhZ2dlZCBvbiB0aGUgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdC5zdGVwcy5maWx0ZXIoZnVuY3Rpb24oc3RlcCkgeyByZXR1cm4gc3RlcC5rZWVwQXJyYXkgPT09IHRydWU7fSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQua2VlcFNpbmdsZXRvbkFycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgZmlyc3Qgc3RlcCBpcyBhIHBhdGggY29uc3RydWN0b3IsIGZsYWcgaXQgZm9yIHNwZWNpYWwgaGFuZGxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQuc3RlcHNbMF0udHlwZSA9PT0gJ3VuYXJ5JyAmJiByZXN1bHQuc3RlcHNbMF0udmFsdWUgPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RlcHNbMF0uY29uc2FycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmVkaWNhdGVkIHN0ZXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMSFMgaXMgYSBzdGVwIG9yIGEgcHJlZGljYXRlZCBzdGVwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUkhTIGlzIHRoZSBwcmVkaWNhdGUgZXhwclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFzdF9vcHRpbWl6ZShleHByLmxocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ZXAgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0LnR5cGUgPT09ICdwYXRoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwID0gcmVzdWx0LnN0ZXBzW3Jlc3VsdC5zdGVwcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGVwLmdyb3VwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMjA5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RlcC5wcmVkaWNhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXAucHJlZGljYXRlID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXAucHJlZGljYXRlLnB1c2goYXN0X29wdGltaXplKGV4cHIucmhzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBncm91cC1ieVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExIUyBpcyBhIHN0ZXAgb3IgYSBwcmVkaWNhdGVkIHN0ZXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSSFMgaXMgdGhlIG9iamVjdCBjb25zdHJ1Y3RvciBleHByXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYXN0X29wdGltaXplKGV4cHIubGhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdC5ncm91cCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDIxMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0b3IgLSBwcm9jZXNzIGVhY2ggcGFpclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ncm91cCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGhzOiBleHByLnJocy5tYXAoZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbYXN0X29wdGltaXplKHBhaXJbMF0pLCBhc3Rfb3B0aW1pemUocGFpclsxXSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3JkZXItYnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMSFMgaXMgdGhlIGFycmF5IHRvIGJlIG9yZGVyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSSFMgZGVmaW5lcyB0aGUgdGVybXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogJ3NvcnQnLCB2YWx1ZTogZXhwci52YWx1ZSwgcG9zaXRpb246IGV4cHIucG9zaXRpb259O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5saHMgPSBhc3Rfb3B0aW1pemUoZXhwci5saHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yaHMgPSBleHByLnJocy5tYXAoZnVuY3Rpb24gKHRlcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjZW5kaW5nOiB0ZXJtcy5kZXNjZW5kaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogYXN0X29wdGltaXplKHRlcm1zLmV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc6PSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6ICdiaW5kJywgdmFsdWU6IGV4cHIudmFsdWUsIHBvc2l0aW9uOiBleHByLnBvc2l0aW9ufTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubGhzID0gYXN0X29wdGltaXplKGV4cHIubGhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmhzID0gYXN0X29wdGltaXplKGV4cHIucmhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ34+JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogJ2FwcGx5JywgdmFsdWU6IGV4cHIudmFsdWUsIHBvc2l0aW9uOiBleHByLnBvc2l0aW9ufTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubGhzID0gYXN0X29wdGltaXplKGV4cHIubGhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmhzID0gYXN0X29wdGltaXplKGV4cHIucmhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6IGV4cHIudHlwZSwgdmFsdWU6IGV4cHIudmFsdWUsIHBvc2l0aW9uOiBleHByLnBvc2l0aW9ufTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubGhzID0gYXN0X29wdGltaXplKGV4cHIubGhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmhzID0gYXN0X29wdGltaXplKGV4cHIucmhzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd1bmFyeSc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt0eXBlOiBleHByLnR5cGUsIHZhbHVlOiBleHByLnZhbHVlLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByLnZhbHVlID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IGNvbnN0cnVjdG9yIC0gcHJvY2VzcyBlYWNoIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5leHByZXNzaW9ucyA9IGV4cHIuZXhwcmVzc2lvbnMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzdF9vcHRpbWl6ZShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIudmFsdWUgPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdG9yIC0gcHJvY2VzcyBlYWNoIHBhaXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5saHMgPSBleHByLmxocy5tYXAoZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2FzdF9vcHRpbWl6ZShwYWlyWzBdKSwgYXN0X29wdGltaXplKHBhaXJbMV0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIG90aGVyIHVuYXJ5IGV4cHJlc3Npb25zIC0ganVzdCBwcm9jZXNzIHRoZSBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXhwcmVzc2lvbiA9IGFzdF9vcHRpbWl6ZShleHByLmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdW5hcnkgbWludXMgb24gYSBudW1iZXIsIHRoZW4gcHJlLXByb2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByLnZhbHVlID09PSAnLScgJiYgcmVzdWx0LmV4cHJlc3Npb24udHlwZSA9PT0gJ2xpdGVyYWwnICYmIGlzTnVtZXJpYyhyZXN1bHQuZXhwcmVzc2lvbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSAtcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICBjYXNlICdwYXJ0aWFsJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6IGV4cHIudHlwZSwgbmFtZTogZXhwci5uYW1lLCB2YWx1ZTogZXhwci52YWx1ZSwgcG9zaXRpb246IGV4cHIucG9zaXRpb259O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXJndW1lbnRzID0gZXhwci5hcmd1bWVudHMubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhc3Rfb3B0aW1pemUoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wcm9jZWR1cmUgPSBhc3Rfb3B0aW1pemUoZXhwci5wcm9jZWR1cmUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdsYW1iZGEnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogZXhwci50eXBlLCBhcmd1bWVudHM6IGV4cHIuYXJndW1lbnRzLCBzaWduYXR1cmU6IGV4cHIuc2lnbmF0dXJlLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gYXN0X29wdGltaXplKGV4cHIuYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ib2R5ID0gdGFpbF9jYWxsX29wdGltaXplKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb25kaXRpb24nOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogZXhwci50eXBlLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb25kaXRpb24gPSBhc3Rfb3B0aW1pemUoZXhwci5jb25kaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQudGhlbiA9IGFzdF9vcHRpbWl6ZShleHByLnRoZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cHIuZWxzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lbHNlID0gYXN0X29wdGltaXplKGV4cHIuZWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndHJhbnNmb3JtJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6IGV4cHIudHlwZSwgcG9zaXRpb246IGV4cHIucG9zaXRpb259O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucGF0dGVybiA9IGFzdF9vcHRpbWl6ZShleHByLnBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQudXBkYXRlID0gYXN0X29wdGltaXplKGV4cHIudXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGV4cHIuZGVsZXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRlbGV0ZSA9IGFzdF9vcHRpbWl6ZShleHByLmRlbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYmxvY2snOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogZXhwci50eXBlLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IG9mIGV4cHJlc3Npb25zIC0gcHJvY2VzcyBlYWNoIG9uZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXhwcmVzc2lvbnMgPSBleHByLmV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzdF9vcHRpbWl6ZShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gc2NhbiB0aGUgYXJyYXkgb2YgZXhwcmVzc2lvbnMgdG8gc2VlIGlmIGFueSBvZiB0aGVtIGFzc2lnbiB2YXJpYWJsZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgc28sIG5lZWQgdG8gbWFyayB0aGUgYmxvY2sgYXMgb25lIHRoYXQgbmVlZHMgdG8gY3JlYXRlIGEgbmV3IGZyYW1lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogJ3BhdGgnLCBzdGVwczogW2V4cHJdfTtcbiAgICAgICAgICAgICAgICAgICAgaWYoZXhwci5rZWVwQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5rZWVwU2luZ2xldG9uQXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xpdGVyYWwnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3dpbGRjYXJkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkZXNjZW5kYW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICd2YXJpYWJsZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAncmVnZXgnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBleHByO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdvcGVyYXRvcic6XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB0b2tlbnMgJ2FuZCcgYW5kICdvcicgbWlnaHQgaGF2ZSBiZWVuIHVzZWQgYXMgYSBuYW1lIHJhdGhlciB0aGFuIGFuIG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByLnZhbHVlID09PSAnYW5kJyB8fCBleHByLnZhbHVlID09PSAnb3InIHx8IGV4cHIudmFsdWUgPT09ICdpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIudHlwZSA9ICduYW1lJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFzdF9vcHRpbWl6ZShleHByKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovIGlmIChleHByLnZhbHVlID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcnRpYWwgYXBwbGljYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV4cHI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDIwMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBleHByLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZXhwcjtcbiAgICAgICAgICAgICAgICAgICAgaWYoZXhwci5saHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFzdF9vcHRpbWl6ZShleHByLmxocyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBcIlMwMjA2XCI7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByLmlkID09PSAnKGVuZCknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gXCJTMDIwN1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogZXhwci52YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZihyZWNvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBlcnJvcjogZXJyfTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbm93IGludm9rZSB0aGUgdG9rZW5pemVyIGFuZCB0aGUgcGFyc2VyIGFuZCByZXR1cm4gdGhlIHN5bnRheCB0cmVlXG4gICAgICAgIGxleGVyID0gdG9rZW5pemVyKHNvdXJjZSk7XG4gICAgICAgIGFkdmFuY2UoKTtcbiAgICAgICAgLy8gcGFyc2UgdGhlIHRva2Vuc1xuICAgICAgICB2YXIgZXhwciA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgIGlmIChub2RlLmlkICE9PSAnKGVuZCknKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAyMDFcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogbm9kZS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICB0b2tlbjogbm9kZS52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZXhwciA9IGFzdF9vcHRpbWl6ZShleHByKTtcblxuICAgICAgICBpZihlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZXhwci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9O1xuXG4gICAgLy8gU3RhcnQgb2YgRXZhbHVhdG9yIGNvZGVcblxuICAgIHZhciBzdGF0aWNGcmFtZSA9IGNyZWF0ZUZyYW1lKG51bGwpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdmFsdWUgaXMgYSBmaW5pdGUgbnVtYmVyXG4gICAgICogQHBhcmFtIHtmbG9hdH0gbiAtIG51bWJlciB0byBldmFsdWF0ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG4gaXMgYSBmaW5pdGUgbnVtYmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgICAgICAgdmFyIGlzTnVtID0gZmFsc2U7XG4gICAgICAgIGlmKHR5cGVvZiBuID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFyIG51bSA9IHBhcnNlRmxvYXQobik7XG4gICAgICAgICAgICBpc051bSA9ICFpc05hTihudW0pO1xuICAgICAgICAgICAgaWYgKGlzTnVtICYmICFpc0Zpbml0ZShudW0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkQxMDAxXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFja1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTnVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXJnIGlzIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgKiBAcGFyYW0geyp9IGFyZyAtIHRoZSBpdGVtIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBhcmcgaXMgYW4gYXJyYXkgb2Ygc3RyaW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlPZlN0cmluZ3MoYXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAoYXJnLmZpbHRlcihmdW5jdGlvbihpdGVtKXtyZXR1cm4gdHlwZW9mIGl0ZW0gIT09ICdzdHJpbmcnO30pLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFyZyBpcyBhbiBhcnJheSBvZiBudW1iZXJzXG4gICAgICogQHBhcmFtIHsqfSBhcmcgLSB0aGUgaXRlbSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYXJnIGlzIGFuIGFycmF5IG9mIG51bWJlcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5T2ZOdW1iZXJzKGFyZykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gKGFyZy5maWx0ZXIoZnVuY3Rpb24oaXRlbSl7cmV0dXJuICFpc051bWVyaWMoaXRlbSk7fSkubGVuZ3RoID09PSAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFBvbHlmaWxsXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBOdW1iZXIuaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmXG4gICAgICAgICAgaXNGaW5pdGUodmFsdWUpICYmXG4gICAgICAgICAgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBleHByZXNzaW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGUoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgdmFyIGVudHJ5Q2FsbGJhY2sgPSBlbnZpcm9ubWVudC5sb29rdXAoJ19fZXZhbHVhdGVfZW50cnknKTtcbiAgICAgICAgaWYoZW50cnlDYWxsYmFjaykge1xuICAgICAgICAgICAgZW50cnlDYWxsYmFjayhleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3BhdGgnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVQYXRoKGV4cHIuc3RlcHMsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbm9ybWFsaXplU2VxdWVuY2UocmVzdWx0LCBleHByLmtlZXBTaW5nbGV0b25BcnJheSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVCaW5hcnkoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3VuYXJ5JzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlVW5hcnkoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlTmFtZShleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGl0ZXJhbCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVMaXRlcmFsKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3aWxkY2FyZCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVXaWxkY2FyZChleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGVzY2VuZGFudCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVEZXNjZW5kYW50cyhleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29uZGl0aW9uJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlQ29uZGl0aW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdibG9jayc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZUJsb2NrKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiaW5kJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlQmluZEV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JlZ2V4JzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZVJlZ2V4KGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZUZ1bmN0aW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd2YXJpYWJsZSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVWYXJpYWJsZShleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGFtYmRhJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZUxhbWJkYShleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncGFydGlhbCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZVBhcnRpYWxBcHBsaWNhdGlvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYXBwbHknOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVBcHBseUV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NvcnQnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVTb3J0RXhwcmVzc2lvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndHJhbnNmb3JtJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZVRyYW5zZm9ybUV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGVudmlyb25tZW50Lmxvb2t1cCgnX19qc29uYXRhX2FzeW5jJykgJiZcbiAgICAgICAgICAodHlwZW9mIHJlc3VsdCA9PT0gJ3VuZGVmaW5lZCcgfHwgcmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQudGhlbiAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGVudmlyb25tZW50Lmxvb2t1cCgnX19qc29uYXRhX2FzeW5jJykgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nICYmIGV4cHIubmV4dEZ1bmN0aW9uICYmIHR5cGVvZiByZXN1bHRbZXhwci5uZXh0RnVuY3Rpb25dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBhbHRob3VnaCB0aGlzIGlzIGEgJ3RoZW5hYmxlJywgaXQgaXMgY2hhaW5pbmcgYSBkaWZmZXJlbnQgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIHNvIGRvbid0IHlpZWxkIHNpbmNlIHlpZWxkaW5nIHdpbGwgdHJpZ2dlciB0aGUgLnRoZW4oKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgcmVzdWx0O1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAoZXhwci5oYXNPd25Qcm9wZXJ0eSgncHJlZGljYXRlJykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogYXBwbHlQcmVkaWNhdGVzKGV4cHIucHJlZGljYXRlLCByZXN1bHQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVNlcXVlbmNlKHJlc3VsdCk7XG5cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwci5oYXNPd25Qcm9wZXJ0eSgnZ3JvdXAnKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZUdyb3VwRXhwcmVzc2lvbihleHByLmdyb3VwLCByZXN1bHQsIGVudmlyb25tZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleGl0Q2FsbGJhY2sgPSBlbnZpcm9ubWVudC5sb29rdXAoJ19fZXZhbHVhdGVfZXhpdCcpO1xuICAgICAgICBpZihleGl0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIGV4aXRDYWxsYmFjayhleHByLCBpbnB1dCwgZW52aXJvbm1lbnQsIHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHBhdGggZXhwcmVzc2lvbiBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlUGF0aChleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIGlucHV0U2VxdWVuY2U7XG4gICAgICAgIC8vIGV4cHIgaXMgYW4gYXJyYXkgb2Ygc3RlcHNcbiAgICAgICAgLy8gaWYgdGhlIGZpcnN0IHN0ZXAgaXMgYSB2YXJpYWJsZSByZWZlcmVuY2UgKCQuLi4pLCBpbmNsdWRpbmcgcm9vdCByZWZlcmVuY2UgKCQkKSxcbiAgICAgICAgLy8gICB0aGVuIHRoZSBwYXRoIGlzIGFic29sdXRlIHJhdGhlciB0aGFuIHJlbGF0aXZlXG4gICAgICAgIGlmIChleHByWzBdLnR5cGUgPT09ICd2YXJpYWJsZScpIHtcbiAgICAgICAgICAgIGlucHV0U2VxdWVuY2UgPSBbaW5wdXRdOyAvLyBkdW1teSBzaW5nbGV0b24gc2VxdWVuY2UgZm9yIGZpcnN0IChhYnNvbHV0ZSkgc3RlcFxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBpbnB1dFNlcXVlbmNlID0gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBpbnB1dCBpcyBub3QgYW4gYXJyYXksIG1ha2UgaXQgc29cbiAgICAgICAgICAgIGlucHV0U2VxdWVuY2UgPSBbaW5wdXRdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdFNlcXVlbmNlO1xuXG4gICAgICAgIC8vIGV2YWx1YXRlIGVhY2ggc3RlcCBpbiB0dXJuXG4gICAgICAgIGZvcih2YXIgaWkgPSAwOyBpaSA8IGV4cHIubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IGV4cHJbaWldO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgZmlyc3Qgc3RlcCBpcyBhbiBleHBsaWNpdCBhcnJheSBjb25zdHJ1Y3RvciwgdGhlbiBqdXN0IGV2YWx1YXRlIHRoYXQgKGkuZS4gZG9uJ3QgaXRlcmF0ZSBvdmVyIGEgY29udGV4dCBhcnJheSlcbiAgICAgICAgICAgIGlmKGlpID09PSAwICYmIHN0ZXAuY29uc2FycmF5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0U2VxdWVuY2UgPSB5aWVsZCAqIGV2YWx1YXRlKHN0ZXAsIGlucHV0U2VxdWVuY2UsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0U2VxdWVuY2UgPSB5aWVsZCAqIGV2YWx1YXRlU3RlcChzdGVwLCBpbnB1dFNlcXVlbmNlLCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHR5cGVvZiByZXN1bHRTZXF1ZW5jZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcmVzdWx0U2VxdWVuY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dFNlcXVlbmNlID0gcmVzdWx0U2VxdWVuY2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0U2VxdWVuY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIGEgSlNPTmF0YSBzZXF1ZW5jZSAtIHNpbmdsZXRvbiBhcnJheXMgYmVjb21lIGF0b21pYyB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzZXF1ZW5jZSAtIGlucHV0IHNlcXVlbmNlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBrZWVwU2luZ2xldG9uIC0ga2VlcCBzaW5nbGV0b24gc2VxdWVuY2VzIGFzIGFycmF5c1xuICAgICAqIEByZXR1cm5zIHsqfSBub3JtYWxpemVkIHNlcXVlbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplU2VxdWVuY2Uoc2VxdWVuY2UsIGtlZXBTaW5nbGV0b24pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYodHlwZW9mIHNlcXVlbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYoIUFycmF5LmlzQXJyYXkoc2VxdWVuY2UpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzZXF1ZW5jZTtcbiAgICAgICAgfSBlbHNlIGlmIChzZXF1ZW5jZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmKGtlZXBTaW5nbGV0b24pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzZXF1ZW5jZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VxdWVuY2VbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2VxdWVuY2UubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc2VxdWVuY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBhIHN0ZXAgd2l0aGluIGEgcGF0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVTdGVwKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cblxuICAgICAgICBmb3IodmFyIGlpID0gMDsgaWkgPCBpbnB1dC5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgIHZhciByZXMgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIsIGlucHV0W2lpXSwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgaWYgKCEoQXJyYXkuaXNBcnJheShyZXMpICYmIChleHByLnZhbHVlICE9PSAnWycgKSkgJiYgIWV4cHIuY29uc2FycmF5KSB7XG4gICAgICAgICAgICAgICAgcmVzID0gW3Jlc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpcyByZXMgYW4gYXJyYXkgLSBpZiBzbywgZmxhdHRlbiBpdCBpbnRvIHRoZSBwYXJlbnQgYXJyYXlcbiAgICAgICAgICAgIHJlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbm5lclJlcykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5uZXJSZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGlubmVyUmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHByZWRpY2F0ZXMgdG8gaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmVkaWNhdGVzIC0gUHJlZGljYXRlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gYXBwbHkgcHJlZGljYXRlcyBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0IGFmdGVyIGFwcGx5aW5nIHByZWRpY2F0ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogYXBwbHlQcmVkaWNhdGVzKHByZWRpY2F0ZXMsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgaW5wdXRTZXF1ZW5jZSA9IGlucHV0O1xuICAgICAgICAvLyBsaHMgcG90ZW50aWFsbHkgaG9sZHMgYW4gYXJyYXlcbiAgICAgICAgLy8gd2Ugd2FudCB0byBpdGVyYXRlIG92ZXIgdGhlIGFycmF5LCBhbmQgb25seSBrZWVwIHRoZSBpdGVtcyB0aGF0IGFyZVxuICAgICAgICAvLyB0cnV0aHkgd2hlbiBhcHBsaWVkIHRvIHRoZSBwcmVkaWNhdGUuXG4gICAgICAgIC8vIGlmIHRoZSBwcmVkaWNhdGUgZXZhbHVhdGVzIHRvIGFuIGludGVnZXIsIHRoZW4gc2VsZWN0IHRoYXQgaW5kZXhcblxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IodmFyIGlpID0gMDsgaWkgPCBwcmVkaWNhdGVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgdmFyIHByZWRpY2F0ZSA9IHByZWRpY2F0ZXNbaWldO1xuICAgICAgICAgICAgLy8gaWYgaXQncyBub3QgYW4gYXJyYXksIHR1cm4gaXQgaW50byBvbmVcbiAgICAgICAgICAgIC8vIHNpbmNlIGluIFhQYXRoID49IDIuMCBhbiBpdGVtIGlzIGVxdWl2YWxlbnQgdG8gYSBzaW5nbGV0b24gc2VxdWVuY2Ugb2YgdGhhdCBpdGVtXG4gICAgICAgICAgICAvLyBpZiBpbnB1dCBpcyBub3QgYW4gYXJyYXksIG1ha2UgaXQgc29cbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dFNlcXVlbmNlKSkge1xuICAgICAgICAgICAgICAgIGlucHV0U2VxdWVuY2UgPSBbaW5wdXRTZXF1ZW5jZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlLnR5cGUgPT09ICdsaXRlcmFsJyAmJiBpc051bWVyaWMocHJlZGljYXRlLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHByZWRpY2F0ZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJvdW5kIGl0IGRvd25cbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb3VudCBpbiBmcm9tIGVuZCBvZiBhcnJheVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGlucHV0U2VxdWVuY2UubGVuZ3RoICsgaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBpbnB1dFNlcXVlbmNlW2luZGV4XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IHlpZWxkICogZXZhbHVhdGVGaWx0ZXIocHJlZGljYXRlLCBpbnB1dFNlcXVlbmNlLCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dFNlcXVlbmNlID0gcmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBmaWx0ZXIgcHJlZGljYXRlIHRvIGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJlZGljYXRlIC0gZmlsdGVyIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGFwcGx5IHByZWRpY2F0ZXMgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IFJlc3VsdCBhZnRlciBhcHBseWluZyBwcmVkaWNhdGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlRmlsdGVyKHByZWRpY2F0ZSwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGZvcih2YXIgaW5kZXggPSAwOyBpbmRleCA8IGlucHV0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpbnB1dFtpbmRleF07XG4gICAgICAgICAgICB2YXIgcmVzID0geWllbGQgKiBldmFsdWF0ZShwcmVkaWNhdGUsIGl0ZW0sIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgIGlmIChpc051bWVyaWMocmVzKSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IFtyZXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoaXNBcnJheU9mTnVtYmVycyhyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzLmZvckVhY2goZnVuY3Rpb24oaXJlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoaXJlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJvdW5kIGl0IGRvd25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlyZXMgPSBNYXRoLmZsb29yKGlyZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpcmVzIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY291bnQgaW4gZnJvbSBlbmQgb2YgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlyZXMgPSBpbnB1dC5sZW5ndGggKyBpcmVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpcmVzID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZ1bmN0aW9uQm9vbGVhbihyZXMpKSB7IC8vIHRydXRoeVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBiaW5hcnkgZXhwcmVzc2lvbiBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gKiBldmFsdWF0ZUJpbmFyeShleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIGxocyA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5saHMsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgIHZhciByaHMgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIucmhzLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICB2YXIgb3AgPSBleHByLnZhbHVlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlTnVtZXJpY0V4cHJlc3Npb24obGhzLCByaHMsIG9wKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlQ29tcGFyaXNvbkV4cHJlc3Npb24obGhzLCByaHMsIG9wKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlU3RyaW5nQ29uY2F0KGxocywgcmhzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYW5kJzpcbiAgICAgICAgICAgICAgICBjYXNlICdvcic6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlQm9vbGVhbkV4cHJlc3Npb24obGhzLCByaHMsIG9wKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnLi4nOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZVJhbmdlRXhwcmVzc2lvbihsaHMsIHJocyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2luJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVJbmNsdWRlc0V4cHJlc3Npb24obGhzLCByaHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIGVyci5wb3NpdGlvbiA9IGV4cHIucG9zaXRpb247XG4gICAgICAgICAgICBlcnIudG9rZW4gPSBvcDtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHVuYXJ5IGV4cHJlc3Npb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBldmFsdWF0ZVVuYXJ5KGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIHN3aXRjaCAoZXhwci52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZShleHByLmV4cHJlc3Npb24sIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtZXJpYyhyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IC1yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJEMTAwMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBleHByLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgICAgIC8vIGFycmF5IGNvbnN0cnVjdG9yIC0gZXZhbHVhdGUgZWFjaCBpdGVtXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpaSA9IDA7IGlpIDwgZXhwci5leHByZXNzaW9ucy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBleHByLmV4cHJlc3Npb25zW2lpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0geWllbGQgKiBldmFsdWF0ZShpdGVtLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS52YWx1ZSA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jdGlvbkFwcGVuZChyZXN1bHQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3RvciAtIGFwcGx5IGdyb3VwaW5nXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZUdyb3VwRXhwcmVzc2lvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBuYW1lIG9iamVjdCBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVOYW1lKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICAvLyBsb29rdXAgdGhlICduYW1lJyBpdGVtIGluIHRoZSBpbnB1dFxuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yKHZhciBpaSA9IDA7IGlpIDwgaW5wdXQubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9ICBldmFsdWF0ZU5hbWUoZXhwciwgaW5wdXRbaWldLCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlucHV0ICE9PSBudWxsICYmIHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0W2V4cHIudmFsdWVdO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVNlcXVlbmNlKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgbGl0ZXJhbCBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlTGl0ZXJhbChleHByKSB7XG4gICAgICAgIHJldHVybiBleHByLnZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHdpbGRjYXJkIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVXaWxkY2FyZChleHByLCBpbnB1dCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAoaW5wdXQgIT09IG51bGwgJiYgdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoaW5wdXQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2tleV07XG4gICAgICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBmbGF0dGVuKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IGZ1bmN0aW9uQXBwZW5kKHJlc3VsdHMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gbm9ybWFsaXplU2VxdWVuY2UocmVzdWx0cyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZsYXR0ZW5lZCBhcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZyAtIHRoZSBhcnJheSB0byBiZSBmbGF0dGVuXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmxhdHRlbmVkIC0gY2FycmllcyB0aGUgZmxhdHRlbmVkIGFycmF5IC0gaWYgbm90IGRlZmluZWQsIHdpbGwgaW5pdGlhbGl6ZSB0byBbXVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gLSB0aGUgZmxhdHRlbmVkIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcmcsIGZsYXR0ZW5lZCkge1xuICAgICAgICBpZih0eXBlb2YgZmxhdHRlbmVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZmxhdHRlbmVkID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICBhcmcuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGZsYXR0ZW4oaXRlbSwgZmxhdHRlbmVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxhdHRlbmVkLnB1c2goYXJnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmxhdHRlbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGRlc2NlbmRhbnRzIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVEZXNjZW5kYW50cyhleHByLCBpbnB1dCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgcmVzdWx0U2VxdWVuY2UgPSBbXTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIHRyYXZlcnNlIGFsbCBkZXNjZW5kYW50cyBvZiB0aGlzIG9iamVjdC9hcnJheVxuICAgICAgICAgICAgcmVjdXJzZURlc2NlbmRhbnRzKGlucHV0LCByZXN1bHRTZXF1ZW5jZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0U2VxdWVuY2UubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0U2VxdWVuY2VbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFNlcXVlbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzZSB0aHJvdWdoIGRlc2NlbmRhbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHRzIC0gUmVzdWx0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlY3Vyc2VEZXNjZW5kYW50cyhpbnB1dCwgcmVzdWx0cykge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIC8vKiBpbiBYUGF0aFxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgaW5wdXQuZm9yRWFjaChmdW5jdGlvbiAobWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgcmVjdXJzZURlc2NlbmRhbnRzKG1lbWJlciwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCAhPT0gbnVsbCAmJiB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhpbnB1dCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmVjdXJzZURlc2NlbmRhbnRzKGlucHV0W2tleV0sIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBudW1lcmljIGV4cHJlc3Npb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxocyAtIExIUyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByaHMgLSBSSFMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3AgLSBvcGNvZGVcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVOdW1lcmljRXhwcmVzc2lvbihsaHMsIHJocywgb3ApIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHJocyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIGlmIGVpdGhlciBzaWRlIGlzIHVuZGVmaW5lZCwgdGhlIHJlc3VsdCBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVtZXJpYyhsaHMpKSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgY29kZTogXCJUMjAwMVwiLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBsaHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc051bWVyaWMocmhzKSkge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMDJcIixcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmhzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGhzICsgcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGhzIC0gcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGhzICogcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGhzIC8gcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGhzICUgcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgY29tcGFyaXNvbiBleHByZXNzaW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsaHMgLSBMSFMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmhzIC0gUkhTIHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wIC0gb3Bjb2RlXG4gICAgICogQHJldHVybnMgeyp9IFJlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlQ29tcGFyaXNvbkV4cHJlc3Npb24obGhzLCByaHMsIG9wKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gdHlwZSBjaGVja3NcbiAgICAgICAgdmFyIGx0eXBlID0gdHlwZW9mIGxocztcbiAgICAgICAgdmFyIHJ0eXBlID0gdHlwZW9mIHJocztcblxuICAgICAgICBpZiAobHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHJ0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gaWYgZWl0aGVyIHNpZGUgaXMgdW5kZWZpbmVkLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGlmIGFhIG9yIGJiIGFyZSBub3Qgc3RyaW5nIG9yIG51bWVyaWMgdmFsdWVzLCB0aGVuIHRocm93IGFuIGVycm9yXG4gICAgICAgICAgICBpZiAoIShsdHlwZSA9PT0gJ3N0cmluZycgfHwgbHR5cGUgPT09ICdudW1iZXInKSB8fCAhKHJ0eXBlID09PSAnc3RyaW5nJyB8fCBydHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQyMDEwXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogIShsdHlwZSA9PT0gJ3N0cmluZycgfHwgbHR5cGUgPT09ICdudW1iZXInKSA/IGxocyA6IHJoc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vaWYgYWEgYW5kIGJiIGFyZSBub3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgICAgICAgaWYgKGx0eXBlICE9PSBydHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJUMjAwOVwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxocyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUyOiByaHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyA9PT0gcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChsaHMgIT09IHJocyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyA8IHJocztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyA8PSByaHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyA+IHJocztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyA+PSByaHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmNsdXNpb24gb3BlcmF0b3IgLSBpblxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxocyAtIExIUyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByaHMgLSBSSFMgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIGxocyBpcyBhIG1lbWJlciBvZiByaHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmFsdWF0ZUluY2x1ZGVzRXhwcmVzc2lvbihsaHMsIHJocykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiByaHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBpZiBlaXRoZXIgc2lkZSBpcyB1bmRlZmluZWQsIHRoZSByZXN1bHQgaXMgZmFsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFBcnJheS5pc0FycmF5KHJocykpIHtcbiAgICAgICAgICAgIHJocyA9IFtyaHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHJocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYocmhzW2ldID09PSBsaHMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBib29sZWFuIGV4cHJlc3Npb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxocyAtIExIUyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByaHMgLSBSSFMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3AgLSBvcGNvZGVcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVCb29sZWFuRXhwcmVzc2lvbihsaHMsIHJocywgb3ApIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgICAgICBjYXNlICdhbmQnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uQm9vbGVhbihsaHMpICYmIGZ1bmN0aW9uQm9vbGVhbihyaHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnb3InOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uQm9vbGVhbihsaHMpIHx8IGZ1bmN0aW9uQm9vbGVhbihyaHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgc3RyaW5nIGNvbmNhdGVuYXRpb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxocyAtIExIUyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByaHMgLSBSSFMgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCp9IENvbmNhdGVuYXRlZCBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmFsdWF0ZVN0cmluZ0NvbmNhdChsaHMsIHJocykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIHZhciBsc3RyID0gJyc7XG4gICAgICAgIHZhciByc3RyID0gJyc7XG4gICAgICAgIGlmICh0eXBlb2YgbGhzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbHN0ciA9IGZ1bmN0aW9uU3RyaW5nKGxocyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByaHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByc3RyID0gZnVuY3Rpb25TdHJpbmcocmhzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IGxzdHIuY29uY2F0KHJzdHIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGdyb3VwIGV4cHJlc3Npb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHt7fX0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVHcm91cEV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgdmFyIGdyb3VwcyA9IHt9O1xuICAgICAgICAvLyBncm91cCB0aGUgaW5wdXQgc2VxdWVuY2UgYnkgJ2tleScgZXhwcmVzc2lvblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBpbnB1dCA9IFtpbnB1dF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBpdGVtSW5kZXggPSAwOyBpdGVtSW5kZXggPCBpbnB1dC5sZW5ndGg7IGl0ZW1JbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGlucHV0W2l0ZW1JbmRleF07XG4gICAgICAgICAgICBmb3IodmFyIHBhaXJJbmRleCA9IDA7IHBhaXJJbmRleCA8IGV4cHIubGhzLmxlbmd0aDsgcGFpckluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFpciA9IGV4cHIubGhzW3BhaXJJbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHlpZWxkICogZXZhbHVhdGUocGFpclswXSwgaXRlbSwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIC8vIGtleSBoYXMgdG8gYmUgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDEwMDNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToga2V5XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHtkYXRhOiBpdGVtLCBleHByOiBwYWlyWzFdfTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYSB2YWx1ZSBhbHJlYWR5IGV4aXN0cyBpbiB0aGlzIHNsb3RcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwZW5kIGl0IGFzIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwc1trZXldLmRhdGEgPSBmdW5jdGlvbkFwcGVuZChncm91cHNba2V5XS5kYXRhLCBpdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncm91cHNba2V5XSA9IGVudHJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGl0ZXJhdGUgb3ZlciB0aGUgZ3JvdXBzIHRvIGV2YWx1YXRlIHRoZSAndmFsdWUnIGV4cHJlc3Npb25cbiAgICAgICAgZm9yIChrZXkgaW4gZ3JvdXBzKSB7XG4gICAgICAgICAgICBlbnRyeSA9IGdyb3Vwc1trZXldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0geWllbGQgKiBldmFsdWF0ZShlbnRyeS5leHByLCBlbnRyeS5kYXRhLCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICBpZih0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgcmFuZ2UgZXhwcmVzc2lvbiBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGhzIC0gTEhTIHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJocyAtIFJIUyB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmVzdWx0YW50IGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVSYW5nZUV4cHJlc3Npb24obGhzLCByaHMpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHJocyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIGlmIGVpdGhlciBzaWRlIGlzIHVuZGVmaW5lZCwgdGhlIHJlc3VsdCBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGhzID4gcmhzKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgbGhzIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcmhzLCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxocykpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlQyMDAzXCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxoc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIocmhzKSkge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMDRcIixcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmhzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KHJocyAtIGxocyArIDEpO1xuICAgICAgICBmb3IgKHZhciBpdGVtID0gbGhzLCBpbmRleCA9IDA7IGl0ZW0gPD0gcmhzOyBpdGVtKyssIGluZGV4KyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgYmluZCBleHByZXNzaW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVCaW5kRXhwcmVzc2lvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgLy8gVGhlIFJIUyBpcyB0aGUgZXhwcmVzc2lvbiB0byBldmFsdWF0ZVxuICAgICAgICAvLyBUaGUgTEhTIGlzIHRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSB0byBiaW5kIHRvIC0gc2hvdWxkIGJlIGEgVkFSSUFCTEUgdG9rZW5cbiAgICAgICAgdmFyIHZhbHVlID0geWllbGQgKiBldmFsdWF0ZShleHByLnJocywgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgaWYgKGV4cHIubGhzLnR5cGUgIT09ICd2YXJpYWJsZScpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQyMDA1XCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgdG9rZW46IGV4cHIudmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV4cHIubGhzLnR5cGUgPT09ICdwYXRoJyA/IGV4cHIubGhzLnN0ZXBzWzBdLnZhbHVlIDogZXhwci5saHMudmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZW52aXJvbm1lbnQuYmluZChleHByLmxocy52YWx1ZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgY29uZGl0aW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVDb25kaXRpb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBjb25kaXRpb24gPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIuY29uZGl0aW9uLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICBpZiAoZnVuY3Rpb25Cb29sZWFuKGNvbmRpdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGUoZXhwci50aGVuLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHByLmVsc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIuZWxzZSwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGJsb2NrIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVCbG9jayhleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgLy8gY3JlYXRlIGEgbmV3IGZyYW1lIHRvIGxpbWl0IHRoZSBzY29wZSBvZiB2YXJpYWJsZSBhc3NpZ25tZW50c1xuICAgICAgICAvLyBUT0RPLCBvbmx5IGRvIHRoaXMgaWYgdGhlIHBvc3QtcGFyc2Ugc3RhZ2UgaGFzIGZsYWdnZWQgdGhpcyBhcyByZXF1aXJlZFxuICAgICAgICB2YXIgZnJhbWUgPSBjcmVhdGVGcmFtZShlbnZpcm9ubWVudCk7XG4gICAgICAgIC8vIGludm9rZSBlYWNoIGV4cHJlc3Npb24gaW4gdHVyblxuICAgICAgICAvLyBvbmx5IHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IG9uZVxuICAgICAgICBmb3IodmFyIGlpID0gMDsgaWkgPCBleHByLmV4cHJlc3Npb25zLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZShleHByLmV4cHJlc3Npb25zW2lpXSwgaW5wdXQsIGZyYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSBhIHJlZ2V4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBleHByZXNzaW9uIGNvbnRhaW5pbmcgcmVnZXhcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEhpZ2hlciBvcmRlciBmdW5jdGlvbiByZXByZXNlbnRpbmcgcHJlcGFyZWQgcmVnZXhcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmFsdWF0ZVJlZ2V4KGV4cHIpIHtcbiAgICAgICAgZXhwci52YWx1ZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgY2xvc3VyZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdmFyIHJlID0gZXhwci52YWx1ZTtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSByZS5leGVjKHN0cik7XG4gICAgICAgICAgICBpZihtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2g6IG1hdGNoWzBdLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogbWF0Y2guaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwczogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmKG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IG1hdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZ3JvdXBzLnB1c2gobWF0Y2hbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHJlLmxhc3RJbmRleCA+PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBjbG9zdXJlKHN0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihuZXh0ICYmIG5leHQubWF0Y2ggPT09ICcnICYmIHJlLmxhc3RJbmRleCA9PT0gZXhwci52YWx1ZS5sYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaGVzIHplcm8gbGVuZ3RoIHN0cmluZzsgdGhpcyB3aWxsIG5ldmVyIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkQxMDA0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGV4cHIudmFsdWUuc291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNsb3N1cmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgdmFyaWFibGUgYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlVmFyaWFibGUoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIC8vIGxvb2t1cCB0aGUgdmFyaWFibGUgdmFsdWUgaW4gdGhlIGVudmlyb25tZW50XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIC8vIGlmIHRoZSB2YXJpYWJsZSBuYW1lIGlzIGVtcHR5IHN0cmluZywgdGhlbiBpdCByZWZlcnMgdG8gY29udGV4dCB2YWx1ZVxuICAgICAgICBpZiAoZXhwci52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gZW52aXJvbm1lbnQubG9va3VwKGV4cHIudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc29ydCAvIG9yZGVyLWJ5IG9wZXJhdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBBU1QgZm9yIG9wZXJhdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gT3JkZXJlZCBzZXF1ZW5jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBldmFsdWF0ZVNvcnRFeHByZXNzaW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIGV2YWx1YXRlIHRoZSBsaHMsIHRoZW4gc29ydCB0aGUgcmVzdWx0cyBpbiBvcmRlciBhY2NvcmRpbmcgdG8gcmhzIGV4cHJlc3Npb25cbiAgICAgICAgdmFyIGxocyA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5saHMsIGlucHV0LCBlbnZpcm9ubWVudCk7XG5cbiAgICAgICAgLy8gc29ydCB0aGUgbGhzIGFycmF5XG4gICAgICAgIC8vIHVzZSBjb21wYXJhdG9yIGZ1bmN0aW9uXG4gICAgICAgIHZhciBjb21wYXJhdG9yID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgLy8gZXhwci5yaHMgaXMgYW4gYXJyYXkgb2Ygb3JkZXItYnkgaW4gcHJpb3JpdHkgb3JkZXJcbiAgICAgICAgICAgIHZhciBjb21wID0gMDtcbiAgICAgICAgICAgIGZvcih2YXIgaW5kZXggPSAwOyBjb21wID09PSAwICYmIGluZGV4IDwgZXhwci5yaHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlcm0gPSBleHByLnJoc1tpbmRleF07XG4gICAgICAgICAgICAgICAgLy9ldmFsdWF0ZSB0aGUgcmhzIGV4cHJlc3Npb24gaW4gdGhlIGNvbnRleHQgb2YgYVxuICAgICAgICAgICAgICAgIHZhciBhYSA9IGRyaXZlR2VuZXJhdG9yKHRlcm0uZXhwcmVzc2lvbiwgYSwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIC8vZXZhbHVhdGUgdGhlIHJocyBleHByZXNzaW9uIGluIHRoZSBjb250ZXh0IG9mIGJcbiAgICAgICAgICAgICAgICB2YXIgYmIgPSBkcml2ZUdlbmVyYXRvcih0ZXJtLmV4cHJlc3Npb24sIGIsIGVudmlyb25tZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIHR5cGUgY2hlY2tzXG4gICAgICAgICAgICAgICAgdmFyIGF0eXBlID0gdHlwZW9mIGFhO1xuICAgICAgICAgICAgICAgIHZhciBidHlwZSA9IHR5cGVvZiBiYjtcbiAgICAgICAgICAgICAgICAvLyB1bmRlZmluZWQgc2hvdWxkIGJlIGxhc3QgaW4gc29ydCBvcmRlclxuICAgICAgICAgICAgICAgIGlmKGF0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBzd2FwIHRoZW0sIHVubGVzcyBidHlwZSBpcyBhbHNvIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICBjb21wID0gKGJ0eXBlID09PSAndW5kZWZpbmVkJykgPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGJ0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIGFhIG9yIGJiIGFyZSBub3Qgc3RyaW5nIG9yIG51bWVyaWMgdmFsdWVzLCB0aGVuIHRocm93IGFuIGVycm9yXG4gICAgICAgICAgICAgICAgaWYoIShhdHlwZSA9PT0gJ3N0cmluZycgfHwgYXR5cGUgPT09ICdudW1iZXInKSB8fCAhKGJ0eXBlID09PSAnc3RyaW5nJyB8fCBidHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMDhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogIShhdHlwZSA9PT0gJ3N0cmluZycgfHwgYXR5cGUgPT09ICdudW1iZXInKSA/IGFhIDogYmJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2lmIGFhIGFuZCBiYiBhcmUgbm90IG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgICAgICAgICAgICBpZihhdHlwZSAhPT0gYnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJUMjAwN1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlMjogYmJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoYWEgPT09IGJiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJvdGggdGhlIHNhbWUgLSBtb3ZlIG9uIHRvIG5leHQgdGVybVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFhIDwgYmIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcCA9IC0xO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXAgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZih0ZXJtLmRlc2NlbmRpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcCA9IC1jb21wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9ubHkgc3dhcCBhICYgYiBpZiBjb21wIGVxdWFscyAxXG4gICAgICAgICAgICByZXR1cm4gY29tcCA9PT0gMTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXN1bHQgPSBmdW5jdGlvblNvcnQobGhzLCBjb21wYXJhdG9yKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIHRyYW5zZm9ybWVyIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBBU1QgZm9yIG9wZXJhdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gdHJhbmZvcm1lciBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlVHJhbnNmb3JtRXhwcmVzc2lvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgZnVuY3Rpb24gdG8gaW1wbGVtZW50IHRoZSB0cmFuc2Zvcm0gZGVmaW5pdGlvblxuICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSBmdW5jdGlvbioob2JqKSB7IC8vIHNpZ25hdHVyZSA8KG9hKTpvPlxuICAgICAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSBjb3B5IG9mIG9iaiB3aXRoIGNoYW5nZXMgc3BlY2lmaWVkIGJ5IHRoZSBwYXR0ZXJuL29wZXJhdGlvblxuICAgICAgICAgICAgdmFyIGNsb25lRnVuY3Rpb24gPSBlbnZpcm9ubWVudC5sb29rdXAoJ2Nsb25lJyk7XG4gICAgICAgICAgICBpZighaXNGdW5jdGlvbihjbG9uZUZ1bmN0aW9uKSkge1xuICAgICAgICAgICAgICAgIC8vIHRocm93IHR5cGUgZXJyb3JcbiAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMTNcIixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB5aWVsZCAqIGFwcGx5KGNsb25lRnVuY3Rpb24sIFtvYmpdLCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5wYXR0ZXJuLCByZXN1bHQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBtYXRjaGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGlmKCFBcnJheS5pc0FycmF5KG1hdGNoZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBbbWF0Y2hlc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcih2YXIgaWkgPSAwOyBpaSA8IG1hdGNoZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IG1hdGNoZXNbaWldO1xuICAgICAgICAgICAgICAgICAgICAvLyBldmFsdWF0ZSB0aGUgdXBkYXRlIHZhbHVlIGZvciBlYWNoIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGUgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIudXBkYXRlLCBtYXRjaCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgbXVzdCBiZSBhbiBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVR5cGUgPSB0eXBlb2YgdXBkYXRlO1xuICAgICAgICAgICAgICAgICAgICBpZih1cGRhdGVUeXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodXBkYXRlVHlwZSAhPT0gJ29iamVjdCcgfHwgdXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgdHlwZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJUMjAxMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIudXBkYXRlLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lcmdlIHRoZSB1cGRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgcHJvcCBpbiB1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtwcm9wXSA9IHVwZGF0ZVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSwgaWYgc3BlY2lmaWVkLCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ3MgKG9yIHNpbmdsZSBzdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBleHByLmRlbGV0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGlvbnMgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIuZGVsZXRlLCBtYXRjaCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGRlbGV0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gZGVsZXRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkZWxldGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0aW9ucyA9IFtkZWxldGlvbnNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXlPZlN0cmluZ3MoZGVsZXRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyB0eXBlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMTJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIuZGVsZXRlLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqaiA9IDA7IGpqIDwgZGVsZXRpb25zLmxlbmd0aDsgamorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWF0Y2hbZGVsZXRpb25zW2pqXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBkZWZpbmVGdW5jdGlvbih0cmFuc2Zvcm1lciwgJzwob2EpOm8+Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgYW4gZXhwcmVzc2lvbiBieSBkcml2aW5nIHRoZSBnZW5lcmF0b3IgdG8gY29tcGxldGlvblxuICAgICAqIFVzZWQgd2hlbiBpdCdzIG5vdCBwb3NzaWJsZSB0byB5aWVsZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gQVNUXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gcmVzdWx0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJpdmVHZW5lcmF0b3IoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciBnZW4gPSBldmFsdWF0ZShleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAvLyByZXR1cm5zIGEgZ2VuZXJhdG9yIC0gc28gaXRlcmF0ZSBvdmVyIGl0XG4gICAgICAgIHZhciBjb21wID0gZ2VuLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFjb21wLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbXAgPSBnZW4ubmV4dChjb21wLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcC52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgY2hhaW4gPSBkcml2ZUdlbmVyYXRvcihwYXJzZXIoJ2Z1bmN0aW9uKCRmLCAkZykgeyBmdW5jdGlvbigkeCl7ICRnKCRmKCR4KSkgfSB9JyksIG51bGwsIHN0YXRpY0ZyYW1lKTtcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBmdW5jdGlvbiBvbiB0aGUgUkhTIHVzaW5nIHRoZSBzZXF1ZW5jZSBvbiB0aGUgTEhTIGFzIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVBcHBseUV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cblxuICAgICAgICBpZihleHByLnJocy50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgZnVuY3Rpb24gX2ludm9jYXRpb25fOyBpbnZva2UgaXQgd2l0aCBsaHMgZXhwcmVzc2lvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAgICAgICAgIGV4cHIucmhzLmFyZ3VtZW50cy51bnNoaWZ0KGV4cHIubGhzKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVGdW5jdGlvbihleHByLnJocywgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgIGV4cHIucmhzLmFyZ3VtZW50cy5zaGlmdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxocyA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5saHMsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICB2YXIgZnVuYyA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5yaHMsIGlucHV0LCBlbnZpcm9ubWVudCk7XG5cbiAgICAgICAgICAgIGlmKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQyMDA2XCIsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihpc0Z1bmN0aW9uKGxocykpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGZ1bmN0aW9uIGNoYWluaW5nIChmdW5jMSB+PiBmdW5jMilcbiAgICAgICAgICAgICAgICAvLyDOuygkZiwgJGcpIHsgzrsoJHgpeyAkZygkZigkeCkpIH0gfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogYXBwbHkoY2hhaW4sIFtsaHMsIGZ1bmNdLCBlbnZpcm9ubWVudCwgbnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogYXBwbHkoZnVuYywgW2xoc10sIGVudmlyb25tZW50LCBudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmcgLSBleHByZXNzaW9uIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIGl0IGlzIGEgZnVuY3Rpb24gKGxhbWJkYSBvciBidWlsdC1pbilcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gKChhcmcgJiYgKGFyZy5fanNvbmF0YV9mdW5jdGlvbiA9PT0gdHJ1ZSB8fCBhcmcuX2pzb25hdGFfbGFtYmRhID09PSB0cnVlKSkgfHwgdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdHMgd2hldGhlciBhcmcgaXMgYSBsYW1iZGEgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IGFyZyAtIHRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSBpZiBpdCBpcyBhIGxhbWJkYSBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGFtYmRhKGFyZykge1xuICAgICAgICByZXR1cm4gYXJnICYmIGFyZy5fanNvbmF0YV9sYW1iZGEgPT09IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZyAtIGV4cHJlc3Npb24gdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUgaWYgaXQgaXMgYSBnZW5lcmF0b3IgaS5lLiB0aGUgcmVzdWx0IGZyb20gY2FsbGluZyBhXG4gICAgICogZ2VuZXJhdG9yIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNHZW5lcmF0b3IoYXJnKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgYXJnICE9PSBudWxsICYmXG4gICAgICAgICAgICBTeW1ib2wuaXRlcmF0b3IgaW4gYXJnICYmXG4gICAgICAgICAgICB0eXBlb2YgYXJnW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICduZXh0JyBpbiBhcmcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBhcmcubmV4dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGZ1bmN0aW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2FwcGx5dG9dIC0gTEhTIG9mIH4+IG9wZXJhdG9yXG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlRnVuY3Rpb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBwcm9jZWR1cmVcbiAgICAgICAgLy8gY2FuJ3QgYXNzdW1lIHRoYXQgZXhwci5wcm9jZWR1cmUgaXMgYSBsYW1iZGEgdHlwZSBkaXJlY3RseVxuICAgICAgICAvLyBjb3VsZCBiZSBhbiBleHByZXNzaW9uIHRoYXQgZXZhbHVhdGVzIHRvIGEgZnVuY3Rpb24gKGUuZy4gdmFyaWFibGUgcmVmZXJlbmNlLCBwYXJlbnMgZXhwciBldGMuXG4gICAgICAgIC8vIGV2YWx1YXRlIGl0IGdlbmVyaWNhbGx5IGZpcnN0LCB0aGVuIGNoZWNrIHRoYXQgaXQgaXMgYSBmdW5jdGlvbi4gIFRocm93IGVycm9yIGlmIG5vdC5cbiAgICAgICAgdmFyIHByb2MgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIucHJvY2VkdXJlLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvYyA9PT0gJ3VuZGVmaW5lZCcgJiYgZXhwci5wcm9jZWR1cmUudHlwZSA9PT0gJ3BhdGgnICYmIGVudmlyb25tZW50Lmxvb2t1cChleHByLnByb2NlZHVyZS5zdGVwc1swXS52YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIGhlbHAgdGhlIHVzZXIgb3V0IGhlcmUgaWYgdGhleSBzaW1wbHkgZm9yZ290IHRoZSBsZWFkaW5nICRcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlQxMDA1XCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgdG9rZW46IGV4cHIucHJvY2VkdXJlLnN0ZXBzWzBdLnZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV2YWx1YXRlZEFyZ3MgPSBbXTtcbiAgICAgICAgLy8gZWFnZXIgZXZhbHVhdGlvbiAtIGV2YWx1YXRlIHRoZSBhcmd1bWVudHNcbiAgICAgICAgZm9yICh2YXIgamogPSAwOyBqaiA8IGV4cHIuYXJndW1lbnRzLmxlbmd0aDsgamorKykge1xuICAgICAgICAgICAgLy8gb25seSBldmFsdWF0ZSAnZWFnZXInIGFyZ3VtZW50cyBhdCB0aGlzIHN0YWdlOyB3cmFwIHRoZSAnbGF6eScgb25lcyBpbiBhIGNsb3N1cmVcbiAgICAgICAgICAgIGV2YWx1YXRlZEFyZ3MucHVzaCh5aWVsZCogZXZhbHVhdGUoZXhwci5hcmd1bWVudHNbampdLCBpbnB1dCwgZW52aXJvbm1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBseSB0aGUgcHJvY2VkdXJlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBpZihpbnB1dCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgLy8gICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnB1dCwgJ19fZW52X18nLCB7XG4gICAgICAgICAgICAvLyAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgLy8gICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAvLyAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgcmV0dXJuIGVudmlyb25tZW50O1xuICAgICAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGFwcGx5KHByb2MsIGV2YWx1YXRlZEFyZ3MsIGlucHV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBhZGQgdGhlIHBvc2l0aW9uIGZpZWxkIHRvIHRoZSBlcnJvclxuICAgICAgICAgICAgZXJyLnBvc2l0aW9uID0gZXhwci5wb3NpdGlvbjtcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgZnVuY3Rpb24gaWRlbnRpZmllclxuICAgICAgICAgICAgZXJyLnRva2VuID0gZXhwci5wcm9jZWR1cmUudHlwZSA9PT0gJ3BhdGgnID8gZXhwci5wcm9jZWR1cmUuc3RlcHNbMF0udmFsdWUgOiBleHByLnByb2NlZHVyZS52YWx1ZTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHByb2NlZHVyZSBvciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9jIC0gUHJvY2VkdXJlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIC0gU2VsZlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXN1bHQgb2YgcHJvY2VkdXJlXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGFwcGx5KHByb2MsIGFyZ3MsIHNlbGYpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0geWllbGQgKiBhcHBseUlubmVyKHByb2MsIGFyZ3MsIHNlbGYpO1xuICAgICAgICB3aGlsZShpc0xhbWJkYShyZXN1bHQpICYmIHJlc3VsdC50aHVuayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gdHJhbXBvbGluZSBsb29wIC0gdGhpcyBnZXRzIGludm9rZWQgYXMgYSByZXN1bHQgb2YgdGFpbC1jYWxsIG9wdGltaXphdGlvblxuICAgICAgICAgICAgLy8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGEgdGFpbC1jYWxsIHRodW5rXG4gICAgICAgICAgICAvLyB1bnBhY2sgaXQsIGV2YWx1YXRlIGl0cyBhcmd1bWVudHMsIGFuZCBhcHBseSB0aGUgdGFpbCBjYWxsXG4gICAgICAgICAgICB2YXIgbmV4dCA9IHlpZWxkICogZXZhbHVhdGUocmVzdWx0LmJvZHkucHJvY2VkdXJlLCByZXN1bHQuaW5wdXQsIHJlc3VsdC5lbnZpcm9ubWVudCk7XG4gICAgICAgICAgICB2YXIgZXZhbHVhdGVkQXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yKHZhciBpaSA9IDA7IGlpIDwgcmVzdWx0LmJvZHkuYXJndW1lbnRzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICAgIGV2YWx1YXRlZEFyZ3MucHVzaCh5aWVsZCAqIGV2YWx1YXRlKHJlc3VsdC5ib2R5LmFyZ3VtZW50c1tpaV0sIHJlc3VsdC5pbnB1dCwgcmVzdWx0LmVudmlyb25tZW50KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogYXBwbHlJbm5lcihuZXh0LCBldmFsdWF0ZWRBcmdzLCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHByb2NlZHVyZSBvciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9jIC0gUHJvY2VkdXJlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIC0gU2VsZlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXN1bHQgb2YgcHJvY2VkdXJlXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGFwcGx5SW5uZXIocHJvYywgYXJncywgc2VsZikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgdmFsaWRhdGVkQXJncyA9IGFyZ3M7XG4gICAgICAgIGlmKHByb2MpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlZEFyZ3MgPSB2YWxpZGF0ZUFyZ3VtZW50cyhwcm9jLnNpZ25hdHVyZSwgYXJncywgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGFtYmRhKHByb2MpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGFwcGx5UHJvY2VkdXJlKHByb2MsIHZhbGlkYXRlZEFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2MgJiYgcHJvYy5fanNvbmF0YV9mdW5jdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcHJvYy5pbXBsZW1lbnRhdGlvbi5hcHBseShzZWxmLCB2YWxpZGF0ZWRBcmdzKTtcbiAgICAgICAgICAgIC8vIGBwcm9jLmltcGxlbWVudGF0aW9uYCBtaWdodCBiZSBhIGdlbmVyYXRvciBmdW5jdGlvblxuICAgICAgICAgICAgLy8gYW5kIGByZXN1bHRgIG1pZ2h0IGJlIGEgZ2VuZXJhdG9yIC0gaWYgc28sIHlpZWxkXG4gICAgICAgICAgICBpZihpc0dlbmVyYXRvcihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gcHJvYy5hcHBseShzZWxmLCB2YWxpZGF0ZWRBcmdzKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZihpc0dlbmVyYXRvcihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlQxMDA2XCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBsYW1iZGEgYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHt7bGFtYmRhOiBib29sZWFuLCBpbnB1dDogKiwgZW52aXJvbm1lbnQ6ICosIGFyZ3VtZW50czogKiwgYm9keTogKn19IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVMYW1iZGEoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIC8vIG1ha2UgYSBmdW5jdGlvbiAoY2xvc3VyZSlcbiAgICAgICAgdmFyIHByb2NlZHVyZSA9IHtcbiAgICAgICAgICAgIF9qc29uYXRhX2xhbWJkYTogdHJ1ZSxcbiAgICAgICAgICAgIGlucHV0OiBpbnB1dCxcbiAgICAgICAgICAgIGVudmlyb25tZW50OiBlbnZpcm9ubWVudCxcbiAgICAgICAgICAgIGFyZ3VtZW50czogZXhwci5hcmd1bWVudHMsXG4gICAgICAgICAgICBzaWduYXR1cmU6IGV4cHIuc2lnbmF0dXJlLFxuICAgICAgICAgICAgYm9keTogZXhwci5ib2R5XG4gICAgICAgIH07XG4gICAgICAgIGlmKGV4cHIudGh1bmsgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHByb2NlZHVyZS50aHVuayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2NlZHVyZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBwYXJ0aWFsIGFwcGxpY2F0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBldmFsdWF0ZVBhcnRpYWxBcHBsaWNhdGlvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgLy8gcGFydGlhbGx5IGFwcGx5IGEgZnVuY3Rpb25cbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgLy8gZXZhbHVhdGUgdGhlIGFyZ3VtZW50c1xuICAgICAgICB2YXIgZXZhbHVhdGVkQXJncyA9IFtdO1xuICAgICAgICBmb3IodmFyIGlpID0gMDsgaWkgPCBleHByLmFyZ3VtZW50cy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBleHByLmFyZ3VtZW50c1tpaV07XG4gICAgICAgICAgICBpZiAoYXJnLnR5cGUgPT09ICdvcGVyYXRvcicgJiYgYXJnLnZhbHVlID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICBldmFsdWF0ZWRBcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZhbHVhdGVkQXJncy5wdXNoKHlpZWxkICogZXZhbHVhdGUoYXJnLCBpbnB1dCwgZW52aXJvbm1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rdXAgdGhlIHByb2NlZHVyZVxuICAgICAgICB2YXIgcHJvYyA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5wcm9jZWR1cmUsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvYyA9PT0gJ3VuZGVmaW5lZCcgJiYgZXhwci5wcm9jZWR1cmUudHlwZSA9PT0gJ3BhdGgnICYmIGVudmlyb25tZW50Lmxvb2t1cChleHByLnByb2NlZHVyZS5zdGVwc1swXS52YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIGhlbHAgdGhlIHVzZXIgb3V0IGhlcmUgaWYgdGhleSBzaW1wbHkgZm9yZ290IHRoZSBsZWFkaW5nICRcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlQxMDA3XCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgdG9rZW46IGV4cHIucHJvY2VkdXJlLnN0ZXBzWzBdLnZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xhbWJkYShwcm9jKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFydGlhbEFwcGx5UHJvY2VkdXJlKHByb2MsIGV2YWx1YXRlZEFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2MgJiYgcHJvYy5fanNvbmF0YV9mdW5jdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFydGlhbEFwcGx5TmF0aXZlRnVuY3Rpb24ocHJvYy5pbXBsZW1lbnRhdGlvbiwgZXZhbHVhdGVkQXJncyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcnRpYWxBcHBseU5hdGl2ZUZ1bmN0aW9uKHByb2MsIGV2YWx1YXRlZEFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiVDEwMDhcIixcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICB0b2tlbjogZXhwci5wcm9jZWR1cmUudHlwZSA9PT0gJ3BhdGgnID8gZXhwci5wcm9jZWR1cmUuc3RlcHNbMF0udmFsdWUgOiBleHByLnByb2NlZHVyZS52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHRoZSBhcmd1bWVudHMgYWdhaW5zdCB0aGUgc2lnbmF0dXJlIHZhbGlkYXRvciAoaWYgaXQgZXhpc3RzKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNpZ25hdHVyZSAtIHZhbGlkYXRvciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgKiBAcGFyYW0geyp9IGNvbnRleHQgLSBjb250ZXh0IHZhbHVlXG4gICAgICogQHJldHVybnMge0FycmF5fSAtIHZhbGlkYXRlZCBhcmd1bWVudHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUFyZ3VtZW50cyhzaWduYXR1cmUsIGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgaWYodHlwZW9mIHNpZ25hdHVyZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gdmFsaWRhdGVcbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxpZGF0ZWRBcmdzID0gc2lnbmF0dXJlLnZhbGlkYXRlKGFyZ3MsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVkQXJncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBwcm9jZWR1cmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvYyAtIFByb2NlZHVyZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBBcmd1bWVudHNcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0IG9mIHByb2NlZHVyZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBhcHBseVByb2NlZHVyZShwcm9jLCBhcmdzKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBlbnYgPSBjcmVhdGVGcmFtZShwcm9jLmVudmlyb25tZW50KTtcbiAgICAgICAgcHJvYy5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0sIGluZGV4KSB7XG4gICAgICAgICAgICBlbnYuYmluZChwYXJhbS52YWx1ZSwgYXJnc1tpbmRleF0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jLmJvZHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBsYW1iZGEgdGhhdCB3cmFwcyBhIG5hdGl2ZSBmdW5jdGlvbiAtIGdlbmVyYXRlZCBieSBwYXJ0aWFsbHkgZXZhbHVhdGluZyBhIG5hdGl2ZVxuICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBhcHBseU5hdGl2ZUZ1bmN0aW9uKHByb2MuYm9keSwgZW52KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGUocHJvYy5ib2R5LCBwcm9jLmlucHV0LCBlbnYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFydGlhbGx5IGFwcGx5IHByb2NlZHVyZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9jIC0gUHJvY2VkdXJlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHt7bGFtYmRhOiBib29sZWFuLCBpbnB1dDogKiwgZW52aXJvbm1lbnQ6IHtiaW5kLCBsb29rdXB9LCBhcmd1bWVudHM6IEFycmF5LCBib2R5OiAqfX0gUmVzdWx0IG9mIHBhcnRpYWxseSBhcHBsaWVkIHByb2NlZHVyZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWxBcHBseVByb2NlZHVyZShwcm9jLCBhcmdzKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIGNsb3N1cmUsIGJpbmQgdGhlIHN1cHBsaWVkIHBhcmFtZXRlcnMgYW5kIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIHJlbWFpbmluZyAoPykgcGFyYW1ldGVyc1xuICAgICAgICB2YXIgZW52ID0gY3JlYXRlRnJhbWUocHJvYy5lbnZpcm9ubWVudCk7XG4gICAgICAgIHZhciB1bmJvdW5kQXJncyA9IFtdO1xuICAgICAgICBwcm9jLmFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChhcmcgJiYgYXJnLnR5cGUgPT09ICdvcGVyYXRvcicgJiYgYXJnLnZhbHVlID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICB1bmJvdW5kQXJncy5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW52LmJpbmQocGFyYW0udmFsdWUsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcHJvY2VkdXJlID0ge1xuICAgICAgICAgICAgX2pzb25hdGFfbGFtYmRhOiB0cnVlLFxuICAgICAgICAgICAgaW5wdXQ6IHByb2MuaW5wdXQsXG4gICAgICAgICAgICBlbnZpcm9ubWVudDogZW52LFxuICAgICAgICAgICAgYXJndW1lbnRzOiB1bmJvdW5kQXJncyxcbiAgICAgICAgICAgIGJvZHk6IHByb2MuYm9keVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcHJvY2VkdXJlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnRpYWxseSBhcHBseSBuYXRpdmUgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuYXRpdmUgLSBOYXRpdmUgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIC0gQXJndW1lbnRzXG4gICAgICogQHJldHVybnMge3tsYW1iZGE6IGJvb2xlYW4sIGlucHV0OiAqLCBlbnZpcm9ubWVudDoge2JpbmQsIGxvb2t1cH0sIGFyZ3VtZW50czogQXJyYXksIGJvZHk6ICp9fSBSZXN1bHQgb2YgcGFydGlhbGx5IGFwcGx5aW5nIG5hdGl2ZSBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWxBcHBseU5hdGl2ZUZ1bmN0aW9uKG5hdGl2ZSwgYXJncykge1xuICAgICAgICAvLyBjcmVhdGUgYSBsYW1iZGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBhbmQgaW52b2tlcyB0aGUgbmF0aXZlIGZ1bmN0aW9uXG4gICAgICAgIC8vIGdldCB0aGUgbGlzdCBvZiBkZWNsYXJlZCBhcmd1bWVudHMgZnJvbSB0aGUgbmF0aXZlIGZ1bmN0aW9uXG4gICAgICAgIC8vIHRoaXMgaGFzIHRvIGJlIHBpY2tlZCBvdXQgZnJvbSB0aGUgdG9TdHJpbmcoKSB2YWx1ZVxuICAgICAgICB2YXIgc2lnQXJncyA9IGdldE5hdGl2ZUZ1bmN0aW9uQXJndW1lbnRzKG5hdGl2ZSk7XG4gICAgICAgIHNpZ0FyZ3MgPSBzaWdBcmdzLm1hcChmdW5jdGlvbiAoc2lnQXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gJyQnICsgc2lnQXJnLnRyaW0oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBib2R5ID0gJ2Z1bmN0aW9uKCcgKyBzaWdBcmdzLmpvaW4oJywgJykgKyAnKXsgXyB9JztcblxuICAgICAgICB2YXIgYm9keUFTVCA9IHBhcnNlcihib2R5KTtcbiAgICAgICAgYm9keUFTVC5ib2R5ID0gbmF0aXZlO1xuXG4gICAgICAgIHZhciBwYXJ0aWFsID0gcGFydGlhbEFwcGx5UHJvY2VkdXJlKGJvZHlBU1QsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gcGFydGlhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBuYXRpdmUgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvYyAtIFByb2NlZHVyZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnYgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXN1bHQgb2YgYXBwbHlpbmcgbmF0aXZlIGZ1bmN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGFwcGx5TmF0aXZlRnVuY3Rpb24ocHJvYywgZW52KSB7XG4gICAgICAgIHZhciBzaWdBcmdzID0gZ2V0TmF0aXZlRnVuY3Rpb25Bcmd1bWVudHMocHJvYyk7XG4gICAgICAgIC8vIGdlbmVyYXRlIHRoZSBhcnJheSBvZiBhcmd1bWVudHMgZm9yIGludm9raW5nIHRoZSBmdW5jdGlvbiAtIGxvb2sgdGhlbSB1cCBpbiB0aGUgZW52aXJvbm1lbnRcbiAgICAgICAgdmFyIGFyZ3MgPSBzaWdBcmdzLm1hcChmdW5jdGlvbiAoc2lnQXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gZW52Lmxvb2t1cChzaWdBcmcudHJpbSgpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHByb2MuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIGlmKGlzR2VuZXJhdG9yKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IG5hdGl2ZSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gRnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7KnxBcnJheX0gTmF0aXZlIGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE5hdGl2ZUZ1bmN0aW9uQXJndW1lbnRzKGZ1bmMpIHtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IGZ1bmMudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIHNpZ1BhcmVucyA9IC9cXCgoW14pXSopXFwpLy5leGVjKHNpZ25hdHVyZSlbMV07IC8vIHRoZSBjb250ZW50cyBvZiB0aGUgcGFyZW5zXG4gICAgICAgIHZhciBzaWdBcmdzID0gc2lnUGFyZW5zLnNwbGl0KCcsJyk7XG4gICAgICAgIHJldHVybiBzaWdBcmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBkZWZpbml0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uIGluIEphdmFzY3JpcHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlIC0gSlNPTmF0YSBmdW5jdGlvbiBzaWduYXR1cmUgZGVmaW5pdGlvblxuICAgICAqIEByZXR1cm5zIHt7aW1wbGVtZW50YXRpb246ICosIHNpZ25hdHVyZTogKn19IGZ1bmN0aW9uIGRlZmluaXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZpbmVGdW5jdGlvbihmdW5jLCBzaWduYXR1cmUpIHtcbiAgICAgICAgdmFyIGRlZmluaXRpb24gPSB7XG4gICAgICAgICAgICBfanNvbmF0YV9mdW5jdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIGltcGxlbWVudGF0aW9uOiBmdW5jXG4gICAgICAgIH07XG4gICAgICAgIGlmKHR5cGVvZiBzaWduYXR1cmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uLnNpZ25hdHVyZSA9IHBhcnNlU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3VtIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgLSBBcmd1bWVudHNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUb3RhbCB2YWx1ZSBvZiBhcmd1bWVudHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblN1bShhcmdzKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZ3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uKG51bSl7dG90YWwgKz0gbnVtO30pO1xuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ291bnQgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkNvdW50KGFyZ3MpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJncyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyZ3MubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1heCBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIC0gQXJndW1lbnRzXG4gICAgICogQHJldHVybnMge251bWJlcn0gTWF4IGVsZW1lbnQgaW4gdGhlIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25NYXgoYXJncykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmdzID09PSAndW5kZWZpbmVkJyB8fCBhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNaW4gZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE1pbiBlbGVtZW50IGluIHRoZSBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uTWluKGFyZ3MpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJncyA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkoTWF0aCwgYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXZlcmFnZSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIC0gQXJndW1lbnRzXG4gICAgICogQHJldHVybnMge251bWJlcn0gQXZlcmFnZSBlbGVtZW50IGluIHRoZSBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uQXZlcmFnZShhcmdzKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZ3MgPT09ICd1bmRlZmluZWQnIHx8IGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uKG51bSl7dG90YWwgKz0gbnVtO30pO1xuICAgICAgICByZXR1cm4gdG90YWwvYXJncy5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RpbmdpZnkgYXJndW1lbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFN0cmluZyBmcm9tIGFyZ3VtZW50c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU3RyaW5nKGFyZykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cjtcblxuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIGFscmVhZHkgYSBzdHJpbmdcbiAgICAgICAgICAgIHN0ciA9IGFyZztcbiAgICAgICAgfSBlbHNlIGlmKGlzRnVuY3Rpb24oYXJnKSkge1xuICAgICAgICAgICAgLy8gZnVuY3Rpb25zIChidWlsdC1pbiBhbmQgbGFtYmRhIGNvbnZlcnQgdG8gZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICBzdHIgPSAnJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUoYXJnKSkge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiRDMwMDFcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXJnLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHN0ciA9IEpTT04uc3RyaW5naWZ5KGFyZywgZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgIT09IG51bGwgJiYgdmFsLnRvUHJlY2lzaW9uICYmIGlzTnVtZXJpYyh2YWwpKSA/IE51bWJlcih2YWwudG9QcmVjaXNpb24oMTMpKSA6XG4gICAgICAgICAgICAgICAgICAgICh2YWwgJiYgaXNGdW5jdGlvbih2YWwpKSA/ICcnIDogdmFsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHN1YnN0cmluZyBiYXNlZCBvbiBjaGFyYWN0ZXIgbnVtYmVyIGFuZCBsZW5ndGhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gU3RyaW5nIHRvIGV2YWx1YXRlXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBzdGFydCAtIENoYXJhY3RlciBudW1iZXIgdG8gc3RhcnQgc3Vic3RyaW5nXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBbbGVuZ3RoXSAtIE51bWJlciBvZiBjaGFyYWN0ZXJzIGluIHN1YnN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8Kn0gU3Vic3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25TdWJzdHJpbmcoc3RyLCBzdGFydCwgbGVuZ3RoKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgc3Vic3RyaW5nIHVwIHVudGlsIGEgY2hhcmFjdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFN0cmluZyB0byBldmFsdWF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjaGFycyAtIENoYXJhY3RlciB0byBkZWZpbmUgc3Vic3RyaW5nIGJvdW5kYXJ5XG4gICAgICogQHJldHVybnMgeyp9IFN1YnN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU3Vic3RyaW5nQmVmb3JlKHN0ciwgY2hhcnMpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3MgPSBzdHIuaW5kZXhPZihjaGFycyk7XG4gICAgICAgIGlmIChwb3MgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgcG9zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgc3Vic3RyaW5nIGFmdGVyIGEgY2hhcmFjdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFN0cmluZyB0byBldmFsdWF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjaGFycyAtIENoYXJhY3RlciB0byBkZWZpbmUgc3Vic3RyaW5nIGJvdW5kYXJ5XG4gICAgICogQHJldHVybnMgeyp9IFN1YnN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU3Vic3RyaW5nQWZ0ZXIoc3RyLCBjaGFycykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvcyA9IHN0ci5pbmRleE9mKGNoYXJzKTtcbiAgICAgICAgaWYgKHBvcyA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihwb3MgKyBjaGFycy5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvd2VyY2FzZSBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBTdHJpbmcgdG8gZXZhbHVhdGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBMb3dlcmNhc2Ugc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Mb3dlcmNhc2Uoc3RyKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBwZXJjYXNlIGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFN0cmluZyB0byBldmFsdWF0ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFVwcGVyY2FzZSBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblVwcGVyY2FzZShzdHIpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBsZW5ndGggb2YgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkxlbmd0aChzdHIpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHIubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBhbmQgdHJpbSB3aGl0ZXNwYWNlIHdpdGhpbiBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBzdHJpbmcgdG8gYmUgdHJpbW1lZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdHJpbW1lZCBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblRyaW0oc3RyKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3JtYWxpemUgd2hpdGVzcGFjZVxuICAgICAgICB2YXIgcmVzdWx0ID0gc3RyLnJlcGxhY2UoL1sgXFx0XFxuXFxyXSsvZ20sICcgJyk7XG4gICAgICAgIGlmKHJlc3VsdC5jaGFyQXQoMCkgPT09ICcgJykge1xuICAgICAgICAgICAgLy8gc3RyaXAgbGVhZGluZyBzcGFjZVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBpZihyZXN1bHQuY2hhckF0KHJlc3VsdC5sZW5ndGggLSAxKSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAvLyBzdHJpcCB0cmFpbGluZyBzcGFjZVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygwLCByZXN1bHQubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWQgYSBzdHJpbmcgdG8gYSBtaW5pbXVtIHdpZHRoIGJ5IGFkZGluZyBjaGFyYWN0ZXJzIHRvIHRoZSBzdGFydCBvciBlbmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gc3RyaW5nIHRvIGJlIHBhZGRlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSBtaW5pbXVtIHdpZHRoOyArdmUgcGFkcyB0byB0aGUgcmlnaHQsIC12ZSBwYWRzIHRvIHRoZSBsZWZ0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFyXSAtIHRoZSBwYWQgY2hhcmFjdGVyKHMpOyBkZWZhdWx0cyB0byAnICdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHBhZGRlZCBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblBhZChzdHIsIHdpZHRoLCBjaGFyKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0eXBlb2YgY2hhciA9PT0gJ3VuZGVmaW5lZCcgfHwgY2hhci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNoYXIgPSAnICc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgcGFkTGVuZ3RoID0gTWF0aC5hYnMod2lkdGgpIC0gc3RyLmxlbmd0aDtcbiAgICAgICAgaWYocGFkTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSAobmV3IEFycmF5KHBhZExlbmd0aCArIDEpKS5qb2luKGNoYXIpO1xuICAgICAgICAgICAgaWYoY2hhci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgcGFkZGluZyA9IHBhZGRpbmcuc3Vic3RyaW5nKDAsIHBhZExlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih3aWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzdHIgKyBwYWRkaW5nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwYWRkaW5nICsgc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3RyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIHN0ciBjb250YWlucyB0aGUgdG9rZW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nIHRvIHRlc3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gLSBzdWJzdHJpbmcgb3IgcmVnZXggdG8gZmluZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSAtIHRydWUgaWYgc3RyIGNvbnRhaW5zIHRva2VuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Db250YWlucyhzdHIsIHRva2VuKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIGlmKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChzdHIuaW5kZXhPZih0b2tlbikgIT09IC0xKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gdG9rZW4oc3RyKTtcbiAgICAgICAgICAgIHJlc3VsdCA9ICh0eXBlb2YgbWF0Y2hlcyAhPT0gJ3VuZGVmaW5lZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXRjaCBhIHN0cmluZyB3aXRoIGEgcmVnZXggcmV0dXJuaW5nIGFuIGFycmF5IG9mIG9iamVjdCBjb250YWluaW5nIGRldGFpbHMgb2YgZWFjaCBtYXRjaFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVnZXggLSB0aGUgcmVnZXggYXBwbGllZCB0byB0aGUgc3RyaW5nXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBbbGltaXRdIC0gbWF4IG51bWJlciBvZiBtYXRjaGVzIHRvIHJldHVyblxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IG9mIG1hdGNoIG9iamVjdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbk1hdGNoKHN0ciwgcmVnZXgsIGxpbWl0KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsaW1pdCwgaWYgc3BlY2lmaWVkLCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlclxuICAgICAgICBpZihsaW1pdCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGltaXQsXG4gICAgICAgICAgICAgICAgY29kZTogJ0QzMDQwJyxcbiAgICAgICAgICAgICAgICBpbmRleDogM1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZih0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnIHx8IGxpbWl0ID4gMCkge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gcmVnZXgoc3RyKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWF0Y2hlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHlwZW9mIG1hdGNoZXMgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnIHx8IGNvdW50IDwgbGltaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoOiBtYXRjaGVzLm1hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IG1hdGNoZXMuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cHM6IG1hdGNoZXMuZ3JvdXBzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXRjaCBhIHN0cmluZyB3aXRoIGEgcmVnZXggcmV0dXJuaW5nIGFuIGFycmF5IG9mIG9iamVjdCBjb250YWluaW5nIGRldGFpbHMgb2YgZWFjaCBtYXRjaFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0dGVybiAtIHRoZSBzdWJzdHJpbmcvcmVnZXggYXBwbGllZCB0byB0aGUgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcGxhY2VtZW50IC0gdGV4dCB0byByZXBsYWNlIHRoZSBtYXRjaGVkIHN1YnN0cmluZ3NcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IFtsaW1pdF0gLSBtYXggbnVtYmVyIG9mIG1hdGNoZXMgdG8gcmV0dXJuXG4gICAgICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2YgbWF0Y2ggb2JqZWN0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBmdW5jdGlvblJlcGxhY2Uoc3RyLCBwYXR0ZXJuLCByZXBsYWNlbWVudCwgbGltaXQpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhdHRlcm4gY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgICBpZihwYXR0ZXJuID09PSAnJykge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiRDMwMTBcIixcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGF0dGVybixcbiAgICAgICAgICAgICAgICBpbmRleDogMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxpbWl0LCBpZiBzcGVjaWZpZWQsIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyXG4gICAgICAgIGlmKGxpbWl0IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiRDMwMTFcIixcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGltaXQsXG4gICAgICAgICAgICAgICAgaW5kZXg6IDRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVwbGFjZXI7XG4gICAgICAgIGlmKHR5cGVvZiByZXBsYWNlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlcGxhY2VyID0gZnVuY3Rpb24gKHJlZ2V4TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic3RpdHV0ZSA9ICcnO1xuICAgICAgICAgICAgICAgIC8vIHNjYW4gZm9yd2FyZCwgY29weWluZyB0aGUgcmVwbGFjZW1lbnQgdGV4dCBpbnRvIHRoZSBzdWJzdGl0dXRlIHN0cmluZ1xuICAgICAgICAgICAgICAgIC8vIGFuZCByZXBsYWNlIGFueSBvY2N1cnJlbmNlIG9mICRuIHdpdGggdGhlIHZhbHVlcyBtYXRjaGVkIGJ5IHRoZSByZWdleFxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcmVwbGFjZW1lbnQuaW5kZXhPZignJCcsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggIT09IC0xICYmIHBvc2l0aW9uIDwgcmVwbGFjZW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGUgKz0gcmVwbGFjZW1lbnQuc3Vic3RyaW5nKHBvc2l0aW9uLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9sbGFyVmFsID0gcmVwbGFjZW1lbnQuY2hhckF0KHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbGxhclZhbCA9PT0gJyQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsaXRlcmFsICRcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGUgKz0gJyQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkb2xsYXJWYWwgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0ZSArPSByZWdleE1hdGNoLm1hdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhEaWdpdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyZWdleE1hdGNoLmdyb3Vwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBzdWItbWF0Y2hlczsgYW55ICQgZm9sbG93ZWQgYnkgYSBkaWdpdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IGFuIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heERpZ2l0cyA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heCBudW1iZXIgb2YgZGlnaXRzIHRvIHBhcnNlIGZvbGxvd2luZyB0aGUgJFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heERpZ2l0cyA9IE1hdGguZmxvb3IoTWF0aC5sb2cocmVnZXhNYXRjaC5ncm91cHMubGVuZ3RoKSAqIE1hdGguTE9HMTBFKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHBhcnNlSW50KHJlcGxhY2VtZW50LnN1YnN0cmluZyhwb3NpdGlvbiwgcG9zaXRpb24gKyBtYXhEaWdpdHMpLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtYXhEaWdpdHMgPiAxICYmIGluZGV4ID4gcmVnZXhNYXRjaC5ncm91cHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBwYXJzZUludChyZXBsYWNlbWVudC5zdWJzdHJpbmcocG9zaXRpb24sIHBvc2l0aW9uICsgbWF4RGlnaXRzIC0gMSksIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4oaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVnZXhNYXRjaC5ncm91cHMubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1Ym1hdGNoID0gcmVnZXhNYXRjaC5ncm91cHNbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWJtYXRjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGUgKz0gc3VibWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gaW5kZXgudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBhIGNhcHR1cmUgZ3JvdXAsIHRyZWF0IHRoZSAkIGFzIGxpdGVyYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRlICs9ICckJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlcGxhY2VtZW50LmluZGV4T2YoJyQnLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1YnN0aXR1dGUgKz0gcmVwbGFjZW1lbnQuc3Vic3RyaW5nKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXBsYWNlciA9IHJlcGxhY2VtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSAwO1xuXG4gICAgICAgIGlmKHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcgfHwgbGltaXQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgaWYodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gc3RyLmluZGV4T2YocGF0dGVybiwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHdoaWxlKGluZGV4ICE9PSAtMSAmJiAodHlwZW9mIGxpbWl0ID09PSAndW5kZWZpbmVkJyB8fCBjb3VudCA8IGxpbWl0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyLnN1YnN0cmluZyhwb3NpdGlvbiwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gaW5kZXggKyBwYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzdHIuaW5kZXhPZihwYXR0ZXJuLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuc3Vic3RyaW5nKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBwYXR0ZXJuKHN0cik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtYXRjaGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHlwZW9mIG1hdGNoZXMgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnIHx8IGNvdW50IDwgbGltaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyLnN1YnN0cmluZyhwb3NpdGlvbiwgbWF0Y2hlcy5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZWRXaXRoID0geWllbGQgKiBhcHBseShyZXBsYWNlciwgW21hdGNoZXNdLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHJlcGxhY2VkV2l0aCBpcyBhIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIHJlcGxhY2VkV2l0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcmVwbGFjZWRXaXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgYSBzdHJpbmcgLSB0aHJvdyBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJEMzAxMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlcGxhY2VkV2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IG1hdGNoZXMuc3RhcnQgKyBtYXRjaGVzLm1hdGNoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5zdWJzdHJpbmcocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHN0cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzdHI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJhc2U2NCBlbmNvZGUgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nXG4gICAgICogQHJldHVybnMge1N0cmluZ30gQmFzZSA2NCBlbmNvZGluZyBvZiB0aGUgYmluYXJ5IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkJhc2U2NGVuY29kZShzdHIpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgYnRvYSBpbiBhIGJyb3dzZXIsIG9yIEJ1ZmZlciBpbiBOb2RlLmpzXG5cbiAgICAgICAgdmFyIGJ0b2EgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB3aW5kb3cuYnRvYSA6XG4gICAgICAgICAgICBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbHkgZG9pbmcgYG5ldyBCdWZmZXJgIGF0IHRoaXMgcG9pbnQgY2F1c2VzIEJyb3dzZXJpZnkgdG8gcHVsbFxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBlbnRpcmUgQnVmZmVyIGJyb3dzZXIgbGlicmFyeSwgd2hpY2ggaXMgbGFyZ2UgYW5kIHVubmVjZXNzYXJ5LlxuICAgICAgICAgICAgICAgIC8vIFVzaW5nIGBnbG9iYWwuQnVmZmVyYCBkZWZlYXRzIHRoaXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBnbG9iYWwuQnVmZmVyKHN0ciwgJ2JpbmFyeScpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIHJldHVybiBidG9hKHN0cik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmFzZTY0IGRlY29kZSBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBCYXNlIDY0IGVuY29kaW5nIG9mIHRoZSBiaW5hcnkgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uQmFzZTY0ZGVjb2RlKHN0cikge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBidG9hIGluIGEgYnJvd3Nlciwgb3IgQnVmZmVyIGluIE5vZGUuanNcbiAgICAgICAgdmFyIGF0b2IgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB3aW5kb3cuYXRvYiA6XG4gICAgICAgICAgICBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbHkgZG9pbmcgYG5ldyBCdWZmZXJgIGF0IHRoaXMgcG9pbnQgY2F1c2VzIEJyb3dzZXJpZnkgdG8gcHVsbFxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBlbnRpcmUgQnVmZmVyIGJyb3dzZXIgbGlicmFyeSwgd2hpY2ggaXMgbGFyZ2UgYW5kIHVubmVjZXNzYXJ5LlxuICAgICAgICAgICAgICAgIC8vIFVzaW5nIGBnbG9iYWwuQnVmZmVyYCBkZWZlYXRzIHRoaXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBnbG9iYWwuQnVmZmVyKHN0ciwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIHJldHVybiBhdG9iKHN0cik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BsaXQgYSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBzdWJzdHJpbmdzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXBhcmF0b3IgLSB0aGUgdG9rZW4gb3IgcmVnZXggdGhhdCBzcGxpdHMgdGhlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gW2xpbWl0XSAtIG1heCBudW1iZXIgb2Ygc3Vic3RyaW5nc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IG9mIHN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU3BsaXQoc3RyLCBzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsaW1pdCwgaWYgc3BlY2lmaWVkLCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlclxuICAgICAgICBpZihsaW1pdCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMDIwXCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxpbWl0LFxuICAgICAgICAgICAgICAgIGluZGV4OiAzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGlmKHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcgfHwgbGltaXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlcGFyYXRvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzdHIuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBzZXBhcmF0b3Ioc3RyKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1hdGNoZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0eXBlb2YgbWF0Y2hlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcgfHwgY291bnQgPCBsaW1pdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0ci5zdWJzdHJpbmcoc3RhcnQsIG1hdGNoZXMuc3RhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbWF0Y2hlcy5lbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcgfHwgY291bnQgPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RyLnN1YnN0cmluZyhzdGFydCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW3N0cl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBKb2luIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzdHJzIC0gYXJyYXkgb2Ygc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzZXBhcmF0b3JdIC0gdGhlIHRva2VuIHRoYXQgc3BsaXRzIHRoZSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgY29uY2F0ZW5hdGVkIHN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uSm9pbihzdHJzLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBzZXBhcmF0b3IgaXMgbm90IHNwZWNpZmllZCwgZGVmYXVsdCB0byBlbXB0eSBzdHJpbmdcbiAgICAgICAgaWYodHlwZW9mIHNlcGFyYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3Rycy5qb2luKHNlcGFyYXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0cyBhIG51bWJlciBpbnRvIGEgZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gdXNpbmcgWFBhdGggMy4xIEYmTyBmbjpmb3JtYXQtbnVtYmVyIHNwZWNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBudW1iZXIgdG8gZm9ybWF0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBpY3R1cmUgLSBwaWN0dXJlIHN0cmluZyBkZWZpbml0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG92ZXJyaWRlIGxvY2FsZSBkZWZhdWx0c1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBmb3JtYXR0ZWQgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Gb3JtYXROdW1iZXIodmFsdWUsIHBpY3R1cmUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgXCJkZWNpbWFsLXNlcGFyYXRvclwiOiBcIi5cIixcbiAgICAgICAgICAgIFwiZ3JvdXBpbmctc2VwYXJhdG9yXCI6IFwiLFwiLFxuICAgICAgICAgICAgXCJleHBvbmVudC1zZXBhcmF0b3JcIjogXCJlXCIsXG4gICAgICAgICAgICBcImluZmluaXR5XCI6IFwiSW5maW5pdHlcIixcbiAgICAgICAgICAgIFwibWludXMtc2lnblwiOiBcIi1cIixcbiAgICAgICAgICAgIFwiTmFOXCI6IFwiTmFOXCIsXG4gICAgICAgICAgICBcInBlcmNlbnRcIjogXCIlXCIsXG4gICAgICAgICAgICBcInBlci1taWxsZVwiOiBcIlxcdTIwMzBcIixcbiAgICAgICAgICAgIFwiemVyby1kaWdpdFwiOiBcIjBcIixcbiAgICAgICAgICAgIFwiZGlnaXRcIjogXCIjXCIsXG4gICAgICAgICAgICBcInBhdHRlcm4tc2VwYXJhdG9yXCI6IFwiO1wiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaWYgYG9wdGlvbnNgIGlzIHNwZWNpZmllZCwgdGhlbiBpdHMgZW50cmllcyBvdmVycmlkZSBkZWZhdWx0c1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IGRlZmF1bHRzO1xuICAgICAgICBpZih0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlY2ltYWxEaWdpdEZhbWlseSA9IFtdO1xuICAgICAgICB2YXIgemVyb0NoYXJDb2RlID0gcHJvcGVydGllc1snemVyby1kaWdpdCddLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGZvcih2YXIgaWkgPSB6ZXJvQ2hhckNvZGU7IGlpIDwgemVyb0NoYXJDb2RlICsgMTA7IGlpKyspIHtcbiAgICAgICAgICAgIGRlY2ltYWxEaWdpdEZhbWlseS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaWkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY3RpdmVDaGFycyA9IGRlY2ltYWxEaWdpdEZhbWlseS5jb25jYXQoW3Byb3BlcnRpZXNbJ2RlY2ltYWwtc2VwYXJhdG9yJ10sIHByb3BlcnRpZXNbJ2V4cG9uZW50LXNlcGFyYXRvciddLCBwcm9wZXJ0aWVzWydncm91cGluZy1zZXBhcmF0b3InXSwgcHJvcGVydGllcy5kaWdpdCwgcHJvcGVydGllc1sncGF0dGVybi1zZXBhcmF0b3InXV0pO1xuXG4gICAgICAgIHZhciBzdWJQaWN0dXJlcyA9IHBpY3R1cmUuc3BsaXQocHJvcGVydGllc1sncGF0dGVybi1zZXBhcmF0b3InXSk7XG5cbiAgICAgICAgaWYoc3ViUGljdHVyZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6ICdEMzA4MCcsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3BsaXRQYXJ0cyA9IGZ1bmN0aW9uKHN1YnBpY3R1cmUpIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaWkgPSAwOyBpaSA8IHN1YnBpY3R1cmUubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gc3VicGljdHVyZS5jaGFyQXQoaWkpO1xuICAgICAgICAgICAgICAgICAgICBpZihhY3RpdmVDaGFycy5pbmRleE9mKGNoKSAhPT0gLTEgJiYgY2ggIT09IHByb3BlcnRpZXNbJ2V4cG9uZW50LXNlcGFyYXRvciddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VicGljdHVyZS5zdWJzdHJpbmcoMCwgaWkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaWkgPSBzdWJwaWN0dXJlLmxlbmd0aCAtIDE7IGlpID49IDA7IGlpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSBzdWJwaWN0dXJlLmNoYXJBdChpaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGFjdGl2ZUNoYXJzLmluZGV4T2YoY2gpICE9PSAtMSAmJiBjaCAhPT0gcHJvcGVydGllc1snZXhwb25lbnQtc2VwYXJhdG9yJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJwaWN0dXJlLnN1YnN0cmluZyhpaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHZhciBhY3RpdmVQYXJ0ID0gc3VicGljdHVyZS5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aCwgc3VicGljdHVyZS5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBtYW50aXNzYVBhcnQsIGV4cG9uZW50UGFydCwgaW50ZWdlclBhcnQsIGZyYWN0aW9uYWxQYXJ0O1xuICAgICAgICAgICAgdmFyIGV4cG9uZW50UG9zaXRpb24gPSBzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllc1snZXhwb25lbnQtc2VwYXJhdG9yJ10sIHByZWZpeC5sZW5ndGgpO1xuICAgICAgICAgICAgaWYoZXhwb25lbnRQb3NpdGlvbiA9PT0gLTEgfHwgZXhwb25lbnRQb3NpdGlvbiA+IHN1YnBpY3R1cmUubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG1hbnRpc3NhUGFydCA9IGFjdGl2ZVBhcnQ7XG4gICAgICAgICAgICAgICAgZXhwb25lbnRQYXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYW50aXNzYVBhcnQgPSBhY3RpdmVQYXJ0LnN1YnN0cmluZygwLCBleHBvbmVudFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBleHBvbmVudFBhcnQgPSBhY3RpdmVQYXJ0LnN1YnN0cmluZyhleHBvbmVudFBvc2l0aW9uICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGVjaW1hbFBvc2l0aW9uID0gbWFudGlzc2FQYXJ0LmluZGV4T2YocHJvcGVydGllc1snZGVjaW1hbC1zZXBhcmF0b3InXSk7XG4gICAgICAgICAgICBpZihkZWNpbWFsUG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaW50ZWdlclBhcnQgPSBtYW50aXNzYVBhcnQ7XG4gICAgICAgICAgICAgICAgZnJhY3Rpb25hbFBhcnQgPSBzdWZmaXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGludGVnZXJQYXJ0ID0gbWFudGlzc2FQYXJ0LnN1YnN0cmluZygwLCBkZWNpbWFsUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGZyYWN0aW9uYWxQYXJ0ID0gbWFudGlzc2FQYXJ0LnN1YnN0cmluZyhkZWNpbWFsUG9zaXRpb24gKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBzdWZmaXgsXG4gICAgICAgICAgICAgICAgYWN0aXZlUGFydDogYWN0aXZlUGFydCxcbiAgICAgICAgICAgICAgICBtYW50aXNzYVBhcnQ6IG1hbnRpc3NhUGFydCxcbiAgICAgICAgICAgICAgICBleHBvbmVudFBhcnQ6IGV4cG9uZW50UGFydCxcbiAgICAgICAgICAgICAgICBpbnRlZ2VyUGFydDogaW50ZWdlclBhcnQsXG4gICAgICAgICAgICAgICAgZnJhY3Rpb25hbFBhcnQ6IGZyYWN0aW9uYWxQYXJ0LFxuICAgICAgICAgICAgICAgIHN1YnBpY3R1cmU6IHN1YnBpY3R1cmVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdmFsaWRhdGUgdGhlIHBpY3R1cmUgc3RyaW5nLCBGJk8gNC43LjNcbiAgICAgICAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24ocGFydHMpIHtcbiAgICAgICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgICAgIHZhciBpaTtcbiAgICAgICAgICAgIHZhciBzdWJwaWN0dXJlID0gcGFydHMuc3VicGljdHVyZTtcbiAgICAgICAgICAgIHZhciBkZWNpbWFsUG9zID0gc3VicGljdHVyZS5pbmRleE9mKHByb3BlcnRpZXNbJ2RlY2ltYWwtc2VwYXJhdG9yJ10pO1xuICAgICAgICAgICAgaWYoZGVjaW1hbFBvcyAhPT0gc3VicGljdHVyZS5sYXN0SW5kZXhPZihwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddKSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gJ0QzMDgxJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHN1YnBpY3R1cmUuaW5kZXhPZihwcm9wZXJ0aWVzLnBlcmNlbnQpICE9PSBzdWJwaWN0dXJlLmxhc3RJbmRleE9mKHByb3BlcnRpZXMucGVyY2VudCkpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA4Mic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllc1sncGVyLW1pbGxlJ10pICE9PSBzdWJwaWN0dXJlLmxhc3RJbmRleE9mKHByb3BlcnRpZXNbJ3Blci1taWxsZSddKSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gJ0QzMDgzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHN1YnBpY3R1cmUuaW5kZXhPZihwcm9wZXJ0aWVzLnBlcmNlbnQpICE9PSAtMSAmJiBzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllc1sncGVyLW1pbGxlJ10pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gJ0QzMDg0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yKGlpID0gMDsgaWkgPCBwYXJ0cy5tYW50aXNzYVBhcnQubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoID0gcGFydHMubWFudGlzc2FQYXJ0LmNoYXJBdChpaSk7XG4gICAgICAgICAgICAgICAgaWYoZGVjaW1hbERpZ2l0RmFtaWx5LmluZGV4T2YoY2gpICE9PSAtMSB8fCBjaCA9PT0gcHJvcGVydGllcy5kaWdpdCkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCF2YWxpZCkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gJ0QzMDg1JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGFyVHlwZXMgPSBwYXJ0cy5hY3RpdmVQYXJ0LnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24oY2hhcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY3RpdmVDaGFycy5pbmRleE9mKGNoYXIpID09PSAtMSA/ICdwJyA6ICdhJztcbiAgICAgICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgICAgICAgaWYoY2hhclR5cGVzLmluZGV4T2YoJ3AnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA4Nic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkZWNpbWFsUG9zICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmKHN1YnBpY3R1cmUuY2hhckF0KGRlY2ltYWxQb3MgLSAxKSA9PT0gcHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10gfHwgc3VicGljdHVyZS5jaGFyQXQoZGVjaW1hbFBvcyArIDEpID09PSBwcm9wZXJ0aWVzWydncm91cGluZy1zZXBhcmF0b3InXSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA4Nyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmKHBhcnRzLmludGVnZXJQYXJ0LmNoYXJBdChwYXJ0cy5pbnRlZ2VyUGFydC5sZW5ndGggLSAxKSA9PT0gcHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10pIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA4OCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10gKyBwcm9wZXJ0aWVzWydncm91cGluZy1zZXBhcmF0b3InXSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAnRDMwODknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9wdGlvbmFsRGlnaXRQb3MgPSBwYXJ0cy5pbnRlZ2VyUGFydC5pbmRleE9mKHByb3BlcnRpZXMuZGlnaXQpO1xuICAgICAgICAgICAgaWYob3B0aW9uYWxEaWdpdFBvcyAhPT0gLTEgJiYgcGFydHMuaW50ZWdlclBhcnQuc3Vic3RyaW5nKDAsIG9wdGlvbmFsRGlnaXRQb3MpLnNwbGl0KCcnKS5maWx0ZXIoZnVuY3Rpb24oY2hhcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNpbWFsRGlnaXRGYW1pbHkuaW5kZXhPZihjaGFyKSA+IC0xO1xuICAgICAgICAgICAgfSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gJ0QzMDkwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbmFsRGlnaXRQb3MgPSBwYXJ0cy5mcmFjdGlvbmFsUGFydC5sYXN0SW5kZXhPZihwcm9wZXJ0aWVzLmRpZ2l0KTtcbiAgICAgICAgICAgIGlmKG9wdGlvbmFsRGlnaXRQb3MgIT09IC0xICYmIHBhcnRzLmZyYWN0aW9uYWxQYXJ0LnN1YnN0cmluZyhvcHRpb25hbERpZ2l0UG9zKS5zcGxpdCgnJykuZmlsdGVyKGZ1bmN0aW9uKGNoYXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjaW1hbERpZ2l0RmFtaWx5LmluZGV4T2YoY2hhcikgPiAtMTtcbiAgICAgICAgICAgIH0pLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA5MSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXhwb25lbnRFeGlzdHMgPSAodHlwZW9mIHBhcnRzLmV4cG9uZW50UGFydCA9PT0gJ3N0cmluZycpO1xuICAgICAgICAgICAgaWYoZXhwb25lbnRFeGlzdHMgJiYgcGFydHMuZXhwb25lbnRQYXJ0Lmxlbmd0aCA+IDAgJiYgKHN1YnBpY3R1cmUuaW5kZXhPZihwcm9wZXJ0aWVzLnBlcmNlbnQpICE9PSAtMSB8fCBzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllc1sncGVyLW1pbGxlJ10pICE9PSAtMSkpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA5Mic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihleHBvbmVudEV4aXN0cyAmJiAocGFydHMuZXhwb25lbnRQYXJ0Lmxlbmd0aCA9PT0gMCB8fCBwYXJ0cy5leHBvbmVudFBhcnQuc3BsaXQoJycpLmZpbHRlcihmdW5jdGlvbihjaGFyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY2ltYWxEaWdpdEZhbWlseS5pbmRleE9mKGNoYXIpID09PSAtMTtcbiAgICAgICAgICAgIH0pLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAnRDMwOTMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFja1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYW5hbHlzZSB0aGUgcGljdHVyZSBzdHJpbmcsIEYmTyA0LjcuNFxuICAgICAgICB2YXIgYW5hbHlzZSA9IGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgICAgICAgICB2YXIgZ2V0R3JvdXBpbmdQb3NpdGlvbnMgPSBmdW5jdGlvbihwYXJ0LCB0b0xlZnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwaW5nUG9zaXRpb24gPSBwYXJ0LmluZGV4T2YocHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10pO1xuICAgICAgICAgICAgICAgIHdoaWxlKGdyb3VwaW5nUG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFyc1RvVGhlUmlnaHQgPSAodG9MZWZ0ID8gcGFydC5zdWJzdHJpbmcoMCwgZ3JvdXBpbmdQb3NpdGlvbikgOiBwYXJ0LnN1YnN0cmluZyhncm91cGluZ1Bvc2l0aW9uKSkuc3BsaXQoJycpLmZpbHRlcihmdW5jdGlvbihjaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjaW1hbERpZ2l0RmFtaWx5LmluZGV4T2YoY2hhcikgIT09IC0xIHx8IGNoYXIgPT09IHByb3BlcnRpZXMuZGlnaXQ7XG4gICAgICAgICAgICAgICAgICAgIH0pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goY2hhcnNUb1RoZVJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBpbmdQb3NpdGlvbiA9IHBhcnRzLmludGVnZXJQYXJ0LmluZGV4T2YocHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10sIGdyb3VwaW5nUG9zaXRpb24gKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgaW50ZWdlclBhcnRHcm91cGluZ1Bvc2l0aW9ucyA9IGdldEdyb3VwaW5nUG9zaXRpb25zKHBhcnRzLmludGVnZXJQYXJ0KTtcbiAgICAgICAgICAgIHZhciByZWd1bGFyID0gZnVuY3Rpb24oaW5kZXhlcykge1xuICAgICAgICAgICAgICAgIC8vIGFyZSB0aGUgZ3JvdXBpbmcgcG9zaXRpb25zIHJlZ3VsYXI/IGkuZS4gc2FtZSBpbnRlcnZhbCBiZXR3ZWVuIGVhY2ggb2YgdGhlbVxuICAgICAgICAgICAgICAgIGlmKGluZGV4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZ2NkID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYiA9PT0gMCA/IGEgOiBnY2QoYiwgYSAlIGIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgZ3JlYXRlc3QgY29tbW9uIGRpdmlzb3Igb2YgYWxsIHRoZSBwb3NpdGlvbnNcbiAgICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gaW5kZXhlcy5yZWR1Y2UoZ2NkKTtcbiAgICAgICAgICAgICAgICAvLyBpcyBldmVyeSBwb3NpdGlvbiBzZXBhcmF0ZWQgYnkgdGhpcyBkaXZpc29yPyBJZiBzbywgaXQncyByZWd1bGFyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpbmRleCA9IDE7IGluZGV4IDw9IGluZGV4ZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGluZGV4ZXMuaW5kZXhPZihpbmRleCAqIGZhY3RvcikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFjdG9yO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHJlZ3VsYXJHcm91cGluZyA9IHJlZ3VsYXIoaW50ZWdlclBhcnRHcm91cGluZ1Bvc2l0aW9ucyk7XG4gICAgICAgICAgICB2YXIgZnJhY3Rpb25hbFBhcnRHcm91cGluZ1Bvc2l0aW9ucyA9IGdldEdyb3VwaW5nUG9zaXRpb25zKHBhcnRzLmZyYWN0aW9uYWxQYXJ0LCB0cnVlKTtcblxuICAgICAgICAgICAgdmFyIG1pbmltdW1JbnRlZ2VyUGFydFNpemUgPSBwYXJ0cy5pbnRlZ2VyUGFydC5zcGxpdCgnJykuZmlsdGVyKGZ1bmN0aW9uKGNoYXIpIHsgcmV0dXJuIGRlY2ltYWxEaWdpdEZhbWlseS5pbmRleE9mKGNoYXIpICE9PSAtMTsgfSkubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHNjYWxpbmdGYWN0b3IgPSBtaW5pbXVtSW50ZWdlclBhcnRTaXplO1xuXG4gICAgICAgICAgICB2YXIgZnJhY3Rpb25hbFBhcnRBcnJheSA9IHBhcnRzLmZyYWN0aW9uYWxQYXJ0LnNwbGl0KCcnKTtcbiAgICAgICAgICAgIHZhciBtaW5pbXVtRmFjdGlvbmFsUGFydFNpemUgPSBmcmFjdGlvbmFsUGFydEFycmF5LmZpbHRlcihmdW5jdGlvbihjaGFyKSB7IHJldHVybiBkZWNpbWFsRGlnaXRGYW1pbHkuaW5kZXhPZihjaGFyKSAhPT0gLTE7IH0pLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBtYXhpbXVtRmFjdGlvbmFsUGFydFNpemUgPSBmcmFjdGlvbmFsUGFydEFycmF5LmZpbHRlcihmdW5jdGlvbihjaGFyKSB7IHJldHVybiBkZWNpbWFsRGlnaXRGYW1pbHkuaW5kZXhPZihjaGFyKSAhPT0gLTEgfHwgY2hhciA9PT0gcHJvcGVydGllcy5kaWdpdDsgfSkubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGV4cG9uZW50UHJlc2VudCA9IHR5cGVvZiBwYXJ0cy5leHBvbmVudFBhcnQgPT09ICdzdHJpbmcnO1xuICAgICAgICAgICAgaWYobWluaW11bUludGVnZXJQYXJ0U2l6ZSA9PT0gMCAmJiBtYXhpbXVtRmFjdGlvbmFsUGFydFNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZihleHBvbmVudFByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bUZhY3Rpb25hbFBhcnRTaXplID0gMTtcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bUZhY3Rpb25hbFBhcnRTaXplID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtSW50ZWdlclBhcnRTaXplID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihleHBvbmVudFByZXNlbnQgJiYgbWluaW11bUludGVnZXJQYXJ0U2l6ZSA9PT0gMCAmJiBwYXJ0cy5pbnRlZ2VyUGFydC5pbmRleE9mKHByb3BlcnRpZXMuZGlnaXQpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIG1pbmltdW1JbnRlZ2VyUGFydFNpemUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYobWluaW11bUludGVnZXJQYXJ0U2l6ZSA9PT0gMCAmJiBtaW5pbXVtRmFjdGlvbmFsUGFydFNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtaW5pbXVtRmFjdGlvbmFsUGFydFNpemUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1pbmltdW1FeHBvbmVudFNpemUgPSAwO1xuICAgICAgICAgICAgaWYoZXhwb25lbnRQcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgbWluaW11bUV4cG9uZW50U2l6ZSA9IHBhcnRzLmV4cG9uZW50UGFydC5zcGxpdCgnJykuZmlsdGVyKGZ1bmN0aW9uKGNoYXIpIHsgcmV0dXJuIGRlY2ltYWxEaWdpdEZhbWlseS5pbmRleE9mKGNoYXIpICE9PSAtMTsgfSkubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGludGVnZXJQYXJ0R3JvdXBpbmdQb3NpdGlvbnM6IGludGVnZXJQYXJ0R3JvdXBpbmdQb3NpdGlvbnMsXG4gICAgICAgICAgICAgICAgcmVndWxhckdyb3VwaW5nOiByZWd1bGFyR3JvdXBpbmcsXG4gICAgICAgICAgICAgICAgbWluaW11bUludGVnZXJQYXJ0U2l6ZTogbWluaW11bUludGVnZXJQYXJ0U2l6ZSxcbiAgICAgICAgICAgICAgICBzY2FsaW5nRmFjdG9yOiBzY2FsaW5nRmFjdG9yLFxuICAgICAgICAgICAgICAgIHByZWZpeDogcGFydHMucHJlZml4LFxuICAgICAgICAgICAgICAgIGZyYWN0aW9uYWxQYXJ0R3JvdXBpbmdQb3NpdGlvbnM6IGZyYWN0aW9uYWxQYXJ0R3JvdXBpbmdQb3NpdGlvbnMsXG4gICAgICAgICAgICAgICAgbWluaW11bUZhY3Rpb25hbFBhcnRTaXplOiBtaW5pbXVtRmFjdGlvbmFsUGFydFNpemUsXG4gICAgICAgICAgICAgICAgbWF4aW11bUZhY3Rpb25hbFBhcnRTaXplOiBtYXhpbXVtRmFjdGlvbmFsUGFydFNpemUsXG4gICAgICAgICAgICAgICAgbWluaW11bUV4cG9uZW50U2l6ZTogbWluaW11bUV4cG9uZW50U2l6ZSxcbiAgICAgICAgICAgICAgICBzdWZmaXg6IHBhcnRzLnN1ZmZpeCxcbiAgICAgICAgICAgICAgICBwaWN0dXJlOiBwYXJ0cy5zdWJwaWN0dXJlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwYXJ0cyA9IHN1YlBpY3R1cmVzLm1hcChzcGxpdFBhcnRzKTtcbiAgICAgICAgcGFydHMuZm9yRWFjaCh2YWxpZGF0ZSk7XG5cbiAgICAgICAgdmFyIHZhcmlhYmxlcyA9IHBhcnRzLm1hcChhbmFseXNlKTtcblxuICAgICAgICBpZih2YXJpYWJsZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB2YXJpYWJsZXMucHVzaChKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhcmlhYmxlc1swXSkpKTtcbiAgICAgICAgICAgIHZhcmlhYmxlc1sxXS5wcmVmaXggPSBwcm9wZXJ0aWVzWydtaW51cy1zaWduJ10gKyB2YXJpYWJsZXNbMV0ucHJlZml4O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETyBjYWNoZSB0aGUgcmVzdWx0IG9mIHRoZSBhbmFseXNpc1xuXG4gICAgICAgIC8vIGZvcm1hdCB0aGUgbnVtYmVyXG4gICAgICAgIC8vIGJ1bGxldCAxOiBUT0RPOiBOYU4gLSBub3Qgc3VyZSB3ZSdkIGV2ZXIgZ2V0IHRoaXMgaW4gSlNPTlxuICAgICAgICB2YXIgcGljO1xuICAgICAgICAvLyBidWxsZXQgMjpcbiAgICAgICAgaWYodmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgcGljID0gdmFyaWFibGVzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGljID0gdmFyaWFibGVzWzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhZGp1c3RlZE51bWJlcjtcbiAgICAgICAgLy8gYnVsbGV0IDM6XG4gICAgICAgIGlmKHBpYy5waWN0dXJlLmluZGV4T2YocHJvcGVydGllcy5wZXJjZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFkanVzdGVkTnVtYmVyID0gdmFsdWUgKiAxMDA7XG4gICAgICAgIH0gZWxzZSBpZihwaWMucGljdHVyZS5pbmRleE9mKHByb3BlcnRpZXNbJ3Blci1taWxsZSddKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFkanVzdGVkTnVtYmVyID0gdmFsdWUgKiAxMDAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRqdXN0ZWROdW1iZXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBidWxsZXQgNDpcbiAgICAgICAgLy8gVE9ETzogaW5maW5pdHkgLSBub3Qgc3VyZSB3ZSdkIGV2ZXIgZ2V0IHRoaXMgaW4gSlNPTlxuICAgICAgICAvLyBidWxsZXQgNTpcbiAgICAgICAgdmFyIG1hbnRpc3NhLCBleHBvbmVudDtcbiAgICAgICAgaWYocGljLm1pbmltdW1FeHBvbmVudFNpemUgPT09IDApIHtcbiAgICAgICAgICAgIG1hbnRpc3NhID0gYWRqdXN0ZWROdW1iZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBtYW50aXNzYSAqIDEwXmV4cG9uZW50ID0gYWRqdXN0ZWROdW1iZXJcbiAgICAgICAgICAgIHZhciBtYXhNYW50aXNzYSA9IE1hdGgucG93KDEwLCBwaWMuc2NhbGluZ0ZhY3Rvcik7XG4gICAgICAgICAgICB2YXIgbWluTWFudGlzc2EgPSBNYXRoLnBvdygxMCwgcGljLnNjYWxpbmdGYWN0b3IgLSAxKTtcbiAgICAgICAgICAgIG1hbnRpc3NhID0gYWRqdXN0ZWROdW1iZXI7XG4gICAgICAgICAgICBleHBvbmVudCA9IDA7XG4gICAgICAgICAgICB3aGlsZShtYW50aXNzYSA8IG1pbk1hbnRpc3NhKSB7XG4gICAgICAgICAgICAgICAgbWFudGlzc2EgKj0gMTA7XG4gICAgICAgICAgICAgICAgZXhwb25lbnQgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlKG1hbnRpc3NhID4gbWF4TWFudGlzc2EpIHtcbiAgICAgICAgICAgICAgICBtYW50aXNzYSAvPSAxMDtcbiAgICAgICAgICAgICAgICBleHBvbmVudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGJ1bGxldCA2OlxuICAgICAgICB2YXIgcm91bmRlZE51bWJlciA9IGZ1bmN0aW9uUm91bmQobWFudGlzc2EsIHBpYy5tYXhpbXVtRmFjdGlvbmFsUGFydFNpemUpO1xuICAgICAgICAvLyBidWxsZXQgNzpcbiAgICAgICAgdmFyIG1ha2VTdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSwgZHApIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBNYXRoLmFicyh2YWx1ZSkudG9GaXhlZChkcCk7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllc1snemVyby1kaWdpdCddICE9PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJycpLm1hcChmdW5jdGlvbiAoZGlnaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoZGlnaXQgPj0gJzAnICYmIGRpZ2l0IDw9JzknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjaW1hbERpZ2l0RmFtaWx5W2RpZ2l0LmNoYXJDb2RlQXQoMCkgLSA0OF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlnaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IG1ha2VTdHJpbmcocm91bmRlZE51bWJlciwgcGljLm1heGltdW1GYWN0aW9uYWxQYXJ0U2l6ZSk7XG4gICAgICAgIHZhciBkZWNpbWFsUG9zID0gc3RyaW5nVmFsdWUuaW5kZXhPZignLicpO1xuICAgICAgICBpZihkZWNpbWFsUG9zID09PSAtMSkge1xuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZSArIHByb3BlcnRpZXNbJ2RlY2ltYWwtc2VwYXJhdG9yJ107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpbmdWYWx1ZSA9IHN0cmluZ1ZhbHVlLnJlcGxhY2UoJy4nLCBwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZShzdHJpbmdWYWx1ZS5jaGFyQXQoMCkgPT09IHByb3BlcnRpZXNbJ3plcm8tZGlnaXQnXSkge1xuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUoc3RyaW5nVmFsdWUuY2hhckF0KHN0cmluZ1ZhbHVlLmxlbmd0aCAtIDEpID09PSBwcm9wZXJ0aWVzWyd6ZXJvLWRpZ2l0J10pIHtcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gc3RyaW5nVmFsdWUuc3Vic3RyaW5nKDAsIHN0cmluZ1ZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ1bGxldHMgOCAmIDk6XG4gICAgICAgIGRlY2ltYWxQb3MgPSBzdHJpbmdWYWx1ZS5pbmRleE9mKHByb3BlcnRpZXNbJ2RlY2ltYWwtc2VwYXJhdG9yJ10pO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IHBpYy5taW5pbXVtSW50ZWdlclBhcnRTaXplIC0gZGVjaW1hbFBvcztcbiAgICAgICAgdmFyIHBhZFJpZ2h0ID0gcGljLm1pbmltdW1GYWN0aW9uYWxQYXJ0U2l6ZSAtIChzdHJpbmdWYWx1ZS5sZW5ndGggLSBkZWNpbWFsUG9zIC0gMSk7XG4gICAgICAgIHN0cmluZ1ZhbHVlID0gKHBhZExlZnQgPiAwID8gbmV3IEFycmF5KHBhZExlZnQgKyAxKS5qb2luKCcwJykgOiAnJykgKyBzdHJpbmdWYWx1ZTtcbiAgICAgICAgc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZSArIChwYWRSaWdodCA+IDAgPyBuZXcgQXJyYXkocGFkUmlnaHQgKyAxKS5qb2luKCcwJykgOiAnJyk7XG4gICAgICAgIGRlY2ltYWxQb3MgPSBzdHJpbmdWYWx1ZS5pbmRleE9mKHByb3BlcnRpZXNbJ2RlY2ltYWwtc2VwYXJhdG9yJ10pO1xuICAgICAgICAvLyBidWxsZXQgMTA6XG4gICAgICAgIGlmKHBpYy5yZWd1bGFyR3JvdXBpbmcgPiAwKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBDb3VudCA9IE1hdGguZmxvb3IoKGRlY2ltYWxQb3MgLSAxKSAvIHBpYy5yZWd1bGFyR3JvdXBpbmcpO1xuICAgICAgICAgICAgZm9yKHZhciBncm91cCA9IDE7IGdyb3VwIDw9IGdyb3VwQ291bnQ7IGdyb3VwKyspIHtcbiAgICAgICAgICAgICAgICBzdHJpbmdWYWx1ZSA9IFtzdHJpbmdWYWx1ZS5zbGljZSgwLCBkZWNpbWFsUG9zIC0gZ3JvdXAgKiBwaWMucmVndWxhckdyb3VwaW5nKSwgcHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10sIHN0cmluZ1ZhbHVlLnNsaWNlKGRlY2ltYWxQb3MgLSBncm91cCAqIHBpYy5yZWd1bGFyR3JvdXBpbmcpXS5qb2luKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBpYy5pbnRlZ2VyUGFydEdyb3VwaW5nUG9zaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gW3N0cmluZ1ZhbHVlLnNsaWNlKDAsIGRlY2ltYWxQb3MgLSBwb3MpLCBwcm9wZXJ0aWVzWydncm91cGluZy1zZXBhcmF0b3InXSwgc3RyaW5nVmFsdWUuc2xpY2UoZGVjaW1hbFBvcyAtIHBvcyldLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIGRlY2ltYWxQb3MrKztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ1bGxldCAxMTpcbiAgICAgICAgZGVjaW1hbFBvcyA9IHN0cmluZ1ZhbHVlLmluZGV4T2YocHJvcGVydGllc1snZGVjaW1hbC1zZXBhcmF0b3InXSk7XG4gICAgICAgIHBpYy5mcmFjdGlvbmFsUGFydEdyb3VwaW5nUG9zaXRpb25zLmZvckVhY2goZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgICAgICBzdHJpbmdWYWx1ZSA9IFtzdHJpbmdWYWx1ZS5zbGljZSgwLCBwb3MgKyBkZWNpbWFsUG9zICsgMSksIHByb3BlcnRpZXNbJ2dyb3VwaW5nLXNlcGFyYXRvciddLCBzdHJpbmdWYWx1ZS5zbGljZShwb3MgKyBkZWNpbWFsUG9zICsgMSldLmpvaW4oJycpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gYnVsbGV0IDEyOlxuICAgICAgICBkZWNpbWFsUG9zID0gc3RyaW5nVmFsdWUuaW5kZXhPZihwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddKTtcbiAgICAgICAgaWYocGljLnBpY3R1cmUuaW5kZXhPZihwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddKSA9PT0gLTEgfHwgZGVjaW1hbFBvcyA9PT0gc3RyaW5nVmFsdWUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZS5zdWJzdHJpbmcoMCwgc3RyaW5nVmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnVsbGV0IDEzOlxuICAgICAgICBpZih0eXBlb2YgZXhwb25lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YXIgc3RyaW5nRXhwb25lbnQgPSBtYWtlU3RyaW5nKGV4cG9uZW50LCAwKTtcbiAgICAgICAgICAgIHBhZExlZnQgPSBwaWMubWluaW11bUV4cG9uZW50U2l6ZSAtIHN0cmluZ0V4cG9uZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmKHBhZExlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nRXhwb25lbnQgPSBuZXcgQXJyYXkocGFkTGVmdCArIDEpLmpvaW4oJzAnKSArIHN0cmluZ0V4cG9uZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZSArIHByb3BlcnRpZXNbJ2V4cG9uZW50LXNlcGFyYXRvciddICsgKGV4cG9uZW50IDwgMCA/IHByb3BlcnRpZXNbJ21pbnVzLXNpZ24nXSA6ICcnKSArIHN0cmluZ0V4cG9uZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ1bGxldCAxNDpcbiAgICAgICAgc3RyaW5nVmFsdWUgPSBwaWMucHJlZml4ICsgc3RyaW5nVmFsdWUgKyBwaWMuc3VmZml4O1xuICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBudW1iZXIgdG8gYSBzdHJpbmcgdXNpbmcgYSBzcGVjaWZpZWQgbnVtYmVyIGJhc2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSB0aGUgbnVtYmVyIHRvIGNvbnZlcnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl4XSAtIHRoZSBudW1iZXIgYmFzZTsgbXVzdCBiZSBiZXR3ZWVuIDIgYW5kIDM2LiBEZWZhdWx0cyB0byAxMFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGNvbnZlcnRlZCBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkZvcm1hdEJhc2UodmFsdWUsIHJhZGl4KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gZnVuY3Rpb25Sb3VuZCh2YWx1ZSk7XG5cbiAgICAgICAgaWYodHlwZW9mIHJhZGl4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmFkaXggPSAxMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhZGl4ID0gZnVuY3Rpb25Sb3VuZChyYWRpeCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihyYWRpeCA8IDIgfHwgcmFkaXggPiAzNikge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6ICdEMzEwMCcsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJhZGl4XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gdmFsdWUudG9TdHJpbmcocmFkaXgpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdCBhcmd1bWVudCB0byBudW1iZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnIC0gQXJndW1lbnRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBudW1lcmljIHZhbHVlIG9mIGFyZ3VtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25OdW1iZXIoYXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gYWxyZWFkeSBhIG51bWJlclxuICAgICAgICAgICAgcmVzdWx0ID0gYXJnO1xuICAgICAgICB9IGVsc2UgaWYodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgJiYgL14tPygwfChbMS05XVswLTldKikpKFxcLlswLTldKyk/KFtFZV1bLStdP1swLTldKyk/JC8udGVzdChhcmcpICYmICFpc05hTihwYXJzZUZsb2F0KGFyZykpICYmIGlzRmluaXRlKGFyZykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlRmxvYXQoYXJnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMDMwXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGFyZyxcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICBpbmRleDogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFic29sdXRlIHZhbHVlIG9mIGEgbnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZyAtIEFyZ3VtZW50XG4gICAgICogQHJldHVybnMge051bWJlcn0gYWJzb2x1dGUgdmFsdWUgb2YgYXJndW1lbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkFicyhhcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gTWF0aC5hYnMoYXJnKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3VuZHMgYSBudW1iZXIgZG93biB0byBpbnRlZ2VyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZyAtIEFyZ3VtZW50XG4gICAgICogQHJldHVybnMge051bWJlcn0gcm91bmRlZCBpbnRlZ2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25GbG9vcihhcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gTWF0aC5mbG9vcihhcmcpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJvdW5kcyBhIG51bWJlciB1cCB0byBpbnRlZ2VyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZyAtIEFyZ3VtZW50XG4gICAgICogQHJldHVybnMge051bWJlcn0gcm91bmRlZCBpbnRlZ2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25DZWlsKGFyZykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBNYXRoLmNlaWwoYXJnKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3VuZCB0byBoYWxmIGV2ZW5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJnIC0gQXJndW1lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJlY2lzaW9uIC0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gICAgICogQHJldHVybnMge051bWJlcn0gcm91bmRlZCBpbnRlZ2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Sb3VuZChhcmcsIHByZWNpc2lvbikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihwcmVjaXNpb24pIHtcbiAgICAgICAgICAgIC8vIHNoaWZ0IHRoZSBkZWNpbWFsIHBsYWNlIC0gdGhpcyBuZWVkcyB0byBiZSBkb25lIGluIGEgc3RyaW5nIHNpbmNlIG11bHRpcGx5aW5nXG4gICAgICAgICAgICAvLyBieSBhIHBvd2VyIG9mIHRlbiBjYW4gaW50cm9kdWNlIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBlcnJvcnMgd2hpY2ggbWVzcyB1cFxuICAgICAgICAgICAgLy8gdGhpcyByb3VuZGluZyBhbGdvcml0aG0gLSBTZWUgJ0RlY2ltYWwgcm91bmRpbmcnIGluXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3JvdW5kXG4gICAgICAgICAgICAvLyBTaGlmdFxuICAgICAgICAgICAgdmFyIHZhbHVlID0gYXJnLnRvU3RyaW5nKCkuc3BsaXQoJ2UnKTtcbiAgICAgICAgICAgIGFyZyA9ICsodmFsdWVbMF0gKyAnZScgKyAodmFsdWVbMV0gPyAoK3ZhbHVlWzFdICsgcHJlY2lzaW9uKSA6IHByZWNpc2lvbikpO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyByb3VuZCB1cCB0byBuZWFyZXN0IGludFxuICAgICAgICByZXN1bHQgPSBNYXRoLnJvdW5kKGFyZyk7XG4gICAgICAgIHZhciBkaWZmID0gcmVzdWx0IC0gYXJnO1xuICAgICAgICBpZihNYXRoLmFicyhkaWZmKSA9PT0gMC41ICYmIE1hdGguYWJzKHJlc3VsdCAlIDIpID09PSAxKSB7XG4gICAgICAgICAgICAvLyByb3VuZGVkIHRoZSB3cm9uZyB3YXkgLSBhZGp1c3QgdG8gbmVhcmVzdCBldmVuIG51bWJlclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0IC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZihwcmVjaXNpb24pIHtcbiAgICAgICAgICAgIC8vIFNoaWZ0IGJhY2tcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0LnRvU3RyaW5nKCkuc3BsaXQoJ2UnKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICByZXN1bHQgPSArKHZhbHVlWzBdICsgJ2UnICsgKHZhbHVlWzFdID8gKCt2YWx1ZVsxXSAtIHByZWNpc2lvbikgOiAtcHJlY2lzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoT2JqZWN0LmlzKHJlc3VsdCwgLTApKSB7IC8vIEVTTGludCBydWxlICduby1jb21wYXJlLW5lZy16ZXJvJyBzdWdnZXN0cyB0aGlzIHdheVxuICAgICAgICAgICAgLy8gSlNPTiBkb2Vzbid0IGRvIC0wXG4gICAgICAgICAgICByZXN1bHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3F1YXJlIHJvb3Qgb2YgbnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZyAtIEFyZ3VtZW50XG4gICAgICogQHJldHVybnMge051bWJlcn0gc3F1YXJlIHJvb3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblNxcnQoYXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGFyZyA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMDYwXCIsXG4gICAgICAgICAgICAgICAgaW5kZXg6IDEsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGFyZ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IE1hdGguc3FydChhcmcpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmFpc2VzIG51bWJlciB0byB0aGUgcG93ZXIgb2YgdGhlIHNlY29uZCBudW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXJnIC0gdGhlIGJhc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZXhwIC0gdGhlIGV4cG9uZW50XG4gICAgICogQHJldHVybnMge051bWJlcn0gcm91bmRlZCBpbnRlZ2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Qb3dlcihhcmcsIGV4cCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBNYXRoLnBvdyhhcmcsIGV4cCk7XG5cbiAgICAgICAgaWYoIWlzRmluaXRlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMDYxXCIsXG4gICAgICAgICAgICAgICAgaW5kZXg6IDEsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGFyZyxcbiAgICAgICAgICAgICAgICBleHA6IGV4cFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSBudW1iZXIgMCA8PSBuIDwgMVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHJhbmRvbSBudW1iZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblJhbmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgYW4gaW5wdXQgYW5kIHJldHVybiBhIGJvb2xlYW5cbiAgICAgKiBAcGFyYW0geyp9IGFyZyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBCb29sZWFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Cb29sZWFuKGFyZykge1xuICAgICAgICAvLyBjYXN0IGFyZyB0byBpdHMgZWZmZWN0aXZlIGJvb2xlYW4gdmFsdWVcbiAgICAgICAgLy8gYm9vbGVhbjogdW5jaGFuZ2VkXG4gICAgICAgIC8vIHN0cmluZzogemVyby1sZW5ndGggLT4gZmFsc2U7IG90aGVyd2lzZSAtPiB0cnVlXG4gICAgICAgIC8vIG51bWJlcjogMCAtPiBmYWxzZTsgb3RoZXJ3aXNlIC0+IHRydWVcbiAgICAgICAgLy8gbnVsbCAtPiBmYWxzZVxuICAgICAgICAvLyBhcnJheTogZW1wdHkgLT4gZmFsc2U7IGxlbmd0aCA+IDEgLT4gdHJ1ZVxuICAgICAgICAvLyBvYmplY3Q6IGVtcHR5IC0+IGZhbHNlOyBub24tZW1wdHkgLT4gdHJ1ZVxuICAgICAgICAvLyBmdW5jdGlvbiAtPiBmYWxzZVxuXG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuY3Rpb25Cb29sZWFuKGFyZ1swXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRydWVzID0gYXJnLmZpbHRlcihmdW5jdGlvbih2YWwpIHtyZXR1cm4gZnVuY3Rpb25Cb29sZWFuKHZhbCk7fSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZXMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGFyZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc051bWVyaWMoYXJnKSkge1xuICAgICAgICAgICAgaWYgKGFyZyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYXJnICE9PSBudWxsICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYXJnKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGl0J3Mgbm90IGEgbGFtYmRhIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKCEoaXNMYW1iZGEoYXJnKSB8fCBhcmcuX2pzb25hdGFfZnVuY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyAmJiBhcmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBCb29sZWFuIE5PVCBvZiB0aGUgYXJnXG4gICAgICogQHBhcmFtIHsqfSBhcmcgLSBhcmd1bWVudFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIE5PVCBhcmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbk5vdChhcmcpIHtcbiAgICAgICAgcmV0dXJuICFmdW5jdGlvbkJvb2xlYW4oYXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBtYXAgZnJvbSBhbiBhcnJheSBvZiBhcmd1bWVudHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyXSAtIGFycmF5IHRvIG1hcCBvdmVyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIGZ1bmN0aW9uIHRvIGFwcGx5XG4gICAgICogQHJldHVybnMge0FycmF5fSBNYXAgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZnVuY3Rpb25NYXAoYXJyLCBmdW5jKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIC8vIGRvIHRoZSBtYXAgLSBpdGVyYXRlIG92ZXIgdGhlIGFycmF5cywgYW5kIGludm9rZSBmdW5jXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZnVuY19hcmdzID0gW2FycltpXV07IC8vIHRoZSBmaXJzdCBhcmcgKHZhbHVlKSBpcyByZXF1aXJlZFxuICAgICAgICAgICAgLy8gdGhlIG90aGVyIHR3byBhcmUgb3B0aW9uYWwgLSBvbmx5IHN1cHBseSBpdCBpZiB0aGUgZnVuY3Rpb24gY2FuIHRha2UgaXRcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmMubGVuZ3RoIDpcbiAgICAgICAgICAgICAgICBmdW5jLl9qc29uYXRhX2Z1bmN0aW9uID09PSB0cnVlID8gZnVuYy5pbXBsZW1lbnRhdGlvbi5sZW5ndGggOiBmdW5jLmFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBpZihsZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgIGZ1bmNfYXJncy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYobGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICAgICBmdW5jX2FyZ3MucHVzaChhcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW52b2tlIGZ1bmNcbiAgICAgICAgICAgIHZhciByZXMgPSB5aWVsZCAqIGFwcGx5KGZ1bmMsIGZ1bmNfYXJncywgbnVsbCk7XG4gICAgICAgICAgICBpZih0eXBlb2YgcmVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFRoaXMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGRvZXMgbm90IGhhdmUgYSB5aWVsZCgpLCBwcmVzdW1hYmx5IHRvIG1ha2UgaXRcbiAgICAvLyBjb25zaXN0ZW50IHdpdGggb3RoZXIgc2ltaWxhciBmdW5jdGlvbnMuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbWFwIGZyb20gYW4gYXJyYXkgb2YgYXJndW1lbnRzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2Fycl0gLSBhcnJheSB0byBmaWx0ZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gcHJlZGljYXRlIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge0FycmF5fSBNYXAgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZnVuY3Rpb25GaWx0ZXIoYXJyLCBmdW5jKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS15aWVsZFxuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcnIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIHZhciBwcmVkaWNhdGUgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBhcnJheSkge1xuICAgICAgICAgICAgdmFyIGl0ID0gYXBwbHkoZnVuYywgW3ZhbHVlLCBpbmRleCwgYXJyYXldLCBudWxsKTtcbiAgICAgICAgICAgIC8vIHJldHVybnMgYSBnZW5lcmF0b3IgLSBzbyBpdGVyYXRlIG92ZXIgaXRcbiAgICAgICAgICAgIHZhciByZXMgPSBpdC5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoIXJlcy5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gaXQubmV4dChyZXMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBhcnJbaV07XG4gICAgICAgICAgICBpZihmdW5jdGlvbkJvb2xlYW4ocHJlZGljYXRlKGVudHJ5LCBpLCBhcnIpKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udm9sdmVzICh6aXBzKSBlYWNoIHZhbHVlIGZyb20gYSBzZXQgb2YgYXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdIC0gYXJyYXlzIHRvIHppcFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gWmlwcGVkIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25aaXAoKSB7XG4gICAgICAgIC8vIHRoaXMgY2FuIHRha2UgYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAvLyBsZW5ndGggb2YgdGhlIHNob3J0ZXN0IGFycmF5XG4gICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbi5hcHBseShNYXRoLCBhcmdzLm1hcChmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmcubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdHVwbGUgPSBhcmdzLm1hcCgoYXJnKSA9PiB7cmV0dXJuIGFyZ1tpXTt9KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHR1cGxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvbGQgbGVmdCBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNlcXVlbmNlIC0gU2VxdWVuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5pdCAtIEluaXRpYWwgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0XG4gICAgICovXG4gICAgZnVuY3Rpb24qIGZ1bmN0aW9uRm9sZExlZnQoc2VxdWVuY2UsIGZ1bmMsIGluaXQpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc2VxdWVuY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBpZiAoIShmdW5jLmxlbmd0aCA9PT0gMiB8fCAoZnVuYy5fanNvbmF0YV9mdW5jdGlvbiA9PT0gdHJ1ZSAmJiBmdW5jLmltcGxlbWVudGF0aW9uLmxlbmd0aCA9PT0gMikgfHwgZnVuYy5hcmd1bWVudHMubGVuZ3RoID09PSAyKSkge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgIGNvZGU6IFwiRDMwNTBcIixcbiAgICAgICAgICAgICAgICBpbmRleDogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbml0ID09PSAndW5kZWZpbmVkJyAmJiBzZXF1ZW5jZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzZXF1ZW5jZVswXTtcbiAgICAgICAgICAgIGluZGV4ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGluaXQ7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBzZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogYXBwbHkoZnVuYywgW3Jlc3VsdCwgc2VxdWVuY2VbaW5kZXhdXSwgbnVsbCk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4ga2V5cyBmb3IgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZyAtIE9iamVjdFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2Yga2V5c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uS2V5cyhhcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgLy8gbWVyZ2UgdGhlIGtleXMgb2YgYWxsIG9mIHRoZSBpdGVtcyBpbiB0aGUgYXJyYXlcbiAgICAgICAgICAgIHZhciBtZXJnZSA9IHt9O1xuICAgICAgICAgICAgYXJnLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gZnVuY3Rpb25LZXlzKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2Vba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuY3Rpb25LZXlzKG1lcmdlKTtcbiAgICAgICAgfSBlbHNlIGlmKGFyZyAhPT0gbnVsbCAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAhKGlzTGFtYmRhKGFyZykpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBPYmplY3Qua2V5cyhhcmcpO1xuICAgICAgICAgICAgaWYocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB2YWx1ZSBmcm9tIGFuIG9iamVjdCBmb3IgYSBnaXZlbiBrZXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gT2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIEtleSBpbiBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7Kn0gVmFsdWUgb2Yga2V5IGluIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uTG9va3VwKG9iamVjdCwga2V5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBldmFsdWF0ZU5hbWUoe3ZhbHVlOiBrZXl9LCBvYmplY3QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGVuZCBzZWNvbmQgYXJndW1lbnQgdG8gZmlyc3RcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gYXJnMSAtIEZpcnN0IGFyZ3VtZW50XG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGFyZzIgLSBTZWNvbmQgYXJndW1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gQXBwZW5kZWQgYXJndW1lbnRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25BcHBlbmQoYXJnMSwgYXJnMikge1xuICAgICAgICAvLyBkaXNyZWdhcmQgdW5kZWZpbmVkIGFyZ3NcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZzI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZzE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgZWl0aGVyIGFyZ3VtZW50IGlzIG5vdCBhbiBhcnJheSwgbWFrZSBpdCBzb1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgICAgIGFyZzEgPSBbYXJnMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZzIpKSB7XG4gICAgICAgICAgICBhcmcyID0gW2FyZzJdO1xuICAgICAgICB9XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGFyZzEsIGFyZzIpO1xuICAgICAgICByZXR1cm4gYXJnMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBhcmd1bWVudCBpcyB1bmRlZmluZWRcbiAgICAgKiBAcGFyYW0geyp9IGFyZyAtIGFyZ3VtZW50XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IEZhbHNlIGlmIGFyZ3VtZW50IHVuZGVmaW5lZCwgb3RoZXJ3aXNlIHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkV4aXN0cyhhcmcpe1xuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGFuIG9iamVjdCBpbnRvIGFuIGFycmF5IG9mIG9iamVjdCB3aXRoIG9uZSBwcm9wZXJ0eSBlYWNoXG4gICAgICogQHBhcmFtIHsqfSBhcmcgLSB0aGUgb2JqZWN0IHRvIHNwbGl0XG4gICAgICogQHJldHVybnMgeyp9IC0gdGhlIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25TcHJlYWQoYXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZihBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgIC8vIHNwcmVhZCBhbGwgb2YgdGhlIGl0ZW1zIGluIHRoZSBhcnJheVxuICAgICAgICAgICAgYXJnLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uQXBwZW5kKHJlc3VsdCwgZnVuY3Rpb25TcHJlYWQoaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZihhcmcgIT09IG51bGwgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgIWlzTGFtYmRhKGFyZykpIHtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIGFyZykge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IGFyZ1trZXldO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhcmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIGEgc2luZ2xlIG9iamVjdC4gIER1cGxpY2F0ZSBwcm9wZXJ0aWVzIGFyZVxuICAgICAqIG92ZXJyaWRkZW4gYnkgZW50cmllcyBsYXRlciBpbiB0aGUgYXJyYXlcbiAgICAgKiBAcGFyYW0geyp9IGFyZyAtIHRoZSBvYmplY3RzIHRvIG1lcmdlXG4gICAgICogQHJldHVybnMgeyp9IC0gdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uTWVyZ2UoYXJnKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgICAgYXJnLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBmb3IodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyB0aGUgb3JkZXIgb2YgaXRlbXMgaW4gYW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgLSB0aGUgYXJyYXkgdG8gcmV2ZXJzZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gLSB0aGUgcmV2ZXJzZWQgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblJldmVyc2UoYXJyKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihhcnIubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtsZW5ndGggLSBpIC0gMV0gPSBhcnJbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBvYmogLSB0aGUgaW5wdXQgb2JqZWN0IHRvIGl0ZXJhdGUgb3ZlclxuICAgICAqIEBwYXJhbSB7Kn0gZnVuYyAtIHRoZSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGtleS92YWx1ZSBwYWlyXG4gICAgICogQHJldHVybnMge0FycmF5fSAtIHRoZSByZXN1bHRhbnQgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZnVuY3Rpb25FYWNoKG9iaiwgZnVuYykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgZm9yKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICB2YXIgZnVuY19hcmdzID0gW29ialtrZXldLCBrZXldO1xuICAgICAgICAgICAgLy8gaW52b2tlIGZ1bmNcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHlpZWxkICogYXBwbHkoZnVuYywgZnVuY19hcmdzLCBudWxsKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgdGhlIG1lcmdlIHNvcnQgKHN0YWJsZSkgd2l0aCBvcHRpb25hbCBjb21wYXJhdG9yIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgLSB0aGUgYXJyYXkgdG8gc29ydFxuICAgICAqIEBwYXJhbSB7Kn0gY29tcGFyYXRvciAtIGNvbXBhcmF0b3IgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IC0gc29ydGVkIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Tb3J0KGFyciwgY29tcGFyYXRvcikge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcnIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYXJyLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbXA7XG4gICAgICAgIGlmKHR5cGVvZiBjb21wYXJhdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gaW5qZWN0IGEgZGVmYXVsdCBjb21wYXJhdG9yIC0gb25seSB3b3JrcyBmb3IgbnVtZXJpYyBvciBzdHJpbmcgYXJyYXlzXG4gICAgICAgICAgICBpZiAoIWlzQXJyYXlPZk51bWJlcnMoYXJyKSAmJiAhaXNBcnJheU9mU3RyaW5ncyhhcnIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJEMzA3MFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogMVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbXAgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhID4gYjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZih0eXBlb2YgY29tcGFyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZm9yIGludGVybmFsIHVzYWdlIG9mIGZ1bmN0aW9uU29ydCAoaS5lLiBvcmRlci1ieSBzeW50YXgpXG4gICAgICAgICAgICBjb21wID0gY29tcGFyYXRvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXAgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBpdCA9IGFwcGx5KGNvbXBhcmF0b3IsIFthLCBiXSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJucyBhIGdlbmVyYXRvciAtIHNvIGl0ZXJhdGUgb3ZlciBpdFxuICAgICAgICAgICAgICAgIHZhciBjb21wID0gaXQubmV4dCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlICghY29tcC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXAgPSBpdC5uZXh0KGNvbXAudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcC52YWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWVyZ2UgPSBmdW5jdGlvbihsLCByKSB7XG4gICAgICAgICAgICB2YXIgbWVyZ2VfaXRlciA9IGZ1bmN0aW9uKHJlc3VsdCwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVmdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyaWdodC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocmVzdWx0LCBsZWZ0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbXAobGVmdFswXSwgcmlnaHRbMF0pKSB7IC8vIGludm9rZSB0aGUgY29tcGFyYXRvciBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCByZXR1cm5zIHRydWUgLSBzd2FwIGxlZnQgYW5kIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJpZ2h0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VfaXRlcihyZXN1bHQsIGxlZnQsIHJpZ2h0LnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Uga2VlcCB0aGUgc2FtZSBvcmRlclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsZWZ0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VfaXRlcihyZXN1bHQsIGxlZnQuc2xpY2UoMSksIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG1lcmdlZCA9IFtdO1xuICAgICAgICAgICAgbWVyZ2VfaXRlcihtZXJnZWQsIGwsIHIpO1xuICAgICAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc29ydCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgICAgICBpZihhcnJheS5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IoYXJyYXkubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBhcnJheS5zbGljZSgwLCBtaWRkbGUpO1xuICAgICAgICAgICAgICAgIHZhciByaWdodCA9IGFycmF5LnNsaWNlKG1pZGRsZSk7XG4gICAgICAgICAgICAgICAgbGVmdCA9IHNvcnQobGVmdCk7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBzb3J0KHJpZ2h0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2UobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBzb3J0KGFycik7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSYW5kb21seSBzaHVmZmxlcyB0aGUgY29udGVudHMgb2YgYW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgLSB0aGUgaW5wdXQgYXJyYXlcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBzaHVmZmxlZCBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU2h1ZmZsZShhcnIpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGFyci5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNodWZmbGUgdXNpbmcgdGhlICdpbnNpZGUtb3V0JyB2YXJpYW50IG9mIHRoZSBGaXNoZXItWWF0ZXMgYWxnb3JpdGhtXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7IC8vIHJhbmRvbSBpbnRlZ2VyIHN1Y2ggdGhhdCAwIOKJpCBqIOKJpCBpXG4gICAgICAgICAgICBpZihpICE9PSBqKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gcmVzdWx0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2pdID0gYXJyW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gYW4gb2JqZWN0LCBhbmQgcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZ1xuICAgICAqIG9ubHkgdGhlIGtleS92YWx1ZSBwYWlycyB0aGF0IHBhc3NlZCB0aGUgcHJlZGljYXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXJnIC0gdGhlIG9iamVjdCB0byBiZSBzaWZ0ZWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZnVuYyAtIHRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gKGxhbWJkYSBvciBuYXRpdmUpXG4gICAgICogQHJldHVybnMge29iamVjdH0gLSBzaWZ0ZWQgb2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25TaWZ0KGFyZywgZnVuYykge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgICAgdmFyIHByZWRpY2F0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBpdCA9IGFwcGx5KGZ1bmMsIFt2YWx1ZSwga2V5LCBvYmplY3RdLCBudWxsKTtcbiAgICAgICAgICAgIC8vIHJldHVybnMgYSBnZW5lcmF0b3IgLSBzbyBpdGVyYXRlIG92ZXIgaXRcbiAgICAgICAgICAgIHZhciByZXMgPSBpdC5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoIXJlcy5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gaXQubmV4dChyZXMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IodmFyIGl0ZW0gaW4gYXJnKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBhcmdbaXRlbV07XG4gICAgICAgICAgICBpZihmdW5jdGlvbkJvb2xlYW4ocHJlZGljYXRlKGVudHJ5LCBpdGVtLCBhcmcpKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpdGVtXSA9IGVudHJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW1wdHkgb2JqZWN0cyBzaG91bGQgYmUgY2hhbmdlZCB0byB1bmRlZmluZWRcbiAgICAgICAgaWYoT2JqZWN0LmtleXMocmVzdWx0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gUmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIGFuIElTTyA4NjAxIGZvcm1hdHRlZCB0aW1lc3RhbXBcbiAgICB2YXIgaXNvODYwMXJlZ2V4ID0gbmV3IFJlZ0V4cCgnXlxcXFxkezR9LVswMV1cXFxcZC1bMC0zXVxcXFxkVFswLTJdXFxcXGQ6WzAtNV1cXFxcZDpbMC01XVxcXFxkXFxcXC5cXFxcZCsoWystXVswLTJdXFxcXGQ6WzAtNV1cXFxcZHxaKSQnKTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIElTTyA4NjAxIHRpbWVzdGFtcCB0byBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGVwb2NoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGltZXN0YW1wIC0gdGhlIElTTyA4NjAxIHRpbWVzdGFtcCB0byBiZSBjb252ZXJ0ZWRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSAtIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2hcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblRvTWlsbGlzKHRpbWVzdGFtcCkge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiB0aW1lc3RhbXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWlzbzg2MDFyZWdleC50ZXN0KHRpbWVzdGFtcCkpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMTEwXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRpbWVzdGFtcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBEYXRlLnBhcnNlKHRpbWVzdGFtcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaCB0byBhbiBJU08gODYwMSB0aW1lc3RhbXBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWlsbGlzIC0gbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaCB0byBiZSBjb252ZXJ0ZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSAtIGFuIElTTyA4NjAxIGZvcm1hdHRlZCB0aW1lc3RhbXBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkZyb21NaWxsaXMobWlsbGlzKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIG1pbGxpcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERhdGUobWlsbGlzKS50b0lTT1N0cmluZygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb25lcyBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnIC0gb2JqZWN0IHRvIGNsb25lIChkZWVwIGNvcHkpXG4gICAgICogQHJldHVybnMgeyp9IC0gdGhlIGNsb25lZCBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkNsb25lKGFyZykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZnVuY3Rpb25TdHJpbmcoYXJnKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGZyYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVuY2xvc2luZ0Vudmlyb25tZW50IC0gRW5jbG9zaW5nIGVudmlyb25tZW50XG4gICAgICogQHJldHVybnMge3tiaW5kOiBiaW5kLCBsb29rdXA6IGxvb2t1cH19IENyZWF0ZWQgZnJhbWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGcmFtZShlbmNsb3NpbmdFbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgYmluZGluZ3MgPSB7fTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJpbmQ6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGJpbmRpbmdzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9va3VwOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZihiaW5kaW5ncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJpbmRpbmdzW25hbWVdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5jbG9zaW5nRW52aXJvbm1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlbmNsb3NpbmdFbnZpcm9ubWVudC5sb29rdXAobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBGdW5jdGlvbiByZWdpc3RyYXRpb25cbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdzdW0nLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblN1bSwgJzxhPG4+Om4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2NvdW50JywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Db3VudCwgJzxhOm4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ21heCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uTWF4LCAnPGE8bj46bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnbWluJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25NaW4sICc8YTxuPjpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdhdmVyYWdlJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25BdmVyYWdlLCAnPGE8bj46bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc3RyaW5nJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TdHJpbmcsICc8eC06cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc3Vic3RyaW5nJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TdWJzdHJpbmcsICc8cy1ubj86cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc3Vic3RyaW5nQmVmb3JlJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TdWJzdHJpbmdCZWZvcmUsICc8cy1zOnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3N1YnN0cmluZ0FmdGVyJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TdWJzdHJpbmdBZnRlciwgJzxzLXM6cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnbG93ZXJjYXNlJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Mb3dlcmNhc2UsICc8cy06cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgndXBwZXJjYXNlJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25VcHBlcmNhc2UsICc8cy06cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnbGVuZ3RoJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25MZW5ndGgsICc8cy06bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgndHJpbScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uVHJpbSwgJzxzLTpzPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdwYWQnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblBhZCwgJzxzLW5zPzpzPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdtYXRjaCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uTWF0Y2gsICc8cy1mPHM6bz5uPzphPG8+PicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdjb250YWlucycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQ29udGFpbnMsICc8cy0oc2YpOmI+JykpOyAvLyBUT0RPIDxzLShzZjxzOm8+KTpiPlxuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3JlcGxhY2UnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblJlcGxhY2UsICc8cy0oc2YpKHNmKW4/OnM+JykpOyAvLyBUT0RPIDxzLShzZjxzOm8+KShzZjxvOnM+KW4/OnM+XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc3BsaXQnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblNwbGl0LCAnPHMtKHNmKW4/OmE8cz4+JykpOyAvLyBUT0RPIDxzLShzZjxzOm8+KW4/OmE8cz4+XG4gICAgc3RhdGljRnJhbWUuYmluZCgnam9pbicsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uSm9pbiwgJzxhPHM+cz86cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnZm9ybWF0TnVtYmVyJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Gb3JtYXROdW1iZXIsICc8bi1zbz86cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnZm9ybWF0QmFzZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uRm9ybWF0QmFzZSwgJzxuLW4/OnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ251bWJlcicsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uTnVtYmVyLCAnPChucyktOm4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2Zsb29yJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25GbG9vciwgJzxuLTpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdjZWlsJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25DZWlsLCAnPG4tOm4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3JvdW5kJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Sb3VuZCwgJzxuLW4/Om4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2FicycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQWJzLCAnPG4tOm4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3NxcnQnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblNxcnQsICc8bi06bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgncG93ZXInLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblBvd2VyLCAnPG4tbjpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdyYW5kb20nLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblJhbmRvbSwgJzw6bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnYm9vbGVhbicsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQm9vbGVhbiwgJzx4LTpiPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdub3QnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbk5vdCwgJzx4LTpiPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdtYXAnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbk1hcCwgJzxhZj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnemlwJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25aaXAsICc8YSs+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2ZpbHRlcicsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uRmlsdGVyLCAnPGFmPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdyZWR1Y2UnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkZvbGRMZWZ0LCAnPGFmaj86aj4nKSk7IC8vIFRPRE8gPGY8amo6aj5hPGo+aj86aj5cbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdzaWZ0JywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TaWZ0LCAnPG8tZj86bz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgna2V5cycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uS2V5cywgJzx4LTphPHM+PicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdsb29rdXAnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkxvb2t1cCwgJzx4LXM6eD4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnYXBwZW5kJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25BcHBlbmQsICc8eHg6YT4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnZXhpc3RzJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25FeGlzdHMsICc8eDpiPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdzcHJlYWQnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblNwcmVhZCwgJzx4LTphPG8+PicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdtZXJnZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uTWVyZ2UsICc8YTxvPjpvPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdyZXZlcnNlJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25SZXZlcnNlLCAnPGE6YT4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnZWFjaCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uRWFjaCwgJzxvLWY6YT4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc29ydCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uU29ydCwgJzxhZj86YT4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc2h1ZmZsZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uU2h1ZmZsZSwgJzxhOmE+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2Jhc2U2NGVuY29kZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQmFzZTY0ZW5jb2RlLCAnPHMtOnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2Jhc2U2NGRlY29kZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQmFzZTY0ZGVjb2RlLCAnPHMtOnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3RvTWlsbGlzJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Ub01pbGxpcywgJzxzLTpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdmcm9tTWlsbGlzJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Gcm9tTWlsbGlzLCAnPG4tOnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2Nsb25lJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25DbG9uZSwgJzwob2EpLTpvPicpKTtcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGVzXG4gICAgICpcbiAgICAgKi9cbiAgICB2YXIgZXJyb3JDb2RlcyA9IHtcbiAgICAgICAgXCJTMDEwMVwiOiBcIlN0cmluZyBsaXRlcmFsIG11c3QgYmUgdGVybWluYXRlZCBieSBhIG1hdGNoaW5nIHF1b3RlXCIsXG4gICAgICAgIFwiUzAxMDJcIjogXCJOdW1iZXIgb3V0IG9mIHJhbmdlOiB7e3Rva2VufX1cIixcbiAgICAgICAgXCJTMDEwM1wiOiBcIlVuc3VwcG9ydGVkIGVzY2FwZSBzZXF1ZW5jZTogXFxcXHt7dG9rZW59fVwiLFxuICAgICAgICBcIlMwMTA0XCI6IFwiVGhlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdSBtdXN0IGJlIGZvbGxvd2VkIGJ5IDQgaGV4IGRpZ2l0c1wiLFxuICAgICAgICBcIlMwMTA1XCI6IFwiUXVvdGVkIHByb3BlcnR5IG5hbWUgbXVzdCBiZSB0ZXJtaW5hdGVkIHdpdGggYSBiYWNrcXVvdGUgKGApXCIsXG4gICAgICAgIFwiUzAyMDFcIjogXCJTeW50YXggZXJyb3I6IHt7dG9rZW59fVwiLFxuICAgICAgICBcIlMwMjAyXCI6IFwiRXhwZWN0ZWQge3t2YWx1ZX19LCBnb3Qge3t0b2tlbn19XCIsXG4gICAgICAgIFwiUzAyMDNcIjogXCJFeHBlY3RlZCB7e3ZhbHVlfX0gYmVmb3JlIGVuZCBvZiBleHByZXNzaW9uXCIsXG4gICAgICAgIFwiUzAyMDRcIjogXCJVbmtub3duIG9wZXJhdG9yOiB7e3Rva2VufX1cIixcbiAgICAgICAgXCJTMDIwNVwiOiBcIlVuZXhwZWN0ZWQgdG9rZW46IHt7dG9rZW59fVwiLFxuICAgICAgICBcIlMwMjA2XCI6IFwiVW5rbm93biBleHByZXNzaW9uIHR5cGU6IHt7dG9rZW59fVwiLFxuICAgICAgICBcIlMwMjA3XCI6IFwiVW5leHBlY3RlZCBlbmQgb2YgZXhwcmVzc2lvblwiLFxuICAgICAgICBcIlMwMjA4XCI6IFwiUGFyYW1ldGVyIHt7dmFsdWV9fSBvZiBmdW5jdGlvbiBkZWZpbml0aW9uIG11c3QgYmUgYSB2YXJpYWJsZSBuYW1lIChzdGFydCB3aXRoICQpXCIsXG4gICAgICAgIFwiUzAyMDlcIjogXCJBIHByZWRpY2F0ZSBjYW5ub3QgZm9sbG93IGEgZ3JvdXBpbmcgZXhwcmVzc2lvbiBpbiBhIHN0ZXBcIixcbiAgICAgICAgXCJTMDIxMFwiOiBcIkVhY2ggc3RlcCBjYW4gb25seSBoYXZlIG9uZSBncm91cGluZyBleHByZXNzaW9uXCIsXG4gICAgICAgIFwiUzAyMTFcIjogXCJUaGUgc3ltYm9sIHt7dG9rZW59fSBjYW5ub3QgYmUgdXNlZCBhcyBhIHVuYXJ5IG9wZXJhdG9yXCIsXG4gICAgICAgIFwiUzAzMDFcIjogXCJFbXB0eSByZWd1bGFyIGV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZFwiLFxuICAgICAgICBcIlMwMzAyXCI6IFwiTm8gdGVybWluYXRpbmcgLyBpbiByZWd1bGFyIGV4cHJlc3Npb25cIixcbiAgICAgICAgXCJTMDQwMlwiOiBcIkNob2ljZSBncm91cHMgY29udGFpbmluZyBwYXJhbWV0ZXJpemVkIHR5cGVzIGFyZSBub3Qgc3VwcG9ydGVkXCIsXG4gICAgICAgIFwiUzA0MDFcIjogXCJUeXBlIHBhcmFtZXRlcnMgY2FuIG9ubHkgYmUgYXBwbGllZCB0byBmdW5jdGlvbnMgYW5kIGFycmF5c1wiLFxuICAgICAgICBcIlMwNTAwXCI6IFwiQXR0ZW1wdGVkIHRvIGV2YWx1YXRlIGFuIGV4cHJlc3Npb24gY29udGFpbmluZyBzeW50YXggZXJyb3IocylcIixcbiAgICAgICAgXCJUMDQxMFwiOiBcIkFyZ3VtZW50IHt7aW5kZXh9fSBvZiBmdW5jdGlvbiB7e3Rva2VufX0gZG9lcyBub3QgbWF0Y2ggZnVuY3Rpb24gc2lnbmF0dXJlXCIsXG4gICAgICAgIFwiVDA0MTFcIjogXCJDb250ZXh0IHZhbHVlIGlzIG5vdCBhIGNvbXBhdGlibGUgdHlwZSB3aXRoIGFyZ3VtZW50IHt7aW5kZXh9fSBvZiBmdW5jdGlvbiB7e3Rva2VufX1cIixcbiAgICAgICAgXCJUMDQxMlwiOiBcIkFyZ3VtZW50IHt7aW5kZXh9fSBvZiBmdW5jdGlvbiB7e3Rva2VufX0gbXVzdCBiZSBhbiBhcnJheSBvZiB7e3R5cGV9fVwiLFxuICAgICAgICBcIkQxMDAxXCI6IFwiTnVtYmVyIG91dCBvZiByYW5nZToge3t2YWx1ZX19XCIsXG4gICAgICAgIFwiRDEwMDJcIjogXCJDYW5ub3QgbmVnYXRlIGEgbm9uLW51bWVyaWMgdmFsdWU6IHt7dmFsdWV9fVwiLFxuICAgICAgICBcIlQxMDAzXCI6IFwiS2V5IGluIG9iamVjdCBzdHJ1Y3R1cmUgbXVzdCBldmFsdWF0ZSB0byBhIHN0cmluZzsgZ290OiB7e3ZhbHVlfX1cIixcbiAgICAgICAgXCJEMTAwNFwiOiBcIlJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaGVzIHplcm8gbGVuZ3RoIHN0cmluZ1wiLFxuICAgICAgICBcIlQxMDA1XCI6IFwiQXR0ZW1wdGVkIHRvIGludm9rZSBhIG5vbi1mdW5jdGlvbi4gRGlkIHlvdSBtZWFuICR7e3t0b2tlbn19fT9cIixcbiAgICAgICAgXCJUMTAwNlwiOiBcIkF0dGVtcHRlZCB0byBpbnZva2UgYSBub24tZnVuY3Rpb25cIixcbiAgICAgICAgXCJUMTAwN1wiOiBcIkF0dGVtcHRlZCB0byBwYXJ0aWFsbHkgYXBwbHkgYSBub24tZnVuY3Rpb24uIERpZCB5b3UgbWVhbiAke3t7dG9rZW59fX0/XCIsXG4gICAgICAgIFwiVDEwMDhcIjogXCJBdHRlbXB0ZWQgdG8gcGFydGlhbGx5IGFwcGx5IGEgbm9uLWZ1bmN0aW9uXCIsXG4gICAgICAgIFwiVDIwMDFcIjogXCJUaGUgbGVmdCBzaWRlIG9mIHRoZSB7e3Rva2VufX0gb3BlcmF0b3IgbXVzdCBldmFsdWF0ZSB0byBhIG51bWJlclwiLFxuICAgICAgICBcIlQyMDAyXCI6IFwiVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHt7dG9rZW59fSBvcGVyYXRvciBtdXN0IGV2YWx1YXRlIHRvIGEgbnVtYmVyXCIsXG4gICAgICAgIFwiVDIwMDNcIjogXCJUaGUgbGVmdCBzaWRlIG9mIHRoZSByYW5nZSBvcGVyYXRvciAoLi4pIG11c3QgZXZhbHVhdGUgdG8gYW4gaW50ZWdlclwiLFxuICAgICAgICBcIlQyMDA0XCI6IFwiVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHJhbmdlIG9wZXJhdG9yICguLikgbXVzdCBldmFsdWF0ZSB0byBhbiBpbnRlZ2VyXCIsXG4gICAgICAgIFwiRDIwMDVcIjogXCJUaGUgbGVmdCBzaWRlIG9mIDo9IG11c3QgYmUgYSB2YXJpYWJsZSBuYW1lIChzdGFydCB3aXRoICQpXCIsXG4gICAgICAgIFwiVDIwMDZcIjogXCJUaGUgcmlnaHQgc2lkZSBvZiB0aGUgZnVuY3Rpb24gYXBwbGljYXRpb24gb3BlcmF0b3Igfj4gbXVzdCBiZSBhIGZ1bmN0aW9uXCIsXG4gICAgICAgIFwiVDIwMDdcIjogXCJUeXBlIG1pc21hdGNoIHdoZW4gY29tcGFyaW5nIHZhbHVlcyB7e3ZhbHVlfX0gYW5kIHt7dmFsdWUyfX0gaW4gb3JkZXItYnkgY2xhdXNlXCIsXG4gICAgICAgIFwiVDIwMDhcIjogXCJUaGUgZXhwcmVzc2lvbnMgd2l0aGluIGFuIG9yZGVyLWJ5IGNsYXVzZSBtdXN0IGV2YWx1YXRlIHRvIG51bWVyaWMgb3Igc3RyaW5nIHZhbHVlc1wiLFxuICAgICAgICBcIlQyMDA5XCI6IFwiVGhlIHZhbHVlcyB7e3ZhbHVlfX0gYW5kIHt7dmFsdWUyfX0gZWl0aGVyIHNpZGUgb2Ygb3BlcmF0b3Ige3t0b2tlbn19IG11c3QgYmUgb2YgdGhlIHNhbWUgZGF0YSB0eXBlXCIsXG4gICAgICAgIFwiVDIwMTBcIjogXCJUaGUgZXhwcmVzc2lvbnMgZWl0aGVyIHNpZGUgb2Ygb3BlcmF0b3Ige3t0b2tlbn19IG11c3QgZXZhbHVhdGUgdG8gbnVtZXJpYyBvciBzdHJpbmcgdmFsdWVzXCIsXG4gICAgICAgIFwiVDIwMTFcIjogXCJUaGUgaW5zZXJ0L3VwZGF0ZSBjbGF1c2Ugb2YgdGhlIHRyYW5zZm9ybSBleHByZXNzaW9uIG11c3QgZXZhbHVhdGUgdG8gYW4gb2JqZWN0OiB7e3ZhbHVlfX1cIixcbiAgICAgICAgXCJUMjAxMlwiOiBcIlRoZSBkZWxldGUgY2xhdXNlIG9mIHRoZSB0cmFuc2Zvcm0gZXhwcmVzc2lvbiBtdXN0IGV2YWx1YXRlIHRvIGEgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3M6IHt7dmFsdWV9fVwiLFxuICAgICAgICBcIlQyMDEzXCI6IFwiVGhlIHRyYW5zZm9ybSBleHByZXNzaW9uIGNsb25lcyB0aGUgaW5wdXQgb2JqZWN0IHVzaW5nIHRoZSAkY2xvbmUoKSBmdW5jdGlvbi4gIFRoaXMgaGFzIGJlZW4gb3ZlcnJpZGRlbiBpbiB0aGUgY3VycmVudCBzY29wZSBieSBhIG5vbi1mdW5jdGlvbi5cIixcbiAgICAgICAgXCJEMzAwMVwiOiBcIkF0dGVtcHRpbmcgdG8gaW52b2tlIHN0cmluZyBmdW5jdGlvbiBvbiBJbmZpbml0eSBvciBOYU5cIixcbiAgICAgICAgXCJEMzAxMFwiOiBcIlNlY29uZCBhcmd1bWVudCBvZiByZXBsYWNlIGZ1bmN0aW9uIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmdcIixcbiAgICAgICAgXCJEMzAxMVwiOiBcIkZvdXJ0aCBhcmd1bWVudCBvZiByZXBsYWNlIGZ1bmN0aW9uIG11c3QgZXZhbHVhdGUgdG8gYSBwb3NpdGl2ZSBudW1iZXJcIixcbiAgICAgICAgXCJEMzAxMlwiOiBcIkF0dGVtcHRlZCB0byByZXBsYWNlIGEgbWF0Y2hlZCBzdHJpbmcgd2l0aCBhIG5vbi1zdHJpbmcgdmFsdWVcIixcbiAgICAgICAgXCJEMzAyMFwiOiBcIlRoaXJkIGFyZ3VtZW50IG9mIHNwbGl0IGZ1bmN0aW9uIG11c3QgZXZhbHVhdGUgdG8gYSBwb3NpdGl2ZSBudW1iZXJcIixcbiAgICAgICAgXCJEMzAzMFwiOiBcIlVuYWJsZSB0byBjYXN0IHZhbHVlIHRvIGEgbnVtYmVyOiB7e3ZhbHVlfX1cIixcbiAgICAgICAgXCJEMzA0MFwiOiBcIlRoaXJkIGFyZ3VtZW50IG9mIG1hdGNoIGZ1bmN0aW9uIG11c3QgZXZhbHVhdGUgdG8gYSBwb3NpdGl2ZSBudW1iZXJcIixcbiAgICAgICAgXCJEMzA1MFwiOiBcIkZpcnN0IGFyZ3VtZW50IG9mIHJlZHVjZSBmdW5jdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24gd2l0aCB0d28gYXJndW1lbnRzXCIsXG4gICAgICAgIFwiRDMwNjBcIjogXCJUaGUgc3FydCBmdW5jdGlvbiBjYW5ub3QgYmUgYXBwbGllZCB0byBhIG5lZ2F0aXZlIG51bWJlcjoge3t2YWx1ZX19XCIsXG4gICAgICAgIFwiRDMwNjFcIjogXCJUaGUgcG93ZXIgZnVuY3Rpb24gaGFzIHJlc3VsdGVkIGluIGEgdmFsdWUgdGhhdCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXMgYSBKU09OIG51bWJlcjogYmFzZT17e3ZhbHVlfX0sIGV4cG9uZW50PXt7ZXhwfX1cIixcbiAgICAgICAgXCJEMzA3MFwiOiBcIlRoZSBzaW5nbGUgYXJndW1lbnQgZm9ybSBvZiB0aGUgc29ydCBmdW5jdGlvbiBjYW4gb25seSBiZSBhcHBsaWVkIHRvIGFuIGFycmF5IG9mIHN0cmluZ3Mgb3IgYW4gYXJyYXkgb2YgbnVtYmVycy4gIFVzZSB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIHNwZWNpZnkgYSBjb21wYXJpc29uIGZ1bmN0aW9uXCIsXG4gICAgICAgIFwiRDMwODBcIjogXCJUaGUgcGljdHVyZSBzdHJpbmcgbXVzdCBvbmx5IGNvbnRhaW4gYSBtYXhpbXVtIG9mIHR3byBzdWItcGljdHVyZXNcIixcbiAgICAgICAgXCJEMzA4MVwiOiBcIlRoZSBzdWItcGljdHVyZSBtdXN0IG5vdCBjb250YWluIG1vcmUgdGhhbiBvbmUgaW5zdGFuY2Ugb2YgdGhlICdkZWNpbWFsLXNlcGFyYXRvcicgY2hhcmFjdGVyXCIsXG4gICAgICAgIFwiRDMwODJcIjogXCJUaGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBtb3JlIHRoYW4gb25lIGluc3RhbmNlIG9mIHRoZSAncGVyY2VudCcgY2hhcmFjdGVyXCIsXG4gICAgICAgIFwiRDMwODNcIjogXCJUaGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBtb3JlIHRoYW4gb25lIGluc3RhbmNlIG9mIHRoZSAncGVyLW1pbGxlJyBjaGFyYWN0ZXJcIixcbiAgICAgICAgXCJEMzA4NFwiOiBcIlRoZSBzdWItcGljdHVyZSBtdXN0IG5vdCBjb250YWluIGJvdGggYSAncGVyY2VudCcgYW5kIGEgJ3Blci1taWxsZScgY2hhcmFjdGVyXCIsXG4gICAgICAgIFwiRDMwODVcIjogXCJUaGUgbWFudGlzc2EgcGFydCBvZiBhIHN1Yi1waWN0dXJlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIHRoYXQgaXMgZWl0aGVyIGFuICdvcHRpb25hbCBkaWdpdCBjaGFyYWN0ZXInIG9yIGEgbWVtYmVyIG9mIHRoZSAnZGVjaW1hbCBkaWdpdCBmYW1pbHknXCIsXG4gICAgICAgIFwiRDMwODZcIjogXCJUaGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBhIHBhc3NpdmUgY2hhcmFjdGVyIHRoYXQgaXMgcHJlY2VkZWQgYnkgYW4gYWN0aXZlIGNoYXJhY3RlciBhbmQgdGhhdCBpcyBmb2xsb3dlZCBieSBhbm90aGVyIGFjdGl2ZSBjaGFyYWN0ZXJcIixcbiAgICAgICAgXCJEMzA4N1wiOiBcIlRoZSBzdWItcGljdHVyZSBtdXN0IG5vdCBjb250YWluIGEgJ2dyb3VwaW5nLXNlcGFyYXRvcicgY2hhcmFjdGVyIHRoYXQgYXBwZWFycyBhZGphY2VudCB0byBhICdkZWNpbWFsLXNlcGFyYXRvcicgY2hhcmFjdGVyXCIsXG4gICAgICAgIFwiRDMwODhcIjogXCJUaGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBhICdncm91cGluZy1zZXBhcmF0b3InIGF0IHRoZSBlbmQgb2YgdGhlIGludGVnZXIgcGFydFwiLFxuICAgICAgICBcIkQzMDg5XCI6IFwiVGhlIHN1Yi1waWN0dXJlIG11c3Qgbm90IGNvbnRhaW4gdHdvIGFkamFjZW50IGluc3RhbmNlcyBvZiB0aGUgJ2dyb3VwaW5nLXNlcGFyYXRvcicgY2hhcmFjdGVyXCIsXG4gICAgICAgIFwiRDMwOTBcIjogXCJUaGUgaW50ZWdlciBwYXJ0IG9mIHRoZSBzdWItcGljdHVyZSBtdXN0IG5vdCBjb250YWluIGEgbWVtYmVyIG9mIHRoZSAnZGVjaW1hbCBkaWdpdCBmYW1pbHknIHRoYXQgaXMgZm9sbG93ZWQgYnkgYW4gaW5zdGFuY2Ugb2YgdGhlICdvcHRpb25hbCBkaWdpdCBjaGFyYWN0ZXInXCIsXG4gICAgICAgIFwiRDMwOTFcIjogXCJUaGUgZnJhY3Rpb25hbCBwYXJ0IG9mIHRoZSBzdWItcGljdHVyZSBtdXN0IG5vdCBjb250YWluIGFuIGluc3RhbmNlIG9mIHRoZSAnb3B0aW9uYWwgZGlnaXQgY2hhcmFjdGVyJyB0aGF0IGlzIGZvbGxvd2VkIGJ5IGEgbWVtYmVyIG9mIHRoZSAnZGVjaW1hbCBkaWdpdCBmYW1pbHknXCIsXG4gICAgICAgIFwiRDMwOTJcIjogXCJBIHN1Yi1waWN0dXJlIHRoYXQgY29udGFpbnMgYSAncGVyY2VudCcgb3IgJ3Blci1taWxsZScgY2hhcmFjdGVyIG11c3Qgbm90IGNvbnRhaW4gYSBjaGFyYWN0ZXIgdHJlYXRlZCBhcyBhbiAnZXhwb25lbnQtc2VwYXJhdG9yJ1wiLFxuICAgICAgICBcIkQzMDkzXCI6IFwiVGhlIGV4cG9uZW50IHBhcnQgb2YgdGhlIHN1Yi1waWN0dXJlIG11c3QgY29tcHJpc2Ugb25seSBvZiBvbmUgb3IgbW9yZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIG1lbWJlcnMgb2YgdGhlICdkZWNpbWFsIGRpZ2l0IGZhbWlseSdcIixcbiAgICAgICAgXCJEMzEwMFwiOiBcIlRoZSByYWRpeCBvZiB0aGUgZm9ybWF0QmFzZSBmdW5jdGlvbiBtdXN0IGJlIGJldHdlZW4gMiBhbmQgMzYuICBJdCB3YXMgZ2l2ZW4ge3t2YWx1ZX19XCIsXG4gICAgICAgIFwiRDMxMTBcIjogXCJUaGUgYXJndW1lbnQgb2YgdGhlIHRvTWlsbGlzIGZ1bmN0aW9uIG11c3QgYmUgYW4gSVNPIDg2MDEgZm9ybWF0dGVkIHRpbWVzdGFtcC4gR2l2ZW4ge3t2YWx1ZX19XCJcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogbG9va3VwIGEgbWVzc2FnZSB0ZW1wbGF0ZSBmcm9tIHRoZSBjYXRhbG9nIGFuZCBzdWJzdGl0dXRlIHRoZSBpbnNlcnRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVyciAtIGVycm9yIGNvZGUgdG8gbG9va3VwXG4gICAgICogQHJldHVybnMge3N0cmluZ30gbWVzc2FnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvb2t1cE1lc3NhZ2UoZXJyKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJ1Vua25vd24gZXJyb3InO1xuICAgICAgICBpZih0eXBlb2YgZXJyLm1lc3NhZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRlbXBsYXRlID0gZXJyb3JDb2Rlc1tlcnIuY29kZV07XG4gICAgICAgIGlmKHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBhbnkgaGFuZGxlYmFycywgcmVwbGFjZSB0aGVtIHdpdGggdGhlIGZpZWxkIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIC8vIHRyaXBsZSBicmFjZXMgLSByZXBsYWNlIHdpdGggdmFsdWVcbiAgICAgICAgICAgIC8vIGRvdWJsZSBicmFjZXMgLSByZXBsYWNlIHdpdGgganNvbiBzdHJpbmdpZmllZCB2YWx1ZVxuICAgICAgICAgICAgbWVzc2FnZSA9IHRlbXBsYXRlLnJlcGxhY2UoL1xce1xce1xceyhbXn1dKyl9fX0vZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyclthcmd1bWVudHNbMV1dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKC9cXHtcXHsoW159XSspfX0vZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGVyclthcmd1bWVudHNbMV1dKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEpTT05hdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucyAtIHJlY292ZXI6IGF0dGVtcHQgdG8gcmVjb3ZlciBvbiBwYXJzZSBlcnJvclxuICAgICAqIEByZXR1cm5zIHt7ZXZhbHVhdGU6IGV2YWx1YXRlLCBhc3NpZ246IGFzc2lnbn19IEV2YWx1YXRlZCBleHByZXNzaW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24ganNvbmF0YShleHByLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBhc3Q7XG4gICAgICAgIHZhciBlcnJvcnM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhc3QgPSBwYXJzZXIoZXhwciwgb3B0aW9ucyAmJiBvcHRpb25zLnJlY292ZXIpO1xuICAgICAgICAgICAgZXJyb3JzID0gYXN0LmVycm9ycztcbiAgICAgICAgICAgIGRlbGV0ZSBhc3QuZXJyb3JzO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGVycm9yIG1lc3NhZ2UgaW50byBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID0gbG9va3VwTWVzc2FnZShlcnIpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbnZpcm9ubWVudCA9IGNyZWF0ZUZyYW1lKHN0YXRpY0ZyYW1lKTtcblxuICAgICAgICB2YXIgdGltZXN0YW1wID0gbmV3IERhdGUoKTsgLy8gd2lsbCBiZSBvdmVycmlkZGVuIG9uIGVhY2ggY2FsbCB0byBldmFsdXRlKClcbiAgICAgICAgZW52aXJvbm1lbnQuYmluZCgnbm93JywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGltZXN0YW1wLnRvSlNPTigpO1xuICAgICAgICB9LCAnPDpzPicpKTtcbiAgICAgICAgZW52aXJvbm1lbnQuYmluZCgnbWlsbGlzJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGltZXN0YW1wLmdldFRpbWUoKTtcbiAgICAgICAgfSwgJzw6bj4nKSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiAoaW5wdXQsIGJpbmRpbmdzLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIHRocm93IGlmIHRoZSBleHByZXNzaW9uIGNvbXBpbGVkIHdpdGggc3ludGF4IGVycm9yc1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBlcnJvcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiAnUzA1MDAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBsb29rdXBNZXNzYWdlKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJpbmRpbmdzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhlY19lbnY7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB2YXJpYWJsZSBiaW5kaW5ncyBoYXZlIGJlZW4gcGFzc2VkIGluIC0gY3JlYXRlIGEgZnJhbWUgdG8gaG9sZCB0aGVzZVxuICAgICAgICAgICAgICAgICAgICBleGVjX2VudiA9IGNyZWF0ZUZyYW1lKGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdiBpbiBiaW5kaW5ncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY19lbnYuYmluZCh2LCBiaW5kaW5nc1t2XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleGVjX2VudiA9IGVudmlyb25tZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBwdXQgdGhlIGlucHV0IGRvY3VtZW50IGludG8gdGhlIGVudmlyb25tZW50IGFzIHRoZSByb290IG9iamVjdFxuICAgICAgICAgICAgICAgIGV4ZWNfZW52LmJpbmQoJyQnLCBpbnB1dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBjYXB0dXJlIHRoZSB0aW1lc3RhbXAgYW5kIHB1dCBpdCBpbiB0aGUgZXhlY3V0aW9uIGVudmlyb25tZW50XG4gICAgICAgICAgICAgICAgLy8gdGhlICRub3coKSBhbmQgJG1pbGxpcygpIGZ1bmN0aW9ucyB3aWxsIHJldHVybiB0aGlzIHZhbHVlIC0gd2hlbmV2ZXIgaXQgaXMgY2FsbGVkXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gbmV3IERhdGUoKTtcblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQsIGl0O1xuICAgICAgICAgICAgICAgIC8vIGlmIGEgY2FsbGJhY2sgZnVuY3Rpb24gaXMgc3VwcGxpZWQsIHRoZW4gZHJpdmUgdGhlIGdlbmVyYXRvciBpbiBhIHByb21pc2UgY2hhaW5cbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhlY19lbnYuYmluZCgnX19qc29uYXRhX2FzeW5jJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGVuSGFuZGxlciA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gaXQubmV4dChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUudGhlbih0aGVuSGFuZGxlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gbG9va3VwTWVzc2FnZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGl0ID0gZXZhbHVhdGUoYXN0LCBpbnB1dCwgZXhlY19lbnYpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBpdC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZS50aGVuKHRoZW5IYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBjYWxsYmFjayBmdW5jdGlvbiAtIGRyaXZlIHRoZSBnZW5lcmF0b3IgdG8gY29tcGxldGlvbiBzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdCA9IGV2YWx1YXRlKGFzdCwgaW5wdXQsIGV4ZWNfZW52KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBpdC5uZXh0KHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2VydCBlcnJvciBtZXNzYWdlIGludG8gc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGxvb2t1cE1lc3NhZ2UoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3NpZ246IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGVudmlyb25tZW50LmJpbmQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZ2lzdGVyRnVuY3Rpb246IGZ1bmN0aW9uKG5hbWUsIGltcGxlbWVudGF0aW9uLCBzaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnVuYyA9IGRlZmluZUZ1bmN0aW9uKGltcGxlbWVudGF0aW9uLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgIGVudmlyb25tZW50LmJpbmQobmFtZSwgZnVuYyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBqc29uYXRhLnBhcnNlciA9IHBhcnNlcjsgLy8gVE9ETyByZW1vdmUgdGhpcyBpbiBhIGZ1dHVyZSByZWxlYXNlIC0gdXNlIGFzdCgpIGluc3RlYWRcblxuICAgIHJldHVybiBqc29uYXRhO1xuXG59KSgpO1xuXG4vLyBub2RlLmpzIG9ubHkgLSBleHBvcnQgdGhlIGpzb25hdGEgYW5kIHBhcnNlciBmdW5jdGlvbnNcbi8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlXG5pZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ganNvbmF0YTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGxvZ2xldmVsID0gcmVxdWlyZSgnbG9nbGV2ZWwnKTtcbnZhciBjaGFsayA9IHJlcXVpcmUoJ2NoYWxrJyk7XG5cbnZhciBsb2dnZXJzID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TG9nZ2VyO1xuXG5mdW5jdGlvbiBnZXRMb2dnZXIoKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIF9yZWYkbGV2ZWwgPSBfcmVmLmxldmVsLFxuICAgICAgbGV2ZWwgPSBfcmVmJGxldmVsID09PSB1bmRlZmluZWQgPyBnZXREZWZhdWx0TGV2ZWwoKSA6IF9yZWYkbGV2ZWwsXG4gICAgICBfcmVmJHByZWZpeCA9IF9yZWYucHJlZml4LFxuICAgICAgcHJlZml4ID0gX3JlZiRwcmVmaXggPT09IHVuZGVmaW5lZCA/ICcnIDogX3JlZiRwcmVmaXg7XG5cbiAgaWYgKGxvZ2dlcnNbcHJlZml4XSkge1xuICAgIHJldHVybiBsb2dnZXJzW3ByZWZpeF07XG4gIH1cbiAgdmFyIGNvbG9yZWRQcmVmaXggPSBwcmVmaXggPyBgJHtjaGFsay5kaW0ocHJlZml4KX0gYCA6ICcnO1xuICB2YXIgbGV2ZWxQcmVmaXggPSB7XG4gICAgVFJBQ0U6IGNoYWxrLmRpbSgnW1RSQUNFXScpLFxuICAgIERFQlVHOiBjaGFsay5jeWFuKCdbREVCVUddJyksXG4gICAgSU5GTzogY2hhbGsuYmx1ZSgnW0lORk9dJyksXG4gICAgV0FSTjogY2hhbGsueWVsbG93KCdbV0FSTl0nKSxcbiAgICBFUlJPUjogY2hhbGsucmVkKCdbRVJST1JdJylcbiAgfTtcblxuICB2YXIgbG9nZ2VyID0gbG9nbGV2ZWwuZ2V0TG9nZ2VyKGAke3ByZWZpeH0tbG9nZ2VyYCk7XG5cbiAgLy8gdGhpcyBpcyB0aGUgcGx1Z2luIFwiYXBpXCJcbiAgdmFyIG9yaWdpbmFsRmFjdG9yeSA9IGxvZ2dlci5tZXRob2RGYWN0b3J5O1xuICBsb2dnZXIubWV0aG9kRmFjdG9yeSA9IG1ldGhvZEZhY3Rvcnk7XG5cbiAgdmFyIG9yaWdpbmFsU2V0TGV2ZWwgPSBsb2dnZXIuc2V0TGV2ZWw7XG4gIGxvZ2dlci5zZXRMZXZlbCA9IHNldExldmVsO1xuICBsb2dnZXIuc2V0TGV2ZWwobGV2ZWwpO1xuICBsb2dnZXJzW3ByZWZpeF0gPSBsb2dnZXI7XG4gIHJldHVybiBsb2dnZXI7XG5cbiAgZnVuY3Rpb24gbWV0aG9kRmFjdG9yeSgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZmFjdG9yeUFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGZhY3RvcnlBcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBsb2dMZXZlbCA9IGZhY3RvcnlBcmdzWzBdO1xuXG4gICAgdmFyIHJhd01ldGhvZCA9IG9yaWdpbmFsRmFjdG9yeS5hcHBseSh1bmRlZmluZWQsIGZhY3RvcnlBcmdzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmF3TWV0aG9kLmFwcGx5KHVuZGVmaW5lZCwgW2Ake2NvbG9yZWRQcmVmaXh9JHtsZXZlbFByZWZpeFtsb2dMZXZlbC50b1VwcGVyQ2FzZSgpXX06YF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0TGV2ZWwobGV2ZWxUb1NldFRvKSB7XG4gICAgdmFyIHBlcnNpc3QgPSBmYWxzZTsgLy8gdXNlcyBicm93c2VyIGxvY2FsU3RvcmFnZVxuICAgIHJldHVybiBvcmlnaW5hbFNldExldmVsLmNhbGwobG9nZ2VyLCBsZXZlbFRvU2V0VG8sIHBlcnNpc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRMZXZlbCgpIHtcbiAgdmFyIGxvZ0xldmVsID0gcHJvY2Vzcy5lbnYuTE9HX0xFVkVMO1xuXG4gIGlmIChsb2dMZXZlbCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWxvZ0xldmVsKSB7XG4gICAgcmV0dXJuICd3YXJuJztcbiAgfVxuICByZXR1cm4gbG9nTGV2ZWw7XG59IiwiLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgICAgIFwidHJhY2VcIixcbiAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICBcImluZm9cIixcbiAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgIF07XG5cbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsIG1ldGhvZE5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlc2UgcHJpdmF0ZSBmdW5jdGlvbnMgYWx3YXlzIG5lZWQgYHRoaXNgIHRvIGJlIHNldCBwcm9wZXJseVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xuICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IChpIDwgbGV2ZWwpID9cbiAgICAgICAgICAgICAgICBub29wIDpcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1Z1xuICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XG4gICAgfVxuXG4gICAgLy8gSW4gb2xkIElFIHZlcnNpb25zLCB0aGUgY29uc29sZSBpc24ndCBwcmVzZW50IHVudGlsIHlvdSBmaXJzdCBvcGVuIGl0LlxuICAgIC8vIFdlIGJ1aWxkIHJlYWxNZXRob2QoKSByZXBsYWNlbWVudHMgaGVyZSB0aGF0IHJlZ2VuZXJhdGUgbG9nZ2luZyBtZXRob2RzXG4gICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcywgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB3ZSB1c2UgY2xvc2VseSBib3VuZCByZWFsIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUsIGFuZFxuICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAgZnVuY3Rpb24gZGVmYXVsdE1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHxcbiAgICAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2dnZXIobmFtZSwgZGVmYXVsdExldmVsLCBmYWN0b3J5KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY3VycmVudExldmVsO1xuICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBcImxvZ2xldmVsXCI7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhjb29raWUuc2xpY2UobG9jYXRpb24pKVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqXG4gICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgc2VsZi5uYW1lID0gbmFtZTtcblxuICAgICAgc2VsZi5sZXZlbHMgPSB7IFwiVFJBQ0VcIjogMCwgXCJERUJVR1wiOiAxLCBcIklORk9cIjogMiwgXCJXQVJOXCI6IDMsXG4gICAgICAgICAgXCJFUlJPUlwiOiA0LCBcIlNJTEVOVFwiOiA1fTtcblxuICAgICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZmFjdG9yeSB8fCBkZWZhdWx0TWV0aG9kRmFjdG9yeTtcblxuICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudExldmVsO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCwgcGVyc2lzdCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwic3RyaW5nXCIgJiYgc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgICBpZiAocGVyc2lzdCAhPT0gZmFsc2UpIHsgIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYsIGxldmVsLCBuYW1lKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlICYmIGxldmVsIDwgc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGxldmVsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgaWYgKCFnZXRQZXJzaXN0ZWRMZXZlbCgpKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbml0aWFsaXplIHdpdGggdGhlIHJpZ2h0IGxldmVsXG4gICAgICB2YXIgaW5pdGlhbExldmVsID0gZ2V0UGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgIGlmIChpbml0aWFsTGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgIGluaXRpYWxMZXZlbCA9IGRlZmF1bHRMZXZlbCA9PSBudWxsID8gXCJXQVJOXCIgOiBkZWZhdWx0TGV2ZWw7XG4gICAgICB9XG4gICAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICpcbiAgICAgKiBUb3AtbGV2ZWwgQVBJXG4gICAgICpcbiAgICAgKi9cblxuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG4gICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIgfHwgbmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdO1xuICAgICAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgICAgIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdID0gbmV3IExvZ2dlcihcbiAgICAgICAgICAgIG5hbWUsIGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSwgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIH07XG5cbiAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XG4gICAgZGVmYXVsdExvZ2dlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmXG4gICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBkZWZhdWx0TG9nZ2VyKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9nID0gX2xvZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xuICAgIH07XG5cbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlcnMgPSBmdW5jdGlvbiBnZXRMb2dnZXJzKCkge1xuICAgICAgICByZXR1cm4gX2xvZ2dlcnNCeU5hbWU7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xufSkpO1xuIiwidmFyIHBlcmZvcm1hbmNlID0gZ2xvYmFsLnBlcmZvcm1hbmNlIHx8IHt9O1xuXG52YXIgcHJlc2VudCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBuYW1lcyA9IFsnbm93JywgJ3dlYmtpdE5vdycsICdtc05vdycsICdtb3pOb3cnLCAnb05vdyddO1xuICB3aGlsZSAobmFtZXMubGVuZ3RoKSB7XG4gICAgdmFyIG5hbWUgPSBuYW1lcy5zaGlmdCgpO1xuICAgIGlmIChuYW1lIGluIHBlcmZvcm1hbmNlKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2VbbmFtZV0uYmluZChwZXJmb3JtYW5jZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRhdGVOb3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfTtcbiAgdmFyIG5hdmlnYXRpb25TdGFydCA9IChwZXJmb3JtYW5jZS50aW1pbmcgfHwge30pLm5hdmlnYXRpb25TdGFydCB8fCBkYXRlTm93KCk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRhdGVOb3coKSAtIG5hdmlnYXRpb25TdGFydDtcbiAgfTtcbn0oKSk7XG5cbnByZXNlbnQucGVyZm9ybWFuY2VOb3cgPSBwZXJmb3JtYW5jZS5ub3c7XG5wcmVzZW50Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHBlcmZvcm1hbmNlLm5vdyA9IHByZXNlbnQucGVyZm9ybWFuY2VOb3c7XG59O1xucHJlc2VudC5jb25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgcGVyZm9ybWFuY2Uubm93ID0gcHJlc2VudDtcbn07XG5wcmVzZW50LmNvbmZsaWN0KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcHJlc2VudDtcbiIsIi8vIEV4cG9ydCAuL2xpYi9yYW5kZ2VuXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL3JhbmRnZW5cIik7XG4iLCIvKmpzbGludCBpbmRlbnQ6IDIsIHBsdXNwbHVzOiB0cnVlLCBzbG9wcHk6IHRydWUgKi9cbi8vIEdlbmVyYXRlIHVuaWZvcm1seSBkaXN0cmlidXRlZCByYW5kb20gbnVtYmVyc1xuLy8gR2l2ZXMgYSByYW5kb20gbnVtYmVyIG9uIHRoZSBpbnRlcnZhbCBbbWluLCBtYXgpLlxuLy8gSWYgZGlzY3JldGUgaXMgdHJ1ZSwgdGhlIG51bWJlciB3aWxsIGJlIGFuIGludGVnZXIuXG5mdW5jdGlvbiBydW5pZihtaW4sIG1heCwgZGlzY3JldGUpIHtcbiAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWluID0gMDtcbiAgfVxuICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXggPSAxO1xuICB9XG4gIGlmIChkaXNjcmV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGlzY3JldGUgPSBmYWxzZTtcbiAgfVxuICBpZiAoZGlzY3JldGUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihydW5pZihtaW4sIG1heCwgZmFsc2UpKTtcbiAgfVxuICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xufVxuXG4vLyBHZW5lcmF0ZSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gbnVibWVyc1xuLy8gQWxnb3JpdGhtIGFkYXB0ZWQgZnJvbTpcbi8vIGh0dHA6Ly9jLWZhcS5jb20vbGliL2dhdXNzaWFuLmh0bWxcbmZ1bmN0aW9uIHJub3JtKG1lYW4sIHN0ZGV2KSB7XG4gIHZhciB1MSwgdTIsIHYxLCB2MiwgcztcbiAgaWYgKG1lYW4gPT09IHVuZGVmaW5lZCkge1xuICAgIG1lYW4gPSAwLjA7XG4gIH1cbiAgaWYgKHN0ZGV2ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGRldiA9IDEuMDtcbiAgfVxuICBpZiAocm5vcm0udjIgPT09IG51bGwpIHtcbiAgICBkbyB7XG4gICAgICB1MSA9IE1hdGgucmFuZG9tKCk7XG4gICAgICB1MiA9IE1hdGgucmFuZG9tKCk7XG5cbiAgICAgIHYxID0gMiAqIHUxIC0gMTtcbiAgICAgIHYyID0gMiAqIHUyIC0gMTtcbiAgICAgIHMgPSB2MSAqIHYxICsgdjIgKiB2MjtcbiAgICB9IHdoaWxlIChzID09PSAwIHx8IHMgPj0gMSk7XG5cbiAgICBybm9ybS52MiA9IHYyICogTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocykgLyBzKTtcbiAgICByZXR1cm4gc3RkZXYgKiB2MSAqIE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHMpIC8gcykgKyBtZWFuO1xuICB9XG5cbiAgdjIgPSBybm9ybS52MjtcbiAgcm5vcm0udjIgPSBudWxsO1xuICByZXR1cm4gc3RkZXYgKiB2MiArIG1lYW47XG59XG5cbnJub3JtLnYyID0gbnVsbDtcblxuLy8gR2VuZXJhdGUgQ2hpLXNxdWFyZSBkaXN0cmlidXRlZCByYW5kb20gbnVtYmVyc1xuZnVuY3Rpb24gcmNoaXNxKGRlZ3JlZXNPZkZyZWVkb20pIHtcbiAgaWYgKGRlZ3JlZXNPZkZyZWVkb20gPT09IHVuZGVmaW5lZCkge1xuICAgIGRlZ3JlZXNPZkZyZWVkb20gPSAxO1xuICB9XG4gIHZhciBpLCB6LCBzdW0gPSAwLjA7XG4gIGZvciAoaSA9IDA7IGkgPCBkZWdyZWVzT2ZGcmVlZG9tOyBpKyspIHtcbiAgICB6ID0gcm5vcm0oKTtcbiAgICBzdW0gKz0geiAqIHo7XG4gIH1cblxuICByZXR1cm4gc3VtO1xufVxuXG4vLyBHZW5lcmF0ZSBQb2lzc29uIGRpc3RyaWJ1dGVkIHJhbmRvbSBudW1iZXJzXG5mdW5jdGlvbiBycG9pc3NvbihsYW1iZGEpIHtcbiAgaWYgKGxhbWJkYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGFtYmRhID0gMTtcbiAgfVxuICB2YXIgbCA9IE1hdGguZXhwKC1sYW1iZGEpLFxuICAgIGsgPSAwLFxuICAgIHAgPSAxLjA7XG4gIGRvIHtcbiAgICBrKys7XG4gICAgcCAqPSBNYXRoLnJhbmRvbSgpO1xuICB9IHdoaWxlIChwID4gbCk7XG5cbiAgcmV0dXJuIGsgLSAxO1xufVxuXG4vLyBHZW5lcmF0ZSBDYXVjaHkgZGlzdHJpYnV0ZWQgcmFuZG9tIG51bWJlcnNcbmZ1bmN0aW9uIHJjYXVjaHkobG9jLCBzY2FsZSkge1xuICBpZiAobG9jID09PSB1bmRlZmluZWQpIHtcbiAgICBsb2MgPSAwLjA7XG4gIH1cbiAgaWYgKHNjYWxlID09PSB1bmRlZmluZWQpIHtcbiAgICBzY2FsZSA9IDEuMDtcbiAgfVxuICB2YXIgbjIsIG4xID0gcm5vcm0oKTtcbiAgZG8ge1xuICAgIG4yID0gcm5vcm0oKTtcbiAgfSB3aGlsZSAobjIgPT09IDAuMCk7XG5cbiAgcmV0dXJuIGxvYyArIHNjYWxlICogbjEgLyBuMjtcbn1cblxuLy8gQmVybm91bGxpIGRpc3RyaWJ1dGlvbjogZ2l2ZXMgMSB3aXRoIHByb2JhYmlsaXR5IHBcbmZ1bmN0aW9uIHJiZXJub3VsbGkocCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKSA8IHAgPyAxIDogMDtcbn1cblxuLy8gVmVjdG9yaXplIGEgcmFuZG9tIGdlbmVyYXRvclxuZnVuY3Rpb24gdmVjdG9yaXplKGdlbmVyYXRvcikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuLCByZXN1bHQsIGksIGFyZ3M7XG4gICAgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgIG4gPSBhcmdzLnNoaWZ0KCk7XG4gICAgcmVzdWx0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLy8gR2VuZXJhdGUgYSBoaXN0b2dyYW0gZnJvbSBhIGxpc3Qgb2YgbnVtYmVyc1xuZnVuY3Rpb24gaGlzdG9ncmFtKGRhdGEsIGJpbkNvdW50KSB7XG4gIGJpbkNvdW50ID0gYmluQ291bnQgfHwgMTA7XG5cbiAgdmFyIGJpbnMsIGksIHNjYWxlZCxcbiAgICBtYXggPSBNYXRoLm1heC5hcHBseSh0aGlzLCBkYXRhKSxcbiAgICBtaW4gPSBNYXRoLm1pbi5hcHBseSh0aGlzLCBkYXRhKTtcblxuICAvLyBlZGdlIGNhc2U6IG1heCA9PSBtaW5cbiAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgcmV0dXJuIFtkYXRhLmxlbmd0aF07XG4gIH1cblxuICBiaW5zID0gW107XG5cbiAgLy8gemVybyBlYWNoIGJpblxuICBmb3IgKGkgPSAwOyBpIDwgYmluQ291bnQ7IGkrKykge1xuICAgIGJpbnMucHVzaCgwKTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gc2NhbGUgaXQgdG8gYmUgYmV0d2VlbiAwIGFuZCAxXG4gICAgc2NhbGVkID0gKGRhdGFbaV0gLSBtaW4pIC8gKG1heCAtIG1pbik7XG5cbiAgICAvLyBzY2FsZSBpdCB1cCB0byB0aGUgaGlzdG9ncmFtIHNpemVcbiAgICBzY2FsZWQgKj0gYmluQ291bnQ7XG5cbiAgICAvLyBkcm9wIGl0IGluIGEgYmluXG4gICAgc2NhbGVkID0gTWF0aC5mbG9vcihzY2FsZWQpO1xuXG4gICAgLy8gZWRnZSBjYXNlOiB0aGUgbWF4XG4gICAgaWYgKHNjYWxlZCA9PT0gYmluQ291bnQpIHsgc2NhbGVkLS07IH1cblxuICAgIGJpbnNbc2NhbGVkXSsrO1xuICB9XG5cbiAgcmV0dXJuIGJpbnM7XG59XG5cbi8qKlxuICogR2V0IGEgcmFuZG9tIGVsZW1lbnQgZnJvbSBhIGxpc3RcbiAqL1xuZnVuY3Rpb24gcmxpc3QobGlzdCkge1xuICByZXR1cm4gbGlzdFtydW5pZigwLCBsaXN0Lmxlbmd0aCwgdHJ1ZSldO1xufVxuXG5leHBvcnRzLnJ1bmlmID0gcnVuaWY7XG5leHBvcnRzLnJub3JtID0gcm5vcm07XG5leHBvcnRzLnJjaGlzcSA9IHJjaGlzcTtcbmV4cG9ydHMucnBvaXNzb24gPSBycG9pc3NvbjtcbmV4cG9ydHMucmNhdWNoeSA9IHJjYXVjaHk7XG5leHBvcnRzLnJiZXJub3VsbGkgPSByYmVybm91bGxpO1xuZXhwb3J0cy5ybGlzdCA9IHJsaXN0O1xuXG5leHBvcnRzLnJ2dW5pZiA9IHZlY3Rvcml6ZShydW5pZik7XG5leHBvcnRzLnJ2bm9ybSA9IHZlY3Rvcml6ZShybm9ybSk7XG5leHBvcnRzLnJ2Y2hpc3EgPSB2ZWN0b3JpemUocmNoaXNxKTtcbmV4cG9ydHMucnZwb2lzc29uID0gdmVjdG9yaXplKHJwb2lzc29uKTtcbmV4cG9ydHMucnZjYXVjaHkgPSB2ZWN0b3JpemUocmNhdWNoeSk7XG5leHBvcnRzLnJ2YmVybm91bGxpID0gdmVjdG9yaXplKHJiZXJub3VsbGkpO1xuZXhwb3J0cy5ydmxpc3QgPSB2ZWN0b3JpemUocmxpc3QpO1xuXG5leHBvcnRzLmhpc3RvZ3JhbSA9IGhpc3RvZ3JhbTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4JykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ci5yZXBsYWNlKGFuc2lSZWdleCwgJycpIDogc3RyO1xufTtcbiIsIi8qIGpzaGludCBub2RlOiB0cnVlICovXG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIG1ha2VBcnJheUZyb20ob2JqKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkob2JqKTtcbn1cbnZhclxuICBQRU5ESU5HID0gXCJwZW5kaW5nXCIsXG4gIFJFU09MVkVEID0gXCJyZXNvbHZlZFwiLFxuICBSRUpFQ1RFRCA9IFwicmVqZWN0ZWRcIjtcblxuZnVuY3Rpb24gU3luY2hyb25vdXNQcm9taXNlKGhhbmRsZXIpIHtcbiAgdGhpcy5zdGF0dXMgPSBQRU5ESU5HO1xuICB0aGlzLl9jb250aW51YXRpb25zID0gW107XG4gIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICBpZiAoaGFuZGxlcikge1xuICAgIGhhbmRsZXIuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICB0aGlzLl9jb250aW51ZVdpdGguYmluZCh0aGlzKSxcbiAgICAgIHRoaXMuX2ZhaWxXaXRoLmJpbmQodGhpcylcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxvb2tzTGlrZUFQcm9taXNlKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiAob2JqLnRoZW4pID09PSBcImZ1bmN0aW9uXCI7XG59XG5cblN5bmNocm9ub3VzUHJvbWlzZS5wcm90b3R5cGUgPSB7XG4gIHRoZW46IGZ1bmN0aW9uIChuZXh0Rm4sIGNhdGNoRm4pIHtcbiAgICB2YXIgbmV4dCA9IFN5bmNocm9ub3VzUHJvbWlzZS51bnJlc29sdmVkKCkuX3NldFBhcmVudCh0aGlzKTtcbiAgICBpZiAodGhpcy5faXNSZWplY3RlZCgpKSB7XG4gICAgICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICAgIHRoaXMuX2NvbnRpbnVhdGlvbnMucHVzaCh7XG4gICAgICAgICAgcHJvbWlzZTogbmV4dCxcbiAgICAgICAgICBuZXh0Rm46IG5leHRGbixcbiAgICAgICAgICBjYXRjaEZuOiBjYXRjaEZuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChjYXRjaEZuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGNhdGNoUmVzdWx0ID0gY2F0Y2hGbih0aGlzLl9lcnJvcik7XG4gICAgICAgICAgaWYgKGxvb2tzTGlrZUFQcm9taXNlKGNhdGNoUmVzdWx0KSkge1xuICAgICAgICAgICAgdGhpcy5fY2hhaW5Qcm9taXNlRGF0YShjYXRjaFJlc3VsdCwgbmV4dCk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKGNhdGNoUmVzdWx0KS5fc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVqZWN0KGUpLl9zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVqZWN0KHRoaXMuX2Vycm9yKS5fc2V0UGFyZW50KHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9jb250aW51YXRpb25zLnB1c2goe1xuICAgICAgcHJvbWlzZTogbmV4dCxcbiAgICAgIG5leHRGbjogbmV4dEZuLFxuICAgICAgY2F0Y2hGbjogY2F0Y2hGblxuICAgIH0pO1xuICAgIHRoaXMuX3J1blJlc29sdXRpb25zKCk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH0sXG4gIGNhdGNoOiBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHtcbiAgICAgIHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZSh0aGlzLl9kYXRhKS5fc2V0UGFyZW50KHRoaXMpO1xuICAgIH1cbiAgICB2YXIgbmV4dCA9IFN5bmNocm9ub3VzUHJvbWlzZS51bnJlc29sdmVkKCkuX3NldFBhcmVudCh0aGlzKTtcbiAgICB0aGlzLl9jb250aW51YXRpb25zLnB1c2goe1xuICAgICAgcHJvbWlzZTogbmV4dCxcbiAgICAgIGNhdGNoRm46IGhhbmRsZXJcbiAgICB9KTtcbiAgICB0aGlzLl9ydW5SZWplY3Rpb25zKCk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH0sXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZpcnN0UGF1c2VkID0gdGhpcy5fZmluZEZpcnN0UGF1c2VkKCk7XG4gICAgaWYgKGZpcnN0UGF1c2VkKSB7XG4gICAgICBmaXJzdFBhdXNlZC5fcGF1c2VkID0gZmFsc2U7XG4gICAgICBmaXJzdFBhdXNlZC5fcnVuUmVzb2x1dGlvbnMoKTtcbiAgICAgIGZpcnN0UGF1c2VkLl9ydW5SZWplY3Rpb25zKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfZmluZEFuY2VzdHJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRpbnVhdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cikge1xuICAgICAgaWYgKGN1ci5wcm9taXNlKSB7XG4gICAgICAgIHZhciBub2RlID0ge1xuICAgICAgICAgIHByb21pc2U6IGN1ci5wcm9taXNlLFxuICAgICAgICAgIGNoaWxkcmVuOiBjdXIucHJvbWlzZS5fZmluZEFuY2VzdHJ5KClcbiAgICAgICAgfTtcbiAgICAgICAgYWNjLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgfSxcbiAgX3NldFBhcmVudDogZnVuY3Rpb24gKHBhcmVudCkge1xuICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInBhcmVudCBhbHJlYWR5IHNldFwiKTtcbiAgICB9XG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfY29udGludWVXaXRoOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBmaXJzdFBlbmRpbmcgPSB0aGlzLl9maW5kRmlyc3RQZW5kaW5nKCk7XG4gICAgaWYgKGZpcnN0UGVuZGluZykge1xuICAgICAgZmlyc3RQZW5kaW5nLl9kYXRhID0gZGF0YTtcbiAgICAgIGZpcnN0UGVuZGluZy5fc2V0UmVzb2x2ZWQoKTtcbiAgICB9XG4gIH0sXG4gIF9maW5kRmlyc3RQZW5kaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRGaXJzdEFuY2VzdG9yKGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgICByZXR1cm4gdGVzdC5faXNQZW5kaW5nICYmIHRlc3QuX2lzUGVuZGluZygpO1xuICAgIH0pO1xuICB9LFxuICBfZmluZEZpcnN0UGF1c2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmRGaXJzdEFuY2VzdG9yKGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgICByZXR1cm4gdGVzdC5fcGF1c2VkO1xuICAgIH0pO1xuICB9LFxuICBfZmluZEZpcnN0QW5jZXN0b3I6IGZ1bmN0aW9uIChtYXRjaGluZykge1xuICAgIHZhciB0ZXN0ID0gdGhpcztcbiAgICB2YXIgcmVzdWx0O1xuICAgIHdoaWxlICh0ZXN0KSB7XG4gICAgICBpZiAobWF0Y2hpbmcodGVzdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gdGVzdDtcbiAgICAgIH1cbiAgICAgIHRlc3QgPSB0ZXN0Ll9wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIF9mYWlsV2l0aDogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgdmFyIGZpcnN0UmVqZWN0ZWQgPSB0aGlzLl9maW5kRmlyc3RQZW5kaW5nKCk7XG4gICAgaWYgKGZpcnN0UmVqZWN0ZWQpIHtcbiAgICAgIGZpcnN0UmVqZWN0ZWQuX2Vycm9yID0gZXJyb3I7XG4gICAgICBmaXJzdFJlamVjdGVkLl9zZXRSZWplY3RlZCgpO1xuICAgIH1cbiAgfSxcbiAgX3Rha2VDb250aW51YXRpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRpbnVhdGlvbnMuc3BsaWNlKDAsIHRoaXMuX2NvbnRpbnVhdGlvbnMubGVuZ3RoKTtcbiAgfSxcbiAgX3J1blJlamVjdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcGF1c2VkIHx8ICF0aGlzLl9pc1JlamVjdGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyXG4gICAgICBlcnJvciA9IHRoaXMuX2Vycm9yLFxuICAgICAgY29udGludWF0aW9ucyA9IHRoaXMuX3Rha2VDb250aW51YXRpb25zKCksXG4gICAgICBzZWxmID0gdGhpcztcbiAgICBjb250aW51YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGNvbnQpIHtcbiAgICAgIGlmIChjb250LmNhdGNoRm4pIHtcbiAgICAgICAgdmFyIGNhdGNoUmVzdWx0ID0gY29udC5jYXRjaEZuKGVycm9yKTtcbiAgICAgICAgc2VsZi5faGFuZGxlVXNlckZ1bmN0aW9uUmVzdWx0KGNhdGNoUmVzdWx0LCBjb250LnByb21pc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udC5wcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIF9ydW5SZXNvbHV0aW9uczogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9wYXVzZWQgfHwgIXRoaXMuX2lzUmVzb2x2ZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY29udGludWF0aW9ucyA9IHRoaXMuX3Rha2VDb250aW51YXRpb25zKCk7XG4gICAgaWYgKGxvb2tzTGlrZUFQcm9taXNlKHRoaXMuX2RhdGEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFuZGxlV2hlblJlc29sdmVkRGF0YUlzUHJvbWlzZSh0aGlzLl9kYXRhKTtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBjb250aW51YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGNvbnQpIHtcbiAgICAgIGlmIChjb250Lm5leHRGbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBjb250Lm5leHRGbihkYXRhKTtcbiAgICAgICAgICBzZWxmLl9oYW5kbGVVc2VyRnVuY3Rpb25SZXN1bHQocmVzdWx0LCBjb250LnByb21pc2UpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgc2VsZi5faGFuZGxlUmVzb2x1dGlvbkVycm9yKGUsIGNvbnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvbnQucHJvbWlzZSkge1xuICAgICAgICBjb250LnByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgX2hhbmRsZVJlc29sdXRpb25FcnJvcjogZnVuY3Rpb24gKGUsIGNvbnRpbnVhdGlvbikge1xuICAgIHRoaXMuX3NldFJlamVjdGVkKCk7XG4gICAgaWYgKGNvbnRpbnVhdGlvbi5jYXRjaEZuKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb250aW51YXRpb24uY2F0Y2hGbihlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgZSA9IGUyO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGludWF0aW9uLnByb21pc2UpIHtcbiAgICAgIGNvbnRpbnVhdGlvbi5wcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH0sXG4gIF9oYW5kbGVXaGVuUmVzb2x2ZWREYXRhSXNQcm9taXNlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gZGF0YS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIHNlbGYuX2RhdGEgPSByZXN1bHQ7XG4gICAgICBzZWxmLl9ydW5SZXNvbHV0aW9ucygpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgc2VsZi5fZXJyb3IgPSBlcnJvcjtcbiAgICAgIHNlbGYuX3NldFJlamVjdGVkKCk7XG4gICAgICBzZWxmLl9ydW5SZWplY3Rpb25zKCk7XG4gICAgfSk7XG4gIH0sXG4gIF9oYW5kbGVVc2VyRnVuY3Rpb25SZXN1bHQ6IGZ1bmN0aW9uIChkYXRhLCBuZXh0U3luY2hyb25vdXNQcm9taXNlKSB7XG4gICAgaWYgKGxvb2tzTGlrZUFQcm9taXNlKGRhdGEpKSB7XG4gICAgICB0aGlzLl9jaGFpblByb21pc2VEYXRhKGRhdGEsIG5leHRTeW5jaHJvbm91c1Byb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0U3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoZGF0YSk7XG4gICAgfVxuICB9LFxuICBfY2hhaW5Qcm9taXNlRGF0YTogZnVuY3Rpb24gKHByb21pc2VEYXRhLCBuZXh0U3luY2hyb25vdXNQcm9taXNlKSB7XG4gICAgcHJvbWlzZURhdGEudGhlbihmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgbmV4dFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKG5ld0RhdGEpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChuZXdFcnJvcikge1xuICAgICAgbmV4dFN5bmNocm9ub3VzUHJvbWlzZS5yZWplY3QobmV3RXJyb3IpO1xuICAgIH0pO1xuICB9LFxuICBfc2V0UmVzb2x2ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnN0YXR1cyA9IFJFU09MVkVEO1xuICAgIGlmICghdGhpcy5fcGF1c2VkKSB7XG4gICAgICB0aGlzLl9ydW5SZXNvbHV0aW9ucygpO1xuICAgIH1cbiAgfSxcbiAgX3NldFJlamVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBSRUpFQ1RFRDtcbiAgICBpZiAoIXRoaXMuX3BhdXNlZCkge1xuICAgICAgdGhpcy5fcnVuUmVqZWN0aW9ucygpO1xuICAgIH1cbiAgfSxcbiAgX2lzUGVuZGluZzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gUEVORElORztcbiAgfSxcbiAgX2lzUmVzb2x2ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IFJFU09MVkVEO1xuICB9LFxuICBfaXNSZWplY3RlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gUkVKRUNURUQ7XG4gIH1cbn07XG5cblN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICByZXR1cm4gbmV3IFN5bmNocm9ub3VzUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKGxvb2tzTGlrZUFQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uIChuZXdSZXN1bHQpIHtcbiAgICAgICAgcmVzb2x2ZShuZXdSZXN1bHQpO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5TeW5jaHJvbm91c1Byb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICByZXR1cm4gbmV3IFN5bmNocm9ub3VzUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVqZWN0KHJlc3VsdCk7XG4gIH0pO1xufTtcblxuU3luY2hyb25vdXNQcm9taXNlLnVucmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgU3luY2hyb25vdXNQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcbn07XG5cblN5bmNocm9ub3VzUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcmdzID0gbWFrZUFycmF5RnJvbShhcmd1bWVudHMpO1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgIGFyZ3MgPSBhcmdzWzBdO1xuICB9XG4gIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICByZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoW10pO1xuICB9XG4gIHJldHVybiBuZXcgU3luY2hyb25vdXNQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXJcbiAgICAgIGFsbERhdGEgPSBbXSxcbiAgICAgIG51bVJlc29sdmVkID0gMCxcbiAgICAgIGRvUmVzb2x2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG51bVJlc29sdmVkID09PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIHJlc29sdmUoYWxsRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZWplY3RlZCA9IGZhbHNlLFxuICAgICAgZG9SZWplY3QgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWplY3RlZCA9IHRydWU7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfTtcbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGFyZywgaWR4KSB7XG4gICAgICBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZShhcmcpLnRoZW4oZnVuY3Rpb24gKHRoaXNSZXN1bHQpIHtcbiAgICAgICAgYWxsRGF0YVtpZHhdID0gdGhpc1Jlc3VsdDtcbiAgICAgICAgbnVtUmVzb2x2ZWQgKz0gMTtcbiAgICAgICAgZG9SZXNvbHZlKCk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGRvUmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG5pZiAoUHJvbWlzZSA9PT0gU3luY2hyb25vdXNQcm9taXNlKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSB1c2UgU3luY2hyb25vdXNQcm9taXNlLmluc3RhbGxHbG9iYWxseSgpIHRvIGluc3RhbGwgZ2xvYmFsbHlcIik7XG59XG52YXIgUmVhbFByb21pc2UgPSBQcm9taXNlO1xuU3luY2hyb25vdXNQcm9taXNlLmluc3RhbGxHbG9iYWxseSA9IGZ1bmN0aW9uKF9fYXdhaXRlcikge1xuICBpZiAoUHJvbWlzZSA9PT0gU3luY2hyb25vdXNQcm9taXNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcjtcbiAgfSBcbiAgdmFyIHJlc3VsdCA9IHBhdGNoQXdhaXRlcklmUmVxdWlyZWQoX19hd2FpdGVyKTtcbiAgUHJvbWlzZSA9IFN5bmNocm9ub3VzUHJvbWlzZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblN5bmNocm9ub3VzUHJvbWlzZS51bmluc3RhbGxHbG9iYWxseSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoUHJvbWlzZSA9PT0gU3luY2hyb25vdXNQcm9taXNlKSB7XG4gICAgUHJvbWlzZSA9IFJlYWxQcm9taXNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwYXRjaEF3YWl0ZXJJZlJlcXVpcmVkKF9fYXdhaXRlcikge1xuICBpZiAodHlwZW9mKF9fYXdhaXRlcikgPT09IFwidW5kZWZpbmVkXCIgfHwgX19hd2FpdGVyLl9fcGF0Y2hlZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXI7XG4gIH1cbiAgdmFyIG9yaWdpbmFsQXdhaXRlciA9IF9fYXdhaXRlcjtcbiAgX19hd2FpdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIFByb21pc2UgPSBSZWFsUHJvbWlzZTtcbiAgICBvcmlnaW5hbEF3YWl0ZXIuYXBwbHkodGhpcywgbWFrZUFycmF5RnJvbShhcmd1bWVudHMpKTtcbiAgfTtcbiAgX19hd2FpdGVyLl9fcGF0Y2hlZCA9IHRydWU7XG4gIHJldHVybiBfX2F3YWl0ZXI7XG59XG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgU3luY2hyb25vdXNQcm9taXNlOiBTeW5jaHJvbm91c1Byb21pc2Vcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBQbHVnaW4gdG8gYWRkICdwcm9wZXJ0eScgKGFzIGluIHBlcnNvbmFsIHByb3BlcnR5KSBwcm9wZXJ0eSB0byBQbGF5ZXJzIHdoZW4gdGhleSBhcmUgaW5pdGlhbGl6ZWQuIE1lYW50IHRvIGJlIHVzZWQgZm9yXHJcbi8vIHNpbXVsYXRpb25zIGludm9sdmluZyBwZXJzb25hbCBwb3Nlc3Npb25zLCBmb3IgaW5zdGFuY2UgZWNvbm9taWMgc2ltdWxhdGlvbnMuXHJcblxyXG4vLyBOYXNoSlMgZW5naW5lIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG4vLyBHYW1lIHN0YXRlXHJcbnZhciB7IHJlZ2lzdHJ5LCBnYW1lUG9wdWxhdGlvbiB9ID0gRW5naW5lLkJhY2tlbmQuU3RhdGU7XHJcblxyXG4vLyBMZXQncyBhZGQgc29tZSBQbGF5ZXJMaXN0IGZ1bmN0aW9uYWxpdHlcclxudmFyIHsgUGxheWVyTGlzdCB9ID0gRW5naW5lLkJhY2tlbmQuQ2xhc3NlcztcclxuXHJcblxyXG52YXIgQmFsYW5jZVNoZWV0ID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdC8vIFZhcmlhYmxlcyB0byBzdG9yZSBzZXR0aW5ncywgYW5kIGRlZmF1bHRzXHJcblx0dmFyIHNldHRpbmdzID0ge1xyXG5cdFx0YWRkQmFsYW5jZVNoZWV0T25DbGFpbTogdHJ1ZSxcclxuXHRcdGNsZWFuWmVyb3M6IHRydWUsXHJcblx0XHRuZWdhdGl2ZUFzc2V0czogZmFsc2VcclxuXHR9XHJcblx0Ly9UT0RPIG1ha2UgbmVnYXRpdmVBc3NldHMgKGFuZCBuZWdhdGl2ZUxpYWJpbGl0aWVzKSB3b3JrXHJcblxyXG5cclxuXHQvLyBBc3NldHMgQ2xhc3Nlc1xyXG5cclxuXHQvLyBDbGFpbSBwYXJlbnQgY2xhc3NcclxuXHR2YXIgQ2xhaW0gPSBmdW5jdGlvbihjbGFpbWFudCwgYW1vdW50KSB7XHJcblx0XHQvLyBBZGQgYmFsYW5jZSBzaGVldCBpZiBuZWNlc3NhcnkgYW5kIHBlcm1pdHRlZFxyXG5cdFx0aWYgKCFjbGFpbWFudC5iYWxhbmNlU2hlZXQpIHtcclxuXHRcdFx0aWYgKHNldHRpbmdzLmFkZEJhbGFuY2VTaGVldE9uQ2xhaW0pIGFkZEVudHJpZXMocmVnaXN0cnkucGxheWVyc1tjbGFpbWFudC5pZCgpXSlcclxuXHRcdFx0Ly8gRmFpbCBpZiBub3QgcGVybWl0dGVkIHRvIGFkZCBuZWNlc3NhcnkgYmFsYW5jZSBzaGVldC5cclxuXHRcdFx0ZWxzZSByZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hbW91bnQgPSBhbW91bnQ7XHJcblx0XHR0aGlzLmNsYWltYW50ID0gY2xhaW1hbnRcclxuXHRcdGNsYWltYW50LmVuZG93KHRoaXMpXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8vIEVuZCBvd25lcnNoaXAgY2xhaW1cclxuXHRDbGFpbS5wcm90b3R5cGUuZXJhc2UgPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuY2xhaW1hbnQucmV2b2tlKHRoaXMpXHJcblx0XHR0aGlzLmNsYWltYW50ID0gbnVsbDtcclxuXHRcdHRoaXMuYW1vdW50ID0gMFxyXG5cdH1cclxuXHJcblx0Ly8gTWVyZ2UgY2xhaW1zIGlmIHRoZXkncmUgdGhlIHNhbWUgZmFtaWx5IGJ1dCBkaWZmZXJlbnQgYW1vdW50c1xyXG5cdENsYWltLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKG90aGVyQ2xhaW0pIHtcclxuXHRcdGlmICh0aGlzLmNsYWltYW50ICE9PSBvdGhlckNsYWltLmNsYWltYW50KSByZXR1cm4gZmFsc2VcclxuXHRcdC8vIEFkZCBhbW91bnRzXHJcblx0XHR0aGlzLmFtb3VudCA9IHRoaXMuYW1vdW50ICsgb3RoZXJDbGFpbS5hbW91bnRcclxuXHJcblx0XHQvLyBSZW1vdmUgZnJvbSBiYWxhbmNlIHNoZWV0XHJcblx0XHRvdGhlckNsYWltLmVyYXNlKCk7XHJcblx0fVxyXG5cclxuXHQvLyBTcGxpdCB0aGlzIGludG8gdHdvIHNlcGFyYXRlIGNsYWltcywgd2l0aCBkaWZmZXJlbnQgYW1vdW50c1xyXG5cdENsYWltLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uKG5ld0Ftb3VudCkge1xyXG5cdFx0dmFyIGNsb25lID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSksIHRoaXMpO1xyXG5cdFx0Y2xvbmUuYW1vdW50ID0gbmV3QW1vdW50O1xyXG5cdFx0dGhpcy5hbW91bnQgPSB0aGlzLmFtb3VudCAtIG5ld0Ftb3VudDtcclxuXHRcdHRoaXMuY2xhaW1hbnQuZW5kb3coY2xvbmUsIGZhbHNlKVxyXG5cdFx0cmV0dXJuIGNsb25lO1xyXG5cdH1cclxuXHJcblx0Ly8gVHJhbnNmZXIgdG8gbmV3IG93bmVyXHJcblx0Q2xhaW0ucHJvdG90eXBlLnRyYW5zZmVyID0gZnVuY3Rpb24obmV3Q2xhaW1hbnQsIGFtb3VudCA9IFwiYWxsXCIpIHtcclxuXHRcdC8vIEFkZCBiYWxhbmNlIHNoZWV0IGlmIG5lY2Vzc2FyeSBhbmQgcGVybWl0dGVkXHJcblx0XHRpZiAoIW5ld0NsYWltYW50LmJhbGFuY2VTaGVldCkge1xyXG5cdFx0XHRpZiAoc2V0dGluZ3MuYWRkQmFsYW5jZVNoZWV0T25DbGFpbSkgYWRkRW50cmllcyhyZWdpc3RyeS5wbGF5ZXJzW25ld0NsYWltYW50LmlkKCldKVxyXG5cdFx0XHQvLyBGYWlsIGlmIG5vdCBwZXJtaXR0ZWQgdG8gYWRkIG5lY2Vzc2FyeSBiYWxhbmNlIHNoZWV0LlxyXG5cdFx0XHRlbHNlIHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBUcmFuc2ZlciBhbGwgb2YgaXRcclxuXHRcdGlmIChhbW91bnQgPT0gXCJhbGxcIiB8fCBhbW91bnQgPT0gdGhpcy5hbW91bnQpIHtcclxuXHRcdFx0dmFyIG9sZENsYWltYW50ID0gdGhpcy5jbGFpbWFudDtcclxuXHRcdFx0dGhpcy5jbGFpbWFudC5yZXZva2UodGhpcyk7XHJcblx0XHRcdHRoaXMuY2xhaW1hbnQgPSBuZXdDbGFpbWFudDtcclxuXHRcdFx0bmV3Q2xhaW1hbnQuZW5kb3codGhpcyk7XHJcblxyXG5cdFx0fVxyXG5cdFx0Ly8gb3Igb25seSBhIHBvcnRpb25cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR2YXIgbmV3Q2xhaW0gPSB0aGlzLnNwbGl0KGFtb3VudCk7XHJcblx0XHRcdG5ld0NsYWltLnRyYW5zZmVyKG5ld0NsYWltYW50LCBcImFsbFwiKVxyXG5cdFx0XHRjbGVhbkFzc2V0KHRoaXMpXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBDbGFpbXMgb24gcmVhbCB0aGluZ3MgKGxpa2UgY2FycywgaG91c2VzLCBnb2xkKVxyXG5cdHZhciBSZWFsQ2xhaW0gPSBmdW5jdGlvbihjbGFpbWFudCwgZ29vZCwgYW1vdW50KSB7XHJcblx0XHRpZiAoIUNsYWltLmNhbGwodGhpcywgY2xhaW1hbnQsIGFtb3VudCkpIHJldHVybiBmYWxzZTtcclxuXHRcdHRoaXMuZ29vZCA9IGdvb2Q7XHJcblx0fVxyXG5cdFJlYWxDbGFpbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYWltLnByb3RvdHlwZSlcclxuXHRSZWFsQ2xhaW0ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVhbENsYWltXHJcblxyXG5cdC8vIExvc2UgdmFsdWUgYnkgcGVyY2VudGFnZVxyXG5cdFJlYWxDbGFpbS5wcm90b3R5cGUuZGVwcmVjaWF0ZSA9IGZ1bmN0aW9uKHJhdGUgPSAuMSkge1xyXG5cdFx0dGhpcy5hbW91bnQgPSB0aGlzLmFtb3VudCAqICgxIC0gcmF0ZSlcclxuXHR9XHJcblxyXG5cdC8vIEFkZCBnb29kIGVuZm9yY2VtZW50IHRvIG1lcmdlXHJcblx0UmVhbENsYWltLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKG90aGVyQ2xhaW0pIHtcclxuXHRcdGlmICh0aGlzLmdvb2QgPT09IG90aGVyQ2xhaW0uZ29vZCkgcmV0dXJuIENsYWltLnByb3RvdHlwZS5tZXJnZS5jYWxsKHRoaXMsIG90aGVyQ2xhaW0pO1xyXG5cdH1cclxuXHJcblx0Ly8gUmVwbGFjZSBwbGF5ZXIgb2JqZWN0IHdpdGggaWQgd2hlbiBzdHJpbmdpZnlpbmdcclxuXHRSZWFsQ2xhaW0ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Y2xhaW1hbnQ6IHRoaXMuY2xhaW1hbnQuaWQoKSxcclxuXHRcdFx0Z29vZDogdGhpcy5nb29kLFxyXG5cdFx0XHRhbW91bnQ6IHRoaXMuYW1vdW50XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBDbGFpbXMgb24gb3RoZXIgZW50aXRpZXMgd2l0aCBiYWxhbmNlIHNoZWV0c1xyXG5cdHZhciBGaW5hbmNpYWxDbGFpbSA9IGZ1bmN0aW9uKGNsYWltYW50LCBjbGFpbWVkLCBhbW91bnQsIGluc3RydW1lbnQgPSBcIkRlYnRcIikge1xyXG5cdFx0Ly8gQWRkIGJhbGFuY2Ugc2hlZXQgaWYgbmVjZXNzYXJ5IGFuZCBwZXJtaXR0ZWRcclxuXHRcdGlmICghY2xhaW1lZC5iYWxhbmNlU2hlZXQpIHtcclxuXHRcdFx0aWYgKHNldHRpbmdzLmFkZEJhbGFuY2VTaGVldE9uQ2xhaW0pIGFkZEVudHJpZXMocmVnaXN0cnkucGxheWVyc1tjbGFpbWVkLmlkKCldKVxyXG5cdFx0XHQvLyBGYWlsIGlmIG5vdCBwZXJtaXR0ZWQgdG8gYWRkIG5lY2Vzc2FyeSBiYWxhbmNlIHNoZWV0LlxyXG5cdFx0XHRlbHNlIHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHRoaXMuY2xhaW1lZCA9IGNsYWltZWQ7XHJcblx0XHR0aGlzLmluc3RydW1lbnQgPSBpbnN0cnVtZW50O1xyXG5cclxuXHRcdGlmICghQ2xhaW0uY2FsbCh0aGlzLCBjbGFpbWFudCwgYW1vdW50KSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdGNsYWltZWQuaW5kZWJ0KHRoaXMpXHJcblx0fVxyXG5cdEZpbmFuY2lhbENsYWltLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhaW0ucHJvdG90eXBlKVxyXG5cdEZpbmFuY2lhbENsYWltLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZpbmFuY2lhbENsYWltXHJcblxyXG5cdC8vIEFkZCB0byBlcmFzZSBmdW5jdGlvbiwgdG8gZXJhc2UgZnJvbSBjbGFpbWVkJ3MgYmFsYW5jZSBzaGVldCB0b29cclxuXHRGaW5hbmNpYWxDbGFpbS5wcm90b3R5cGUuZXJhc2UgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBicyA9IHJlZ2lzdHJ5LnBsYXllcnNbdGhpcy5jbGFpbWVkLmlkKCldLmJhbGFuY2VTaGVldC5saWFiaWxpdGllc1xyXG5cdFx0YnMuc3BsaWNlKGJzLmluZGV4T2YodGhpcyksIDEpXHJcblx0XHR0aGlzLmNsYWltZWQgPSBudWxsO1xyXG5cclxuXHRcdHJldHVybiBDbGFpbS5wcm90b3R5cGUuZXJhc2UuY2FsbCh0aGlzKVxyXG5cdH1cclxuXHJcblx0Ly8gQWRkIGNsYWltZWQgZW5mb3JjZW1lbnQgdG8gbWVyZ2VcclxuXHRGaW5hbmNpYWxDbGFpbS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihvdGhlckNsYWltKSB7XHJcblx0XHRpZiAodGhpcy5jbGFpbWVkID09PSBvdGhlckNsYWltLmNsYWltZWQpIHJldHVybiBDbGFpbS5wcm90b3R5cGUubWVyZ2UuY2FsbCh0aGlzLCBvdGhlckNsYWltKTtcclxuXHR9XHJcblxyXG5cclxuXHQvLyBBZGQgdG8gc3BsaXQgZnVuY3Rpb24sIHRvIHNwbGl0IG9uIGNsYWltZWQncyBiYWxhbmNlIHNoZWV0IHRvb1xyXG5cdEZpbmFuY2lhbENsYWltLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uKG5ld0Ftb3VudCkge1xyXG5cdFx0dmFyIGNsb25lID0gQ2xhaW0ucHJvdG90eXBlLnNwbGl0LmNhbGwodGhpcywgbmV3QW1vdW50KTtcclxuXHRcdGNsb25lLmNsYWltZWQuaW5kZWJ0KGNsb25lLCBmYWxzZSk7XHJcblx0XHRyZXR1cm4gY2xvbmU7XHJcblx0fVxyXG5cclxuXHQvLyBSZXBsYWNlIHBsYXllciBvYmplY3Qgd2l0aCBpZCB3aGVuIHN0cmluZ2lmeWluZ1xyXG5cdEZpbmFuY2lhbENsYWltLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGNsYWltYW50OiB0aGlzLmNsYWltYW50LmlkKCksXHJcblx0XHRcdGNsYWltZWQ6IHRoaXMuY2xhaW1lZC5pZCgpLFxyXG5cdFx0XHRpbnN0cnVtZW50OiB0aGlzLmluc3RydW1lbnQsXHJcblx0XHRcdGFtb3VudDogdGhpcy5hbW91bnRcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHQvLyBDbGVhbiB0aGUgc2ltaWxhciBjbGFpbXMgb24gdGhlIGNsYWltYW50IHN1cHBsaWVkXHJcblx0dmFyIGNsZWFuQXNzZXQgPSBmdW5jdGlvbihjbGFpbSkge1xyXG5cdFx0dmFyIGJzID0gcmVnaXN0cnkucGxheWVyc1tjbGFpbS5jbGFpbWFudC5pZCgpXS5iYWxhbmNlU2hlZXQuYXNzZXRzO1xyXG5cclxuXHRcdHZhciBkaXJ0eSA9IGJzLmZpbHRlcihmdW5jdGlvbihlbnRyeSkge1xyXG5cdFx0XHRyZXR1cm4gKGVudHJ5ICE9PSBjbGFpbSAmJiBlbnRyeS5nb29kID09PSBjbGFpbS5nb29kICYmIGVudHJ5Lmluc3RydW1lbnQgPT09IGNsYWltLmluc3RydW1lbnQpO1xyXG5cdFx0fSlcclxuXHJcblx0XHRkaXJ0eS5mb3JFYWNoKGZ1bmN0aW9uKGRpcnQpIHtcclxuXHRcdFx0Y2xhaW0ubWVyZ2UoZGlydClcclxuXHRcdH0pXHJcblxyXG5cdFx0aWYgKHNldHRpbmdzLmNsZWFuWmVyb3MgJiYgY2xhaW0uYW1vdW50ID09IDApIGNsYWltLmVyYXNlKClcclxuXHR9XHJcblxyXG5cdHZhciBjbGVhbkxpYWJpbGl0eSA9IGZ1bmN0aW9uKGNsYWltKSB7XHJcblx0XHR2YXIgYnMgPSByZWdpc3RyeS5wbGF5ZXJzW2NsYWltLmNsYWltZWQuaWQoKV0uYmFsYW5jZVNoZWV0LmxpYWJpbGl0aWVzO1xyXG5cclxuXHRcdHZhciBkaXJ0eSA9IGJzLmZpbHRlcihmdW5jdGlvbihlbnRyeSkge1xyXG5cdFx0XHRyZXR1cm4gKGVudHJ5ICE9PSBjbGFpbSAmJiBlbnRyeS5jbGFpbWFudCA9PT0gY2xhaW0uY2xhaW1hbnQgJiYgZW50cnkuaW5zdHJ1bWVudCA9PT0gY2xhaW0uaW5zdHJ1bWVudCk7XHJcblx0XHR9KVxyXG5cclxuXHRcdGRpcnR5LmZvckVhY2goZnVuY3Rpb24oZGlydCkge1xyXG5cdFx0XHRjbGFpbS5tZXJnZShkaXJ0KVxyXG5cdFx0fSlcclxuXHJcblx0XHRpZiAoc2V0dGluZ3MuY2xlYW5aZXJvcyAmJiBjbGFpbS5hbW91bnQgPT0gMCkgY2xhaW0uZXJhc2VcclxuXHR9XHJcblxyXG5cclxuXHJcblx0Ly8gQWRkIGJhbGFuY2Ugc2hlZXQgb2JqZWN0IGFuZCBtZXRob2RzIHRvIHBsYXllci5cclxuXHR2YXIgYWRkRW50cmllcyA9IGZ1bmN0aW9uKHBsYXllcikge1xyXG5cclxuXHRcdC8vX3BsYXllciBwcm9wZXJ0aWVzL21ldGhvZHNcclxuXHRcdHBsYXllci5iYWxhbmNlU2hlZXQgPSB7IGFzc2V0czogW10sIGxpYWJpbGl0aWVzOiBbXSB9XHJcblxyXG5cdFx0LypcclxuXHRcdHZhciBsb29rdXAgPSBmdW5jdGlvbih0eXBlKSB7XHJcblx0XHRcdHRoaXMucmVkdWNlKGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSkge1xyXG5cdFx0XHRcdGlmICh0eXBlID09PSB2YWx1ZS5nb29kKSBhY2N1bXVsYXRvciArPSB2YWx1ZS5hbW91bnRcclxuXHRcdFx0XHRlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgT2JqZWN0ICYmIHR5cGUuaW5zdHJ1bWVudCA9PSB2YWx1ZS5pbnN0cnVtZW50ICYmICh0eXBlLmNsYWltZWQgPT09IHZhbHVlLmNsYWltZWQpKVxyXG5cdFx0XHRcdFx0YWNjdW11bGF0b3IgKz0gdmFsdWUuYW1vdW50XHJcblx0XHRcdFx0cmV0dXJuIGFjY3VtdWxhdG9yO1xyXG5cdFx0XHR9LCAwKVxyXG5cdFx0fVxyXG5cdFx0cGxheWVyLmJhbGFuY2VTaGVldC5hc3NldHMubG9va3VwID0gbG9va3VwO1xyXG5cdFx0cGxheWVyLmJhbGFuY2VTaGVldC5saWFiaWxpdGllcy5sb29rdXAgPSBsb29rdXA7XHJcblx0XHQqL1xyXG5cclxuXHRcdHBsYXllci5uZXRXb3J0aCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0dmFyIGFzc2V0cyA9IHRoaXMuYmFsYW5jZVNoZWV0LmFzc2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSkge1xyXG5cdFx0XHRcdHJldHVybiBhY2N1bXVsYXRvciArIGN1cnJlbnRWYWx1ZS5hbW91bnRcclxuXHRcdFx0fSwgMCk7XHJcblxyXG5cdFx0XHR2YXIgbGlhYmlsaXRpZXMgPSB0aGlzLmJhbGFuY2VTaGVldC5saWFiaWxpdGllcy5yZWR1Y2UoZnVuY3Rpb24oYWNjdW11bGF0b3IsXHJcblx0XHRcdFx0Y3VycmVudFZhbHVlKSB7XHJcblx0XHRcdFx0cmV0dXJuIGFjY3VtdWxhdG9yICsgY3VycmVudFZhbHVlLmFtb3VudFxyXG5cdFx0XHR9LCAwKTtcclxuXHJcblx0XHRcdHJldHVybiBhc3NldHMgLSBsaWFiaWxpdGllcztcclxuXHRcdH1cclxuXHJcblx0XHQvLyBVc2VyIGludGVyZmFjZVxyXG5cdFx0cGxheWVyLmludGVyZmFjZS5iYWxhbmNlU2hlZXQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVnaXN0cnkucGxheWVyc1twbGF5ZXIuaWRdLmJhbGFuY2VTaGVldCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHBsYXllci5pbnRlcmZhY2UubmV0V29ydGggPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyLmlkXS5uZXRXb3J0aCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRPRE8gdmFsaWRhdGUgb2JqZWN0LlxyXG5cdFx0cGxheWVyLmludGVyZmFjZS5lbmRvdyA9IGZ1bmN0aW9uKGFzc2V0LCBjbGVhbiA9IHRydWUpIHtcclxuXHRcdFx0aWYgKGFzc2V0IGluc3RhbmNlb2YgQ2xhaW0pIHtcclxuXHRcdFx0XHRyZWdpc3RyeS5wbGF5ZXJzW3BsYXllci5pZF0uYmFsYW5jZVNoZWV0LmFzc2V0cy5wdXNoKGFzc2V0KTtcclxuXHRcdFx0XHRpZiAoY2xlYW4pIGNsZWFuQXNzZXQoYXNzZXQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cGxheWVyLmludGVyZmFjZS5pbmRlYnQgPSBmdW5jdGlvbihsaWFiaWxpdHksIGNsZWFuID0gdHJ1ZSkge1xyXG5cdFx0XHRpZiAobGlhYmlsaXR5IGluc3RhbmNlb2YgRmluYW5jaWFsQ2xhaW0pIHtcclxuXHRcdFx0XHRyZWdpc3RyeS5wbGF5ZXJzW3BsYXllci5pZF0uYmFsYW5jZVNoZWV0LmxpYWJpbGl0aWVzLnB1c2goXHJcblx0XHRcdFx0XHRsaWFiaWxpdHkpO1xyXG5cdFx0XHRcdGlmIChjbGVhbikgY2xlYW5MaWFiaWxpdHkobGlhYmlsaXR5KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHBsYXllci5pbnRlcmZhY2UucmV2b2tlID0gZnVuY3Rpb24oYXNzZXQpIHtcclxuXHRcdFx0aWYgKGFzc2V0IGluc3RhbmNlb2YgQ2xhaW0pIHtcclxuXHRcdFx0XHR2YXIgYnMgPSByZWdpc3RyeS5wbGF5ZXJzW3BsYXllci5pZF0uYmFsYW5jZVNoZWV0LmFzc2V0c1xyXG5cdFx0XHRcdGJzLnNwbGljZShicy5pbmRleE9mKGFzc2V0KSwgMSlcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRPRE8gY29udmVydCB0aGlzIG92ZXJcclxuXHRcdHBsYXllci5pbnRlcmZhY2UubGVuZCA9IGZ1bmN0aW9uKGJvcnJvd2VyLCBhbW91bnQsIGluc3RydW1lbnQgPSBcIkRlYnRcIikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IEZpbmFuY2lhbENsYWltKHBsYXllci5pbnRlcmZhY2UsIGJvcnJvd2VyLCBhbW91bnQsIGluc3RydW1lbnQpXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8vIFRoZSBwbHVnaW4gb2JqZWN0LlxyXG5cdHZhciBQbHVnaW4gPSB7XHJcblx0XHRuYW1lOiBcImJhbGFuY2Utc2hlZXQtY29tcGxleFwiLFxyXG5cclxuXHRcdHNldHRpbmdzOiBmdW5jdGlvbihwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRcdFx0T2JqZWN0LmFzc2lnbihzZXR0aW5ncywgcGFyYW1ldGVycylcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gT3B0aW9uIHRvIGluaXRpYWxpemUgYnkgY3JlYXRpbmcgJ3Byb3BlcnR5JyBmb3IgYSBncm91cCBvZiBwbGF5ZXJzLlxyXG5cdFx0aW5pdChwbGF5ZXJzID0gW10pIHtcclxuXHRcdFx0Ly8gQWRkIHNvbWUgcGxheWVybGlzdCBmdW5jdGlvbmFsaXR5XHJcblx0XHRcdFBsYXllckxpc3QucHJvdG90eXBlLmJhbGFuY2VTaGVldHMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0XHRpZiAocGxheWVyLmJhbGFuY2VTaGVldCkgcmV0dXJuIHBsYXllci5pbnRlcmZhY2UuYmFsYW5jZVNoZWV0KCk7XHJcblx0XHRcdFx0XHRlbHNlIHJldHVybiBudWxsO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRQbGF5ZXJMaXN0LnByb3RvdHlwZS5hc3NldHMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0XHRpZiAocGxheWVyLmJhbGFuY2VTaGVldCkgcmV0dXJuIHBsYXllci5pbnRlcmZhY2UuYmFsYW5jZVNoZWV0KCkuYXNzZXRzO1xyXG5cdFx0XHRcdFx0ZWxzZSByZXR1cm4gbnVsbDtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0UGxheWVyTGlzdC5wcm90b3R5cGUubGlhYmlsaXRpZXMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0XHRpZiAocGxheWVyLmJhbGFuY2VTaGVldCkgcmV0dXJuIHBsYXllci5pbnRlcmZhY2UuYmFsYW5jZVNoZWV0KCkubGlhYmlsaXRpZXM7XHJcblx0XHRcdFx0XHRlbHNlIHJldHVybiBudWxsO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRQbGF5ZXJMaXN0LnByb3RvdHlwZS5uZXRXb3J0aCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0XHRcdGlmIChwbGF5ZXIuYmFsYW5jZVNoZWV0KSByZXR1cm4gcGxheWVyLm5ldFdvcnRoKCk7XHJcblx0XHRcdFx0XHRlbHNlIHJldHVybiBudWxsO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRQbGF5ZXJMaXN0LnByb3RvdHlwZS56ZXJvQmFsYW5jZVNoZWV0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHRoaXMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0XHRcdGFkZEVudHJpZXMocGxheWVyKVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBBZGQgYnMgZm9yIHNwZWNpZmllZCBwbGF5ZXJzXHJcblx0XHRcdHBsYXllcnMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0XHRhZGRFbnRyaWVzKHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyLmlkKCldKTtcclxuXHRcdFx0fSlcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gSWYgd2UndmUgaW5pdC1lZCBhbHJlZHksIGp1c3QgYWRkIGJzJ3MgdG8gdGhlIGN1cnJlbnQgcGxheWVyIGxpc3QgaWYgdGhleSBkb24ndCBoYXZlIGFscmVhZHlcclxuXHRcdHJlcXVpcmUocGxheWVycyA9IFtdKSB7XHJcblx0XHRcdHBsYXllcnMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0XHRpZiAoIXBsYXllci5iYWxhbmNlU2hlZXQpIGFkZEVudHJpZXMocmVnaXN0cnkucGxheWVyc1twbGF5ZXIuaWQoKV0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0sXHJcblxyXG5cdFx0c3RvcCgpIHtcclxuXHRcdFx0Ly8gcmVtb3ZlIHByb3RvdHlwZSBhZGRFbnRyaWVzXHJcblx0XHRcdGRlbGV0ZSBQbGF5ZXJMaXN0LnByb3RvdHlwZS5iYWxhbmNlU2hlZXRzO1xyXG5cdFx0XHRkZWxldGUgUGxheWVyTGlzdC5wcm90b3R5cGUuYXNzZXRzO1xyXG5cdFx0XHRkZWxldGUgUGxheWVyTGlzdC5wcm90b3R5cGUubGlhYmlsaXRpZXM7XHJcblx0XHRcdGRlbGV0ZSBQbGF5ZXJMaXN0LnByb3RvdHlwZS5uZXRXb3J0aDtcclxuXHJcblx0XHRcdC8vIGRlbGV0ZSBiYWxhbmNlIHNoZWV0IHByb3BlcnRpZXMgZnJvbSBldmVyeSBwbGF5ZXIgYW5kIGludGVyZmFjZS5cclxuXHRcdFx0Z2FtZVBvcHVsYXRpb24oKS5mb3JFYWNoKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdGRlbGV0ZSBwbGF5ZXIuYmFsYW5jZVNoZWV0O1xyXG5cdFx0XHRcdGRlbGV0ZSBwbGF5ZXIubmV0V29ydGg7XHJcblx0XHRcdFx0ZGVsZXRlIHBsYXllci5pbnRlcmZhY2UuYmFsYW5jZVNoZWV0O1xyXG5cdFx0XHRcdGRlbGV0ZSBwbGF5ZXIuaW50ZXJmYWNlLm5ldFdvcnRoO1xyXG5cdFx0XHRcdGRlbGV0ZSBwbGF5ZXIuaW50ZXJmYWNlLmVuZG93QXNzZXRzO1xyXG5cdFx0XHRcdGRlbGV0ZSBwbGF5ZXIuaW50ZXJmYWNlLmxlbmQ7XHJcblx0XHRcdH0pXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIFB1YmxpYyBjbGFzc2VzIGZvciBhc3NldC9saWFiaWxpdHlcclxuXHRcdHB1YmxpY0lmQWN0aXZlOiB7XHJcblx0XHRcdFJlYWxDbGFpbSxcclxuXHRcdFx0RmluYW5jaWFsQ2xhaW1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gY3JlYXRlIHByb3BlcnR5IGFuZCBpbnRlcmZhY2UgZnVuY3Rpb24gd2hlbiBwbGF5ZXIgaXMgY3JlYXRlZFxyXG5cdFx0J3BsYXllci1jcmVhdGUnOiBhZGRFbnRyaWVzLFxyXG5cclxuXHRcdC8vIEJsYW5rIHByb3BlcnR5IHdoZW4gcGxheWVyIGlzIHJlLWluaXRpYWxpemVkXHJcblx0XHRcInBsYXllci1yZWluaXRpYWxpemVcIiAocGxheWVyKSB7XHJcblx0XHRcdHBsYXllci5iYWxhbmNlU2hlZXQgPSB7IGFzc2V0czogW10sIGxpYWJpbGl0aWVzOiBbXSB9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gUGx1Z2luO1xyXG59XHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFsYW5jZVNoZWV0O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIFBsdWdpbiB0byBhZGQgJ3Byb3BlcnR5JyAoYXMgaW4gcGVyc29uYWwgcHJvcGVydHkpIHByb3BlcnR5IHRvIFBsYXllcnMgd2hlbiB0aGV5IGFyZSBpbml0aWFsaXplZC4gTWVhbnQgdG8gYmUgdXNlZCBmb3JcclxuLy8gc2ltdWxhdGlvbnMgaW52b2x2aW5nIHBlcnNvbmFsIHBvc2Vzc2lvbnMsIGZvciBpbnN0YW5jZSBlY29ub21pYyBzaW11bGF0aW9ucy5cclxuXHJcbi8vIE5hc2hKUyBlbmdpbmUgY29tcG9uZW50c1xyXG52YXIgRW5naW5lID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIilcclxuXHJcbi8vIEdhbWUgc3RhdGVcclxudmFyIHsgcmVnaXN0cnksIGdhbWVQb3B1bGF0aW9uIH0gPSBFbmdpbmUuQmFja2VuZC5TdGF0ZTtcclxuXHJcbi8vIExldCdzIGFkZCBzb21lIFBsYXllckxpc3QgZnVuY3Rpb25hbGl0eVxyXG52YXIgeyBQbGF5ZXJMaXN0IH0gPSBFbmdpbmUuQmFja2VuZC5DbGFzc2VzO1xyXG5cclxuXHJcbnZhciBCYWxhbmNlU2hlZXQgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dmFyIGFkZEVudHJpZXMgPSBmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdC8vX3BsYXllciBwcm9wZXJ0aWVzL21ldGhvZHNcclxuXHRcdHBsYXllci5iYWxhbmNlU2hlZXQgPSB7IGFzc2V0czoge30sIGxpYWJpbGl0aWVzOiB7fSB9XHJcblxyXG5cdFx0cGxheWVyLm5ldFdvcnRoID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0XHR2YXIgYXNzZXRzID0gT2JqZWN0LmVudHJpZXModGhpcy5iYWxhbmNlU2hlZXQuYXNzZXRzKS5yZWR1Y2UoZnVuY3Rpb24oYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSkge1xyXG5cdFx0XHRcdHJldHVybiBhY2N1bXVsYXRvciArIGN1cnJlbnRWYWx1ZVsxXVxyXG5cdFx0XHR9LCAwKTtcclxuXHJcblx0XHRcdHZhciBsaWFiaWxpdGllcyA9IE9iamVjdC5lbnRyaWVzKHRoaXMuYmFsYW5jZVNoZWV0LmxpYWJpbGl0aWVzKS5yZWR1Y2UoZnVuY3Rpb24oYWNjdW11bGF0b3IsXHJcblx0XHRcdFx0Y3VycmVudFZhbHVlKSB7XHJcblx0XHRcdFx0cmV0dXJuIGFjY3VtdWxhdG9yICsgY3VycmVudFZhbHVlWzFdXHJcblx0XHRcdH0sIDApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGFzc2V0cyAtIGxpYWJpbGl0aWVzO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFVzZXIgaW50ZXJmYWNlXHJcblx0XHRwbGF5ZXIuaW50ZXJmYWNlLmJhbGFuY2VTaGVldCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZWdpc3RyeS5wbGF5ZXJzW3BsYXllci5pZF0uYmFsYW5jZVNoZWV0KSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cGxheWVyLmludGVyZmFjZS5uZXRXb3J0aCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gcmVnaXN0cnkucGxheWVyc1twbGF5ZXIuaWRdLm5ldFdvcnRoKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVE9ETyB2YWxpZGF0ZSBvYmplY3QuIFNob3VsZCBiZSBvZiBmb3JtIHthcHBsZXM6MiwgZG9nczoxfVxyXG5cdFx0cGxheWVyLmludGVyZmFjZS5lbmRvd0Fzc2V0cyA9IGZ1bmN0aW9uKGFzc2V0T2JqZWN0KSB7XHJcblxyXG5cdFx0XHRPYmplY3QuYXNzaWduKHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyLmlkXS5iYWxhbmNlU2hlZXQuYXNzZXRzLCBhc3NldE9iamVjdClcclxuXHRcdH1cclxuXHJcblx0XHRwbGF5ZXIuaW50ZXJmYWNlLmxlbmQgPSBmdW5jdGlvbihsb2FuT2JqZWN0KSB7XHJcblx0XHRcdC8vVE9ETyB2YWxpZGF0ZSBvYmplY3QuIFNob3VsZCBiZSBvZiBmb3JtIHtwbGF5ZXIxOnttb3J0Z2FnZToxMH19XHJcblx0XHRcdHZhciBsZW5kZXIgPSByZWdpc3RyeS5wbGF5ZXJzW3BsYXllci5pZF0uYmFsYW5jZVNoZWV0LmFzc2V0c1xyXG5cdFx0XHRPYmplY3QuZW50cmllcyhsb2FuT2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uKGxvYW5Ubykge1xyXG5cdFx0XHRcdHZhciBkZWJ0cztcclxuXHRcdFx0XHRsZW5kZXJbbG9hblRvWzBdXSA/XHJcblx0XHRcdFx0XHRkZWJ0cyA9IGxlbmRlcltsb2FuVG9bMF1dIDogZGVidHMgPSBsZW5kZXJbbG9hblRvWzBdXSA9IHt9O1xyXG5cclxuXHRcdFx0XHRPYmplY3QuZW50cmllcyhsb2FuVG9bMV0pLmZvckVhY2goZnVuY3Rpb24obmV3TG9hbikge1xyXG5cdFx0XHRcdFx0ZGVidHNbbmV3TG9hblswXV0gPyBkZWJ0c1tuZXdMb2FuWzBdXSArPSBuZXdMb2FuWzFdIDogZGVidHNbbmV3TG9hblswXV0gPSBuZXdMb2FuWzFdXHJcblx0XHRcdFx0XHRyZWdpc3RyeS5wbGF5ZXJzW2xvYW5Ub1swXV0uYmFsYW5jZVNoZWV0LmxpYWJpbGl0aWVzW25ld0xvYW5bMF1dID8gcmVnaXN0cnkucGxheWVyc1tsb2FuVG9bMF1dLmJhbGFuY2VTaGVldFxyXG5cdFx0XHRcdFx0XHQubGlhYmlsaXRpZXNbbmV3TG9hblswXV0gKz0gbmV3TG9hblsxXSA6IHJlZ2lzdHJ5LnBsYXllcnNbbG9hblRvWzBdXS5iYWxhbmNlU2hlZXQubGlhYmlsaXRpZXNbXHJcblx0XHRcdFx0XHRcdFx0bmV3TG9hblswXV0gPSBuZXdMb2FuWzFdO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHJcblx0Ly8gVGhlIHBsdWdpbiBvYmplY3QuXHJcblx0dmFyIFBsdWdpbiA9IHtcclxuXHRcdG5hbWU6IFwiYmFsYW5jZS1zaGVldFwiLFxyXG5cclxuXHRcdC8vIE9wdGlvbiB0byBpbml0aWFsaXplIGJ5IGNyZWF0aW5nICdwcm9wZXJ0eScgZm9yIGEgZ3JvdXAgb2YgcGxheWVycy5cclxuXHRcdGluaXQocGxheWVycyA9IFtdKSB7XHJcblx0XHRcdC8vIEFkZCBzb21lIHBsYXllcmxpc3QgZnVuY3Rpb25hbGl0eVxyXG5cdFx0XHRQbGF5ZXJMaXN0LnByb3RvdHlwZS5iYWxhbmNlU2hlZXRzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdFx0aWYgKHBsYXllci5iYWxhbmNlU2hlZXQpIHJldHVybiBwbGF5ZXIuaW50ZXJmYWNlLmJhbGFuY2VTaGVldCgpO1xyXG5cdFx0XHRcdFx0ZWxzZSByZXR1cm4gbnVsbDtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0UGxheWVyTGlzdC5wcm90b3R5cGUuYXNzZXRzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdFx0aWYgKHBsYXllci5iYWxhbmNlU2hlZXQpIHJldHVybiBwbGF5ZXIuaW50ZXJmYWNlLmJhbGFuY2VTaGVldCgpLmFzc2V0cztcclxuXHRcdFx0XHRcdGVsc2UgcmV0dXJuIG51bGw7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdFBsYXllckxpc3QucHJvdG90eXBlLmxpYWJpbGl0aWVzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdFx0aWYgKHBsYXllci5iYWxhbmNlU2hlZXQpIHJldHVybiBwbGF5ZXIuaW50ZXJmYWNlLmJhbGFuY2VTaGVldCgpLmxpYWJpbGl0aWVzO1xyXG5cdFx0XHRcdFx0ZWxzZSByZXR1cm4gbnVsbDtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0UGxheWVyTGlzdC5wcm90b3R5cGUubmV0V29ydGggPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0XHRpZiAocGxheWVyLmJhbGFuY2VTaGVldCkgcmV0dXJuIHBsYXllci5uZXRXb3J0aCgpO1xyXG5cdFx0XHRcdFx0ZWxzZSByZXR1cm4gbnVsbDtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0UGxheWVyTGlzdC5wcm90b3R5cGUuemVyb0JhbGFuY2VTaGVldHMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR0aGlzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0XHRhZGRFbnRyaWVzKHBsYXllcilcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQWRkIGJzIGZvciBzcGVjaWZpZWQgcGxheWVyc1xyXG5cdFx0XHRwbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0YWRkRW50cmllcyhyZWdpc3RyeS5wbGF5ZXJzW3BsYXllci5pZCgpXSk7XHJcblx0XHRcdH0pXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIElmIHdlJ3ZlIGluaXQtZWQgYWxyZWR5LCBqdXN0IGFkZCBicydzIHRvIHRoZSBjdXJyZW50IHBsYXllciBsaXN0IGlmIHRoZXkgZG9uJ3QgaGF2ZSBhbHJlYWR5XHJcblx0XHRyZXF1aXJlKHBsYXllcnMgPSBbXSkge1xyXG5cdFx0XHRwbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0aWYgKCFwbGF5ZXIuYmFsYW5jZVNoZWV0KSBhZGRFbnRyaWVzKHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyLmlkKCldKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdHN0b3AoKSB7XHJcblx0XHRcdC8vIHJlbW92ZSBwcm90b3R5cGUgYWRkRW50cmllc1xyXG5cdFx0XHRkZWxldGUgUGxheWVyTGlzdC5wcm90b3R5cGUuYmFsYW5jZVNoZWV0cztcclxuXHRcdFx0ZGVsZXRlIFBsYXllckxpc3QucHJvdG90eXBlLmFzc2V0cztcclxuXHRcdFx0ZGVsZXRlIFBsYXllckxpc3QucHJvdG90eXBlLmxpYWJpbGl0aWVzO1xyXG5cdFx0XHRkZWxldGUgUGxheWVyTGlzdC5wcm90b3R5cGUubmV0V29ydGg7XHJcblxyXG5cdFx0XHQvLyBkZWxldGUgYmFsYW5jZSBzaGVldCBwcm9wZXJ0aWVzIGZyb20gZXZlcnkgcGxheWVyIGFuZCBpbnRlcmZhY2UuXHJcblx0XHRcdGdhbWVQb3B1bGF0aW9uKCkuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLmJhbGFuY2VTaGVldDtcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLm5ldFdvcnRoO1xyXG5cdFx0XHRcdGRlbGV0ZSBwbGF5ZXIuaW50ZXJmYWNlLmJhbGFuY2VTaGVldDtcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLmludGVyZmFjZS5uZXRXb3J0aDtcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLmludGVyZmFjZS5lbmRvd0Fzc2V0cztcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLmludGVyZmFjZS5sZW5kO1xyXG5cdFx0XHR9KVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBjcmVhdGUgcHJvcGVydHkgYW5kIGludGVyZmFjZSBmdW5jdGlvbiB3aGVuIHBsYXllciBpcyBjcmVhdGVkXHJcblx0XHQncGxheWVyLWNyZWF0ZSc6IGFkZEVudHJpZXMsXHJcblxyXG5cdFx0Ly8gQmxhbmsgcHJvcGVydHkgd2hlbiBwbGF5ZXIgaXMgcmUtaW5pdGlhbGl6ZWRcclxuXHRcdFwicGxheWVyLXJlaW5pdGlhbGl6ZVwiIChwbGF5ZXIpIHtcclxuXHRcdFx0cGxheWVyLmJhbGFuY2VTaGVldCA9IHsgYXNzZXRzOiBbXSwgbGlhYmlsaXRpZXM6IFtdIH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBQbHVnaW47XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhbGFuY2VTaGVldDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBnYW1lIHBpZWNlc1xyXG52YXIgcHJpc29uZXJEaWxlbW1hID0gcmVxdWlyZShcIi4vaXRlcmF0ZWQtcHJpc29uZXItZGlsZW1tYVwiKS5jcmVhdGVHZW5lcmF0b3I7XHJcbnZhciByb3VuZFJvYmluID0gcmVxdWlyZShcIi4vcm91bmQtcm9iaW5cIik7XHJcblxyXG4vLyBOYXNoSlMgZW5naW5lIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG52YXIgeyBMb29wIH0gPSBFbmdpbmUuRnJvbnRlbmQuUGxheWFibGVzO1xyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lV3JhcHBlciB9ID0gRW5naW5lLkJhY2tlbmQuSGVscGVyRnVuY3Rpb25zKFwic3RvY2stZ2FtZXNcIilcclxudmFyIHsgZ2VuZXJhdGVQb3B1bGF0aW9uIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJ0b3VybmFtZW50XCIpO1xyXG5cclxuLy8gUG9wdWxhdGlvbiBpbnRlcmZhY2VzXHJcbnZhciB7IFBvcHVsYXRpb24gfSA9IEVuZ2luZS5Gcm9udGVuZC5Qb3B1bGF0aW9uO1xyXG5cclxuXHJcbnZhciBBeGVscm9kVG91cm5hbWVudCA9IGdhbWVXcmFwcGVyKGZ1bmN0aW9uKHBsYXllcnMsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHZhciB7IGdlbmVyYXRlUGxheWVycyA9IHRydWUsIHJlcGVhdHMgPSA1LCBnYW1lTGVuZ3RoID0gMjAwIH0gPSBwYXJhbWV0ZXJzO1xyXG5cclxuXHQvLyBFaXRoZXIgY3JlYXRlIGFuIGVudGlyZSBwb3B1bGF0aW9uXHJcblx0aWYgKGdlbmVyYXRlUGxheWVycykge1xyXG5cdFx0Ly8gR2V0IHR3byBzZXRzIG9mIHBsYXllcnMuIFRoZSBzZWNvbmQgaXMgc28gcGxheWVycyBjYW4gcGxheSB0aGVtc2VsdmVzXHJcblx0XHRwbGF5ZXJzID0gZ2VuZXJhdGVQb3B1bGF0aW9uKCk7XHJcblx0XHR2YXIgY29waWVzID0gZ2VuZXJhdGVQb3B1bGF0aW9uKCk7XHJcblx0XHRwYXJhbWV0ZXJzLmNvcGllcyA9IGNvcGllcztcclxuXHR9XHJcblxyXG5cdC8vIG9yIHVzZSB0aGUgc3VwcGxpZWQgcGxheWVyc1xyXG5cdGVsc2UgaWYgKHBsYXllcnMpIHtcclxuXHRcdC8vIGRvIG5vdGhpbmdcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gb3IgdXNlIHRoZSBwbGF5ZXJzIGFscmVhZHkgcHJlc2VudFxyXG5cdFx0cGxheWVycyA9IFBvcHVsYXRpb24oKS5vbmx5QWxpdmUoKS5vbmx5QXZhaWxhYmxlKCk7XHJcblx0fVxyXG5cclxuXHQvLyBhc3NpZ24gcGFyYW1ldGVycyBhbmQgZ2VuZXJhdGUgdGhlIGdhbWVcclxuXHRwYXJhbWV0ZXJzLmluaXRpYWxpemVQbGF5ZXJzID0gcGxheWVycztcclxuXHR2YXIgaXRlcmF0aW9uID0gcm91bmRSb2JpbihwbGF5ZXJzLCBwcmlzb25lckRpbGVtbWEoZ2FtZUxlbmd0aCksIHBhcmFtZXRlcnMpO1xyXG5cclxuXHRyZXR1cm4gTG9vcChpdGVyYXRpb24sIHJlcGVhdHMsIHsgaWQ6IFwiQXhlbHJvZC1Ub3VybmFtZW50XCIgfSk7XHJcbn0pO1xyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEF4ZWxyb2RUb3VybmFtZW50O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vYmFzZSBnYW1lXHJcbnZhciBUd29QbGF5ZXJOb3JtYWwgPSByZXF1aXJlKFwiLi9zaW1wbGUtbm9ybWFsXCIpO1xyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lV3JhcHBlciB9ID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIikuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKVxyXG5cclxuXHJcbi8vIEJhdHRsZSBvZiB0aGUgU2V4ZXNcclxudmFyIEJhdHRsZU9mVGhlU2V4ZXMgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRwYXJhbWV0ZXJzLmlkID0gcGFyYW1ldGVycy5pZCB8fCBcIkJhdHRsZS1vZi10aGUtU2V4ZXNcIjtcclxuXHJcblx0dmFyIGNob2ljZXMgPSBbXHJcblx0XHRbXCJPcGVyYVwiLCBcIkZvb3RiYWxsXCJdLFxyXG5cdFx0W1wiT3BlcmFcIiwgXCJGb290YmFsbFwiXVxyXG5cdF07XHJcblx0dmFyIHBheW9mZnMgPSBbXHJcblx0XHRbXHJcblx0XHRcdFsyLCAxXSxcclxuXHRcdFx0WzAsIDBdXHJcblx0XHRdLFxyXG5cdFx0W1xyXG5cdFx0XHRbMCwgMF0sXHJcblx0XHRcdFsxLCAyXVxyXG5cdFx0XVxyXG5cdF07XHJcblxyXG5cdHJldHVybiBUd29QbGF5ZXJOb3JtYWwocGxheWVycywgY2hvaWNlcywgcGF5b2ZmcywgcGFyYW1ldGVycyk7XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYXR0bGVPZlRoZVNleGVzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIE5hc2hKUyBlbmdpbmUgY29tcG9uZW50c1xyXG52YXIgRW5naW5lID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIilcclxuXHJcbi8vIFVzZXIgZGF0YVxyXG52YXIgeyBQb3B1bGF0aW9uIH0gPSBFbmdpbmUuRnJvbnRlbmRcclxuXHJcbi8vIFBsYXlhYmxlc1xyXG52YXIgeyBMYW1iZGEsIFNpbXVsdGFuZW91cywgU2VxdWVuY2UsIExvb3AgfSA9IEVuZ2luZS5Gcm9udGVuZC5QbGF5YWJsZXM7XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlzRnVuY3Rpb24gfSA9IEVuZ2luZS5CYWNrZW5kLkhlbHBlckZ1bmN0aW9ucyhcImdlbmVyYWxcIik7XHJcblxyXG5cclxuLy9DdWx0dXJhbCBldm9sdXRpb25cclxuLy9cclxuLy8gVE9ETzogYWRkIGluc3RydWN0aW9ucyBoZXJlXHJcbmZ1bmN0aW9uIEN1bHR1cmFsRXZvbHV0aW9uKGdhbWVHZW5lcmF0b3IsIG51bUxvb3BzID0gMSwge1xyXG5cdGlkID0gXCJDdWx0dXJhbEV2b2x1dGlvblwiLFxyXG5cdGdhbWVQcm9iYWJpbGl0eSA9IC4yNSxcclxuXHRwYWlyUHJvYmFiaWxpdHkgPSAuMjUsXHJcblx0Z2VuZXJhdGVQb3B1bGF0aW9uID0gbnVsbCxcclxuXHRsb29wID0gdHJ1ZVxyXG59ID0ge30pIHtcclxuXHJcblx0aWYgKGxvb3AgJiYgaXNOYU4obnVtTG9vcHMpKSB0aHJvdyBuZXcgRXJyb3IoXCJDdWx0dXJhbEV2b2x1dGlvbiBhcmd1bWVudCAnbnVtTG9vcHMgbXVzdCBiZSBhIG51bWJlclwiKTtcclxuXHRpZiAoIWlzRnVuY3Rpb24oZ2FtZUdlbmVyYXRvcikpIHRocm93IG5ldyBFcnJvcihcclxuXHRcdFwiQ3VsdHVyYWxFdm9sdXRpb24gYXJndW1lbnQgJ2dhbWVHZW5lcmF0b3InIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcclxuXHRpZiAoaXNOYU4oZ2FtZVByb2JhYmlsaXR5KSB8fCBnYW1lUHJvYmFiaWxpdHkgPCAwIHx8IGdhbWVQcm9iYWJpbGl0eSA+IDEpIHRocm93IG5ldyBFcnJvcihcclxuXHRcdFwiQ3VsdHVyYWxFdm9sdXRpb24gYXJndW1lbnQgJ2dhbWVQcm9iYWJpbGl0eScgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDFcIik7XHJcblx0aWYgKGlzTmFOKHBhaXJQcm9iYWJpbGl0eSkgfHwgcGFpclByb2JhYmlsaXR5IDwgMCB8fCBwYWlyUHJvYmFiaWxpdHkgPiAxKSB0aHJvdyBuZXcgRXJyb3IoXHJcblx0XHRcIkN1bHR1cmFsRXZvbHV0aW9uIGFyZ3VtZW50ICdwYWlyUHJvYmFiaWxpdHknIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxXCIpO1xyXG5cclxuXHQvLyBHZW5lcmF0ZSBwb3B1bGF0aW9uIGlmIHVzZXIgd2FudHMgdXMgdG8uXHJcblx0aWYgKGlzRnVuY3Rpb24oZ2VuZXJhdGVQb3B1bGF0aW9uKSkgZ2VuZXJhdGVQb3B1bGF0aW9uKCk7XHJcblxyXG5cdC8vUmVzZXQgdGhlIHNjb3JlcyBlYWNoIHJvdW5kLlxyXG5cdHZhciBSZXNldFNjb3JlcyA9IExhbWJkYShmdW5jdGlvbigpIHtcclxuXHRcdFBvcHVsYXRpb24oKS5vbmx5QWxpdmUoKS5yZXNldFNjb3JlcygpO1xyXG5cdH0pO1xyXG5cclxuXHQvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIG1hdGNoZXNcclxuXHR2YXIgbiA9IE1hdGguZmxvb3IoUG9wdWxhdGlvbigpLm9ubHlBbGl2ZSgpLmxlbmd0aCAqIGdhbWVQcm9iYWJpbGl0eSk7XHJcblxyXG5cdC8vIENyZWF0ZSBtYXRjaGVzLlxyXG5cdHZhciBtYXRjaGVzID0gWy4uLkFycmF5KG4pXVxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRtYXRjaGVzW2ldID0gZ2FtZUdlbmVyYXRvcigpO1xyXG5cdFx0aWYgKCFtYXRjaGVzW2ldLnBsYXkpIHRocm93IG5ldyBFcnJvcihcIkN1bHR1cmFsRXZvbHV0aW9uIGFyZ3VtZW50ICdnYW1lR2VuZXJhdG9yJyBtdXN0IHJldHVybiBhIFBsYXlhYmxlXCIpO1xyXG5cdH1cclxuXHJcblx0Ly9SdW4gYWxsIG1hdGNoZXMgc2ltdWx0YW5lb3VzbHlcclxuXHR2YXIgUm91bmQgPSBTaW11bHRhbmVvdXMobWF0Y2hlcyk7XHJcblxyXG5cdC8vQ2FsY3VsYXRlIG51bWJlciBvZiBwYWlyaW5nc1xyXG5cdHZhciBuID0gTWF0aC5mbG9vcihQb3B1bGF0aW9uKCkub25seUFsaXZlKCkubGVuZ3RoICogcGFpclByb2JhYmlsaXR5KVxyXG5cclxuXHQvL0NyZWF0ZSBwYWlyaW5nc1xyXG5cdHZhciBwYWlyaW5ncyA9IFsuLi5BcnJheShuKV07XHJcblx0Zm9yIChpID0gMDsgaSA8IG47IGkrKykge1xyXG5cclxuXHRcdHBhaXJpbmdzW2ldID0gTGFtYmRhKGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0Ly9GaW5kIHNvbWUgYXZhaWxhYmxlIHBsYXllcnNcclxuXHRcdFx0dmFyIHBvb2wgPSBQb3B1bGF0aW9uKCkub25seUFsaXZlKCkub25seUF2YWlsYWJsZSgpO1xyXG5cdFx0XHR2YXIgcDEgPSBwb29sW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvb2wubGVuZ3RoKV07XHJcblx0XHRcdHZhciBwMiA9IHBvb2xbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9vbC5sZW5ndGgpXTtcclxuXHJcblx0XHRcdC8vTWFyayB0aGVtIGJ1c3lcclxuXHRcdFx0cDEuYnVzeSgpO1xyXG5cdFx0XHRwMi5idXN5KCk7XHJcblxyXG5cdFx0XHQvLyBBc3NpZ24gc3RyYXRlZ3kgb2YgcGxheWVyIHdpdGggaGlnaGVyIHNjb3JlXHJcblx0XHRcdGlmIChwMS5zY29yZSgpID4gcDIuc2NvcmUoKSkgcDIuYXNzaWduKHAxLnN0cmF0ZWd5KCkpO1xyXG5cdFx0XHRlbHNlIGlmIChwMS5zY29yZSgpID09IHAyLnNjb3JlKCkpIG51bGw7XHJcblx0XHRcdGVsc2UgcDEuYXNzaWduKHAyLnN0cmF0ZWd5KCkpO1xyXG5cclxuXHRcdFx0Ly9SZXR1cm4gdmFsdWUgb2YgcGxheWVyIGlkcywgc28gdGhlIGxvZyBtYWtlcyBzb21lIHNlbnNlLlxyXG5cdFx0XHRyZXR1cm4gW3AxLmlkKCksIHAyLmlkKCldO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvLyBSdW4gcGFpcmluZ3Mgc2ltdWx0YW5lb3VzbHlcclxuXHR2YXIgUGFpcmluZyA9IFNpbXVsdGFuZW91cyhwYWlyaW5ncyk7XHJcblxyXG5cdC8vIEFmdGVyIHBhaXJpbmdzLCBtYXJrIGFsbCBwbGF5ZXJzIGFzIGF2YWlsYWJsZS5cclxuXHR2YXIgUmVsZWFzZVBsYXllcnMgPSBMYW1iZGEoZnVuY3Rpb24oKSB7XHJcblx0XHRQb3B1bGF0aW9uKCkub25seUFsaXZlKCkucmVsZWFzZSgpO1xyXG5cdH0pO1xyXG5cclxuXHQvLyBEZWZpbmUgdGhlIGdhbWUuXHJcblx0Um91bmQoUmVzZXRTY29yZXMpO1xyXG5cdFBhaXJpbmcoUm91bmQpO1xyXG5cdFJlbGVhc2VQbGF5ZXJzKFBhaXJpbmcpO1xyXG5cdHZhciBJdGVyYXRpb24gPSBTZXF1ZW5jZShSZXNldFNjb3JlcywgUmVsZWFzZVBsYXllcnMpO1xyXG5cclxuXHQvLyBVc2VyIGNhbiBzZXQgbG9vcCBwYXJhbWV0ZXIgdG8gZmFsc2UsIHRvIGF2b2lkIHdyYXBwaW5nIHRoaXMgaW4gYSBsb29wLlxyXG5cdGlmIChsb29wKVxyXG5cdFx0dmFyIENFID0gTG9vcChJdGVyYXRpb24sIG51bUxvb3BzLCB7IHBsYXlhYmxlUGFyYW1ldGVyczogeyBpbml0aWFsaXplUGxheWVyczogdHJ1ZSB9IH0pO1xyXG5cdGVsc2VcclxuXHRcdHZhciBDRSA9IEl0ZXJhdGlvbjtcclxuXHJcblx0cmV0dXJuIENFO1xyXG59XHJcblxyXG4vL1RPRE86IGZpeCBwYXJhbWV0ZXJzLiBVc2VyIHNob3VsZCBiZSBhYmxlIHRvIHN1cHBseSBwYXJhbWV0ZXJzIHdoaWNoIGVpdGhlclxyXG4vLyBlbmQgdXAgYXMgcGFyYW1ldGVycyBmb3IgdGhlIExvb3Agb3IgdGhlIFNlcXVlbmNlLlxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3VsdHVyYWxFdm9sdXRpb247XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gYmFzZSBnYW1lXHJcbnZhciBUd29QbGF5ZXJOb3JtYWwgPSByZXF1aXJlKFwiLi9zaW1wbGUtbm9ybWFsXCIpLlR3b1BsYXllck5vcm1hbDtcclxuXHJcbi8vIE5hc2hKUyBlbmdpbmUgY29tcG9uZW50c1xyXG52YXIgRW5naW5lID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIilcclxuXHJcbi8vIE5hc2ggZW5naW5lIGNvbXBvbmVudHNcclxudmFyIHsgU2VxdWVuY2UsIExhbWJkYSB9ID0gRW5naW5lLkZyb250ZW5kLlBsYXlhYmxlcztcclxuXHJcbi8vIEdhbWUgc3RhdGVcclxudmFyIHsgcmVnaXN0cnkgfSA9IEVuZ2luZS5CYWNrZW5kLlN0YXRlXHJcblxyXG4vLyBoZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKVxyXG5cclxuLy8gV2UnbGwgbmVlZCB0aGUgJ2JhbGFuY2Utc2hlZXQnIHBsdWdpblxyXG52YXIgUGx1Z2luTWFuYWdlciA9IEVuZ2luZS5CYWNrZW5kLlBsdWdpbk1hbmFnZXI7XHJcblxyXG5mdW5jdGlvbiBpbnZlcnRUZXJtcyh0ZXJtc09mVHJhZGUpIHtcclxuXHR2YXIgaW52ZXJzZSA9IHt9XHJcblx0T2JqZWN0LmVudHJpZXModGVybXNPZlRyYWRlKS5mb3JFYWNoKGZ1bmN0aW9uKHRlcm0pIHtcclxuXHRcdGlmICh0ZXJtWzBdID09IFwiYm9ycm93XCIpIHtcclxuXHRcdFx0aW52ZXJzZS5sZW5kID0gdGVybVsxXVxyXG5cdFx0fSBlbHNlIGlmICh0ZXJtWzBdID09IFwibGVuZFwiKSB7XHJcblx0XHRcdGludmVyc2UuYm9ycm93ID0gdGVybVsxXVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW52ZXJzZVt0ZXJtWzBdXSA9IHRlcm1bMV0gKiAtMVxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdHJldHVybiBpbnZlcnNlO1xyXG59XHJcblxyXG4vLyB0ZXJtc09mVHJhZGUgc2hvdWxkIGJlIGFuIG9iamVjdCByZWZsZWN0aW5nIHRoZSBvdXRjb21lcyBmb3IgcGxheWVyIDEuXHJcbi8vIEV4YW1wbGUge2FwcGxlOjIsIG9yYW5nZTotMn0uIFRvIGJvcnJvdyBvciBsZW5kLCBjcmVhdGUgYSBzdWItb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGxvYW4gdGVybXMuXHJcbi8vIGVnIHthcHBsZToyLCBib3Jyb3c6e0lPVTo1fX0sIG9yIHtjb3VjaDotMTAsIGxlbmQ6eydjcmVkaXQgY2FyZCc6NTB9fVxyXG52YXIgRXhjaGFuZ2UgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCB0ZXJtc09mVHJhZGUgPSB7fSwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIHsgdXRpbGl0eUZ1bmN0aW9ucywgdXRpbGl0eU1vZGUgPSBcImFic29sdXRlXCIsIGluaXRpYWxFbmRvd21lbnQgPSBbe30sIHt9XSB9ID0gcGFyYW1ldGVycyAvL3V0aWxpdHlGdW5jdGlvbnMgc2hvdWxkIGJlIGFuIGFycmF5IG9mIDIgZnVuY3Rpb25zLCB3aGljaCB0YWtlIGEgcmVzdWx0cyBvYmplY3QgYW5kIHJldHVybiBhIGNoYW5nZSBpbiB1dGlsaXR5XHJcblx0cGFyYW1ldGVycy5pZCA9IFwiRXhjaGFuZ2VcIiB8fCBwYXJhbWV0ZXJzLmlkO1xyXG5cclxuXHJcblxyXG5cclxuXHQvLyBUbyBwbGF5IHRoaXMgZ2FtZSwgcGxheWVycyB3aWxsIG5lZWQgYSBiYWxhbmNlIHNoZWV0LiBUaGlzIHBsdWdpbiB3aWxsIGFkZCBiYWxhbmNlIHNoZWV0cyB0byB0aGUgcGxheWVycyxcclxuXHQvLyBhcyB3ZWxsIGFzIGVuc3VyZSB0aGF0IG5ldyBwbGF5ZXJzIGFyZSBjcmVhdGVkIHdpdGggb25lLCBhbmQgdGhhdCB0aGV5IGFyZSByZS1pbml0aWFsaXplZCBwcm9wZXJseS5cclxuXHR2YXIgYmFsYW5jZVNoZWV0ID0gUGx1Z2luTWFuYWdlci5wYWNrYWdlKFwiYmFsYW5jZS1zaGVldC1jb21wbGV4XCIpLnJlcXVpcmUocGxheWVycyk7XHJcblx0YmFsYW5jZVNoZWV0LnNldHRpbmdzKHsgY2xlYW5aZXJvczogZmFsc2UgfSlcclxuXHJcblx0dmFyIHAxID0gcmVnaXN0cnkucGxheWVyc1twbGF5ZXJzWzBdLmlkKCldO1xyXG5cdHZhciBwMiA9IHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyc1sxXS5pZCgpXTtcclxuXHJcblx0Ly8gRG8gaW5pdGlhbCBlbmRvd21lbnRzIGlmIHRoZXJlIGFyZSBhbnkuIEZvcm1hdCBzYW1lIGFzIGZvciB0ZXJtcyBvZiB0cmFkZS5cclxuXHRpbml0aWFsRW5kb3dtZW50LmZvckVhY2goZnVuY3Rpb24oZW5kb3dtZW50LCBpbmRleCkge1xyXG5cdFx0dmFyIHBsYXllciA9IHBsYXllcnNbaW5kZXhdXHJcblx0XHR2YXIgaW52ZXJ0UGxheWVyID0gcGxheWVyc1tOdW1iZXIoIWluZGV4KV1cclxuXHRcdE9iamVjdC5lbnRyaWVzKGVuZG93bWVudCkuZm9yRWFjaChmdW5jdGlvbih0ZXJtKSB7XHJcblx0XHRcdGlmICh0ZXJtWzBdID09IFwiYm9ycm93XCIpIHtcclxuXHRcdFx0XHR2YXIgbG9hblRlcm1zID0gT2JqZWN0LmVudHJpZXModGVybVsxXSlbMF1cclxuXHRcdFx0XHRuZXcgYmFsYW5jZVNoZWV0LkZpbmFuY2lhbENsYWltKGludmVydFBsYXllciwgcGxheWVyLCBsb2FuVGVybXNbMV0sIGxvYW5UZXJtc1swXSlcclxuXHRcdFx0fSBlbHNlIGlmICh0ZXJtWzBdID09IFwibGVuZFwiKSB7XHJcblx0XHRcdFx0dmFyIGxvYW5UZXJtcyA9IE9iamVjdC5lbnRyaWVzKHRlcm1bMV0pWzBdXHJcblx0XHRcdFx0bmV3IGJhbGFuY2VTaGVldC5GaW5hbmNpYWxDbGFpbShwbGF5ZXIsIGludmVydFBsYXllciwgbG9hblRlcm1zWzFdLCBsb2FuVGVybXNbMF0pXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bmV3IGJhbGFuY2VTaGVldC5SZWFsQ2xhaW0ocGxheWVyLCB0ZXJtWzBdLCB0ZXJtWzFdKVxyXG5cdFx0XHR9XHJcblx0XHR9KVxyXG5cdH0pXHJcblxyXG5cdC8vIFRoZSBhY3R1YWwgcGxheWFibGVcclxuXHR2YXIgRGVjaXNpb24gPSBUd29QbGF5ZXJOb3JtYWwocGxheWVycywgW1xyXG5cdFx0W1wiQWNjZXB0XCIsIFwiUmVqZWN0XCJdLFxyXG5cdFx0W1wiQWNjZXB0XCIsIFwiUmVqZWN0XCJdXHJcblx0XSwgbnVsbCwge1xyXG5cdFx0aWQ6IFwiRGVjaXNpb25cIixcclxuXHRcdGluZm9ybWF0aW9uRmlsdGVyOiBmdW5jdGlvbihpbmZvKSB7IC8vVE9ETyBtaWdodCBuZWVkIHRvIHdyYXAgdXNlci1zdXBwbGllZCBpbmZvcm1hdGlvbkZpbHRlcj9cclxuXHRcdFx0aW5mby50ZXJtc09mVHJhZGUgPSB7XHJcblx0XHRcdFx0W3AxLmlkXTogdGVybXNPZlRyYWRlLFxyXG5cdFx0XHRcdFtwMi5pZF06IGludmVydFRlcm1zKHRlcm1zT2ZUcmFkZSlcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gaW5mbztcclxuXHRcdH1cclxuXHR9KVxyXG5cclxuXHQvLyBEaXN0cmlidXRlIHRoZSBnb29kc1xyXG5cdHZhciBEaXN0cmlidXRlID0gTGFtYmRhKGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciByZXN1bHRzID0gW107XHJcblxyXG5cdFx0T2JqZWN0LmVudHJpZXModGVybXNPZlRyYWRlKS5mb3JFYWNoKGZ1bmN0aW9uKHRlcm0pIHtcclxuXHRcdFx0aWYgKHRlcm1bMF0gPT0gXCJib3Jyb3dcIikge1xyXG5cdFx0XHRcdHZhciBsb2FuVGVybXMgPSBPYmplY3QuZW50cmllcyh0ZXJtWzFdKVswXVxyXG5cdFx0XHRcdHZhciBsb2FuID0gbmV3IGJhbGFuY2VTaGVldC5GaW5hbmNpYWxDbGFpbShwMi5pbnRlcmZhY2UsIHAxLmludGVyZmFjZSwgbG9hblRlcm1zWzFdLCBsb2FuVGVybXNbMF0pXHJcblxyXG5cdFx0XHRcdHJlc3VsdHMucHVzaCh7XHJcblx0XHRcdFx0XHRwbGF5ZXI6IHAxLmlkLFxyXG5cdFx0XHRcdFx0Ym9ycm93OiB7XHJcblx0XHRcdFx0XHRcdFtsb2FuVGVybXNbMF1dOiBsb2FuVGVybXNbMV1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0cmVzdWx0cy5wdXNoKHtcclxuXHRcdFx0XHRcdHBsYXllcjogcDIuaWQsXHJcblx0XHRcdFx0XHRsZW5kOiB7XHJcblx0XHRcdFx0XHRcdFtwMS5pZF06IHtcclxuXHRcdFx0XHRcdFx0XHRbbG9hblRlcm1zWzBdXTogbG9hblRlcm1zWzFdXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAodGVybVswXSA9PSBcImxlbmRcIikge1xyXG5cdFx0XHRcdHZhciBsb2FuVGVybXMgPSBPYmplY3QuZW50cmllcyh0ZXJtWzFdKVswXVxyXG5cdFx0XHRcdHZhciBsb2FuID0gbmV3IGJhbGFuY2VTaGVldC5GaW5hbmNpYWxDbGFpbShwMS5pbnRlcmZhY2UsIHAyLmludGVyZmFjZSwgbG9hblRlcm1zWzFdLCBsb2FuVGVybXNbMF0pXHJcblxyXG5cdFx0XHRcdHJlc3VsdHMucHVzaCh7XHJcblx0XHRcdFx0XHRwbGF5ZXI6IHAyLmlkLFxyXG5cdFx0XHRcdFx0Ym9ycm93OiB7XHJcblx0XHRcdFx0XHRcdFtsb2FuVGVybXNbMF1dOiBsb2FuVGVybXNbMV1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0cmVzdWx0cy5wdXNoKHtcclxuXHRcdFx0XHRcdHBsYXllcjogcDEuaWQsXHJcblx0XHRcdFx0XHRsZW5kOiB7XHJcblx0XHRcdFx0XHRcdFtwMi5pZF06IHtcclxuXHRcdFx0XHRcdFx0XHRbbG9hblRlcm1zWzBdXTogbG9hblRlcm1zWzFdXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGdvb2QgPSBuZXcgYmFsYW5jZVNoZWV0LlJlYWxDbGFpbShwMS5pbnRlcmZhY2UsIHRlcm1bMF0sIDApXHJcblx0XHRcdFx0Z29vZC50cmFuc2ZlcihwMi5pbnRlcmZhY2UsIHRlcm1bMV0gKiAtMSlcclxuXHJcblx0XHRcdFx0cmVzdWx0cy5wdXNoKHsgcGxheWVyOiBwMS5pZCwgW3Rlcm1bMF1dOiB0ZXJtWzFdIH0pO1xyXG5cdFx0XHRcdHJlc3VsdHMucHVzaCh7IHBsYXllcjogcDIuaWQsIFt0ZXJtWzBdXTogLTEgKiB0ZXJtWzFdIH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblxyXG5cdFx0aWYgKHV0aWxpdHlGdW5jdGlvbnMpIHtcclxuXHJcblx0XHRcdHAxLnNjb3JlID0gdXRpbGl0eU1vZGUudG9Mb3dlckNhc2UoKSA9PSBcInJlbGF0aXZlXCIgPyBwMS5zY29yZSArIHV0aWxpdHlGdW5jdGlvbnNbMF0ocmVzdWx0cykgOlxyXG5cdFx0XHRcdHV0aWxpdHlGdW5jdGlvbnNbMF0ocmVzdWx0cylcclxuXHRcdFx0cDIuc2NvcmUgPSB1dGlsaXR5TW9kZS50b0xvd2VyQ2FzZSgpID09IFwicmVsYXRpdmVcIiA/IHAyLnNjb3JlICsgdXRpbGl0eUZ1bmN0aW9uc1sxXShyZXN1bHRzKSA6XHJcblx0XHRcdFx0dXRpbGl0eUZ1bmN0aW9uc1sxXShyZXN1bHRzKVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHRzO1xyXG5cdH0sIHsgaWQ6IFwiRGlzdHJpYnV0aW9uXCIgfSk7XHJcblxyXG5cdC8vQnV0IG9ubHkgZG8gaXQgaWYgdGhlIHRyYWRlIGdvZXMgdGhyb3VnaC5cclxuXHREaXN0cmlidXRlKERlY2lzaW9uLkFjY2VwdC5BY2NlcHQoKSlcclxuXHJcblxyXG5cclxuXHRyZXR1cm4gU2VxdWVuY2UoRGVjaXNpb24sIERpc3RyaWJ1dGUsIHBhcmFtZXRlcnMpO1xyXG59LCB7XHJcblx0YXJndW1lbnRWYWxpZGF0b3IocGxheWVycywgdGVybXNPZlRyYWRlKSB7XHJcblx0XHQvLyBUT0RPOiB2YWxpZGF0ZSBwYXJhbWV0ZXJzXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXhjaGFuZ2U7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gQ29kZSBmb3Igc3RvY2sgZ2FtZSBxdWVyeSBzaG9ydGN1dHMuXHJcbnZhciB7IHJlZ2lzdHJ5LCBpZENvdW50ZXJzIH0gPSByZXF1aXJlKFwiLi4vbGliL2VuZ2luZVwiKS5CYWNrZW5kLlN0YXRlXHJcbnJlZ2lzdHJ5Ll9hZGRUeXBlXyhcInF1ZXJpZXNcIilcclxuaWRDb3VudGVycy5fYWRkVHlwZV8oXCJxdWVyeVwiKVxyXG5cclxuXHJcblxyXG52YXIgU3RvY2tHYW1lcyA9IHtcclxuXHQvL0dhbWUgc2tlbGV0b25zXHJcblx0XCJUd28tUGxheWVyIE5vcm1hbFwiOiByZXF1aXJlKFwiLi9zaW1wbGUtbm9ybWFsXCIpLlR3b1BsYXllck5vcm1hbCxcclxuXHRcIk5vcm1hbFwiOiByZXF1aXJlKFwiLi9zaW1wbGUtbm9ybWFsXCIpLk5vcm1hbCxcclxuXHRcIlNpbXBsZSBaZXJvLVN1bVwiOiByZXF1aXJlKFwiLi9zaW1wbGUtemVyby1zdW1cIiksXHJcblxyXG5cdC8vIENsYXNzaWMgZ2FtZXNcclxuXHRcIkJhdHRsZSBPZiBUaGUgU2V4ZXNcIjogcmVxdWlyZShcIi4vYmF0dGxlLW9mLXRoZS1zZXhlc1wiKSxcclxuXHRcIk1hdGNoaW5nIFBlbm5pZXNcIjogcmVxdWlyZShcIi4vbWF0Y2hpbmctcGVubmllc1wiKSxcclxuXHRcIlByaXNvbmVyJ3MgRGlsZW1tYVwiOiByZXF1aXJlKFwiLi9wcmlzb25lci1kaWxlbW1hXCIpLFxyXG5cdFwiUm9jay1QYXBlci1TY2lzc29yc1wiOiByZXF1aXJlKFwiLi9yb2NrLXBhcGVyLXNjaXNzb3JzXCIpLFxyXG5cclxuXHQvLyBJdGVyYXRlZCBnYW1lc1xyXG5cdFwiSXRlcmF0ZWRcIjogcmVxdWlyZShcIi4vaXRlcmF0ZWRcIiksXHJcblx0XCJJdGVyYXRlZCBQcmlzb25lcidzIERpbGVtbWFcIjogcmVxdWlyZShcIi4vaXRlcmF0ZWQtcHJpc29uZXItZGlsZW1tYVwiKSxcclxuXHJcblx0Ly8gRXZvbHV0aW9uYXJ5IGdhbWVzXHJcblx0XCJDdWx0dXJhbCBFdm9sdXRpb25cIjogcmVxdWlyZShcIi4vY3VsdHVyYWwtZXZvbHV0aW9uXCIpLFxyXG5cclxuXHQvL1RvdXJuYW1lbnRzXHJcblx0XCJSb3VuZCBSb2JpblwiOiByZXF1aXJlKFwiLi9yb3VuZC1yb2JpblwiKSxcclxuXHRcIkF4ZWxyb2QgVG91cm5hbWVudFwiOiByZXF1aXJlKFwiLi9heGVscm9kLXRvdXJuYW1lbnRcIiksXHJcblxyXG5cdC8vIFByb2JhYmlsaXR5IFRoZW9yeVxyXG5cdFwiTW9udHkgSGFsbFwiOiByZXF1aXJlKFwiLi9tb250eS1oYWxsXCIpLFxyXG5cclxuXHQvL05lb2NsYXNzaWNhbCBlY29ub21pY3NcclxuXHRcIkV4Y2hhbmdlXCI6IHJlcXVpcmUoXCIuL2V4Y2hhbmdlLWNvbXBsZXhcIiksXHJcblxyXG5cdHF1ZXJpZXMoKSB7XHJcblx0XHRyZXR1cm4gT2JqZWN0LmtleXMocmVnaXN0cnkucXVlcmllcykubWFwKGZ1bmN0aW9uKHF1ZXJ5KSB7IHJldHVybiB7XHJcblx0XHRcdFx0W3F1ZXJ5XTogcmVnaXN0cnkucXVlcmllc1txdWVyeV0uZGVzY3JpcHRpb24gfSB9KVxyXG5cdH1cclxufTtcclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdG9ja0dhbWVzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIEJhc2UgZ2FtZVxyXG52YXIgcHJpc29uZXJEaWxlbW1hID0gcmVxdWlyZShcIi4vcHJpc29uZXItZGlsZW1tYVwiKS5jcmVhdGVHZW5lcmF0b3IoKTtcclxuXHJcbi8vIE5hc2hKUyBlbmdpbmUgY29tcG9uZW50c1xyXG52YXIgRW5naW5lID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIilcclxuXHJcbi8vIGdhbWUgZW5naW5lXHJcbnZhciB7IExvb3AgfSA9IEVuZ2luZS5Gcm9udGVuZC5QbGF5YWJsZXM7XHJcblxyXG4vLyBoZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKVxyXG5cclxuLy8gR2FtZSB1dGlsaXR5XHJcbnZhciBJdGVyYXRlZCA9IHJlcXVpcmUoXCIuL2l0ZXJhdGVkXCIpXHJcblxyXG5cclxuXHJcbnZhciBJdGVyYXRlZFByaXNvbmVyRGlsZW1tYSA9IGdhbWVXcmFwcGVyKGZ1bmN0aW9uKHBsYXllcnMsIG51bWJlckl0ZXJhdGlvbnMgPSA1MCwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0cmV0dXJuIEl0ZXJhdGVkKHBsYXllcnMsIHByaXNvbmVyRGlsZW1tYSwgXCJQcmlzb25lci1EaWxlbW1hXCIsIG51bWJlckl0ZXJhdGlvbnMsIHBhcmFtZXRlcnMpXHJcbn0sIHtcclxuXHRxdWVyeUxvYWRlcigpIHtcclxuXHRcdHJldHVybiBbe1xyXG5cdFx0XHRcdG5hbWU6IFwiQElQRC1jaG9pY2VzXCIsXHJcblx0XHRcdFx0cXVlcnk6IFwiJG1hcCgkLlthY3Rpb25dLnJlc3VsdHMsIGZ1bmN0aW9uKCRsKXskbC5yZXN1bHR9KVwiLFxyXG5cdFx0XHRcdGRlc2NyaXB0aW9uOiBcIlJlc3VsdHMsIG9yZ2FuaXplZCBieSByb3VuZC5cIlxyXG5cdFx0XHR9LFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0bmFtZTogXCJASVBELXBsYXllcnNcIixcclxuXHRcdFx0XHRxdWVyeTogXCIkbWFwKCQuW2FjdGlvbl0ucmVzdWx0cywgZnVuY3Rpb24oJGwpeyRsLnBsYXllcn0pXCIsXHJcblx0XHRcdFx0ZGVzY3JpcHRpb246IFwiUGxheWVycywgb3JnYW5pemVkIGJ5IHJvdW5kLlwiXHJcblx0XHRcdH0sXHJcblx0XHRcdHtcclxuXHRcdFx0XHRuYW1lOiBcIkBJUEQtcGF5b3V0c1wiLFxyXG5cdFx0XHRcdHF1ZXJ5OiBcIiQuYWN0aW9uLnBheW91dHNcIixcclxuXHRcdFx0XHRkZXNjcmlwdGlvbjogXCJQYXlvdXRzLCBhcyBhcnJheSBvZiBvYmplY3RzLlwiXHJcblx0XHRcdH1cclxuXHRcdF1cclxuXHR9LFxyXG5cdHN0cmF0ZWd5TG9hZGVyKCkge1xyXG5cdFx0cmV0dXJuIFt7XHJcblx0XHRcdFx0bmFtZTogXCJUaXQgRm9yIFRhdFwiLFxyXG5cdFx0XHRcdGRlc2NyaXB0aW9uOiBcIkRvIHdoYXRldmVyIHlvdXIgb3Bwb25lbnQgZGlkIGxhc3QgdHVybi4gQ29vcGVyYXRlIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHR1cm4uXCIsXHJcblx0XHRcdFx0c3RyYXRlZ3k6IGZ1bmN0aW9uIHRpdEZvclRhdCgpIHtcclxuXHRcdFx0XHRcdHRoaXMuY2hvb3NlID0gZnVuY3Rpb24oY2hvaWNlcywgaW5mb3JtYXRpb24pIHtcclxuXHRcdFx0XHRcdFx0aWYgKGluZm9ybWF0aW9uLm9wcG9uZW50Lmhpc3RvcnkubGVuZ3RoKSByZXR1cm4gaW5mb3JtYXRpb24ub3Bwb25lbnQuaGlzdG9yeVtpbmZvcm1hdGlvbi5vcHBvbmVudFxyXG5cdFx0XHRcdFx0XHRcdFx0Lmhpc3RvcnkubGVuZ3RoIC0gMV1cclxuXHRcdFx0XHRcdFx0XHQucmVzdWx0XHJcblx0XHRcdFx0XHRcdGVsc2UgcmV0dXJuIFwiQ29vcGVyYXRlXCI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0bmFtZTogXCJHcnVkZ2VyXCIsXHJcblx0XHRcdFx0ZGVzY3JpcHRpb246IFwiQ29vcGVyYXRlIHVudGlsIHlvdXIgb3Bwb25lbnQgZG9lc24ndCwgdGhlbiBEZWZlY3QuXCIsXHJcblx0XHRcdFx0c3RyYXRlZ3k6IGZ1bmN0aW9uIGdydWRnZXIoKSB7XHJcblx0XHRcdFx0XHR0aGlzLmNvb3BlcmF0aW5nID0gdHJ1ZVxyXG5cclxuXHRcdFx0XHRcdHRoaXMuY2hvb3NlID0gZnVuY3Rpb24oY2hvaWNlcywgaW5mb3JtYXRpb24pIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIElmIG9wcG9uZW50IGp1c3QgZGVmZWN0ZWQsIHRoZW4gc3RvcCBjb29wZXJhdGluZ1xyXG5cdFx0XHRcdFx0XHRpZiAoaW5mb3JtYXRpb24ub3Bwb25lbnQuaGlzdG9yeS5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoaW5mb3JtYXRpb24ub3Bwb25lbnQuaGlzdG9yeVtpbmZvcm1hdGlvbi5vcHBvbmVudC5oaXN0b3J5Lmxlbmd0aCAtIDFdLnJlc3VsdCA9PSBcIkRlZmVjdFwiKSB0aGlzXHJcblx0XHRcdFx0XHRcdFx0XHQuY29vcGVyYXRpbmcgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuY29vcGVyYXRpbmcpIHJldHVybiBcIkNvb3BlcmF0ZVwiO1xyXG5cdFx0XHRcdFx0XHRlbHNlIHJldHVybiBcIkRlZmVjdFwiO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHtcclxuXHRcdFx0XHRuYW1lOiBcIk5haXZlIFByb2JlclwiLFxyXG5cdFx0XHRcdGRlc2NyaXB0aW9uOiBcIkxpa2UgVGl0IEZvciBUYXQsIGJ1dCBvY2Nhc2lvbmFsbHkgRGVmZWN0cyB3aXRoIHNtYWxsIHByb2JhYmlsaXR5XCIsXHJcblx0XHRcdFx0c3RyYXRlZ3k6IGZ1bmN0aW9uIHByb2Jlcihwcm9iYWJpbGl0eSA9IDAuMSkge1xyXG5cdFx0XHRcdFx0dGhpcy5jaG9vc2UgPSBmdW5jdGlvbihjaG9pY2VzLCBpbmZvcm1hdGlvbikge1xyXG5cdFx0XHRcdFx0XHRpZiAoTWF0aC5yYW5kb20oKSA8IHByb2JhYmlsaXR5KSByZXR1cm4gXCJEZWZlY3RcIjtcclxuXHJcblx0XHRcdFx0XHRcdGlmIChpbmZvcm1hdGlvbi5vcHBvbmVudC5oaXN0b3J5Lmxlbmd0aCkgcmV0dXJuIGluZm9ybWF0aW9uLm9wcG9uZW50Lmhpc3RvcnlbaW5mb3JtYXRpb24ub3Bwb25lbnRcclxuXHRcdFx0XHRcdFx0XHRcdC5oaXN0b3J5Lmxlbmd0aCAtIDFdXHJcblx0XHRcdFx0XHRcdFx0LnJlc3VsdFxyXG5cdFx0XHRcdFx0XHRlbHNlIHJldHVybiBcIkNvb3BlcmF0ZVwiO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHtcclxuXHRcdFx0XHRuYW1lOiBcIlRpdCBGb3IgVHdvIFRhdHNcIixcclxuXHRcdFx0XHRkZXNjcmlwdGlvbjogXCJDb29wZXJhdGVzIG9uIHRoZSBmaXJzdCBtb3ZlLCB0aGVuIERlZmVjdHMgb25seSB3aGVuIHRoZSBvcHBvbmVudCBEZWZlY3RzIHR3byB0aW1lc1wiLFxyXG5cdFx0XHRcdHN0cmF0ZWd5OiBmdW5jdGlvbiBURjJUKCkge1xyXG5cdFx0XHRcdFx0dGhpcy5jaG9vc2UgPSBmdW5jdGlvbihjaG9pY2VzLCBpbmZvcm1hdGlvbikge1xyXG5cdFx0XHRcdFx0XHRpZiAoaW5mb3JtYXRpb24ub3Bwb25lbnQuaGlzdG9yeS5sZW5ndGggPiAxKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGluZm9ybWF0aW9uLm9wcG9uZW50Lmhpc3RvcnlbaW5mb3JtYXRpb24ub3Bwb25lbnQuaGlzdG9yeS5sZW5ndGggLSAxXS5yZXN1bHQgPT0gXCJEZWZlY3RcIiAmJlxyXG5cdFx0XHRcdFx0XHRcdFx0aW5mb3JtYXRpb24ub3Bwb25lbnQuaGlzdG9yeVtpbmZvcm1hdGlvbi5vcHBvbmVudC5oaXN0b3J5Lmxlbmd0aCAtIDJdLnJlc3VsdCA9PSBcIkRlZmVjdFwiKSByZXR1cm4gXCJEZWZlY3RcIjtcclxuXHRcdFx0XHRcdFx0XHRlbHNlIHJldHVybiBcIkNvb3BlcmF0ZVwiO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgcmV0dXJuIFwiQ29vcGVyYXRlXCI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XVxyXG5cdH1cclxufSk7XHJcbi8vIFRPRE8gdmFsaWRhdGUgYXJndW1lbnRzXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEl0ZXJhdGVkUHJpc29uZXJEaWxlbW1hXHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gTmFzaEpTIGVuZ2luZSBjb21wb25lbnRzXHJcbnZhciBFbmdpbmUgPSByZXF1aXJlKFwiLi4vbGliL2VuZ2luZVwiKVxyXG5cclxuLy8gZ2FtZSBlbmdpbmVcclxudmFyIHsgTG9vcCB9ID0gRW5naW5lLkZyb250ZW5kLlBsYXlhYmxlcztcclxuXHJcbi8vIGhlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgZ2FtZVdyYXBwZXIgfSA9IEVuZ2luZS5CYWNrZW5kLkhlbHBlckZ1bmN0aW9ucyhcInN0b2NrLWdhbWVzXCIpXHJcblxyXG5cclxudmFyIEl0ZXJhdGVkID0gZ2FtZVdyYXBwZXIoZnVuY3Rpb24ocGxheWVycywgZ2FtZUdlbmVyYXRvciwgZ2FtZU5hbWUsIG51bWJlckl0ZXJhdGlvbnMgPSA1MCwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblxyXG5cdHZhciB7IHBhcmFtZXRlcnM6IGdhbWVQYXJhbWV0ZXJzID0ge30gfSA9IHBhcmFtZXRlcnNcclxuXHJcblx0Z2FtZVBhcmFtZXRlcnMuaWQgPSBnYW1lUGFyYW1ldGVycy5pZCB8fCBnYW1lTmFtZVxyXG5cdHBhcmFtZXRlcnMuaWQgPSBwYXJhbWV0ZXJzLmlkIHx8IFwiSXRlcmF0ZWQtXCIgKyBnYW1lTmFtZTtcclxuXHJcblx0cmV0dXJuIExvb3AoZ2FtZUdlbmVyYXRvcihwbGF5ZXJzLCBnYW1lUGFyYW1ldGVycyksIG51bWJlckl0ZXJhdGlvbnMsIHBhcmFtZXRlcnMpO1xyXG59KVxyXG5cclxuLy8gVE9ETyB2YWxpZGF0ZSBhcmd1bWVudHNcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSXRlcmF0ZWQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gYmFzZSBnYW1lXHJcbnZhciBTaW1wbGVaZXJvU3VtID0gcmVxdWlyZShcIi4vc2ltcGxlLXplcm8tc3VtXCIpO1xyXG5cclxuLy8gTmFzaEpTIGVuZ2luZSBjb21wb25lbnRzXHJcbnZhciBFbmdpbmUgPSByZXF1aXJlKFwiLi4vbGliL2VuZ2luZVwiKVxyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lV3JhcHBlciB9ID0gRW5naW5lLkJhY2tlbmQuSGVscGVyRnVuY3Rpb25zKFwic3RvY2stZ2FtZXNcIilcclxuXHJcbi8vIFBsYXktdGltZSBsb2dpY1xyXG52YXIgeyBFeHByZXNzaW9uIH0gPSBFbmdpbmUuRnJvbnRlbmRcclxuXHJcblxyXG52YXIgTWF0Y2hpbmdQZW5uaWVzID0gZ2FtZVdyYXBwZXIoZnVuY3Rpb24ocGxheWVycywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0cGFyYW1ldGVycy5pZCA9IHBhcmFtZXRlcnMuaWQgfHwgXCJNYXRjaGluZy1QZW5uaWVzXCI7XHJcblx0cGF5b2ZmID0gcGFyYW1ldGVycy5wYXlvZmYgfHwgMTtcclxuXHJcblx0dmFyIHdpbiA9IHBheW9mZjtcclxuXHR2YXIgbG9zZSA9IEV4cHJlc3Npb24oZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gLXBheW9mZjtcclxuXHR9KTtcclxuXHJcblx0dmFyIGNob2ljZXMgPSBbXHJcblx0XHRbXCJIZWFkc1wiLCBcIlRhaWxzXCJdLFxyXG5cdFx0W1wiSGVhZHNcIiwgXCJUYWlsc1wiXVxyXG5cdF07XHJcblxyXG5cdHZhciBwYXlvZmZzID0gW1xyXG5cdFx0W3dpbiwgbG9zZV0sXHJcblx0XHRbbG9zZSwgd2luXVxyXG5cdF07XHJcblxyXG5cdHJldHVybiBTaW1wbGVaZXJvU3VtKHBsYXllcnMsIGNob2ljZXMsIHBheW9mZnMsIHBhcmFtZXRlcnMpO1xyXG59KTtcclxuXHJcbi8vIE1hdGNoaW5nIFBlbm5pZXNcclxubW9kdWxlLmV4cG9ydHMgPSBNYXRjaGluZ1Blbm5pZXM7XHJcbiIsIlwidXNlIHN0cmljdFwiXHJcblxyXG4vLyBOYXNoSlMgZW5naW5lIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpO1xyXG5cclxuLy8gUGxheWFibGVzXHJcbnZhciB7IENob2ljZSwgTGFtYmRhIH0gPSBFbmdpbmUuRnJvbnRlbmQuUGxheWFibGVzO1xyXG5cclxuLy8gbG9naWNcclxudmFyIHsgVmFyaWFibGUsIENvbXBsZXhWYXJpYWJsZSB9ID0gRW5naW5lLkZyb250ZW5kXHJcblxyXG4vLyBoZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKTtcclxuXHJcblxyXG52YXIgTW9udHlIYWxsID0gZ2FtZVdyYXBwZXIoZnVuY3Rpb24ocGxheWVyLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRwYXJhbWV0ZXJzLmlkID0gcGFyYW1ldGVycy5pZCB8fCBcIk1vbnR5LUhhbGxcIlxyXG5cdHZhciBudW1Eb29ycyA9IHBhcmFtZXRlcnMubnVtRG9vcnMgfHwgMztcclxuXHR2YXIgbnVtUHJpemVzID0gcGFyYW1ldGVycy5udW1Qcml6ZXMgfHwgMTtcclxuXHR2YXIgbnVtUmV2ZWFscyA9IHBhcmFtZXRlcnMubnVtUmV2ZWFscyB8fCAxO1xyXG5cdHZhciBwcml6ZSA9IHBhcmFtZXRlcnMucHJpemUgfHwgNTtcclxuXHJcblx0Ly8gQWxsb3cgYXJyYXkgb3Igc2luZ2xlIHBsYXllclxyXG5cdGlmIChBcnJheS5pc0FycmF5KHBsYXllcikpIHBsYXllciA9IHBsYXllclswXVxyXG5cclxuXHQvL0dlbmVyYXRlIGxpc3Qgb2YgZG9vcnNcclxuXHR2YXIgZG9vcnMgPSBbXTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG51bURvb3JzOyBpKyspIHtcclxuXHRcdGRvb3JzLnB1c2goXCJEb29yIFwiICsgaS50b1N0cmluZygpKVxyXG5cdH1cclxuXHJcblx0dmFyIENob29zZSA9IENob2ljZShwbGF5ZXIsIGRvb3JzLCB7IGlkOiBcIkNob29zZVwiIH0pO1xyXG5cclxuXHJcblx0dmFyIHByaXplc1xyXG5cdHZhciBzY29yZXMgPSBBcnJheS5hcHBseShudWxsLCBBcnJheShkb29ycy5sZW5ndGgpKS5tYXAoZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gVmFyaWFibGUoMClcclxuXHR9KVxyXG5cclxuXHQvL05lZWQgdG8gc2V0IHRoaXMgaGVyZSBpbiBvcmRlciBmb3Igc2NvcmluZyB0byB3b3JrXHJcblx0dmFyIGRvb3JzMiA9IENvbXBsZXhWYXJpYWJsZShkb29ycy5zbGljZSgpKTtcclxuXHJcblx0dmFyIFJldmVhbCA9IExhbWJkYShmdW5jdGlvbih7IGhpc3RvcnkgfSkge1xyXG5cclxuXHRcdC8vIFJlLWluaXRpYWxpemUgcGF5b2Zmcy5cclxuXHRcdHByaXplcyA9IFtdXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNjb3Jlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRzY29yZXNbaV0uc2V0KDApXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gV2hhdCBkb29yIGRpZCB0aGUgcGxheWVyIG9wZW4/XHJcblx0XHR2YXIgcGxheWVyQ2hvaWNlID0gaGlzdG9yeS5sb2cucXVlcnkoXCIkW2Nob2ljZT0nXCIgKyBDaG9vc2UuaWQoKSArIFwiJ11bLTFdXCIpLnJlc3VsdCAvLyBUT0RPIGRvZXMgdGhpcyB3b3JrP1xyXG5cclxuXHRcdC8vIFNlbGVjdCB3aGljaCBkb29ycyBoYXZlIHByaXplc1xyXG5cdFx0dmFyIHJldmVhbEZyb20gPSBkb29ycy5zbGljZSgpOyAvLyBDb3B5IHRoZSBkb29ycyBsaXN0XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG51bVByaXplczsgaSsrKSB7XHJcblx0XHRcdHZhciBwcml6ZUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcmV2ZWFsRnJvbS5sZW5ndGgpIC8vIFNlbGVjdCBhIGRvb3IgZnJvbSB0aGUgZG9vcnMgY29weVxyXG5cdFx0XHRwcml6ZXMucHVzaChyZXZlYWxGcm9tW3ByaXplSW5kZXhdKSAvLyBBZGQgdGhlIHByaXplIHRvIHRoZSBsaXN0c1xyXG5cdFx0XHRzY29yZXNbcHJpemVJbmRleF0uc2V0KHByaXplKSAvLyBTZXQgcGF5b2ZmcyBhcHByb3ByaWF0ZWx5XHJcblx0XHRcdHJldmVhbEZyb20uc3BsaWNlKHByaXplSW5kZXgsIDEpIC8vIFJlbW92ZSB0aGUgcHJpemVkIGRvb3IgZnJvbSB0aGUgZG9vcnMgY29weSwgc28gdGhhdCB3ZSBkb24ndCBzZWxlY3QgaXQgbW9yZSB0aGFuIG9uY2VcclxuXHRcdH1cclxuXHJcblx0XHQvL1JlbW92ZSBwbGF5ZXIgY2hvaWNlIGZyb20gZG9vcnMgY29weVxyXG5cdFx0dmFyIHBsYXllckNob2ljZUluZGV4ID0gcmV2ZWFsRnJvbS5pbmRleE9mKHBsYXllckNob2ljZSlcclxuXHRcdGlmIChwbGF5ZXJDaG9pY2VJbmRleCA+IC0xKSByZXZlYWxGcm9tLnNwbGljZShwbGF5ZXJDaG9pY2VJbmRleCwgMSlcclxuXHJcblx0XHQvLyBDaG9vc2UgZG9vcnMgdG8gcmV2ZWFsXHJcblx0XHR2YXIgcmV2ZWFsID0gW107XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG51bVJldmVhbHM7IGkrKykge1xyXG5cdFx0XHRyZXZlYWwucHVzaChyZXZlYWxGcm9tW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSkgKiByZXZlYWxGcm9tLmxlbmd0aF0pXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ29weSBkb29ycyBsaXN0IHRvIHNlbmQgb253YXJkLCB0aGVuIHJlbW92ZSB0aGUgcmV2ZWFsZWQgZG9vcnMgZnJvbSBsaXN0XHJcblx0XHRkb29yczIuc2V0KGRvb3JzLnNsaWNlKCkpOyAvLyBOZWVkIHRvIHNldCB0aGlzIGhlcmUgc28gcmV2ZWFsaW5nIHRvIHdvcmtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcmV2ZWFsLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBpbmRleCA9IGRvb3JzMi5pbmRleE9mKHJldmVhbFtpXSlcclxuXHRcdFx0ZG9vcnMyKCkuc3BsaWNlKGluZGV4LCAxKVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXZlYWwubGVuZ3RoID09IDEgPyByZXZlYWxbMF0gOiByZXZlYWw7XHJcblx0fSwgeyBpZDogXCJSZXZlYWxcIiB9KVxyXG5cclxuXHR2YXIgU2Vjb25kQ2hvaWNlID0gQ2hvaWNlKHBsYXllciwgZG9vcnMyLCB7IGlkOiBcIlN0YXktb3ItU3dpdGNoXCIsIHVzZVBheW9mZnM6IHRydWUgfSk7XHJcblx0U2Vjb25kQ2hvaWNlLnNldEFsbFBheW9mZnMoc2NvcmVzKVxyXG5cclxuXHRSZXZlYWwoQ2hvb3NlKVxyXG5cdFNlY29uZENob2ljZShSZXZlYWwpXHJcblxyXG5cdHJldHVybiBTZXF1ZW5jZShDaG9vc2UsIFNlY29uZENob2ljZSwgcGFyYW1ldGVycyk7XHJcbn0sIHtcclxuXHJcblx0c3RyYXRlZ3lMb2FkZXIoKSB7XHJcblx0XHRyZXR1cm4gW3tcclxuXHRcdFx0XHRuYW1lOiBcIkFsd2F5cyBTd2l0Y2hcIixcclxuXHRcdFx0XHRkZXNjcmlwdGlvbjogXCJSYW5kb21seSBzZWxlY3QgYSBkb29yLiBUaGVuLCBhbHdheXMgc3dpdGNoIHRvIGEgZGlmZmVyZW50IG9uZS5cIixcclxuXHJcblx0XHRcdFx0c3RyYXRlZ3k6IGZ1bmN0aW9uIGFsd2F5c1N3aXRjaCgpIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLmRvb3IgPSBudWxsO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuY2hvb3NlID0gZnVuY3Rpb24ob3B0aW9ucywgaW5mb3JtYXRpb24pIHtcclxuXHRcdFx0XHRcdFx0dmFyIGNob2ljZVxyXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5kb29yKSB7XHJcblx0XHRcdFx0XHRcdFx0b3B0aW9ucy5zcGxpY2Uob3B0aW9ucy5pbmRleE9mKHRoaXMuZG9vciksIDEpXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5kb29yID0gbnVsbDtcclxuXHRcdFx0XHRcdFx0XHRjaG9pY2UgPSBvcHRpb25zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG9wdGlvbnMubGVuZ3RoKV1cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRjaG9pY2UgPSBvcHRpb25zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG9wdGlvbnMubGVuZ3RoKV1cclxuXHRcdFx0XHRcdFx0XHR0aGlzLmRvb3IgPSBjaG9pY2VcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIGNob2ljZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdG5hbWU6IFwiQWx3YXlzIFN0YXlcIixcclxuXHRcdFx0XHRkZXNjcmlwdGlvbjogXCJSYW5kb21seSBzZWxlY3QgYSBkb29yLiBUaGVuLCBhbHdheXMgc3RheSB3aXRoIHRoYXQgZG9vci5cIixcclxuXHJcblx0XHRcdFx0c3RyYXRlZ3k6IGZ1bmN0aW9uIGFsd2F5c1N0YXkoKSB7XHJcblx0XHRcdFx0XHR0aGlzLmRvb3IgPSBudWxsO1xyXG5cclxuXHRcdFx0XHRcdC8vVE9ETyBhZGQgc3RyYXRlZ3kgZGVzY3JpcHRpb24gZmVhdHVyZVxyXG5cdFx0XHRcdFx0dGhpcy5jaG9vc2UgPSBmdW5jdGlvbihvcHRpb25zLCBpbmZvcm1hdGlvbikge1xyXG5cdFx0XHRcdFx0XHR2YXIgY2hvaWNlXHJcblx0XHRcdFx0XHRcdGlmICh0aGlzLmRvb3IpIHtcclxuXHRcdFx0XHRcdFx0XHRjaG9pY2UgPSB0aGlzLmRvb3JcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmRvb3IgPSBudWxsO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRjaG9pY2UgPSBvcHRpb25zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG9wdGlvbnMubGVuZ3RoKV1cclxuXHRcdFx0XHRcdFx0XHR0aGlzLmRvb3IgPSBjaG9pY2VcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIGNob2ljZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XVxyXG5cdH1cclxufSlcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTW9udHlIYWxsXHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gYmFzZSBnYW1lXHJcbnZhciBUd29QbGF5ZXJOb3JtYWwgPSByZXF1aXJlKFwiLi9zaW1wbGUtbm9ybWFsXCIpLlR3b1BsYXllck5vcm1hbDtcclxuXHJcbi8vTmFzaEpTIGVuZ2luZSBjb21wb25lbnRzXHJcbnZhciBFbmdpbmUgPSByZXF1aXJlKFwiLi4vbGliL2VuZ2luZVwiKVxyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lV3JhcHBlciB9ID0gRW5naW5lLkJhY2tlbmQuSGVscGVyRnVuY3Rpb25zKFwic3RvY2stZ2FtZXNcIik7XHJcblxyXG4vLyBwbGF5LXRpbWUgbG9naWNcclxudmFyIHsgVmFyaWFibGUsIEV4cHJlc3Npb24gfSA9IEVuZ2luZS5Gcm9udGVuZDtcclxuXHJcblxyXG52YXIgcHJpc29uZXJEaWxlbW1hID0gZ2FtZVdyYXBwZXIoZnVuY3Rpb24ocGxheWVycywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0cGFyYW1ldGVycy5pZCA9IHBhcmFtZXRlcnMuaWQgfHwgXCJQcmlzb25lci1EaWxlbW1hXCI7XHJcblx0dmFyIHBheW9mZnMgPSBwYXJhbWV0ZXJzLnBheW9mZnMgfHwgW1ZhcmlhYmxlKDEpLCBWYXJpYWJsZSgyKSwgVmFyaWFibGUoMyksIFZhcmlhYmxlKDQpXTtcclxuXHJcblxyXG5cdC8vIHNvcnQgbnVtYmVycyBiZWNhdXNlIHRoZSB3cm9uZyBvcmRlciB3b3VsZCBzY3JldyB1cCB0aGUgZ2FtZVxyXG5cdHBheW9mZnMuc29ydCgpXHJcblx0dmFyIHN1Y2tlciA9IHBheW9mZnNbMF1cclxuXHR2YXIgcHVuaXNobWVudCA9IHBheW9mZnNbMV1cclxuXHR2YXIgcmV3YXJkID0gcGF5b2Zmc1syXVxyXG5cdHZhciB0ZW1wdGF0aW9uID0gcGF5b2Zmc1szXVxyXG5cclxuXHJcblx0dmFyIGNob2ljZXMgPSBbXHJcblx0XHRbXCJDb29wZXJhdGVcIiwgXCJEZWZlY3RcIl0sXHJcblx0XHRbXCJDb29wZXJhdGVcIiwgXCJEZWZlY3RcIl1cclxuXHRdO1xyXG5cdHZhciBnYW1lUGF5b2ZmcyA9IFtcclxuXHRcdFtcclxuXHRcdFx0W3Jld2FyZCwgcmV3YXJkXSxcclxuXHRcdFx0W3N1Y2tlciwgdGVtcHRhdGlvbl1cclxuXHRcdF0sXHJcblx0XHRbXHJcblx0XHRcdFt0ZW1wdGF0aW9uLCBzdWNrZXJdLFxyXG5cdFx0XHRbcHVuaXNobWVudCwgcHVuaXNobWVudF1cclxuXHRcdF1cclxuXHRdO1xyXG5cclxuXHRyZXR1cm4gVHdvUGxheWVyTm9ybWFsKHBsYXllcnMsIGNob2ljZXMsIGdhbWVQYXlvZmZzLCBwYXJhbWV0ZXJzKTtcclxufSk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBwcmlzb25lckRpbGVtbWE7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gYmFzZSBnYW1lXHJcbnZhciBTaW1wbGVaZXJvU3VtID0gcmVxdWlyZShcIi4vc2ltcGxlLXplcm8tc3VtXCIpO1xyXG5cclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG4vLyBoZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKVxyXG5cclxuLy8gUGxheS10aW1lIGxvZ2ljXHJcbnZhciB7IEV4cHJlc3Npb24gfSA9IEVuZ2luZS5Gcm9udGVuZFxyXG5cclxuXHJcbi8vIFJvY2stUGFwZXItU2Npc3NvcnNcclxudmFyIFJvY2tQYXBlclNjaXNzb3JzID0gZ2FtZVdyYXBwZXIoZnVuY3Rpb24ocGxheWVycywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0cGFyYW1ldGVycy5pZCA9IHBhcmFtZXRlcnMuaWQgfHwgXCJSb2NrLVBhcGVyLVNjaXNzb3JzXCI7XHJcblx0cGFyYW1ldGVycy5wYXlvZmYgPSBwYXJhbWV0ZXJzLnBheW9mZiB8fCAxO1xyXG5cclxuXHR2YXIgd2luID0gcGFyYW1ldGVycy5wYXlvZmY7XHJcblx0dmFyIGxvc2UgPSBFeHByZXNzaW9uKGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIC1wYXlvZmY7XHJcblx0fSk7XHJcblxyXG5cdHZhciBjaG9pY2VzID0gW1xyXG5cdFx0W1wiUm9ja1wiLCBcIlBhcGVyXCIsIFwiU2Npc3NvcnNcIl0sXHJcblx0XHRbXCJSb2NrXCIsIFwiUGFwZXJcIiwgXCJTY2lzc29yc1wiXVxyXG5cdF07XHJcblx0dmFyIHBheW9mZnMgPSBbXHJcblx0XHRbMCwgbG9zZSwgd2luXSxcclxuXHRcdFt3aW4sIDAsIGxvc2VdLFxyXG5cdFx0W2xvc2UsIHdpbiwgMF1cclxuXHRdO1xyXG5cclxuXHRyZXR1cm4gU2ltcGxlWmVyb1N1bShwbGF5ZXJzLCBjaG9pY2VzLCBwYXlvZmZzLCBwYXJhbWV0ZXJzKTtcclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvY2tQYXBlclNjaXNzb3JzXHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy9OYXNoSlMgRW5naW5lXHJcbnZhciBFbmdpbmUgPSByZXF1aXJlKFwiLi4vbGliL2VuZ2luZVwiKVxyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uXHJcbnZhciB7IHNodWZmbGUgfSA9IEVuZ2luZS5CYWNrZW5kLkhlbHBlckZ1bmN0aW9ucyhcImdlbmVyYWxcIik7XHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKVxyXG5cclxuLy8gbmFzaEpTIGVuZ2luZSBjb21wb25lbnRcclxudmFyIHsgU2VxdWVuY2UsIFNpbXVsdGFuZW91cyB9ID0gRW5naW5lLkZyb250ZW5kLlBsYXlhYmxlcztcclxuXHJcbi8vZm9yIGluZm9ybWF0aW9uIG1lY2hhbmljc1xyXG52YXIgeyBJbmZvcm1hdGlvbiwgSGlzdG9yeSwgUGxheWVyTGlzdCB9ID0gRW5naW5lLkJhY2tlbmQuQ2xhc3NlcztcclxuXHJcblxyXG4vLyBnYW1lR2VuZXJhdG9yIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHdob3NlIGZpcnN0IGFyZ3VtZW50IGlzIGFuIGFycmF5IG9mIHBsYXllcnNcclxudmFyIFJvdW5kUm9iaW4gPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCBnYW1lR2VuZXJhdG9yLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRwYXJhbWV0ZXJzLmlkID0gcGFyYW1ldGVycy5pZCB8fCBcIlJvdW5kLVJvYmluXCI7XHJcblx0cGFyYW1ldGVycy5pbml0aWFsaXplUGxheWVycyA9IHBhcmFtZXRlcnMuaW5pdGlhbGl6ZVBsYXllcnMgJiYgdHJ1ZTtcclxuXHJcblx0Ly8gQ3JlYXRlIGFycmF5IG9mIGVhY2ggY29tYmluYXRpb24gb2YgcGxheWVyc1xyXG5cdHZhciBtYXRjaGVzID0gW107XHJcblxyXG5cdHBsYXllcnMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIxLCBpbmRleDEpIHtcclxuXHRcdGZvciAodmFyIGluZGV4MiA9IDA7IGluZGV4MiA8IGluZGV4MTsgaW5kZXgyKyspIHtcclxuXHRcdFx0bWF0Y2hlcy5wdXNoKFtwbGF5ZXJzW2luZGV4Ml0sIHBsYXllcjFdKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvcHRpb25hbCBwYXJhbWV0ZXIgJ2NvcGllcy4nIFBhc3MgYW4gZXh0cmEgY29weSBvZiBlYWNoIHBsYXllciwgdG8gcGxheSB0aGVtc2VsdmVzXHJcblx0XHRpZiAocGFyYW1ldGVycy5jb3BpZXMpIG1hdGNoZXMucHVzaChbcGFyYW1ldGVycy5jb3BpZXNbaW5kZXgxXSwgcGxheWVyMV0pO1xyXG5cdH0pO1xyXG5cclxuXHQvL3JhbmRvbWl6ZSB0aGUgb3JkZXJcclxuXHRzaHVmZmxlKG1hdGNoZXMpO1xyXG5cclxuXHQvLyBUcmFjayBzY29yZXNcclxuXHR2YXIgc2NvcmVzUmVjb3JkID0gW107XHJcblxyXG5cdC8vXHJcblx0dmFyIGFkZFJvdW5kID0gZnVuY3Rpb24ocGxheWVycywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0XHQvLyBpbmZvcm1hdGlvbiBtZWNoYW5pY3MgYW5kIG90aGVyIHBhcmFtZXRlcnNcclxuXHRcdHZhciBwb3B1bGF0aW9uID0gbmV3IFBsYXllckxpc3QocGxheWVycykuZ2VuZXJhdG9yXHJcblx0XHRwYXJhbWV0ZXJzLmNvbXBhcnRtZW50YWxpemUgPSB7IHBvcHVsYXRpb24gfVxyXG5cdFx0cGFyYW1ldGVycy5pbml0aWFsaXplUGxheWVycyA9IHBvcHVsYXRpb247XHJcblxyXG5cdFx0Ly8gZ2VuZXJhdGUgcm91bmRcclxuXHRcdHZhciByb3VuZCA9IGdhbWVHZW5lcmF0b3IocGxheWVycywgcGFyYW1ldGVycyk7XHJcblxyXG5cdFx0Ly8gdHJhY2sgdGhlIHNjb3Jlc1xyXG5cdFx0dmFyIHJlY29yZFNjb3JlcyA9IExhbWJkYShmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHNjb3JlID0ge31cclxuXHRcdFx0Zm9yIChsZXQgW3N0cmF0ZWd5LCBzY29yZXNdIG9mIE9iamVjdC5lbnRyaWVzKHBvcHVsYXRpb24oKS5zY29yZXNCeVN0cmF0ZWd5KCkpKSB7XHJcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoc2NvcmVzKSkge1xyXG5cdFx0XHRcdFx0aWYgKHNjb3Jlcy5sZW5ndGggPT0gMSkgc2NvcmVzID0gc2NvcmVzWzBdXHJcblx0XHRcdFx0XHRzY29yZVtzdHJhdGVneV0gPSBzY29yZXM7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHNjb3Jlc1JlY29yZC5wdXNoKHNjb3JlKTtcclxuXHJcblx0XHRcdC8vcmV0dXJuIHNjb3JlIGZvciBoaXN0b3J5XHJcblx0XHRcdHJldHVybiBzY29yZTtcclxuXHRcdH0sIHsgaWQ6IFwiUmVjb3JkLVNjb3Jlc1wiIH0pO1xyXG5cclxuXHRcdC8vQ2hhaW4gdG9nZXRoZXJcclxuXHRcdHJlY29yZFNjb3Jlcyhyb3VuZCk7XHJcblxyXG5cdFx0Ly8gcmV0dXJuIGJvdGhcclxuXHRcdHJldHVybiBbcm91bmQsIHJlY29yZFNjb3Jlc1xyXG5cdFx0XHQvLyAsU2VxdWVuY2Uocm91bmQsIHJlY29yZFNjb3JlcykgLy8gVW5jb21tZW50IGZvciBTaW11bHRhbmVvdXMgaW1wbGVtZW50YXRpb25cclxuXHRcdF07XHJcblx0fTtcclxuXHJcblxyXG5cclxuXHQvLyBTZXF1ZW50aWFsIGltcGxlbWVudGF0aW9uXHJcblx0Ly8gbG9hZCB0aGUgZmlyc3QgbWF0Y2ggbWFudWFsbHlcclxuXHR2YXIgW2ZpcnN0Um91bmQsIGZpcnN0UmVjb3JkXSA9IGFkZFJvdW5kKFxyXG5cdFx0bWF0Y2hlcy5zaGlmdCgpLFxyXG5cdFx0cGFyYW1ldGVycy5wYXJhbWV0ZXJzXHJcblx0KTtcclxuXHJcblx0Ly90aGVuIGxvYWQgc3Vic2VxdWVudCBtYXRjaGVzXHJcblx0dmFyIHJlY29yZCA9IGZpcnN0UmVjb3JkO1xyXG5cdHZhciBsYXN0UmVjb3JkLCBsYXN0Um91bmQ7XHJcblxyXG5cdG1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbihtYXRjaCkge1xyXG5cdFx0W2xhc3RSb3VuZCwgbGFzdFJlY29yZF0gPSBhZGRSb3VuZChtYXRjaCwgcGFyYW1ldGVycy5wYXJhbWV0ZXJzKTtcclxuXHJcblx0XHRsYXN0Um91bmQocmVjb3JkKTtcclxuXHRcdHJlY29yZCA9IGxhc3RSZWNvcmQ7XHJcblx0fSk7XHJcblxyXG5cclxuXHRyZXR1cm4gU2VxdWVuY2UoZmlyc3RSb3VuZCwgbGFzdFJlY29yZCwgcGFyYW1ldGVycyk7XHJcblxyXG5cdC8qIC8vIFNpbXVsdGFuZW91cyBpbXBsZW1lbnRhdGlvblxyXG5cdHZhciByb3VuZHMgPSBbXTtcclxuXHRtYXRjaGVzLmZvckVhY2goZnVuY3Rpb24obWF0Y2gpIHtcclxuXHQgIHJvdW5kcy5wdXNoKGFkZFJvdW5kKG1hdGNoLCBwYXJhbWV0ZXJzLmdhbWVQYXJhbWV0ZXJzKVsyXSk7XHJcblx0fSk7XHJcblxyXG5cdHJldHVybiBTaW11bHRhbmVvdXMocm91bmRzLCBwYXJhbWV0ZXJzKTsgKi9cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJvdW5kUm9iaW47XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy9HYW1lIGVuZ2luZVxyXG52YXIgRW5naW5lID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIilcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpc0Z1bmN0aW9uIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJnZW5lcmFsXCIpXHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKVxyXG5cclxuLy8gUGxheWFibGVzXHJcbnZhciB7IFR1cm4sIENob2ljZSwgUmFuZG9tUGxheWVyQ2hvaWNlIH0gPSBFbmdpbmUuRnJvbnRlbmQuUGxheWFibGVzO1xyXG5cclxuLy9QbGF5LXRpbWUgTG9naWNcclxudmFyIHsgUmFuZG9tVmFyaWFibGUgfSA9IEVuZ2luZS5Gcm9udGVuZFxyXG5cclxudmFyIE5vcm1hbCA9IGdhbWVXcmFwcGVyKGZ1bmN0aW9uKHBsYXllcnMsIGNob2ljZUxpc3RzLCBwYXlvZmZzID0gbnVsbCwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblxyXG5cdFx0Ly9wcm9wb2dhdGUgdGhlIGluZm9ybWF0aW9uIGZpbHRlclxyXG5cdFx0cGFyYW1ldGVycy5wYXJhbWV0ZXJzID8gcGFyYW1ldGVycy5wYXJhbWV0ZXJzLmluZm9ybWF0aW9uRmlsdGVyID0gcGFyYW1ldGVycy5pbmZvcm1hdGlvbkZpbHRlciA6XHJcblx0XHRcdHBhcmFtZXRlcnMucGFyYW1ldGVycyA9IHsgaW5mb3JtYXRpb25GaWx0ZXI6IHBhcmFtZXRlcnMuaW5mb3JtYXRpb25GaWx0ZXIgfVxyXG5cclxuXHRcdC8vIGNvbnN0cnVjdCB0aGUgY2hvaWNlc1xyXG5cdFx0dmFyIGNob2ljZXMgPSBjaG9pY2VMaXN0cy5tYXAoZnVuY3Rpb24obGlzdCwgaW5kZXgpIHtcclxuXHRcdFx0cmV0dXJuIHBsYXllcnMgPT0gXCJyYW5kb21cIiA/IFJhbmRvbVBsYXllckNob2ljZShsaXN0LCBwYXJhbWV0ZXJzLnBhcmFtZXRlcnMpIDogQ2hvaWNlKHBsYXllcnNbaW5kZXhdLFxyXG5cdFx0XHRcdGxpc3QsIHBhcmFtZXRlcnMucGFyYW1ldGVycyk7XHJcblx0XHR9KTtcclxuXHJcblx0XHR2YXIgZ2FtZSA9IFR1cm4oY2hvaWNlcywgcGFyYW1ldGVycyk7XHJcblxyXG5cdFx0aWYgKHBheW9mZnMpIGdhbWUuc2V0QWxsUGF5b2ZmcyhwYXlvZmZzKTtcclxuXHJcblx0XHRyZXR1cm4gZ2FtZTtcclxuXHR9LCB7XHJcblx0XHRxdWVyeUxvYWRlcigpIHtcclxuXHRcdFx0cmV0dXJuIFt7XHJcblx0XHRcdFx0XHRuYW1lOiBcIkBOLWNob2ljZXNcIixcclxuXHRcdFx0XHRcdHF1ZXJ5OiBcIiQucmVzdWx0c3twbGF5ZXI6cmVzdWx0fVwiLFxyXG5cdFx0XHRcdFx0ZGVzY3JpcHRpb246IFwiUGxheWVycyBhbmQgdGhlaXIgY2hvaWNlLlwiXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRuYW1lOiBcIkBOLXBsYXllcnNcIixcclxuXHRcdFx0XHRcdHF1ZXJ5OiBcIiQucmVzdWx0cy5wbGF5ZXJcIixcclxuXHRcdFx0XHRcdGRlc2NyaXB0aW9uOiBcIldobyBwbGF5ZWQuXCJcclxuXHRcdFx0XHR9XHJcblx0XHRcdF1cclxuXHRcdH0sXHJcblx0XHRzdHJhdGVneUxvYWRlcjogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiBbe1xyXG5cdFx0XHRcdFx0c3RyYXRlZ3k6IGZ1bmN0aW9uIGNob29zZUZpcnN0KCkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmNob29zZSA9IGZ1bmN0aW9uKGNob2ljZXMsIGluZm9ybWF0aW9uKSB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNob2ljZXNbMF1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdG5hbWU6IFwiQ2hvb3NlIEZpcnN0XCIsXHJcblx0XHRcdFx0XHRkZXNjcmlwdGlvbjogXCJBbHdheXMgY2hvb3NlIGZpcnN0IGF2YWlsYWJsZSBvcHRpb24uXCJcclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRzdHJhdGVneTogZnVuY3Rpb24gY2hvb3NlU2Vjb25kKCkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmNob29zZSA9IGZ1bmN0aW9uKGNob2ljZXMsIGluZm9ybWF0aW9uKSB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNob2ljZXNbMV1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdG5hbWU6IFwiQ2hvb3NlIFNlY29uZFwiLFxyXG5cdFx0XHRcdFx0ZGVzY3JpcHRpb246IFwiQWx3YXlzIGNob29zZSBzZWNvbmQgYXZhaWxhYmxlIG9wdGlvbi5cIlxyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHN0cmF0ZWd5OiBmdW5jdGlvbiByYW5kb21pemUoY2hvaWNlcyA9IFswLCAxXSkge1xyXG5cdFx0XHRcdFx0XHQvLyBDcmVhdGluZyBhIG1hcCB3aWxsIG1ha2UgcGlja2luZyBhIHJhbmRvbSB2YWx1ZSBlYXNpZXJcclxuXHRcdFx0XHRcdFx0Y2hvaWNlcyA9IGNob2ljZXMubWFwKGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFtpbmRleCwgaXRlbV1cclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdHZhciBjaG9pY2VNYXAgPSBuZXcgTWFwKGNob2ljZXMpXHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLmNob29zZSA9IGZ1bmN0aW9uKGNob2ljZXMsIGluZm9ybWF0aW9uKSB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNob2ljZXNbY2hvaWNlTWFwLmdldChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaG9pY2VNYXAuc2l6ZSkpXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdG5hbWU6IFwiUmFuZG9taXplXCIsXHJcblx0XHRcdFx0XHRkZXNjcmlwdGlvbjogXCJDaG9vc2UgcmFuZG9tbHkgZnJvbSBhdmFpbGFibGUgb3B0aW9ucy5cIlxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XTtcclxuXHRcdH1cclxuXHR9IC8vIFx0XHRcdFx0XHRcdFx0XHRcdFx0VE9ETzogdmFsaWRhdGUgYWxsIGFyZ3VtZW50c1xyXG4pO1xyXG5cclxuXHJcbnZhciBUd29QbGF5ZXJOb3JtYWwgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCBjaG9pY2VzLCBwYXlvZmZzID0gbnVsbCwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblxyXG5cdC8vIEluZm9ybWF0aW9uIG1lY2hhbmljcy4uIFRoZXJlIGFyZSBvbmx5IHR3byBwbGF5ZXJzLCBzbyB3ZSBjYW4gaGF2ZSBhICdtZScgYW5kICdvcHBvbmVudCcgZW50cnkuXHJcblx0Ly8gSWYgdXNlciBzdXBwbGllZCBhbiBpbmZvcm1hdGlvbiBmaWx0ZXIsIHdyYXAgdGhhdCBmaWx0ZXIgaW4gb3Vycy5cclxuXHR2YXIgeyBpbmZvcm1hdGlvbkZpbHRlciB9ID0gcGFyYW1ldGVycztcclxuXHRpZiAoIWlzRnVuY3Rpb24oaW5mb3JtYXRpb25GaWx0ZXIpKSBpbmZvcm1hdGlvbkZpbHRlciA9IG51bGw7XHJcblxyXG5cdC8vIFdyYXAgdGhlIHVzZXIncyBmaWx0ZXJcclxuXHR2YXIgd3JhcHBlZEZpbHRlciA9IGZ1bmN0aW9uKGluZm9ybWF0aW9uKSB7XHJcblx0XHQvLyBGaWd1cmUgb3V0IHdobyBJIGFtIGFuZCB3aG8gdGhlIG9wcG9uZW50IGlzXHJcblx0XHR2YXIgbWUgPSBpbmZvcm1hdGlvbi5tZS5pZFxyXG5cdFx0dmFyIHBsYXllcnMgPSBbaW5mb3JtYXRpb24udHVybi5jaG9pY2VzWzBdLmNob2ljZS5wbGF5ZXIsIGluZm9ybWF0aW9uLnR1cm4uY2hvaWNlc1sxXS5jaG9pY2UucGxheWVyXVxyXG5cdFx0dmFyIG9wcG9uZW50ID0gcGxheWVycy5zcGxpY2UocGxheWVycy5pbmRleE9mKG1lKSwgMSkgJiYgcGxheWVyc1swXTtcclxuXHJcblx0XHQvLyBhZGQgZW50cnkgZm9yIG9wcG9uZW50XHJcblx0XHR2YXIgb3Bwb25lbnREZXRhaWwgPSBpbmZvcm1hdGlvbi5wb3B1bGF0aW9uLmZpbHRlcihmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0cmV0dXJuIChwbGF5ZXIuaWQgPT0gb3Bwb25lbnQpXHJcblx0XHR9KVswXTtcclxuXHRcdGluZm9ybWF0aW9uLm9wcG9uZW50ID0gb3Bwb25lbnREZXRhaWw7XHJcblxyXG5cdFx0Ly8gcnVuIHRoZSB1c2VyJ3MgaW5mb3JtYXRpb24gZmlsdGVyXHJcblx0XHRpZiAoaW5mb3JtYXRpb25GaWx0ZXIpIGluZm9ybWF0aW9uID0gaW5mb3JtYXRpb25GaWx0ZXIoaW5mb3JtYXRpb24pO1xyXG5cclxuXHRcdHJldHVybiBpbmZvcm1hdGlvbjtcclxuXHR9XHJcblxyXG5cdC8vIFBhc3MgdGhlIGluZm9ybWF0aW9uIGZpbHRlclxyXG5cdHBhcmFtZXRlcnMuaW5mb3JtYXRpb25GaWx0ZXIgPSB3cmFwcGVkRmlsdGVyXHJcblxyXG5cdHJldHVybiBOb3JtYWwocGxheWVycywgY2hvaWNlcywgcGF5b2ZmcywgcGFyYW1ldGVycylcclxufSk7IC8vXHRcdFx0XHQgXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRUT0RPOiBtYXkgd2FudCB0byB2YWxpZGF0ZSBhcmd1bWVudHMgaGVyZSB0b29cclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IFR3b1BsYXllck5vcm1hbCwgTm9ybWFsIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gYmFzZSBnYW1lXHJcbnZhciBUd29QbGF5ZXJOb3JtYWwgPSByZXF1aXJlKFwiLi9zaW1wbGUtbm9ybWFsXCIpLlR3b1BsYXllck5vcm1hbDtcclxuXHJcbi8vIE5hc2hKUyBjb21wb25lbnRzXHJcbnZhciBFbmdpbmUgPSByZXF1aXJlKFwiLi4vbGliL2VuZ2luZVwiKVxyXG5cclxuLy8gR2FtZSBzdGF0ZSBjb250cm9sbGVyXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSBFbmdpbmUuQmFja2VuZC5TdGF0ZVxyXG52YXIgeyBnYW1lV3JhcHBlciB9ID0gRW5naW5lLkJhY2tlbmQuSGVscGVyRnVuY3Rpb25zKFwic3RvY2stZ2FtZXNcIik7XHJcblxyXG4vLyBQbGF5LXRpbWUgbG9naWNcclxudmFyIHsgVmFyaWFibGUsIEV4cHJlc3Npb24gfSA9IEVuZ2luZS5Gcm9udGVuZDtcclxuXHJcbi8qIGJlYXV0aWZ5IHByZXNlcnZlOnN0YXJ0ICovXHJcbnZhciBTaW1wbGVaZXJvU3VtID0gZ2FtZVdyYXBwZXIoZnVuY3Rpb24ocGxheWVycywgY2hvaWNlcywgcGF5b2ZmcyA9IFtbMCwgMF0sXHRbMCwgMF1dLCBwYXJhbWV0ZXJzPXt9KSB7XHJcbi8qIGJlYXV0aWZ5IHByZXNlcnZlOmVuZCAqL1xyXG5cclxuXHR2YXIgZ2FtZSA9IFR3b1BsYXllck5vcm1hbChwbGF5ZXJzLCBjaG9pY2VzLCBudWxsLCBwYXJhbWV0ZXJzKVxyXG5cclxuXHR2YXIgZTtcclxuXHJcblx0Y2hvaWNlc1swXS5mb3JFYWNoKGZ1bmN0aW9uKGNob2ljZTAsIGluZGV4MCkge1xyXG5cdFx0Y2hvaWNlc1sxXS5mb3JFYWNoKGZ1bmN0aW9uKGNob2ljZTEsIGluZGV4MSkge1xyXG5cclxuXHRcdFx0Ly8gU2V0IGV4cHJlc3Npb25cclxuXHRcdFx0ZSA9IEV4cHJlc3Npb24oZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly9SZXR1cm4gdGhlIG5lZ2F0aXZlIHBheW9mZiwgb3IgemVyb1xyXG5cdFx0XHRcdHJldHVybiAoMCAtIHJlZ2lzdHJ5LnR1cm5zW2dhbWUuaWQoKV0ucGF5b2Zmc0ltcGxpY2l0W2Nob2ljZTBdW2Nob2ljZTFdWzBdIHx8IDApO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdC8vU2V0IHBheW9mZnNcclxuXHRcdFx0Z2FtZVtjaG9pY2UwXVtjaG9pY2UxXShbcGF5b2Zmc1tpbmRleDBdW2luZGV4MV0sIGVdKTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gZ2FtZTtcclxufSk7IC8vXHRcdFx0XHRcdFRPRE86IHZhbGlkYXRlIGFyZ3VtZW50c1xyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNpbXBsZVplcm9TdW07XHJcbiJdfQ==
