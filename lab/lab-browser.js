(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":3}],3:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],4:[function(require,module,exports){
//Main module code
var NashJS = require('./lib/engine').Frontend;

//Stock-games
NashJS.StockGames = require('./stock-games');


module.exports = NashJS;

},{"./lib/engine":6,"./stock-games":74}],5:[function(require,module,exports){
({
	Player,
	_Player,
	gamePopulation,
	Population,
	PlayerList,
	registerStrategy,
	Strategies,
	strategyLoader,
	_expose,
	registry,
	Variable,
	Expression,
	RandomVariable,
	ComplexVariable,
	History,
	Queries,
	excludedPlayers,
	startREPL,
	nhistory,
	Information,
	PerfectInformation,
	PluginManager,
	syncMode
} = require("../index"));
({
	Choice,
	Range,
	Turn,
	Sequence,
	Consecutive,
	Loop,
	StochasticLoop,
	HaltIf,
	StochasticHalt,
	Lambda,
	RandomPlayerChoice,
	PopulationDynamics,
	Simultaneous
} = require("../index").Playables);
StockGames = require("../index").StockGames;



p1 = Player();
p2 = Player();
p3 = Player();
ipd = StockGames["Iterated Prisoner's Dilemma"]([p1, p2], 20)
/*
StockGames["Prisoner's Dilemma"]([p1, p2])

p1.assign("chooseFirst")
p2.assign("randomize");

p3 = Player();
p3.assign("chooseSecond");
p4 = Player();
p4.assign("randomize")

c1 = Choice(p1, ["cooperate", "defect"]);
//c1['left'](5) ;
//c1['right'](2);
c2 = Choice(p2, ["Cooperate", "Defect"]);
//c2['up'](1);
//c2['down'](7);

t2 = Turn([c1, c2]);
t3 = Turn([c1, c2]);
t4 = Turn([c1, c2]);
t5 = Turn([c1, c2]);
s1 = Simultaneous([t2, t3, t4, t5])

c = Consecutive([
	Turn([c1, c2]),
	Turn([c2, c1]),
	Choice(p1, ["cooperate", "defect"]),
	Lambda(function() { console.log("hi") }),
	HaltIf(function() { return true })
])

c3 = RandomPlayerChoice(["cooperate", "defect"]);
c4 = RandomPlayerChoice(["Cooperate", "Defect"]);

t1 = Turn([c3, c4]);

v1 = new Variable(3);

t1.defect.Defect([2, 2]);
t1.defect.Cooperate([4, 1]);
t1.cooperate.Defect([1, 4]);
t1.cooperate.Cooperate([v1, v1]);

L1 = Lambda(function() {
	v1.set(v1 + 1);
});

pd1 = PopulationDynamics(1.5, 1);

h2 = HaltIf(function() {
	return Population().onlyAlive().length == 0;
});

L1(t1);
pd1(L1);
h2(pd1);

//s1 = Sequence(t1, h2);

//l1 = Loop(s1, 10, { logContinue: true });

//console.log(_expose(t1).next)
//console.log(_expose(t1).next.cooperate.Cooperate)

h2 = HaltIf(function() {
	return Population().onlyAlive().length == 0;
});

L2 = Lambda(function() {
	p1.kill();
});

t2(L2);

generatePopulation = function() {
	for (i = 0; i < 30; i++) {
		Player({ assign: "chooseFirst" });
	}
	for (i = 0; i < 30; i++) {
		Player({ assign: "chooseSecond" });
	}
};

function gameGenerator() {
	var t = Turn([
		RandomPlayerChoice(["cooperate", "defect"]),
		RandomPlayerChoice(["Cooperate", "Defect"])
	]);

	t.defect.Defect([2, 2]);
	t.defect.Cooperate([4, 1]);
	t.cooperate.Defect([1, 4]);
	t.cooperate.Cooperate([3, 3]);

	return t;
}
//
//
//

//CE = StockGames["Cultural Evolution"](gameGenerator, 1, {generatePopulation});

//n = StockGames["Two-Player Normal"](p1,p2,[["left","right"],["up","down"]]);
//pd1 = StockGames["Prisoner's Dilemma"]([p1, p2]);
//pd2 = StockGames["Prisoner's Dilemma"]([p3, p4]);

//s = Simultaneous([pd1, pd2])

v2 = Variable(1);

//n = StockGames["Simple Zero-Sum"](p1,p2,[["left","right"],["up","down"]], [[v2,2],[3,4]]);

//rpc = StockGames["Rock-Paper-Scissors"]([p1, p2]);
//t = StockGames["Axelrod Tournament"];
//t = StockGames["Iterated Prisoner's Dilemma"]([p1, p2]);
//The code below is to run the repl for testing purposes.
//var toRepl = {_expose, registry,Player,Choice,Turn,Sequence,Loop,StochasticLoop,HaltIf, StochasticHalt, Lambda, p1,c1,c2,t1};
//startREPL(toRepl);
*/

},{"../index":4}],6:[function(require,module,exports){
"use strict";

// Load settings information
var Settings = require("../settings");
// object for user to change settings
function settings(setting, value) {
	Settings[setting] = value
}


// Start plug-in manager
var PluginManager = require("./plugin-manager")
PluginManager.start(function() {})


//Logging
var log = require("./logger");
log.setLevel(Settings["init-log-level"]);
log("info", "Starting NashJS");


//Game state controllers
var { registry, idCounters } = require('./state');
registry.Settings = Settings


// Helper function loader
var HelperFunctions = require('./helper-functions');

// Sync mode
var { syncMode } = HelperFunctions("state")
syncMode(Settings["init-sync-mode"]);

// Query language and shortcuts
var { Queries, Query, QueryResult, evaluateQuery, registerQueryObject } = require("./query");


// History
var { gameHistory, userGameHistory, History, UserHistory } = require('./history');


//Players
var { _Player, Player } = require('./player');
registry._addType_("players");
idCounters._addType_("player");


//Population
var { gamePopulation, Population, PlayerList, UserPlayerList } = require('./population');


//Information mechanics
var { Information, PerfectInformation } = require("./information");


//Playables
var { playableClasses, playableInterfaces } = require('./playables/')
for (var _class in playableClasses) {
	registry._addType_(playableClasses[_class].registryName);
	idCounters._addType_(playableClasses[_class].counterName);
}

//Symbolic Logic
var {
	variablePrototype,
	Variable,
	expressionPrototype,
	Expression,
	RandomVariable,
	ComplexVariable
} = require("./logic");


//Strategies
registry._addType_("strategies");
idCounters._addType_("strategy");

var { registerStrategy, registerStrategyObject, Strategies } = require('./strategy');
var { loadStrategy, loadStrategyFolder } = require('./strategy-loader');




//THIS FUNCTION IS ONLY FOR DEBUGGING. REMOVE IT FROM MODULE EXPORTS WHEN PUBLISHING
function Expose(interfacePlayable) {
	return registry.playables[interfacePlayable.id()];
}


function startREPL(toREPL) {
	var repl = require("repl");

	var replServer = repl.start({
		prompt: "Nash >> "
	});

	Object.assign(replServer.context, toREPL);
}



var Engine = {
	Frontend: {
		Player,
		//_Player, //REMOVE THIS LINE WHEN PUBLISHING
		//gamePopulation, //REMOVE THIS LINE WHEN PUBLISHING
		'PlayerList': UserPlayerList,
		Population,
		//Information, //REMOVE THIS LINE WHEN PUBLISHING
		//PerfectInformation, //REMOVE THIS LINE WHEN PUBLISHING
		'Playables': playableInterfaces,
		registerStrategy,
		registerStrategyObject,
		Strategies,
		loadStrategy,
		loadStrategyFolder,
		History: userGameHistory,
		Queries,
		//Expose, //REMOVE THIS LINE WHEN PUBLISHING
		//registry, //REMOVE THIS LINE WHEN PUBLISHING
		startREPL, //Should this line be removed when publishing?
		Variable,
		Expression,
		RandomVariable,
		ComplexVariable,
		syncMode
		//PluginManager //REMOVE THIS LINE WHEN PUBLISHING
	},

	Backend: {
		logger: log,
		State: { registry, idCounters, gameHistory, gamePopulation, PerfectInformation },
		Classes: {
			Player: _Player,
			History,
			UserHistory,
			PlayerList,
			UserPlayerList,
			Information,
			PlayableClasses: { playableClasses },
			Query,
			QueryResult,
			variablePrototype,
			expressionPrototype
		},
		HelperFunctions,
		PluginManager,
		registerQueryObject,
		Expose
	}
}

module.exports = Engine;

},{"../settings":69,"./helper-functions":8,"./history":16,"./information":17,"./logger":18,"./logic":19,"./playables/":23,"./player":35,"./plugin-manager":37,"./population":41,"./query":42,"./state":43,"./strategy":45,"./strategy-loader":44,"repl":1}],7:[function(require,module,exports){
var general = {
	//Check if variable is an Object
	isObject(a) {
		return !!a && a.constructor === Object;
	},

	//What do you think?
	isFunction(a) {
		return typeof a === "function";
	},

	//Provide a function, a context ('this'), and an argument array.
	//Returns a function that can be called.
	applyBind(func, that, argArray) {
		return func.bind.apply(func, [that].concat(argArray));
	},

	//Wraps a function to ensure it only gets called one time.
	once(fn, context) {
		var result;

		return function() {
			if (fn) {
				result = fn.apply(context || this, arguments);
				fn = null;
			}

			return result;
		};
	},

	// Randomly re-order array
	shuffle(array) {
		var currentIndex = array.length,
			temporaryValue,
			randomIndex;

		// While there remain elements to shuffle...
		while (0 !== currentIndex) {
			// Pick a remaining element...
			randomIndex = Math.floor(Math.random() * currentIndex);
			currentIndex -= 1;

			// And swap it with the current element.
			temporaryValue = array[currentIndex];
			array[currentIndex] = array[randomIndex];
			array[randomIndex] = temporaryValue;
		}

		return array;
	}
};

module.exports = general;

},{}],8:[function(require,module,exports){
"use strict";

var log = require("../logger");

log("debug", "helperFunctions-index: Loading helper functions loader.");

/*
var general  = require('./general');
var player   = require('./player');
var playable = require('./playable');
var turn 	 = require('./turn');
var state 	 = require('./state'); 
*/

function loader(file) {
	return require("./" + file + ".js");
}

module.exports = loader;
//module.exports = {general, player, playable, turn, state};

// Hack to compile Glob files (in browserify). Don´t call this function!
(function() {
	require('./general.js');require('./index.js');require('./logic.js');require('./playable.js');require('./player.js');require('./state.js');require('./stock-games.js');require('./tournament.js');require('./turn.js');
});

},{"../logger":18,"./general.js":7,"./index.js":8,"./logic.js":9,"./playable.js":10,"./player.js":11,"./state.js":12,"./stock-games.js":13,"./tournament.js":14,"./turn.js":15}],9:[function(require,module,exports){
"use strict";

var logic = {

	// Check to see if object is Variable/Expression or not. Returns true/false
	isLogic(logic) {

		if (logic instanceof Function && logic == logic * 1) return true
		else return false;
	}
};

module.exports = logic;

},{}],10:[function(require,module,exports){
"use strict";

var { SynchronousPromise } = require('synchronous-promise');

//Game state controllers
var { registry } = require('../state');

var playable = {
	// Generates the function that gets returned when a Playable is called, which can then be called to chain playables together.
	chainerGenerator(externalObj, internalObj) {
		externalObj = this;
		return function(source) {
			var previousPlayable, path;

			//TODO: verify that source is the right type

			return SynchronousPromise.all([function() {
				if (source instanceof Promise || source instanceof SynchronousPromise) {
					source.then(function(result) {
						previousPlayable = registry.playables[result.playable.id()];
						path = result.path
						return SynchronousPromise.resolve();
					});
				}
				return SynchronousPromise.resolve()
			}(), function() {
				if (!(source instanceof Promise || source instanceof SynchronousPromise)) {
					previousPlayable = registry.playables[source.id()];
					path = source.path;
				}
				return SynchronousPromise.resolve();
			}()]).then(function(result) {

				if (path == "all") previousPlayable.addNext(internalObj);
				else {

					outcomeTreeGetValue(previousPlayable.next, path).push(internalObj);
				}

				//previousPlayable.next[selected].push(_choice);

				return SynchronousPromise.resolve({
					'playable': externalObj,
					path: "all"
				});
			});
		};
	},


	//Use to set every value of an outcome tree
	outcomeTreeAddAll(tree, value) {

		//If it's an array, then we're already done.
		if (Array.isArray(tree)) {
			tree.push(value); //Use push here because this will be a unique array
		} else {
			var recurse = function(obj, val) {

				for (var keys in obj) {

					//If no keys left to traverse, then assign value. If not, recurse.
					if (Array.isArray(obj[keys])) {
						obj[keys] = obj[keys].slice().concat(val); //Use slice-concat here because this might not be a unique array (the creation process duplicates them)
					} else recurse(obj[keys], val);

				}
			};
			recurse(tree, value);
		}
	},


	//Traverse an outcome tree to obtain the value for a desired key-set
	//Argument one is a nested object, while argument 2 is an array of keys for the object, 1 layer at a time.
	outcomeTreeGetValue(tree, selector) {

		//Find the next item in the chain associated with the resultant outcome
		for (var i = 0, len = selector.length; i < len; i++) {
			tree = tree[selector[i]];
		}

		return tree;
	},


	//Traverse an outcome tree to set the value for a desired key-set
	//Argument one is a nested object, while argument 2 is an array of keys for the object, 1 layer at a time.
	outcomeTreeSetValue(tree, selector, value) {

		//Find the next item in the chain associated with the resultant outcome
		for (var i = 0, len = selector.length - 1; i < len; i++) {
			tree = tree[selector[i]];
		}

		return tree[selector[i]] = value;
	}
}



module.exports = playable;

},{"../state":43,"synchronous-promise":66}],11:[function(require,module,exports){
"use strict";

//  Game state
var { registry } = require("../state");

// helper function
var { isFunction } = require("./general");

// Player claass
var { _Player } = require("../player");

// Population
var { gamePopulation } = require("../population")

// Plugins
var PluginManager = require("../plugin-manager/")

var player = {

	//reset all players. Recreate from class, re-assign strategy, loop through objects that reference player to set new reference. result argument is only for pass-through.
	reinitializePlayers(population = "all", result = null) {
		return Promise.resolve().then(function() {
			var oldPlayer, strategy, strategyArgs, parameters;

			// if no population is supplied, fetch everybody
			if (population === "all") population = Object.keys(registry.players)
			else(population = population.ids())

			//Redefine each player
			for (var i = 0; i < population.length; i++) {
				var player = population[i];

				oldPlayer = registry.players[player];
				strategy = oldPlayer.strategy ? oldPlayer.strategy._id : null;
				strategyArgs = strategy ? oldPlayer.strategy._args : [];
				parameters = {}; //TODO: when adding player parameters, be sure they're included here

				registry.players[player] = new _Player(oldPlayer.id, parameters);
				registry.players[player].interface = oldPlayer.interface;
				strategy && registry.players[player].assign(strategy, ...strategyArgs);

				// Plugin, to alter players in re-initialization
				PluginManager.run("player-reinitialize", registry.players[player]);
			}

			//For each choice, recreate player references
			for (var choice in registry.decisions) {
				if (registry.decisions[choice].player)
					registry.decisions[choice].player = registry.players[registry.decisions[choice].player.id];
			}

			return Promise.resolve(result);
		});
	}
};

module.exports = player;

},{"../player":35,"../plugin-manager/":37,"../population":41,"../state":43,"./general":7}],12:[function(require,module,exports){
"use strict";

var log = require('../logger');

// State variables
var { idCounters, registry } = require('../state');

// External dependency
var { SynchronousPromise } = require("synchronous-promise");

var state = {

	//Handle ID setting for all objects that get stored in the registry
	idHandler: function idHandler(id, type, recursing = false) {
		//Assign id

		idCounters[type]++;
		var counter = idCounters[type];

		if (!id) {
			return type + counter.toString();
		} else {

			// Check that id isn't taken. If it is, construct a new one.

			//Construct list of all objects by extracting all registry entries
			var items = []
			Object.keys(registry).forEach(function(reg) { items.push.apply(items, Object.keys(registry[reg])) })

			// if id is already taken, generate a new one by adding a number at the end.
			if (items.indexOf(id) > -1) {

				var match, oldNum, exp, newId;
				var oldId = id;

				do {
					// This finds a number at the end, and increments it, or starts with 1 if there wasn't one.
					match = /\d+$/.exec(id);
					oldNum = match ? match[0] : "";
					exp = new RegExp(oldNum + "$");
					id = id.replace(exp, Number(oldNum) + 1)

				}
				while (items.indexOf(id) > -1)

				// Log warning
				log("warn", "ID " + oldId + " is taken. Using instead " + id);
			}

			return id
		}
	},

	// Change promises to sync
	syncMode(sync = "sync") {
		for (let prop of ["resolve", "reject", "all"]) {
			if (sync.toLowerCase() == "sync") {
				registry.Promise[prop] = SynchronousPromise[prop].bind(SynchronousPromise);
				registry.Promise.mode = "sync"
				registry.Settings["clear-history-on-play"] = false
			} else {
				registry.Promise[prop] = Promise[prop].bind(Promise)
				registry.Promise.mode = "async"
				registry.Settings["clear-history-on-play"] = true
			}
		}
	},
};

module.exports = state;

},{"../logger":18,"../state":43,"synchronous-promise":66}],13:[function(require,module,exports){
"use strict";

// Strategy registration
var { registerStrategyObject } = require("../engine").Frontend;

// Helper functions
var { isFunction, once } = require("./general");

//External dependency
var esprima = require("esprima");


// For handling queries
var { registry } = require("../engine").Backend.State
var { registerQueryObject } = require("../engine").Backend
var { idHandler } = require("./state")



var stockGames = {
	// utility function to create two ways to call a game, either with all the arguments, or curried, where the returned function takes players and parameters
	// The combineParameters setting will
	gameWrapper(game, {
		argumentValidator = function() { return true; },
		combineParameters = true,
		gameDescription = "No description given.",
		strategyLoader = null,
		queries = null
	} = {}) {

		var generate;

		// If there's a strategy loader, make sure it only runs once
		var loadStrategies
		if (isFunction(strategyLoader)) loadStrategies = once(function() {
			return registerStrategyObject(strategyLoader());
		});
		else loadStrategies = function() {}

		// If there's a query loader, make sure it only runs once
		var loadQueries
		if (queries) loadQueries = once(function() {
			return registerQueryObject(queries);
		});
		else loadQueries = function() {}

		// run the game. Optionally, validate the arguments and load strageies first
		generate = function(...args) {
			var result = argumentValidator(...args)
			if (result === true) {
				loadStrategies();
				loadQueries();
				return game(...args);
			} else throw new Error(result);
		}

		// creates a wrapper around the game, which accepts the first argument (players) and last argument (parameters), and passes it forward.
		// If combineParameters is set to true, then the second argument of the returned function will get merged with the last argument
		// given when generator is called.
		generate.createGenerator = function(...args) {

			var gameCode = esprima.parseScript("(" + game.toString() + ")")

			var gameArgs = gameCode.body[0].expression.params
			var lastArg = gameArgs[gameArgs.length - 1]

			var originalParameters
			if ((lastArg.name && lastArg.name.toLowerCase() === "parameters") || lastArg.type === "ObjectPattern" ||
				(lastArg.type == "AssignmentPattern" && lastArg.left.type == "ObjectPattern")) {
				// Check that the game arguments and createGenerator arguments are the correct lengths. createGenerator should be
				// 1 less than game, because players is omitted.
				// TODO: use esprima to allow players to be anywhere in the game definition (or even omitted) rather than first
				if (args.length == gameArgs.length - 1) originalParameters = args.pop();
			}


			return function(players, parameters = {}) {

				// If combining parameters, merge and remove from arguments
				if (combineParameters && originalParameters) parameters = Object.assign({}, originalParameters,
					parameters)

				return generate(players, ...args, parameters)
			}
		}

		// Allow for game description feature
		generate.description = function() {
			return gameDescription;
		};

		// Display any queries
		generate.queries = function() {
			return queries;
		}

		return generate;
	}


}

module.exports = stockGames;

},{"../engine":6,"./general":7,"./state":12,"esprima":54}],14:[function(require,module,exports){
"use strict";

// Strategies
var { Strategies } = require("../strategy");

// Players
var { Player } = require("../player");

module.exports = {
	// Create a player for each available strategy
	generatePopulation() {
		var players = [];

		Strategies().forEach(function(strategy) {
			players.push(Player({ assign: strategy }));
		});

		return players;
	}
};

},{"../player":35,"../strategy":45}],15:[function(require,module,exports){
"use strict";

var { SynchronousPromise } = require('synchronous-promise');

var turn = {

	//Recurse through the options in input, and write val to output.
	recurse: function recurse(input, output, val, valGenerator = function() {}, path = []) {


		//Since we slice the array each time, if there are no more entries left then we're done with this branch.
		if (input.length == 0) return path


		//Among all values from the array
		return input[0].map(function(item) {
			var value;
			var splitPath = path.slice(0).concat(item);

			//If there are more items to iterate over, include them in the output then recurse.
			//If not, put in the new value.
			if (input.length == 1) {

				//If val is a function, wrap it in a function that will get supplied an argument with where we are
				if (typeof val == "function") {
					value = function() {
						var args = [splitPath].concat(Array.prototype.slice.call(arguments));
						return val.apply(null, args);
					};
				} else value = val || valGenerator(splitPath);

				output[item] = value;
			} else output[item] = {};


			return recurse(input.slice(1), output[item], val, valGenerator, splitPath);
		});
	}
};


module.exports = turn;

},{"synchronous-promise":66}],16:[function(require,module,exports){
"use strict";

var { evaluateQuery } = require("./query")

var { registry } = require("./state")

var { isObject, isFunction } = require("./helper-functions")("general");

//Extension of array to handle history lists.
function History(...args) {
	if (Array.isArray(args[0])) args = args[0];

	Object.setPrototypeOf(args, History.prototype);

	args.log = args.slice();
	args.log.tree = args;
	Object.setPrototypeOf(args.log, History.prototype);

	args.scores = [];
	args.scores.tree = args;
	Object.setPrototypeOf(args.scores, History.prototype);

	return args;
}

History.prototype = Object.create(Array.prototype);
History.prototype.constructor = History;

//To add entry
History.prototype.add = function(entry) {
	//Add to history and to log
	this.push(entry);
	if (this.log) this.log.push(entry);

	//Cycle up the parent tree, add to each log
	var check = this;
	if (check.tree instanceof History && check.tree.parent instanceof History) {
		check.tree.parent.log.add(entry);
	}
	if (check.parent instanceof History) {
		check.parent.log.add(entry);
	}

	//If we're being called fr

	return this;
};

//To add entry without logging (for playables that would like the tree history
//to be structured differently than the log history.
History.prototype.addNoLog = function(entry) {
	this.push(entry);
	return this;
};


History.prototype.addScores = function(entry) {
	//Add to history
	this.scores.push(entry);

	//Cycle up the parent tree, add to each log
	var check = this;
	if (check.parent instanceof History) {
		check.parent.addScores(entry);
	}



	return this;
};


//A temporary History that can be merged back in later. The child and parent are linked until .orphan() is called.
History.prototype.child = function(parent = this) {
	var h = new History();
	h.parent = parent;
	return h;
};

//Same as .child except includes prior parent history when .print() is called.
History.prototype.childWithContent = function(parent = this) {
	var storedLog = parent.slice();
	var storedScores = parent.slice();

	var h = new History();


	h.log.print = function() {
		History.prototype.print.call(storedLog.concat(h.log))
	}
	h.scores.print = function() {
		History.prototype.print.call(storedScores.concat(h.scores))
	}

	h.parent = parent;
	return h;
};

//This severs the link between the temporary history and its parent. Use this when merging composite entries.
History.prototype.orphan = function() {
	delete this.parent;
	delete this.log;
	delete this.scores;
	return this;
};

//Clear history
History.prototype.clearHistory = function() {
	this.splice(0, this.length);
	if (this.log) this.log.splice(0, this.log.length);
	if (this.scores) this.scores.splice(0, this.scores.length);
	delete this.parent;
};

//End the game.
History.prototype.end = function() {
	this.stop = true;
	if (this.parent) this.parent.end();
};

//Get a particular sort of entry, eg. Turn.
History.prototype.getType = function(type) {
	return new History(
		this.filter(function(entry) {
			//If it's not an object, don't even bother.
			if (!isObject(entry)) return false;

			for (var key in entry) {
				if (key == type) return true;
			}

			return false;
		})
	);
};

History.prototype.mostRecent = function() {
	return this[this.length - 1]
}

//Help read the history in Chrome with less clutter.
History.prototype.print = function() {
	var history = JSON.parse(JSON.stringify(this));
	history.query = History.prototype.query
	return history;
};

History.prototype.query = function(queryString, ...args) {
	return evaluateQuery(queryString, this, ...args)
}

//Supply an entry, it will check for a property that is a History
History.prototype.recurse = function(type) {
	var list = this;

	return new History(
		list.map(function(entry) {
			for (var key in entry) {
				console.log(key, entry);
				if (entry[key] instanceof History) return entry[key].recurse(type);
				else if (key == type) return entry;
			}
			return null;
		})
	);
};

//Accept a History and return one suitable for the user
function UserHistory(history) {
	var userHistory = history.map(function(entry) {
		return JSON.parse(JSON.stringify(entry));
	});
	if (history.log) {
		userHistory.log = new UserHistory(history.log)
	};
	if (history.scores) {
		userHistory.scores = new UserHistory(history.scores)
	}

	Object.setPrototypeOf(userHistory, UserHistory.prototype);

	//Attach methods from History, wrapped in a function. If those methods return a history,
	//then the function will convert that to a userHistory.
	for (var method in History.prototype) {
		if (isFunction(history[method])) {
			if (method != "constructor")
				userHistory[method] = (function(method) {
					return function() {
						var result = history[method].apply(history, arguments);
						if (result instanceof History) return new UserHistory(result);
						else if (isObject(result))
							return JSON.parse(JSON.stringify(result));
						else return result;
					};
				})(method);
		}
	}

	return userHistory;
}

UserHistory.prototype = Object.create(History.prototype);
UserHistory.prototype.constructor = UserHistory;

var gameHistory = new History(); //TODO: add choice-only history

var userGameHistory = function() {
	return new UserHistory(gameHistory)
}

module.exports = { History, UserHistory, gameHistory, userGameHistory };

},{"./helper-functions":8,"./query":42,"./state":43}],17:[function(require,module,exports){
"use strict";

//When a strategy's .choose() function is called, it is given an information set. That data is a limited map of the internal objects of the game engine, including information on the game history and the players. This is threaded through playables, much like History, so that a parent playable can specify an information set for the playables it calls, or else the default construction will be used. Additionally, the user can provide a filter function, to selectively delete (or add) information elements before they are passed to .choose().

//History functions
var { gameHistory, History } = require('./history');

//Population functions
var { gamePopulation, PlayerList } = require('./population');


function Information(history = gameHistory, population = gamePopulation, { parentHistory = [] } = {}) {
	this.history = history;
	this.population = population;

	// Record any history entries that need to be added to the records
	this.parentHistory = parentHistory.slice(0);

	this.additional = [];

	this.update();
};

//Check the source then cache a hard-copy.
Information.prototype.update = function(player, local) {
	this.infoPopulation = this.population().info();

	this.infoHistory = {
		log: this.parentHistory.concat(this.history.log),
		scores: this.history.scores
			.slice(0)
	};

	this.additional = [];

	//Return value. Mimics .deliver()
	var information = {
		history: { log: this.infoHistory.log, scores: this.infoHistory.scores },
		population: this
			.infoPopulation
	}
	if (player) information.me = information.population.get(player.id);
	if (local) Object.assign(information, local);

	return information;
};

//Clone the cached copies and provide them. Will deliver the same thing every time until update is called.
Information.prototype.deliver = function(player, local) {
	var information = {
		history: { log: this.infoHistory.log, scores: this.infoHistory.scores },
		population: this
			.infoPopulation
	}


	if (player) information.me = information.population.get(player.id);
	if (local) Object.assign(information, local);
	if (this.additional) this.additional.forEach(function(entry) { Object.assign(information, entry) });

	return JSON.parse(JSON.stringify(information));
};

//This probably doesn't need to be a separate function, but adding it in case it expands later.
Information.prototype.addAdditional = function(entry = null) {
	if (entry) this.additional.push(entry);
};

//Make copy of this information function, which allows for updating and freezing.
Information.prototype.child = function() {
	var information = new Information(this.history, this.population, { parentHistory: this.parentHistory });

	return information;
};



//Game state, analogous to gameHistory
var PerfectInformation = new Information(gameHistory, gamePopulation);

//Overwrite .deliver(). PerfectInformation is always up-to-date! Thus no need to do a 2nd JSON.stringify.
PerfectInformation.deliver = function(player, local) {

	var information = this.update(player, local);

	if (player) information.me = information.population.get(player.id);
	if (local) Object.assign(information, local);

	return information;
};


module.exports = { Information, PerfectInformation };

},{"./history":16,"./population":41}],18:[function(require,module,exports){
"use strict";


var logger = function() {
	var args = [...arguments];
	var level = (args[0] == "silly" || !args[0]) ? "trace" : args[0];
	var level = level == "warning" ? "warn" : level;
	args.shift();

	logger.logger[level].apply(logger.logger, args);
};

//logger.logger = console;					//TODO clean this all up a lot.

var getLogger = require("loglevel-colored-level-prefix");
var options = { prefix: 'nashJS', level: 'trace' }
logger.logger = getLogger(options)

logger.setLevel = function(level) {
	logger.logger.level = level;
	logger.logger.setLevel(level)
};

/*
logger.useWinston = function(){

	var winston = require('winston');
	var util = require('util');

	winston.level = "warn";

	winston.clear()
	winston.add(winston.transports.Console, {
		level: 'trace',
		prettyPrint:  function ( object ){
			return util.inspect(object);
		},
		colorize: true,
		silent: false,
		timestamp: false
	});

	this.logger = winston;
};
*/

module.exports = logger;

},{"loglevel-colored-level-prefix":60}],19:[function(require,module,exports){
"use strict";

var log = require("./logger");

//Helper functions
var { isFunction } = require("./helper-functions")("general");

// Extend function, the sneaky way.
var variablePrototype = Object.create(Function.prototype);

variablePrototype.constructor = function(value, { enforceNumber = true } = {}) {
	var variable = this;
	variable.value = enforceNumber ? value * 1 : value;
	variable.enforceNumber = enforceNumber

	this.id = function() {
		return _playable.id;
	}; //TODO: work on ids and registration
};

variablePrototype.call = function() {
	return this.value;
};

variablePrototype.toJSON = function() {
	return this.call();
};
variablePrototype.toString = function() {
	return this.call();
};
variablePrototype.valueOf = function() {
	return this.call();
};

variablePrototype.set = function(newValue) {
	this.value = this.enforceNumber ? newValue * 1 : newValue
	return this.value;
};

//Repurpose the very-similar code for Variable, but re-write certain keys
var expressionPrototype = Object.create(Function.prototype);

expressionPrototype.constructor = function(expression) {
	if (!isFunction(expression)) log("error", "Expression must be a function.");

	var value = expression();
	if (isNaN(value)) log("error", "Expression must return a number"); //TODO: should Expressions/Variables allow strings?

	this.value = expression;

	return value;
};

expressionPrototype.call = function() {
	return this.value() * 1;
};

expressionPrototype.toJSON = function() {
	return this.call();
};
expressionPrototype.toString = function() {
	return this.call();
};
expressionPrototype.valueOf = function() {
	return this.call();
};

expressionPrototype.set = function(newExpression) {
	if (!isFunction(newExpression))
		log("error", "Expression must be a function.");

	var value = newExpression();
	this.value = newExpression;

	return value;
};

//Produces the function that will produce the end result. This part is reusable if you need to do this again.
var classFactory = function(proto) {
	return function() {
		var f = function() {
			return f.call.apply(f, arguments);
		};

		Object.defineProperty(f, "constructor", {
			configurable: true,
			writable: true
		});
		Object.defineProperty(f, "call", {
			writable: true
		});
		Object.defineProperty(f, "toString", {
			writable: true
		});
		Object.defineProperty(f, "valueOf", {
			writable: true
		});

		Object.keys(proto).forEach(function(key) {
			f[key] = proto[key];
		});

		f.constructor.apply(f, arguments);

		return f;
	};
};

var Variable = classFactory(variablePrototype);
var Expression = classFactory(expressionPrototype);
// called as: var instance = Variable();

// A pre-built Expression generator, for generating random numbers
var RandomVariable = function({ lowerbound = 0, upperbound = 10, generator = "uniform" }) {

	if (isFunction(generator)) {
		var expression = Expression(generator);
		expression.generator = generator;
		return expression;

	} else if (generator.toLowerCase() == "uniform") {
		generator = function() {
			return Math.floor(Math.random() * (upperbound - lowerbound + 1) + lowerbound);
		};
		//	TODO: add more distributions here.
	}

	return Expression(generator);
};



// A way to have Variables which are more complicated things, like arrays or obects
var ComplexVariable = function(value) {
	var variable = Variable(value, { enforceNumber: false })

	var excludeList = ["set", "call", "toJSON", "toString", "valueOf"]

	var handler = {
		get(target, key) {
			var prop;
			if (excludeList.indexOf(key) > -1) prop = target[key].bind(target);
			else {
				prop = target.value[key]
				if (isFunction(prop)) prop = prop.bind(target.value)
			}

			return prop
		},
		set(target, key, prop) {
			target.value[key] = prop;
			return true;
		}
	}
	return new Proxy(variable, handler)
}




module.exports = {
	variablePrototype,
	Variable,
	expressionPrototype,
	Expression,
	RandomVariable,
	ComplexVariable
};

},{"./helper-functions":8,"./logger":18}],20:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Choice");

//Game state controllers
var { registry } = require("../state");
var Promise = registry.Promise; // For sync mode

var { gameHistory } = require("../history");
var { PerfectInformation } = require("../information");

//Helper functions
var { idHandler } = require("../helper-functions")("state");
var { isFunction } = require("../helper-functions")("general");
var { chainerGenerator } = require("../helper-functions")("playable");

//Parent class
var { Branch, _Playable, Playable } = require("./playable");


// Branch subclass
var ChoiceBranch = (function() {
	// Private data
	var _choices = new WeakMap();

	class ChoiceBranch extends Branch {
		constructor(path, _choice) {
			super(path, _choice.interface)
			_choices.set(this, _choice)
		}

		// The __call__ function, this will set the payoff of the branch
		payoff(payoff) {
			var _choice = _choices.get(this)
			if (!isNaN(payoff)) _choice.payoffs[this.path[0]] = payoff;
			else throw new Error("Choice payoff must be a number.")
			return super.payoff()
		}
	}
	return ChoiceBranch;
})()



// Hidden class for Choice playable
class _Choice extends _Playable {
	constructor(id, player, options, parameters = {}) {
		super(id, parameters)

		this.player = registry.players[player];
		this.options = options;
		this.defaultOption = parameters.defaultOption || options[0]; //TODO: make defaultOption functional
		this.playerMethod = parameters.playerMethod || "choose"
		this.informationFilter = parameters.informationFilter || null;
		this.usePayoffs = parameters.usePayoffs || false;
		this.zeroPayoffs() //Create payoffs anyway in case we use them later

		this.next = {};

		var choice = this;
		this.options.forEach(function(item) {
			choice.next[item] = [];
		});
	}


	play({
		usePayoffs = this.usePayoffs,
		history = gameHistory,
		information: rawInformation = PerfectInformation,
		releasePlayer = true,
		informationFilter = this.informationFilter,
		_compileInformation = null
	} = {}) {
		var choice = this;

		if (!choice.player.alive)
			return Promise.reject({
				result: choice.id + ": Player " + choice.player.id + " is dead."
			});

		//While this choice is happening, don't allow other choices to use this player.
		choice.player.available = false;

		//Information mechanics. If we're dealing with PerfectInformation, this won't get delivered, so we'll include it in the call to .deliver(). If we're using an information supplied from some other playable, then they can do what they like with it.
		var choiceInfo = {
			choice: {
				id: choice.id,
				player: choice.player.id,
				options: choice.options
			}
		};
		rawInformation.addAdditional(choiceInfo);
		//Perform some data processing if other playables need it.
		if (_compileInformation) _compileInformation(rawInformation);

		return Promise.resolve()
			.then(function() {
				//Prep information
				var information = rawInformation.deliver(choice.player, choiceInfo);
				if (informationFilter) information = informationFilter(information);

				return choice.player.choose(choice.options.slice(0), information, choice.playerMethod);
			})
			.then(function(result) {
				var player = choice.player;
				var id = choice.id;

				//Add to player's individual history;
				player.history.push({
					choice: id,
					options: choice.options,
					result
				});

				result = result || choice.defaultOption;

				var resultObject = {
					result,
					historyEntry: {
						choice: id,
						player: player.id,
						result
					}
				};

				//This will probably only happen if it's a single-player game, otherwise we'll use playoffs defined in a Turn
				if (usePayoffs) {
					var payout = choice.payoffs[result];

					player.score += payout;

					//track the payoff
					var scoreEntry = {
						choice: id,
						payouts: {
							[player.id]: payout
						}
					};
					history.addScores(scoreEntry);

					resultObject.historyEntry.payouts = {
						[player.id]: payout
					};
				}

				log(
					"silly",
					"_Choice.play: removing from occupiedPlayers: ",
					choice.player.id
				);
				if (releasePlayer) choice.releasePlayer();

				return Promise.resolve(resultObject);
			});
	};

	//Release player from excluded players list, so that other objects can use it.
	releasePlayer() {
		this.player.available = true;
	};

	findNext({ result } = {}) {
		return this.next[result.result];
	};

	generateBranches() {
		var _choice = this;
		var choice = _choice.interface

		_choice.options.forEach(function(option) {
			choice[option] = new ChoiceBranch([option], _choice)
		});
	};

	summaryThis(summary) {
		summary("player", this.player.id);
		summary("options", this.options.slice());
		// Include method, but only if it's not the default.
		if (this.playerMethod != "choose") summary("method", this.playerMethod)

		return summary;
	};

	//TODO: un-fuck this.
	summaryNext(summary) {
		// construct the tree in the summary based on available options
		var count = 0
		summary.treeArray("next", [this.options], this.next, function(playable, path, summary) {
			count++;
			return playable.summarize(summary)
		})

		// if there's no result, delete the tag to avoid clutter
		if (!count) summary.delete("next")

		return summary;
	};

	//Set all payoffs to zero.
	zeroPayoffs() {
		var choice = this;

		choice.payoffs = {};

		choice.options.forEach(function(option) {
			choice.payoffs[option] = 0;
		});
	};
}
_Choice.registryName = "decisions";
_Choice.counterName = "choice";


// Frontend class for Choice
class Choice extends Playable {
	constructor(player, options, parameters = {}) {
		var id = idHandler(parameters.id, "choice");

		//If informationFilter was supplied, it must be a function
		if (parameters.informationFilter && !isFunction(parameters.informationFilter))
			throw new Error("informationFilter must be a function");

		//Create backend choice object
		var _choice = new _Choice(id, player.id(), options, parameters);

		// Run Playable constructor
		super(_choice)

		_choice.generateBranches();
	}

	//User can set all payoffs at once using an array
	setAllPayoffs(payoffs) {
		if (!Array.isArray(payoffs)) throw new Error("Payoffs must be array")

		var id = this.id()
		var options = registry.decisions[id].options

		if (payoffs.length != options.length) throw new Error(
			"Payoffs must be same dimensions as choice options")

		payoffs.forEach(function(payoff, index) {
			registry.decisions[id].payoffs[options[index]] = payoff;
		})
	}

	// A way for the user to interact with the payoffs
	payoffs() {
		return JSON.parse(JSON.stringify(registry.decisions[this.id()].payoffs))
	}
}

module.exports = { ChoiceBranch, _Choice, Choice };

},{"../helper-functions":8,"../history":16,"../information":17,"../logger":18,"../state":43,"./playable":26}],21:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Consecutive");

//Game state controllers
var { registry } = require("../state");
var Promise = registry.Promise; // For sync mode
var { gameHistory } = require("../history");

//Helper functions
var { idHandler } = require("../helper-functions")("state");

//Information
var { Information, PerfectInformation } = require("../information");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Consecutive
function _Consecutive(id, playablesArray, parameters = {}) {
	_Playable.call(this, id, parameters);

	playablesArray = playablesArray.map(function(playable) {
		return registry.playables[playable.id()]
	})
	this.playablesArray = playablesArray
}
_Consecutive.prototype = Object.create(_Playable.prototype);
_Consecutive.prototype.constructor = _Consecutive;

_Consecutive.registryName = "consecutives";
_Consecutive.counterName = "consecutive";

_Consecutive.prototype.play = function({
	history = gameHistory,
	information = this.information ||
	PerfectInformation
} = {}) {

	var consecutive = this;

	//Log the history appropriately
	var startEntry = {
		consecutive: consecutive.id,
		action: "start"
	};
	history.log.add(startEntry);

	//History object to give to consecutived playables.
	var consecutiveHistory = history.child();

	//compartmentalize if set. "compartmentalize" means pass on information as if this playable is the entire game.
	if (consecutive.compartmentalize) {
		information = new Information(consecutive.compartmentalize.history || consecutiveHistory,
			consecutive.compartmentalize.population || information.population);
	}

	var action = function action(playablesArray) {
		//Stop if the game is over.
		if (history.stop) return { playable: consecutive };

		if (playablesArray.length > 0) {
			return playablesArray.shift().play({ shortCircuit: true, history: consecutiveHistory, information })
				.then(function(result) {
					return action(playablesArray) || result
				})
		} else return false
	}

	return action(consecutive.playablesArray.slice())
		.then(function(result) {
			result.historyEntry = {
				consecutive: consecutive.id,
				action: consecutiveHistory.orphan()
			};

			//TODO: add information mechanisms

			return Promise.resolve(result);
		});
};

//Overwrite history handler so that tree doesn't have "start" and "finish" entries.
_Consecutive.prototype.handleHistory = function({ history = gameHistory } = {},
	result
) {
	var consecutive = this;

	return Promise.resolve(result).then(function(result) {
		history.log.add({
			consecutive: consecutive.id,
			action: "finish",
			duration: result.historyEntry.duration
		});

		history.addNoLog(result.historyEntry);
		return Promise.resolve(result);
	});
};

//TODO: finish this!
_Consecutive.prototype.summaryThis = function(summary, entries, shortCircuit) {
	summary.action = {};

	this.playableStart.summarize(
		summary.action,
		entries,
		(shortCircuit = this.playableFinish)
	);
};

function Consecutive(playablesArray, parameters = {}) {
	var id = idHandler(parameters.id, "consecutive");

	//Create backend loop object
	var _consecutive = new _Consecutive(id, playablesArray, parameters);

	//Return this reference object to the user. Run the function to select a source
	var consecutive = Playable(_consecutive);

	consecutive.ids = function() {
		return playablesArray.map(function(playable) {
			return playable.id();
		})
	}

	return consecutive;
}

module.exports = { _Consecutive, Consecutive };

},{"../helper-functions":8,"../history":16,"../information":17,"../logger":18,"../state":43,"./playable":26}],22:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: HaltIf")

//Game state controllers
var { registry } = require('../state');
var Promise = registry.Promise; // For sync mode
var { gameHistory } = require('../history');

//Helper functions
var { isFunction } = require('../helper-functions')("general");
var { idHandler } = require('../helper-functions')("state");

//Parent class
var { _Playable, Playable } = require('./playable');



//Backend function class for Game
function _Halt(id, testCondition, { logContinue = false }) {
	_Playable.call(this, id);

	this.testCondition = testCondition;
	this.logContinue = logContinue;
}

_Halt.prototype = Object.create(_Playable.prototype);
_Halt.prototype.constructor = _Halt;

_Halt.registryName = "halts";
_Halt.counterName = "haltIf";

_Halt.prototype.play = function({ initializePlayers = false, shortCircuit = false, history = gameHistory } = {}) {

	var halt = this;

	var resultObject = {
		'playable': halt,
		'historyEntry': {
			'halt': halt.id
		}
	};


	var test = halt.testCondition();


	if (test) {
		log("info", "Halting at " + halt.id)

		resultObject.historyEntry.action = "halt";
		resultObject.result = "Halt";

		return Promise.reject(resultObject);
	}

	//Halt probably gets used for loops, and we might not want to see lots of continue messages, so "logContinue" will omit them.
	if (halt.logContinue) {
		resultObject.historyEntry.action = "continue";
	} else delete resultObject.historyEntry


	return Promise.resolve(resultObject)
};


_Halt.prototype.summaryThis = function(summary) {
	summary.condition = this.testCondition.toString();
}



function HaltIf(testCondition = function() {}, { id = null, logContinue = false } = {}) {
	var id = idHandler(id, "haltIf")

	if (!isFunction(testCondition)) log("warn", id +
		": testCondition should be a function, or else game will not halt.")

	//Create backend loop object
	var _halt = new _Halt(id, testCondition, { logContinue });


	//Return this reference object to the user. Run the function to select a source
	var halt = Playable(_halt);
	return halt;
}


module.exports = { _Halt, HaltIf };

},{"../helper-functions":8,"../history":16,"../logger":18,"../state":43,"./playable":26}],23:[function(require,module,exports){
"use strict";

//Loads the playables that will be used by Nash. This is basically the controller list: if it's not in these lists,
// then it won't be available for us.

var log = require("../logger");
log("debug", "Loading Playable Classes: ");

//External dependency
var present = require("present");

// Utility function
var { applyBind } = require("../helper-functions")("general");

// history controller
var { gameHistory } = require("../history")

//Playables
var { _Playable } = require("./playable");
var { _Choice, Choice } = require("./choice");
var { _Range, Range } = require("./range");
var { _Turn, Turn } = require("./turn");
var { _Sequence, Sequence } = require("./sequence");
var { _Consecutive, Consecutive } = require("./consecutive");
var { _Loop, Loop } = require("./loop");
var { _SLoop, StochasticLoop } = require("./stochasticLoop");
var { _Halt, HaltIf } = require("./halt-if");
var { _SHalt, StochasticHalt } = require("./stochastic-halt");
var { _Lambda, Lambda } = require("./lambda");
var { _RPChoice, RandomPlayerChoice } = require("./random-player-choice");
var { _PopulationDynamics, PopulationDynamics } = require("./population-dynamics");
var { _Simultaneous, Simultaneous } = require("./simultaneous");

//Runs when loading Playable classes.
function initializePlayableClass(playableClass) {

	//Replace the .play() method with a wrapper which calls it and a few other functions
	if (playableClass.prototype.hasOwnProperty("play")) {
		playableClass.prototype.play = (function(play) {
			return function(...args) {
				if (!args[0]) args[0] = {}
				var playable = this;

				// Set our history
				args[0].history ? null : args[0].history = this.history || gameHistory

				// how to halt the game without errors. TODO this is probably fucked
				if (args[0].history.stop) return { playable };


				return _Playable.prototype._startTimer
					.apply(playable, args)
					.then(applyBind(playable.checkInit, playable, args))
					.then(applyBind(playable.prePlay, playable, args))
					.then(applyBind(play, playable, args))
					.then(applyBind(playable.postPlay, playable, args))
					.then(applyBind(_Playable.prototype._stopTimer, playable, args))
					.then(applyBind(playable.handleHistory, playable, args))
					.then(applyBind(_Playable.prototype.proceed, playable, args));
			};
		})(playableClass.prototype.play);
	}
}

function initializePlayableInterface(playableInterface) {

	// create an initializer that doesn't have to use "new"
	playableInterface.creator = new Proxy(playableInterface, {
		apply: function(target, thisArg, argumentsList) {
			return new target(...argumentsList)
		}
	})


}

exports.playableClasses = {
	_Playable,
	_Choice,
	_Range,
	_Turn,
	_Sequence,
	_Consecutive,
	_Loop,
	_SLoop,
	_Halt,
	_SHalt,
	_Lambda,
	_RPChoice,
	_PopulationDynamics,
	_Simultaneous
};
exports.playableInterfaces = {
	Choice,
	Range,
	Turn,
	Sequence,
	Consecutive,
	Loop,
	StochasticLoop,
	HaltIf,
	StochasticHalt,
	Lambda,
	RandomPlayerChoice,
	PopulationDynamics,
	Simultaneous
};


for (var playableClass in exports.playableClasses) {
	if (playableClass != "_Playable") {
		initializePlayableClass(exports.playableClasses[playableClass]);
	}
}

for (var playableInterface in exports.playableInterfaces) {
	if (playableInterface != "Playable") {
		initializePlayableInterface(exports.playableInterfaces[playableInterface])
		exports.playableInterfaces[playableInterface] = exports.playableInterfaces[playableInterface].creator
	}
}

},{"../helper-functions":8,"../history":16,"../logger":18,"./choice":20,"./consecutive":21,"./halt-if":22,"./lambda":24,"./loop":25,"./playable":26,"./population-dynamics":27,"./random-player-choice":28,"./range":29,"./sequence":30,"./simultaneous":31,"./stochastic-halt":32,"./stochasticLoop":33,"./turn":34,"present":62}],24:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: Lambda")

//Game state controllers
var { registry } = require('../state');
var Promise = registry.Promise; // For sync mode
var { gameHistory } = require("../history");

// Information mechanics
var { PerfectInformation } = require("../information");

//Helper functions
var { isFunction } = require('../helper-functions')("general");
var { idHandler } = require('../helper-functions')("state");

//Parent class
var { _Playable, Playable } = require('./playable');



//Backend function class for Game
function _Lambda(id, action, parameters = {}) {
	_Playable.call(this, id);

	this.action = action;
}
_Lambda.prototype = Object.create(_Playable.prototype);
_Lambda.prototype.constructor = _Lambda

_Lambda.registryName = "lambdas";
_Lambda.counterName = "lambda";


_Lambda.prototype.play = function({
	initializePlayers = false,
	shortCircuit = false,
	history = gameHistory,
	information = PerfectInformation
} = {}) {

	var lambda = this;

	var result = lambda.action({ history, information })

	var resultObject = {
		result,
		'playable': lambda,
		historyEntry: {
			lambda: lambda.id,
			result
		}
	};

	return Promise.resolve(resultObject)
};

// Simple helper to just run synchronously whatever the Lambda is. Useful for debugging.
_Lambda.prototype.run = function() {
	return this.action();
}

_Lambda.prototype.summaryThis = function(summary) {
	summary.action = this.action.toString();
}


function Lambda(action = function() {}, parameters = {}) {
	var id = idHandler(parameters.id, "lambda")

	if (!isFunction(action)) log("warn", id + ": action should be a function.")

	//Create backend lambda object
	var _lambda = new _Lambda(id, action, parameters);


	//Return this reference object to the user. Run the function to select a source
	var lambda = Playable(_lambda);


	lambda.run = function() {
		return _lambda.run();
	}

	return lambda;
}


module.exports = { _Lambda, Lambda };

},{"../helper-functions":8,"../history":16,"../information":17,"../logger":18,"../state":43,"./playable":26}],25:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Loop");

//Game state controllers
var { registry } = require("../state");
var Promise = registry.Promise; // For sync mode
var { gameHistory, History } = require("../history");

//Helper functions
var { idHandler } = require("../helper-functions")("state");
var { chainerGenerator } = require("../helper-functions")("playable");

// Information mechanics
var { Information, PerfectInformation } = require("../information");
var { gamePopulation } = require("../population");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Loop

function _Loop(id, playable, count, parameters) {
	_Playable.call(this, id, parameters);

	var { logContinue = true, playableParameters = {} } = parameters;

	this.playable = registry.playables[playable.id()];
	this.logContinue = logContinue;
	this.playableParameters = playableParameters;

	this.count = count;
}
_Loop.prototype = Object.create(_Playable.prototype);
_Loop.prototype.constructor = _Loop;

_Loop.registryName = "loops";
_Loop.counterName = "loop";

_Loop.prototype.play = function({
	history = this.history || gameHistory,
	information = this.information || PerfectInformation,
	playableParameters = this.playableParameters
} = {}) {

	var loop = this;
	loop.counter = 0;

	// Split the history entry
	var loopHistory = history.child();

	// information mechanics.
	//compartmentalize If set
	if (loop.compartmentalize) {
		information = new Information(loop.compartmentalize.history || loopHistory,
			loop.compartmentalize.population || information.population);
	}
	// Pass along
	playableParameters.information = information


	var promise = Promise.resolve();

	var action = function(result) {
		//If the game has been ended early, don't continue.
		if (history.stop) return { playable: loop };

		loop.counter++;
		if (!result) result = {};

		//Deal with history
		history.log.add({
			loop: loop.id,
			loopTo: loop.playable.id,
			count: loop.counter
		});

		playableParameters.shortCircuit = true;
		playableParameters.history = loopHistory;

		return loop.playable.play(playableParameters).then(function(result) {
			//Re-format result, replace playable with Loop playable
			result.playable = loop;

			//TODO: add information mechanisms

			return Promise.resolve(result);
		});
	};

	//Repeat the playable loop.count times, by chaining promises.
	for (var i = 0; i < loop.count; i++) {
		promise = promise.then(action);
	}

	return promise.then(function(result) {
		result.historyEntry = {
			loop: loop.id,
			count: loop.counter,
			action: loopHistory.orphan()
		};
		return Promise.resolve(result);
	});
};

//Overwrite history handler to prevent "loop finished" entry from hitting the tree.
_Loop.prototype.handleHistory = function({
		history = this.history || gameHistory,
		information = this.information || PerfectInformation,
		logContinue = this.logContinue
	} = {},
	result
) {
	var loop = this;

	return Promise.resolve(result).then(function(result) {
		//Write final entry if logContinue is set to true
		if (logContinue) {
			history.log.add({
				loop: loop.id,
				loopTo: "Loop finished.",
				count: loop.counter
			});
		}

		history.addNoLog(result.historyEntry);

		return result;
	});
};

// Add detail/nesting to summary.
_Loop.prototype.summaryThis = function(summary, entries) {
	summary.count = this.count;

	summary.action = {};
	this.playable.summarize(summary.action, entries, true);
};

function Loop(playable, count = 1, parameters = {}) {
	var id = idHandler(parameters.id, "loop");

	//Create backend loop object
	var _loop = new _Loop(id, playable, count, parameters);

	//Return this reference object to the user. Run the function to select a source
	var loop = Playable(_loop);
	return loop;
}

module.exports = { _Loop, Loop };

},{"../helper-functions":8,"../history":16,"../information":17,"../logger":18,"../population":41,"../state":43,"./playable":26}],26:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Playable");

var { SynchronousPromise } = require("synchronous-promise");
var present = require("present");
var CallableInstance = require('callable-instance');

// Data structure for summaries
var { Summary } = require("../summary")


//Game state controllers
var { registry, idCounters } = require("../state");
var Promise = registry.Promise; // For sync mode
var { gameHistory, History } = require("../history");

//Helper functions
var { isFunction } = require("../helper-functions")("general");
var { outcomeTreeAddAll, outcomeTreeGetValue } = require("../helper-functions")("playable");
var { reinitializePlayers } = require("../helper-functions")("player");

//To return to user
var { Population, PlayerList } = require("../population");

// For better object preview summaries.
var beautify = require("json-beautify")


// branch class, for the user to interact with when tree-branching, to replace promises
// Extend this branch and add a payoff function for each case (Turn, Choice, etc)
// path is an ordered array of branches; playable is a user interface
var Branch = class Branch extends CallableInstance {
	constructor(path, playable) {
		super("payoff");
		this.path = path;
		this.playable = playable;
		return
	}

	toString() {
		return "Branch"
	}

	payoff(payoff) {
		return this;
	}
};


// Base class for system-side _Playables
class _Playable {
	constructor(id, parameters = {}) {
		this.id = id;
		this.next = []; // Default next-map is an array, but certain playables might use something else
		registry.playables[id] = this;
		if (this.constructor.registryName != "playables") registry[this.constructor.registryName][id] = this;
		idCounters.playable++;

		parameters.compartmentalize ? this.compartmentalize = parameters.compartmentalize : null;
		parameters.history ? (this.history = parameters.history) : null;
		parameters.information ? (this.information = parameters.information) : null;
		parameters.initializePlayers ? (this.initializePlayers = parameters.initializePlayers) : null;
	}

	//Called before .play() to start timing.
	_startTimer() {
		this._timer = present();
		return Promise.resolve();
	};


	//Add reference to next playable branch, to chain playables together.
	addNext(nextPlayable, path = "all") {
		if (path == "all") outcomeTreeAddAll(this.next, nextPlayable);
		else {
			outcomeTreeGetValue(this.next, path).push(nextPlayable);
		}
	};


	//Called before prePlay, initialize players if true.
	checkInit({ initializePlayers = this.initializePlayers } = {}, result) {
		// if we get something
		if (initializePlayers) {
			// if it's just true, then reinitialize everybody
			if (initializePlayers === true) return reinitializePlayers("all", result)

			// if it's a playerList, use that
			else if (initializePlayers instanceof PlayerList) return reinitializePlayers(initializePlayers)

			// if we get a function, then run the function and check that it's returning a playerList
			else if (isFunction(initializePlayers)) {
				var list = initializePlayers()
				if (list instanceof PlayerList) return reinitializePlayers(list, result);
			}

			// otherwise, convert it to a playerList and let PlayerList deal with it.
			else return reinitializePlayers(new PlayerList(initializePlayers), result);
		}

		// if we didn't get anything or got false, we're done here.
		else return Promise.resolve(result);
	};


	//Called before .play() but after _startTimer, overwriteable
	prePlay({} = {}, result) {
		return Promise.resolve(result);
	};

	// The main attraction. Each class should overwrite this.(And it will get wrapped anyway. This mostly exists for testing purposes)
	play({} = {}, result) {
		return Promise.resolve(result)
	}

	//Called after .play(), overwritable.
	postPlay({} = {}, result) {
		return Promise.resolve(result);
	};

	//Called after .postPlay() to stop timer and log.
	_stopTimer({} = {}, result) {
		if (result.historyEntry)
			result.historyEntry.duration = present() - this._timer;
		delete this._timer;

		return Promise.resolve(result);
	};

	//Called after timer stops, to write log. Overwiteable if playable has specific logging behavior.
	handleHistory({ history = gameHistory } = {},
		result
	) {
		return Promise.resolve(result).then(function(result) {
			if (result.historyEntry) history.add(result.historyEntry);
			return Promise.resolve(result);
		});
	};

	//Determine whether to play next, and if so, do.
	proceed({ shortCircuit } = {}, result) {
		var playable = this;

		return Promise.resolve(result).then(function(result) {
			//Replace reported playable with latest running playable (this is necessary for short-circuit logic)
			result.playable = playable;

			//Short-circuit logic allows higher-order playable to figure out what to do next.
			if (shortCircuit) return Promise.resolve(result);

			return playable.playNext(result);
		});
	};

	//Play next.
	playNext(result, parameters = {}) {
		var playable = this;

		return Promise.resolve(result).then(function(result) {
			//Find out where to go next
			var next = playable.findNext({ result });

			//If there's somewhere to go, then go.
			if (next[0] instanceof _Playable)
				return Promise.all(
					next.map(function(playable) {
						return playable.play(parameters);
					})
				);

			//Otherwise, we're done here
			return Promise.resolve(result);
		});
	};

	// Return the next playable in the sequence. Overwriteable for playables with more complicated branching.
	findNext() {
		return this.next;
	};


	// Summarize the game structure. Calls summaryThis and summaryNext, which are overwritable.
	summarize(
		summary = new Summary(),
		shortCircuit = false,
		maxEntries = 10
	) {
		// Start summary for this playable
		summary(this.constructor.counterName, this.id);

		// Track how many times we've been here before, to avoid circular recursion
		summary.entries[this.id] ? ++summary.entries[this.id] : (summary.entries[this.id] = 1);
		if (summary.entries[this.id] > maxEntries) shortCircuit = true;

		// Add summary
		summary = this.summaryThis(summary);

		// Proceed to next steps
		if (!shortCircuit || shortCircuit !== this)
			this.summaryNext(summary);

		return summary;
	};

	// Adds the summary information on this playable. Overwrite this in order to add specific information.
	summaryThis(summary = {}) {
		return summary;
	};

	// Adds summary information down the next-path. Overwite this for playables with more complex branching.
	summaryNext(summary = new Summary()) {
		// If there's a next-entry
		if (this.next.length > 0) {
			// Loop over each next-item, and summarize it.
			summary.array("next", this.next, function(playable, summary) {
				return playable.summarize(summary)
			})
		}

		return summary;
	};

}
_Playable.registryName = "playables";
_Playable.counterName = "playable";


// Base class for playable user-interfaces
let Playable = (function() {
	//  private data. Hide the internal _playable from the user access.
	let _playables = new WeakMap();

	class Playable extends CallableInstance {
		//override this on each class. return a new instance of the class, to avoid the 'new' keyword
		static creator(...args) {
			return new Playable(...args)
		}

		static toString() {
			return "Playable"
		}

		constructor(_playable) {
			super("chain")
			_playables.set(this, _playable); // this is private
			_playable.interface = this
		}
		chain(source) {
			var previousPlayable, path

			// Act according to source type
			if (source instanceof Playable) {
				previousPlayable = registry.playables[source.id()]

			} else if (source instanceof Branch) {
				previousPlayable = registry.playables[source.playable.id()]

			} else throw new Error("Can only chain playables.")

			path = source.path
			var _playable = _playables.get(this)

			log("debug", "Adding next playable to " + previousPlayable.id + ", node " + _playable.id);

			previousPlayable.addNext(_playable, path);

			return this;
		}

		id() {
			return _playables.get(this).id
		}

		play({
			initializePlayers = false,
			usePayoffs = true,
			shortCircuit = false,
			writeHistory = true,
			clearHistory = registry.Settings["clear-history-on-play"],
			releasePlayers = true
		} = {}) {

			var _playable = _playables.get(this)

			if (clearHistory) gameHistory.clearHistory();

			var history = writeHistory ?
				_playable.history || gameHistory :
				new History();

			var returnValue = Promise.resolve()
				.then(function(result) {
					return _playable.play({ initializePlayers, usePayoffs, shortCircuit, history, releasePlayers });
				})
				.catch(function(reason) {
					console.log(reason);

					//If the game was stopped by a Halt playable or everybody's dead, we'll end up here, and things are fine. Just log it.
					if (reason.result == "Halt") {
						gameHistory.add(reason.historyEntry);
						return Promise.resolve(reason.result);
					} else if (reason.result == "Population Collapse")
						return Promise.resolve(reason.result);
					else {
						history.log.add({ error: reason });
						return Promise.reject(reason);
					}
				})
				.then(function(result) {
					//Replace result, so that user can't get access to _playables

					return Promise.resolve({
						Population: Population(),
						gameHistory
					});
				});

			// SynchronousPromise reveals too much data. Gotta just return the results.
			if (registry.Promise.mode == "sync") return returnValue._data
			return returnValue
		}

		summarize() {
			return _playables.get(this).summarize().print()
		}

		toString() {

			// this function will edit the summaries.
			var replacer = function replacer(key, value) {
				// if set, shorten summaries
				if (registry.Settings["condense-next-summary-preview"] && key == "next") return "..."
				return value
			}

			return beautify(this.summarize(), replacer, 2, 60)
		}
	}
	// default branching (probably not strictly necessary.)
	Playable.prototype.path = "all";

	return Playable;
})();



module.exports = { Branch, _Playable, Playable };

},{"../helper-functions":8,"../history":16,"../logger":18,"../population":41,"../state":43,"../summary":46,"callable-instance":50,"json-beautify":58,"present":62,"synchronous-promise":66}],27:[function(require,module,exports){
"use strict";

var log = require('../logger');

//External dependency
var poisson = require('randgen').rpoisson;

//Game state controllers
var { registry } = require('../state');
var Promise = registry.Promise; // For sync mode
var { gameHistory } = require("../history");

//Helper functions
var { isFunction } = require('../helper-functions')("general");
var { idHandler } = require('../helper-functions')("state");

//Parent class
var { _Playable, Playable } = require('./playable');

//Player controllers
var { _Player, Player } = require('../player');
var { PlayerList, UserPlayerList, gamePopulation, Population } = require('../population');

//Update this each time .play is called, but leave it available to the whole scope so that
//growth and decay can access it
var population;

//Default growth function
var growthDefault = function growth(player, population, birthRate, selectiveMultiplier) {
	var score = player.score;
	var mean = population.scoresMean();
	var std = population.scoresStd();

	var Z = !(isNaN(std) || std == 0) ? (score - mean) / std : 0

	console.log(score, mean, std, Z);

	var rate = birthRate + selectiveMultiplier * Z;

	var generated = poisson(rate);
	log("silly", "growthDefault: generated random number " + generated.toString() + " using rate " + rate.toString());

	return generated;
}

//Default decay function
var decayDefault = function decay(player, population, deathRate, selectiveMultiplier) {
	var score = player.score;
	var mean = population.scoresMean();
	var std = population.scoresStd();

	console.log(score, mean, std);

	var Z = !(isNaN(std) || std == 0) ? (score - mean) / std : 0;

	console.log(Z)
	var rate = deathRate - selectiveMultiplier * Z;

	var generated = poisson(rate);
	log("silly", "decayDefault: generated random number " + generated.toString() + " using rate " + rate.toString());
	return generated;
}



//Backend function class for PopulationDynamics
function _PopulationDynamics(id, birthRate, deathRate, {
	growthFunction = growthDefault,
	decayFunction =
	decayDefault,
	selectiveMultiplier = .5,
	playerParameters = {}
} = {}) {
	_Playable.call(this, id);

	var pd = this;

	this.birthRate = birthRate;
	this.deathRate = deathRate;
	this.selectiveMultiplier = selectiveMultiplier;

	//Wrap the growth and decay functions, so that the user doesn't have to worry about calling this.birthRate or this.deathRate
	this.growth = function(player) {
		log("silly", "_pd.growth: Checking grow condition");
		return growthFunction(player, population, pd.birthRate, pd.selectiveMultiplier)
	};
	this.decay = function(player) {
		log("silly", "_pd.decay: Checking decay condition");
		return decayFunction(player, population, pd.deathRate, pd.selectiveMultiplier);
	};

	this.playerParameters = playerParameters;
}
_PopulationDynamics.prototype = Object.create(_Playable.prototype);
_PopulationDynamics.prototype.constructor = _PopulationDynamics;

_PopulationDynamics.registryName = "controllers";
_PopulationDynamics.counterName = "populationDynamics";


_PopulationDynamics.prototype.play = function({
	initializePlayers = false,
	shortCircuit = false,
	history =
	gameHistory
} = {}) {

	var pd = this;

	var births = 0;
	var deaths = 0;

	//Update population using whoever's alive currently
	population = gamePopulation().onlyAlive();


	//Kill cycle
	var killed = new PlayerList([]);
	population.forEach(function(player) {
		// If the decay function is returns truthy, kill.

		if (pd.decay(player)) {
			log("silly", "must kill...")
			player.kill();
			deaths++;
			killed.push(player);
			log("silly", "dead");
		}


	});

	//Update update again to prevent the recently deceased from reproducing
	population = gamePopulation().onlyAlive();

	if (population.length == 0) {
		//Everybody's dead. Let's wrap it up.
		var reason = { result: "Population Collapse", playable: pd };
		history.end();
		return Promise.resolve(reason);
	}

	//Birth cycle
	var born = new UserPlayerList([]);
	population.forEach(function(player) {
		//Birth whatever number is returned
		var numBirth = pd.growth(player)
		console.log(numBirth);
		for (var i = 1; i <= numBirth; i++) {
			log("silly", "Player " + player.id + " giving birth!");

			var playerParameters = Object.assign({}, {
				assign: player.strategy ? player.strategy._id : "",
				parent: player.id
			}, pd.playerParameters);

			born.push(Player(playerParameters));
		}
	});


	var result = { births, deaths };

	var resultObject = {
		result,
		'playable': pd,
		historyEntry: {
			populationDynamics: pd.id,
			result
		}
	};

	return Promise.resolve(resultObject);
};



function PopulationDynamics(birthRate = .05, deathRate = .05, parameters = {}) {
	var id = idHandler(parameters.id, "populationDynamics")

	if (parameters.growth && !isFunction(growth)) log("error", id + ": growth should be a function.");
	if (parameters.decay && !isFunction(decay)) log("error", id + ": decay should be a function.");

	//Create backend lambda object
	var _pd = new _PopulationDynamics(id, birthRate, deathRate, parameters);


	//Return this reference object to the user. Run the function to select a source
	var pd = Playable(_pd);
	return pd;
}


module.exports = { _PopulationDynamics, PopulationDynamics };

},{"../helper-functions":8,"../history":16,"../logger":18,"../player":35,"../population":41,"../state":43,"./playable":26,"randgen":63}],28:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: RandomPlayerChoice")

//Game state controllers
var { registry, gameHistory, occupiedPlayers } = require('../state');
var Promise = registry.Promise; // For sync mode

//Helper functions
var { idHandler } = require('../helper-functions')("state");
var { chainerGenerator } = require('../helper-functions')("playable");

//Parent class
var { _Playable, Playable } = require('./playable');
var { _Choice, Choice } = require('./choice');

//Population helpers
var { PlayerList } = require('../population');


//Backend function class for RPChoice
function _RPChoice(id, options, parameters = {}) {

	//If they specify players to draw from, use only that list. Otherwise, use whoever's around.
	this.includePlayers = parameters.includePlayers || "all";

	this.excludePlayers = parameters.excludePlayers ? new PlayerList(parameters.excludePlayers) : new PlayerList()

	this.generator = Math.random;

	var player = null;


	_Choice.call(this, id, player, options, parameters);
}

_RPChoice.prototype = Object.create(_Choice.prototype);
_RPChoice.prototype.constructor = _RPChoice;

_RPChoice.registryName = "choices";
_RPChoice.counterName = "randomPlayerChoice";



//Select the player to make the choice
_RPChoice.prototype.choosePlayer = function choosePlayer() {

	var rpChoice = this;

	return Promise.resolve().then(function() {

		//Find players to choose from
		var pool = new PlayerList(rpChoice.includePlayers).onlyAlive().onlyAvailable().exclude(rpChoice.excludePlayers)
		if (pool.length == 0) return Promise.reject("No available players.");

		log("silly", "rpChoice.choosePlayer: choosing froom pool: " + pool.ids());

		var randomNumber = Math.floor(rpChoice.generator() * pool.length);
		var candidate = pool[randomNumber];


		log("silly", "rpChoice.choosePlayer: selecting player ", candidate.id)

		rpChoice.player = candidate;
		candidate.available = false;

		return Promise.resolve(candidate.id);
	});
};

_RPChoice.prototype.prePlay = function() {
	return this.choosePlayer();
};


_RPChoice.prototype.summaryThis = function(summary) {
	summary.options = this.options;
};



function RandomPlayerChoice(options, parameters = {}) {
	var { id = null, excludePlayers = [], playerList = null } = parameters

	var id = idHandler(id, "randomPlayerChoice")

	//Create backend choice object
	var _rpChoice = new _RPChoice(id, options, parameters);

	//Return this reference object to the user. Run the function to select a source
	var rpChoice = Playable(_rpChoice)

	rpChoice.playerList = function(playerList) {
		if (Array.isArray(playerList)) _rpChoice.playerList = playerList;
		return _rpChoice.playerList
	};

	rpChoice.excludePlayers = function(excludePlayers) {
		if (Array.isArray(excludePlayers)) {
			_rpChoice.excludePlayers = [];

			excludePlayers.forEach(function(player) {
				_rpChoice.excludePlayers.push(player.id());
			});

		}
		return _rpChoice.excludePlayers
	};

	//Interface to specify single-player payoffs in single-player/single-choice games
	_rpChoice.zeroPayoffs();

	_rpChoice.generateChainingFunctions(rpChoice);

	//Function to set all payoffs at once
	rpChoice.setAllPayoffs = function(payoffs) {
		//TODO: make this work. Include error handling if array given isn't expected dimensions.
	};


	//Way for user to interact with payoffs
	rpChoice.payoffs = function() { return registry.decisions[id].payoffs; };

	return rpChoice;
}



module.exports = { _RPChoice, RandomPlayerChoice };

},{"../helper-functions":8,"../logger":18,"../population":41,"../state":43,"./choice":20,"./playable":26}],29:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Range");

// External base class
var CallableInstance = require("callable-instance")

//Game state controllers
var { registry } = require("../state");
var Promise = registry.Promise; // For sync mode
var { gameHistory } = require("../history");
var { PerfectInformation } = require("../information");

//Helper functions
var { idHandler } = require("../helper-functions")("state");
var { isFunction } = require("../helper-functions")("general");
var { chainerGenerator } = require("../helper-functions")("playable");

//base Classes
var { Branch, _Playable, Playable } = require("./playable")

// Class to hold user-defined evaluator functions, mostly for speedy type comparisons
class Evaluator extends CallableInstance {
	constructor(func, parameters = {}) {
		super("test")
		this.func = func
		this.id = parameters.id || func.name || "evaluator"
		var evaluator = this;
		this.toString = function() { return evaluator.id }
	}
	test(value) {
		return this.func(value)
	}
}


// Branch subclass
var RangeOutcome = (function() {
	// Private data
	var _ranges = new WeakMap();

	class RangeOutcome extends Branch {
		constructor(evaluator, _range) {
			super(evaluator, _range.interface)
			_ranges.set(this, _range)

			_range.next.set(evaluator, []) // add blank nextmap once the branch is defined
		}

		// The __call__ function, this will set the payoff of the branch
		payoff(payoff) {
			var _range = _ranges.get(this)
			if (!isNaN(payoff)) _range.payoffs.set(this.path, payoff);
			return super.payoff()
		}
	}

	return RangeOutcome;
})()


class _Range extends _Playable {
	constructor(id, player, bounds, parameters = {}) {
		super(id, parameters)

		this.player = registry.players[player];
		this.bounds = bounds;
		this.defaultOption = parameters.defaultOption || bounds[0];
		this.playerMethod = parameters.playerMethod || "range"
		this.informationFilter = parameters.informationFilter || null;
		this.usePayoffs = parameters.usePayoffs || false;

		this.next = new Map([
			["all", []]
		]) // all is for any-outcome cases
		this.payoffs = new Map()
	}

	addNext(nextPlayable, path = "all") {
		if (path == "all") this.next.get("all").push(nextPlayable)
		else if (this.next.has(path)) this.next.get(path).push(nextPlayable)
		else throw new Error("Invalid path: ".concat(path))
	}

	findNext({ result } = {}) {
		// return the "any outcome" cases
		var next = this.next.get("all").slice()

		// For each evaluator, run it with the result, and if true, add those playables to the list
		for (var [evaluator, playables] of this.next) {
			if (evaluator !== "all" && evaluator(result.result) === true) next.push(...playables)
		}
		return next
	}

	play({
		usePayoffs = this.usePayoffs,
		history = gameHistory,
		information: rawInformation = PerfectInformation,
		releasePlayer = true,
		informationFilter = this.informationFilter,
		_compileInformation = null
	} = {}) {
		var range = this;

		if (!range.player.alive)
			return Promise.reject({
				result: range.id + ": Player " + range.player.id + " is dead."
			});

		//While this range is happening, don't allow other choices to use this player.
		range.player.available = false;

		//Information mechanics. If we're dealing with PerfectInformation, this won't get delivered, so we'll include it in the call to .deliver(). If we're using an information supplied from some other playable, then they can do what they like with it.
		var rangeInfo = {
			range: {
				id: range.id,
				player: range.player.id,
				bounds: range.bounds
			}
		};
		rawInformation.addAdditional(rangeInfo);
		//Perform some data processing if other playables need it.
		if (_compileInformation) _compileInformation(rawInformation);

		return Promise.resolve()
			.then(function() {
				//Prep information
				var information = rawInformation.deliver(range.player, rangeInfo);
				if (informationFilter) information = informationFilter(information);

				return range.player.choose(range.bounds.slice(0), information, range.playerMethod);
			})
			.then(function(result) {
				var player = range.player;
				var id = range.id;

				//Add to player's individual history;
				player.history.push({
					range: id,
					bounds: range.bounds,
					result
				});

				result = result || range.defaultOption;

				// Enforce some rules on responses
				var bounds = range.bounds
				if (result < bounds[0]) result = bounds[0]
				if (result > bounds[1]) result = bounds[1]
				// If we have an increment (bounds[2]) round to the nearest increment
				if (range.bounds[2]) {
					result = Math.round(result / range.bounds[2]) * range.bounds[2]
				}

				var resultObject = {
					result,
					historyEntry: {
						range: id,
						player: player.id,
						result
					}
				};


				//This will probably only happen if it's a single-player game, otherwise we'll use playoffs defined in a Turn
				if (usePayoffs) {
					var payout = 0;
					for (var [evaluator, payoff] of range.payoffs.entries()) {
						if (evaluator == "all") payout += payoff
						else if (evaluator(result)) payout += payoff
					}

					player.score += payout;

					//track the payoff
					var scoreEntry = {
						range: id,
						payouts: {
							[player.id]: payout
						}
					};
					history.addScores(scoreEntry);

					resultObject.historyEntry.payouts = {
						[player.id]: payout
					};
				}

				log(
					"silly",
					"_Choice.play: removing from occupiedPlayers: ",
					range.player.id
				);
				if (releasePlayer) range.releasePlayer();

				return Promise.resolve(resultObject); //TODO: add information mechanisms
			});
	}

	//Release player from excluded players list, so that other objects can use it.
	releasePlayer() {
		this.player.available = true;
	};


	summaryThis(summary) {
		summary("player", this.player.id);
		summary("bounds", this.bounds.slice());

		return summary;
	};


	summaryNext(summary) {
		// construct the tree in the summary based on available bounds
		summary.mapArray("next", this.next, function(playable, summary) {
			return playable.summarize(summary)
		})

		// if there's no result, delete the tag to avoid clutter
		if (summary("next") === undefined) summary.delete("next")

		return summary;
	};

}
_Range.registryName = "decisions";
_Range.counterName = "range";


// User object for Range.
class Range extends Playable {
	constructor(player, bounds, parameters = {}) {
		var id = idHandler(parameters.id, "range");

		//If informationFilter was supplied, it must be a function
		if (parameters.informationFilter && !isFunction(parameters.informationFilter))
			throw new Error("informationFilter must be a function");

		//Create backend range object
		var _range = new _Range(id, player.id(), bounds, parameters);

		// Run Playable constructor
		super(_range)
	}

	// User can supply a function to evaluate what to do next
	outcome(func, parameters) {
		var evaluator = new Evaluator(func, parameters)
		return new RangeOutcome(evaluator, registry.decisions[this.id()])
	}

	// Function to see the results of a particular result
	payoff() {
		var range = this;
		return function(result) {
			var _range = registry.decisions[range.id()]

			var payout = 0;
			for (var [evaluator, payoff] of _range.payoffs.entries()) {
				if (evaluator == "all") payout += payoff
				else if (evaluator(result)) payout += payoff
			}
			return payout
		}
	}
}



module.exports = { Evaluator, RangeOutcome, _Range, Range }

},{"../helper-functions":8,"../history":16,"../information":17,"../logger":18,"../state":43,"./playable":26,"callable-instance":50}],30:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Sequence");

//Game state controllers
var { registry } = require("../state");
var Promise = registry.Promise; // For sync mode
var { gameHistory } = require("../history");

//Helper functions
var { idHandler } = require("../helper-functions")("state");

//Information
var { Information, PerfectInformation } = require("../information");

//Parent class
var { _Playable, Playable } = require("./playable");

//Backend function class for Sequence
function _Sequence(id, playableStart, playableFinish, parameters = {}) {
	_Playable.call(this, id, parameters);

	this.playableStart = registry.playables[playableStart.id()];
	this.playableFinish = registry.playables[playableFinish.id()];
}
_Sequence.prototype = Object.create(_Playable.prototype);
_Sequence.prototype.constructor = _Sequence;

_Sequence.registryName = "sequences";
_Sequence.counterName = "sequence";

_Sequence.prototype.play = function({
	history = gameHistory,
	information = this.information ||
	PerfectInformation
} = {}) {

	var sequence = this;

	//Log the history appropriately
	var startEntry = {
		sequence: sequence.id,
		action: "start"
	};
	history.log.add(startEntry);

	//History object to give to sequenced playables.
	var sequenceHistory = history.child();

	//compartmentalize if set. "compartmentalize" means pass on information as if this playable is the entire game.
	if (sequence.compartmentalize) {
		information = new Information(sequence.compartmentalize.history || sequenceHistory,
			sequence.compartmentalize.population || information.population);
	}

	// Recursion down the chain of playables
	var action = function action(result) {
		//Stop if the game is over.
		if (history.stop) return { playable: sequence };

		//Otherwise, recurse to figure out what to do next.
		if (Array.isArray(result)) {
			log("silly", "sequence.play: Next-item is an array, splitting into pieces.");

			return Promise.all(
				result.map(function(item) {
					log("silly", "sequence.play: recursing on", item);
					return action(item);
				})
			);
		}

		if (result.playable !== sequence.playableFinish) {
			log("silly", result);

			if (result.playable.findNext({ result }).length > 0) {
				log("silly", "Playable has next-item, continuing down chain.");

				return result.playable.playNext(result, { shortCircuit: true, history: sequenceHistory, information })
					.then(action); //Repeat for next playable in chain
			}
			return Promise.resolve(result);
		}
		return Promise.resolve(result);
	};

	return sequence.playableStart
		.play({ shortCircuit: true, history: sequenceHistory, information })
		.then(action)
		.then(function(result) {
			result.historyEntry = {
				sequence: sequence.id,
				action: sequenceHistory.orphan()
			};

			//TODO: add information mechanisms

			return Promise.resolve(result);
		});
};

//Overwrite history handler so that tree doesn't have "start" and "finish" entries.
_Sequence.prototype.handleHistory = function({ history = gameHistory } = {},
	result
) {
	var sequence = this;

	return Promise.resolve(result).then(function(result) {
		history.log.add({
			sequence: sequence.id,
			action: "finish",
			duration: result.historyEntry.duration
		});

		history.addNoLog(result.historyEntry);
		return Promise.resolve(result);
	});
};

//TODO: finish this!
_Sequence.prototype.summaryThis = function(summary, entries, shortCircuit) {
	summary.action = {};

	this.playableStart.summarize(
		summary.action,
		entries,
		(shortCircuit = this.playableFinish)
	);
};

function Sequence(playableStart, playableFinish, parameters = {}) {
	var id = idHandler(parameters.id, "sequence");

	//Create backend loop object
	var _sequence = new _Sequence(id, playableStart, playableFinish, parameters);

	//Return this reference object to the user. Run the function to select a source
	var sequence = Playable(_sequence);
	return sequence;
}

module.exports = { _Sequence, Sequence };

},{"../helper-functions":8,"../history":16,"../information":17,"../logger":18,"../state":43,"./playable":26}],31:[function(require,module,exports){
"use strict";

var log = require('../logger');

//Helper functions
var { isObject } = require('../helper-functions')("general");
var { idHandler } = require('../helper-functions')("state");

//Game state controllers
var { registry } = require('../state');
var Promise = registry.Promise; // For sync mode

//Parent class
var { _Playable, Playable } = require('./playable');

// Information mechanics
var { Information, PerfectInformation } = require('../information');


//Backend class
function _Simultaneous(id, playableArray, { playableParameters = {} } = {}) {
	_Playable.call(this, id);

	this.playableArray = playableArray;
	this.playableParameters = playableParameters;
}

_Simultaneous.prototype = Object.create(_Playable.prototype);
_Simultaneous.prototype.constructor = _Simultaneous;

_Simultaneous.registryName = "controllers";
_Simultaneous.counterName = "simultaneous";


//Simultaneous Promise.all's the playables, which causes them to run meshed.
_Simultaneous.prototype.play = function({ history = gameHistory, information = PerfectInformation } = {}) {

	var simultaneous = this;

	// Deal with history. Log start, then split history for children playables to fill in.
	history.log.add({
		simultaneous: simultaneous.id,
		action: "Simultaneous start."
	});
	var simultaneousHistory = []



	//TODO: is information mechanics correct?

	return Promise.all(simultaneous.playableArray.map(function(playable) {

		var branchHistory = history.child();
		simultaneousHistory.push(branchHistory)

		// Information mechanics
		var infoPopulation, parentHistory, infoHistory = branchHistory;
		//compartmentalize if set. "compartmentalize" means pass on information as if this playable is the entire game.
		if (simultaneous.compartmentalize) {
			infoPopulation = simultaneous.compartmentalize.population || information.population;
			parentHistory = simultaneous.compartmentalize.history || information.history;
		} else {
			infoPopulation = information.population;
			parentHistory = information.history
		}
		var simultaneousInformation = new Information(infoHistory, infoPopulation, { parentHistory });



		return playable.play({ history: branchHistory, information: simultaneousInformation });
	})).then(function(resultArray) {

		var resultObject = {
			resultArray,
			playable: simultaneous,
			historyEntry: {
				simultaneous: simultaneous.id,
				action: simultaneousHistory.map(function(history) {
					return history.orphan();
				})
			}
		};
		return resultObject;
	});
};


_Simultaneous.prototype.handleHistory = function({ history = gameHistory } = {}, result) {

	history.log.add({
		simultaneous: this.id,
		action: "Simultaneous complete."
	});

	history.addNoLog(result.historyEntry);

	return Promise.resolve(result);
};

_Simultaneous.prototype.summaryThis = function(summary, entries) {
	summary.action = [];

	this.playableArray.forEach(function(playable, index) {
		summary.action[index] = {}
		playable.summarize(summary.action[index], entries);
	});
}


//Frontend class
function Simultaneous(playableArray, parameters = {}) {
	var id = idHandler(parameters.id, "simultaneous")

	playableArray = playableArray.map(function(playable) {
		return registry.playables[playable.id()];
	});


	//Create backend instance.
	var _simultaneous = new _Simultaneous(id, playableArray, parameters);

	//Return this reference object to the user. Run the function to select a source
	var simultaneous = Playable(_simultaneous);
	return simultaneous;
}


module.exports = { _Simultaneous, Simultaneous };

},{"../helper-functions":8,"../information":17,"../logger":18,"../state":43,"./playable":26}],32:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: Stochastic-Halt")

//Game state controllers
var { registry, gameHistory } = require('../state');
var Promise = registry.Promise; // For sync mode

//Helper functions
var { isFunction } = require('../helper-functions')("general");
var { idHandler } = require('../helper-functions')("state");

//Parent class
var { _Playable, Playable } = require('./playable');
var { _Halt, Halt } = require('./halt-if');


//Backend function class for SHalt
function _SHalt(id, probability, parameters) {
	_Halt.call(this, id, null, parameters);

	var sHalt = this;

	this.probability = probability;
	this.generator = Math.random; //TODO: allow user to specify random number generator

	this.testCondition = function() {
		if (sHalt.generator() < sHalt.probability) return true;
	};
}
_SHalt.prototype = Object.create(_Halt.prototype);
_SHalt.prototype.constructor = _SHalt;

_SHalt.registryName = "sHalts";
_SHalt.counterName = "stochasticHalt";

/*
_SHalt.prototype.play = function({initializePlayers=false, shortCircuit=false}={}){

	var sHalt = this;
	var test = sHalt.testCondition();

	if (test) {
		log("info", "Halting at " + sHalt.id)

		return Promise.reject({
			result:"Halt",
			playable:sHalt
		});
	}

	var resultObject = {
		'result':"Continued",
		'playable':sHalt
	};

	return Promise.resolve(resultObject)
	.then(function(result){

		//TODO: add information mechanisms

		return Promise.resolve(result)
	}).then(function(result){

		return sHalt.proceed(result, shortCircuit);
	});
};
*/

_SHalt.prototype.summaryThis = function(summary, entries) {
	summary.probability = this.probability;
}


function StochasticHalt(probability, { id = null, logContinue = false } = {}) {
	var id = idHandler(id, "stochasticHalt")

	if (isNaN(probability) || probability < 0 || probability > 1) throw new Error('Invalid probability');

	//Create backend sHalt objects
	var _sHalt = new _SHalt(id, probability, { logContinue });


	//Return this reference object to the user. Run the function to select a source
	var sHalt = Playable(_sHalt);
	return sHalt;
}


module.exports = { _SHalt, StochasticHalt };

},{"../helper-functions":8,"../logger":18,"../state":43,"./halt-if":22,"./playable":26}],33:[function(require,module,exports){
"use strict";

var log = require('../logger');
log("debug", "Loading Class: StochasticLoop")

//Game state controllers
var { registry, gameHistory } = require('../state');
var Promise = registry.Promise; // For sync mode

//Helper functions
var { idHandler } = require('../helper-functions')("state");
var { chainerGenerator } = require('../helper-functions')("playable");

//Parent classes
var { _Playable, Playable } = require('./playable');
var { _Loop, Loop } = require('./loop');


//Backend function class for StochasticLoop
function _SLoop(id, playable, probability, parameters) {
	_Loop.call(this, id, playable, null, parameters);

	this.playable = registry.playables[playable.id()];

	//This inherits from Loop which uses a count. Delete that and replace with probability.
	delete this.count;
	this.probability = probability;

	this.generator = Math.random; //TODO: allow user to specify random number generator
}
_SLoop.prototype = Object.create(_Loop.prototype);
_SLoop.prototype.constructor = _SLoop;

_SLoop.registryName = "sLoops";
_SLoop.counterName = "stochasticLoop";


_SLoop.prototype.play = function({
	initializePlayers = false,
	shortCircuit = false,
	history = gameHistory,
	information: PerfectInformation
} = {}) {

	var sLoop = this;
	sLoop.counter = 0;
	var loopHistory = history.child();

	if (sLoop.compartmentalize) {
		information = new Information(sLoop.compartmentalize.history || loopHistory,
			sLoop.compartmentalize.population || information.population);
	}


	var promise = Promise.resolve({});

	//Section that will be looped
	var action = function(result) {

		sLoop.counter++;
		if (!result) result = {};


		//Deal with history
		history.log.add({
			loop: sLoop.id,
			loopTo: sLoop.playable.id,
			count: sLoop.counter
		});

		return sLoop.playable.play({ shortCircuit: true, history: loopHistory, information })
			.then(function(result) {

				result.playable = sLoop;
				//TODO: add information mechanisms

				return Promise.resolve(result)
			});
	};


	//Generate random numbers, repeat while number is above halting probability
	while (sLoop.generator() > sLoop.probability) {
		promise = promise.then(action);
	}


	return promise.then(function(result) {

		result.historyEntry = {
			loop: sLoop.id,
			count: sLoop.counter,
			action: loopHistory.orphan()
		};

		return Promise.resolve(result);
	});
};

_SLoop.prototype.summaryThis = function(summary, entries) {
	summary.probability = this.probability;

	summary.action = {}
	this.playable.summarize(summary.action, entries, true)
}


//User interface
function StochasticLoop(playable, probability = .5, parameters = {}) {
	var id = idHandler(parameters.id, "stochasticLoop")

	if (isNaN(probability) || probability < 0 || probability > 1) throw new Error('Invalid probability');

	//Create backend sLoop object
	var _sLoop = new _SLoop(id, playable, probability, parameters);


	//Return this reference object to the user. Run the function to select a source
	var sLoop = Playable(_sLoop);
	return sLoop;
}



module.exports = { _SLoop, StochasticLoop };

},{"../helper-functions":8,"../logger":18,"../state":43,"./loop":25,"./playable":26}],34:[function(require,module,exports){
"use strict";

var log = require("../logger");
log("debug", "Loading Class: Turn");

//External dependency
var { SynchronousPromise } = require("synchronous-promise");

//Helper functions
var { isObject, once } = require("../helper-functions")("general");
var { chainerGenerator, outcomeTreeGetValue, outcomeTreeSetValue } = require("../helper-functions")(
	"playable");
var { recurse } = require("../helper-functions")("turn");
var { idHandler } = require("../helper-functions")("state");

//Game state controllers
var { registry } = require("../state");
var Promise = registry.Promise; // For sync mode
var { gameHistory } = require("../history");
var { Information, PerfectInformation } = require("../information");

//Parent classes
var { Branch, _Playable, Playable } = require("./playable");
var { Evaluator } = require("./range")


// Turn has the most complex branching of any Playable, because its sub-playables can be
// either Choice or Range. If they are all Choices, it uses branching like Choice does.
// There is an outcomeTree, an object of objects, where the path through them, (eg. left->right->down)
// defines the responses of the players in each respective Choice. Like ChoiceBranch, this uses the
// TurnBranch class to generate chaining objects and set payoffs.
//
// However, if any of the sub-playables are Range, then Turn uses a branching system more
// like that of Range, ie analogous to RangeOutcome, we'll use TurnOutcome. This creates
// branches and payoffs in the form of a Map, where the keys in the Map are Evaluators,
// and the values are for branching an array of next playables, and for payoffs a value for the
// payout. The Evaluator will be a function which takes a "result" argument, which is an array of the
// responses from each player, and should return true if the outcome branch/payoff is supposed to be
// triggered for this result.
//
// Turn also allows for both implicit and explicit payoffs. The latter names players by id, ie.
// p1 gets 2, while the former refers to players who are used by the sub-playables (Choice or Range)
// that are assigned to the Turn. Implicit payoffs allow for a more dynamic game (ie using RandomPlayerChoice,
// the player can change) while explicit payoffs allow players who aren't involved in the decision to still
// receive a payout or penalty.
//
// Soooo... good luck.


// Branch subclass
var TurnBranch = (function() {
	// Private data
	var _turns = new WeakMap();

	class TurnBranch extends Branch {
		constructor(path, _turn) {
			super(path, _turn.interface)
			_turns.set(this, _turn)
		}

		payoff(payoffs) {
			// Payoffs need to be array
			if (!Array.isArray(payoffs)) throw new Error("Argument must be payoffs array.")

			var _turn = _turns.get(this);
			var numPlayers = _turn.decisions.length
			var path = this.path

			//Allow the first few array elements to be implicit payoffs. Check that they are actually there and are numbers or null
			var implicit = payoffs.slice(0, numPlayers);
			if (implicit.length == numPlayers && implicit.every(function(payoff) {
					return (!isNaN(payoff) || payoff == null);
				})) {
				outcomeTreeSetValue(_turn.payoffsImplicit, path, implicit);
			} else throw new Error("Turn implicit payoffs must be correct size and each must be a number or null.")


			//Any remaining should be assigned as explicit payoffs, if they're objects.
			payoffs.slice(numPlayers).forEach(function(explicit) {
				if (isObject(explicit))
					outcomeTreeSetValue(_turn.payoffsExplicit, path, explicit);
			});

			return super.payoff();
		}

	}
	return TurnBranch;
})()




// Branch subclass
var TurnOutcome = (function() {
	// Private data
	var _turns = new WeakMap();

	class TurnOutcome extends Branch {
		constructor(evaluator, _turn) {
			super(evaluator, _turn)
			_turns.set(this, _turn)

			_turn.next.set(evaluator, []) // add blank nextmap once the branch is defined
		}

		payoff(payoffs) {
			// Payoffs need to be array
			if (!Array.isArray(payoffs)) throw new Error("Argument must be payoffs array.")

			var _turn = _turns.get(this);
			var numPlayers = _turn.decisions.length
			var path = this.path

			//Allow the first few array elements to be implicit payoffs. Check that they are actually there and are numbers or null
			var implicit = payoffs.slice(0, numPlayers);
			if (implicit.length == numPlayers && implicit.every(function(payoff) {
					return (!isNaN(payoff) || payoff == null);
				})) {
				_turn.payoffsImplicit.set(path, implicit)
			} else throw new Error("Turn implicit payoffs must be correct size and each must be a number or null.")


			//Any remaining should be assigned as explicit payoffs, if they're objects.
			payoffs.slice(numPlayers).forEach(function(explicit) {
				if (isObject(explicit)) {

					// Don't use the original object because then user could still have a reference
					// to it. Instead, copy over keys/values that are numbers (this will work for Variables)
					var obj = {}
					for (var key in explicit) {
						if (!isNaN(explicit[key])) obj[key] = explicit[key]
					}
					_turn.payoffsExplicit.set(path, obj)

				}

			});

			return super.payoff();
		}
	}

	return TurnOutcome;
})()



class _Turn extends _Playable {
	constructor(id, decisions, parameters = {}) {
		super(id, parameters)

		var turn = this;

		turn.decisions = decisions;

		// the decisionMap is an array of arrays, each corresponding to the options in a choice.
		turn.decisionMap = turn.decisions.map(function(item) {
			return item.options ? item.options : item.bounds;
		});

		// If any of the sub-playables are Range, or if set to forceOutcomeMode,
		//then we'll use Maps/Outcomes instead of objects/Branches
		if (parameters.forceOutcomeMode || turn.decisions.some(function(decision) {
				return decision.constructor.name == "_Range"
			})) {
			turn.branchMode = "outcome"
			turn.payoffsImplicit = new Map();
			turn.payoffsExplicit = new Map();
			turn.next = new Map([
				["all", []]
			]) // all is for any-outcome cases
		}
		// If no Range's, just use objects for simplicity
		else {
			turn.branchMode = "tree"
			turn.payoffsImplicit = {};
			turn.payoffsExplicit = {};
			turn.next = {};

			// Now let's fill those in with blank values.

			log("silly", "Adding implicit payoffs map to turn.");
			recurse(turn.decisionMap, turn.payoffsImplicit, null, function() {
				return Array(turn.decisionMap.length).fill(0);
			})

			log("silly", "Adding explicit payoffs map to turn.");
			recurse(turn.decisionMap, turn.payoffsExplicit, null, function() {
				return {}
			});

			log("silly", "Adding blank next map to turn.");
			recurse(turn.decisionMap, turn.next, null, function() {
				return [];
			});
		}
		//TODO: error handling here

	}

	addNext(nextPlayable, path = "all") {
		// The normal Playable addNext already suports tree mode.
		if (this.branchMode == "tree") return super.addNext(nextPlayable, path)
		// in outcome mode:
		else {
			if (path == "all") this.next.get("all").push(nextPlayable)
			else if (this.next.has(path)) this.next.get(path).push(nextPlayable)
			else throw new Error("Invalid path: ".concat(path))
		}
	}


	// Adding more complicated summary entry
	summaryThis(summary) {
		// Fetch summaries for each choice.
		summary.array("decisions", this.decisions, function(decision, summary) {
			return decision.summarize(summary, true) // short-circuit summary
		});

		// Include payoffs
		if (this.branchMode == "tree")
			summary("payoffs", JSON.parse(
				JSON.stringify({
					implicit: this.payoffsImplicit,
					explicit: this.payoffsExplicit
				})
			))
		// TODO: make payoff summary work for outcome mode.

		return summary;
	};

	play({
		usePayoffs = true,
		history = gameHistory,
		information = PerfectInformation,
		releasePlayers = true
	} = {}) {
		var turn = this;
		var choiceHistory = history.child();
		var choiceInformation = information.child();

		if (turn.compartmentalize) {
			choiceInformation = new Information(turn.compartmentalize.history || choiceHistory,
				turn.compartmentalize.population || information.population);
		}

		history.log.add({
			turn: turn.id,
			decisions: turn.decisions.map(function(decision) {
				return decision.id;
			})
		});

		var compileInformation = function(ri) {
			//If there's no turn entry, create one.
			if (!choiceInformation.additional[0].turn) {
				var turnInfo = {
					turn: {
						id: turn.id,
						decisions: [],
						exclude(player) {
							return this.decisions.filter(function(decision) {
								return decision.player == player;
							});
						}
					}
				};
				// Stick turn info in before decision infos
				choiceInformation.additional.unshift(turnInfo);
			}
			// move decision infos into turn info.
			choiceInformation.additional[0].turn.decisions.push(
				choiceInformation.additional.pop()
			);

			// Copy additional information from information to choiceInformation
			information.additional.forEach(
				choiceInformation.addAdditional.bind(choiceInformation)
			);
		};

		return Promise.all(
				turn.decisions.map(function(choice) {
					return choice.play({
						shortCircuit: true,
						history: choiceHistory,
						information: choiceInformation,
						_compileInformation: compileInformation,
						releasePlayers: false
					});
				})
			)
			.then(function(result) {
				//Re-format output from array of Choice results to single Turn result
				//And release players
				var resultPath = result.map(function(choice, index) {
					if (releasePlayers) turn.decisions[index].releasePlayer();
					return choice.result;
				});

				//Pass along results and record history
				var resultObject = {
					result: resultPath,
					playable: turn,
					historyEntry: {
						turn: turn.id,
						results: choiceHistory.orphan(),
						payouts: {}
					}
				};

				return Promise.resolve(resultObject);
			})
			.then(function(result) {
				//Implement payoffs
				if (usePayoffs) {
					var implicitPayoffs = outcomeTreeGetValue(
						turn.payoffsImplicit,
						result.result
					);
					var explicitPayoffs = outcomeTreeGetValue(
						turn.payoffsExplicit,
						result.result
					);

					// For the log
					var payouts = {};

					implicitPayoffs.forEach(function(payoff, index) {
						// Do nothing if payoff is zero.
						if (payoff == 0) return;

						// fetch player and increment score
						var player = turn.decisions[index].player;
						player.score += payoff;

						//And include it in the log entry
						payouts[player.id] = Number(payoff);
					});

					for (var player in explicitPayoffs) {
						registry.players[player].score += explicitPayoffs[player];

						//And include it in the log entry
						payouts[player] = Number(explicitPayoffs[player]);
					}

					//Log for the scores log
					var scoreEntry = {
						turn: turn.id,
						result: result.result,
						payouts: payouts
					};
					history.addScores(scoreEntry);


					// Log for the game history
					result.historyEntry.payouts = payouts;
				}

				return Promise.resolve(result); //TODO: add information mechanisms
			});
	}

	//Overwrite default history handler, because we don't want a second entry in the tree
	handleHistory({ history = gameHistory } = {}, result) {
		history.addNoLog(result.historyEntry);
		return Promise.resolve(result);
	};

	// Find the next thing to do.
	findNext({ result } = {}) {
		var next;

		// In branch mode, get the next items from the next tree.
		if (this.branchMode == "tree") {
			next = outcomeTreeGetValue(this.next, result.result);
		}

		// in outcome mode, iterate over the Map.
		else {
			// return the "any outcome" cases
			next = this.next.get("all").slice()

			// For each evaluator, run it with the result, and if true, add those playables to the list
			for (var [evaluator, playables] of this.next) {
				if (evaluator !== "all" && evaluator(result.result) === true) next.push(...playables)
			}
		}

		return next;
	};


	generateBranches() {
		var _turn = this;
		// In outcome (Range) mode, don't even bother.
		if (_turn.branchMode == "outcome") return false;

		// Keep an easy track of the branches, which will help for setAllPayoffs
		_turn.branches = []
		var turn = _turn.interface;

		recurse(_turn.decisionMap, turn, null, function(path) {
			let branch = new TurnBranch(path, _turn)
			_turn.branches.push(branch)
			return branch
		})

		return true
	}


	// Replaced with generateBranches, delete when you feel confident about it.
	generateChainingFunctions() {
		var _turn = this;
		var turn = _turn.interface;

		//Create payoff setter/branch router functions.
		//recurse adds a wrapper around this function which supplies the path.
		recurse(_turn.decisionMap, turn, function(path, payoffs) {
			//If user supplied payoffs in array form, then translate to object based on which players are involved in the decisions
			if (Array.isArray(payoffs)) {
				if (payoffs.length !== _turn.decisions.length) {
					//If array isn't right length, then this is unintelligible.
					log(
						"error",
						"Payoff array does not match Turn dimensions, cannot assign payoffs."
					);
					return Promise.reject(new Error("Payoff array is not correct length"));
				}

				var originalPayoffs = payoffs.slice();
				payoffs = {};

				outcomeTreeSetValue(_turn.payoffsImplicit, path, originalPayoffs);
			} else if (isObject(payoffs)) {
				payoffs = JSON.parse(JSON.stringify(payoffs));
				outcomeTreeSetValue(_turn.payoffsExplicit, path, payoffs);
			}

			return SynchronousPromise.resolve({
				playable: turn,
				path: path
			});
		});
	};

}
_Turn.registryName = "turns";
_Turn.counterName = "turn";




_Turn.prototype.setAllPayoffs = function(payoffArray) {
	var turn = this;

	//Recurse through the options in input, to come up with a path to every combination of options in the array of arrays.
	function recurse(input, numPlayers, payoffs, path = [], coordinates = []) {

		//Since we slice the array each time, if there are no more entries left then we're done with this branch.
		if (input.length == 0) return SynchronousPromise.resolve(path);

		//Among all values from the array
		return input[0].map(function(item, index) {
			var splitPath = path.slice(0).concat(item);
			var splitCoordinates = coordinates.slice(0).concat(index);
			var splitPayoffs = payoffs[index];

			//If we're at the last position in the array of options, then we have a complete path.
			if (input.length == 1) {
				/* you might need these later
				console.log("path ", splitPath);
				console.log("coordinates ", splitCoordinates)
				console.log("payoff ",splitPayoffs)
				*/

				splitPayoffs = JSON.parse(JSON.stringify(splitPayoffs));

				//Allow the first few array elements to be implicit payoffs. Check that they are actually there and are numbers
				var implicit = splitPayoffs.slice(0, numPlayers);
				if (
					implicit.length == numPlayers &&
					implicit.every(function(payoff) {
						return !isNaN(payoff);
					})
				) {
					outcomeTreeSetValue(turn.payoffsImplicit, splitPath, implicit);
				}

				//Any remaining should be assigned as explicit payoffs, if they're objects.
				splitPayoffs.slice(numPlayers).forEach(function(explicit) {
					if (isObject(explicit))
						outcomeTreeSetValue(turn.payoffsExplicit, splitPath, explicit);
				});
			}

			//If there are more items to iterate over, include them in the output then recurse.
			return recurse(
				input.slice(1),
				numPlayers,
				splitPayoffs,
				splitPath,
				splitCoordinates
			);
		})

	}

	return recurse(turn.decisionMap, turn.decisions.length, payoffArray).catch(
		function(reason) {
			log("error", reason);
		}
	);
};


_Turn.prototype.summaryNext = function(summary, entries) {
	var turn = this;

	// Create map
	summary.next = {};
	var count = 0;
	recurse(this.decisionMap, summary.next, null, function(path) {
		return outcomeTreeGetValue(turn.next, path).map(function(playable) {
			++count;
			return playable.summarize();
		});
	});

	// If there is no next, delete the key.
	if (count == 0) delete summary.next;
};



function Turn(decisions, parameters = {}) {
	var id = idHandler(parameters.id, "turn");

	decisions = decisions.map(function(choice) {
		return registry.decisions[choice.id()];
	});

	//Create backend choice object
	var _turn = new _Turn(id, decisions, parameters);

	//Return this reference object to the user. Run the function to select a source
	var turn = new Playable(_turn);

	_turn.generateBranches();


	turn.outcome = function(func, parameters) {
		var evaluator = new Evaluator(func, parameters)
		return new TurnOutcome(evaluator, registry.turns[this.id()])
	}

	//Function to set all payoffs at once
	turn.setAllPayoffs = function(payoffs) {
		//TODO: Include error handling if array given isn't expected dimensions.
		_turn.setAllPayoffs(payoffs);
	};

	//Way for user to interact with payoffs
	turn.payoffs = function() {
		return JSON.parse(
			JSON.stringify({
				implicit: _turn.payoffsImplicit,
				explicit: _turn.payoffsExplicit
			})
		);
	};

	// Returns the payoffs in nested array form, to make cloning easier, ie. t2.setAllPayoffs(t1.payoffsMatrix())
	turn.payoffsMatrix = function() {

		// recursion to construct payoff matrix
		var mapper = function(obj, path = []) {
			//If it's an array, then we've reached the payoffs
			if (Array.isArray(obj)) {
				var payoff = obj.slice(0)
				// Add explicit payoffs too
				var explicit = outcomeTreeGetValue(_turn.payoffsExplicit, path);

				// Only add an entry if the explicit payoffs object is not empty
				return Object.keys(explicit).length > 0 ? payoff.concat([outcomeTreeGetValue(_turn.payoffsExplicit,
					path)]) : payoff
			}

			// Otherwise, dig in deeper
			else return Object.keys(obj).map(function(key) { return mapper(obj[key], path.slice(0).concat([key])) })
		}
		return mapper(_turn.payoffsImplicit)
	}

	return turn;
}

module.exports = { TurnBranch, TurnOutcome, _Turn, Turn };

},{"../helper-functions":8,"../history":16,"../information":17,"../logger":18,"../state":43,"./playable":26,"./range":29,"synchronous-promise":66}],35:[function(require,module,exports){
"use strict";

var log = require('./logger');


//Game state controllers
var { registry } = require('./state');
var Promise = registry.Promise

//Helper functions
var { idHandler } = require('./helper-functions')("state");
var { chainerGenerator } = require('./helper-functions')("playable");

var { UserHistory } = require('./history');

// Plugins
var PluginManager = require("./plugin-manager")


// Internal player object
class _Player {
	constructor(id, { role = "", assign = null } = {}) {
		log('silly', 'Creating interal player object.');

		this.id = id
		this.role = role.toString();

		this.history = [];
		this.score = 0
		this.alive = true;
		this.available = true;

		if (assign) this.assign(assign);

		registry.players[id] = this;
	}

	//Assign strategy to player
	assign(strategy, ...args) {

		//TODO: verify strategy type
		if (registry.strategies[strategy]) {

			// don't allow incorrect roles, but only if roles exist for both player and strategy
			if (registry.strategies[strategy].role && this.role && registry.strategies[strategy].role != this.role) {
				throw new Error(
					"Cannot assign strategy ${strategy} (role ${registry.strategies[strategy].role}) to player ${this.id} (role ${this.role})"
				)
			}

			// assign strategy
			this.strategy = new registry.strategies[strategy](...args);
			this.strategy._id = strategy
			this.strategy._args = args
		} else throw new Error("Strategy '" + strategy + "' is not defined");
	};

	//Call strategy to make a choice
	choose(options, information = {}, playerMethod = "choose") {
		var player = this;
		if (player.strategy) {
			let result = player.strategy[playerMethod](options, information)
			if (result) return Promise.resolve(result.toString());
			// If no response, give warning
			else log("warning", "No response from player " + player.id + ". Using default option.")
		}
		// If no strategy, give warning
		else
			log("warning", "No strategy assigned to player " + player.id + ". Using default option.");
		return Promise.resolve(null);
	};

	//Takes a JSON.parse(JSON.stringify()) copy of _player. Returns a cleaned up version
	infoClean(infoObject) {
		delete infoObject.interface;
		infoObject.strategy = infoObject.strategy ? infoObject.strategy._id : null;

		return infoObject;
	};

	//Kill player. TODO: add player to some sort of "dead" list to avoid being picked to do things.
	kill() {
		this.alive = false;
	};
}


//Make a copy of the player, in order to take a snapshot. ////TODO try this again sometime.
/*
_Player.prototype.clone = function(){
	//Make new copy. Don't keep more than one.
	delete this.copy

	var clone = new _Player(this.id);

	//Loop through properties and assign them.
	for (var key in this){
		clone[key] = this[key];
	}
	//Do not add to registry. This will keep duplicates out of population.

	//Do add reference so we can find it again.
	this.copy = clone;

	return clone;
};
*/


//Class that is the reference for the user to hold onto
function player() {}


//Frontend for Player
function Player(parameters = {}) {
	var id = idHandler(parameters.id, "player");

	//Create backend player object
	var _player = new _Player(id, parameters);


	//Return this reference object to the user
	var playerInterface = new player(); //Probably add functionality here

	//Tag-back. Store the front-end object in the back-end object, for retrieval
	_player.interface = playerInterface;

	playerInterface.alive = function() {
		return registry.players[id].alive;
	}

	playerInterface.assign = function(strategy, ...args) {
		registry.players[id].assign(strategy, ...args);
	};

	playerInterface.history = function() {
		return new UserHistory(registry.players[id].history);
	};

	playerInterface.id = function() { return id; };

	playerInterface.isAvailable = function() {
		return registry.players[id].available
	};

	playerInterface.kill = function() {
		registry.players[id].kill();
	}

	playerInterface.markAvailable = function() {
		registry.players[id].available = true;
	};

	playerInterface.markBusy = function() {
		registry.players[id].available = false;
	};

	playerInterface.role = function(role) {
		if (role) registry.players[id].role = role.toString();
		return registry.players[id].role
	}

	playerInterface.resetScore = function() {
		registry.players[id].score = 0;
	}

	playerInterface.score = function() {
		return registry.players[id].score;
	};

	playerInterface.strategy = function() {
		return registry.players[id].strategy._id;
	};

	// PLUGIN: run after player creation
	PluginManager.run("player-create", _player)

	return playerInterface
}




module.exports = { _Player, Player };

},{"./helper-functions":8,"./history":16,"./logger":18,"./plugin-manager":37,"./state":43}],36:[function(require,module,exports){
/**
 *
 * @type {{}}
 */

function AsyncCtx(callback) {
	this.callback = callback;
	this.sync = true;
}

AsyncCtx.prototype.async = function() {
	this.sync = false;
	return this.callback;
};

/**
 * This is an API meant to be used only from synchronous
 * callbacks into an asynchronous like hook.
 *
 * it represent continuity from the "sync()" or "waterfall()"
 * plugin management
 */
AsyncCtx.prototype.stop = function() {
	var callback = this.async();
	callback(true);
};

module.exports = AsyncCtx;
},{}],37:[function(require,module,exports){
// Stolen liberally and brazenly from "polite-plugin-manager".
"use strict";

const pluginDirectoryPath = "../../plugins/"
// Hack to compile Glob files for browserify. Don´t call this function!
function $_DONOTCALL() {
	require('../../plugins/balance-sheet-complex.js');require('../../plugins/balance-sheet.js')
}

/**
 * Polite Plugin Manager
 * register and run hooks granting extendability
 *
 */


// Global Dependencies
var fs = require('fs'),
	path = require('path'),
	async = require('async'),

	// Local Modules
	AsyncCtx = require('./async-ctx'),
	WaterfallCtx = require('./waterfall-ctx'),
	PluginNameError = require('./plugin-name-error'),
	PluginCallbackError = require('./plugin-callback-error');


// ------------------------------------------------------------------------------------ //
// ---[[   C O N S T R U C T O R   A N D   L I F E C Y C L E   U T I L I T I E S   ]]-- //
// ------------------------------------------------------------------------------------ //

var PluginManager = {},
	packages = [],
	packageNames = [],
	hooks = {},
	skipProps = ['module', 'name', 'priority', 'active', 'init', 'require', 'stop', 'public', 'settings'];



PluginManager.reset = function() {
	packages = [];
	packageNames = [];
	hooks = {};
	return this;
};

/**
 * Apply package sorting,
 * register packages into hooks,
 * run packages init() method
 */
PluginManager.start = function(callback) {

	var self = this,
		inits = [];

	// sort by priorities
	packages.sort(function(a, b) {
		return a.priority > b.priority;
	});

	// register init & hooks
	// hooks are all functions who are not special properties
	// identified by "skipProps" list
	packages.forEach(function(pkg) {
		if (pkg.init) {
			inits.push(pkg.init);
		}
		for (var prop in pkg) {
			if (skipProps.indexOf(prop) === -1 && typeof pkg[prop] == 'function') {
				PluginManager.registerHook(prop, pkg[prop]);
			}
		}
	});

	// run all package.init() method in series!
	if (inits.length) {
		async.eachSeries(inits, function(fn, done) {

			var context = new AsyncCtx(done),
				result = fn.apply(context);

			// sync false stop initialization cycle!
			if (context.sync) {
				if (result === false) {
					callback.call(self);
				} else {
					done(result);
				}
			}

		}, callback.bind(this));
	} else {
		callback.call(self);
	}

	return this;
};




// --------------------------------- //
// ---[[   H O O K S   A P I   ]]--- //
// --------------------------------- //

PluginManager.registerHook = function(hookName, hookFn, hookPriority = 100) {
	hookFn.priority = hookPriority;

	if (!hooks[hookName]) {
		hooks[hookName] = [];
	}

	hooks[hookName].push(hookFn);
	return this;
};


PluginManager.isEmpty = function(hookName) {
	if (hooks[hookName] && hooks[hookName].length) {
		return false;
	} else {
		return true;
	}
};



/**
 * Run registered hook callbacks in series
 * (it supports asynchronous callbacks)
 */
PluginManager.run = function(hookName, ...args) {

	// Use the runWithCallback but with blank callback.
	PluginManager.runWithCallback(hookName, ...args, function() {})
};

// Same as above, but use last argument as callback
PluginManager.runWithCallback = function(hookName, ...args) {

	// collect hookName property
	if (!hookName) throw new PluginNameError('missing plugin name!');

	// obtain async callback
	if (!args.length || typeof args[args.length - 1] !== 'function') {
		throw new PluginCallbackError('[' + hookName + '] missing callback for async plugin!');
	} else {
		var callback = args.pop();
	}


	// check for some callbacks existance
	// [???] may give out an exception when no callbacks were found!
	if (!hooks[hookName] || !hooks[hookName].length) {
		callback(false);
		return false;
	}

	// Sort hooks by priority
	hooks[hookName].sort(function(a, b) {
		return a.priority > b.priority
	})

	// run async queque
	// NOTE: a step function should stop the queque by done(true)
	async.eachSeries(hooks[hookName], function(fn, done) {
		var context = new AsyncCtx(done),
			result = fn.apply(context, args);

		if (context.sync) {
			if (result === false) {
				callback();
			} else {
				done(result);
			}
		}
	}, callback);

	return true;
}

/**
 * Run registered hook callbacks in parallel
 * (it supports asynchronous callbacks)
 * @param hookName
 */

PluginManager.parallel = function() {

	var hookName = '',
		callback = null,
		args = Array.prototype.slice.call(arguments);

	// collect hookName property
	if (!args.length) {
		throw new PluginNameError('missing plugin name!');
	} else {
		hookName = args.shift();
	}

	// obtain async callback
	if (!args.length || typeof args[args.length - 1] !== 'function') {
		throw new PluginCallbackError('[' + hookName + '] missing callback for async plugin!');
	} else {
		callback = args[args.length - 1];
	}

	// check for some callbacks existance
	// [???] may give out an exception when no callbacks were found!
	if (!hooks[hookName] || !hooks[hookName].length) {
		callback(false);
		return false;
	}

	// run async in parallel
	// NOTE: a step function should stop the queque by done(true)
	async.each(hooks[hookName], function(fn, done) {
		var context = new AsyncCtx(done),
			result = fn.apply(context, args);

		// handle sync callbacks
		if (context.sync) {
			done(result);
		}
	}, callback);

	return true;
};


/**
 * WATERFALL
 * Run a hook as a normal function in a fully syncronous mode
 * Each hookFn should return a value who's forward as first argument for the next one
 * last hookFn return value is the final output
 */
PluginManager.waterfall = function(hookName) {

	if (!hookName) {
		throw new PluginNameError('missing plugin name!');
	}

	var args = Array.prototype.slice.call(arguments);
	args.shift();

	if (hooks[hookName]) {
		// use known exception to exit forEach cycle implementing a stoppable watefall
		// (http://stackoverflow.com/questions/2641347/how-to-short-circuit-array-foreach-like-calling-break?answertab=votes#tab-top)
		var WaterfallBreakException = {};
		try {
			hooks[hookName].forEach(function(fn) {
				var context = new WaterfallCtx(),
					result = fn.apply(context, args);

				if (args.length) {
					args[0] = result;
				}

				if (context.stopped) {
					throw WaterfallBreakException;
				}

			});
		} catch (e) {
			if (e !== WaterfallBreakException) throw e;
		}
	}

	if (args.length) {
		return args[0];
	} else {
		return;
	}
};




// --------------------------------------- //
// ---[[   P A C K A G E S   A P I   ]]--- //
// --------------------------------------- //

function getPackageByName(name) {
	var list = packages.filter(function(pkg) { return (pkg.name === name) })
	if (list.length == 1) return list[0]
	else return list;
}

// Package class
function Package(module, name = null, context = null) {
	// Basic assignment and default values
	Object.assign(this, {
		module,
		name,
		priority: 100,
		active: false,
		init: function() {},
		require: function() {},
		stop: function() {},
		settings: function() {},
		public: {}
	})
	// Package-defined values and hooks
	Object.assign(this, module(context || {}))

	// add to registry
	// Check to see if it's the same module being loaded twice, or different modules with the same name
	if (packageNames.includes(this.name)) {
		if (this.module === getPackageByName(this.name).module) {
			// Same module. Do nothing
		} else {
			// Different modules with same name, handle name conflict.
			//TODO: figure out how to handle name conflict.
		}
	}
	// No name conflict, add to registry
	else {
		packages.push(this);
		packageNames.push(this.name)
	}
}

Package.prototype.registerHooks = function() {
	var pkg = this;
	for (var prop in pkg) {
		if (skipProps.indexOf(prop) === -1 && typeof pkg[prop] == 'function') {
			PluginManager.registerHook(prop, pkg[prop]);
		}
	}
}

// Create interface for user to interact with package.
function PackageInterface(pkg) {

	// Merge any public items specified by the package with this interface format
	return Object.assign({}, pkg.public, {
		name: function() { return pkg.name },
		priority: function() { return pkg.priority },
		active: function() { return pkg.active },

		init: function(...args) {
			pkg.init(...args);
			pkg.registerHooks();
			pkg.active = true;
			return Object.assign(this, pkg.publicIfActive);
		},
		require: function(...args) {
			if (pkg.active) pkg.require(...args);
			else {
				pkg.init(...args);
				pkg.registerHooks();
				Object.assign(this, pkg.publicIfActive);
			}
			pkg.active = true;

			return this;
		},
		stop: function(...args) {
			if (pkg.active) pkg.stop(...args);
			pkg.active = false;
		},
		settings: function(...args) {
			return pkg.settings(...args);
		}

	}, pkg.active ? pkg.publicIfActive : null);
}




/**
 * Load a plugin package by folder path
 * @param sourceFolder
 */
PluginManager.package = function(source, context) {
	if (packageNames.includes(source)) {
		// Already loaded module, just return it
		return PackageInterface(getPackageByName(source))
	} else {
		var name = path.basename(source),
			module = require(pluginDirectoryPath + source + '.js')

		// obtain package informations and apply some default values
		var pkg = new Package(module, name, context)
		return PackageInterface(pkg)
	}
}

/*
			load: function(callback = function() {}, ...initArgs) {
				var self = pm,
					inits = [],


					// register init & hooks
					// hooks are all functions who are not special properties
					// identified by "skipProps" list

					if (pkg.init) {
						inits.push(pkg.init);
					}


				// run all package.init() method in series! //EDIT: will only be the one
				if (inits.length) {
					async.eachSeries(inits, function(fn, done) {

						var context = new AsyncCtx(done),
							result = fn.apply(context, initArgs);

						// sync false stop initialization cycle!
						if (context.sync) {
							if (result === false) {
								callback.call(self);
							} else {
								done(result);
							}
						}

					}, callback.bind(self));
				} else {
					callback.call(self);
				}

				return self;
			}

		};
	};
*/

/** TODO: this doesn't work right now
 * Load all packages from a given folder path
 * (syncronous)
 */
PluginManager.registerMany = function(sourceFolder, context) {
	var self = this;

	if (fs.existsSync(sourceFolder)) {
		fs.readdirSync(sourceFolder).forEach(function(item) {
			var itemPath = sourceFolder + '/' + item,
				itemStat = fs.lstatSync(itemPath);

			if (itemStat.isDirectory()) {
				self.loadPackage(itemPath, context);
			}
		});
	}

	return this;
};

module.exports = PluginManager

},{"../../plugins/balance-sheet-complex.js":67,"../../plugins/balance-sheet.js":68,"./async-ctx":36,"./plugin-callback-error":38,"./plugin-name-error":39,"./waterfall-ctx":40,"async":49,"fs":1,"path":2}],38:[function(require,module,exports){

function PluginCallbackError(message) {
	this.name = "PluginCallbackError";
	this.message = (message || "");
}


PluginCallbackError.prototype = new Error();
PluginCallbackError.prototype.constructor = PluginCallbackError;

module.exports = PluginCallbackError;
},{}],39:[function(require,module,exports){

function PluginNameError(message) {
	this.name = "PluginNameError";
	this.message = (message || "");
}


PluginNameError.prototype = new Error();
PluginNameError.prototype.constructor = PluginNameError;

module.exports = PluginNameError;
},{}],40:[function(require,module,exports){
/**
 *
 * @type {{}}
 */

function WaterfallCtx() {
	this.stopped = false;
}

WaterfallCtx.prototype.stop = function() {
	this.stopped = true;
};

module.exports = WaterfallCtx;
},{}],41:[function(require,module,exports){
"use strict";

var log = require("./logger");

//Helper functions
var { isFunction, isObject } = require("./helper-functions")("general");

//Game state controllers
var { registry } = require("./state");

var { _Player } = require("./player");

//Class PlayerList is a list of players which includes some extra functionality. UserPlayerList takes a playerList and
//sanitizes it for the user (ie returns .interface for each player).

function PlayerList(...args) {
	if (Array.isArray(args[0])) args = args[0].slice(0);
	if (args == "all") return gamePopulation();

	// We'll need to retain the original arguments in order to create the generator
	var originalArgs = []

	// Loop over the arguments, save the originals, parse them to _players
	for (var i = 0, len = args.length; i < len; i++) {
		originalArgs.push(args[i]);
		if (isFunction(args[i].id)) args[i] = registry.players[args[i].id()];
		else if (typeof args[i] === 'string') args[i] = registry.players[args[i]]
	}

	Object.setPrototypeOf(args, PlayerList.prototype);

	// returns the same playerlist, but updated, using the original args.
	args.generator = function() {
		return new PlayerList(originalArgs);
	};

	return args;
}

PlayerList.prototype = Object.create(Array.prototype);
PlayerList.prototype.constructor = PlayerList;


// Assign a strategy en masse
PlayerList.prototype.assign = function(strategyName) {
	this.forEach(function(player) {
		player.assign(strategyName)
	})
	return this;
}


//Return a PlayerList minus the specified players.
//Argument can be _player, interface, or a player's id.
PlayerList.prototype.exclude = function(playerArg) {
	if (Array.isArray(playerArg))
		return playerArg.reduce(function(running, item) {
			return running.exclude(item);
		}, this);

	return new PlayerList(
		this.filter(function(player) {
			if (
				playerArg === player ||
				playerArg == player.interface ||
				playerArg == player.id ||
				(isObject(playerArg) && playerArg.id == player.id)
			)
				return false;
			else return true;
		})
	);
};


// Placeholder for generator method.
PlayerList.prototype.generator = function() {
	// This will get shadowed when the constructor is called, but it needs to be here so that the
	// UserPlayerList and InfoPlayerList constructors can see it.
}


//Create an InfoPlayerList out of this PlayerList. Useful for getting summary view.
PlayerList.prototype.info = function() {
	return new InfoPlayerList(this);
};


//Return array of ids of each player in the list
PlayerList.prototype.ids = function() {
	return this.map(function(player) {
		return player.id;
	});
};


//Kill all players in the playerList
PlayerList.prototype.kill = function() {
	this.forEach(function(player) {
		player.kill();
	});
	return this;
};


//Returns the single player with the highest score
PlayerList.prototype.leader = function() {
	var players = this.slice();

	players.sort(function(a, b) {
		return b.score - a.score;
	});

	players = players.filter(function(player) {
		return player.score == players[0].score
	})


	return players.length > 1 ? new PlayerList(players) : players[0];
};


PlayerList.prototype.release = function() {
	this.forEach(function(player) {
		player.available = true;
	});
	return this;
};



//Return a playerList with only the players who are available
PlayerList.prototype.onlyAlive = function() {
	return new PlayerList(
		this.filter(function(player) {
			return player.alive;
		})
	);
};


//Return a playerList with only the players who are available
PlayerList.prototype.onlyAvailable = function() {
	return new PlayerList(
		this.filter(function(player) {
			return player.available;
		})
	);
};


//Returns an array of scores of each player in the list
PlayerList.prototype.scores = function() {
	var scores = [];

	this.forEach(function(player) {
		scores.push(player.score); //Use the interface function to avoid users re-assigning the reference
	});
	return scores;
};


// Returns an object where each key is a strategy and each value is an array of the scores of players with that strategy.
// TODO: finish .total() method, which will sum the arrays (duplicating .scoresByStrategyTotals)
PlayerList.prototype.scoresByStrategy = function() {
	var scores = {};
	var list = this;

	list.strategies().map(function(strategy) {
		scores[strategy] = list.usingStrategy(strategy).scores();
	});

	scores.total = function() {
		var score = {};
		var scores = this;
		Object.keys(scores).forEach(function(strategy) {
			if (Array.isArray(scores[strategy])) score[strategy] = scores[strategy].reduce(function(a, b) {
				return a + b;
			}, 0);
		});
		return score;
	};

	return scores;
};

// Returns an object where each key is a strategy and each value is the sum of scores of all players with that value
PlayerList.prototype.scoresByStrategyTotals = function() {
	var scores = {};
	var list = this;

	list.strategies().map(function(strategy) {
		scores[strategy] = list
			.usingStrategy(strategy)
			.scores()
			.reduce(function(a, b) {
				return a + b;
			}, 0);
	});

	return scores;
};

//Returns an object where the keys are the player ids and the values
//are the players' score
PlayerList.prototype.scoresObject = function() {
	var scores = {};

	this.forEach(function(player) {
		scores[player.id] = player.score;
	});

	return scores;
};

//Mean of the scores
PlayerList.prototype.scoresMean = function() {
	var scores = this.scores();

	var mean =
		scores.reduce(function(sum, value) {
			return sum + value;
		}, 0) / scores.length;

	return mean;
};

//Array with 2 entries, the lowest and highest score
PlayerList.prototype.scoresRange = function() {
	var scores = this.scores();

	scores.sort(function(a, b) {
		return a - b;
	});

	return [scores[0], scores[scores.length - 1]];
};

//The standard deviation of the scores
PlayerList.prototype.scoresStd = function() {
	var scores = this.scores();
	var mean = this.scoresMean();

	var variance =
		scores.reduce(function(sum, value) {
			return sum + Math.pow(value - mean, 2);
		}, 0) / scores.length;

	var std = Math.sqrt(variance);

	return std;
};


//Return an array of the strategy of each player in the list
PlayerList.prototype.strategies = function() {
	return this.map(function(player) {
		return player.strategy ? player.strategy._id : "";
	});
};

//Return a PlayerList with only players using a given strategy
PlayerList.prototype.usingStrategy = function(strategy) {
	return new PlayerList(
		this.filter(function(player) {
			if (
				player.strategy == strategy ||
				player.strategy._id == strategy ||
				(isFunction(strategy) && player.strategy instanceof strategy)
			)
				return true;
			else return false;
		})
	);
};

/*

TODO figure out how to make this work

//Returns an object where the keys are strategy names and the values are arrays of players.
//This needs to be overridden on the UserPlayerList prototype, because the normal wrapper logic
//for UserPlayerList cannot sanitize this.
PlayerList.prototype.byStrategy = function(){
	var list = this;
	var data = {};

	Object.keys(registry.strategies).forEach(function(strategy){
		data[strategy] = list.usingStrategy(strategy);
	});

	return data;
};
*/

//Returns an object where the keys are each strategy and the values
//are the number of players in the list who are using it.
PlayerList.prototype.strategyDistribution = function() {
	var counts = {};

	this.forEach(function(player) {
		var s = player.strategy._id;
		counts[s] = (counts[s] || 0) + 1;
	});

	return counts;
};



PlayerList.prototype.resetScores = function() {
	this.forEach(function(player) {
		player.score = 0;
	});
	return this;
};

//Accept a PlayerList and return one suitable for the user, or create a playerlist and return one suitable for the user
function UserPlayerList(...playerList) {
	if (Array.isArray(playerList[0])) playerList = playerList[0];

	// If we've got a playerList, return the interface of each player
	if (playerList instanceof PlayerList) {
		var userPlayerList = playerList.map(function(player) {
			return player.interface;
		});
	}
	// If not, first create a playerList, then call this function again to wrap it.
	else return new UserPlayerList(new PlayerList(playerList));

	Object.setPrototypeOf(userPlayerList, UserPlayerList.prototype);

	//Attach methods from PlayerList, wrapped in a function. If those methods return a playerList,
	//then the function will convert that to a UserPlayerList.
	for (var method in PlayerList.prototype) {
		if (isFunction(playerList[method])) {
			if (method != "constructor")
				userPlayerList[method] = (function(method) {
					return function() {
						var result = playerList[method].apply(playerList, arguments);
						if (result instanceof PlayerList) return new UserPlayerList(result);
						else if (result instanceof _Player) return result.interface;
						else return result;
					};
				})(method);
		}
	}

	return userPlayerList;
}

UserPlayerList.prototype = Object.create(PlayerList.prototype);
UserPlayerList.prototype.constructor = UserPlayerList;

//Accept a PlayerList and return one suitable for a strategy information set.
function InfoPlayerList(playerList) {
	var infoPlayerList = playerList.map(function(player) {
		return player.infoClean(JSON.parse(JSON.stringify(player)));
	});

	Object.setPrototypeOf(infoPlayerList, InfoPlayerList.prototype);

	//Attach selected methods from PlayerList, wrapped in a function. If those methods return a playerList,
	//then the function will convert that to an InfoPlayerList.
	var methodsToInclude = [
		"onlyAlive",
		"onlyAvailable",
		"ids",
		"exclude",
		"generator",
		"strategies",
		"usingStrategy",
		"strategyDistribution",
		"scores",
		"scoresObject",
		"scoresMean",
		"scoresRange",
		"scoresStd",
		"leader"
	];

	for (var method in PlayerList.prototype) {
		if (isFunction(playerList[method])) {
			if (methodsToInclude.indexOf(method) > -1)
				infoPlayerList[method] = (function(method) {
					return function() {
						var result = playerList[method].apply(playerList, arguments);
						if (result instanceof PlayerList) return new InfoPlayerList(result);
						else if (result instanceof _Player)
							return result.infoClean(JSON.parse(JSON.stringify(result)));
						else return result;
					};
				})(method);
		}
	}

	return infoPlayerList;
}

InfoPlayerList.prototype = Object.create(Array.prototype);
InfoPlayerList.prototype.constructor = InfoPlayerList;

//Extra method to return a single player from an infoPlayerList
InfoPlayerList.prototype.get = function(playerID) {
	return this.find(function(player) {
		return player.id == playerID;
	});
};

//Generates a PlayerList containing all players.
var gamePopulation = function() {
	var population = [];

	for (var player in registry.players) {
		population.push(registry.players[player]);
	}

	return new PlayerList(population);
};

//Does the same, but a UserPlayerList
var Population = function() {
	return new UserPlayerList(gamePopulation());
};

//Does the same, but an InfoPlayerList
var InfoPopulation = function() {
	return new InfoPlayerList(gamePopulation());
};

//A short-hand to return total population size without creating a PlayerList
Population.size = function() {
	return Object.keys(registry.players).length;
};

module.exports = {
	PlayerList,
	UserPlayerList,
	InfoPlayerList,
	gamePopulation,
	Population,
	InfoPopulation
};

},{"./helper-functions":8,"./logger":18,"./player":35,"./state":43}],42:[function(require,module,exports){
"use strict";

// External dependency
var jsonata = require("jsonata");

// Game state
var { registry, idCounters } = require("./state")
var { idHandler } = require('./helper-functions')("state");
registry._addType_("queries")
idCounters._addType_("query")


var registerQueryObject = function(queryObject, gameName) {
	// If there are multiple queries, recurse
	if (Array.isArray(queryObject)) return queryObject.map(function(query) {
		return registerQueryObject(query)
	});

	var { shortcut, query, description = "No description given." } = queryObject;
	// Enforce naming convention, first character '@'
	if (shortcut[0] != "@") shortcut = "@".concat(shortcut)

	// Check for duplicates. Abort if so, but return the data for display purposes.
	if (registry.queries[shortcut] && registry.queries[shortcut].query == query &&
		registry.queries[shortcut].description == description)
		return { shortcut, description };

	// assign id and add to registry
	var id = idHandler(shortcut, "query")
	registry.queries[id] = { query, description }

	//return the data for display purposes
	return { shortcut: id, description }
}


// The code which evaluates all queries, no matter where they come from.
function evaluateQuery(queryString, target, ...args) {
	// Check for pre-programmed query, designated by '@'
	if (queryString[0] == "@" && registry.queries[queryString]) queryString = registry.queries[queryString].query
	else if (queryString[0] == "@") queryString = queryString.slice(1)

	return new QueryResult(queryString, jsonata(queryString).evaluate(target, ...args)).pack();
}


// Object to pass around queries
function Query(shortcut, query, description, format = "shortcut") {

	if (format == "save") {
		this.saveShortcut = function(shortcut, description) {
			return registerQueryObject({ query: this.query, shortcut, description })
		}
	}

	// Only include requested properties, to avoid visual clutter
	if (format == "code" || format == "save" || format == "all") this.query = query;
	if (format == "shortcut" || format == "all") {
		this.shortcut = shortcut

		if (format !== "all") {
			// Normally we'd use the prototype method to save memory, but in this case it won't work, so attach another
			this.evaluate = function(target, ...args) {
				return evaluateQuery(query, target, ...args);
			}
		}

	}
	this.description = description
}

Query.prototype.evaluate = function(target, ...args) {
	return evaluateQuery(this.query, target, ...args)
};



// A class to share results with. A simple QueryResult has a `result` and
// a `queryString` property, and a `.pack` method. Calling `.pack` will
// create a new object whose value is the `result` property, but whose
//prototype is the original object. This gives a clean result, that still
// has a `.queryString` property, to view the string that generated it.
function QueryResult(query, result) {
	// Can't add properties to undefined, to change to a string
	if (result == undefined) result = {}

	this.query = query
	this.result = result
}
QueryResult.prototype = Object.create(Array.prototype)
QueryResult.prototype.constructor = QueryResult;

// Returns an object that is the results of the query, but whose
// prototype contains .query (unless the result was just a string)
QueryResult.prototype.pack = function() {
	// If result is string,
	if (typeof this.result === "string") {
		var packed = new String(this.result)
		packed.query = this.query
		return packed;
	}
	// If it's array
	else if (Array.isArray(this.result)) {
		var packed = Object.create(this)
		packed.push(...this.result)
		return packed
	}
	//Normal object
	else return Object.assign(Object.create(this), this.result)
}


// User object for dealing with these things.
function Queries(queryString, target, ...args) {
	// If no query string, display all available shortcuts
	if (!queryString) {
		return Object.keys(registry.queries).map(function(query) {
			var q = registry.queries[query]
			return new Query(query, q.query, q.description, "shortcut")
		})
	}
	// If query string, either run query or return query
	else {
		// If no target, return query
		if (!target) {
			var q = registry.queries[queryString]
			if (q) return new Query(queryString, q.query, q.description, "code")
			else return new Query(null, queryString, null, "save")
		}
		// If yes target, run query on target and return result
		else {
			return evaluateQuery(queryString, target, ...args)
		}
	}
}


module.exports = { Queries, Query, QueryResult, evaluateQuery, registerQueryObject }

},{"./helper-functions":8,"./state":43,"jsonata":59}],43:[function(require,module,exports){
"use strict";

var log = require('./logger');

log("debug", "state: Creating game state variables.")


var registry = {}
registry.Promise = {}; // Necessary for sync mode
registry._addType_ = function(type) {
	registry[type] = {};
	log("silly", "state: adding registry entry: ", type)
};


var idCounters = {}
idCounters._addType_ = function(type) {
	idCounters[type] = 0
	log("silly", "state: adding counter entry: ", type)
};




module.exports = { registry, idCounters };

},{"./logger":18}],44:[function(require,module,exports){
"use strict";

const nashName = "./core"; //Change this when published, probably to 'nash-js'

var fs = require("fs");

var { registerStrategy, registerStrategyObject } = require('./strategy');

//Check to see if parsed expression is call to require or eval
function isBannedCall(node) {
	return (node.type === 'CallExpression') &&
		(node.callee.type === 'MemberExpression') &&
		(node.callee.object.type === 'Identifier') &&
		((node.callee.object.name === 'require') || (node.callee.object.name === 'eval'));
}


function removeCalls(source) {
	const entries = [];
	esprima.parseScript(source, {}, function(node, meta) {
		if (isBannedCall(node)) {
			entries.push({
				start: meta.start.offset,
				end: meta.end.offset
			});
		}
	});
	entries.sort((a, b) => { return b.end - a.end }).forEach(n => {
		source = source.slice(0, n.start) + " null; " + source.slice(n.end);
	});
	return source;
}



var loadStrategy = function(filepath, trusted = false) {
	var compiler = require('expression-sandbox');

	var source = fs.readFileSync(filepath);

	if (!trusted) {
		var originalSource = source;
		var parsedSource = removeCalls(source);

		if (originalSource != parsedSource) throw new Error("Strategy " + filepath + " uses require or eval.");
	}

	source = "\"use strict\"; \n " + source;
	compiler(source)({ registerStrategy, registerStrategyObject });

}; //TODO: change this so that strategies can't require any modules.



function loadStrategyFolder(path, trusted = false) {
	var files = fs.readdirSync(path);
	files.forEach(function(file) {
		var filePath = path + '/' + file;
		loadStrategy(filepath);
	});
};


module.exports = { loadStrategy, loadStrategyFolder };

},{"./strategy":45,"expression-sandbox":55,"fs":1}],45:[function(require,module,exports){
"use strict";

var log = require('./logger');

//Javascript code parser
var esprima = require('esprima');

//Game state controllers
var { registry } = require('./state');

//Helper functions
var { idHandler } = require('./helper-functions')("state");



//User interface to declare strategy type.
function registerStrategy(strategy, name, description = "No description given.", role = "") {
	var id = idHandler(name, "strategy");

	if (id !== name) {
		//There was already a strategy registered with this name.
		//Check to see if it's the same strategy or not.
		if (registry.strategies[id] !== strategy) {
			//They're different, so we have a name conflict.
			throw new Error("Strategy name conflict with " + name);

		} else {
			// They're the same, do nothing.
			return true;
		}
	}

	// No name conflict and strategy not loaded yet. Add to registry.
	log("debug", "Loading strategy '" + id + "'")
	strategy.role = role;
	strategy.description = description;
	registry.strategies[id] = strategy;
	return name;
}

function registerStrategyObject(strategyObject) {
	// If multiple strategies, split into individuals
	if (Array.isArray(strategyObject)) return strategyObject.map(registerStrategyObject)

	return registerStrategy(strategyObject.strategy, strategyObject.name, strategyObject.description,
		strategyObject.role)
}

//Strip out requires and such
function sanitizeStrategy(strategy) {
	// console.log(x) or console['error'](y)
	function isRequireCall(node) {
		return (node.type === 'CallExpression') &&
			(node.callee.type === 'MemberExpression') &&
			(node.callee.object.type === 'Identifier') &&
			(node.callee.object.name === 'require');
	}

	function removeCalls(source) {
		const entries = [];
		esprima.parseScript(source, {}, function(node, meta) {
			if (isRequireCall(node)) {
				entries.push({
					start: meta.start.offset,
					end: meta.end.offset
				});
			}
		});
		entries.sort((a, b) => { return b.end - a.end }).forEach(n => {
			source = source.slice(0, n.start) + source.slice(n.end);
		});
		return source;
	}

	removeCalls(strategy.toString());

}

//Returns to the user an array of all registered strategies. TODO: have this mirror PlayerList, to provide functionality like onlyAlive and scoresObject.
function Strategies() {
	var strategies = [];
	for (var strategy in registry.strategies) strategies.push(strategy);
	return strategies;
};


Strategies.byRole = function() {
	var roles = { none: [] }
	for (var strategy in registry.strategies)
		if (registry.strategies[strategy].role) roles[registry.strategies[strategy].role] = [];
	for (var strategy in registry.strategies) {
		let role = registry.strategies[strategy].role;
		if (role) roles[role].push(strategy);
		else roles.none.push(strategy)
	}
	return roles;
}


// Fetch the descriptions of the strategies.
Strategies.descriptions = function() {
	var strategies = {};
	for (var strategy in registry.strategies) strategies[strategy] = registry.strategies[strategy].description;
	return strategies;
}


// A built-in strategy for dev debugging. This strategy will be created but do nothing
Strategies.dummy = function() {
	registerStrategy(function() {
		this.choose = function(options, information) {
			return
		}
	}, "dummy")
	return "dummy"
}

Strategies.quick = function(func, methods = []) {

	methods.push("choose")
	methods.push("range")

	registerStrategy(function() {
		for (var method of methods) this[method] = function(options, information) {
			return (func(options, information))
		}
	}, "quick")
	return "quick"
}

// A built-in debugging strategy. Calling this function loads the strategy.
// The strategy just calles 'debugger' when asked to choose.
Strategies.debugger = function(methods = []) {
	registerStrategy(function() {

		this.choose = function(options, information) {
			debugger;
		}

		this.range = function(bounds, information) {
			debugger;
		}

		// arbitrary user methods
		for (var method of methods) this[method] = function(options, information) { debugger; }

	}, "debugger")
	return "debugger"
}


Strategies.logger = function(methods = []) {
	registerStrategy(function() {

		this.choose = function(options, information) {
			console.log("Options: ", options);
			console.log("Information: ", information)
		}

		this.range = function(bounds, information) {
			console.log("Bounds: ", bounds);
			console.log("Information: ", information)
		}

		for (var method of methods)
			this[method] = function(options, information) {
				console.log("Options: ", options);
				console.log("Information: ", information)
			}

	}, "logger")
	return "logger"
}

module.exports = { registerStrategy, registerStrategyObject, Strategies };

},{"./helper-functions":8,"./logger":18,"./state":43,"esprima":54}],46:[function(require,module,exports){
"use strict";

// Base class, external dependency
var CallableInstance = require('callable-instance');

// To aid with tree-branching
var { recurse } = require("./helper-functions")("turn");
var { outcomeTreeGetValue } = require("./helper-functions")("playable");

// Data structure for playable summary passing. Callable with a name, creating a sub-branch.
// 'entries' can be used to keep track of instances of a particular playable, to prevent infinite loops.
class Summary extends CallableInstance {
	constructor(entries = {}) {
		super("key")
		this.summary = {}
		this.entries = entries
	}

	// create a key in the summary, and fill it with value
	key(keyName, value) {
		if (value !== undefined) this.summary[keyName] = value
		return this.summary[keyName]
	}


	delete(keyName) {
		delete this.summary[keyName]
	}


	// create a branch (key) in the summary which will itself have a Summary, with the same entry list (to prevent circles)
	branch(branchName) {
		this.summary[branchName] = new Summary(this.entries)
		return this.summary[branchName]
	}


	// create a branch (key) which will have an array of Summaries (all with the same entry list)
	array(branchName, array, func, arrayIfOne = false) {
		var summary = this
		summary.summary[branchName] = array.map(function(item) {
			var itemSummary = new Summary(summary.entries)
			var result = func(item, itemSummary)
			return result ? result : itemSummary // in case they forget to return
		})

		// If only one entry, no need for array
		if (!arrayIfOne && summary.summary[branchName].length == 1) summary.summary[branchName] = summary.summary[
			branchName][0]

		return this;
	}


	// create a branch (key) from a tree (outcomeTree), where the values deepest in the tree will be Summaries (all with the same entries list)
	tree(branchName, treeMap, tree, func, treeIfIdentical = false) {
		var summary = this;
		var items = []
		var tempTree = {}

		recurse(treeMap, tempTree, null, function(path) {
			var item = outcomeTreeGetValue(tree, path)
			items.push(item)

			var itemSummary = new Summary(summary.entries)
			var result = func(item, path, itemSummary)
			return result ? result : itemSummary
		})

		var areIdentical = items.every(function(item) {
			return (item === items[0])
		})

		if (areIdentical && !treeIfIdentical) summary.summary[branchName] = items[0]
		else summary.summary[branchName] = tempTree

		return this;
	}


	// create a branch (key) from a tree (outcomeTree), where the values deepest in the tree will be arrays of Summaries (all with the same entries list)
	treeArray(branchName, treeMap, tree, func, { arrayIfOne = false, treeIfIdentical = false } = {}) {
		var summary = this;
		var items = []
		var processedItem // will hold onto the last item, then get used as the end result if items are identical
		var tempTree = {}

		// using treeMap as a guide, write to tempTree, the value returned by the function
		recurse(treeMap, tempTree, null, function(path) {
			var array = outcomeTreeGetValue(tree, path)
			items.push(array)

			// process the raw input into a Summary, using the user-provided function
			array = array.map(function(item) {
				var itemSummary = new Summary(summary.entries)
				var result = func(item, path, itemSummary)
				processedItem = result
				return result ? result : itemSummary
			})
			// by default, replace single-length arrays with the value
			if (!arrayIfOne && array.length == 1) {
				array = array[0]
				items[items.length - 1] = items[items.length - 1][0]
			}

			return array
		})

		var areIdentical = items.every(function(item) {
			return (item == items[0])
		})

		if (areIdentical && !treeIfIdentical) {
			// just use the item rather than the whole tree of superfluous information
			summary.summary[branchName] = processedItem

			//try to cut down on entry list duplicates
			// ie. if a Choice with 10 options has the same next item for all of them,
			// that doesn't mean we've been circling 10 times.
			if (items.id) summary.entries[items.id] = summary.entries[items.id] - items.length + 1
		} else summary.summary[branchName] = tempTree

		return this;
	}

	mapArray(branchName, map, func, { arrayIfOne = false, condenseAll = true } = {}) {
		var summary = this;
		summary.summary[branchName] = []

		// iterate over the map, process the value
		for (var [key, value] of map.entries()) {
			value = value.map(function(item) {
				var itemSummary = new Summary(summary.entries)
				var result = func(item, itemSummary)
				return result ? result : itemSummary // In case they forget to return the summary
			})
			// condense by default
			if (!arrayIfOne && value.length == 1) value = value[0]

			summary.summary[branchName].push({
				[key.path || key.name || key]: value
			})
		}

		// condense by default (turn singlet array into value, turn singlet "all" object into value)
		if (!arrayIfOne && summary.summary[branchName].length == 1) {
			summary.summary[branchName] = summary.summary[branchName][0]
			if (condenseAll && summary.summary[branchName].all) summary.summary[branchName] = summary.summary[
				branchName].all
		}
	}


	// TODO: Meant to collapse summaries into simple objects. Ths is going to require some work...
	print() {

		// recursive function to handle nested objects in the summary
		function crawl(input) {
			if (input instanceof Summary) return input.print()
			else if (input instanceof Object) {
				for (var key in input) {
					input[key] = crawl(input[key])
				}
			}
			return input
		}

		// Loop over summary keys and recurse over ones that are summaries
		for (var key in this.summary) {
			if (this.summary[key] instanceof Summary) this.summary[key] = this.summary[key].print()
			// if the key is an array, loop through the items, and collapse any that are summaries
			else if (Array.isArray(this.summary[key])) this.summary[key] = this.summary[key].map(function(item) {
				if (item instanceof Summary) return item.print()
				else return crawl(item)
			})
			else {
				this.summary[key] = crawl(this.summary[key])
			}
		}

		return this.summary
	}

}

module.exports = { Summary }

},{"./helper-functions":8,"callable-instance":50}],47:[function(require,module,exports){
'use strict';
module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};

},{}],48:[function(require,module,exports){
'use strict';

function assembleStyles () {
	var styles = {
		modifiers: {
			reset: [0, 0],
			bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		colors: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39]
		},
		bgColors: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49]
		}
	};

	// fix humans
	styles.colors.grey = styles.colors.gray;

	Object.keys(styles).forEach(function (groupName) {
		var group = styles[groupName];

		Object.keys(group).forEach(function (styleName) {
			var style = group[styleName];

			styles[styleName] = group[styleName] = {
				open: '\u001b[' + style[0] + 'm',
				close: '\u001b[' + style[1] + 'm'
			};
		});

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	});

	return styles;
}

Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});

},{}],49:[function(require,module,exports){
(function (process,global){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.async = global.async || {})));
}(this, (function (exports) { 'use strict';

function slice(arrayLike, start) {
    start = start|0;
    var newLen = Math.max(arrayLike.length - start, 0);
    var newArr = Array(newLen);
    for(var idx = 0; idx < newLen; idx++)  {
        newArr[idx] = arrayLike[start + idx];
    }
    return newArr;
}

/**
 * Creates a continuation function with some arguments already applied.
 *
 * Useful as a shorthand when combined with other control flow functions. Any
 * arguments passed to the returned function are added to the arguments
 * originally passed to apply.
 *
 * @name apply
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {Function} fn - The function you want to eventually apply all
 * arguments to. Invokes with (arguments...).
 * @param {...*} arguments... - Any number of arguments to automatically apply
 * when the continuation is called.
 * @returns {Function} the partially-applied function
 * @example
 *
 * // using apply
 * async.parallel([
 *     async.apply(fs.writeFile, 'testfile1', 'test1'),
 *     async.apply(fs.writeFile, 'testfile2', 'test2')
 * ]);
 *
 *
 * // the same process without using apply
 * async.parallel([
 *     function(callback) {
 *         fs.writeFile('testfile1', 'test1', callback);
 *     },
 *     function(callback) {
 *         fs.writeFile('testfile2', 'test2', callback);
 *     }
 * ]);
 *
 * // It's possible to pass any number of additional arguments when calling the
 * // continuation:
 *
 * node> var fn = async.apply(sys.puts, 'one');
 * node> fn('two', 'three');
 * one
 * two
 * three
 */
var apply = function(fn/*, ...args*/) {
    var args = slice(arguments, 1);
    return function(/*callArgs*/) {
        var callArgs = slice(arguments);
        return fn.apply(null, args.concat(callArgs));
    };
};

var initialParams = function (fn) {
    return function (/*...args, callback*/) {
        var args = slice(arguments);
        var callback = args.pop();
        fn.call(this, args, callback);
    };
};

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
var hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

function fallback(fn) {
    setTimeout(fn, 0);
}

function wrap(defer) {
    return function (fn/*, ...args*/) {
        var args = slice(arguments, 1);
        defer(function () {
            fn.apply(null, args);
        });
    };
}

var _defer;

if (hasSetImmediate) {
    _defer = setImmediate;
} else if (hasNextTick) {
    _defer = process.nextTick;
} else {
    _defer = fallback;
}

var setImmediate$1 = wrap(_defer);

/**
 * Take a sync function and make it async, passing its return value to a
 * callback. This is useful for plugging sync functions into a waterfall,
 * series, or other async functions. Any arguments passed to the generated
 * function will be passed to the wrapped function (except for the final
 * callback argument). Errors thrown will be passed to the callback.
 *
 * If the function passed to `asyncify` returns a Promise, that promises's
 * resolved/rejected state will be used to call the callback, rather than simply
 * the synchronous return value.
 *
 * This also means you can asyncify ES2017 `async` functions.
 *
 * @name asyncify
 * @static
 * @memberOf module:Utils
 * @method
 * @alias wrapSync
 * @category Util
 * @param {Function} func - The synchronous function, or Promise-returning
 * function to convert to an {@link AsyncFunction}.
 * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
 * invoked with `(args..., callback)`.
 * @example
 *
 * // passing a regular synchronous function
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(JSON.parse),
 *     function (data, next) {
 *         // data is the result of parsing the text.
 *         // If there was a parsing error, it would have been caught.
 *     }
 * ], callback);
 *
 * // passing a function returning a promise
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(function (contents) {
 *         return db.model.create(contents);
 *     }),
 *     function (model, next) {
 *         // `model` is the instantiated model object.
 *         // If there was an error, this function would be skipped.
 *     }
 * ], callback);
 *
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.queue(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.push(files);
 */
function asyncify(func) {
    return initialParams(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (isObject(result) && typeof result.then === 'function') {
            result.then(function(value) {
                invokeCallback(callback, null, value);
            }, function(err) {
                invokeCallback(callback, err.message ? err : new Error(err));
            });
        } else {
            callback(null, result);
        }
    });
}

function invokeCallback(callback, error, value) {
    try {
        callback(error, value);
    } catch (e) {
        setImmediate$1(rethrow, e);
    }
}

function rethrow(error) {
    throw error;
}

var supportsSymbol = typeof Symbol === 'function';

function isAsync(fn) {
    return supportsSymbol && fn[Symbol.toStringTag] === 'AsyncFunction';
}

function wrapAsync(asyncFn) {
    return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
}

function applyEach$1(eachfn) {
    return function(fns/*, ...args*/) {
        var args = slice(arguments, 1);
        var go = initialParams(function(args, callback) {
            var that = this;
            return eachfn(fns, function (fn, cb) {
                wrapAsync(fn).apply(that, args.concat(cb));
            }, callback);
        });
        if (args.length) {
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
}

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */
var Symbol$1 = root.Symbol;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$1.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]';
var undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]';
var funcTag = '[object Function]';
var genTag = '[object GeneratorFunction]';
var proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

// A temporary value used to identify if the loop should be broken.
// See #1064, #1293
var breakLoop = {};

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

function once(fn) {
    return function () {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}

var iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;

var getIterator = function (coll) {
    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
};

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]';
var arrayTag = '[object Array]';
var boolTag = '[object Boolean]';
var dateTag = '[object Date]';
var errorTag = '[object Error]';
var funcTag$1 = '[object Function]';
var mapTag = '[object Map]';
var numberTag = '[object Number]';
var objectTag = '[object Object]';
var regexpTag = '[object RegExp]';
var setTag = '[object Set]';
var stringTag = '[object String]';
var weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]';
var dataViewTag = '[object DataView]';
var float32Tag = '[object Float32Array]';
var float64Tag = '[object Float64Array]';
var int8Tag = '[object Int8Array]';
var int16Tag = '[object Int16Array]';
var int32Tag = '[object Int32Array]';
var uint8Tag = '[object Uint8Array]';
var uint8ClampedTag = '[object Uint8ClampedArray]';
var uint16Tag = '[object Uint16Array]';
var uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports$1 && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$1.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;

  return value === proto;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$3.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

function createArrayIterator(coll) {
    var i = -1;
    var len = coll.length;
    return function next() {
        return ++i < len ? {value: coll[i], key: i} : null;
    }
}

function createES2015Iterator(iterator) {
    var i = -1;
    return function next() {
        var item = iterator.next();
        if (item.done)
            return null;
        i++;
        return {value: item.value, key: i};
    }
}

function createObjectIterator(obj) {
    var okeys = keys(obj);
    var i = -1;
    var len = okeys.length;
    return function next() {
        var key = okeys[++i];
        return i < len ? {value: obj[key], key: key} : null;
    };
}

function iterator(coll) {
    if (isArrayLike(coll)) {
        return createArrayIterator(coll);
    }

    var iterator = getIterator(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
}

function onlyOnce(fn) {
    return function() {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}

function _eachOfLimit(limit) {
    return function (obj, iteratee, callback) {
        callback = once(callback || noop);
        if (limit <= 0 || !obj) {
            return callback(null);
        }
        var nextElem = iterator(obj);
        var done = false;
        var running = 0;
        var looping = false;

        function iterateeCallback(err, value) {
            running -= 1;
            if (err) {
                done = true;
                callback(err);
            }
            else if (value === breakLoop || (done && running <= 0)) {
                done = true;
                return callback(null);
            }
            else if (!looping) {
                replenish();
            }
        }

        function replenish () {
            looping = true;
            while (running < limit && !done) {
                var elem = nextElem();
                if (elem === null) {
                    done = true;
                    if (running <= 0) {
                        callback(null);
                    }
                    return;
                }
                running += 1;
                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
            }
            looping = false;
        }

        replenish();
    };
}

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name eachOfLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 */
function eachOfLimit(coll, limit, iteratee, callback) {
    _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
}

function doLimit(fn, limit) {
    return function (iterable, iteratee, callback) {
        return fn(iterable, limit, iteratee, callback);
    };
}

// eachOf implementation optimized for array-likes
function eachOfArrayLike(coll, iteratee, callback) {
    callback = once(callback || noop);
    var index = 0,
        completed = 0,
        length = coll.length;
    if (length === 0) {
        callback(null);
    }

    function iteratorCallback(err, value) {
        if (err) {
            callback(err);
        } else if ((++completed === length) || value === breakLoop) {
            callback(null);
        }
    }

    for (; index < length; index++) {
        iteratee(coll[index], index, onlyOnce(iteratorCallback));
    }
}

// a generic version of eachOf which can handle array, object, and iterator cases.
var eachOfGeneric = doLimit(eachOfLimit, Infinity);

/**
 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
 * to the iteratee.
 *
 * @name eachOf
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEachOf
 * @category Collection
 * @see [async.each]{@link module:Collections.each}
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each
 * item in `coll`.
 * The `key` is the item's key, or index in the case of an array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @example
 *
 * var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
 * var configs = {};
 *
 * async.forEachOf(obj, function (value, key, callback) {
 *     fs.readFile(__dirname + value, "utf8", function (err, data) {
 *         if (err) return callback(err);
 *         try {
 *             configs[key] = JSON.parse(data);
 *         } catch (e) {
 *             return callback(e);
 *         }
 *         callback();
 *     });
 * }, function (err) {
 *     if (err) console.error(err.message);
 *     // configs is now a map of JSON data
 *     doSomethingWith(configs);
 * });
 */
var eachOf = function(coll, iteratee, callback) {
    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
    eachOfImplementation(coll, wrapAsync(iteratee), callback);
};

function doParallel(fn) {
    return function (obj, iteratee, callback) {
        return fn(eachOf, obj, wrapAsync(iteratee), callback);
    };
}

function _asyncMap(eachfn, arr, iteratee, callback) {
    callback = callback || noop;
    arr = arr || [];
    var results = [];
    var counter = 0;
    var _iteratee = wrapAsync(iteratee);

    eachfn(arr, function (value, _, callback) {
        var index = counter++;
        _iteratee(value, function (err, v) {
            results[index] = v;
            callback(err);
        });
    }, function (err) {
        callback(err, results);
    });
}

/**
 * Produces a new collection of values by mapping each value in `coll` through
 * the `iteratee` function. The `iteratee` is called with an item from `coll`
 * and a callback for when it has finished processing. Each of these callback
 * takes 2 arguments: an `error`, and the transformed item from `coll`. If
 * `iteratee` passes an error to its callback, the main `callback` (for the
 * `map` function) is immediately called with the error.
 *
 * Note, that since this function applies the `iteratee` to each item in
 * parallel, there is no guarantee that the `iteratee` functions will complete
 * in order. However, the results array will be in the same order as the
 * original `coll`.
 *
 * If `map` is passed an Object, the results will be an Array.  The results
 * will roughly be in the order of the original Objects' keys (but this can
 * vary across JavaScript engines).
 *
 * @name map
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an Array of the
 * transformed items from the `coll`. Invoked with (err, results).
 * @example
 *
 * async.map(['file1','file2','file3'], fs.stat, function(err, results) {
 *     // results is now an array of stats for each file
 * });
 */
var map = doParallel(_asyncMap);

/**
 * Applies the provided arguments to each function in the array, calling
 * `callback` after all functions have completed. If you only provide the first
 * argument, `fns`, then it will return a function which lets you pass in the
 * arguments as if it were a single function call. If more arguments are
 * provided, `callback` is required while `args` is still optional.
 *
 * @name applyEach
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s
 * to all call with the same arguments
 * @param {...*} [args] - any number of separate arguments to pass to the
 * function.
 * @param {Function} [callback] - the final argument should be the callback,
 * called when all functions have completed processing.
 * @returns {Function} - If only the first argument, `fns`, is provided, it will
 * return a function which lets you pass in the arguments as if it were a single
 * function call. The signature is `(..args, callback)`. If invoked with any
 * arguments, `callback` is required.
 * @example
 *
 * async.applyEach([enableSearch, updateSchema], 'bucket', callback);
 *
 * // partial application example:
 * async.each(
 *     buckets,
 *     async.applyEach([enableSearch, updateSchema]),
 *     callback
 * );
 */
var applyEach = applyEach$1(map);

function doParallelLimit(fn) {
    return function (obj, limit, iteratee, callback) {
        return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
    };
}

/**
 * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.
 *
 * @name mapLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.map]{@link module:Collections.map}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an array of the
 * transformed items from the `coll`. Invoked with (err, results).
 */
var mapLimit = doParallelLimit(_asyncMap);

/**
 * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.
 *
 * @name mapSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.map]{@link module:Collections.map}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an array of the
 * transformed items from the `coll`. Invoked with (err, results).
 */
var mapSeries = doLimit(mapLimit, 1);

/**
 * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.
 *
 * @name applyEachSeries
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.applyEach]{@link module:ControlFlow.applyEach}
 * @category Control Flow
 * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s to all
 * call with the same arguments
 * @param {...*} [args] - any number of separate arguments to pass to the
 * function.
 * @param {Function} [callback] - the final argument should be the callback,
 * called when all functions have completed processing.
 * @returns {Function} - If only the first argument is provided, it will return
 * a function which lets you pass in the arguments as if it were a single
 * function call.
 */
var applyEachSeries = applyEach$1(mapSeries);

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

/**
 * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on
 * their requirements. Each function can optionally depend on other functions
 * being completed first, and each function is run as soon as its requirements
 * are satisfied.
 *
 * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence
 * will stop. Further tasks will not execute (so any other functions depending
 * on it will not run), and the main `callback` is immediately called with the
 * error.
 *
 * {@link AsyncFunction}s also receive an object containing the results of functions which
 * have completed so far as the first argument, if they have dependencies. If a
 * task function has no dependencies, it will only be passed a callback.
 *
 * @name auto
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Object} tasks - An object. Each of its properties is either a
 * function or an array of requirements, with the {@link AsyncFunction} itself the last item
 * in the array. The object's key of a property serves as the name of the task
 * defined by that property, i.e. can be used when specifying requirements for
 * other tasks. The function receives one or two arguments:
 * * a `results` object, containing the results of the previously executed
 *   functions, only passed if the task has any dependencies,
 * * a `callback(err, result)` function, which must be called when finished,
 *   passing an `error` (which can be `null`) and the result of the function's
 *   execution.
 * @param {number} [concurrency=Infinity] - An optional `integer` for
 * determining the maximum number of tasks that can be run in parallel. By
 * default, as many as possible.
 * @param {Function} [callback] - An optional callback which is called when all
 * the tasks have been completed. It receives the `err` argument if any `tasks`
 * pass an error to their callback. Results are always returned; however, if an
 * error occurs, no further `tasks` will be performed, and the results object
 * will only contain partial results. Invoked with (err, results).
 * @returns undefined
 * @example
 *
 * async.auto({
 *     // this function will just be passed a callback
 *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),
 *     showData: ['readData', function(results, cb) {
 *         // results.readData is the file's contents
 *         // ...
 *     }]
 * }, callback);
 *
 * async.auto({
 *     get_data: function(callback) {
 *         console.log('in get_data');
 *         // async code to get some data
 *         callback(null, 'data', 'converted to array');
 *     },
 *     make_folder: function(callback) {
 *         console.log('in make_folder');
 *         // async code to create a directory to store a file in
 *         // this is run at the same time as getting the data
 *         callback(null, 'folder');
 *     },
 *     write_file: ['get_data', 'make_folder', function(results, callback) {
 *         console.log('in write_file', JSON.stringify(results));
 *         // once there is some data and the directory exists,
 *         // write the data to a file in the directory
 *         callback(null, 'filename');
 *     }],
 *     email_link: ['write_file', function(results, callback) {
 *         console.log('in email_link', JSON.stringify(results));
 *         // once the file is written let's email a link to it...
 *         // results.write_file contains the filename returned by write_file.
 *         callback(null, {'file':results.write_file, 'email':'user@example.com'});
 *     }]
 * }, function(err, results) {
 *     console.log('err = ', err);
 *     console.log('results = ', results);
 * });
 */
var auto = function (tasks, concurrency, callback) {
    if (typeof concurrency === 'function') {
        // concurrency is optional, shift the args.
        callback = concurrency;
        concurrency = null;
    }
    callback = once(callback || noop);
    var keys$$1 = keys(tasks);
    var numTasks = keys$$1.length;
    if (!numTasks) {
        return callback(null);
    }
    if (!concurrency) {
        concurrency = numTasks;
    }

    var results = {};
    var runningTasks = 0;
    var hasError = false;

    var listeners = Object.create(null);

    var readyTasks = [];

    // for cycle detection:
    var readyToCheck = []; // tasks that have been identified as reachable
    // without the possibility of returning to an ancestor task
    var uncheckedDependencies = {};

    baseForOwn(tasks, function (task, key) {
        if (!isArray(task)) {
            // no dependencies
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
        }

        var dependencies = task.slice(0, task.length - 1);
        var remainingDependencies = dependencies.length;
        if (remainingDependencies === 0) {
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
        }
        uncheckedDependencies[key] = remainingDependencies;

        arrayEach(dependencies, function (dependencyName) {
            if (!tasks[dependencyName]) {
                throw new Error('async.auto task `' + key +
                    '` has a non-existent dependency `' +
                    dependencyName + '` in ' +
                    dependencies.join(', '));
            }
            addListener(dependencyName, function () {
                remainingDependencies--;
                if (remainingDependencies === 0) {
                    enqueueTask(key, task);
                }
            });
        });
    });

    checkForDeadlocks();
    processQueue();

    function enqueueTask(key, task) {
        readyTasks.push(function () {
            runTask(key, task);
        });
    }

    function processQueue() {
        if (readyTasks.length === 0 && runningTasks === 0) {
            return callback(null, results);
        }
        while(readyTasks.length && runningTasks < concurrency) {
            var run = readyTasks.shift();
            run();
        }

    }

    function addListener(taskName, fn) {
        var taskListeners = listeners[taskName];
        if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
        }

        taskListeners.push(fn);
    }

    function taskComplete(taskName) {
        var taskListeners = listeners[taskName] || [];
        arrayEach(taskListeners, function (fn) {
            fn();
        });
        processQueue();
    }


    function runTask(key, task) {
        if (hasError) return;

        var taskCallback = onlyOnce(function(err, result) {
            runningTasks--;
            if (arguments.length > 2) {
                result = slice(arguments, 1);
            }
            if (err) {
                var safeResults = {};
                baseForOwn(results, function(val, rkey) {
                    safeResults[rkey] = val;
                });
                safeResults[key] = result;
                hasError = true;
                listeners = Object.create(null);

                callback(err, safeResults);
            } else {
                results[key] = result;
                taskComplete(key);
            }
        });

        runningTasks++;
        var taskFn = wrapAsync(task[task.length - 1]);
        if (task.length > 1) {
            taskFn(results, taskCallback);
        } else {
            taskFn(taskCallback);
        }
    }

    function checkForDeadlocks() {
        // Kahn's algorithm
        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
        var currentTask;
        var counter = 0;
        while (readyToCheck.length) {
            currentTask = readyToCheck.pop();
            counter++;
            arrayEach(getDependents(currentTask), function (dependent) {
                if (--uncheckedDependencies[dependent] === 0) {
                    readyToCheck.push(dependent);
                }
            });
        }

        if (counter !== numTasks) {
            throw new Error(
                'async.auto cannot execute tasks due to a recursive dependency'
            );
        }
    }

    function getDependents(taskName) {
        var result = [];
        baseForOwn(tasks, function (task, key) {
            if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {
                result.push(key);
            }
        });
        return result;
    }
};

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined;
var symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the last unmatched string symbol.
 */
function charsEndIndex(strSymbols, chrSymbols) {
  var index = strSymbols.length;

  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

/**
 * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the first unmatched string symbol.
 */
function charsStartIndex(strSymbols, chrSymbols) {
  var index = -1,
      length = strSymbols.length;

  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff';
var rsComboMarksRange = '\\u0300-\\u036f';
var reComboHalfMarksRange = '\\ufe20-\\ufe2f';
var rsComboSymbolsRange = '\\u20d0-\\u20ff';
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

/** Used to compose unicode character classes. */
var rsAstralRange$1 = '\\ud800-\\udfff';
var rsComboMarksRange$1 = '\\u0300-\\u036f';
var reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f';
var rsComboSymbolsRange$1 = '\\u20d0-\\u20ff';
var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
var rsVarRange$1 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange$1 + ']';
var rsCombo = '[' + rsComboRange$1 + ']';
var rsFitz = '\\ud83c[\\udffb-\\udfff]';
var rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';
var rsNonAstral = '[^' + rsAstralRange$1 + ']';
var rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}';
var rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]';
var rsZWJ$1 = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?';
var rsOptVar = '[' + rsVarRange$1 + ']?';
var rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/**
 * Removes leading and trailing whitespace or specified characters from `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the trimmed string.
 * @example
 *
 * _.trim('  abc  ');
 * // => 'abc'
 *
 * _.trim('-_-abc-_-', '_-');
 * // => 'abc'
 *
 * _.map(['  foo  ', '  bar  '], _.trim);
 * // => ['foo', 'bar']
 */
function trim(string, chars, guard) {
  string = toString(string);
  if (string && (guard || chars === undefined)) {
    return string.replace(reTrim, '');
  }
  if (!string || !(chars = baseToString(chars))) {
    return string;
  }
  var strSymbols = stringToArray(string),
      chrSymbols = stringToArray(chars),
      start = charsStartIndex(strSymbols, chrSymbols),
      end = charsEndIndex(strSymbols, chrSymbols) + 1;

  return castSlice(strSymbols, start, end).join('');
}

var FN_ARGS = /^(?:async\s+)?(function)?\s*[^\(]*\(\s*([^\)]*)\)/m;
var FN_ARG_SPLIT = /,/;
var FN_ARG = /(=.+)?(\s*)$/;
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;

function parseParams(func) {
    func = func.toString().replace(STRIP_COMMENTS, '');
    func = func.match(FN_ARGS)[2].replace(' ', '');
    func = func ? func.split(FN_ARG_SPLIT) : [];
    func = func.map(function (arg){
        return trim(arg.replace(FN_ARG, ''));
    });
    return func;
}

/**
 * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent
 * tasks are specified as parameters to the function, after the usual callback
 * parameter, with the parameter names matching the names of the tasks it
 * depends on. This can provide even more readable task graphs which can be
 * easier to maintain.
 *
 * If a final callback is specified, the task results are similarly injected,
 * specified as named parameters after the initial error parameter.
 *
 * The autoInject function is purely syntactic sugar and its semantics are
 * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.
 *
 * @name autoInject
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.auto]{@link module:ControlFlow.auto}
 * @category Control Flow
 * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of
 * the form 'func([dependencies...], callback). The object's key of a property
 * serves as the name of the task defined by that property, i.e. can be used
 * when specifying requirements for other tasks.
 * * The `callback` parameter is a `callback(err, result)` which must be called
 *   when finished, passing an `error` (which can be `null`) and the result of
 *   the function's execution. The remaining parameters name other tasks on
 *   which the task is dependent, and the results from those tasks are the
 *   arguments of those parameters.
 * @param {Function} [callback] - An optional callback which is called when all
 * the tasks have been completed. It receives the `err` argument if any `tasks`
 * pass an error to their callback, and a `results` object with any completed
 * task results, similar to `auto`.
 * @example
 *
 * //  The example from `auto` can be rewritten as follows:
 * async.autoInject({
 *     get_data: function(callback) {
 *         // async code to get some data
 *         callback(null, 'data', 'converted to array');
 *     },
 *     make_folder: function(callback) {
 *         // async code to create a directory to store a file in
 *         // this is run at the same time as getting the data
 *         callback(null, 'folder');
 *     },
 *     write_file: function(get_data, make_folder, callback) {
 *         // once there is some data and the directory exists,
 *         // write the data to a file in the directory
 *         callback(null, 'filename');
 *     },
 *     email_link: function(write_file, callback) {
 *         // once the file is written let's email a link to it...
 *         // write_file contains the filename returned by write_file.
 *         callback(null, {'file':write_file, 'email':'user@example.com'});
 *     }
 * }, function(err, results) {
 *     console.log('err = ', err);
 *     console.log('email_link = ', results.email_link);
 * });
 *
 * // If you are using a JS minifier that mangles parameter names, `autoInject`
 * // will not work with plain functions, since the parameter names will be
 * // collapsed to a single letter identifier.  To work around this, you can
 * // explicitly specify the names of the parameters your task function needs
 * // in an array, similar to Angular.js dependency injection.
 *
 * // This still has an advantage over plain `auto`, since the results a task
 * // depends on are still spread into arguments.
 * async.autoInject({
 *     //...
 *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {
 *         callback(null, 'filename');
 *     }],
 *     email_link: ['write_file', function(write_file, callback) {
 *         callback(null, {'file':write_file, 'email':'user@example.com'});
 *     }]
 *     //...
 * }, function(err, results) {
 *     console.log('err = ', err);
 *     console.log('email_link = ', results.email_link);
 * });
 */
function autoInject(tasks, callback) {
    var newTasks = {};

    baseForOwn(tasks, function (taskFn, key) {
        var params;
        var fnIsAsync = isAsync(taskFn);
        var hasNoDeps =
            (!fnIsAsync && taskFn.length === 1) ||
            (fnIsAsync && taskFn.length === 0);

        if (isArray(taskFn)) {
            params = taskFn.slice(0, -1);
            taskFn = taskFn[taskFn.length - 1];

            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
        } else if (hasNoDeps) {
            // no dependencies, use the function as-is
            newTasks[key] = taskFn;
        } else {
            params = parseParams(taskFn);
            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
                throw new Error("autoInject task functions require explicit parameters.");
            }

            // remove callback param
            if (!fnIsAsync) params.pop();

            newTasks[key] = params.concat(newTask);
        }

        function newTask(results, taskCb) {
            var newArgs = arrayMap(params, function (name) {
                return results[name];
            });
            newArgs.push(taskCb);
            wrapAsync(taskFn).apply(null, newArgs);
        }
    });

    auto(newTasks, callback);
}

// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation
// used for queues. This implementation assumes that the node provided by the user can be modified
// to adjust the next and last properties. We implement only the minimal functionality
// for queue support.
function DLL() {
    this.head = this.tail = null;
    this.length = 0;
}

function setInitial(dll, node) {
    dll.length = 1;
    dll.head = dll.tail = node;
}

DLL.prototype.removeLink = function(node) {
    if (node.prev) node.prev.next = node.next;
    else this.head = node.next;
    if (node.next) node.next.prev = node.prev;
    else this.tail = node.prev;

    node.prev = node.next = null;
    this.length -= 1;
    return node;
};

DLL.prototype.empty = function () {
    while(this.head) this.shift();
    return this;
};

DLL.prototype.insertAfter = function(node, newNode) {
    newNode.prev = node;
    newNode.next = node.next;
    if (node.next) node.next.prev = newNode;
    else this.tail = newNode;
    node.next = newNode;
    this.length += 1;
};

DLL.prototype.insertBefore = function(node, newNode) {
    newNode.prev = node.prev;
    newNode.next = node;
    if (node.prev) node.prev.next = newNode;
    else this.head = newNode;
    node.prev = newNode;
    this.length += 1;
};

DLL.prototype.unshift = function(node) {
    if (this.head) this.insertBefore(this.head, node);
    else setInitial(this, node);
};

DLL.prototype.push = function(node) {
    if (this.tail) this.insertAfter(this.tail, node);
    else setInitial(this, node);
};

DLL.prototype.shift = function() {
    return this.head && this.removeLink(this.head);
};

DLL.prototype.pop = function() {
    return this.tail && this.removeLink(this.tail);
};

DLL.prototype.toArray = function () {
    var arr = Array(this.length);
    var curr = this.head;
    for(var idx = 0; idx < this.length; idx++) {
        arr[idx] = curr.data;
        curr = curr.next;
    }
    return arr;
};

DLL.prototype.remove = function (testFn) {
    var curr = this.head;
    while(!!curr) {
        var next = curr.next;
        if (testFn(curr)) {
            this.removeLink(curr);
        }
        curr = next;
    }
    return this;
};

function queue(worker, concurrency, payload) {
    if (concurrency == null) {
        concurrency = 1;
    }
    else if(concurrency === 0) {
        throw new Error('Concurrency must not be zero');
    }

    var _worker = wrapAsync(worker);
    var numRunning = 0;
    var workersList = [];

    var processingScheduled = false;
    function _insert(data, insertAtFront, callback) {
        if (callback != null && typeof callback !== 'function') {
            throw new Error('task callback must be a function');
        }
        q.started = true;
        if (!isArray(data)) {
            data = [data];
        }
        if (data.length === 0 && q.idle()) {
            // call drain immediately if there are no tasks
            return setImmediate$1(function() {
                q.drain();
            });
        }

        for (var i = 0, l = data.length; i < l; i++) {
            var item = {
                data: data[i],
                callback: callback || noop
            };

            if (insertAtFront) {
                q._tasks.unshift(item);
            } else {
                q._tasks.push(item);
            }
        }

        if (!processingScheduled) {
            processingScheduled = true;
            setImmediate$1(function() {
                processingScheduled = false;
                q.process();
            });
        }
    }

    function _next(tasks) {
        return function(err){
            numRunning -= 1;

            for (var i = 0, l = tasks.length; i < l; i++) {
                var task = tasks[i];

                var index = baseIndexOf(workersList, task, 0);
                if (index === 0) {
                    workersList.shift();
                } else if (index > 0) {
                    workersList.splice(index, 1);
                }

                task.callback.apply(task, arguments);

                if (err != null) {
                    q.error(err, task.data);
                }
            }

            if (numRunning <= (q.concurrency - q.buffer) ) {
                q.unsaturated();
            }

            if (q.idle()) {
                q.drain();
            }
            q.process();
        };
    }

    var isProcessing = false;
    var q = {
        _tasks: new DLL(),
        concurrency: concurrency,
        payload: payload,
        saturated: noop,
        unsaturated:noop,
        buffer: concurrency / 4,
        empty: noop,
        drain: noop,
        error: noop,
        started: false,
        paused: false,
        push: function (data, callback) {
            _insert(data, false, callback);
        },
        kill: function () {
            q.drain = noop;
            q._tasks.empty();
        },
        unshift: function (data, callback) {
            _insert(data, true, callback);
        },
        remove: function (testFn) {
            q._tasks.remove(testFn);
        },
        process: function () {
            // Avoid trying to start too many processing operations. This can occur
            // when callbacks resolve synchronously (#1267).
            if (isProcessing) {
                return;
            }
            isProcessing = true;
            while(!q.paused && numRunning < q.concurrency && q._tasks.length){
                var tasks = [], data = [];
                var l = q._tasks.length;
                if (q.payload) l = Math.min(l, q.payload);
                for (var i = 0; i < l; i++) {
                    var node = q._tasks.shift();
                    tasks.push(node);
                    workersList.push(node);
                    data.push(node.data);
                }

                numRunning += 1;

                if (q._tasks.length === 0) {
                    q.empty();
                }

                if (numRunning === q.concurrency) {
                    q.saturated();
                }

                var cb = onlyOnce(_next(tasks));
                _worker(data, cb);
            }
            isProcessing = false;
        },
        length: function () {
            return q._tasks.length;
        },
        running: function () {
            return numRunning;
        },
        workersList: function () {
            return workersList;
        },
        idle: function() {
            return q._tasks.length + numRunning === 0;
        },
        pause: function () {
            q.paused = true;
        },
        resume: function () {
            if (q.paused === false) { return; }
            q.paused = false;
            setImmediate$1(q.process);
        }
    };
    return q;
}

/**
 * A cargo of tasks for the worker function to complete. Cargo inherits all of
 * the same methods and event callbacks as [`queue`]{@link module:ControlFlow.queue}.
 * @typedef {Object} CargoObject
 * @memberOf module:ControlFlow
 * @property {Function} length - A function returning the number of items
 * waiting to be processed. Invoke like `cargo.length()`.
 * @property {number} payload - An `integer` for determining how many tasks
 * should be process per round. This property can be changed after a `cargo` is
 * created to alter the payload on-the-fly.
 * @property {Function} push - Adds `task` to the `queue`. The callback is
 * called once the `worker` has finished processing the task. Instead of a
 * single task, an array of `tasks` can be submitted. The respective callback is
 * used for every task in the list. Invoke like `cargo.push(task, [callback])`.
 * @property {Function} saturated - A callback that is called when the
 * `queue.length()` hits the concurrency and further tasks will be queued.
 * @property {Function} empty - A callback that is called when the last item
 * from the `queue` is given to a `worker`.
 * @property {Function} drain - A callback that is called when the last item
 * from the `queue` has returned from the `worker`.
 * @property {Function} idle - a function returning false if there are items
 * waiting or being processed, or true if not. Invoke like `cargo.idle()`.
 * @property {Function} pause - a function that pauses the processing of tasks
 * until `resume()` is called. Invoke like `cargo.pause()`.
 * @property {Function} resume - a function that resumes the processing of
 * queued tasks when the queue is paused. Invoke like `cargo.resume()`.
 * @property {Function} kill - a function that removes the `drain` callback and
 * empties remaining tasks from the queue forcing it to go idle. Invoke like `cargo.kill()`.
 */

/**
 * Creates a `cargo` object with the specified payload. Tasks added to the
 * cargo will be processed altogether (up to the `payload` limit). If the
 * `worker` is in progress, the task is queued until it becomes available. Once
 * the `worker` has completed some tasks, each callback of those tasks is
 * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
 * for how `cargo` and `queue` work.
 *
 * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers
 * at a time, cargo passes an array of tasks to a single worker, repeating
 * when the worker is finished.
 *
 * @name cargo
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.queue]{@link module:ControlFlow.queue}
 * @category Control Flow
 * @param {AsyncFunction} worker - An asynchronous function for processing an array
 * of queued tasks. Invoked with `(tasks, callback)`.
 * @param {number} [payload=Infinity] - An optional `integer` for determining
 * how many tasks should be processed per round; if omitted, the default is
 * unlimited.
 * @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can
 * attached as certain properties to listen for specific events during the
 * lifecycle of the cargo and inner queue.
 * @example
 *
 * // create a cargo object with payload 2
 * var cargo = async.cargo(function(tasks, callback) {
 *     for (var i=0; i<tasks.length; i++) {
 *         console.log('hello ' + tasks[i].name);
 *     }
 *     callback();
 * }, 2);
 *
 * // add some items
 * cargo.push({name: 'foo'}, function(err) {
 *     console.log('finished processing foo');
 * });
 * cargo.push({name: 'bar'}, function(err) {
 *     console.log('finished processing bar');
 * });
 * cargo.push({name: 'baz'}, function(err) {
 *     console.log('finished processing baz');
 * });
 */
function cargo(worker, payload) {
    return queue(worker, 1, payload);
}

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
 *
 * @name eachOfSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfSeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Invoked with (err).
 */
var eachOfSeries = doLimit(eachOfLimit, 1);

/**
 * Reduces `coll` into a single value using an async `iteratee` to return each
 * successive step. `memo` is the initial state of the reduction. This function
 * only operates in series.
 *
 * For performance reasons, it may make sense to split a call to this function
 * into a parallel map, and then use the normal `Array.prototype.reduce` on the
 * results. This function is for situations where each step in the reduction
 * needs to be async; if you can get the data before reducing it, then it's
 * probably a good idea to do so.
 *
 * @name reduce
 * @static
 * @memberOf module:Collections
 * @method
 * @alias inject
 * @alias foldl
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {*} memo - The initial state of the reduction.
 * @param {AsyncFunction} iteratee - A function applied to each item in the
 * array to produce the next step in the reduction.
 * The `iteratee` should complete with the next state of the reduction.
 * If the iteratee complete with an error, the reduction is stopped and the
 * main `callback` is immediately called with the error.
 * Invoked with (memo, item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the reduced value. Invoked with
 * (err, result).
 * @example
 *
 * async.reduce([1,2,3], 0, function(memo, item, callback) {
 *     // pointless async:
 *     process.nextTick(function() {
 *         callback(null, memo + item)
 *     });
 * }, function(err, result) {
 *     // result is now equal to the last value of memo, which is 6
 * });
 */
function reduce(coll, memo, iteratee, callback) {
    callback = once(callback || noop);
    var _iteratee = wrapAsync(iteratee);
    eachOfSeries(coll, function(x, i, callback) {
        _iteratee(memo, x, function(err, v) {
            memo = v;
            callback(err);
        });
    }, function(err) {
        callback(err, memo);
    });
}

/**
 * Version of the compose function that is more natural to read. Each function
 * consumes the return value of the previous function. It is the equivalent of
 * [compose]{@link module:ControlFlow.compose} with the arguments reversed.
 *
 * Each function is executed with the `this` binding of the composed function.
 *
 * @name seq
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.compose]{@link module:ControlFlow.compose}
 * @category Control Flow
 * @param {...AsyncFunction} functions - the asynchronous functions to compose
 * @returns {Function} a function that composes the `functions` in order
 * @example
 *
 * // Requires lodash (or underscore), express3 and dresende's orm2.
 * // Part of an app, that fetches cats of the logged user.
 * // This example uses `seq` function to avoid overnesting and error
 * // handling clutter.
 * app.get('/cats', function(request, response) {
 *     var User = request.models.User;
 *     async.seq(
 *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))
 *         function(user, fn) {
 *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))
 *         }
 *     )(req.session.user_id, function (err, cats) {
 *         if (err) {
 *             console.error(err);
 *             response.json({ status: 'error', message: err.message });
 *         } else {
 *             response.json({ status: 'ok', message: 'Cats found', data: cats });
 *         }
 *     });
 * });
 */
function seq(/*...functions*/) {
    var _functions = arrayMap(arguments, wrapAsync);
    return function(/*...args*/) {
        var args = slice(arguments);
        var that = this;

        var cb = args[args.length - 1];
        if (typeof cb == 'function') {
            args.pop();
        } else {
            cb = noop;
        }

        reduce(_functions, args, function(newargs, fn, cb) {
            fn.apply(that, newargs.concat(function(err/*, ...nextargs*/) {
                var nextargs = slice(arguments, 1);
                cb(err, nextargs);
            }));
        },
        function(err, results) {
            cb.apply(that, [err].concat(results));
        });
    };
}

/**
 * Creates a function which is a composition of the passed asynchronous
 * functions. Each function consumes the return value of the function that
 * follows. Composing functions `f()`, `g()`, and `h()` would produce the result
 * of `f(g(h()))`, only this version uses callbacks to obtain the return values.
 *
 * Each function is executed with the `this` binding of the composed function.
 *
 * @name compose
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {...AsyncFunction} functions - the asynchronous functions to compose
 * @returns {Function} an asynchronous function that is the composed
 * asynchronous `functions`
 * @example
 *
 * function add1(n, callback) {
 *     setTimeout(function () {
 *         callback(null, n + 1);
 *     }, 10);
 * }
 *
 * function mul3(n, callback) {
 *     setTimeout(function () {
 *         callback(null, n * 3);
 *     }, 10);
 * }
 *
 * var add1mul3 = async.compose(mul3, add1);
 * add1mul3(4, function (err, result) {
 *     // result now equals 15
 * });
 */
var compose = function(/*...args*/) {
    return seq.apply(null, slice(arguments).reverse());
};

var _concat = Array.prototype.concat;

/**
 * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.
 *
 * @name concatLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.concat]{@link module:Collections.concat}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
 * which should use an array as its result. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is an array
 * containing the concatenated results of the `iteratee` function. Invoked with
 * (err, results).
 */
var concatLimit = function(coll, limit, iteratee, callback) {
    callback = callback || noop;
    var _iteratee = wrapAsync(iteratee);
    mapLimit(coll, limit, function(val, callback) {
        _iteratee(val, function(err /*, ...args*/) {
            if (err) return callback(err);
            return callback(null, slice(arguments, 1));
        });
    }, function(err, mapResults) {
        var result = [];
        for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
                result = _concat.apply(result, mapResults[i]);
            }
        }

        return callback(err, result);
    });
};

/**
 * Applies `iteratee` to each item in `coll`, concatenating the results. Returns
 * the concatenated list. The `iteratee`s are called in parallel, and the
 * results are concatenated as they return. There is no guarantee that the
 * results array will be returned in the original order of `coll` passed to the
 * `iteratee` function.
 *
 * @name concat
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
 * which should use an array as its result. Invoked with (item, callback).
 * @param {Function} [callback(err)] - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is an array
 * containing the concatenated results of the `iteratee` function. Invoked with
 * (err, results).
 * @example
 *
 * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {
 *     // files is now a list of filenames that exist in the 3 directories
 * });
 */
var concat = doLimit(concatLimit, Infinity);

/**
 * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.
 *
 * @name concatSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.concat]{@link module:Collections.concat}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.
 * The iteratee should complete with an array an array of results.
 * Invoked with (item, callback).
 * @param {Function} [callback(err)] - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is an array
 * containing the concatenated results of the `iteratee` function. Invoked with
 * (err, results).
 */
var concatSeries = doLimit(concatLimit, 1);

/**
 * Returns a function that when called, calls-back with the values provided.
 * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to
 * [`auto`]{@link module:ControlFlow.auto}.
 *
 * @name constant
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {...*} arguments... - Any number of arguments to automatically invoke
 * callback with.
 * @returns {AsyncFunction} Returns a function that when invoked, automatically
 * invokes the callback with the previous given arguments.
 * @example
 *
 * async.waterfall([
 *     async.constant(42),
 *     function (value, next) {
 *         // value === 42
 *     },
 *     //...
 * ], callback);
 *
 * async.waterfall([
 *     async.constant(filename, "utf8"),
 *     fs.readFile,
 *     function (fileData, next) {
 *         //...
 *     }
 *     //...
 * ], callback);
 *
 * async.auto({
 *     hostname: async.constant("https://server.net/"),
 *     port: findFreePort,
 *     launchServer: ["hostname", "port", function (options, cb) {
 *         startServer(options, cb);
 *     }],
 *     //...
 * }, callback);
 */
var constant = function(/*...values*/) {
    var values = slice(arguments);
    var args = [null].concat(values);
    return function (/*...ignoredArgs, callback*/) {
        var callback = arguments[arguments.length - 1];
        return callback.apply(this, args);
    };
};

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

function _createTester(check, getResult) {
    return function(eachfn, arr, iteratee, cb) {
        cb = cb || noop;
        var testPassed = false;
        var testResult;
        eachfn(arr, function(value, _, callback) {
            iteratee(value, function(err, result) {
                if (err) {
                    callback(err);
                } else if (check(result) && !testResult) {
                    testPassed = true;
                    testResult = getResult(true, value);
                    callback(null, breakLoop);
                } else {
                    callback();
                }
            });
        }, function(err) {
            if (err) {
                cb(err);
            } else {
                cb(null, testPassed ? testResult : getResult(false));
            }
        });
    };
}

function _findGetResult(v, x) {
    return x;
}

/**
 * Returns the first value in `coll` that passes an async truth test. The
 * `iteratee` is applied in parallel, meaning the first iteratee to return
 * `true` will fire the detect `callback` with that result. That means the
 * result might not be the first item in the original `coll` (in terms of order)
 * that passes the test.

 * If order within the original `coll` is important, then look at
 * [`detectSeries`]{@link module:Collections.detectSeries}.
 *
 * @name detect
 * @static
 * @memberOf module:Collections
 * @method
 * @alias find
 * @category Collections
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
 * The iteratee must complete with a boolean value as its result.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 * @example
 *
 * async.detect(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, result) {
 *     // result now equals the first file in the list that exists
 * });
 */
var detect = doParallel(_createTester(identity, _findGetResult));

/**
 * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name detectLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.detect]{@link module:Collections.detect}
 * @alias findLimit
 * @category Collections
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
 * The iteratee must complete with a boolean value as its result.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 */
var detectLimit = doParallelLimit(_createTester(identity, _findGetResult));

/**
 * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.
 *
 * @name detectSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.detect]{@link module:Collections.detect}
 * @alias findSeries
 * @category Collections
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
 * The iteratee must complete with a boolean value as its result.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 */
var detectSeries = doLimit(detectLimit, 1);

function consoleFunc(name) {
    return function (fn/*, ...args*/) {
        var args = slice(arguments, 1);
        args.push(function (err/*, ...args*/) {
            var args = slice(arguments, 1);
            if (typeof console === 'object') {
                if (err) {
                    if (console.error) {
                        console.error(err);
                    }
                } else if (console[name]) {
                    arrayEach(args, function (x) {
                        console[name](x);
                    });
                }
            }
        });
        wrapAsync(fn).apply(null, args);
    };
}

/**
 * Logs the result of an [`async` function]{@link AsyncFunction} to the
 * `console` using `console.dir` to display the properties of the resulting object.
 * Only works in Node.js or in browsers that support `console.dir` and
 * `console.error` (such as FF and Chrome).
 * If multiple arguments are returned from the async function,
 * `console.dir` is called on each argument in order.
 *
 * @name dir
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} function - The function you want to eventually apply
 * all arguments to.
 * @param {...*} arguments... - Any number of arguments to apply to the function.
 * @example
 *
 * // in a module
 * var hello = function(name, callback) {
 *     setTimeout(function() {
 *         callback(null, {hello: name});
 *     }, 1000);
 * };
 *
 * // in the node repl
 * node> async.dir(hello, 'world');
 * {hello: 'world'}
 */
var dir = consoleFunc('dir');

/**
 * The post-check version of [`during`]{@link module:ControlFlow.during}. To reflect the difference in
 * the order of operations, the arguments `test` and `fn` are switched.
 *
 * Also a version of [`doWhilst`]{@link module:ControlFlow.doWhilst} with asynchronous `test` function.
 * @name doDuring
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.during]{@link module:ControlFlow.during}
 * @category Control Flow
 * @param {AsyncFunction} fn - An async function which is called each time
 * `test` passes. Invoked with (callback).
 * @param {AsyncFunction} test - asynchronous truth test to perform before each
 * execution of `fn`. Invoked with (...args, callback), where `...args` are the
 * non-error args from the previous callback of `fn`.
 * @param {Function} [callback] - A callback which is called after the test
 * function has failed and repeated execution of `fn` has stopped. `callback`
 * will be passed an error if one occurred, otherwise `null`.
 */
function doDuring(fn, test, callback) {
    callback = onlyOnce(callback || noop);
    var _fn = wrapAsync(fn);
    var _test = wrapAsync(test);

    function next(err/*, ...args*/) {
        if (err) return callback(err);
        var args = slice(arguments, 1);
        args.push(check);
        _test.apply(this, args);
    }

    function check(err, truth) {
        if (err) return callback(err);
        if (!truth) return callback(null);
        _fn(next);
    }

    check(null, true);

}

/**
 * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in
 * the order of operations, the arguments `test` and `iteratee` are switched.
 *
 * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.
 *
 * @name doWhilst
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.whilst]{@link module:ControlFlow.whilst}
 * @category Control Flow
 * @param {AsyncFunction} iteratee - A function which is called each time `test`
 * passes. Invoked with (callback).
 * @param {Function} test - synchronous truth test to perform after each
 * execution of `iteratee`. Invoked with any non-error callback results of
 * `iteratee`.
 * @param {Function} [callback] - A callback which is called after the test
 * function has failed and repeated execution of `iteratee` has stopped.
 * `callback` will be passed an error and any arguments passed to the final
 * `iteratee`'s callback. Invoked with (err, [results]);
 */
function doWhilst(iteratee, test, callback) {
    callback = onlyOnce(callback || noop);
    var _iteratee = wrapAsync(iteratee);
    var next = function(err/*, ...args*/) {
        if (err) return callback(err);
        var args = slice(arguments, 1);
        if (test.apply(this, args)) return _iteratee(next);
        callback.apply(null, [null].concat(args));
    };
    _iteratee(next);
}

/**
 * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the
 * argument ordering differs from `until`.
 *
 * @name doUntil
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}
 * @category Control Flow
 * @param {AsyncFunction} iteratee - An async function which is called each time
 * `test` fails. Invoked with (callback).
 * @param {Function} test - synchronous truth test to perform after each
 * execution of `iteratee`. Invoked with any non-error callback results of
 * `iteratee`.
 * @param {Function} [callback] - A callback which is called after the test
 * function has passed and repeated execution of `iteratee` has stopped. `callback`
 * will be passed an error and any arguments passed to the final `iteratee`'s
 * callback. Invoked with (err, [results]);
 */
function doUntil(iteratee, test, callback) {
    doWhilst(iteratee, function() {
        return !test.apply(this, arguments);
    }, callback);
}

/**
 * Like [`whilst`]{@link module:ControlFlow.whilst}, except the `test` is an asynchronous function that
 * is passed a callback in the form of `function (err, truth)`. If error is
 * passed to `test` or `fn`, the main callback is immediately called with the
 * value of the error.
 *
 * @name during
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.whilst]{@link module:ControlFlow.whilst}
 * @category Control Flow
 * @param {AsyncFunction} test - asynchronous truth test to perform before each
 * execution of `fn`. Invoked with (callback).
 * @param {AsyncFunction} fn - An async function which is called each time
 * `test` passes. Invoked with (callback).
 * @param {Function} [callback] - A callback which is called after the test
 * function has failed and repeated execution of `fn` has stopped. `callback`
 * will be passed an error, if one occurred, otherwise `null`.
 * @example
 *
 * var count = 0;
 *
 * async.during(
 *     function (callback) {
 *         return callback(null, count < 5);
 *     },
 *     function (callback) {
 *         count++;
 *         setTimeout(callback, 1000);
 *     },
 *     function (err) {
 *         // 5 seconds have passed
 *     }
 * );
 */
function during(test, fn, callback) {
    callback = onlyOnce(callback || noop);
    var _fn = wrapAsync(fn);
    var _test = wrapAsync(test);

    function next(err) {
        if (err) return callback(err);
        _test(check);
    }

    function check(err, truth) {
        if (err) return callback(err);
        if (!truth) return callback(null);
        _fn(next);
    }

    _test(check);
}

function _withoutIndex(iteratee) {
    return function (value, index, callback) {
        return iteratee(value, callback);
    };
}

/**
 * Applies the function `iteratee` to each item in `coll`, in parallel.
 * The `iteratee` is called with an item from the list, and a callback for when
 * it has finished. If the `iteratee` passes an error to its `callback`, the
 * main `callback` (for the `each` function) is immediately called with the
 * error.
 *
 * Note, that since this function applies `iteratee` to each item in parallel,
 * there is no guarantee that the iteratee functions will complete in order.
 *
 * @name each
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEach
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to
 * each item in `coll`. Invoked with (item, callback).
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOf`.
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @example
 *
 * // assuming openFiles is an array of file names and saveFile is a function
 * // to save the modified contents of that file:
 *
 * async.each(openFiles, saveFile, function(err){
 *   // if any of the saves produced an error, err would equal that error
 * });
 *
 * // assuming openFiles is an array of file names
 * async.each(openFiles, function(file, callback) {
 *
 *     // Perform operation on file here.
 *     console.log('Processing file ' + file);
 *
 *     if( file.length > 32 ) {
 *       console.log('This file name is too long');
 *       callback('File name too long');
 *     } else {
 *       // Do work to process file here
 *       console.log('File processed');
 *       callback();
 *     }
 * }, function(err) {
 *     // if any of the file processing produced an error, err would equal that error
 *     if( err ) {
 *       // One of the iterations produced an error.
 *       // All processing will now stop.
 *       console.log('A file failed to process');
 *     } else {
 *       console.log('All files have been processed successfully');
 *     }
 * });
 */
function eachLimit(coll, iteratee, callback) {
    eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}

/**
 * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.
 *
 * @name eachLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.each]{@link module:Collections.each}
 * @alias forEachLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOfLimit`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 */
function eachLimit$1(coll, limit, iteratee, callback) {
    _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}

/**
 * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.
 *
 * @name eachSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.each]{@link module:Collections.each}
 * @alias forEachSeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each
 * item in `coll`.
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOfSeries`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 */
var eachSeries = doLimit(eachLimit$1, 1);

/**
 * Wrap an async function and ensure it calls its callback on a later tick of
 * the event loop.  If the function already calls its callback on a next tick,
 * no extra deferral is added. This is useful for preventing stack overflows
 * (`RangeError: Maximum call stack size exceeded`) and generally keeping
 * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)
 * contained. ES2017 `async` functions are returned as-is -- they are immune
 * to Zalgo's corrupting influences, as they always resolve on a later tick.
 *
 * @name ensureAsync
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} fn - an async function, one that expects a node-style
 * callback as its last argument.
 * @returns {AsyncFunction} Returns a wrapped function with the exact same call
 * signature as the function passed in.
 * @example
 *
 * function sometimesAsync(arg, callback) {
 *     if (cache[arg]) {
 *         return callback(null, cache[arg]); // this would be synchronous!!
 *     } else {
 *         doSomeIO(arg, callback); // this IO would be asynchronous
 *     }
 * }
 *
 * // this has a risk of stack overflows if many results are cached in a row
 * async.mapSeries(args, sometimesAsync, done);
 *
 * // this will defer sometimesAsync's callback if necessary,
 * // preventing stack overflows
 * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
 */
function ensureAsync(fn) {
    if (isAsync(fn)) return fn;
    return initialParams(function (args, callback) {
        var sync = true;
        args.push(function () {
            var innerArgs = arguments;
            if (sync) {
                setImmediate$1(function () {
                    callback.apply(null, innerArgs);
                });
            } else {
                callback.apply(null, innerArgs);
            }
        });
        fn.apply(this, args);
        sync = false;
    });
}

function notId(v) {
    return !v;
}

/**
 * Returns `true` if every element in `coll` satisfies an async test. If any
 * iteratee call returns `false`, the main `callback` is immediately called.
 *
 * @name every
 * @static
 * @memberOf module:Collections
 * @method
 * @alias all
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collection in parallel.
 * The iteratee must complete with a boolean result value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 * @example
 *
 * async.every(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, result) {
 *     // if result is true then every file exists
 * });
 */
var every = doParallel(_createTester(notId, notId));

/**
 * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.
 *
 * @name everyLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.every]{@link module:Collections.every}
 * @alias allLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collection in parallel.
 * The iteratee must complete with a boolean result value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 */
var everyLimit = doParallelLimit(_createTester(notId, notId));

/**
 * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.
 *
 * @name everySeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.every]{@link module:Collections.every}
 * @alias allSeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collection in series.
 * The iteratee must complete with a boolean result value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 */
var everySeries = doLimit(everyLimit, 1);

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

function filterArray(eachfn, arr, iteratee, callback) {
    var truthValues = new Array(arr.length);
    eachfn(arr, function (x, index, callback) {
        iteratee(x, function (err, v) {
            truthValues[index] = !!v;
            callback(err);
        });
    }, function (err) {
        if (err) return callback(err);
        var results = [];
        for (var i = 0; i < arr.length; i++) {
            if (truthValues[i]) results.push(arr[i]);
        }
        callback(null, results);
    });
}

function filterGeneric(eachfn, coll, iteratee, callback) {
    var results = [];
    eachfn(coll, function (x, index, callback) {
        iteratee(x, function (err, v) {
            if (err) {
                callback(err);
            } else {
                if (v) {
                    results.push({index: index, value: x});
                }
                callback();
            }
        });
    }, function (err) {
        if (err) {
            callback(err);
        } else {
            callback(null, arrayMap(results.sort(function (a, b) {
                return a.index - b.index;
            }), baseProperty('value')));
        }
    });
}

function _filter(eachfn, coll, iteratee, callback) {
    var filter = isArrayLike(coll) ? filterArray : filterGeneric;
    filter(eachfn, coll, wrapAsync(iteratee), callback || noop);
}

/**
 * Returns a new array of all the values in `coll` which pass an async truth
 * test. This operation is performed in parallel, but the results array will be
 * in the same order as the original.
 *
 * @name filter
 * @static
 * @memberOf module:Collections
 * @method
 * @alias select
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @example
 *
 * async.filter(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, results) {
 *     // results now equals an array of the existing files
 * });
 */
var filter = doParallel(_filter);

/**
 * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name filterLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]{@link module:Collections.filter}
 * @alias selectLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 */
var filterLimit = doParallelLimit(_filter);

/**
 * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.
 *
 * @name filterSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]{@link module:Collections.filter}
 * @alias selectSeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results)
 */
var filterSeries = doLimit(filterLimit, 1);

/**
 * Calls the asynchronous function `fn` with a callback parameter that allows it
 * to call itself again, in series, indefinitely.

 * If an error is passed to the callback then `errback` is called with the
 * error, and execution stops, otherwise it will never be called.
 *
 * @name forever
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {AsyncFunction} fn - an async function to call repeatedly.
 * Invoked with (next).
 * @param {Function} [errback] - when `fn` passes an error to it's callback,
 * this function will be called, and execution stops. Invoked with (err).
 * @example
 *
 * async.forever(
 *     function(next) {
 *         // next is suitable for passing to things that need a callback(err [, whatever]);
 *         // it will result in this function being called again.
 *     },
 *     function(err) {
 *         // if next is called with a value in its first parameter, it will appear
 *         // in here as 'err', and execution will stop.
 *     }
 * );
 */
function forever(fn, errback) {
    var done = onlyOnce(errback || noop);
    var task = wrapAsync(ensureAsync(fn));

    function next(err) {
        if (err) return done(err);
        task(next);
    }
    next();
}

/**
 * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.
 *
 * @name groupByLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.groupBy]{@link module:Collections.groupBy}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a `key` to group the value under.
 * Invoked with (value, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Result is an `Object` whoses
 * properties are arrays of values which returned the corresponding key.
 */
var groupByLimit = function(coll, limit, iteratee, callback) {
    callback = callback || noop;
    var _iteratee = wrapAsync(iteratee);
    mapLimit(coll, limit, function(val, callback) {
        _iteratee(val, function(err, key) {
            if (err) return callback(err);
            return callback(null, {key: key, val: val});
        });
    }, function(err, mapResults) {
        var result = {};
        // from MDN, handle object having an `hasOwnProperty` prop
        var hasOwnProperty = Object.prototype.hasOwnProperty;

        for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
                var key = mapResults[i].key;
                var val = mapResults[i].val;

                if (hasOwnProperty.call(result, key)) {
                    result[key].push(val);
                } else {
                    result[key] = [val];
                }
            }
        }

        return callback(err, result);
    });
};

/**
 * Returns a new object, where each value corresponds to an array of items, from
 * `coll`, that returned the corresponding key. That is, the keys of the object
 * correspond to the values passed to the `iteratee` callback.
 *
 * Note: Since this function applies the `iteratee` to each item in parallel,
 * there is no guarantee that the `iteratee` functions will complete in order.
 * However, the values for each key in the `result` will be in the same order as
 * the original `coll`. For Objects, the values will roughly be in the order of
 * the original Objects' keys (but this can vary across JavaScript engines).
 *
 * @name groupBy
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a `key` to group the value under.
 * Invoked with (value, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Result is an `Object` whoses
 * properties are arrays of values which returned the corresponding key.
 * @example
 *
 * async.groupBy(['userId1', 'userId2', 'userId3'], function(userId, callback) {
 *     db.findById(userId, function(err, user) {
 *         if (err) return callback(err);
 *         return callback(null, user.age);
 *     });
 * }, function(err, result) {
 *     // result is object containing the userIds grouped by age
 *     // e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};
 * });
 */
var groupBy = doLimit(groupByLimit, Infinity);

/**
 * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.
 *
 * @name groupBySeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.groupBy]{@link module:Collections.groupBy}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a `key` to group the value under.
 * Invoked with (value, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Result is an `Object` whoses
 * properties are arrays of values which returned the corresponding key.
 */
var groupBySeries = doLimit(groupByLimit, 1);

/**
 * Logs the result of an `async` function to the `console`. Only works in
 * Node.js or in browsers that support `console.log` and `console.error` (such
 * as FF and Chrome). If multiple arguments are returned from the async
 * function, `console.log` is called on each argument in order.
 *
 * @name log
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} function - The function you want to eventually apply
 * all arguments to.
 * @param {...*} arguments... - Any number of arguments to apply to the function.
 * @example
 *
 * // in a module
 * var hello = function(name, callback) {
 *     setTimeout(function() {
 *         callback(null, 'hello ' + name);
 *     }, 1000);
 * };
 *
 * // in the node repl
 * node> async.log(hello, 'world');
 * 'hello world'
 */
var log = consoleFunc('log');

/**
 * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name mapValuesLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.mapValues]{@link module:Collections.mapValues}
 * @category Collection
 * @param {Object} obj - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - A function to apply to each value and key
 * in `coll`.
 * The iteratee should complete with the transformed value as its result.
 * Invoked with (value, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. `result` is a new object consisting
 * of each key from `obj`, with each transformed value on the right-hand side.
 * Invoked with (err, result).
 */
function mapValuesLimit(obj, limit, iteratee, callback) {
    callback = once(callback || noop);
    var newObj = {};
    var _iteratee = wrapAsync(iteratee);
    eachOfLimit(obj, limit, function(val, key, next) {
        _iteratee(val, key, function (err, result) {
            if (err) return next(err);
            newObj[key] = result;
            next();
        });
    }, function (err) {
        callback(err, newObj);
    });
}

/**
 * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.
 *
 * Produces a new Object by mapping each value of `obj` through the `iteratee`
 * function. The `iteratee` is called each `value` and `key` from `obj` and a
 * callback for when it has finished processing. Each of these callbacks takes
 * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`
 * passes an error to its callback, the main `callback` (for the `mapValues`
 * function) is immediately called with the error.
 *
 * Note, the order of the keys in the result is not guaranteed.  The keys will
 * be roughly in the order they complete, (but this is very engine-specific)
 *
 * @name mapValues
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Object} obj - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each value and key
 * in `coll`.
 * The iteratee should complete with the transformed value as its result.
 * Invoked with (value, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. `result` is a new object consisting
 * of each key from `obj`, with each transformed value on the right-hand side.
 * Invoked with (err, result).
 * @example
 *
 * async.mapValues({
 *     f1: 'file1',
 *     f2: 'file2',
 *     f3: 'file3'
 * }, function (file, key, callback) {
 *   fs.stat(file, callback);
 * }, function(err, result) {
 *     // result is now a map of stats for each file, e.g.
 *     // {
 *     //     f1: [stats for file1],
 *     //     f2: [stats for file2],
 *     //     f3: [stats for file3]
 *     // }
 * });
 */

var mapValues = doLimit(mapValuesLimit, Infinity);

/**
 * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.
 *
 * @name mapValuesSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.mapValues]{@link module:Collections.mapValues}
 * @category Collection
 * @param {Object} obj - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each value and key
 * in `coll`.
 * The iteratee should complete with the transformed value as its result.
 * Invoked with (value, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. `result` is a new object consisting
 * of each key from `obj`, with each transformed value on the right-hand side.
 * Invoked with (err, result).
 */
var mapValuesSeries = doLimit(mapValuesLimit, 1);

function has(obj, key) {
    return key in obj;
}

/**
 * Caches the results of an async function. When creating a hash to store
 * function results against, the callback is omitted from the hash and an
 * optional hash function can be used.
 *
 * If no hash function is specified, the first argument is used as a hash key,
 * which may work reasonably if it is a string or a data type that converts to a
 * distinct string. Note that objects and arrays will not behave reasonably.
 * Neither will cases where the other arguments are significant. In such cases,
 * specify your own hash function.
 *
 * The cache of results is exposed as the `memo` property of the function
 * returned by `memoize`.
 *
 * @name memoize
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} fn - The async function to proxy and cache results from.
 * @param {Function} hasher - An optional function for generating a custom hash
 * for storing results. It has all the arguments applied to it apart from the
 * callback, and must be synchronous.
 * @returns {AsyncFunction} a memoized version of `fn`
 * @example
 *
 * var slow_fn = function(name, callback) {
 *     // do something
 *     callback(null, result);
 * };
 * var fn = async.memoize(slow_fn);
 *
 * // fn can now be used as if it were slow_fn
 * fn('some name', function() {
 *     // callback
 * });
 */
function memoize(fn, hasher) {
    var memo = Object.create(null);
    var queues = Object.create(null);
    hasher = hasher || identity;
    var _fn = wrapAsync(fn);
    var memoized = initialParams(function memoized(args, callback) {
        var key = hasher.apply(null, args);
        if (has(memo, key)) {
            setImmediate$1(function() {
                callback.apply(null, memo[key]);
            });
        } else if (has(queues, key)) {
            queues[key].push(callback);
        } else {
            queues[key] = [callback];
            _fn.apply(null, args.concat(function(/*args*/) {
                var args = slice(arguments);
                memo[key] = args;
                var q = queues[key];
                delete queues[key];
                for (var i = 0, l = q.length; i < l; i++) {
                    q[i].apply(null, args);
                }
            }));
        }
    });
    memoized.memo = memo;
    memoized.unmemoized = fn;
    return memoized;
}

/**
 * Calls `callback` on a later loop around the event loop. In Node.js this just
 * calls `process.nextTick`.  In the browser it will use `setImmediate` if
 * available, otherwise `setTimeout(callback, 0)`, which means other higher
 * priority events may precede the execution of `callback`.
 *
 * This is used internally for browser-compatibility purposes.
 *
 * @name nextTick
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.setImmediate]{@link module:Utils.setImmediate}
 * @category Util
 * @param {Function} callback - The function to call on a later loop around
 * the event loop. Invoked with (args...).
 * @param {...*} args... - any number of additional arguments to pass to the
 * callback on the next tick.
 * @example
 *
 * var call_order = [];
 * async.nextTick(function() {
 *     call_order.push('two');
 *     // call_order now equals ['one','two']
 * });
 * call_order.push('one');
 *
 * async.setImmediate(function (a, b, c) {
 *     // a, b, and c equal 1, 2, and 3
 * }, 1, 2, 3);
 */
var _defer$1;

if (hasNextTick) {
    _defer$1 = process.nextTick;
} else if (hasSetImmediate) {
    _defer$1 = setImmediate;
} else {
    _defer$1 = fallback;
}

var nextTick = wrap(_defer$1);

function _parallel(eachfn, tasks, callback) {
    callback = callback || noop;
    var results = isArrayLike(tasks) ? [] : {};

    eachfn(tasks, function (task, key, callback) {
        wrapAsync(task)(function (err, result) {
            if (arguments.length > 2) {
                result = slice(arguments, 1);
            }
            results[key] = result;
            callback(err);
        });
    }, function (err) {
        callback(err, results);
    });
}

/**
 * Run the `tasks` collection of functions in parallel, without waiting until
 * the previous function has completed. If any of the functions pass an error to
 * its callback, the main `callback` is immediately called with the value of the
 * error. Once the `tasks` have completed, the results are passed to the final
 * `callback` as an array.
 *
 * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
 * parallel execution of code.  If your tasks do not use any timers or perform
 * any I/O, they will actually be executed in series.  Any synchronous setup
 * sections for each task will happen one after the other.  JavaScript remains
 * single-threaded.
 *
 * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the
 * execution of other tasks when a task fails.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 * results from {@link async.parallel}.
 *
 * @name parallel
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} tasks - A collection of
 * [async functions]{@link AsyncFunction} to run.
 * Each async function can complete with any number of optional `result` values.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed successfully. This function gets a results array
 * (or object) containing all the result arguments passed to the task callbacks.
 * Invoked with (err, results).
 *
 * @example
 * async.parallel([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     // the results array will equal ['one','two'] even though
 *     // the second function had a shorter timeout.
 * });
 *
 * // an example using an object instead of an array
 * async.parallel({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     // results is now equals to: {one: 1, two: 2}
 * });
 */
function parallelLimit(tasks, callback) {
    _parallel(eachOf, tasks, callback);
}

/**
 * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name parallelLimit
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.parallel]{@link module:ControlFlow.parallel}
 * @category Control Flow
 * @param {Array|Iterable|Object} tasks - A collection of
 * [async functions]{@link AsyncFunction} to run.
 * Each async function can complete with any number of optional `result` values.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed successfully. This function gets a results array
 * (or object) containing all the result arguments passed to the task callbacks.
 * Invoked with (err, results).
 */
function parallelLimit$1(tasks, limit, callback) {
    _parallel(_eachOfLimit(limit), tasks, callback);
}

/**
 * A queue of tasks for the worker function to complete.
 * @typedef {Object} QueueObject
 * @memberOf module:ControlFlow
 * @property {Function} length - a function returning the number of items
 * waiting to be processed. Invoke with `queue.length()`.
 * @property {boolean} started - a boolean indicating whether or not any
 * items have been pushed and processed by the queue.
 * @property {Function} running - a function returning the number of items
 * currently being processed. Invoke with `queue.running()`.
 * @property {Function} workersList - a function returning the array of items
 * currently being processed. Invoke with `queue.workersList()`.
 * @property {Function} idle - a function returning false if there are items
 * waiting or being processed, or true if not. Invoke with `queue.idle()`.
 * @property {number} concurrency - an integer for determining how many `worker`
 * functions should be run in parallel. This property can be changed after a
 * `queue` is created to alter the concurrency on-the-fly.
 * @property {Function} push - add a new task to the `queue`. Calls `callback`
 * once the `worker` has finished processing the task. Instead of a single task,
 * a `tasks` array can be submitted. The respective callback is used for every
 * task in the list. Invoke with `queue.push(task, [callback])`,
 * @property {Function} unshift - add a new task to the front of the `queue`.
 * Invoke with `queue.unshift(task, [callback])`.
 * @property {Function} remove - remove items from the queue that match a test
 * function.  The test function will be passed an object with a `data` property,
 * and a `priority` property, if this is a
 * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.
 * Invoked with `queue.remove(testFn)`, where `testFn` is of the form
 * `function ({data, priority}) {}` and returns a Boolean.
 * @property {Function} saturated - a callback that is called when the number of
 * running workers hits the `concurrency` limit, and further tasks will be
 * queued.
 * @property {Function} unsaturated - a callback that is called when the number
 * of running workers is less than the `concurrency` & `buffer` limits, and
 * further tasks will not be queued.
 * @property {number} buffer - A minimum threshold buffer in order to say that
 * the `queue` is `unsaturated`.
 * @property {Function} empty - a callback that is called when the last item
 * from the `queue` is given to a `worker`.
 * @property {Function} drain - a callback that is called when the last item
 * from the `queue` has returned from the `worker`.
 * @property {Function} error - a callback that is called when a task errors.
 * Has the signature `function(error, task)`.
 * @property {boolean} paused - a boolean for determining whether the queue is
 * in a paused state.
 * @property {Function} pause - a function that pauses the processing of tasks
 * until `resume()` is called. Invoke with `queue.pause()`.
 * @property {Function} resume - a function that resumes the processing of
 * queued tasks when the queue is paused. Invoke with `queue.resume()`.
 * @property {Function} kill - a function that removes the `drain` callback and
 * empties remaining tasks from the queue forcing it to go idle. No more tasks
 * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.
 */

/**
 * Creates a `queue` object with the specified `concurrency`. Tasks added to the
 * `queue` are processed in parallel (up to the `concurrency` limit). If all
 * `worker`s are in progress, the task is queued until one becomes available.
 * Once a `worker` completes a `task`, that `task`'s callback is called.
 *
 * @name queue
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {AsyncFunction} worker - An async function for processing a queued task.
 * If you want to handle errors from an individual task, pass a callback to
 * `q.push()`. Invoked with (task, callback).
 * @param {number} [concurrency=1] - An `integer` for determining how many
 * `worker` functions should be run in parallel.  If omitted, the concurrency
 * defaults to `1`.  If the concurrency is `0`, an error is thrown.
 * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can
 * attached as certain properties to listen for specific events during the
 * lifecycle of the queue.
 * @example
 *
 * // create a queue object with concurrency 2
 * var q = async.queue(function(task, callback) {
 *     console.log('hello ' + task.name);
 *     callback();
 * }, 2);
 *
 * // assign a callback
 * q.drain = function() {
 *     console.log('all items have been processed');
 * };
 *
 * // add some items to the queue
 * q.push({name: 'foo'}, function(err) {
 *     console.log('finished processing foo');
 * });
 * q.push({name: 'bar'}, function (err) {
 *     console.log('finished processing bar');
 * });
 *
 * // add some items to the queue (batch-wise)
 * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {
 *     console.log('finished processing item');
 * });
 *
 * // add some items to the front of the queue
 * q.unshift({name: 'bar'}, function (err) {
 *     console.log('finished processing bar');
 * });
 */
var queue$1 = function (worker, concurrency) {
    var _worker = wrapAsync(worker);
    return queue(function (items, cb) {
        _worker(items[0], cb);
    }, concurrency, 1);
};

/**
 * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and
 * completed in ascending priority order.
 *
 * @name priorityQueue
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.queue]{@link module:ControlFlow.queue}
 * @category Control Flow
 * @param {AsyncFunction} worker - An async function for processing a queued task.
 * If you want to handle errors from an individual task, pass a callback to
 * `q.push()`.
 * Invoked with (task, callback).
 * @param {number} concurrency - An `integer` for determining how many `worker`
 * functions should be run in parallel.  If omitted, the concurrency defaults to
 * `1`.  If the concurrency is `0`, an error is thrown.
 * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two
 * differences between `queue` and `priorityQueue` objects:
 * * `push(task, priority, [callback])` - `priority` should be a number. If an
 *   array of `tasks` is given, all tasks will be assigned the same priority.
 * * The `unshift` method was removed.
 */
var priorityQueue = function(worker, concurrency) {
    // Start with a normal queue
    var q = queue$1(worker, concurrency);

    // Override push to accept second parameter representing priority
    q.push = function(data, priority, callback) {
        if (callback == null) callback = noop;
        if (typeof callback !== 'function') {
            throw new Error('task callback must be a function');
        }
        q.started = true;
        if (!isArray(data)) {
            data = [data];
        }
        if (data.length === 0) {
            // call drain immediately if there are no tasks
            return setImmediate$1(function() {
                q.drain();
            });
        }

        priority = priority || 0;
        var nextNode = q._tasks.head;
        while (nextNode && priority >= nextNode.priority) {
            nextNode = nextNode.next;
        }

        for (var i = 0, l = data.length; i < l; i++) {
            var item = {
                data: data[i],
                priority: priority,
                callback: callback
            };

            if (nextNode) {
                q._tasks.insertBefore(nextNode, item);
            } else {
                q._tasks.push(item);
            }
        }
        setImmediate$1(q.process);
    };

    // Remove unshift function
    delete q.unshift;

    return q;
};

/**
 * Runs the `tasks` array of functions in parallel, without waiting until the
 * previous function has completed. Once any of the `tasks` complete or pass an
 * error to its callback, the main `callback` is immediately called. It's
 * equivalent to `Promise.race()`.
 *
 * @name race
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}
 * to run. Each function can complete with an optional `result` value.
 * @param {Function} callback - A callback to run once any of the functions have
 * completed. This function gets an error or result from the first function that
 * completed. Invoked with (err, result).
 * @returns undefined
 * @example
 *
 * async.race([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ],
 * // main callback
 * function(err, result) {
 *     // the result will be equal to 'two' as it finishes earlier
 * });
 */
function race(tasks, callback) {
    callback = once(callback || noop);
    if (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));
    if (!tasks.length) return callback();
    for (var i = 0, l = tasks.length; i < l; i++) {
        wrapAsync(tasks[i])(callback);
    }
}

/**
 * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.
 *
 * @name reduceRight
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.reduce]{@link module:Collections.reduce}
 * @alias foldr
 * @category Collection
 * @param {Array} array - A collection to iterate over.
 * @param {*} memo - The initial state of the reduction.
 * @param {AsyncFunction} iteratee - A function applied to each item in the
 * array to produce the next step in the reduction.
 * The `iteratee` should complete with the next state of the reduction.
 * If the iteratee complete with an error, the reduction is stopped and the
 * main `callback` is immediately called with the error.
 * Invoked with (memo, item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the reduced value. Invoked with
 * (err, result).
 */
function reduceRight (array, memo, iteratee, callback) {
    var reversed = slice(array).reverse();
    reduce(reversed, memo, iteratee, callback);
}

/**
 * Wraps the async function in another function that always completes with a
 * result object, even when it errors.
 *
 * The result object has either the property `error` or `value`.
 *
 * @name reflect
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} fn - The async function you want to wrap
 * @returns {Function} - A function that always passes null to it's callback as
 * the error. The second argument to the callback will be an `object` with
 * either an `error` or a `value` property.
 * @example
 *
 * async.parallel([
 *     async.reflect(function(callback) {
 *         // do some stuff ...
 *         callback(null, 'one');
 *     }),
 *     async.reflect(function(callback) {
 *         // do some more stuff but error ...
 *         callback('bad stuff happened');
 *     }),
 *     async.reflect(function(callback) {
 *         // do some more stuff ...
 *         callback(null, 'two');
 *     })
 * ],
 * // optional callback
 * function(err, results) {
 *     // values
 *     // results[0].value = 'one'
 *     // results[1].error = 'bad stuff happened'
 *     // results[2].value = 'two'
 * });
 */
function reflect(fn) {
    var _fn = wrapAsync(fn);
    return initialParams(function reflectOn(args, reflectCallback) {
        args.push(function callback(error, cbArg) {
            if (error) {
                reflectCallback(null, { error: error });
            } else {
                var value;
                if (arguments.length <= 2) {
                    value = cbArg;
                } else {
                    value = slice(arguments, 1);
                }
                reflectCallback(null, { value: value });
            }
        });

        return _fn.apply(this, args);
    });
}

/**
 * A helper function that wraps an array or an object of functions with `reflect`.
 *
 * @name reflectAll
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.reflect]{@link module:Utils.reflect}
 * @category Util
 * @param {Array|Object|Iterable} tasks - The collection of
 * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.
 * @returns {Array} Returns an array of async functions, each wrapped in
 * `async.reflect`
 * @example
 *
 * let tasks = [
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         // do some more stuff but error ...
 *         callback(new Error('bad stuff happened'));
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ];
 *
 * async.parallel(async.reflectAll(tasks),
 * // optional callback
 * function(err, results) {
 *     // values
 *     // results[0].value = 'one'
 *     // results[1].error = Error('bad stuff happened')
 *     // results[2].value = 'two'
 * });
 *
 * // an example using an object instead of an array
 * let tasks = {
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         callback('two');
 *     },
 *     three: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'three');
 *         }, 100);
 *     }
 * };
 *
 * async.parallel(async.reflectAll(tasks),
 * // optional callback
 * function(err, results) {
 *     // values
 *     // results.one.value = 'one'
 *     // results.two.error = 'two'
 *     // results.three.value = 'three'
 * });
 */
function reflectAll(tasks) {
    var results;
    if (isArray(tasks)) {
        results = arrayMap(tasks, reflect);
    } else {
        results = {};
        baseForOwn(tasks, function(task, key) {
            results[key] = reflect.call(this, task);
        });
    }
    return results;
}

function reject$1(eachfn, arr, iteratee, callback) {
    _filter(eachfn, arr, function(value, cb) {
        iteratee(value, function(err, v) {
            cb(err, !v);
        });
    }, callback);
}

/**
 * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.
 *
 * @name reject
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]{@link module:Collections.filter}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - An async truth test to apply to each item in
 * `coll`.
 * The should complete with a boolean value as its `result`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @example
 *
 * async.reject(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, results) {
 *     // results now equals an array of missing files
 *     createFiles(results);
 * });
 */
var reject = doParallel(reject$1);

/**
 * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name rejectLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.reject]{@link module:Collections.reject}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} iteratee - An async truth test to apply to each item in
 * `coll`.
 * The should complete with a boolean value as its `result`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 */
var rejectLimit = doParallelLimit(reject$1);

/**
 * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.
 *
 * @name rejectSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.reject]{@link module:Collections.reject}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - An async truth test to apply to each item in
 * `coll`.
 * The should complete with a boolean value as its `result`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 */
var rejectSeries = doLimit(rejectLimit, 1);

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant$1(value) {
  return function() {
    return value;
  };
}

/**
 * Attempts to get a successful response from `task` no more than `times` times
 * before returning an error. If the task is successful, the `callback` will be
 * passed the result of the successful task. If all attempts fail, the callback
 * will be passed the error and result (if any) of the final attempt.
 *
 * @name retry
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @see [async.retryable]{@link module:ControlFlow.retryable}
 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an
 * object with `times` and `interval` or a number.
 * * `times` - The number of attempts to make before giving up.  The default
 *   is `5`.
 * * `interval` - The time to wait between retries, in milliseconds.  The
 *   default is `0`. The interval may also be specified as a function of the
 *   retry count (see example).
 * * `errorFilter` - An optional synchronous function that is invoked on
 *   erroneous result. If it returns `true` the retry attempts will continue;
 *   if the function returns `false` the retry flow is aborted with the current
 *   attempt's error and result being returned to the final callback.
 *   Invoked with (err).
 * * If `opts` is a number, the number specifies the number of times to retry,
 *   with the default interval of `0`.
 * @param {AsyncFunction} task - An async function to retry.
 * Invoked with (callback).
 * @param {Function} [callback] - An optional callback which is called when the
 * task has succeeded, or after the final failed attempt. It receives the `err`
 * and `result` arguments of the last attempt at completing the `task`. Invoked
 * with (err, results).
 *
 * @example
 *
 * // The `retry` function can be used as a stand-alone control flow by passing
 * // a callback, as shown below:
 *
 * // try calling apiMethod 3 times
 * async.retry(3, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod 3 times, waiting 200 ms between each retry
 * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod 10 times with exponential backoff
 * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)
 * async.retry({
 *   times: 10,
 *   interval: function(retryCount) {
 *     return 50 * Math.pow(2, retryCount);
 *   }
 * }, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod the default 5 times no delay between each retry
 * async.retry(apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod only when error condition satisfies, all other
 * // errors will abort the retry control flow and return to final callback
 * async.retry({
 *   errorFilter: function(err) {
 *     return err.message === 'Temporary error'; // only retry on a specific error
 *   }
 * }, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // to retry individual methods that are not as reliable within other
 * // control flow functions, use the `retryable` wrapper:
 * async.auto({
 *     users: api.getUsers.bind(api),
 *     payments: async.retryable(3, api.getPayments.bind(api))
 * }, function(err, results) {
 *     // do something with the results
 * });
 *
 */
function retry(opts, task, callback) {
    var DEFAULT_TIMES = 5;
    var DEFAULT_INTERVAL = 0;

    var options = {
        times: DEFAULT_TIMES,
        intervalFunc: constant$1(DEFAULT_INTERVAL)
    };

    function parseTimes(acc, t) {
        if (typeof t === 'object') {
            acc.times = +t.times || DEFAULT_TIMES;

            acc.intervalFunc = typeof t.interval === 'function' ?
                t.interval :
                constant$1(+t.interval || DEFAULT_INTERVAL);

            acc.errorFilter = t.errorFilter;
        } else if (typeof t === 'number' || typeof t === 'string') {
            acc.times = +t || DEFAULT_TIMES;
        } else {
            throw new Error("Invalid arguments for async.retry");
        }
    }

    if (arguments.length < 3 && typeof opts === 'function') {
        callback = task || noop;
        task = opts;
    } else {
        parseTimes(options, opts);
        callback = callback || noop;
    }

    if (typeof task !== 'function') {
        throw new Error("Invalid arguments for async.retry");
    }

    var _task = wrapAsync(task);

    var attempt = 1;
    function retryAttempt() {
        _task(function(err) {
            if (err && attempt++ < options.times &&
                (typeof options.errorFilter != 'function' ||
                    options.errorFilter(err))) {
                setTimeout(retryAttempt, options.intervalFunc(attempt));
            } else {
                callback.apply(null, arguments);
            }
        });
    }

    retryAttempt();
}

/**
 * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method
 * wraps a task and makes it retryable, rather than immediately calling it
 * with retries.
 *
 * @name retryable
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.retry]{@link module:ControlFlow.retry}
 * @category Control Flow
 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional
 * options, exactly the same as from `retry`
 * @param {AsyncFunction} task - the asynchronous function to wrap.
 * This function will be passed any arguments passed to the returned wrapper.
 * Invoked with (...args, callback).
 * @returns {AsyncFunction} The wrapped function, which when invoked, will
 * retry on an error, based on the parameters specified in `opts`.
 * This function will accept the same parameters as `task`.
 * @example
 *
 * async.auto({
 *     dep1: async.retryable(3, getFromFlakyService),
 *     process: ["dep1", async.retryable(3, function (results, cb) {
 *         maybeProcessData(results.dep1, cb);
 *     })]
 * }, callback);
 */
var retryable = function (opts, task) {
    if (!task) {
        task = opts;
        opts = null;
    }
    var _task = wrapAsync(task);
    return initialParams(function (args, callback) {
        function taskFn(cb) {
            _task.apply(null, args.concat(cb));
        }

        if (opts) retry(opts, taskFn, callback);
        else retry(taskFn, callback);

    });
};

/**
 * Run the functions in the `tasks` collection in series, each one running once
 * the previous function has completed. If any functions in the series pass an
 * error to its callback, no more functions are run, and `callback` is
 * immediately called with the value of the error. Otherwise, `callback`
 * receives an array of results when `tasks` have completed.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function, and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 *  results from {@link async.series}.
 *
 * **Note** that while many implementations preserve the order of object
 * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
 * explicitly states that
 *
 * > The mechanics and order of enumerating the properties is not specified.
 *
 * So if you rely on the order in which your series of functions are executed,
 * and want this to work on all platforms, consider using an array.
 *
 * @name series
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} tasks - A collection containing
 * [async functions]{@link AsyncFunction} to run in series.
 * Each function can complete with any number of optional `result` values.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This function gets a results array (or object)
 * containing all the result arguments passed to the `task` callbacks. Invoked
 * with (err, result).
 * @example
 * async.series([
 *     function(callback) {
 *         // do some stuff ...
 *         callback(null, 'one');
 *     },
 *     function(callback) {
 *         // do some more stuff ...
 *         callback(null, 'two');
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     // results is now equal to ['one', 'two']
 * });
 *
 * async.series({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback){
 *         setTimeout(function() {
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     // results is now equal to: {one: 1, two: 2}
 * });
 */
function series(tasks, callback) {
    _parallel(eachOfSeries, tasks, callback);
}

/**
 * Returns `true` if at least one element in the `coll` satisfies an async test.
 * If any iteratee call returns `true`, the main `callback` is immediately
 * called.
 *
 * @name some
 * @static
 * @memberOf module:Collections
 * @method
 * @alias any
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in parallel.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 * @example
 *
 * async.some(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, result) {
 *     // if result is true then at least one of the files exists
 * });
 */
var some = doParallel(_createTester(Boolean, identity));

/**
 * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.
 *
 * @name someLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.some]{@link module:Collections.some}
 * @alias anyLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in parallel.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 */
var someLimit = doParallelLimit(_createTester(Boolean, identity));

/**
 * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.
 *
 * @name someSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.some]{@link module:Collections.some}
 * @alias anySeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in series.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 */
var someSeries = doLimit(someLimit, 1);

/**
 * Sorts a list by the results of running each `coll` value through an async
 * `iteratee`.
 *
 * @name sortBy
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a value to use as the sort criteria as
 * its `result`.
 * Invoked with (item, callback).
 * @param {Function} callback - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is the items
 * from the original `coll` sorted by the values returned by the `iteratee`
 * calls. Invoked with (err, results).
 * @example
 *
 * async.sortBy(['file1','file2','file3'], function(file, callback) {
 *     fs.stat(file, function(err, stats) {
 *         callback(err, stats.mtime);
 *     });
 * }, function(err, results) {
 *     // results is now the original array of files sorted by
 *     // modified date
 * });
 *
 * // By modifying the callback parameter the
 * // sorting order can be influenced:
 *
 * // ascending order
 * async.sortBy([1,9,3,5], function(x, callback) {
 *     callback(null, x);
 * }, function(err,result) {
 *     // result callback
 * });
 *
 * // descending order
 * async.sortBy([1,9,3,5], function(x, callback) {
 *     callback(null, x*-1);    //<- x*-1 instead of x, turns the order around
 * }, function(err,result) {
 *     // result callback
 * });
 */
function sortBy (coll, iteratee, callback) {
    var _iteratee = wrapAsync(iteratee);
    map(coll, function (x, callback) {
        _iteratee(x, function (err, criteria) {
            if (err) return callback(err);
            callback(null, {value: x, criteria: criteria});
        });
    }, function (err, results) {
        if (err) return callback(err);
        callback(null, arrayMap(results.sort(comparator), baseProperty('value')));
    });

    function comparator(left, right) {
        var a = left.criteria, b = right.criteria;
        return a < b ? -1 : a > b ? 1 : 0;
    }
}

/**
 * Sets a time limit on an asynchronous function. If the function does not call
 * its callback within the specified milliseconds, it will be called with a
 * timeout error. The code property for the error object will be `'ETIMEDOUT'`.
 *
 * @name timeout
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} asyncFn - The async function to limit in time.
 * @param {number} milliseconds - The specified time limit.
 * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)
 * to timeout Error for more information..
 * @returns {AsyncFunction} Returns a wrapped function that can be used with any
 * of the control flow functions.
 * Invoke this function with the same parameters as you would `asyncFunc`.
 * @example
 *
 * function myFunction(foo, callback) {
 *     doAsyncTask(foo, function(err, data) {
 *         // handle errors
 *         if (err) return callback(err);
 *
 *         // do some stuff ...
 *
 *         // return processed data
 *         return callback(null, data);
 *     });
 * }
 *
 * var wrapped = async.timeout(myFunction, 1000);
 *
 * // call `wrapped` as you would `myFunction`
 * wrapped({ bar: 'bar' }, function(err, data) {
 *     // if `myFunction` takes < 1000 ms to execute, `err`
 *     // and `data` will have their expected values
 *
 *     // else `err` will be an Error with the code 'ETIMEDOUT'
 * });
 */
function timeout(asyncFn, milliseconds, info) {
    var fn = wrapAsync(asyncFn);

    return initialParams(function (args, callback) {
        var timedOut = false;
        var timer;

        function timeoutCallback() {
            var name = asyncFn.name || 'anonymous';
            var error  = new Error('Callback function "' + name + '" timed out.');
            error.code = 'ETIMEDOUT';
            if (info) {
                error.info = info;
            }
            timedOut = true;
            callback(error);
        }

        args.push(function () {
            if (!timedOut) {
                callback.apply(null, arguments);
                clearTimeout(timer);
            }
        });

        // setup timer and call original function
        timer = setTimeout(timeoutCallback, milliseconds);
        fn.apply(null, args);
    });
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil;
var nativeMax = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}

/**
 * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name timesLimit
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.times]{@link module:ControlFlow.times}
 * @category Control Flow
 * @param {number} count - The number of times to run the function.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - The async function to call `n` times.
 * Invoked with the iteration index and a callback: (n, next).
 * @param {Function} callback - see [async.map]{@link module:Collections.map}.
 */
function timeLimit(count, limit, iteratee, callback) {
    var _iteratee = wrapAsync(iteratee);
    mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);
}

/**
 * Calls the `iteratee` function `n` times, and accumulates results in the same
 * manner you would use with [map]{@link module:Collections.map}.
 *
 * @name times
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.map]{@link module:Collections.map}
 * @category Control Flow
 * @param {number} n - The number of times to run the function.
 * @param {AsyncFunction} iteratee - The async function to call `n` times.
 * Invoked with the iteration index and a callback: (n, next).
 * @param {Function} callback - see {@link module:Collections.map}.
 * @example
 *
 * // Pretend this is some complicated async factory
 * var createUser = function(id, callback) {
 *     callback(null, {
 *         id: 'user' + id
 *     });
 * };
 *
 * // generate 5 users
 * async.times(5, function(n, next) {
 *     createUser(n, function(err, user) {
 *         next(err, user);
 *     });
 * }, function(err, users) {
 *     // we should now have 5 users
 * });
 */
var times = doLimit(timeLimit, Infinity);

/**
 * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.
 *
 * @name timesSeries
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.times]{@link module:ControlFlow.times}
 * @category Control Flow
 * @param {number} n - The number of times to run the function.
 * @param {AsyncFunction} iteratee - The async function to call `n` times.
 * Invoked with the iteration index and a callback: (n, next).
 * @param {Function} callback - see {@link module:Collections.map}.
 */
var timesSeries = doLimit(timeLimit, 1);

/**
 * A relative of `reduce`.  Takes an Object or Array, and iterates over each
 * element in series, each step potentially mutating an `accumulator` value.
 * The type of the accumulator defaults to the type of collection passed in.
 *
 * @name transform
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {*} [accumulator] - The initial state of the transform.  If omitted,
 * it will default to an empty Object or Array, depending on the type of `coll`
 * @param {AsyncFunction} iteratee - A function applied to each item in the
 * collection that potentially modifies the accumulator.
 * Invoked with (accumulator, item, key, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the transformed accumulator.
 * Invoked with (err, result).
 * @example
 *
 * async.transform([1,2,3], function(acc, item, index, callback) {
 *     // pointless async:
 *     process.nextTick(function() {
 *         acc.push(item * 2)
 *         callback(null)
 *     });
 * }, function(err, result) {
 *     // result is now equal to [2, 4, 6]
 * });
 *
 * @example
 *
 * async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {
 *     setImmediate(function () {
 *         obj[key] = val * 2;
 *         callback();
 *     })
 * }, function (err, result) {
 *     // result is equal to {a: 2, b: 4, c: 6}
 * })
 */
function transform (coll, accumulator, iteratee, callback) {
    if (arguments.length <= 3) {
        callback = iteratee;
        iteratee = accumulator;
        accumulator = isArray(coll) ? [] : {};
    }
    callback = once(callback || noop);
    var _iteratee = wrapAsync(iteratee);

    eachOf(coll, function(v, k, cb) {
        _iteratee(accumulator, v, k, cb);
    }, function(err) {
        callback(err, accumulator);
    });
}

/**
 * It runs each task in series but stops whenever any of the functions were
 * successful. If one of the tasks were successful, the `callback` will be
 * passed the result of the successful task. If all tasks fail, the callback
 * will be passed the error and result (if any) of the final attempt.
 *
 * @name tryEach
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} tasks - A collection containing functions to
 * run, each function is passed a `callback(err, result)` it must call on
 * completion with an error `err` (which can be `null`) and an optional `result`
 * value.
 * @param {Function} [callback] - An optional callback which is called when one
 * of the tasks has succeeded, or all have failed. It receives the `err` and
 * `result` arguments of the last attempt at completing the `task`. Invoked with
 * (err, results).
 * @example
 * async.tryEach([
 *     function getDataFromFirstWebsite(callback) {
 *         // Try getting the data from the first website
 *         callback(err, data);
 *     },
 *     function getDataFromSecondWebsite(callback) {
 *         // First website failed,
 *         // Try getting the data from the backup website
 *         callback(err, data);
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     Now do something with the data.
 * });
 *
 */
function tryEach(tasks, callback) {
    var error = null;
    var result;
    callback = callback || noop;
    eachSeries(tasks, function(task, callback) {
        wrapAsync(task)(function (err, res/*, ...args*/) {
            if (arguments.length > 2) {
                result = slice(arguments, 1);
            } else {
                result = res;
            }
            error = err;
            callback(!err);
        });
    }, function () {
        callback(error, result);
    });
}

/**
 * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,
 * unmemoized form. Handy for testing.
 *
 * @name unmemoize
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.memoize]{@link module:Utils.memoize}
 * @category Util
 * @param {AsyncFunction} fn - the memoized function
 * @returns {AsyncFunction} a function that calls the original unmemoized function
 */
function unmemoize(fn) {
    return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
    };
}

/**
 * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when
 * stopped, or an error occurs.
 *
 * @name whilst
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Function} test - synchronous truth test to perform before each
 * execution of `iteratee`. Invoked with ().
 * @param {AsyncFunction} iteratee - An async function which is called each time
 * `test` passes. Invoked with (callback).
 * @param {Function} [callback] - A callback which is called after the test
 * function has failed and repeated execution of `iteratee` has stopped. `callback`
 * will be passed an error and any arguments passed to the final `iteratee`'s
 * callback. Invoked with (err, [results]);
 * @returns undefined
 * @example
 *
 * var count = 0;
 * async.whilst(
 *     function() { return count < 5; },
 *     function(callback) {
 *         count++;
 *         setTimeout(function() {
 *             callback(null, count);
 *         }, 1000);
 *     },
 *     function (err, n) {
 *         // 5 seconds have passed, n = 5
 *     }
 * );
 */
function whilst(test, iteratee, callback) {
    callback = onlyOnce(callback || noop);
    var _iteratee = wrapAsync(iteratee);
    if (!test()) return callback(null);
    var next = function(err/*, ...args*/) {
        if (err) return callback(err);
        if (test()) return _iteratee(next);
        var args = slice(arguments, 1);
        callback.apply(null, [null].concat(args));
    };
    _iteratee(next);
}

/**
 * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when
 * stopped, or an error occurs. `callback` will be passed an error and any
 * arguments passed to the final `iteratee`'s callback.
 *
 * The inverse of [whilst]{@link module:ControlFlow.whilst}.
 *
 * @name until
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.whilst]{@link module:ControlFlow.whilst}
 * @category Control Flow
 * @param {Function} test - synchronous truth test to perform before each
 * execution of `iteratee`. Invoked with ().
 * @param {AsyncFunction} iteratee - An async function which is called each time
 * `test` fails. Invoked with (callback).
 * @param {Function} [callback] - A callback which is called after the test
 * function has passed and repeated execution of `iteratee` has stopped. `callback`
 * will be passed an error and any arguments passed to the final `iteratee`'s
 * callback. Invoked with (err, [results]);
 */
function until(test, iteratee, callback) {
    whilst(function() {
        return !test.apply(this, arguments);
    }, iteratee, callback);
}

/**
 * Runs the `tasks` array of functions in series, each passing their results to
 * the next in the array. However, if any of the `tasks` pass an error to their
 * own callback, the next function is not executed, and the main `callback` is
 * immediately called with the error.
 *
 * @name waterfall
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}
 * to run.
 * Each function should complete with any number of `result` values.
 * The `result` values will be passed as arguments, in order, to the next task.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This will be passed the results of the last task's
 * callback. Invoked with (err, [results]).
 * @returns undefined
 * @example
 *
 * async.waterfall([
 *     function(callback) {
 *         callback(null, 'one', 'two');
 *     },
 *     function(arg1, arg2, callback) {
 *         // arg1 now equals 'one' and arg2 now equals 'two'
 *         callback(null, 'three');
 *     },
 *     function(arg1, callback) {
 *         // arg1 now equals 'three'
 *         callback(null, 'done');
 *     }
 * ], function (err, result) {
 *     // result now equals 'done'
 * });
 *
 * // Or, with named functions:
 * async.waterfall([
 *     myFirstFunction,
 *     mySecondFunction,
 *     myLastFunction,
 * ], function (err, result) {
 *     // result now equals 'done'
 * });
 * function myFirstFunction(callback) {
 *     callback(null, 'one', 'two');
 * }
 * function mySecondFunction(arg1, arg2, callback) {
 *     // arg1 now equals 'one' and arg2 now equals 'two'
 *     callback(null, 'three');
 * }
 * function myLastFunction(arg1, callback) {
 *     // arg1 now equals 'three'
 *     callback(null, 'done');
 * }
 */
var waterfall = function(tasks, callback) {
    callback = once(callback || noop);
    if (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
    if (!tasks.length) return callback();
    var taskIndex = 0;

    function nextTask(args) {
        var task = wrapAsync(tasks[taskIndex++]);
        args.push(onlyOnce(next));
        task.apply(null, args);
    }

    function next(err/*, ...args*/) {
        if (err || taskIndex === tasks.length) {
            return callback.apply(null, arguments);
        }
        nextTask(slice(arguments, 1));
    }

    nextTask([]);
};

/**
 * An "async function" in the context of Async is an asynchronous function with
 * a variable number of parameters, with the final parameter being a callback.
 * (`function (arg1, arg2, ..., callback) {}`)
 * The final callback is of the form `callback(err, results...)`, which must be
 * called once the function is completed.  The callback should be called with a
 * Error as its first argument to signal that an error occurred.
 * Otherwise, if no error occurred, it should be called with `null` as the first
 * argument, and any additional `result` arguments that may apply, to signal
 * successful completion.
 * The callback must be called exactly once, ideally on a later tick of the
 * JavaScript event loop.
 *
 * This type of function is also referred to as a "Node-style async function",
 * or a "continuation passing-style function" (CPS). Most of the methods of this
 * library are themselves CPS/Node-style async functions, or functions that
 * return CPS/Node-style async functions.
 *
 * Wherever we accept a Node-style async function, we also directly accept an
 * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.
 * In this case, the `async` function will not be passed a final callback
 * argument, and any thrown error will be used as the `err` argument of the
 * implicit callback, and the return value will be used as the `result` value.
 * (i.e. a `rejected` of the returned Promise becomes the `err` callback
 * argument, and a `resolved` value becomes the `result`.)
 *
 * Note, due to JavaScript limitations, we can only detect native `async`
 * functions and not transpilied implementations.
 * Your environment must have `async`/`await` support for this to work.
 * (e.g. Node > v7.6, or a recent version of a modern browser).
 * If you are using `async` functions through a transpiler (e.g. Babel), you
 * must still wrap the function with [asyncify]{@link module:Utils.asyncify},
 * because the `async function` will be compiled to an ordinary function that
 * returns a promise.
 *
 * @typedef {Function} AsyncFunction
 * @static
 */

/**
 * Async is a utility module which provides straight-forward, powerful functions
 * for working with asynchronous JavaScript. Although originally designed for
 * use with [Node.js](http://nodejs.org) and installable via
 * `npm install --save async`, it can also be used directly in the browser.
 * @module async
 * @see AsyncFunction
 */


/**
 * A collection of `async` functions for manipulating collections, such as
 * arrays and objects.
 * @module Collections
 */

/**
 * A collection of `async` functions for controlling the flow through a script.
 * @module ControlFlow
 */

/**
 * A collection of `async` utility functions.
 * @module Utils
 */

var index = {
    apply: apply,
    applyEach: applyEach,
    applyEachSeries: applyEachSeries,
    asyncify: asyncify,
    auto: auto,
    autoInject: autoInject,
    cargo: cargo,
    compose: compose,
    concat: concat,
    concatLimit: concatLimit,
    concatSeries: concatSeries,
    constant: constant,
    detect: detect,
    detectLimit: detectLimit,
    detectSeries: detectSeries,
    dir: dir,
    doDuring: doDuring,
    doUntil: doUntil,
    doWhilst: doWhilst,
    during: during,
    each: eachLimit,
    eachLimit: eachLimit$1,
    eachOf: eachOf,
    eachOfLimit: eachOfLimit,
    eachOfSeries: eachOfSeries,
    eachSeries: eachSeries,
    ensureAsync: ensureAsync,
    every: every,
    everyLimit: everyLimit,
    everySeries: everySeries,
    filter: filter,
    filterLimit: filterLimit,
    filterSeries: filterSeries,
    forever: forever,
    groupBy: groupBy,
    groupByLimit: groupByLimit,
    groupBySeries: groupBySeries,
    log: log,
    map: map,
    mapLimit: mapLimit,
    mapSeries: mapSeries,
    mapValues: mapValues,
    mapValuesLimit: mapValuesLimit,
    mapValuesSeries: mapValuesSeries,
    memoize: memoize,
    nextTick: nextTick,
    parallel: parallelLimit,
    parallelLimit: parallelLimit$1,
    priorityQueue: priorityQueue,
    queue: queue$1,
    race: race,
    reduce: reduce,
    reduceRight: reduceRight,
    reflect: reflect,
    reflectAll: reflectAll,
    reject: reject,
    rejectLimit: rejectLimit,
    rejectSeries: rejectSeries,
    retry: retry,
    retryable: retryable,
    seq: seq,
    series: series,
    setImmediate: setImmediate$1,
    some: some,
    someLimit: someLimit,
    someSeries: someSeries,
    sortBy: sortBy,
    timeout: timeout,
    times: times,
    timesLimit: timeLimit,
    timesSeries: timesSeries,
    transform: transform,
    tryEach: tryEach,
    unmemoize: unmemoize,
    until: until,
    waterfall: waterfall,
    whilst: whilst,

    // aliases
    all: every,
    allLimit: everyLimit,
    allSeries: everySeries,
    any: some,
    anyLimit: someLimit,
    anySeries: someSeries,
    find: detect,
    findLimit: detectLimit,
    findSeries: detectSeries,
    forEach: eachLimit,
    forEachSeries: eachSeries,
    forEachLimit: eachLimit$1,
    forEachOf: eachOf,
    forEachOfSeries: eachOfSeries,
    forEachOfLimit: eachOfLimit,
    inject: reduce,
    foldl: reduce,
    foldr: reduceRight,
    select: filter,
    selectLimit: filterLimit,
    selectSeries: filterSeries,
    wrapSync: asyncify
};

exports['default'] = index;
exports.apply = apply;
exports.applyEach = applyEach;
exports.applyEachSeries = applyEachSeries;
exports.asyncify = asyncify;
exports.auto = auto;
exports.autoInject = autoInject;
exports.cargo = cargo;
exports.compose = compose;
exports.concat = concat;
exports.concatLimit = concatLimit;
exports.concatSeries = concatSeries;
exports.constant = constant;
exports.detect = detect;
exports.detectLimit = detectLimit;
exports.detectSeries = detectSeries;
exports.dir = dir;
exports.doDuring = doDuring;
exports.doUntil = doUntil;
exports.doWhilst = doWhilst;
exports.during = during;
exports.each = eachLimit;
exports.eachLimit = eachLimit$1;
exports.eachOf = eachOf;
exports.eachOfLimit = eachOfLimit;
exports.eachOfSeries = eachOfSeries;
exports.eachSeries = eachSeries;
exports.ensureAsync = ensureAsync;
exports.every = every;
exports.everyLimit = everyLimit;
exports.everySeries = everySeries;
exports.filter = filter;
exports.filterLimit = filterLimit;
exports.filterSeries = filterSeries;
exports.forever = forever;
exports.groupBy = groupBy;
exports.groupByLimit = groupByLimit;
exports.groupBySeries = groupBySeries;
exports.log = log;
exports.map = map;
exports.mapLimit = mapLimit;
exports.mapSeries = mapSeries;
exports.mapValues = mapValues;
exports.mapValuesLimit = mapValuesLimit;
exports.mapValuesSeries = mapValuesSeries;
exports.memoize = memoize;
exports.nextTick = nextTick;
exports.parallel = parallelLimit;
exports.parallelLimit = parallelLimit$1;
exports.priorityQueue = priorityQueue;
exports.queue = queue$1;
exports.race = race;
exports.reduce = reduce;
exports.reduceRight = reduceRight;
exports.reflect = reflect;
exports.reflectAll = reflectAll;
exports.reject = reject;
exports.rejectLimit = rejectLimit;
exports.rejectSeries = rejectSeries;
exports.retry = retry;
exports.retryable = retryable;
exports.seq = seq;
exports.series = series;
exports.setImmediate = setImmediate$1;
exports.some = some;
exports.someLimit = someLimit;
exports.someSeries = someSeries;
exports.sortBy = sortBy;
exports.timeout = timeout;
exports.times = times;
exports.timesLimit = timeLimit;
exports.timesSeries = timesSeries;
exports.transform = transform;
exports.tryEach = tryEach;
exports.unmemoize = unmemoize;
exports.until = until;
exports.waterfall = waterfall;
exports.whilst = whilst;
exports.all = every;
exports.allLimit = everyLimit;
exports.allSeries = everySeries;
exports.any = some;
exports.anyLimit = someLimit;
exports.anySeries = someSeries;
exports.find = detect;
exports.findLimit = detectLimit;
exports.findSeries = detectSeries;
exports.forEach = eachLimit;
exports.forEachSeries = eachSeries;
exports.forEachLimit = eachLimit$1;
exports.forEachOf = eachOf;
exports.forEachOfSeries = eachOfSeries;
exports.forEachOfLimit = eachOfLimit;
exports.inject = reduce;
exports.foldl = reduce;
exports.foldr = reduceRight;
exports.select = filter;
exports.selectLimit = filterLimit;
exports.selectSeries = filterSeries;
exports.wrapSync = asyncify;

Object.defineProperty(exports, '__esModule', { value: true });

})));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":3}],50:[function(require,module,exports){
function CallableInstance(property) {
  var func = this.constructor.prototype[property];
  var apply = function() { return func.apply(apply, arguments); }
  Object.setPrototypeOf(apply, this.constructor.prototype);
  Object.getOwnPropertyNames(func).forEach(function (p) {
    Object.defineProperty(apply, p, Object.getOwnPropertyDescriptor(func, p));
  });
  return apply;
}
CallableInstance.prototype = Object.create(Function.prototype);

module.exports = CallableInstance;

},{}],51:[function(require,module,exports){
(function (process){
'use strict';
var escapeStringRegexp = require('escape-string-regexp');
var ansiStyles = require('ansi-styles');
var stripAnsi = require('strip-ansi');
var hasAnsi = require('has-ansi');
var supportsColor = require('supports-color');
var defineProps = Object.defineProperties;
var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);

function Chalk(options) {
	// detect mode if not set manually
	this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
}

// use bright blue on Windows as the normal blue color is illegible
if (isSimpleWindowsTerm) {
	ansiStyles.blue.open = '\u001b[94m';
}

var styles = (function () {
	var ret = {};

	Object.keys(ansiStyles).forEach(function (key) {
		ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

		ret[key] = {
			get: function () {
				return build.call(this, this._styles.concat(key));
			}
		};
	});

	return ret;
})();

var proto = defineProps(function chalk() {}, styles);

function build(_styles) {
	var builder = function () {
		return applyStyle.apply(builder, arguments);
	};

	builder._styles = _styles;
	builder.enabled = this.enabled;
	// __proto__ is used because we must return a function, but there is
	// no way to create a function with a different prototype.
	/* eslint-disable no-proto */
	builder.__proto__ = proto;

	return builder;
}

function applyStyle() {
	// support varags, but simply cast to string in case there's only one arg
	var args = arguments;
	var argsLen = args.length;
	var str = argsLen !== 0 && String(arguments[0]);

	if (argsLen > 1) {
		// don't slice `arguments`, it prevents v8 optimizations
		for (var a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || !str) {
		return str;
	}

	var nestedStyles = this._styles;
	var i = nestedStyles.length;

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	var originalDim = ansiStyles.dim.open;
	if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
		ansiStyles.dim.open = '';
	}

	while (i--) {
		var code = ansiStyles[nestedStyles[i]];

		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;
	}

	// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
	ansiStyles.dim.open = originalDim;

	return str;
}

function init() {
	var ret = {};

	Object.keys(styles).forEach(function (name) {
		ret[name] = {
			get: function () {
				return build.call(this, [name]);
			}
		};
	});

	return ret;
}

defineProps(Chalk.prototype, init());

module.exports = new Chalk();
module.exports.styles = ansiStyles;
module.exports.hasColor = hasAnsi;
module.exports.stripColor = stripAnsi;
module.exports.supportsColor = supportsColor;

}).call(this,require('_process'))

},{"_process":3,"ansi-styles":48,"escape-string-regexp":53,"has-ansi":57,"strip-ansi":65,"supports-color":52}],52:[function(require,module,exports){
(function (process){
'use strict';
var argv = process.argv;

var terminator = argv.indexOf('--');
var hasFlag = function (flag) {
	flag = '--' + flag;
	var pos = argv.indexOf(flag);
	return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
};

module.exports = (function () {
	if ('FORCE_COLOR' in process.env) {
		return true;
	}

	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false')) {
		return false;
	}

	if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
})();

}).call(this,require('_process'))

},{"_process":3}],53:[function(require,module,exports){
'use strict';

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(matchOperatorsRe, '\\$&');
};

},{}],54:[function(require,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
/* istanbul ignore next */
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
/* istanbul ignore next */
	else if(typeof exports === 'object')
		exports["esprima"] = factory();
	else
		root["esprima"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/* istanbul ignore if */
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/*
	  Copyright JS Foundation and other contributors, https://js.foundation/

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	var comment_handler_1 = __webpack_require__(1);
	var jsx_parser_1 = __webpack_require__(3);
	var parser_1 = __webpack_require__(8);
	var tokenizer_1 = __webpack_require__(15);
	function parse(code, options, delegate) {
	    var commentHandler = null;
	    var proxyDelegate = function (node, metadata) {
	        if (delegate) {
	            delegate(node, metadata);
	        }
	        if (commentHandler) {
	            commentHandler.visit(node, metadata);
	        }
	    };
	    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;
	    var collectComment = false;
	    if (options) {
	        collectComment = (typeof options.comment === 'boolean' && options.comment);
	        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);
	        if (collectComment || attachComment) {
	            commentHandler = new comment_handler_1.CommentHandler();
	            commentHandler.attach = attachComment;
	            options.comment = true;
	            parserDelegate = proxyDelegate;
	        }
	    }
	    var isModule = false;
	    if (options && typeof options.sourceType === 'string') {
	        isModule = (options.sourceType === 'module');
	    }
	    var parser;
	    if (options && typeof options.jsx === 'boolean' && options.jsx) {
	        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
	    }
	    else {
	        parser = new parser_1.Parser(code, options, parserDelegate);
	    }
	    var program = isModule ? parser.parseModule() : parser.parseScript();
	    var ast = program;
	    if (collectComment && commentHandler) {
	        ast.comments = commentHandler.comments;
	    }
	    if (parser.config.tokens) {
	        ast.tokens = parser.tokens;
	    }
	    if (parser.config.tolerant) {
	        ast.errors = parser.errorHandler.errors;
	    }
	    return ast;
	}
	exports.parse = parse;
	function parseModule(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'module';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseModule = parseModule;
	function parseScript(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'script';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseScript = parseScript;
	function tokenize(code, options, delegate) {
	    var tokenizer = new tokenizer_1.Tokenizer(code, options);
	    var tokens;
	    tokens = [];
	    try {
	        while (true) {
	            var token = tokenizer.getNextToken();
	            if (!token) {
	                break;
	            }
	            if (delegate) {
	                token = delegate(token);
	            }
	            tokens.push(token);
	        }
	    }
	    catch (e) {
	        tokenizer.errorHandler.tolerate(e);
	    }
	    if (tokenizer.errorHandler.tolerant) {
	        tokens.errors = tokenizer.errors();
	    }
	    return tokens;
	}
	exports.tokenize = tokenize;
	var syntax_1 = __webpack_require__(2);
	exports.Syntax = syntax_1.Syntax;
	// Sync with *.json manifests.
	exports.version = '4.0.0';


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	var CommentHandler = (function () {
	    function CommentHandler() {
	        this.attach = false;
	        this.comments = [];
	        this.stack = [];
	        this.leading = [];
	        this.trailing = [];
	    }
	    CommentHandler.prototype.insertInnerComments = function (node, metadata) {
	        //  innnerComments for properties empty block
	        //  `function a() {/** comments **\/}`
	        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
	            var innerComments = [];
	            for (var i = this.leading.length - 1; i >= 0; --i) {
	                var entry = this.leading[i];
	                if (metadata.end.offset >= entry.start) {
	                    innerComments.unshift(entry.comment);
	                    this.leading.splice(i, 1);
	                    this.trailing.splice(i, 1);
	                }
	            }
	            if (innerComments.length) {
	                node.innerComments = innerComments;
	            }
	        }
	    };
	    CommentHandler.prototype.findTrailingComments = function (metadata) {
	        var trailingComments = [];
	        if (this.trailing.length > 0) {
	            for (var i = this.trailing.length - 1; i >= 0; --i) {
	                var entry_1 = this.trailing[i];
	                if (entry_1.start >= metadata.end.offset) {
	                    trailingComments.unshift(entry_1.comment);
	                }
	            }
	            this.trailing.length = 0;
	            return trailingComments;
	        }
	        var entry = this.stack[this.stack.length - 1];
	        if (entry && entry.node.trailingComments) {
	            var firstComment = entry.node.trailingComments[0];
	            if (firstComment && firstComment.range[0] >= metadata.end.offset) {
	                trailingComments = entry.node.trailingComments;
	                delete entry.node.trailingComments;
	            }
	        }
	        return trailingComments;
	    };
	    CommentHandler.prototype.findLeadingComments = function (metadata) {
	        var leadingComments = [];
	        var target;
	        while (this.stack.length > 0) {
	            var entry = this.stack[this.stack.length - 1];
	            if (entry && entry.start >= metadata.start.offset) {
	                target = entry.node;
	                this.stack.pop();
	            }
	            else {
	                break;
	            }
	        }
	        if (target) {
	            var count = target.leadingComments ? target.leadingComments.length : 0;
	            for (var i = count - 1; i >= 0; --i) {
	                var comment = target.leadingComments[i];
	                if (comment.range[1] <= metadata.start.offset) {
	                    leadingComments.unshift(comment);
	                    target.leadingComments.splice(i, 1);
	                }
	            }
	            if (target.leadingComments && target.leadingComments.length === 0) {
	                delete target.leadingComments;
	            }
	            return leadingComments;
	        }
	        for (var i = this.leading.length - 1; i >= 0; --i) {
	            var entry = this.leading[i];
	            if (entry.start <= metadata.start.offset) {
	                leadingComments.unshift(entry.comment);
	                this.leading.splice(i, 1);
	            }
	        }
	        return leadingComments;
	    };
	    CommentHandler.prototype.visitNode = function (node, metadata) {
	        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
	            return;
	        }
	        this.insertInnerComments(node, metadata);
	        var trailingComments = this.findTrailingComments(metadata);
	        var leadingComments = this.findLeadingComments(metadata);
	        if (leadingComments.length > 0) {
	            node.leadingComments = leadingComments;
	        }
	        if (trailingComments.length > 0) {
	            node.trailingComments = trailingComments;
	        }
	        this.stack.push({
	            node: node,
	            start: metadata.start.offset
	        });
	    };
	    CommentHandler.prototype.visitComment = function (node, metadata) {
	        var type = (node.type[0] === 'L') ? 'Line' : 'Block';
	        var comment = {
	            type: type,
	            value: node.value
	        };
	        if (node.range) {
	            comment.range = node.range;
	        }
	        if (node.loc) {
	            comment.loc = node.loc;
	        }
	        this.comments.push(comment);
	        if (this.attach) {
	            var entry = {
	                comment: {
	                    type: type,
	                    value: node.value,
	                    range: [metadata.start.offset, metadata.end.offset]
	                },
	                start: metadata.start.offset
	            };
	            if (node.loc) {
	                entry.comment.loc = node.loc;
	            }
	            node.type = type;
	            this.leading.push(entry);
	            this.trailing.push(entry);
	        }
	    };
	    CommentHandler.prototype.visit = function (node, metadata) {
	        if (node.type === 'LineComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (node.type === 'BlockComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (this.attach) {
	            this.visitNode(node, metadata);
	        }
	    };
	    return CommentHandler;
	}());
	exports.CommentHandler = CommentHandler;


/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Syntax = {
	    AssignmentExpression: 'AssignmentExpression',
	    AssignmentPattern: 'AssignmentPattern',
	    ArrayExpression: 'ArrayExpression',
	    ArrayPattern: 'ArrayPattern',
	    ArrowFunctionExpression: 'ArrowFunctionExpression',
	    AwaitExpression: 'AwaitExpression',
	    BlockStatement: 'BlockStatement',
	    BinaryExpression: 'BinaryExpression',
	    BreakStatement: 'BreakStatement',
	    CallExpression: 'CallExpression',
	    CatchClause: 'CatchClause',
	    ClassBody: 'ClassBody',
	    ClassDeclaration: 'ClassDeclaration',
	    ClassExpression: 'ClassExpression',
	    ConditionalExpression: 'ConditionalExpression',
	    ContinueStatement: 'ContinueStatement',
	    DoWhileStatement: 'DoWhileStatement',
	    DebuggerStatement: 'DebuggerStatement',
	    EmptyStatement: 'EmptyStatement',
	    ExportAllDeclaration: 'ExportAllDeclaration',
	    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	    ExportNamedDeclaration: 'ExportNamedDeclaration',
	    ExportSpecifier: 'ExportSpecifier',
	    ExpressionStatement: 'ExpressionStatement',
	    ForStatement: 'ForStatement',
	    ForOfStatement: 'ForOfStatement',
	    ForInStatement: 'ForInStatement',
	    FunctionDeclaration: 'FunctionDeclaration',
	    FunctionExpression: 'FunctionExpression',
	    Identifier: 'Identifier',
	    IfStatement: 'IfStatement',
	    ImportDeclaration: 'ImportDeclaration',
	    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	    ImportSpecifier: 'ImportSpecifier',
	    Literal: 'Literal',
	    LabeledStatement: 'LabeledStatement',
	    LogicalExpression: 'LogicalExpression',
	    MemberExpression: 'MemberExpression',
	    MetaProperty: 'MetaProperty',
	    MethodDefinition: 'MethodDefinition',
	    NewExpression: 'NewExpression',
	    ObjectExpression: 'ObjectExpression',
	    ObjectPattern: 'ObjectPattern',
	    Program: 'Program',
	    Property: 'Property',
	    RestElement: 'RestElement',
	    ReturnStatement: 'ReturnStatement',
	    SequenceExpression: 'SequenceExpression',
	    SpreadElement: 'SpreadElement',
	    Super: 'Super',
	    SwitchCase: 'SwitchCase',
	    SwitchStatement: 'SwitchStatement',
	    TaggedTemplateExpression: 'TaggedTemplateExpression',
	    TemplateElement: 'TemplateElement',
	    TemplateLiteral: 'TemplateLiteral',
	    ThisExpression: 'ThisExpression',
	    ThrowStatement: 'ThrowStatement',
	    TryStatement: 'TryStatement',
	    UnaryExpression: 'UnaryExpression',
	    UpdateExpression: 'UpdateExpression',
	    VariableDeclaration: 'VariableDeclaration',
	    VariableDeclarator: 'VariableDeclarator',
	    WhileStatement: 'WhileStatement',
	    WithStatement: 'WithStatement',
	    YieldExpression: 'YieldExpression'
	};


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
/* istanbul ignore next */
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var character_1 = __webpack_require__(4);
	var JSXNode = __webpack_require__(5);
	var jsx_syntax_1 = __webpack_require__(6);
	var Node = __webpack_require__(7);
	var parser_1 = __webpack_require__(8);
	var token_1 = __webpack_require__(13);
	var xhtml_entities_1 = __webpack_require__(14);
	token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
	token_1.TokenName[101 /* Text */] = 'JSXText';
	// Fully qualified element name, e.g. <svg:path> returns "svg:path"
	function getQualifiedElementName(elementName) {
	    var qualifiedName;
	    switch (elementName.type) {
	        case jsx_syntax_1.JSXSyntax.JSXIdentifier:
	            var id = elementName;
	            qualifiedName = id.name;
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
	            var ns = elementName;
	            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +
	                getQualifiedElementName(ns.name);
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
	            var expr = elementName;
	            qualifiedName = getQualifiedElementName(expr.object) + '.' +
	                getQualifiedElementName(expr.property);
	            break;
	        /* istanbul ignore next */
	        default:
	            break;
	    }
	    return qualifiedName;
	}
	var JSXParser = (function (_super) {
	    __extends(JSXParser, _super);
	    function JSXParser(code, options, delegate) {
	        return _super.call(this, code, options, delegate) || this;
	    }
	    JSXParser.prototype.parsePrimaryExpression = function () {
	        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
	    };
	    JSXParser.prototype.startJSX = function () {
	        // Unwind the scanner before the lookahead token.
	        this.scanner.index = this.startMarker.index;
	        this.scanner.lineNumber = this.startMarker.line;
	        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
	    };
	    JSXParser.prototype.finishJSX = function () {
	        // Prime the next lookahead.
	        this.nextToken();
	    };
	    JSXParser.prototype.reenterJSX = function () {
	        this.startJSX();
	        this.expectJSX('}');
	        // Pop the closing '}' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	    };
	    JSXParser.prototype.createJSXNode = function () {
	        this.collectComments();
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.createJSXChildNode = function () {
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.scanXHTMLEntity = function (quote) {
	        var result = '&';
	        var valid = true;
	        var terminated = false;
	        var numeric = false;
	        var hex = false;
	        while (!this.scanner.eof() && valid && !terminated) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === quote) {
	                break;
	            }
	            terminated = (ch === ';');
	            result += ch;
	            ++this.scanner.index;
	            if (!terminated) {
	                switch (result.length) {
	                    case 2:
	                        // e.g. '&#123;'
	                        numeric = (ch === '#');
	                        break;
	                    case 3:
	                        if (numeric) {
	                            // e.g. '&#x41;'
	                            hex = (ch === 'x');
	                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
	                            numeric = numeric && !hex;
	                        }
	                        break;
	                    default:
	                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
	                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
	                        break;
	                }
	            }
	        }
	        if (valid && terminated && result.length > 2) {
	            // e.g. '&#x41;' becomes just '#x41'
	            var str = result.substr(1, result.length - 2);
	            if (numeric && str.length > 1) {
	                result = String.fromCharCode(parseInt(str.substr(1), 10));
	            }
	            else if (hex && str.length > 2) {
	                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
	            }
	            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
	                result = xhtml_entities_1.XHTMLEntities[str];
	            }
	        }
	        return result;
	    };
	    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
	    JSXParser.prototype.lexJSX = function () {
	        var cp = this.scanner.source.charCodeAt(this.scanner.index);
	        // < > / : = { }
	        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
	            var value = this.scanner.source[this.scanner.index++];
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index - 1,
	                end: this.scanner.index
	            };
	        }
	        // " '
	        if (cp === 34 || cp === 39) {
	            var start = this.scanner.index;
	            var quote = this.scanner.source[this.scanner.index++];
	            var str = '';
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source[this.scanner.index++];
	                if (ch === quote) {
	                    break;
	                }
	                else if (ch === '&') {
	                    str += this.scanXHTMLEntity(quote);
	                }
	                else {
	                    str += ch;
	                }
	            }
	            return {
	                type: 8 /* StringLiteral */,
	                value: str,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // ... or .
	        if (cp === 46) {
	            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
	            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
	            var value = (n1 === 46 && n2 === 46) ? '...' : '.';
	            var start = this.scanner.index;
	            this.scanner.index += value.length;
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // `
	        if (cp === 96) {
	            // Only placeholder, since it will be rescanned as a real assignment expression.
	            return {
	                type: 10 /* Template */,
	                value: '',
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index,
	                end: this.scanner.index
	            };
	        }
	        // Identifer can not contain backslash (char code 92).
	        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {
	            var start = this.scanner.index;
	            ++this.scanner.index;
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source.charCodeAt(this.scanner.index);
	                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {
	                    ++this.scanner.index;
	                }
	                else if (ch === 45) {
	                    // Hyphen (char code 45) can be part of an identifier.
	                    ++this.scanner.index;
	                }
	                else {
	                    break;
	                }
	            }
	            var id = this.scanner.source.slice(start, this.scanner.index);
	            return {
	                type: 100 /* Identifier */,
	                value: id,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        return this.scanner.lex();
	    };
	    JSXParser.prototype.nextJSXToken = function () {
	        this.collectComments();
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = this.lexJSX();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        if (this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.nextJSXText = function () {
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var start = this.scanner.index;
	        var text = '';
	        while (!this.scanner.eof()) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === '{' || ch === '<') {
	                break;
	            }
	            ++this.scanner.index;
	            text += ch;
	            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.scanner.lineNumber;
	                if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
	                    ++this.scanner.index;
	                }
	                this.scanner.lineStart = this.scanner.index;
	            }
	        }
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = {
	            type: 101 /* Text */,
	            value: text,
	            lineNumber: this.scanner.lineNumber,
	            lineStart: this.scanner.lineStart,
	            start: start,
	            end: this.scanner.index
	        };
	        if ((text.length > 0) && this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.peekJSXToken = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.lexJSX();
	        this.scanner.restoreState(state);
	        return next;
	    };
	    // Expect the next JSX token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    JSXParser.prototype.expectJSX = function (value) {
	        var token = this.nextJSXToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next JSX token matches the specified punctuator.
	    JSXParser.prototype.matchJSX = function (value) {
	        var next = this.peekJSXToken();
	        return next.type === 7 /* Punctuator */ && next.value === value;
	    };
	    JSXParser.prototype.parseJSXIdentifier = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 100 /* Identifier */) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
	    };
	    JSXParser.prototype.parseJSXElementName = function () {
	        var node = this.createJSXNode();
	        var elementName = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = elementName;
	            this.expectJSX(':');
	            var name_1 = this.parseJSXIdentifier();
	            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
	        }
	        else if (this.matchJSX('.')) {
	            while (this.matchJSX('.')) {
	                var object = elementName;
	                this.expectJSX('.');
	                var property = this.parseJSXIdentifier();
	                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
	            }
	        }
	        return elementName;
	    };
	    JSXParser.prototype.parseJSXAttributeName = function () {
	        var node = this.createJSXNode();
	        var attributeName;
	        var identifier = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = identifier;
	            this.expectJSX(':');
	            var name_2 = this.parseJSXIdentifier();
	            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
	        }
	        else {
	            attributeName = identifier;
	        }
	        return attributeName;
	    };
	    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 8 /* StringLiteral */) {
	            this.throwUnexpectedToken(token);
	        }
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    JSXParser.prototype.parseJSXExpressionAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.finishJSX();
	        if (this.match('}')) {
	            this.tolerateError('JSX attributes must only be assigned a non-empty expression');
	        }
	        var expression = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXAttributeValue = function () {
	        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :
	            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
	    };
	    JSXParser.prototype.parseJSXNameValueAttribute = function () {
	        var node = this.createJSXNode();
	        var name = this.parseJSXAttributeName();
	        var value = null;
	        if (this.matchJSX('=')) {
	            this.expectJSX('=');
	            value = this.parseJSXAttributeValue();
	        }
	        return this.finalize(node, new JSXNode.JSXAttribute(name, value));
	    };
	    JSXParser.prototype.parseJSXSpreadAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.expectJSX('...');
	        this.finishJSX();
	        var argument = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
	    };
	    JSXParser.prototype.parseJSXAttributes = function () {
	        var attributes = [];
	        while (!this.matchJSX('/') && !this.matchJSX('>')) {
	            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :
	                this.parseJSXNameValueAttribute();
	            attributes.push(attribute);
	        }
	        return attributes;
	    };
	    JSXParser.prototype.parseJSXOpeningElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXBoundaryElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        if (this.matchJSX('/')) {
	            this.expectJSX('/');
	            var name_3 = this.parseJSXElementName();
	            this.expectJSX('>');
	            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
	        }
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXEmptyExpression = function () {
	        var node = this.createJSXChildNode();
	        this.collectComments();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        return this.finalize(node, new JSXNode.JSXEmptyExpression());
	    };
	    JSXParser.prototype.parseJSXExpressionContainer = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        var expression;
	        if (this.matchJSX('}')) {
	            expression = this.parseJSXEmptyExpression();
	            this.expectJSX('}');
	        }
	        else {
	            this.finishJSX();
	            expression = this.parseAssignmentExpression();
	            this.reenterJSX();
	        }
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXChildren = function () {
	        var children = [];
	        while (!this.scanner.eof()) {
	            var node = this.createJSXChildNode();
	            var token = this.nextJSXText();
	            if (token.start < token.end) {
	                var raw = this.getTokenRaw(token);
	                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
	                children.push(child);
	            }
	            if (this.scanner.source[this.scanner.index] === '{') {
	                var container = this.parseJSXExpressionContainer();
	                children.push(container);
	            }
	            else {
	                break;
	            }
	        }
	        return children;
	    };
	    JSXParser.prototype.parseComplexJSXElement = function (el) {
	        var stack = [];
	        while (!this.scanner.eof()) {
	            el.children = el.children.concat(this.parseJSXChildren());
	            var node = this.createJSXChildNode();
	            var element = this.parseJSXBoundaryElement();
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
	                var opening = element;
	                if (opening.selfClosing) {
	                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
	                    el.children.push(child);
	                }
	                else {
	                    stack.push(el);
	                    el = { node: node, opening: opening, closing: null, children: [] };
	                }
	            }
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
	                el.closing = element;
	                var open_1 = getQualifiedElementName(el.opening.name);
	                var close_1 = getQualifiedElementName(el.closing.name);
	                if (open_1 !== close_1) {
	                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
	                }
	                if (stack.length > 0) {
	                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
	                    el = stack[stack.length - 1];
	                    el.children.push(child);
	                    stack.pop();
	                }
	                else {
	                    break;
	                }
	            }
	        }
	        return el;
	    };
	    JSXParser.prototype.parseJSXElement = function () {
	        var node = this.createJSXNode();
	        var opening = this.parseJSXOpeningElement();
	        var children = [];
	        var closing = null;
	        if (!opening.selfClosing) {
	            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
	            children = el.children;
	            closing = el.closing;
	        }
	        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
	    };
	    JSXParser.prototype.parseJSXRoot = function () {
	        // Pop the opening '<' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	        this.startJSX();
	        var element = this.parseJSXElement();
	        this.finishJSX();
	        return element;
	    };
	    JSXParser.prototype.isStartOfExpression = function () {
	        return _super.prototype.isStartOfExpression.call(this) || this.match('<');
	    };
	    return JSXParser;
	}(parser_1.Parser));
	exports.JSXParser = JSXParser;


/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// See also tools/generate-unicode-regex.js.
	var Regex = {
	    // Unicode v8.0.0 NonAsciiIdentifierStart:
	    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
	    // Unicode v8.0.0 NonAsciiIdentifierPart:
	    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	};
	exports.Character = {
	    /* tslint:disable:no-bitwise */
	    fromCodePoint: function (cp) {
	        return (cp < 0x10000) ? String.fromCharCode(cp) :
	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
	                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
	    },
	    // https://tc39.github.io/ecma262/#sec-white-space
	    isWhiteSpace: function (cp) {
	        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
	            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
	    },
	    // https://tc39.github.io/ecma262/#sec-line-terminators
	    isLineTerminator: function (cp) {
	        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
	    },
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    isIdentifierStart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));
	    },
	    isIdentifierPart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp >= 0x30 && cp <= 0x39) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));
	    },
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    isDecimalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39); // 0..9
	    },
	    isHexDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39) ||
	            (cp >= 0x41 && cp <= 0x46) ||
	            (cp >= 0x61 && cp <= 0x66); // a..f
	    },
	    isOctalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x37); // 0..7
	    }
	};


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var jsx_syntax_1 = __webpack_require__(6);
	/* tslint:disable:max-classes-per-file */
	var JSXClosingElement = (function () {
	    function JSXClosingElement(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
	        this.name = name;
	    }
	    return JSXClosingElement;
	}());
	exports.JSXClosingElement = JSXClosingElement;
	var JSXElement = (function () {
	    function JSXElement(openingElement, children, closingElement) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXElement;
	        this.openingElement = openingElement;
	        this.children = children;
	        this.closingElement = closingElement;
	    }
	    return JSXElement;
	}());
	exports.JSXElement = JSXElement;
	var JSXEmptyExpression = (function () {
	    function JSXEmptyExpression() {
	        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
	    }
	    return JSXEmptyExpression;
	}());
	exports.JSXEmptyExpression = JSXEmptyExpression;
	var JSXExpressionContainer = (function () {
	    function JSXExpressionContainer(expression) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
	        this.expression = expression;
	    }
	    return JSXExpressionContainer;
	}());
	exports.JSXExpressionContainer = JSXExpressionContainer;
	var JSXIdentifier = (function () {
	    function JSXIdentifier(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
	        this.name = name;
	    }
	    return JSXIdentifier;
	}());
	exports.JSXIdentifier = JSXIdentifier;
	var JSXMemberExpression = (function () {
	    function JSXMemberExpression(object, property) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
	        this.object = object;
	        this.property = property;
	    }
	    return JSXMemberExpression;
	}());
	exports.JSXMemberExpression = JSXMemberExpression;
	var JSXAttribute = (function () {
	    function JSXAttribute(name, value) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
	        this.name = name;
	        this.value = value;
	    }
	    return JSXAttribute;
	}());
	exports.JSXAttribute = JSXAttribute;
	var JSXNamespacedName = (function () {
	    function JSXNamespacedName(namespace, name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
	        this.namespace = namespace;
	        this.name = name;
	    }
	    return JSXNamespacedName;
	}());
	exports.JSXNamespacedName = JSXNamespacedName;
	var JSXOpeningElement = (function () {
	    function JSXOpeningElement(name, selfClosing, attributes) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
	        this.name = name;
	        this.selfClosing = selfClosing;
	        this.attributes = attributes;
	    }
	    return JSXOpeningElement;
	}());
	exports.JSXOpeningElement = JSXOpeningElement;
	var JSXSpreadAttribute = (function () {
	    function JSXSpreadAttribute(argument) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
	        this.argument = argument;
	    }
	    return JSXSpreadAttribute;
	}());
	exports.JSXSpreadAttribute = JSXSpreadAttribute;
	var JSXText = (function () {
	    function JSXText(value, raw) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXText;
	        this.value = value;
	        this.raw = raw;
	    }
	    return JSXText;
	}());
	exports.JSXText = JSXText;


/***/ },
/* 6 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JSXSyntax = {
	    JSXAttribute: 'JSXAttribute',
	    JSXClosingElement: 'JSXClosingElement',
	    JSXElement: 'JSXElement',
	    JSXEmptyExpression: 'JSXEmptyExpression',
	    JSXExpressionContainer: 'JSXExpressionContainer',
	    JSXIdentifier: 'JSXIdentifier',
	    JSXMemberExpression: 'JSXMemberExpression',
	    JSXNamespacedName: 'JSXNamespacedName',
	    JSXOpeningElement: 'JSXOpeningElement',
	    JSXSpreadAttribute: 'JSXSpreadAttribute',
	    JSXText: 'JSXText'
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	/* tslint:disable:max-classes-per-file */
	var ArrayExpression = (function () {
	    function ArrayExpression(elements) {
	        this.type = syntax_1.Syntax.ArrayExpression;
	        this.elements = elements;
	    }
	    return ArrayExpression;
	}());
	exports.ArrayExpression = ArrayExpression;
	var ArrayPattern = (function () {
	    function ArrayPattern(elements) {
	        this.type = syntax_1.Syntax.ArrayPattern;
	        this.elements = elements;
	    }
	    return ArrayPattern;
	}());
	exports.ArrayPattern = ArrayPattern;
	var ArrowFunctionExpression = (function () {
	    function ArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = false;
	    }
	    return ArrowFunctionExpression;
	}());
	exports.ArrowFunctionExpression = ArrowFunctionExpression;
	var AssignmentExpression = (function () {
	    function AssignmentExpression(operator, left, right) {
	        this.type = syntax_1.Syntax.AssignmentExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentExpression;
	}());
	exports.AssignmentExpression = AssignmentExpression;
	var AssignmentPattern = (function () {
	    function AssignmentPattern(left, right) {
	        this.type = syntax_1.Syntax.AssignmentPattern;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentPattern;
	}());
	exports.AssignmentPattern = AssignmentPattern;
	var AsyncArrowFunctionExpression = (function () {
	    function AsyncArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = true;
	    }
	    return AsyncArrowFunctionExpression;
	}());
	exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
	var AsyncFunctionDeclaration = (function () {
	    function AsyncFunctionDeclaration(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionDeclaration;
	}());
	exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
	var AsyncFunctionExpression = (function () {
	    function AsyncFunctionExpression(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionExpression;
	}());
	exports.AsyncFunctionExpression = AsyncFunctionExpression;
	var AwaitExpression = (function () {
	    function AwaitExpression(argument) {
	        this.type = syntax_1.Syntax.AwaitExpression;
	        this.argument = argument;
	    }
	    return AwaitExpression;
	}());
	exports.AwaitExpression = AwaitExpression;
	var BinaryExpression = (function () {
	    function BinaryExpression(operator, left, right) {
	        var logical = (operator === '||' || operator === '&&');
	        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return BinaryExpression;
	}());
	exports.BinaryExpression = BinaryExpression;
	var BlockStatement = (function () {
	    function BlockStatement(body) {
	        this.type = syntax_1.Syntax.BlockStatement;
	        this.body = body;
	    }
	    return BlockStatement;
	}());
	exports.BlockStatement = BlockStatement;
	var BreakStatement = (function () {
	    function BreakStatement(label) {
	        this.type = syntax_1.Syntax.BreakStatement;
	        this.label = label;
	    }
	    return BreakStatement;
	}());
	exports.BreakStatement = BreakStatement;
	var CallExpression = (function () {
	    function CallExpression(callee, args) {
	        this.type = syntax_1.Syntax.CallExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return CallExpression;
	}());
	exports.CallExpression = CallExpression;
	var CatchClause = (function () {
	    function CatchClause(param, body) {
	        this.type = syntax_1.Syntax.CatchClause;
	        this.param = param;
	        this.body = body;
	    }
	    return CatchClause;
	}());
	exports.CatchClause = CatchClause;
	var ClassBody = (function () {
	    function ClassBody(body) {
	        this.type = syntax_1.Syntax.ClassBody;
	        this.body = body;
	    }
	    return ClassBody;
	}());
	exports.ClassBody = ClassBody;
	var ClassDeclaration = (function () {
	    function ClassDeclaration(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassDeclaration;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassDeclaration;
	}());
	exports.ClassDeclaration = ClassDeclaration;
	var ClassExpression = (function () {
	    function ClassExpression(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassExpression;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassExpression;
	}());
	exports.ClassExpression = ClassExpression;
	var ComputedMemberExpression = (function () {
	    function ComputedMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = true;
	        this.object = object;
	        this.property = property;
	    }
	    return ComputedMemberExpression;
	}());
	exports.ComputedMemberExpression = ComputedMemberExpression;
	var ConditionalExpression = (function () {
	    function ConditionalExpression(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.ConditionalExpression;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return ConditionalExpression;
	}());
	exports.ConditionalExpression = ConditionalExpression;
	var ContinueStatement = (function () {
	    function ContinueStatement(label) {
	        this.type = syntax_1.Syntax.ContinueStatement;
	        this.label = label;
	    }
	    return ContinueStatement;
	}());
	exports.ContinueStatement = ContinueStatement;
	var DebuggerStatement = (function () {
	    function DebuggerStatement() {
	        this.type = syntax_1.Syntax.DebuggerStatement;
	    }
	    return DebuggerStatement;
	}());
	exports.DebuggerStatement = DebuggerStatement;
	var Directive = (function () {
	    function Directive(expression, directive) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	        this.directive = directive;
	    }
	    return Directive;
	}());
	exports.Directive = Directive;
	var DoWhileStatement = (function () {
	    function DoWhileStatement(body, test) {
	        this.type = syntax_1.Syntax.DoWhileStatement;
	        this.body = body;
	        this.test = test;
	    }
	    return DoWhileStatement;
	}());
	exports.DoWhileStatement = DoWhileStatement;
	var EmptyStatement = (function () {
	    function EmptyStatement() {
	        this.type = syntax_1.Syntax.EmptyStatement;
	    }
	    return EmptyStatement;
	}());
	exports.EmptyStatement = EmptyStatement;
	var ExportAllDeclaration = (function () {
	    function ExportAllDeclaration(source) {
	        this.type = syntax_1.Syntax.ExportAllDeclaration;
	        this.source = source;
	    }
	    return ExportAllDeclaration;
	}());
	exports.ExportAllDeclaration = ExportAllDeclaration;
	var ExportDefaultDeclaration = (function () {
	    function ExportDefaultDeclaration(declaration) {
	        this.type = syntax_1.Syntax.ExportDefaultDeclaration;
	        this.declaration = declaration;
	    }
	    return ExportDefaultDeclaration;
	}());
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	var ExportNamedDeclaration = (function () {
	    function ExportNamedDeclaration(declaration, specifiers, source) {
	        this.type = syntax_1.Syntax.ExportNamedDeclaration;
	        this.declaration = declaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ExportNamedDeclaration;
	}());
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	var ExportSpecifier = (function () {
	    function ExportSpecifier(local, exported) {
	        this.type = syntax_1.Syntax.ExportSpecifier;
	        this.exported = exported;
	        this.local = local;
	    }
	    return ExportSpecifier;
	}());
	exports.ExportSpecifier = ExportSpecifier;
	var ExpressionStatement = (function () {
	    function ExpressionStatement(expression) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	    }
	    return ExpressionStatement;
	}());
	exports.ExpressionStatement = ExpressionStatement;
	var ForInStatement = (function () {
	    function ForInStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForInStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	        this.each = false;
	    }
	    return ForInStatement;
	}());
	exports.ForInStatement = ForInStatement;
	var ForOfStatement = (function () {
	    function ForOfStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForOfStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	    }
	    return ForOfStatement;
	}());
	exports.ForOfStatement = ForOfStatement;
	var ForStatement = (function () {
	    function ForStatement(init, test, update, body) {
	        this.type = syntax_1.Syntax.ForStatement;
	        this.init = init;
	        this.test = test;
	        this.update = update;
	        this.body = body;
	    }
	    return ForStatement;
	}());
	exports.ForStatement = ForStatement;
	var FunctionDeclaration = (function () {
	    function FunctionDeclaration(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionDeclaration;
	}());
	exports.FunctionDeclaration = FunctionDeclaration;
	var FunctionExpression = (function () {
	    function FunctionExpression(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionExpression;
	}());
	exports.FunctionExpression = FunctionExpression;
	var Identifier = (function () {
	    function Identifier(name) {
	        this.type = syntax_1.Syntax.Identifier;
	        this.name = name;
	    }
	    return Identifier;
	}());
	exports.Identifier = Identifier;
	var IfStatement = (function () {
	    function IfStatement(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.IfStatement;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return IfStatement;
	}());
	exports.IfStatement = IfStatement;
	var ImportDeclaration = (function () {
	    function ImportDeclaration(specifiers, source) {
	        this.type = syntax_1.Syntax.ImportDeclaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ImportDeclaration;
	}());
	exports.ImportDeclaration = ImportDeclaration;
	var ImportDefaultSpecifier = (function () {
	    function ImportDefaultSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportDefaultSpecifier;
	        this.local = local;
	    }
	    return ImportDefaultSpecifier;
	}());
	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	var ImportNamespaceSpecifier = (function () {
	    function ImportNamespaceSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
	        this.local = local;
	    }
	    return ImportNamespaceSpecifier;
	}());
	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
	var ImportSpecifier = (function () {
	    function ImportSpecifier(local, imported) {
	        this.type = syntax_1.Syntax.ImportSpecifier;
	        this.local = local;
	        this.imported = imported;
	    }
	    return ImportSpecifier;
	}());
	exports.ImportSpecifier = ImportSpecifier;
	var LabeledStatement = (function () {
	    function LabeledStatement(label, body) {
	        this.type = syntax_1.Syntax.LabeledStatement;
	        this.label = label;
	        this.body = body;
	    }
	    return LabeledStatement;
	}());
	exports.LabeledStatement = LabeledStatement;
	var Literal = (function () {
	    function Literal(value, raw) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	    }
	    return Literal;
	}());
	exports.Literal = Literal;
	var MetaProperty = (function () {
	    function MetaProperty(meta, property) {
	        this.type = syntax_1.Syntax.MetaProperty;
	        this.meta = meta;
	        this.property = property;
	    }
	    return MetaProperty;
	}());
	exports.MetaProperty = MetaProperty;
	var MethodDefinition = (function () {
	    function MethodDefinition(key, computed, value, kind, isStatic) {
	        this.type = syntax_1.Syntax.MethodDefinition;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.static = isStatic;
	    }
	    return MethodDefinition;
	}());
	exports.MethodDefinition = MethodDefinition;
	var Module = (function () {
	    function Module(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'module';
	    }
	    return Module;
	}());
	exports.Module = Module;
	var NewExpression = (function () {
	    function NewExpression(callee, args) {
	        this.type = syntax_1.Syntax.NewExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return NewExpression;
	}());
	exports.NewExpression = NewExpression;
	var ObjectExpression = (function () {
	    function ObjectExpression(properties) {
	        this.type = syntax_1.Syntax.ObjectExpression;
	        this.properties = properties;
	    }
	    return ObjectExpression;
	}());
	exports.ObjectExpression = ObjectExpression;
	var ObjectPattern = (function () {
	    function ObjectPattern(properties) {
	        this.type = syntax_1.Syntax.ObjectPattern;
	        this.properties = properties;
	    }
	    return ObjectPattern;
	}());
	exports.ObjectPattern = ObjectPattern;
	var Property = (function () {
	    function Property(kind, key, computed, value, method, shorthand) {
	        this.type = syntax_1.Syntax.Property;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.method = method;
	        this.shorthand = shorthand;
	    }
	    return Property;
	}());
	exports.Property = Property;
	var RegexLiteral = (function () {
	    function RegexLiteral(value, raw, pattern, flags) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	        this.regex = { pattern: pattern, flags: flags };
	    }
	    return RegexLiteral;
	}());
	exports.RegexLiteral = RegexLiteral;
	var RestElement = (function () {
	    function RestElement(argument) {
	        this.type = syntax_1.Syntax.RestElement;
	        this.argument = argument;
	    }
	    return RestElement;
	}());
	exports.RestElement = RestElement;
	var ReturnStatement = (function () {
	    function ReturnStatement(argument) {
	        this.type = syntax_1.Syntax.ReturnStatement;
	        this.argument = argument;
	    }
	    return ReturnStatement;
	}());
	exports.ReturnStatement = ReturnStatement;
	var Script = (function () {
	    function Script(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'script';
	    }
	    return Script;
	}());
	exports.Script = Script;
	var SequenceExpression = (function () {
	    function SequenceExpression(expressions) {
	        this.type = syntax_1.Syntax.SequenceExpression;
	        this.expressions = expressions;
	    }
	    return SequenceExpression;
	}());
	exports.SequenceExpression = SequenceExpression;
	var SpreadElement = (function () {
	    function SpreadElement(argument) {
	        this.type = syntax_1.Syntax.SpreadElement;
	        this.argument = argument;
	    }
	    return SpreadElement;
	}());
	exports.SpreadElement = SpreadElement;
	var StaticMemberExpression = (function () {
	    function StaticMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = false;
	        this.object = object;
	        this.property = property;
	    }
	    return StaticMemberExpression;
	}());
	exports.StaticMemberExpression = StaticMemberExpression;
	var Super = (function () {
	    function Super() {
	        this.type = syntax_1.Syntax.Super;
	    }
	    return Super;
	}());
	exports.Super = Super;
	var SwitchCase = (function () {
	    function SwitchCase(test, consequent) {
	        this.type = syntax_1.Syntax.SwitchCase;
	        this.test = test;
	        this.consequent = consequent;
	    }
	    return SwitchCase;
	}());
	exports.SwitchCase = SwitchCase;
	var SwitchStatement = (function () {
	    function SwitchStatement(discriminant, cases) {
	        this.type = syntax_1.Syntax.SwitchStatement;
	        this.discriminant = discriminant;
	        this.cases = cases;
	    }
	    return SwitchStatement;
	}());
	exports.SwitchStatement = SwitchStatement;
	var TaggedTemplateExpression = (function () {
	    function TaggedTemplateExpression(tag, quasi) {
	        this.type = syntax_1.Syntax.TaggedTemplateExpression;
	        this.tag = tag;
	        this.quasi = quasi;
	    }
	    return TaggedTemplateExpression;
	}());
	exports.TaggedTemplateExpression = TaggedTemplateExpression;
	var TemplateElement = (function () {
	    function TemplateElement(value, tail) {
	        this.type = syntax_1.Syntax.TemplateElement;
	        this.value = value;
	        this.tail = tail;
	    }
	    return TemplateElement;
	}());
	exports.TemplateElement = TemplateElement;
	var TemplateLiteral = (function () {
	    function TemplateLiteral(quasis, expressions) {
	        this.type = syntax_1.Syntax.TemplateLiteral;
	        this.quasis = quasis;
	        this.expressions = expressions;
	    }
	    return TemplateLiteral;
	}());
	exports.TemplateLiteral = TemplateLiteral;
	var ThisExpression = (function () {
	    function ThisExpression() {
	        this.type = syntax_1.Syntax.ThisExpression;
	    }
	    return ThisExpression;
	}());
	exports.ThisExpression = ThisExpression;
	var ThrowStatement = (function () {
	    function ThrowStatement(argument) {
	        this.type = syntax_1.Syntax.ThrowStatement;
	        this.argument = argument;
	    }
	    return ThrowStatement;
	}());
	exports.ThrowStatement = ThrowStatement;
	var TryStatement = (function () {
	    function TryStatement(block, handler, finalizer) {
	        this.type = syntax_1.Syntax.TryStatement;
	        this.block = block;
	        this.handler = handler;
	        this.finalizer = finalizer;
	    }
	    return TryStatement;
	}());
	exports.TryStatement = TryStatement;
	var UnaryExpression = (function () {
	    function UnaryExpression(operator, argument) {
	        this.type = syntax_1.Syntax.UnaryExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = true;
	    }
	    return UnaryExpression;
	}());
	exports.UnaryExpression = UnaryExpression;
	var UpdateExpression = (function () {
	    function UpdateExpression(operator, argument, prefix) {
	        this.type = syntax_1.Syntax.UpdateExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = prefix;
	    }
	    return UpdateExpression;
	}());
	exports.UpdateExpression = UpdateExpression;
	var VariableDeclaration = (function () {
	    function VariableDeclaration(declarations, kind) {
	        this.type = syntax_1.Syntax.VariableDeclaration;
	        this.declarations = declarations;
	        this.kind = kind;
	    }
	    return VariableDeclaration;
	}());
	exports.VariableDeclaration = VariableDeclaration;
	var VariableDeclarator = (function () {
	    function VariableDeclarator(id, init) {
	        this.type = syntax_1.Syntax.VariableDeclarator;
	        this.id = id;
	        this.init = init;
	    }
	    return VariableDeclarator;
	}());
	exports.VariableDeclarator = VariableDeclarator;
	var WhileStatement = (function () {
	    function WhileStatement(test, body) {
	        this.type = syntax_1.Syntax.WhileStatement;
	        this.test = test;
	        this.body = body;
	    }
	    return WhileStatement;
	}());
	exports.WhileStatement = WhileStatement;
	var WithStatement = (function () {
	    function WithStatement(object, body) {
	        this.type = syntax_1.Syntax.WithStatement;
	        this.object = object;
	        this.body = body;
	    }
	    return WithStatement;
	}());
	exports.WithStatement = WithStatement;
	var YieldExpression = (function () {
	    function YieldExpression(argument, delegate) {
	        this.type = syntax_1.Syntax.YieldExpression;
	        this.argument = argument;
	        this.delegate = delegate;
	    }
	    return YieldExpression;
	}());
	exports.YieldExpression = YieldExpression;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var error_handler_1 = __webpack_require__(10);
	var messages_1 = __webpack_require__(11);
	var Node = __webpack_require__(7);
	var scanner_1 = __webpack_require__(12);
	var syntax_1 = __webpack_require__(2);
	var token_1 = __webpack_require__(13);
	var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
	var Parser = (function () {
	    function Parser(code, options, delegate) {
	        if (options === void 0) { options = {}; }
	        this.config = {
	            range: (typeof options.range === 'boolean') && options.range,
	            loc: (typeof options.loc === 'boolean') && options.loc,
	            source: null,
	            tokens: (typeof options.tokens === 'boolean') && options.tokens,
	            comment: (typeof options.comment === 'boolean') && options.comment,
	            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant
	        };
	        if (this.config.loc && options.source && options.source !== null) {
	            this.config.source = String(options.source);
	        }
	        this.delegate = delegate;
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = this.config.tolerant;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = this.config.comment;
	        this.operatorPrecedence = {
	            ')': 0,
	            ';': 0,
	            ',': 0,
	            '=': 0,
	            ']': 0,
	            '||': 1,
	            '&&': 2,
	            '|': 3,
	            '^': 4,
	            '&': 5,
	            '==': 6,
	            '!=': 6,
	            '===': 6,
	            '!==': 6,
	            '<': 7,
	            '>': 7,
	            '<=': 7,
	            '>=': 7,
	            '<<': 8,
	            '>>': 8,
	            '>>>': 8,
	            '+': 9,
	            '-': 9,
	            '*': 11,
	            '/': 11,
	            '%': 11
	        };
	        this.lookahead = {
	            type: 2 /* EOF */,
	            value: '',
	            lineNumber: this.scanner.lineNumber,
	            lineStart: 0,
	            start: 0,
	            end: 0
	        };
	        this.hasLineTerminator = false;
	        this.context = {
	            isModule: false,
	            await: false,
	            allowIn: true,
	            allowStrictDirective: true,
	            allowYield: true,
	            firstCoverInitializedNameError: null,
	            isAssignmentTarget: false,
	            isBindingElement: false,
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            labelSet: {},
	            strict: false
	        };
	        this.tokens = [];
	        this.startMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.lastMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.nextToken();
	        this.lastMarker = {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    }
	    Parser.prototype.throwError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.lastMarker.line;
	        var column = this.lastMarker.column + 1;
	        throw this.errorHandler.createError(index, line, column, msg);
	    };
	    Parser.prototype.tolerateError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.scanner.lineNumber;
	        var column = this.lastMarker.column + 1;
	        this.errorHandler.tolerateError(index, line, column, msg);
	    };
	    // Throw an exception because of the token.
	    Parser.prototype.unexpectedTokenError = function (token, message) {
	        var msg = message || messages_1.Messages.UnexpectedToken;
	        var value;
	        if (token) {
	            if (!message) {
	                msg = (token.type === 2 /* EOF */) ? messages_1.Messages.UnexpectedEOS :
	                    (token.type === 3 /* Identifier */) ? messages_1.Messages.UnexpectedIdentifier :
	                        (token.type === 6 /* NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :
	                            (token.type === 8 /* StringLiteral */) ? messages_1.Messages.UnexpectedString :
	                                (token.type === 10 /* Template */) ? messages_1.Messages.UnexpectedTemplate :
	                                    messages_1.Messages.UnexpectedToken;
	                if (token.type === 4 /* Keyword */) {
	                    if (this.scanner.isFutureReservedWord(token.value)) {
	                        msg = messages_1.Messages.UnexpectedReserved;
	                    }
	                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
	                        msg = messages_1.Messages.StrictReservedWord;
	                    }
	                }
	            }
	            value = token.value;
	        }
	        else {
	            value = 'ILLEGAL';
	        }
	        msg = msg.replace('%0', value);
	        if (token && typeof token.lineNumber === 'number') {
	            var index = token.start;
	            var line = token.lineNumber;
	            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
	            var column = token.start - lastMarkerLineStart + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	        else {
	            var index = this.lastMarker.index;
	            var line = this.lastMarker.line;
	            var column = this.lastMarker.column + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	    };
	    Parser.prototype.throwUnexpectedToken = function (token, message) {
	        throw this.unexpectedTokenError(token, message);
	    };
	    Parser.prototype.tolerateUnexpectedToken = function (token, message) {
	        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
	    };
	    Parser.prototype.collectComments = function () {
	        if (!this.config.comment) {
	            this.scanner.scanComments();
	        }
	        else {
	            var comments = this.scanner.scanComments();
	            if (comments.length > 0 && this.delegate) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var node = void 0;
	                    node = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
	                    };
	                    if (this.config.range) {
	                        node.range = e.range;
	                    }
	                    if (this.config.loc) {
	                        node.loc = e.loc;
	                    }
	                    var metadata = {
	                        start: {
	                            line: e.loc.start.line,
	                            column: e.loc.start.column,
	                            offset: e.range[0]
	                        },
	                        end: {
	                            line: e.loc.end.line,
	                            column: e.loc.end.column,
	                            offset: e.range[1]
	                        }
	                    };
	                    this.delegate(node, metadata);
	                }
	            }
	        }
	    };
	    // From internal representation to an external structure
	    Parser.prototype.getTokenRaw = function (token) {
	        return this.scanner.source.slice(token.start, token.end);
	    };
	    Parser.prototype.convertToken = function (token) {
	        var t = {
	            type: token_1.TokenName[token.type],
	            value: this.getTokenRaw(token)
	        };
	        if (this.config.range) {
	            t.range = [token.start, token.end];
	        }
	        if (this.config.loc) {
	            t.loc = {
	                start: {
	                    line: this.startMarker.line,
	                    column: this.startMarker.column
	                },
	                end: {
	                    line: this.scanner.lineNumber,
	                    column: this.scanner.index - this.scanner.lineStart
	                }
	            };
	        }
	        if (token.type === 9 /* RegularExpression */) {
	            var pattern = token.pattern;
	            var flags = token.flags;
	            t.regex = { pattern: pattern, flags: flags };
	        }
	        return t;
	    };
	    Parser.prototype.nextToken = function () {
	        var token = this.lookahead;
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        this.collectComments();
	        if (this.scanner.index !== this.startMarker.index) {
	            this.startMarker.index = this.scanner.index;
	            this.startMarker.line = this.scanner.lineNumber;
	            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        }
	        var next = this.scanner.lex();
	        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
	        if (next && this.context.strict && next.type === 3 /* Identifier */) {
	            if (this.scanner.isStrictModeReservedWord(next.value)) {
	                next.type = 4 /* Keyword */;
	            }
	        }
	        this.lookahead = next;
	        if (this.config.tokens && next.type !== 2 /* EOF */) {
	            this.tokens.push(this.convertToken(next));
	        }
	        return token;
	    };
	    Parser.prototype.nextRegexToken = function () {
	        this.collectComments();
	        var token = this.scanner.scanRegExp();
	        if (this.config.tokens) {
	            // Pop the previous token, '/' or '/='
	            // This is added from the lookahead token.
	            this.tokens.pop();
	            this.tokens.push(this.convertToken(token));
	        }
	        // Prime the next lookahead.
	        this.lookahead = token;
	        this.nextToken();
	        return token;
	    };
	    Parser.prototype.createNode = function () {
	        return {
	            index: this.startMarker.index,
	            line: this.startMarker.line,
	            column: this.startMarker.column
	        };
	    };
	    Parser.prototype.startNode = function (token) {
	        return {
	            index: token.start,
	            line: token.lineNumber,
	            column: token.start - token.lineStart
	        };
	    };
	    Parser.prototype.finalize = function (marker, node) {
	        if (this.config.range) {
	            node.range = [marker.index, this.lastMarker.index];
	        }
	        if (this.config.loc) {
	            node.loc = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column
	                }
	            };
	            if (this.config.source) {
	                node.loc.source = this.config.source;
	            }
	        }
	        if (this.delegate) {
	            var metadata = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                    offset: marker.index
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column,
	                    offset: this.lastMarker.index
	                }
	            };
	            this.delegate(node, metadata);
	        }
	        return node;
	    };
	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    Parser.prototype.expect = function (value) {
	        var token = this.nextToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
	    Parser.prototype.expectCommaSeparator = function () {
	        if (this.config.tolerant) {
	            var token = this.lookahead;
	            if (token.type === 7 /* Punctuator */ && token.value === ',') {
	                this.nextToken();
	            }
	            else if (token.type === 7 /* Punctuator */ && token.value === ';') {
	                this.nextToken();
	                this.tolerateUnexpectedToken(token);
	            }
	            else {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
	            }
	        }
	        else {
	            this.expect(',');
	        }
	    };
	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.
	    Parser.prototype.expectKeyword = function (keyword) {
	        var token = this.nextToken();
	        if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next token matches the specified punctuator.
	    Parser.prototype.match = function (value) {
	        return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
	    };
	    // Return true if the next token matches the specified keyword
	    Parser.prototype.matchKeyword = function (keyword) {
	        return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token matches the specified contextual keyword
	    // (where an identifier is sometimes a keyword depending on the context)
	    Parser.prototype.matchContextualKeyword = function (keyword) {
	        return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token is an assignment operator
	    Parser.prototype.matchAssign = function () {
	        if (this.lookahead.type !== 7 /* Punctuator */) {
	            return false;
	        }
	        var op = this.lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '**=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    };
	    // Cover grammar support.
	    //
	    // When an assignment expression position starts with an left parenthesis, the determination of the type
	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	    //
	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
	    // after the outermost pair is closed. They are:
	    //
	    //   1. AssignmentExpression
	    //   2. BindingElements
	    //   3. AssignmentTargets
	    //
	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
	    // binding element or assignment target.
	    //
	    // The three productions have the relationship:
	    //
	    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
	    //
	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	    //
	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	    // the CoverInitializedName check is conducted.
	    //
	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	    // pattern. The CoverInitializedName check is deferred.
	    Parser.prototype.isolateCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        if (this.context.firstCoverInitializedNameError !== null) {
	            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
	        }
	        this.context.isBindingElement = previousIsBindingElement;
	        this.context.isAssignmentTarget = previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.inheritCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
	        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.consumeSemicolon = function () {
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else if (!this.hasLineTerminator) {
	            if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.lastMarker.index = this.startMarker.index;
	            this.lastMarker.line = this.startMarker.line;
	            this.lastMarker.column = this.startMarker.column;
	        }
	    };
	    // https://tc39.github.io/ecma262/#sec-primary-expression
	    Parser.prototype.parsePrimaryExpression = function () {
	        var node = this.createNode();
	        var expr;
	        var token, raw;
	        switch (this.lookahead.type) {
	            case 3 /* Identifier */:
	                if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
	                    this.tolerateUnexpectedToken(this.lookahead);
	                }
	                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
	                break;
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	                if (this.context.strict && this.lookahead.octal) {
	                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
	                }
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 1 /* BooleanLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
	                break;
	            case 5 /* NullLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(null, raw));
	                break;
	            case 10 /* Template */:
	                expr = this.parseTemplateLiteral();
	                break;
	            case 7 /* Punctuator */:
	                switch (this.lookahead.value) {
	                    case '(':
	                        this.context.isBindingElement = false;
	                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
	                        break;
	                    case '[':
	                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
	                        break;
	                    case '{':
	                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
	                        break;
	                    case '/':
	                    case '/=':
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                        this.scanner.index = this.startMarker.index;
	                        token = this.nextRegexToken();
	                        raw = this.getTokenRaw(token);
	                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
	                        break;
	                    default:
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                }
	                break;
	            case 4 /* Keyword */:
	                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
	                    expr = this.parseIdentifierName();
	                }
	                else if (!this.context.strict && this.matchKeyword('let')) {
	                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
	                }
	                else {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    if (this.matchKeyword('function')) {
	                        expr = this.parseFunctionExpression();
	                    }
	                    else if (this.matchKeyword('this')) {
	                        this.nextToken();
	                        expr = this.finalize(node, new Node.ThisExpression());
	                    }
	                    else if (this.matchKeyword('class')) {
	                        expr = this.parseClassExpression();
	                    }
	                    else {
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                    }
	                }
	                break;
	            default:
	                expr = this.throwUnexpectedToken(this.nextToken());
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-array-initializer
	    Parser.prototype.parseSpreadElement = function () {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
	        return this.finalize(node, new Node.SpreadElement(arg));
	    };
	    Parser.prototype.parseArrayInitializer = function () {
	        var node = this.createNode();
	        var elements = [];
	        this.expect('[');
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else if (this.match('...')) {
	                var element = this.parseSpreadElement();
	                if (!this.match(']')) {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    this.expect(',');
	                }
	                elements.push(element);
	            }
	            else {
	                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayExpression(elements));
	    };
	    // https://tc39.github.io/ecma262/#sec-object-initializer
	    Parser.prototype.parsePropertyMethod = function (params) {
	        this.context.isAssignmentTarget = false;
	        this.context.isBindingElement = false;
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = params.simple;
	        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
	        if (this.context.strict && params.firstRestricted) {
	            this.tolerateUnexpectedToken(params.firstRestricted, params.message);
	        }
	        if (this.context.strict && params.stricted) {
	            this.tolerateUnexpectedToken(params.stricted, params.message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        return body;
	    };
	    Parser.prototype.parsePropertyMethodFunction = function () {
	        var isGenerator = false;
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = false;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    Parser.prototype.parsePropertyMethodAsyncFunction = function () {
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        var previousAwait = this.context.await;
	        this.context.allowYield = false;
	        this.context.await = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        this.context.await = previousAwait;
	        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
	    };
	    Parser.prototype.parseObjectPropertyKey = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        var key;
	        switch (token.type) {
	            case 8 /* StringLiteral */:
	            case 6 /* NumericLiteral */:
	                if (this.context.strict && token.octal) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
	                }
	                var raw = this.getTokenRaw(token);
	                key = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 3 /* Identifier */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 4 /* Keyword */:
	                key = this.finalize(node, new Node.Identifier(token.value));
	                break;
	            case 7 /* Punctuator */:
	                if (token.value === '[') {
	                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    this.expect(']');
	                }
	                else {
	                    key = this.throwUnexpectedToken(token);
	                }
	                break;
	            default:
	                key = this.throwUnexpectedToken(token);
	        }
	        return key;
	    };
	    Parser.prototype.isPropertyKey = function (key, value) {
	        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||
	            (key.type === syntax_1.Syntax.Literal && key.value === value);
	    };
	    Parser.prototype.parseObjectProperty = function (hasProto) {
	        var node = this.createNode();
	        var token = this.lookahead;
	        var kind;
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var shorthand = false;
	        var isAsync = false;
	        if (token.type === 3 /* Identifier */) {
	            var id = token.value;
	            this.nextToken();
	            computed = this.match('[');
	            isAsync = !this.hasLineTerminator && (id === 'async') &&
	                !this.match(':') && !this.match('(') && !this.match('*');
	            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
	        }
	        else if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
	            kind = 'get';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.context.allowYield = false;
	            value = this.parseGetterMethod();
	        }
	        else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
	            kind = 'set';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseSetterMethod();
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        else {
	            if (!key) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            kind = 'init';
	            if (this.match(':') && !isAsync) {
	                if (!computed && this.isPropertyKey(key, '__proto__')) {
	                    if (hasProto.value) {
	                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
	                    }
	                    hasProto.value = true;
	                }
	                this.nextToken();
	                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
	            }
	            else if (this.match('(')) {
	                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	                method = true;
	            }
	            else if (token.type === 3 /* Identifier */) {
	                var id = this.finalize(node, new Node.Identifier(token.value));
	                if (this.match('=')) {
	                    this.context.firstCoverInitializedNameError = this.lookahead;
	                    this.nextToken();
	                    shorthand = true;
	                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
	                }
	                else {
	                    shorthand = true;
	                    value = id;
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectInitializer = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var properties = [];
	        var hasProto = { value: false };
	        while (!this.match('}')) {
	            properties.push(this.parseObjectProperty(hasProto));
	            if (!this.match('}')) {
	                this.expectCommaSeparator();
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectExpression(properties));
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literals
	    Parser.prototype.parseTemplateHead = function () {
	        assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateElement = function () {
	        if (this.lookahead.type !== 10 /* Template */) {
	            this.throwUnexpectedToken();
	        }
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateLiteral = function () {
	        var node = this.createNode();
	        var expressions = [];
	        var quasis = [];
	        var quasi = this.parseTemplateHead();
	        quasis.push(quasi);
	        while (!quasi.tail) {
	            expressions.push(this.parseExpression());
	            quasi = this.parseTemplateElement();
	            quasis.push(quasi);
	        }
	        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
	    };
	    // https://tc39.github.io/ecma262/#sec-grouping-operator
	    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	            case syntax_1.Syntax.MemberExpression:
	            case syntax_1.Syntax.RestElement:
	            case syntax_1.Syntax.AssignmentPattern:
	                break;
	            case syntax_1.Syntax.SpreadElement:
	                expr.type = syntax_1.Syntax.RestElement;
	                this.reinterpretExpressionAsPattern(expr.argument);
	                break;
	            case syntax_1.Syntax.ArrayExpression:
	                expr.type = syntax_1.Syntax.ArrayPattern;
	                for (var i = 0; i < expr.elements.length; i++) {
	                    if (expr.elements[i] !== null) {
	                        this.reinterpretExpressionAsPattern(expr.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectExpression:
	                expr.type = syntax_1.Syntax.ObjectPattern;
	                for (var i = 0; i < expr.properties.length; i++) {
	                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
	                }
	                break;
	            case syntax_1.Syntax.AssignmentExpression:
	                expr.type = syntax_1.Syntax.AssignmentPattern;
	                delete expr.operator;
	                this.reinterpretExpressionAsPattern(expr.left);
	                break;
	            default:
	                // Allow other node type for tolerant parsing.
	                break;
	        }
	    };
	    Parser.prototype.parseGroupExpression = function () {
	        var expr;
	        this.expect('(');
	        if (this.match(')')) {
	            this.nextToken();
	            if (!this.match('=>')) {
	                this.expect('=>');
	            }
	            expr = {
	                type: ArrowParameterPlaceHolder,
	                params: [],
	                async: false
	            };
	        }
	        else {
	            var startToken = this.lookahead;
	            var params = [];
	            if (this.match('...')) {
	                expr = this.parseRestElement(params);
	                this.expect(')');
	                if (!this.match('=>')) {
	                    this.expect('=>');
	                }
	                expr = {
	                    type: ArrowParameterPlaceHolder,
	                    params: [expr],
	                    async: false
	                };
	            }
	            else {
	                var arrow = false;
	                this.context.isBindingElement = true;
	                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                if (this.match(',')) {
	                    var expressions = [];
	                    this.context.isAssignmentTarget = false;
	                    expressions.push(expr);
	                    while (this.lookahead.type !== 2 /* EOF */) {
	                        if (!this.match(',')) {
	                            break;
	                        }
	                        this.nextToken();
	                        if (this.match(')')) {
	                            this.nextToken();
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else if (this.match('...')) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            expressions.push(this.parseRestElement(params));
	                            this.expect(')');
	                            if (!this.match('=>')) {
	                                this.expect('=>');
	                            }
	                            this.context.isBindingElement = false;
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else {
	                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        if (arrow) {
	                            break;
	                        }
	                    }
	                    if (!arrow) {
	                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	                    }
	                }
	                if (!arrow) {
	                    this.expect(')');
	                    if (this.match('=>')) {
	                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: [expr],
	                                async: false
	                            };
	                        }
	                        if (!arrow) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            if (expr.type === syntax_1.Syntax.SequenceExpression) {
	                                for (var i = 0; i < expr.expressions.length; i++) {
	                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);
	                                }
	                            }
	                            else {
	                                this.reinterpretExpressionAsPattern(expr);
	                            }
	                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: parameters,
	                                async: false
	                            };
	                        }
	                    }
	                    this.context.isBindingElement = false;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
	    Parser.prototype.parseArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAssignmentExpression);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.isIdentifierName = function (token) {
	        return token.type === 3 /* Identifier */ ||
	            token.type === 4 /* Keyword */ ||
	            token.type === 1 /* BooleanLiteral */ ||
	            token.type === 5 /* NullLiteral */;
	    };
	    Parser.prototype.parseIdentifierName = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (!this.isIdentifierName(token)) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseNewExpression = function () {
	        var node = this.createNode();
	        var id = this.parseIdentifierName();
	        assert_1.assert(id.name === 'new', 'New expression must start with `new`');
	        var expr;
	        if (this.match('.')) {
	            this.nextToken();
	            if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
	                var property = this.parseIdentifierName();
	                expr = new Node.MetaProperty(id, property);
	            }
	            else {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
	            var args = this.match('(') ? this.parseArguments() : [];
	            expr = new Node.NewExpression(callee, args);
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return this.finalize(node, expr);
	    };
	    Parser.prototype.parseAsyncArgument = function () {
	        var arg = this.parseAssignmentExpression();
	        this.context.firstCoverInitializedNameError = null;
	        return arg;
	    };
	    Parser.prototype.parseAsyncArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAsyncArgument);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
	        var startToken = this.lookahead;
	        var maybeAsync = this.matchContextualKeyword('async');
	        var previousAllowIn = this.context.allowIn;
	        this.context.allowIn = true;
	        var expr;
	        if (this.matchKeyword('super') && this.context.inFunctionBody) {
	            expr = this.createNode();
	            this.nextToken();
	            expr = this.finalize(expr, new Node.Super());
	            if (!this.match('(') && !this.match('.') && !this.match('[')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        }
	        while (true) {
	            if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.match('(')) {
	                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = false;
	                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
	                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
	                if (asyncArrow && this.match('=>')) {
	                    for (var i = 0; i < args.length; ++i) {
	                        this.reinterpretExpressionAsPattern(args[i]);
	                    }
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: args,
	                        async: true
	                    };
	                }
	            }
	            else if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        this.context.allowIn = previousAllowIn;
	        return expr;
	    };
	    Parser.prototype.parseSuper = function () {
	        var node = this.createNode();
	        this.expectKeyword('super');
	        if (!this.match('[') && !this.match('.')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        return this.finalize(node, new Node.Super());
	    };
	    Parser.prototype.parseLeftHandSideExpression = function () {
	        assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
	        var node = this.startNode(this.lookahead);
	        var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :
	            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        while (true) {
	            if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-update-expressions
	    Parser.prototype.parseUpdateExpression = function () {
	        var expr;
	        var startToken = this.lookahead;
	        if (this.match('++') || this.match('--')) {
	            var node = this.startNode(startToken);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
	            }
	            if (!this.context.isAssignmentTarget) {
	                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	            }
	            var prefix = true;
	            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
	                if (this.match('++') || this.match('--')) {
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
	                    }
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    var operator = this.nextToken().value;
	                    var prefix = false;
	                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-unary-operators
	    Parser.prototype.parseAwaitExpression = function () {
	        var node = this.createNode();
	        this.nextToken();
	        var argument = this.parseUnaryExpression();
	        return this.finalize(node, new Node.AwaitExpression(argument));
	    };
	    Parser.prototype.parseUnaryExpression = function () {
	        var expr;
	        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||
	            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
	            var node = this.startNode(this.lookahead);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
	            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
	                this.tolerateError(messages_1.Messages.StrictDelete);
	            }
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else if (this.context.await && this.matchContextualKeyword('await')) {
	            expr = this.parseAwaitExpression();
	        }
	        else {
	            expr = this.parseUpdateExpression();
	        }
	        return expr;
	    };
	    Parser.prototype.parseExponentiationExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-exp-operator
	    // https://tc39.github.io/ecma262/#sec-multiplicative-operators
	    // https://tc39.github.io/ecma262/#sec-additive-operators
	    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
	    // https://tc39.github.io/ecma262/#sec-relational-operators
	    // https://tc39.github.io/ecma262/#sec-equality-operators
	    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
	    // https://tc39.github.io/ecma262/#sec-binary-logical-operators
	    Parser.prototype.binaryPrecedence = function (token) {
	        var op = token.value;
	        var precedence;
	        if (token.type === 7 /* Punctuator */) {
	            precedence = this.operatorPrecedence[op] || 0;
	        }
	        else if (token.type === 4 /* Keyword */) {
	            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;
	        }
	        else {
	            precedence = 0;
	        }
	        return precedence;
	    };
	    Parser.prototype.parseBinaryExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
	        var token = this.lookahead;
	        var prec = this.binaryPrecedence(token);
	        if (prec > 0) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var markers = [startToken, this.lookahead];
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            var stack = [left, token.value, right];
	            var precedences = [prec];
	            while (true) {
	                prec = this.binaryPrecedence(this.lookahead);
	                if (prec <= 0) {
	                    break;
	                }
	                // Reduce: make a binary expression from the three topmost entries.
	                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {
	                    right = stack.pop();
	                    var operator = stack.pop();
	                    precedences.pop();
	                    left = stack.pop();
	                    markers.pop();
	                    var node = this.startNode(markers[markers.length - 1]);
	                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
	                }
	                // Shift.
	                stack.push(this.nextToken().value);
	                precedences.push(prec);
	                markers.push(this.lookahead);
	                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
	            }
	            // Final reduce to clean-up the stack.
	            var i = stack.length - 1;
	            expr = stack[i];
	            markers.pop();
	            while (i > 1) {
	                var node = this.startNode(markers.pop());
	                var operator = stack[i - 1];
	                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
	                i -= 2;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-conditional-operator
	    Parser.prototype.parseConditionalExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
	        if (this.match('?')) {
	            this.nextToken();
	            var previousAllowIn = this.context.allowIn;
	            this.context.allowIn = true;
	            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowIn = previousAllowIn;
	            this.expect(':');
	            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-assignment-operators
	    Parser.prototype.checkPatternParam = function (options, param) {
	        switch (param.type) {
	            case syntax_1.Syntax.Identifier:
	                this.validateParam(options, param, param.name);
	                break;
	            case syntax_1.Syntax.RestElement:
	                this.checkPatternParam(options, param.argument);
	                break;
	            case syntax_1.Syntax.AssignmentPattern:
	                this.checkPatternParam(options, param.left);
	                break;
	            case syntax_1.Syntax.ArrayPattern:
	                for (var i = 0; i < param.elements.length; i++) {
	                    if (param.elements[i] !== null) {
	                        this.checkPatternParam(options, param.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectPattern:
	                for (var i = 0; i < param.properties.length; i++) {
	                    this.checkPatternParam(options, param.properties[i].value);
	                }
	                break;
	            default:
	                break;
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	    };
	    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
	        var params = [expr];
	        var options;
	        var asyncArrow = false;
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	                break;
	            case ArrowParameterPlaceHolder:
	                params = expr.params;
	                asyncArrow = expr.async;
	                break;
	            default:
	                return null;
	        }
	        options = {
	            simple: true,
	            paramSet: {}
	        };
	        for (var i = 0; i < params.length; ++i) {
	            var param = params[i];
	            if (param.type === syntax_1.Syntax.AssignmentPattern) {
	                if (param.right.type === syntax_1.Syntax.YieldExpression) {
	                    if (param.right.argument) {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                    param.right.type = syntax_1.Syntax.Identifier;
	                    param.right.name = 'yield';
	                    delete param.right.argument;
	                    delete param.right.delegate;
	                }
	            }
	            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.checkPatternParam(options, param);
	            params[i] = param;
	        }
	        if (this.context.strict || !this.context.allowYield) {
	            for (var i = 0; i < params.length; ++i) {
	                var param = params[i];
	                if (param.type === syntax_1.Syntax.YieldExpression) {
	                    this.throwUnexpectedToken(this.lookahead);
	                }
	            }
	        }
	        if (options.message === messages_1.Messages.StrictParamDupe) {
	            var token = this.context.strict ? options.stricted : options.firstRestricted;
	            this.throwUnexpectedToken(token, options.message);
	        }
	        return {
	            simple: options.simple,
	            params: params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.parseAssignmentExpression = function () {
	        var expr;
	        if (!this.context.allowYield && this.matchKeyword('yield')) {
	            expr = this.parseYieldExpression();
	        }
	        else {
	            var startToken = this.lookahead;
	            var token = startToken;
	            expr = this.parseConditionalExpression();
	            if (token.type === 3 /* Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {
	                if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
	                    var arg = this.parsePrimaryExpression();
	                    this.reinterpretExpressionAsPattern(arg);
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: [arg],
	                        async: true
	                    };
	                }
	            }
	            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
	                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                var isAsync = expr.async;
	                var list = this.reinterpretAsCoverFormalsList(expr);
	                if (list) {
	                    if (this.hasLineTerminator) {
	                        this.tolerateUnexpectedToken(this.lookahead);
	                    }
	                    this.context.firstCoverInitializedNameError = null;
	                    var previousStrict = this.context.strict;
	                    var previousAllowStrictDirective = this.context.allowStrictDirective;
	                    this.context.allowStrictDirective = list.simple;
	                    var previousAllowYield = this.context.allowYield;
	                    var previousAwait = this.context.await;
	                    this.context.allowYield = true;
	                    this.context.await = isAsync;
	                    var node = this.startNode(startToken);
	                    this.expect('=>');
	                    var body = void 0;
	                    if (this.match('{')) {
	                        var previousAllowIn = this.context.allowIn;
	                        this.context.allowIn = true;
	                        body = this.parseFunctionSourceElements();
	                        this.context.allowIn = previousAllowIn;
	                    }
	                    else {
	                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    }
	                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
	                    if (this.context.strict && list.firstRestricted) {
	                        this.throwUnexpectedToken(list.firstRestricted, list.message);
	                    }
	                    if (this.context.strict && list.stricted) {
	                        this.tolerateUnexpectedToken(list.stricted, list.message);
	                    }
	                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :
	                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
	                    this.context.strict = previousStrict;
	                    this.context.allowStrictDirective = previousAllowStrictDirective;
	                    this.context.allowYield = previousAllowYield;
	                    this.context.await = previousAwait;
	                }
	            }
	            else {
	                if (this.matchAssign()) {
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
	                        var id = expr;
	                        if (this.scanner.isRestrictedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
	                        }
	                        if (this.scanner.isStrictModeReservedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	                        }
	                    }
	                    if (!this.match('=')) {
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                    }
	                    else {
	                        this.reinterpretExpressionAsPattern(expr);
	                    }
	                    token = this.nextToken();
	                    var operator = token.value;
	                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
	                    this.context.firstCoverInitializedNameError = null;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-comma-operator
	    Parser.prototype.parseExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        if (this.match(',')) {
	            var expressions = [];
	            expressions.push(expr);
	            while (this.lookahead.type !== 2 /* EOF */) {
	                if (!this.match(',')) {
	                    break;
	                }
	                this.nextToken();
	                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	            }
	            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-block
	    Parser.prototype.parseStatementListItem = function () {
	        var statement;
	        this.context.isAssignmentTarget = true;
	        this.context.isBindingElement = true;
	        if (this.lookahead.type === 4 /* Keyword */) {
	            switch (this.lookahead.value) {
	                case 'export':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
	                    }
	                    statement = this.parseExportDeclaration();
	                    break;
	                case 'import':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
	                    }
	                    statement = this.parseImportDeclaration();
	                    break;
	                case 'const':
	                    statement = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'function':
	                    statement = this.parseFunctionDeclaration();
	                    break;
	                case 'class':
	                    statement = this.parseClassDeclaration();
	                    break;
	                case 'let':
	                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
	                    break;
	                default:
	                    statement = this.parseStatement();
	                    break;
	            }
	        }
	        else {
	            statement = this.parseStatement();
	        }
	        return statement;
	    };
	    Parser.prototype.parseBlock = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var block = [];
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            block.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.BlockStatement(block));
	    };
	    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations
	    Parser.prototype.parseLexicalBinding = function (kind, options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, kind);
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (kind === 'const') {
	            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
	                if (this.match('=')) {
	                    this.nextToken();
	                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                }
	                else {
	                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
	                }
	            }
	        }
	        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {
	            this.expect('=');
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseBindingList = function (kind, options) {
	        var list = [this.parseLexicalBinding(kind, options)];
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseLexicalBinding(kind, options));
	        }
	        return list;
	    };
	    Parser.prototype.isLexicalDeclaration = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.scanner.lex();
	        this.scanner.restoreState(state);
	        return (next.type === 3 /* Identifier */) ||
	            (next.type === 7 /* Punctuator */ && next.value === '[') ||
	            (next.type === 7 /* Punctuator */ && next.value === '{') ||
	            (next.type === 4 /* Keyword */ && next.value === 'let') ||
	            (next.type === 4 /* Keyword */ && next.value === 'yield');
	    };
	    Parser.prototype.parseLexicalDeclaration = function (options) {
	        var node = this.createNode();
	        var kind = this.nextToken().value;
	        assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
	        var declarations = this.parseBindingList(kind, options);
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
	    };
	    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
	    Parser.prototype.parseBindingRestElement = function (params, kind) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params, kind);
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseArrayPattern = function (params, kind) {
	        var node = this.createNode();
	        this.expect('[');
	        var elements = [];
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else {
	                if (this.match('...')) {
	                    elements.push(this.parseBindingRestElement(params, kind));
	                    break;
	                }
	                else {
	                    elements.push(this.parsePatternWithDefault(params, kind));
	                }
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayPattern(elements));
	    };
	    Parser.prototype.parsePropertyPattern = function (params, kind) {
	        var node = this.createNode();
	        var computed = false;
	        var shorthand = false;
	        var method = false;
	        var key;
	        var value;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            var keyToken = this.lookahead;
	            key = this.parseVariableIdentifier();
	            var init = this.finalize(node, new Node.Identifier(keyToken.value));
	            if (this.match('=')) {
	                params.push(keyToken);
	                shorthand = true;
	                this.nextToken();
	                var expr = this.parseAssignmentExpression();
	                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
	            }
	            else if (!this.match(':')) {
	                params.push(keyToken);
	                shorthand = true;
	                value = init;
	            }
	            else {
	                this.expect(':');
	                value = this.parsePatternWithDefault(params, kind);
	            }
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.expect(':');
	            value = this.parsePatternWithDefault(params, kind);
	        }
	        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectPattern = function (params, kind) {
	        var node = this.createNode();
	        var properties = [];
	        this.expect('{');
	        while (!this.match('}')) {
	            properties.push(this.parsePropertyPattern(params, kind));
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectPattern(properties));
	    };
	    Parser.prototype.parsePattern = function (params, kind) {
	        var pattern;
	        if (this.match('[')) {
	            pattern = this.parseArrayPattern(params, kind);
	        }
	        else if (this.match('{')) {
	            pattern = this.parseObjectPattern(params, kind);
	        }
	        else {
	            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
	                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
	            }
	            params.push(this.lookahead);
	            pattern = this.parseVariableIdentifier(kind);
	        }
	        return pattern;
	    };
	    Parser.prototype.parsePatternWithDefault = function (params, kind) {
	        var startToken = this.lookahead;
	        var pattern = this.parsePattern(params, kind);
	        if (this.match('=')) {
	            this.nextToken();
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = true;
	            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowYield = previousAllowYield;
	            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
	        }
	        return pattern;
	    };
	    // https://tc39.github.io/ecma262/#sec-variable-statement
	    Parser.prototype.parseVariableIdentifier = function (kind) {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (token.type === 4 /* Keyword */ && token.value === 'yield') {
	            if (this.context.strict) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else if (!this.context.allowYield) {
	                this.throwUnexpectedToken(token);
	            }
	        }
	        else if (token.type !== 3 /* Identifier */) {
	            if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else {
	                if (this.context.strict || token.value !== 'let' || kind !== 'var') {
	                    this.throwUnexpectedToken(token);
	                }
	            }
	        }
	        else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
	            this.tolerateUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseVariableDeclaration = function (options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, 'var');
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (this.match('=')) {
	            this.nextToken();
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
	            this.expect('=');
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseVariableDeclarationList = function (options) {
	        var opt = { inFor: options.inFor };
	        var list = [];
	        list.push(this.parseVariableDeclaration(opt));
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseVariableDeclaration(opt));
	        }
	        return list;
	    };
	    Parser.prototype.parseVariableStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('var');
	        var declarations = this.parseVariableDeclarationList({ inFor: false });
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
	    };
	    // https://tc39.github.io/ecma262/#sec-empty-statement
	    Parser.prototype.parseEmptyStatement = function () {
	        var node = this.createNode();
	        this.expect(';');
	        return this.finalize(node, new Node.EmptyStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-expression-statement
	    Parser.prototype.parseExpressionStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ExpressionStatement(expr));
	    };
	    // https://tc39.github.io/ecma262/#sec-if-statement
	    Parser.prototype.parseIfClause = function () {
	        if (this.context.strict && this.matchKeyword('function')) {
	            this.tolerateError(messages_1.Messages.StrictFunction);
	        }
	        return this.parseStatement();
	    };
	    Parser.prototype.parseIfStatement = function () {
	        var node = this.createNode();
	        var consequent;
	        var alternate = null;
	        this.expectKeyword('if');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            consequent = this.parseIfClause();
	            if (this.matchKeyword('else')) {
	                this.nextToken();
	                alternate = this.parseIfClause();
	            }
	        }
	        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
	    };
	    // https://tc39.github.io/ecma262/#sec-do-while-statement
	    Parser.prototype.parseDoWhileStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('do');
	        var previousInIteration = this.context.inIteration;
	        this.context.inIteration = true;
	        var body = this.parseStatement();
	        this.context.inIteration = previousInIteration;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	        }
	        else {
	            this.expect(')');
	            if (this.match(';')) {
	                this.nextToken();
	            }
	        }
	        return this.finalize(node, new Node.DoWhileStatement(body, test));
	    };
	    // https://tc39.github.io/ecma262/#sec-while-statement
	    Parser.prototype.parseWhileStatement = function () {
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.parseStatement();
	            this.context.inIteration = previousInIteration;
	        }
	        return this.finalize(node, new Node.WhileStatement(test, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-for-statement
	    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
	    Parser.prototype.parseForStatement = function () {
	        var init = null;
	        var test = null;
	        var update = null;
	        var forIn = true;
	        var left, right;
	        var node = this.createNode();
	        this.expectKeyword('for');
	        this.expect('(');
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else {
	            if (this.matchKeyword('var')) {
	                init = this.createNode();
	                this.nextToken();
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                var declarations = this.parseVariableDeclarationList({ inFor: true });
	                this.context.allowIn = previousAllowIn;
	                if (declarations.length === 1 && this.matchKeyword('in')) {
	                    var decl = declarations[0];
	                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
	                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
	                    }
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.expect(';');
	                }
	            }
	            else if (this.matchKeyword('const') || this.matchKeyword('let')) {
	                init = this.createNode();
	                var kind = this.nextToken().value;
	                if (!this.context.strict && this.lookahead.value === 'in') {
	                    init = this.finalize(init, new Node.Identifier(kind));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else {
	                    var previousAllowIn = this.context.allowIn;
	                    this.context.allowIn = false;
	                    var declarations = this.parseBindingList(kind, { inFor: true });
	                    this.context.allowIn = previousAllowIn;
	                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseExpression();
	                        init = null;
	                    }
	                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseAssignmentExpression();
	                        init = null;
	                        forIn = false;
	                    }
	                    else {
	                        this.consumeSemicolon();
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                    }
	                }
	            }
	            else {
	                var initStartToken = this.lookahead;
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                this.context.allowIn = previousAllowIn;
	                if (this.matchKeyword('in')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (this.matchContextualKeyword('of')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    if (this.match(',')) {
	                        var initSeq = [init];
	                        while (this.match(',')) {
	                            this.nextToken();
	                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
	                    }
	                    this.expect(';');
	                }
	            }
	        }
	        if (typeof left === 'undefined') {
	            if (!this.match(';')) {
	                test = this.parseExpression();
	            }
	            this.expect(';');
	            if (!this.match(')')) {
	                update = this.parseExpression();
	            }
	        }
	        var body;
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.isolateCoverGrammar(this.parseStatement);
	            this.context.inIteration = previousInIteration;
	        }
	        return (typeof left === 'undefined') ?
	            this.finalize(node, new Node.ForStatement(init, test, update, body)) :
	            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :
	                this.finalize(node, new Node.ForOfStatement(left, right, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-continue-statement
	    Parser.prototype.parseContinueStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('continue');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            label = id;
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration) {
	            this.throwError(messages_1.Messages.IllegalContinue);
	        }
	        return this.finalize(node, new Node.ContinueStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-break-statement
	    Parser.prototype.parseBreakStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('break');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	            label = id;
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration && !this.context.inSwitch) {
	            this.throwError(messages_1.Messages.IllegalBreak);
	        }
	        return this.finalize(node, new Node.BreakStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-return-statement
	    Parser.prototype.parseReturnStatement = function () {
	        if (!this.context.inFunctionBody) {
	            this.tolerateError(messages_1.Messages.IllegalReturn);
	        }
	        var node = this.createNode();
	        this.expectKeyword('return');
	        var hasArgument = !this.match(';') && !this.match('}') &&
	            !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */;
	        var argument = hasArgument ? this.parseExpression() : null;
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ReturnStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-with-statement
	    Parser.prototype.parseWithStatement = function () {
	        if (this.context.strict) {
	            this.tolerateError(messages_1.Messages.StrictModeWith);
	        }
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('with');
	        this.expect('(');
	        var object = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            body = this.parseStatement();
	        }
	        return this.finalize(node, new Node.WithStatement(object, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-switch-statement
	    Parser.prototype.parseSwitchCase = function () {
	        var node = this.createNode();
	        var test;
	        if (this.matchKeyword('default')) {
	            this.nextToken();
	            test = null;
	        }
	        else {
	            this.expectKeyword('case');
	            test = this.parseExpression();
	        }
	        this.expect(':');
	        var consequent = [];
	        while (true) {
	            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
	                break;
	            }
	            consequent.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.SwitchCase(test, consequent));
	    };
	    Parser.prototype.parseSwitchStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('switch');
	        this.expect('(');
	        var discriminant = this.parseExpression();
	        this.expect(')');
	        var previousInSwitch = this.context.inSwitch;
	        this.context.inSwitch = true;
	        var cases = [];
	        var defaultFound = false;
	        this.expect('{');
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            var clause = this.parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }
	        this.expect('}');
	        this.context.inSwitch = previousInSwitch;
	        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
	    };
	    // https://tc39.github.io/ecma262/#sec-labelled-statements
	    Parser.prototype.parseLabelledStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var statement;
	        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {
	            this.nextToken();
	            var id = expr;
	            var key = '$' + id.name;
	            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
	            }
	            this.context.labelSet[key] = true;
	            var body = void 0;
	            if (this.matchKeyword('class')) {
	                this.tolerateUnexpectedToken(this.lookahead);
	                body = this.parseClassDeclaration();
	            }
	            else if (this.matchKeyword('function')) {
	                var token = this.lookahead;
	                var declaration = this.parseFunctionDeclaration();
	                if (this.context.strict) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
	                }
	                else if (declaration.generator) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
	                }
	                body = declaration;
	            }
	            else {
	                body = this.parseStatement();
	            }
	            delete this.context.labelSet[key];
	            statement = new Node.LabeledStatement(id, body);
	        }
	        else {
	            this.consumeSemicolon();
	            statement = new Node.ExpressionStatement(expr);
	        }
	        return this.finalize(node, statement);
	    };
	    // https://tc39.github.io/ecma262/#sec-throw-statement
	    Parser.prototype.parseThrowStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('throw');
	        if (this.hasLineTerminator) {
	            this.throwError(messages_1.Messages.NewlineAfterThrow);
	        }
	        var argument = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ThrowStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-try-statement
	    Parser.prototype.parseCatchClause = function () {
	        var node = this.createNode();
	        this.expectKeyword('catch');
	        this.expect('(');
	        if (this.match(')')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        var params = [];
	        var param = this.parsePattern(params);
	        var paramMap = {};
	        for (var i = 0; i < params.length; i++) {
	            var key = '$' + params[i].value;
	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
	                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
	            }
	            paramMap[key] = true;
	        }
	        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(param.name)) {
	                this.tolerateError(messages_1.Messages.StrictCatchVariable);
	            }
	        }
	        this.expect(')');
	        var body = this.parseBlock();
	        return this.finalize(node, new Node.CatchClause(param, body));
	    };
	    Parser.prototype.parseFinallyClause = function () {
	        this.expectKeyword('finally');
	        return this.parseBlock();
	    };
	    Parser.prototype.parseTryStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('try');
	        var block = this.parseBlock();
	        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
	        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
	        if (!handler && !finalizer) {
	            this.throwError(messages_1.Messages.NoCatchOrFinally);
	        }
	        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
	    };
	    // https://tc39.github.io/ecma262/#sec-debugger-statement
	    Parser.prototype.parseDebuggerStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('debugger');
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.DebuggerStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
	    Parser.prototype.parseStatement = function () {
	        var statement;
	        switch (this.lookahead.type) {
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	            case 10 /* Template */:
	            case 9 /* RegularExpression */:
	                statement = this.parseExpressionStatement();
	                break;
	            case 7 /* Punctuator */:
	                var value = this.lookahead.value;
	                if (value === '{') {
	                    statement = this.parseBlock();
	                }
	                else if (value === '(') {
	                    statement = this.parseExpressionStatement();
	                }
	                else if (value === ';') {
	                    statement = this.parseEmptyStatement();
	                }
	                else {
	                    statement = this.parseExpressionStatement();
	                }
	                break;
	            case 3 /* Identifier */:
	                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
	                break;
	            case 4 /* Keyword */:
	                switch (this.lookahead.value) {
	                    case 'break':
	                        statement = this.parseBreakStatement();
	                        break;
	                    case 'continue':
	                        statement = this.parseContinueStatement();
	                        break;
	                    case 'debugger':
	                        statement = this.parseDebuggerStatement();
	                        break;
	                    case 'do':
	                        statement = this.parseDoWhileStatement();
	                        break;
	                    case 'for':
	                        statement = this.parseForStatement();
	                        break;
	                    case 'function':
	                        statement = this.parseFunctionDeclaration();
	                        break;
	                    case 'if':
	                        statement = this.parseIfStatement();
	                        break;
	                    case 'return':
	                        statement = this.parseReturnStatement();
	                        break;
	                    case 'switch':
	                        statement = this.parseSwitchStatement();
	                        break;
	                    case 'throw':
	                        statement = this.parseThrowStatement();
	                        break;
	                    case 'try':
	                        statement = this.parseTryStatement();
	                        break;
	                    case 'var':
	                        statement = this.parseVariableStatement();
	                        break;
	                    case 'while':
	                        statement = this.parseWhileStatement();
	                        break;
	                    case 'with':
	                        statement = this.parseWithStatement();
	                        break;
	                    default:
	                        statement = this.parseExpressionStatement();
	                        break;
	                }
	                break;
	            default:
	                statement = this.throwUnexpectedToken(this.lookahead);
	        }
	        return statement;
	    };
	    // https://tc39.github.io/ecma262/#sec-function-definitions
	    Parser.prototype.parseFunctionSourceElements = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var body = this.parseDirectivePrologues();
	        var previousLabelSet = this.context.labelSet;
	        var previousInIteration = this.context.inIteration;
	        var previousInSwitch = this.context.inSwitch;
	        var previousInFunctionBody = this.context.inFunctionBody;
	        this.context.labelSet = {};
	        this.context.inIteration = false;
	        this.context.inSwitch = false;
	        this.context.inFunctionBody = true;
	        while (this.lookahead.type !== 2 /* EOF */) {
	            if (this.match('}')) {
	                break;
	            }
	            body.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        this.context.labelSet = previousLabelSet;
	        this.context.inIteration = previousInIteration;
	        this.context.inSwitch = previousInSwitch;
	        this.context.inFunctionBody = previousInFunctionBody;
	        return this.finalize(node, new Node.BlockStatement(body));
	    };
	    Parser.prototype.validateParam = function (options, param, name) {
	        var key = '$' + name;
	        if (this.context.strict) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        else if (!options.firstRestricted) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            else if (this.scanner.isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictReservedWord;
	            }
	            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        /* istanbul ignore next */
	        if (typeof Object.defineProperty === 'function') {
	            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
	        }
	        else {
	            options.paramSet[key] = true;
	        }
	    };
	    Parser.prototype.parseRestElement = function (params) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params);
	        if (this.match('=')) {
	            this.throwError(messages_1.Messages.DefaultRestParameter);
	        }
	        if (!this.match(')')) {
	            this.throwError(messages_1.Messages.ParameterAfterRestParameter);
	        }
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseFormalParameter = function (options) {
	        var params = [];
	        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
	        for (var i = 0; i < params.length; i++) {
	            this.validateParam(options, params[i], params[i].value);
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	        options.params.push(param);
	    };
	    Parser.prototype.parseFormalParameters = function (firstRestricted) {
	        var options;
	        options = {
	            simple: true,
	            params: [],
	            firstRestricted: firstRestricted
	        };
	        this.expect('(');
	        if (!this.match(')')) {
	            options.paramSet = {};
	            while (this.lookahead.type !== 2 /* EOF */) {
	                this.parseFormalParameter(options);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expect(',');
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return {
	            simple: options.simple,
	            params: options.params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.matchAsyncFunction = function () {
	        var match = this.matchContextualKeyword('async');
	        if (match) {
	            var state = this.scanner.saveState();
	            this.scanner.scanComments();
	            var next = this.scanner.lex();
	            this.scanner.restoreState(state);
	            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Keyword */) && (next.value === 'function');
	        }
	        return match;
	    };
	    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted = null;
	        if (!identifierIsOptional || !this.match('(')) {
	            var token = this.lookahead;
	            id = this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :
	            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
	    };
	    Parser.prototype.parseFunctionExpression = function () {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted;
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        if (!this.match('(')) {
	            var token = this.lookahead;
	            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :
	            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
	    Parser.prototype.parseDirective = function () {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;
	        this.consumeSemicolon();
	        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
	    };
	    Parser.prototype.parseDirectivePrologues = function () {
	        var firstRestricted = null;
	        var body = [];
	        while (true) {
	            var token = this.lookahead;
	            if (token.type !== 8 /* StringLiteral */) {
	                break;
	            }
	            var statement = this.parseDirective();
	            body.push(statement);
	            var directive = statement.directive;
	            if (typeof directive !== 'string') {
	                break;
	            }
	            if (directive === 'use strict') {
	                this.context.strict = true;
	                if (firstRestricted) {
	                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
	                }
	                if (!this.context.allowStrictDirective) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
	                }
	            }
	            else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }
	        return body;
	    };
	    // https://tc39.github.io/ecma262/#sec-method-definitions
	    Parser.prototype.qualifiedPropertyName = function (token) {
	        switch (token.type) {
	            case 3 /* Identifier */:
	            case 8 /* StringLiteral */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 4 /* Keyword */:
	                return true;
	            case 7 /* Punctuator */:
	                return token.value === '[';
	            default:
	                break;
	        }
	        return false;
	    };
	    Parser.prototype.parseGetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = false;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length > 0) {
	            this.tolerateError(messages_1.Messages.BadGetterArity);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseSetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = false;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length !== 1) {
	            this.tolerateError(messages_1.Messages.BadSetterArity);
	        }
	        else if (formalParameters.params[0] instanceof Node.RestElement) {
	            this.tolerateError(messages_1.Messages.BadSetterRestParameter);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseGeneratorMethod = function () {
	        var node = this.createNode();
	        var isGenerator = true;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        this.context.allowYield = false;
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-generator-function-definitions
	    Parser.prototype.isStartOfExpression = function () {
	        var start = true;
	        var value = this.lookahead.value;
	        switch (this.lookahead.type) {
	            case 7 /* Punctuator */:
	                start = (value === '[') || (value === '(') || (value === '{') ||
	                    (value === '+') || (value === '-') ||
	                    (value === '!') || (value === '~') ||
	                    (value === '++') || (value === '--') ||
	                    (value === '/') || (value === '/='); // regular expression literal
	                break;
	            case 4 /* Keyword */:
	                start = (value === 'class') || (value === 'delete') ||
	                    (value === 'function') || (value === 'let') || (value === 'new') ||
	                    (value === 'super') || (value === 'this') || (value === 'typeof') ||
	                    (value === 'void') || (value === 'yield');
	                break;
	            default:
	                break;
	        }
	        return start;
	    };
	    Parser.prototype.parseYieldExpression = function () {
	        var node = this.createNode();
	        this.expectKeyword('yield');
	        var argument = null;
	        var delegate = false;
	        if (!this.hasLineTerminator) {
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = false;
	            delegate = this.match('*');
	            if (delegate) {
	                this.nextToken();
	                argument = this.parseAssignmentExpression();
	            }
	            else if (this.isStartOfExpression()) {
	                argument = this.parseAssignmentExpression();
	            }
	            this.context.allowYield = previousAllowYield;
	        }
	        return this.finalize(node, new Node.YieldExpression(argument, delegate));
	    };
	    // https://tc39.github.io/ecma262/#sec-class-definitions
	    Parser.prototype.parseClassElement = function (hasConstructor) {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var kind = '';
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var isStatic = false;
	        var isAsync = false;
	        if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            var id = key;
	            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
	                token = this.lookahead;
	                isStatic = true;
	                computed = this.match('[');
	                if (this.match('*')) {
	                    this.nextToken();
	                }
	                else {
	                    key = this.parseObjectPropertyKey();
	                }
	            }
	            if ((token.type === 3 /* Identifier */) && !this.hasLineTerminator && (token.value === 'async')) {
	                var punctuator = this.lookahead.value;
	                if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
	                    isAsync = true;
	                    token = this.lookahead;
	                    key = this.parseObjectPropertyKey();
	                    if (token.type === 3 /* Identifier */) {
	                        if (token.value === 'get' || token.value === 'set') {
	                            this.tolerateUnexpectedToken(token);
	                        }
	                        else if (token.value === 'constructor') {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
	                        }
	                    }
	                }
	            }
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */) {
	            if (token.value === 'get' && lookaheadPropertyKey) {
	                kind = 'get';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                this.context.allowYield = false;
	                value = this.parseGetterMethod();
	            }
	            else if (token.value === 'set' && lookaheadPropertyKey) {
	                kind = 'set';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                value = this.parseSetterMethod();
	            }
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        if (!kind && key && this.match('(')) {
	            kind = 'init';
	            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	            method = true;
	        }
	        if (!kind) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        if (kind === 'init') {
	            kind = 'method';
	        }
	        if (!computed) {
	            if (isStatic && this.isPropertyKey(key, 'prototype')) {
	                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
	            }
	            if (!isStatic && this.isPropertyKey(key, 'constructor')) {
	                if (kind !== 'method' || !method || (value && value.generator)) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
	                }
	                if (hasConstructor.value) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
	                }
	                else {
	                    hasConstructor.value = true;
	                }
	                kind = 'constructor';
	            }
	        }
	        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
	    };
	    Parser.prototype.parseClassElementList = function () {
	        var body = [];
	        var hasConstructor = { value: false };
	        this.expect('{');
	        while (!this.match('}')) {
	            if (this.match(';')) {
	                this.nextToken();
	            }
	            else {
	                body.push(this.parseClassElement(hasConstructor));
	            }
	        }
	        this.expect('}');
	        return body;
	    };
	    Parser.prototype.parseClassBody = function () {
	        var node = this.createNode();
	        var elementList = this.parseClassElementList();
	        return this.finalize(node, new Node.ClassBody(elementList));
	    };
	    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Identifier */)) ? null : this.parseVariableIdentifier();
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
	    };
	    Parser.prototype.parseClassExpression = function () {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (this.lookahead.type === 3 /* Identifier */) ? this.parseVariableIdentifier() : null;
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
	    };
	    // https://tc39.github.io/ecma262/#sec-scripts
	    // https://tc39.github.io/ecma262/#sec-modules
	    Parser.prototype.parseModule = function () {
	        this.context.strict = true;
	        this.context.isModule = true;
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Module(body));
	    };
	    Parser.prototype.parseScript = function () {
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Script(body));
	    };
	    // https://tc39.github.io/ecma262/#sec-imports
	    Parser.prototype.parseModuleSpecifier = function () {
	        var node = this.createNode();
	        if (this.lookahead.type !== 8 /* StringLiteral */) {
	            this.throwError(messages_1.Messages.InvalidModuleSpecifier);
	        }
	        var token = this.nextToken();
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    // import {<foo as bar>} ...;
	    Parser.prototype.parseImportSpecifier = function () {
	        var node = this.createNode();
	        var imported;
	        var local;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            imported = this.parseVariableIdentifier();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	        }
	        else {
	            imported = this.parseIdentifierName();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.ImportSpecifier(local, imported));
	    };
	    // {foo, bar as bas}
	    Parser.prototype.parseNamedImports = function () {
	        this.expect('{');
	        var specifiers = [];
	        while (!this.match('}')) {
	            specifiers.push(this.parseImportSpecifier());
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return specifiers;
	    };
	    // import <foo> ...;
	    Parser.prototype.parseImportDefaultSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportDefaultSpecifier(local));
	    };
	    // import <* as foo> ...;
	    Parser.prototype.parseImportNamespaceSpecifier = function () {
	        var node = this.createNode();
	        this.expect('*');
	        if (!this.matchContextualKeyword('as')) {
	            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
	        }
	        this.nextToken();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
	    };
	    Parser.prototype.parseImportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalImportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('import');
	        var src;
	        var specifiers = [];
	        if (this.lookahead.type === 8 /* StringLiteral */) {
	            // import 'foo';
	            src = this.parseModuleSpecifier();
	        }
	        else {
	            if (this.match('{')) {
	                // import {bar}
	                specifiers = specifiers.concat(this.parseNamedImports());
	            }
	            else if (this.match('*')) {
	                // import * as foo
	                specifiers.push(this.parseImportNamespaceSpecifier());
	            }
	            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
	                // import foo
	                specifiers.push(this.parseImportDefaultSpecifier());
	                if (this.match(',')) {
	                    this.nextToken();
	                    if (this.match('*')) {
	                        // import foo, * as foo
	                        specifiers.push(this.parseImportNamespaceSpecifier());
	                    }
	                    else if (this.match('{')) {
	                        // import foo, {bar}
	                        specifiers = specifiers.concat(this.parseNamedImports());
	                    }
	                    else {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            src = this.parseModuleSpecifier();
	        }
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
	    };
	    // https://tc39.github.io/ecma262/#sec-exports
	    Parser.prototype.parseExportSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        var exported = local;
	        if (this.matchContextualKeyword('as')) {
	            this.nextToken();
	            exported = this.parseIdentifierName();
	        }
	        return this.finalize(node, new Node.ExportSpecifier(local, exported));
	    };
	    Parser.prototype.parseExportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalExportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('export');
	        var exportDeclaration;
	        if (this.matchKeyword('default')) {
	            // export default ...
	            this.nextToken();
	            if (this.matchKeyword('function')) {
	                // export default function foo () {}
	                // export default function () {}
	                var declaration = this.parseFunctionDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchKeyword('class')) {
	                // export default class foo {}
	                var declaration = this.parseClassDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchContextualKeyword('async')) {
	                // export default async function f () {}
	                // export default async function () {}
	                // export default async x => x
	                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else {
	                if (this.matchContextualKeyword('from')) {
	                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
	                }
	                // export default {};
	                // export default [];
	                // export default (1 + 2);
	                var declaration = this.match('{') ? this.parseObjectInitializer() :
	                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
	                this.consumeSemicolon();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	        }
	        else if (this.match('*')) {
	            // export * from 'foo';
	            this.nextToken();
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            var src = this.parseModuleSpecifier();
	            this.consumeSemicolon();
	            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
	        }
	        else if (this.lookahead.type === 4 /* Keyword */) {
	            // export var f = 1;
	            var declaration = void 0;
	            switch (this.lookahead.value) {
	                case 'let':
	                case 'const':
	                    declaration = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'var':
	                case 'class':
	                case 'function':
	                    declaration = this.parseStatementListItem();
	                    break;
	                default:
	                    this.throwUnexpectedToken(this.lookahead);
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else if (this.matchAsyncFunction()) {
	            var declaration = this.parseFunctionDeclaration();
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else {
	            var specifiers = [];
	            var source = null;
	            var isExportFromIdentifier = false;
	            this.expect('{');
	            while (!this.match('}')) {
	                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
	                specifiers.push(this.parseExportSpecifier());
	                if (!this.match('}')) {
	                    this.expect(',');
	                }
	            }
	            this.expect('}');
	            if (this.matchContextualKeyword('from')) {
	                // export {default} from 'foo';
	                // export {foo} from 'foo';
	                this.nextToken();
	                source = this.parseModuleSpecifier();
	                this.consumeSemicolon();
	            }
	            else if (isExportFromIdentifier) {
	                // export {default}; // missing fromClause
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            else {
	                // export {foo};
	                this.consumeSemicolon();
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
	        }
	        return exportDeclaration;
	    };
	    return Parser;
	}());
	exports.Parser = Parser;


/***/ },
/* 9 */
/***/ function(module, exports) {

	"use strict";
	// Ensure the condition is true, otherwise throw an error.
	// This is only to have a better contract semantic, i.e. another safety net
	// to catch a logic error. The condition shall be fulfilled in normal case.
	// Do NOT use this to enforce a certain condition on any user input.
	Object.defineProperty(exports, "__esModule", { value: true });
	function assert(condition, message) {
	    /* istanbul ignore if */
	    if (!condition) {
	        throw new Error('ASSERT: ' + message);
	    }
	}
	exports.assert = assert;


/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	/* tslint:disable:max-classes-per-file */
	Object.defineProperty(exports, "__esModule", { value: true });
	var ErrorHandler = (function () {
	    function ErrorHandler() {
	        this.errors = [];
	        this.tolerant = false;
	    }
	    ErrorHandler.prototype.recordError = function (error) {
	        this.errors.push(error);
	    };
	    ErrorHandler.prototype.tolerate = function (error) {
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    ErrorHandler.prototype.constructError = function (msg, column) {
	        var error = new Error(msg);
	        try {
	            throw error;
	        }
	        catch (base) {
	            /* istanbul ignore else */
	            if (Object.create && Object.defineProperty) {
	                error = Object.create(base);
	                Object.defineProperty(error, 'column', { value: column });
	            }
	        }
	        /* istanbul ignore next */
	        return error;
	    };
	    ErrorHandler.prototype.createError = function (index, line, col, description) {
	        var msg = 'Line ' + line + ': ' + description;
	        var error = this.constructError(msg, col);
	        error.index = index;
	        error.lineNumber = line;
	        error.description = description;
	        return error;
	    };
	    ErrorHandler.prototype.throwError = function (index, line, col, description) {
	        throw this.createError(index, line, col, description);
	    };
	    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
	        var error = this.createError(index, line, col, description);
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    return ErrorHandler;
	}());
	exports.ErrorHandler = ErrorHandler;


/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// Error messages should be identical to V8.
	exports.Messages = {
	    BadGetterArity: 'Getter must not have any formal parameters',
	    BadSetterArity: 'Setter must have exactly one formal parameter',
	    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
	    ConstructorIsAsync: 'Class constructor may not be an async method',
	    ConstructorSpecialMethod: 'Class constructor may not be an accessor',
	    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
	    DefaultRestParameter: 'Unexpected token =',
	    DuplicateBinding: 'Duplicate binding %0',
	    DuplicateConstructor: 'A class may only have one constructor',
	    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
	    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
	    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
	    IllegalBreak: 'Illegal break statement',
	    IllegalContinue: 'Illegal continue statement',
	    IllegalExportDeclaration: 'Unexpected token',
	    IllegalImportDeclaration: 'Unexpected token',
	    IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
	    IllegalReturn: 'Illegal return statement',
	    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
	    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
	    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	    InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
	    InvalidModuleSpecifier: 'Unexpected token',
	    InvalidRegExp: 'Invalid regular expression',
	    LetInLexicalBinding: 'let is disallowed as a lexically bound name',
	    MissingFromClause: 'Unexpected token',
	    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	    NewlineAfterThrow: 'Illegal newline after throw',
	    NoAsAfterImportNamespace: 'Unexpected token',
	    NoCatchOrFinally: 'Missing catch or finally after try',
	    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
	    Redeclaration: '%0 \'%1\' has already been declared',
	    StaticPrototype: 'Classes may not have static property named prototype',
	    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	    StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
	    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictModeWith: 'Strict mode code may not include a with statement',
	    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	    StrictReservedWord: 'Use of future reserved word in strict mode',
	    StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
	    UnexpectedEOS: 'Unexpected end of input',
	    UnexpectedIdentifier: 'Unexpected identifier',
	    UnexpectedNumber: 'Unexpected number',
	    UnexpectedReserved: 'Unexpected reserved word',
	    UnexpectedString: 'Unexpected string',
	    UnexpectedTemplate: 'Unexpected quasi %0',
	    UnexpectedToken: 'Unexpected token %0',
	    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
	    UnknownLabel: 'Undefined label \'%0\'',
	    UnterminatedRegExp: 'Invalid regular expression: missing /'
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var character_1 = __webpack_require__(4);
	var messages_1 = __webpack_require__(11);
	function hexValue(ch) {
	    return '0123456789abcdef'.indexOf(ch.toLowerCase());
	}
	function octalValue(ch) {
	    return '01234567'.indexOf(ch);
	}
	var Scanner = (function () {
	    function Scanner(code, handler) {
	        this.source = code;
	        this.errorHandler = handler;
	        this.trackComment = false;
	        this.length = code.length;
	        this.index = 0;
	        this.lineNumber = (code.length > 0) ? 1 : 0;
	        this.lineStart = 0;
	        this.curlyStack = [];
	    }
	    Scanner.prototype.saveState = function () {
	        return {
	            index: this.index,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart
	        };
	    };
	    Scanner.prototype.restoreState = function (state) {
	        this.index = state.index;
	        this.lineNumber = state.lineNumber;
	        this.lineStart = state.lineStart;
	    };
	    Scanner.prototype.eof = function () {
	        return this.index >= this.length;
	    };
	    Scanner.prototype.throwUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    Scanner.prototype.tolerateUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    // https://tc39.github.io/ecma262/#sec-comments
	    Scanner.prototype.skipSingleLineComment = function (offset) {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - offset;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - offset
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            ++this.index;
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (this.trackComment) {
	                    loc.end = {
	                        line: this.lineNumber,
	                        column: this.index - this.lineStart - 1
	                    };
	                    var entry = {
	                        multiLine: false,
	                        slice: [start + offset, this.index - 1],
	                        range: [start, this.index - 1],
	                        loc: loc
	                    };
	                    comments.push(entry);
	                }
	                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                return comments;
	            }
	        }
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: false,
	                slice: [start + offset, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        return comments;
	    };
	    Scanner.prototype.skipMultiLineComment = function () {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - 2;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - 2
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                ++this.index;
	                this.lineStart = this.index;
	            }
	            else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (this.source.charCodeAt(this.index + 1) === 0x2F) {
	                    this.index += 2;
	                    if (this.trackComment) {
	                        loc.end = {
	                            line: this.lineNumber,
	                            column: this.index - this.lineStart
	                        };
	                        var entry = {
	                            multiLine: true,
	                            slice: [start + 2, this.index - 2],
	                            range: [start, this.index],
	                            loc: loc
	                        };
	                        comments.push(entry);
	                    }
	                    return comments;
	                }
	                ++this.index;
	            }
	            else {
	                ++this.index;
	            }
	        }
	        // Ran off the end of the file - the whole thing is a comment
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: true,
	                slice: [start + 2, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        this.tolerateUnexpectedToken();
	        return comments;
	    };
	    Scanner.prototype.scanComments = function () {
	        var comments;
	        if (this.trackComment) {
	            comments = [];
	        }
	        var start = (this.index === 0);
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isWhiteSpace(ch)) {
	                ++this.index;
	            }
	            else if (character_1.Character.isLineTerminator(ch)) {
	                ++this.index;
	                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                start = true;
	            }
	            else if (ch === 0x2F) {
	                ch = this.source.charCodeAt(this.index + 1);
	                if (ch === 0x2F) {
	                    this.index += 2;
	                    var comment = this.skipSingleLineComment(2);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                    start = true;
	                }
	                else if (ch === 0x2A) {
	                    this.index += 2;
	                    var comment = this.skipMultiLineComment();
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (start && ch === 0x2D) {
	                // U+003E is '>'
	                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    this.index += 3;
	                    var comment = this.skipSingleLineComment(3);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (ch === 0x3C) {
	                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
	                    this.index += 4; // `<!--`
	                    var comment = this.skipSingleLineComment(4);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else {
	                break;
	            }
	        }
	        return comments;
	    };
	    // https://tc39.github.io/ecma262/#sec-future-reserved-words
	    Scanner.prototype.isFutureReservedWord = function (id) {
	        switch (id) {
	            case 'enum':
	            case 'export':
	            case 'import':
	            case 'super':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isStrictModeReservedWord = function (id) {
	        switch (id) {
	            case 'implements':
	            case 'interface':
	            case 'package':
	            case 'private':
	            case 'protected':
	            case 'public':
	            case 'static':
	            case 'yield':
	            case 'let':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isRestrictedWord = function (id) {
	        return id === 'eval' || id === 'arguments';
	    };
	    // https://tc39.github.io/ecma262/#sec-keywords
	    Scanner.prototype.isKeyword = function (id) {
	        switch (id.length) {
	            case 2:
	                return (id === 'if') || (id === 'in') || (id === 'do');
	            case 3:
	                return (id === 'var') || (id === 'for') || (id === 'new') ||
	                    (id === 'try') || (id === 'let');
	            case 4:
	                return (id === 'this') || (id === 'else') || (id === 'case') ||
	                    (id === 'void') || (id === 'with') || (id === 'enum');
	            case 5:
	                return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                    (id === 'class') || (id === 'super');
	            case 6:
	                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                    (id === 'switch') || (id === 'export') || (id === 'import');
	            case 7:
	                return (id === 'default') || (id === 'finally') || (id === 'extends');
	            case 8:
	                return (id === 'function') || (id === 'continue') || (id === 'debugger');
	            case 10:
	                return (id === 'instanceof');
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.codePointAt = function (i) {
	        var cp = this.source.charCodeAt(i);
	        if (cp >= 0xD800 && cp <= 0xDBFF) {
	            var second = this.source.charCodeAt(i + 1);
	            if (second >= 0xDC00 && second <= 0xDFFF) {
	                var first = cp;
	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            }
	        }
	        return cp;
	    };
	    Scanner.prototype.scanHexEscape = function (prefix) {
	        var len = (prefix === 'u') ? 4 : 2;
	        var code = 0;
	        for (var i = 0; i < len; ++i) {
	            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                code = code * 16 + hexValue(this.source[this.index++]);
	            }
	            else {
	                return null;
	            }
	        }
	        return String.fromCharCode(code);
	    };
	    Scanner.prototype.scanUnicodeCodePointEscape = function () {
	        var ch = this.source[this.index];
	        var code = 0;
	        // At least, one hex digit is required.
	        if (ch === '}') {
	            this.throwUnexpectedToken();
	        }
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
	                break;
	            }
	            code = code * 16 + hexValue(ch);
	        }
	        if (code > 0x10FFFF || ch !== '}') {
	            this.throwUnexpectedToken();
	        }
	        return character_1.Character.fromCodePoint(code);
	    };
	    Scanner.prototype.getIdentifier = function () {
	        var start = this.index++;
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            else if (ch >= 0xD800 && ch < 0xDFFF) {
	                // Need to handle surrogate pairs.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            if (character_1.Character.isIdentifierPart(ch)) {
	                ++this.index;
	            }
	            else {
	                break;
	            }
	        }
	        return this.source.slice(start, this.index);
	    };
	    Scanner.prototype.getComplexIdentifier = function () {
	        var cp = this.codePointAt(this.index);
	        var id = character_1.Character.fromCodePoint(cp);
	        this.index += id.length;
	        // '\u' (U+005C, U+0075) denotes an escaped character.
	        var ch;
	        if (cp === 0x5C) {
	            if (this.source.charCodeAt(this.index) !== 0x75) {
	                this.throwUnexpectedToken();
	            }
	            ++this.index;
	            if (this.source[this.index] === '{') {
	                ++this.index;
	                ch = this.scanUnicodeCodePointEscape();
	            }
	            else {
	                ch = this.scanHexEscape('u');
	                if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken();
	                }
	            }
	            id = ch;
	        }
	        while (!this.eof()) {
	            cp = this.codePointAt(this.index);
	            if (!character_1.Character.isIdentifierPart(cp)) {
	                break;
	            }
	            ch = character_1.Character.fromCodePoint(cp);
	            id += ch;
	            this.index += ch.length;
	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (cp === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (this.source.charCodeAt(this.index) !== 0x75) {
	                    this.throwUnexpectedToken();
	                }
	                ++this.index;
	                if (this.source[this.index] === '{') {
	                    ++this.index;
	                    ch = this.scanUnicodeCodePointEscape();
	                }
	                else {
	                    ch = this.scanHexEscape('u');
	                    if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                        this.throwUnexpectedToken();
	                    }
	                }
	                id += ch;
	            }
	        }
	        return id;
	    };
	    Scanner.prototype.octalToDecimal = function (ch) {
	        // \0 is not octal escape sequence
	        var octal = (ch !== '0');
	        var code = octalValue(ch);
	        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	            octal = true;
	            code = code * 8 + octalValue(this.source[this.index++]);
	            // 3 digits are only allowed when string starts
	            // with 0, 1, 2, 3
	            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                code = code * 8 + octalValue(this.source[this.index++]);
	            }
	        }
	        return {
	            code: code,
	            octal: octal
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    Scanner.prototype.scanIdentifier = function () {
	        var type;
	        var start = this.index;
	        // Backslash (U+005C) starts an escaped character.
	        var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();
	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = 3 /* Identifier */;
	        }
	        else if (this.isKeyword(id)) {
	            type = 4 /* Keyword */;
	        }
	        else if (id === 'null') {
	            type = 5 /* NullLiteral */;
	        }
	        else if (id === 'true' || id === 'false') {
	            type = 1 /* BooleanLiteral */;
	        }
	        else {
	            type = 3 /* Identifier */;
	        }
	        if (type !== 3 /* Identifier */ && (start + id.length !== this.index)) {
	            var restore = this.index;
	            this.index = start;
	            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
	            this.index = restore;
	        }
	        return {
	            type: type,
	            value: id,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-punctuators
	    Scanner.prototype.scanPunctuator = function () {
	        var start = this.index;
	        // Check for most common single-character punctuators.
	        var str = this.source[this.index];
	        switch (str) {
	            case '(':
	            case '{':
	                if (str === '{') {
	                    this.curlyStack.push('{');
	                }
	                ++this.index;
	                break;
	            case '.':
	                ++this.index;
	                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
	                    // Spread operator: ...
	                    this.index += 2;
	                    str = '...';
	                }
	                break;
	            case '}':
	                ++this.index;
	                this.curlyStack.pop();
	                break;
	            case ')':
	            case ';':
	            case ',':
	            case '[':
	            case ']':
	            case ':':
	            case '?':
	            case '~':
	                ++this.index;
	                break;
	            default:
	                // 4-character punctuator.
	                str = this.source.substr(this.index, 4);
	                if (str === '>>>=') {
	                    this.index += 4;
	                }
	                else {
	                    // 3-character punctuators.
	                    str = str.substr(0, 3);
	                    if (str === '===' || str === '!==' || str === '>>>' ||
	                        str === '<<=' || str === '>>=' || str === '**=') {
	                        this.index += 3;
	                    }
	                    else {
	                        // 2-character punctuators.
	                        str = str.substr(0, 2);
	                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
	                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
	                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
	                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
	                            str === '<=' || str === '>=' || str === '=>' || str === '**') {
	                            this.index += 2;
	                        }
	                        else {
	                            // 1-character punctuators.
	                            str = this.source[this.index];
	                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
	                                ++this.index;
	                            }
	                        }
	                    }
	                }
	        }
	        if (this.index === start) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 7 /* Punctuator */,
	            value: str,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    Scanner.prototype.scanHexLiteral = function (start) {
	        var num = '';
	        while (!this.eof()) {
	            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt('0x' + num, 16),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanBinaryLiteral = function (start) {
	        var num = '';
	        var ch;
	        while (!this.eof()) {
	            ch = this.source[this.index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            // only 0b or 0B
	            this.throwUnexpectedToken();
	        }
	        if (!this.eof()) {
	            ch = this.source.charCodeAt(this.index);
	            /* istanbul ignore else */
	            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
	                this.throwUnexpectedToken();
	            }
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 2),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanOctalLiteral = function (prefix, start) {
	        var num = '';
	        var octal = false;
	        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
	            octal = true;
	            num = '0' + this.source[this.index++];
	        }
	        else {
	            ++this.index;
	        }
	        while (!this.eof()) {
	            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (!octal && num.length === 0) {
	            // only 0o or 0O
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 8),
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.isImplicitOctalLiteral = function () {
	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (var i = this.index + 1; i < this.length; ++i) {
	            var ch = this.source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                return true;
	            }
	        }
	        return true;
	    };
	    Scanner.prototype.scanNumericLiteral = function () {
	        var start = this.index;
	        var ch = this.source[start];
	        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
	        var num = '';
	        if (ch !== '.') {
	            num = this.source[this.index++];
	            ch = this.source[this.index];
	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (num === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++this.index;
	                    return this.scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++this.index;
	                    return this.scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O') {
	                    return this.scanOctalLiteral(ch, start);
	                }
	                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                    if (this.isImplicitOctalLiteral()) {
	                        return this.scanOctalLiteral(ch, start);
	                    }
	                }
	            }
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === '.') {
	            num += this.source[this.index++];
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === 'e' || ch === 'E') {
	            num += this.source[this.index++];
	            ch = this.source[this.index];
	            if (ch === '+' || ch === '-') {
	                num += this.source[this.index++];
	            }
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                    num += this.source[this.index++];
	                }
	            }
	            else {
	                this.throwUnexpectedToken();
	            }
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseFloat(num),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-string-literals
	    Scanner.prototype.scanStringLiteral = function () {
	        var start = this.index;
	        var quote = this.source[start];
	        assert_1.assert((quote === '\'' || quote === '"'), 'String literal must starts with a quote');
	        ++this.index;
	        var octal = false;
	        var str = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === quote) {
	                quote = '';
	                break;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                str += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var unescaped_1 = this.scanHexEscape(ch);
	                                if (unescaped_1 === null) {
	                                    this.throwUnexpectedToken();
	                                }
	                                str += unescaped_1;
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            str += unescaped;
	                            break;
	                        case 'n':
	                            str += '\n';
	                            break;
	                        case 'r':
	                            str += '\r';
	                            break;
	                        case 't':
	                            str += '\t';
	                            break;
	                        case 'b':
	                            str += '\b';
	                            break;
	                        case 'f':
	                            str += '\f';
	                            break;
	                        case 'v':
	                            str += '\x0B';
	                            break;
	                        case '8':
	                        case '9':
	                            str += ch;
	                            this.tolerateUnexpectedToken();
	                            break;
	                        default:
	                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                var octToDec = this.octalToDecimal(ch);
	                                octal = octToDec.octal || octal;
	                                str += String.fromCharCode(octToDec.code);
	                            }
	                            else {
	                                str += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            }
	            else {
	                str += ch;
	            }
	        }
	        if (quote !== '') {
	            this.index = start;
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 8 /* StringLiteral */,
	            value: str,
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
	    Scanner.prototype.scanTemplate = function () {
	        var cooked = '';
	        var terminated = false;
	        var start = this.index;
	        var head = (this.source[start] === '`');
	        var tail = false;
	        var rawOffset = 2;
	        ++this.index;
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === '`') {
	                rawOffset = 1;
	                tail = true;
	                terminated = true;
	                break;
	            }
	            else if (ch === '$') {
	                if (this.source[this.index] === '{') {
	                    this.curlyStack.push('${');
	                    ++this.index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'n':
	                            cooked += '\n';
	                            break;
	                        case 'r':
	                            cooked += '\r';
	                            break;
	                        case 't':
	                            cooked += '\t';
	                            break;
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                cooked += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var restore = this.index;
	                                var unescaped_2 = this.scanHexEscape(ch);
	                                if (unescaped_2 !== null) {
	                                    cooked += unescaped_2;
	                                }
	                                else {
	                                    this.index = restore;
	                                    cooked += ch;
	                                }
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            cooked += unescaped;
	                            break;
	                        case 'b':
	                            cooked += '\b';
	                            break;
	                        case 'f':
	                            cooked += '\f';
	                            break;
	                        case 'v':
	                            cooked += '\v';
	                            break;
	                        default:
	                            if (ch === '0') {
	                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                                    // Illegal: \01 \02 and so on
	                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                                }
	                                cooked += '\0';
	                            }
	                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                // Illegal: \1 \2
	                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                            }
	                            else {
	                                cooked += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.lineNumber;
	                if (ch === '\r' && this.source[this.index] === '\n') {
	                    ++this.index;
	                }
	                this.lineStart = this.index;
	                cooked += '\n';
	            }
	            else {
	                cooked += ch;
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken();
	        }
	        if (!head) {
	            this.curlyStack.pop();
	        }
	        return {
	            type: 10 /* Template */,
	            value: this.source.slice(start + 1, this.index - rawOffset),
	            cooked: cooked,
	            head: head,
	            tail: tail,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	    Scanner.prototype.testRegExp = function (pattern, flags) {
	        // The BMP character to use as a replacement for astral symbols when
	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
	        // approximation.
	        // Note: replacing with '\uFFFF' enables false positives in unlikely
	        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
	        // pattern that would not be detected by this substitution.
	        var astralSubstitute = '\uFFFF';
	        var tmp = pattern;
	        var self = this;
	        if (flags.indexOf('u') >= 0) {
	            tmp = tmp
	                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
	                var codePoint = parseInt($1 || $2, 16);
	                if (codePoint > 0x10FFFF) {
	                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	                }
	                if (codePoint <= 0xFFFF) {
	                    return String.fromCharCode(codePoint);
	                }
	                return astralSubstitute;
	            })
	                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
	        }
	        // First, detect invalid regular expressions.
	        try {
	            RegExp(tmp);
	        }
	        catch (e) {
	            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	        }
	        // Return a regular expression object for this pattern-flag pair, or
	        // `null` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        }
	        catch (exception) {
	            /* istanbul ignore next */
	            return null;
	        }
	    };
	    Scanner.prototype.scanRegExpBody = function () {
	        var ch = this.source[this.index];
	        assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
	        var str = this.source[this.index++];
	        var classMarker = false;
	        var terminated = false;
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = this.source[this.index++];
	                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	            }
	            else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            }
	            else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                }
	                else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	        }
	        // Exclude leading and trailing slash.
	        return str.substr(1, str.length - 2);
	    };
	    Scanner.prototype.scanRegExpFlags = function () {
	        var str = '';
	        var flags = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index];
	            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }
	            ++this.index;
	            if (ch === '\\' && !this.eof()) {
	                ch = this.source[this.index];
	                if (ch === 'u') {
	                    ++this.index;
	                    var restore = this.index;
	                    var char = this.scanHexEscape('u');
	                    if (char !== null) {
	                        flags += char;
	                        for (str += '\\u'; restore < this.index; ++restore) {
	                            str += this.source[restore];
	                        }
	                    }
	                    else {
	                        this.index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    this.tolerateUnexpectedToken();
	                }
	                else {
	                    str += '\\';
	                    this.tolerateUnexpectedToken();
	                }
	            }
	            else {
	                flags += ch;
	                str += ch;
	            }
	        }
	        return flags;
	    };
	    Scanner.prototype.scanRegExp = function () {
	        var start = this.index;
	        var pattern = this.scanRegExpBody();
	        var flags = this.scanRegExpFlags();
	        var value = this.testRegExp(pattern, flags);
	        return {
	            type: 9 /* RegularExpression */,
	            value: '',
	            pattern: pattern,
	            flags: flags,
	            regex: value,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.lex = function () {
	        if (this.eof()) {
	            return {
	                type: 2 /* EOF */,
	                value: '',
	                lineNumber: this.lineNumber,
	                lineStart: this.lineStart,
	                start: this.index,
	                end: this.index
	            };
	        }
	        var cp = this.source.charCodeAt(this.index);
	        if (character_1.Character.isIdentifierStart(cp)) {
	            return this.scanIdentifier();
	        }
	        // Very common: ( and ) and ;
	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
	            return this.scanPunctuator();
	        }
	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (cp === 0x27 || cp === 0x22) {
	            return this.scanStringLiteral();
	        }
	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (cp === 0x2E) {
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
	                return this.scanNumericLiteral();
	            }
	            return this.scanPunctuator();
	        }
	        if (character_1.Character.isDecimalDigit(cp)) {
	            return this.scanNumericLiteral();
	        }
	        // Template literals start with ` (U+0060) for template head
	        // or } (U+007D) for template middle or template tail.
	        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${')) {
	            return this.scanTemplate();
	        }
	        // Possible identifier start in a surrogate pair.
	        if (cp >= 0xD800 && cp < 0xDFFF) {
	            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
	                return this.scanIdentifier();
	            }
	        }
	        return this.scanPunctuator();
	    };
	    return Scanner;
	}());
	exports.Scanner = Scanner;


/***/ },
/* 13 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TokenName = {};
	exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
	exports.TokenName[2 /* EOF */] = '<end>';
	exports.TokenName[3 /* Identifier */] = 'Identifier';
	exports.TokenName[4 /* Keyword */] = 'Keyword';
	exports.TokenName[5 /* NullLiteral */] = 'Null';
	exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
	exports.TokenName[7 /* Punctuator */] = 'Punctuator';
	exports.TokenName[8 /* StringLiteral */] = 'String';
	exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
	exports.TokenName[10 /* Template */] = 'Template';


/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	// Generated by generate-xhtml-entities.js. DO NOT MODIFY!
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.XHTMLEntities = {
	    quot: '\u0022',
	    amp: '\u0026',
	    apos: '\u0027',
	    gt: '\u003E',
	    nbsp: '\u00A0',
	    iexcl: '\u00A1',
	    cent: '\u00A2',
	    pound: '\u00A3',
	    curren: '\u00A4',
	    yen: '\u00A5',
	    brvbar: '\u00A6',
	    sect: '\u00A7',
	    uml: '\u00A8',
	    copy: '\u00A9',
	    ordf: '\u00AA',
	    laquo: '\u00AB',
	    not: '\u00AC',
	    shy: '\u00AD',
	    reg: '\u00AE',
	    macr: '\u00AF',
	    deg: '\u00B0',
	    plusmn: '\u00B1',
	    sup2: '\u00B2',
	    sup3: '\u00B3',
	    acute: '\u00B4',
	    micro: '\u00B5',
	    para: '\u00B6',
	    middot: '\u00B7',
	    cedil: '\u00B8',
	    sup1: '\u00B9',
	    ordm: '\u00BA',
	    raquo: '\u00BB',
	    frac14: '\u00BC',
	    frac12: '\u00BD',
	    frac34: '\u00BE',
	    iquest: '\u00BF',
	    Agrave: '\u00C0',
	    Aacute: '\u00C1',
	    Acirc: '\u00C2',
	    Atilde: '\u00C3',
	    Auml: '\u00C4',
	    Aring: '\u00C5',
	    AElig: '\u00C6',
	    Ccedil: '\u00C7',
	    Egrave: '\u00C8',
	    Eacute: '\u00C9',
	    Ecirc: '\u00CA',
	    Euml: '\u00CB',
	    Igrave: '\u00CC',
	    Iacute: '\u00CD',
	    Icirc: '\u00CE',
	    Iuml: '\u00CF',
	    ETH: '\u00D0',
	    Ntilde: '\u00D1',
	    Ograve: '\u00D2',
	    Oacute: '\u00D3',
	    Ocirc: '\u00D4',
	    Otilde: '\u00D5',
	    Ouml: '\u00D6',
	    times: '\u00D7',
	    Oslash: '\u00D8',
	    Ugrave: '\u00D9',
	    Uacute: '\u00DA',
	    Ucirc: '\u00DB',
	    Uuml: '\u00DC',
	    Yacute: '\u00DD',
	    THORN: '\u00DE',
	    szlig: '\u00DF',
	    agrave: '\u00E0',
	    aacute: '\u00E1',
	    acirc: '\u00E2',
	    atilde: '\u00E3',
	    auml: '\u00E4',
	    aring: '\u00E5',
	    aelig: '\u00E6',
	    ccedil: '\u00E7',
	    egrave: '\u00E8',
	    eacute: '\u00E9',
	    ecirc: '\u00EA',
	    euml: '\u00EB',
	    igrave: '\u00EC',
	    iacute: '\u00ED',
	    icirc: '\u00EE',
	    iuml: '\u00EF',
	    eth: '\u00F0',
	    ntilde: '\u00F1',
	    ograve: '\u00F2',
	    oacute: '\u00F3',
	    ocirc: '\u00F4',
	    otilde: '\u00F5',
	    ouml: '\u00F6',
	    divide: '\u00F7',
	    oslash: '\u00F8',
	    ugrave: '\u00F9',
	    uacute: '\u00FA',
	    ucirc: '\u00FB',
	    uuml: '\u00FC',
	    yacute: '\u00FD',
	    thorn: '\u00FE',
	    yuml: '\u00FF',
	    OElig: '\u0152',
	    oelig: '\u0153',
	    Scaron: '\u0160',
	    scaron: '\u0161',
	    Yuml: '\u0178',
	    fnof: '\u0192',
	    circ: '\u02C6',
	    tilde: '\u02DC',
	    Alpha: '\u0391',
	    Beta: '\u0392',
	    Gamma: '\u0393',
	    Delta: '\u0394',
	    Epsilon: '\u0395',
	    Zeta: '\u0396',
	    Eta: '\u0397',
	    Theta: '\u0398',
	    Iota: '\u0399',
	    Kappa: '\u039A',
	    Lambda: '\u039B',
	    Mu: '\u039C',
	    Nu: '\u039D',
	    Xi: '\u039E',
	    Omicron: '\u039F',
	    Pi: '\u03A0',
	    Rho: '\u03A1',
	    Sigma: '\u03A3',
	    Tau: '\u03A4',
	    Upsilon: '\u03A5',
	    Phi: '\u03A6',
	    Chi: '\u03A7',
	    Psi: '\u03A8',
	    Omega: '\u03A9',
	    alpha: '\u03B1',
	    beta: '\u03B2',
	    gamma: '\u03B3',
	    delta: '\u03B4',
	    epsilon: '\u03B5',
	    zeta: '\u03B6',
	    eta: '\u03B7',
	    theta: '\u03B8',
	    iota: '\u03B9',
	    kappa: '\u03BA',
	    lambda: '\u03BB',
	    mu: '\u03BC',
	    nu: '\u03BD',
	    xi: '\u03BE',
	    omicron: '\u03BF',
	    pi: '\u03C0',
	    rho: '\u03C1',
	    sigmaf: '\u03C2',
	    sigma: '\u03C3',
	    tau: '\u03C4',
	    upsilon: '\u03C5',
	    phi: '\u03C6',
	    chi: '\u03C7',
	    psi: '\u03C8',
	    omega: '\u03C9',
	    thetasym: '\u03D1',
	    upsih: '\u03D2',
	    piv: '\u03D6',
	    ensp: '\u2002',
	    emsp: '\u2003',
	    thinsp: '\u2009',
	    zwnj: '\u200C',
	    zwj: '\u200D',
	    lrm: '\u200E',
	    rlm: '\u200F',
	    ndash: '\u2013',
	    mdash: '\u2014',
	    lsquo: '\u2018',
	    rsquo: '\u2019',
	    sbquo: '\u201A',
	    ldquo: '\u201C',
	    rdquo: '\u201D',
	    bdquo: '\u201E',
	    dagger: '\u2020',
	    Dagger: '\u2021',
	    bull: '\u2022',
	    hellip: '\u2026',
	    permil: '\u2030',
	    prime: '\u2032',
	    Prime: '\u2033',
	    lsaquo: '\u2039',
	    rsaquo: '\u203A',
	    oline: '\u203E',
	    frasl: '\u2044',
	    euro: '\u20AC',
	    image: '\u2111',
	    weierp: '\u2118',
	    real: '\u211C',
	    trade: '\u2122',
	    alefsym: '\u2135',
	    larr: '\u2190',
	    uarr: '\u2191',
	    rarr: '\u2192',
	    darr: '\u2193',
	    harr: '\u2194',
	    crarr: '\u21B5',
	    lArr: '\u21D0',
	    uArr: '\u21D1',
	    rArr: '\u21D2',
	    dArr: '\u21D3',
	    hArr: '\u21D4',
	    forall: '\u2200',
	    part: '\u2202',
	    exist: '\u2203',
	    empty: '\u2205',
	    nabla: '\u2207',
	    isin: '\u2208',
	    notin: '\u2209',
	    ni: '\u220B',
	    prod: '\u220F',
	    sum: '\u2211',
	    minus: '\u2212',
	    lowast: '\u2217',
	    radic: '\u221A',
	    prop: '\u221D',
	    infin: '\u221E',
	    ang: '\u2220',
	    and: '\u2227',
	    or: '\u2228',
	    cap: '\u2229',
	    cup: '\u222A',
	    int: '\u222B',
	    there4: '\u2234',
	    sim: '\u223C',
	    cong: '\u2245',
	    asymp: '\u2248',
	    ne: '\u2260',
	    equiv: '\u2261',
	    le: '\u2264',
	    ge: '\u2265',
	    sub: '\u2282',
	    sup: '\u2283',
	    nsub: '\u2284',
	    sube: '\u2286',
	    supe: '\u2287',
	    oplus: '\u2295',
	    otimes: '\u2297',
	    perp: '\u22A5',
	    sdot: '\u22C5',
	    lceil: '\u2308',
	    rceil: '\u2309',
	    lfloor: '\u230A',
	    rfloor: '\u230B',
	    loz: '\u25CA',
	    spades: '\u2660',
	    clubs: '\u2663',
	    hearts: '\u2665',
	    diams: '\u2666',
	    lang: '\u27E8',
	    rang: '\u27E9'
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var error_handler_1 = __webpack_require__(10);
	var scanner_1 = __webpack_require__(12);
	var token_1 = __webpack_require__(13);
	var Reader = (function () {
	    function Reader() {
	        this.values = [];
	        this.curly = this.paren = -1;
	    }
	    // A function following one of those tokens is an expression.
	    Reader.prototype.beforeFunctionExpression = function (t) {
	        return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	            'return', 'case', 'delete', 'throw', 'void',
	            // assignment operators
	            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',
	            '&=', '|=', '^=', ',',
	            // binary/unary operators
	            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
	    };
	    // Determine if forward slash (/) is an operator or part of a regular expression
	    // https://github.com/mozilla/sweet.js/wiki/design
	    Reader.prototype.isRegexStart = function () {
	        var previous = this.values[this.values.length - 1];
	        var regex = (previous !== null);
	        switch (previous) {
	            case 'this':
	            case ']':
	                regex = false;
	                break;
	            case ')':
	                var keyword = this.values[this.paren - 1];
	                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');
	                break;
	            case '}':
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                regex = false;
	                if (this.values[this.curly - 3] === 'function') {
	                    // Anonymous function, e.g. function(){} /42
	                    var check = this.values[this.curly - 4];
	                    regex = check ? !this.beforeFunctionExpression(check) : false;
	                }
	                else if (this.values[this.curly - 4] === 'function') {
	                    // Named function, e.g. function f(){} /42/
	                    var check = this.values[this.curly - 5];
	                    regex = check ? !this.beforeFunctionExpression(check) : true;
	                }
	                break;
	            default:
	                break;
	        }
	        return regex;
	    };
	    Reader.prototype.push = function (token) {
	        if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
	            if (token.value === '{') {
	                this.curly = this.values.length;
	            }
	            else if (token.value === '(') {
	                this.paren = this.values.length;
	            }
	            this.values.push(token.value);
	        }
	        else {
	            this.values.push(null);
	        }
	    };
	    return Reader;
	}());
	var Tokenizer = (function () {
	    function Tokenizer(code, config) {
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;
	        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;
	        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;
	        this.buffer = [];
	        this.reader = new Reader();
	    }
	    Tokenizer.prototype.errors = function () {
	        return this.errorHandler.errors;
	    };
	    Tokenizer.prototype.getNextToken = function () {
	        if (this.buffer.length === 0) {
	            var comments = this.scanner.scanComments();
	            if (this.scanner.trackComment) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
	                    var comment = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: value
	                    };
	                    if (this.trackRange) {
	                        comment.range = e.range;
	                    }
	                    if (this.trackLoc) {
	                        comment.loc = e.loc;
	                    }
	                    this.buffer.push(comment);
	                }
	            }
	            if (!this.scanner.eof()) {
	                var loc = void 0;
	                if (this.trackLoc) {
	                    loc = {
	                        start: {
	                            line: this.scanner.lineNumber,
	                            column: this.scanner.index - this.scanner.lineStart
	                        },
	                        end: {}
	                    };
	                }
	                var startRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();
	                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
	                this.reader.push(token);
	                var entry = {
	                    type: token_1.TokenName[token.type],
	                    value: this.scanner.source.slice(token.start, token.end)
	                };
	                if (this.trackRange) {
	                    entry.range = [token.start, token.end];
	                }
	                if (this.trackLoc) {
	                    loc.end = {
	                        line: this.scanner.lineNumber,
	                        column: this.scanner.index - this.scanner.lineStart
	                    };
	                    entry.loc = loc;
	                }
	                if (token.type === 9 /* RegularExpression */) {
	                    var pattern = token.pattern;
	                    var flags = token.flags;
	                    entry.regex = { pattern: pattern, flags: flags };
	                }
	                this.buffer.push(entry);
	            }
	        }
	        return this.buffer.shift();
	    };
	    return Tokenizer;
	}());
	exports.Tokenizer = Tokenizer;


/***/ }
/******/ ])
});
;
},{}],55:[function(require,module,exports){
'use strict'
var readonlyProxies = new WeakMap
var currentSandbox = undefined
var GLOBAL = new Function('return this')()
var unscopablesSymbol = Symbol.unscopables
var FunctionConstructor = 0..constructor.constructor

function compileExpression(src) {
	if (typeof src !== 'string') {
		throw new TypeError('Expected argument to be a string.')
	}
	
	new FunctionConstructor('"use strict"; return ' + src) // Tests for syntax errors without running the code
	var code = new FunctionConstructor('sandbox', 'with (sandbox) {return (function () {"use strict"; return ' + src + '}).call(this)}')
	
	return function (sandbox) {
		if (!isObject(sandbox)) {
			throw new TypeError('Expected argument to be an object or function.')
		}
		if (currentSandbox) {
			throw new Error('You cannot run sandboxed code inside an already-running sandbox.')
		}
		var sandboxProxy = getProxy(sandbox)
		var result, error
		
		currentSandbox = sandbox
		try {
			result = code.call(sandboxProxy, sandboxProxy)
			currentSandbox = undefined
		} catch (ex) {
			currentSandbox = undefined
			if (ex instanceof Error) {
				error = new ex.constructor('' + ex.message)
				error.stack = '' + ex.stack
				throw error
			}
			throw new Error(String(ex))
		}
		if (isObject(result)) {
			throw TypeError('Sandboxes are only allowed to return primitive values.')
		}
		return result
	}
}
module.exports = compileExpression

var traps = {
	get: function (target, key, receiver) {
		if (currentSandbox) {
			if (key === unscopablesSymbol && target === currentSandbox) {
				return undefined
			}
			if (!notPrivate(key)) {
				return undefined
			}
			return getProxyOrPrimitive(Reflect.get(target, key, receiver))
		}
		return Reflect.get(target, key, receiver)
	},
	set: function (target, key, value, receiver) {
		if (currentSandbox) {
			throw new TypeError('You cannot set properties on a sandboxed object.')
		}
		return Reflect.set(target, key, value, receiver)
	},
	has: function (target, key) {
		if (currentSandbox) {
			if (target === currentSandbox) {
				return true
			}
			if (!notPrivate(key)) {
				return false
			}
			return getProxyOrPrimitive(Reflect.has(target, key))
		}
		return Reflect.has(target, key)
	},
	getPrototypeOf: function (target) {
		if (currentSandbox) {
			return getProxyOrPrimitive(Reflect.getPrototypeOf(target))
		}
		return Reflect.getPrototypeOf(target)
	},
	setPrototypeOf: function (target, proto) {
		if (currentSandbox) {
			throw new TypeError('You cannot set the prototype of a sandboxed object.')
		}
		return Reflect.setPrototypeOf(target, proto)
	},
	isExtensible: function (target) {
		if (currentSandbox) {
			return getProxyOrPrimitive(Reflect.isExtensible(target))
		}
		return Reflect.isExtensible(target)
	},
	preventExtensions: function (target) {
		if (currentSandbox) {
			throw new TypeError('You cannot change the extensibility of a sandboxed object.')
		}
		return Reflect.preventExtensions(target)
	},
	getOwnPropertyDescriptor: function (target, key) {
		if (currentSandbox) {
			if (key === Symbol.unscopables && target === currentSandbox) {
				return undefined
			}
			if (!notPrivate(key)) {
				return undefined
			}
			return getProxyOrPrimitive(Reflect.getOwnPropertyDescriptor(target, key))
		}
		return Reflect.getOwnPropertyDescriptor(target, key)
	},
	defineProperty: function (target, key, descriptor) {
		if (currentSandbox) {
			throw new TypeError('You cannot define properties on a sandboxed object.')
		}
		return Reflect.defineProperty(target, key, descriptor)
	},
	deleteProperty: function (target, key) {
		if (currentSandbox) {
			throw new TypeError('You cannot delete properties on a sandboxed object.')
		}
		return Reflect.deleteProperty(target, key)
	},
	ownKeys: function (target) {
		if (currentSandbox) {
			return getProxyOrPrimitive(Reflect.ownKeys(target).filter(notPrivate))
		}
		return Reflect.ownKeys(target)
	},
	apply: function (target, thisArg, argumentsList) {
		if (currentSandbox) {
			if (target === FunctionConstructor || target === FunctionConstructorProxy) {
				throw new TypeError('You cannot use the Function constructor in a sandboxed context.')
			}
			return getProxyOrPrimitive(Reflect.apply(target, thisArg, argumentsList))
		}
		return Reflect.apply(target, thisArg, argumentsList)
	},
	construct: function (target, argumentsList, newTarget) {
		if (currentSandbox) {
			if (target === FunctionConstructor || target === FunctionConstructorProxy) {
				throw new TypeError('You cannot use the Function constructor in a sandboxed context.')
			}
			return getProxyOrPrimitive(Reflect.construct(target, argumentsList, newTarget))
		}
		return Reflect.construct(target, argumentsList, newTarget)
	}
}

function isObject(value) {
	return typeof value === 'function' || (value !== null && typeof value === 'object')
}

function getProxyOrPrimitive(value) {
	if (isObject(value)) {
		return safeObjects.indexOf(value) >= 0 ? value : getProxy(value)
	}
	return value
}

function getProxy(object, hideOriginal) {
	if (object === GLOBAL) {
		throw new TypeError('The global object is forbidden from entering a sandboxed context.')
	}
	if (object === evalFunction) {
		throw new TypeError('The eval function is forbidden from entering a sandboxed context.')
	}
	var proxy = readonlyProxies.get(object)
	if (typeof proxy === 'undefined') {
		proxy = new Proxy(object, traps)
		readonlyProxies.set(hideOriginal ? proxy : object, proxy)
	}
	return proxy
}

function notPrivate(key) {
	return typeof key !== 'string' || key[0] !== '_'
}

// Freeze and proxy anything that is accessible through JavaScript syntax alone
// This should include any value that you can get from JavaScript syntax itself.
// For example:
//     "my string".foobar
//     try {throw 1} catch (err) {err.foobar}
// Symbols are included here because they are not protected by our proxying
// because they are primitives.
var safeObjects = require('./lib/make-safe')([
	Boolean.prototype,
	Number.prototype,
	String.prototype,
	Symbol.prototype,
	Function.prototype,
	Object.prototype,
	Array.prototype,
	RegExp.prototype,
	Error.prototype,
	EvalError.prototype,
	RangeError.prototype,
	ReferenceError.prototype,
	SyntaxError.prototype,
	TypeError.prototype,
	URIError.prototype,
	Promise.prototype,
	Object.getPrototypeOf(function*(){}),
	Object.getPrototypeOf(function*(){}())
], isObject, getProxy, GLOBAL)

var evalFunction = GLOBAL.eval
var FunctionConstructorProxy = 0..constructor.constructor

module.exports.equals = function (a, b) {
	return a === b || (readonlyProxies.get(a) || a) === (readonlyProxies.get(b) || b)
}



},{"./lib/make-safe":56}],56:[function(require,module,exports){
'use strict'

module.exports = function (unsafeObjects, isObject, getProxy, GLOBAL) {
	var proxies = []
	var safeObjects = []
	var returnsSafeValues = [
		Function.prototype[Symbol.hasInstance]
	]
	var globalKeys = Object.getOwnPropertyNames(GLOBAL).filter(function (key) {return key !== 'root' && key !== 'GLOBAL' && key !== 'global' && key !== 'window' && key !== 'self'})
	var globalValues = globalKeys.map(function (key) {return this[key]}, GLOBAL)
	
	while (unsafeObjects.length) {
		makeSafe(unsafeObjects.shift())
	}
	
	function makeSafe(object) {
		if (isSafe(object)) {
			return
		}
		
		var reachable = Object.getOwnPropertyNames(object)
			.concat(Object.getOwnPropertySymbols(object))
		
		if (object === Function.prototype) {
			reachable = reachable.filter(ignoredKeys)
		}
		
		reachable.forEach(replaceWithProxy, object)
		Object.freeze(object)
		safeObjects.push(object)
		
		unsafeObjects.push(Object.getPrototypeOf(object))
	}
	
	function ignoredKeys(key) {
		return key !== 'caller' && key !== 'arguments'
	}
	
	function isSafe(value) {
		return !isObject(value) || proxies.indexOf(value) >= 0 || safeObjects.indexOf(value) >= 0
	}
	
	function replaceWithProxy(key) {
		var d = Object.getOwnPropertyDescriptor(this, key)
		if (!('value' in d)) {
			if (key === '__proto__' && isSafe(this[key])) {
				return
			}
			if (!d.configurable) {
				d.get && unsafeObjects.push(d.get)
				d.set && unsafeObjects.push(d.set)
				// This getter/setter could potentially return a non-proxied object
				console.warn('Potentially vulnerable getter/setter at %s in %s', key, this)
				return
			}
			var getter = d.get && getProxy(d.get, true)
			var setter = d.set && getProxy(d.set, true)
			Object.defineProperty(this, key, {
				get: getter,
				set: setter,
				enumerable: d.enumerable,
				configurable: false
			})
			getter && proxies.push(getter)
			setter && proxies.push(setter)
			return
		}
		
		var value = this[key]
		if (isSafe(value)) {
			return
		}
		
		if (d.writable) {
			var proxy = getProxy(value, true)
			proxies.push(this[key] = proxy)
			replaceInGlobal(value, proxy)
			return
		}
		
		if (d.configurable) {
			var proxy = getProxy(value, true)
			Object.defineProperty(this, key, {
				value: proxy,
				writable: false,
				enumerable: d.enumerable,
				configurable: false
			})
			replaceInGlobal(value, proxy)
			proxies.push(proxy)
			return
		}
		
		unsafeObjects.push(value)
		if (typeof value === 'function' && returnsSafeValues.indexOf(value) === -1) {
			// This function could potentially return a non-proxied object
			console.warn('Potentially vulnerable function at %s in %s', key, this)
		}
	}
	
	function replaceInGlobal(value, proxy) {
		var index = globalValues.indexOf(value)
		if (index >= 0) {
			var key = globalKeys[index]
			var d = Object.getOwnPropertyDescriptor(GLOBAL, key)
			if (d.writable) {
				GLOBAL[key] = proxy
			} else if (d.configurable) {
				Object.defineProperty(GLOBAL, key, {
					value: proxy,
					writable: false,
					enumerable: d.enumerable,
					configurable: false
				})
			} else {
				console.warn('Was not able to replace %s in global object', key)
			}
		}
	}
	
	return safeObjects
}

},{}],57:[function(require,module,exports){
'use strict';
var ansiRegex = require('ansi-regex');
var re = new RegExp(ansiRegex().source); // remove the `g` flag
module.exports = re.test.bind(re);

},{"ansi-regex":47}],58:[function(require,module,exports){

var rx_escapable = /[\\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

var gap,
    indent,
    meta = { // table of character substitutions
      '\b': '\\b',
      '\t': '\\t',
      '\n': '\\n',
      '\f': '\\f',
      '\r': '\\r',
      '"': '\\"',
      '\\': '\\\\'
    },
    rep;

function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

    rx_escapable.lastIndex = 0;
    return rx_escapable.test(string)
        ? '"' + string.replace(rx_escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"'
        : '"' + string + '"';
}


function str(key, holder, limit) {

// Produce a string from holder[key].

    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }

// What happens next depends on the value's type.

    switch (typeof value) {
    case 'string':
        return quote(value);

    case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

        return isFinite(value)
            ? String(value)
            : 'null';

    case 'boolean':
    case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

        return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

    case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

        if (!value) {
            return 'null';
        }

// Make an array to hold the partial results of stringifying this object value.

        gap += indent;
        partial = [];

// Is the value an array?

        if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

            length = value.length;
            for (i = 0; i < length; i += 1) {
                partial[i] = str(i, value, limit) || 'null';
            }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

            v = partial.length === 0
                ? '[]'
                : gap
                    ? (
                      gap.length + partial.join(', ').length + 4 > limit ?
                      '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                      '[ ' + partial.join(', ') + ' ]'
                    )
                    : '[' + partial.join(',') + ']';
            gap = mind;
            return v;
        }

// If the replacer is an array, use it to select the members to be stringified.

        if (rep && typeof rep === 'object') {
            length = rep.length;
            for (i = 0; i < length; i += 1) {
                if (typeof rep[i] === 'string') {
                    k = rep[i];
                    v = str(k, value, limit);
                    if (v) {
                        partial.push(quote(k) + (
                            gap
                                ? ': '
                                : ':'
                        ) + v);
                    }
                }
            }
        } else {

// Otherwise, iterate through all of the keys in the object.

            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = str(k, value, limit);
                    if (v) {
                        partial.push(quote(k) + (
                            gap
                                ? ': '
                                : ':'
                        ) + v);
                    }
                }
            }
        }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

        v = partial.length === 0
            ? '{}'
            : gap
                ? (
                  gap.length + partial.join(', ').length + 4 > limit ?
                  '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                  '{ ' + partial.join(', ') + ' }'
                )
                : '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}


function beautify (value, replacer, space, limit) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

  var i;
  gap = '';
  indent = '';

  if (!limit) limit = 0;

  if (typeof limit !== "number")
    throw new Error("beaufifier: limit must be a number");

// If the space parameter is a number, make an indent string containing that
// many spaces.

  if (typeof space === 'number') {
      for (i = 0; i < space; i += 1) {
          indent += ' ';
      }

// If the space parameter is a string, it will be used as the indent string.

  } else if (typeof space === 'string') {
      indent = space;
  }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

  rep = replacer;
  if (replacer && typeof replacer !== 'function' &&
          (typeof replacer !== 'object' ||
          typeof replacer.length !== 'number')) {
      throw new Error('beautifier: wrong replacer parameter');
  }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

  return str('', {'': value}, limit);
}

module.exports = beautify;

},{}],59:[function(require,module,exports){
(function (global){
/**
 * © Copyright IBM Corp. 2016, 2017 All Rights Reserved
 *   Project name: JSONata
 *   This project is licensed under the MIT License, see LICENSE
 */

/**
 * @module JSONata
 * @description JSON query and transformation language
 */

/**
 * jsonata
 * @function
 * @param {Object} expr - JSONata expression
 * @returns {{evaluate: evaluate, assign: assign}} Evaluated expression
 */
var jsonata = (function() {
    'use strict';

    var operators = {
        '.': 75,
        '[': 80,
        ']': 0,
        '{': 70,
        '}': 0,
        '(': 80,
        ')': 0,
        ',': 0,
        '@': 75,
        '#': 70,
        ';': 80,
        ':': 80,
        '?': 20,
        '+': 50,
        '-': 50,
        '*': 60,
        '/': 60,
        '%': 60,
        '|': 20,
        '=': 40,
        '<': 40,
        '>': 40,
        '^': 40,
        '**': 60,
        '..': 20,
        ':=': 10,
        '!=': 40,
        '<=': 40,
        '>=': 40,
        '~>': 40,
        'and': 30,
        'or': 25,
        'in': 40,
        '&': 50,
        '!': 0,   // not an operator, but needed as a stop character for name tokens
        '~': 0   // not an operator, but needed as a stop character for name tokens
    };

    var escapes = {  // JSON string escape sequences - see json.org
        '"': '"',
        '\\': '\\',
        '/': '/',
        'b': '\b',
        'f': '\f',
        'n': '\n',
        'r': '\r',
        't': '\t'
    };

    // Tokenizer (lexer) - invoked by the parser to return one token at a time
    var tokenizer = function (path) {
        var position = 0;
        var length = path.length;

        var create = function (type, value) {
            var obj = {type: type, value: value, position: position};
            return obj;
        };

        var scanRegex = function() {
            // the prefix '/' will have been previously scanned. Find the end of the regex.
            // search for closing '/' ignoring any that are escaped, or within brackets
            var start = position;
            var depth = 0;
            var pattern;
            var flags;
            while(position < length) {
                var currentChar = path.charAt(position);
                if(currentChar === '/' && path.charAt(position - 1) !== '\\' && depth === 0) {
                    // end of regex found
                    pattern = path.substring(start, position);
                    if(pattern === '') {
                        throw {
                            code: "S0301",
                            stack: (new Error()).stack,
                            position: position
                        };
                    }
                    position++;
                    currentChar = path.charAt(position);
                    // flags
                    start = position;
                    while(currentChar === 'i' || currentChar === 'm') {
                        position++;
                        currentChar = path.charAt(position);
                    }
                    flags = path.substring(start, position) + 'g';
                    return new RegExp(pattern, flags);
                }
                if((currentChar === '(' || currentChar === '[' || currentChar === '{') && path.charAt(position - 1) !== '\\' ) {
                    depth++;
                }
                if((currentChar === ')' || currentChar === ']' || currentChar === '}') && path.charAt(position - 1) !== '\\' ) {
                    depth--;
                }

                position++;
            }
            throw {
                code: "S0302",
                stack: (new Error()).stack,
                position: position
            };
        };

        var next = function (prefix) {
            if (position >= length) return null;
            var currentChar = path.charAt(position);
            // skip whitespace
            while (position < length && ' \t\n\r\v'.indexOf(currentChar) > -1) {
                position++;
                currentChar = path.charAt(position);
            }
            // test for regex
            if (prefix !== true && currentChar === '/') {
                position++;
                return create('regex', scanRegex());
            }
            // handle double-char operators
            if (currentChar === '.' && path.charAt(position + 1) === '.') {
                // double-dot .. range operator
                position += 2;
                return create('operator', '..');
            }
            if (currentChar === ':' && path.charAt(position + 1) === '=') {
                // := assignment
                position += 2;
                return create('operator', ':=');
            }
            if (currentChar === '!' && path.charAt(position + 1) === '=') {
                // !=
                position += 2;
                return create('operator', '!=');
            }
            if (currentChar === '>' && path.charAt(position + 1) === '=') {
                // >=
                position += 2;
                return create('operator', '>=');
            }
            if (currentChar === '<' && path.charAt(position + 1) === '=') {
                // <=
                position += 2;
                return create('operator', '<=');
            }
            if (currentChar === '*' && path.charAt(position + 1) === '*') {
                // **  descendant wildcard
                position += 2;
                return create('operator', '**');
            }
            if (currentChar === '~' && path.charAt(position + 1) === '>') {
                // ~>  chain function
                position += 2;
                return create('operator', '~>');
            }
            // test for single char operators
            if (operators.hasOwnProperty(currentChar)) {
                position++;
                return create('operator', currentChar);
            }
            // test for string literals
            if (currentChar === '"' || currentChar === "'") {
                var quoteType = currentChar;
                // double quoted string literal - find end of string
                position++;
                var qstr = "";
                while (position < length) {
                    currentChar = path.charAt(position);
                    if (currentChar === '\\') { // escape sequence
                        position++;
                        currentChar = path.charAt(position);
                        if (escapes.hasOwnProperty(currentChar)) {
                            qstr += escapes[currentChar];
                        } else if (currentChar === 'u') {
                            // \u should be followed by 4 hex digits
                            var octets = path.substr(position + 1, 4);
                            if (/^[0-9a-fA-F]+$/.test(octets)) {
                                var codepoint = parseInt(octets, 16);
                                qstr += String.fromCharCode(codepoint);
                                position += 4;
                            } else {
                                throw {
                                    code: "S0104",
                                    stack: (new Error()).stack,
                                    position: position
                                };
                            }
                        } else {
                            // illegal escape sequence
                            throw {
                                code: "S0103",
                                stack: (new Error()).stack,
                                position: position,
                                token: currentChar
                            };

                        }
                    } else if (currentChar === quoteType) {
                        position++;
                        return create('string', qstr);
                    } else {
                        qstr += currentChar;
                    }
                    position++;
                }
                throw {
                    code: "S0101",
                    stack: (new Error()).stack,
                    position: position
                };
            }
            // test for numbers
            var numregex = /^-?(0|([1-9][0-9]*))(\.[0-9]+)?([Ee][-+]?[0-9]+)?/;
            var match = numregex.exec(path.substring(position));
            if (match !== null) {
                var num = parseFloat(match[0]);
                if (!isNaN(num) && isFinite(num)) {
                    position += match[0].length;
                    return create('number', num);
                } else {
                    throw {
                        code: "S0102",
                        stack: (new Error()).stack,
                        position: position,
                        token: match[0]
                    };
                }
            }
            // test for quoted names (backticks)
            var name;
            if(currentChar === '`') {
                // scan for closing quote
                position++;
                var end = path.indexOf('`', position);
                if(end !== -1) {
                    name = path.substring(position, end);
                    position = end + 1;
                    return create('name', name);
                }
                position = length;
                throw {
                    code: "S0105",
                    stack: (new Error()).stack,
                    position: position
                };
            }
            // test for names
            var i = position;
            var ch;
            for (;;) {
                ch = path.charAt(i);
                if (i === length || ' \t\n\r\v'.indexOf(ch) > -1 || operators.hasOwnProperty(ch)) {
                    if (path.charAt(position) === '$') {
                        // variable reference
                        name = path.substring(position + 1, i);
                        position = i;
                        return create('variable', name);
                    } else {
                        name = path.substring(position, i);
                        position = i;
                        switch (name) {
                            case 'or':
                            case 'in':
                            case 'and':
                                return create('operator', name);
                            case 'true':
                                return create('value', true);
                            case 'false':
                                return create('value', false);
                            case 'null':
                                return create('value', null);
                            default:
                                if (position === length && name === '') {
                                    // whitespace at end of input
                                    return null;
                                }
                                return create('name', name);
                        }
                    }
                } else {
                    i++;
                }
            }
        };

        return next;
    };

    /**
     * Parses a function signature definition and returns a validation function
     * @param {string} signature - the signature between the <angle brackets>
     * @returns {Function} validation function
     */
    function parseSignature(signature) {
        // create a Regex that represents this signature and return a function that when invoked,
        // returns the validated (possibly fixed-up) arguments, or throws a validation error
        // step through the signature, one symbol at a time
        var position = 1;
        var params = [];
        var param = {};
        var prevParam = param;
        while (position < signature.length) {
            var symbol = signature.charAt(position);
            if(symbol === ':') {
                // TODO figure out what to do with the return type
                // ignore it for now
                break;
            }

            var next = function() {
                params.push(param);
                prevParam = param;
                param = {};
            };

            var findClosingBracket = function(str, start, openSymbol, closeSymbol) {
                // returns the position of the closing symbol (e.g. bracket) in a string
                // that balances the opening symbol at position start
                var depth = 1;
                var position = start;
                while(position < str.length) {
                    position++;
                    symbol = str.charAt(position);
                    if(symbol === closeSymbol) {
                        depth--;
                        if(depth === 0) {
                            // we're done
                            break; // out of while loop
                        }
                    } else if(symbol === openSymbol) {
                        depth++;
                    }
                }
                return position;
            };

            switch (symbol) {
                case 's': // string
                case 'n': // number
                case 'b': // boolean
                case 'l': // not so sure about expecting null?
                case 'o': // object
                    param.regex = '[' + symbol + 'm]';
                    param.type = symbol;
                    next();
                    break;
                case 'a': // array
                    //  normally treat any value as singleton array
                    param.regex = '[asnblfom]';
                    param.type = symbol;
                    param.array = true;
                    next();
                    break;
                case 'f': // function
                    param.regex = 'f';
                    param.type = symbol;
                    next();
                    break;
                case 'j': // any JSON type
                    param.regex = '[asnblom]';
                    param.type = symbol;
                    next();
                    break;
                case 'x': // any type
                    param.regex = '[asnblfom]';
                    param.type = symbol;
                    next();
                    break;
                case '-': // use context if param not supplied
                    prevParam.context = true;
                    prevParam.contextRegex = new RegExp(prevParam.regex); // pre-compiled to test the context type at runtime
                    prevParam.regex += '?';
                    break;
                case '?': // optional param
                case '+': // one or more
                    prevParam.regex += symbol;
                    break;
                case '(': // choice of types
                    // search forward for matching ')'
                    var endParen = findClosingBracket(signature, position, '(', ')');
                    var choice = signature.substring(position + 1, endParen);
                    if(choice.indexOf('<') === -1) {
                        // no parameterized types, simple regex
                        param.regex = '[' + choice + 'm]';
                    } else {
                        // TODO harder
                        throw {
                            code: "S0402",
                            stack: (new Error()).stack,
                            value: choice,
                            offset: position
                        };
                    }
                    param.type = '(' + choice + ')';
                    position = endParen;
                    next();
                    break;
                case '<': // type parameter - can only be applied to 'a' and 'f'
                    if(prevParam.type === 'a' || prevParam.type === 'f') {
                        // search forward for matching '>'
                        var endPos = findClosingBracket(signature, position, '<', '>');
                        prevParam.subtype = signature.substring(position + 1, endPos);
                        position = endPos;
                    } else {
                        throw {
                            code: "S0401",
                            stack: (new Error()).stack,
                            value: prevParam.type,
                            offset: position
                        };
                    }
                    break;
            }
            position++;
        }
        var regexStr = '^' +
          params.map(function(param) {
              return '(' + param.regex + ')';
          }).join('') +
          '$';
        var regex = new RegExp(regexStr);
        var getSymbol = function(value) {
            var symbol;
            if(isFunction(value)) {
                symbol = 'f';
            } else {
                var type = typeof value;
                switch (type) {
                    case 'string':
                        symbol = 's';
                        break;
                    case 'number':
                        symbol = 'n';
                        break;
                    case 'boolean':
                        symbol = 'b';
                        break;
                    case 'object':
                        if (value === null) {
                            symbol = 'l';
                        } else if (Array.isArray(value)) {
                            symbol = 'a';
                        } else {
                            symbol = 'o';
                        }
                        break;
                    case 'undefined':
                        // any value can be undefined, but should be allowed to match
                        symbol = 'm'; // m for missing
                }
            }
            return symbol;
        };

        var throwValidationError = function(badArgs, badSig) {
            // to figure out where this went wrong we need apply each component of the
            // regex to each argument until we get to the one that fails to match
            var partialPattern = '^';
            var goodTo = 0;
            for(var index = 0; index < params.length; index++) {
                partialPattern += params[index].regex;
                var match = badSig.match(partialPattern);
                if(match === null) {
                    // failed here
                    throw {
                        code: "T0410",
                        stack: (new Error()).stack,
                        value: badArgs[goodTo],
                        index: goodTo + 1
                    };
                }
                goodTo = match[0].length;
            }
            // if it got this far, it's probably because of extraneous arguments (we
            // haven't added the trailing '$' in the regex yet.
            throw {
                code: "T0410",
                stack: (new Error()).stack,
                value: badArgs[goodTo],
                index: goodTo + 1
            };
        };

        return {
            definition: signature,
            validate: function(args, context) {
                var suppliedSig = '';
                args.forEach(function(arg) {
                    suppliedSig += getSymbol(arg);
                });
                var isValid = regex.exec(suppliedSig);
                if(isValid) {
                    var validatedArgs = [];
                    var argIndex = 0;
                    params.forEach(function(param, index) {
                        var arg = args[argIndex];
                        var match = isValid[index + 1];
                        if(match === '') {
                            if (param.context) {
                                // substitute context value for missing arg
                                // first check that the context value is the right type
                                var contextType = getSymbol(context);
                                // test contextType against the regex for this arg (without the trailing ?)
                                if(param.contextRegex.test(contextType)) {
                                    validatedArgs.push(context);
                                } else {
                                    // context value not compatible with this argument
                                    throw {
                                        code: "T0411",
                                        stack: (new Error()).stack,
                                        value: context,
                                        index: argIndex + 1
                                    };
                                }
                            } else {
                                validatedArgs.push(arg);
                                argIndex++;
                            }
                        } else {
                            // may have matched multiple args (if the regex ends with a '+'
                            // split into single tokens
                            match.split('').forEach(function(single) {
                                if (param.type === 'a') {
                                    if (single === 'm') {
                                        // missing (undefined)
                                        arg = undefined;
                                    } else {
                                        arg = args[argIndex];
                                        var arrayOK = true;
                                        // is there type information on the contents of the array?
                                        if (typeof param.subtype !== 'undefined') {
                                            if (single !== 'a' && match !== param.subtype) {
                                                arrayOK = false;
                                            } else if (single === 'a') {
                                                if (arg.length > 0) {
                                                    var itemType = getSymbol(arg[0]);
                                                    if (itemType !== param.subtype.charAt(0)) { // TODO recurse further
                                                        arrayOK = false;
                                                    } else {
                                                        // make sure every item in the array is this type
                                                        var differentItems = arg.filter(function (val) {
                                                            return (getSymbol(val) !== itemType);
                                                        });
                                                        arrayOK = (differentItems.length === 0);
                                                    }
                                                }
                                            }
                                        }
                                        if (!arrayOK) {
                                            throw {
                                                code: "T0412",
                                                stack: (new Error()).stack,
                                                value: arg,
                                                index: argIndex + 1,
                                                type: param.subtype // TODO translate symbol to type name
                                            };
                                        }
                                        // the function expects an array. If it's not one, make it so
                                        if (single !== 'a') {
                                            arg = [arg];
                                        }
                                    }
                                    validatedArgs.push(arg);
                                    argIndex++;
                                } else {
                                    validatedArgs.push(arg);
                                    argIndex++;
                                }
                            });
                        }
                    });
                    return validatedArgs;
                }
                throwValidationError(args, suppliedSig);
            }
        };
    }

    // This parser implements the 'Top down operator precedence' algorithm developed by Vaughan R Pratt; http://dl.acm.org/citation.cfm?id=512931.
    // and builds on the Javascript framework described by Douglas Crockford at http://javascript.crockford.com/tdop/tdop.html
    // and in 'Beautiful Code', edited by Andy Oram and Greg Wilson, Copyright 2007 O'Reilly Media, Inc. 798-0-596-51004-6

    var parser = function (source, recover) {
        var node;
        var lexer;

        var symbol_table = {};
        var errors = [];

        var remainingTokens = function() {
            var remaining = [];
            if(node.id !== '(end)') {
                remaining.push({type: node.type, value: node.value, position: node.position});
            }
            var nxt = lexer();
            while(nxt !== null) {
                remaining.push(nxt);
                nxt = lexer();
            }
            return remaining;
        };

        var base_symbol = {
            nud: function () {
                // error - symbol has been invoked as a unary operator
                var err = {
                    code: 'S0211',
                    token: this.value,
                    position: this.position
                };

                if(recover) {
                    err.remaining = remainingTokens();
                    err.type = 'error';
                    errors.push(err);
                    return err;
                } else {
                    err.stack = (new Error()).stack;
                    throw err;
                }
            }
        };

        var symbol = function (id, bp) {
            var s = symbol_table[id];
            bp = bp || 0;
            if (s) {
                if (bp >= s.lbp) {
                    s.lbp = bp;
                }
            } else {
                s = Object.create(base_symbol);
                s.id = s.value = id;
                s.lbp = bp;
                symbol_table[id] = s;
            }
            return s;
        };

        var handleError = function(err) {
            if(recover) {
                // tokenize the rest of the buffer and add it to an error token
                err.remaining = remainingTokens();
                errors.push(err);
                var symbol = symbol_table["(error)"];
                node = Object.create(symbol);
                node.error = err;
                node.type = "(error)";
                return node;
            } else {
                err.stack = (new Error()).stack;
                throw err;
            }
        };

        var advance = function (id, infix) {
            if (id && node.id !== id) {
                var code;
                if(node.id === '(end)') {
                    // unexpected end of buffer
                    code = "S0203";
                } else {
                    code = "S0202";
                }
                var err = {
                    code: code,
                    position: node.position,
                    token: node.value,
                    value: id
                };
                return handleError(err);
            }
            var next_token = lexer(infix);
            if (next_token === null) {
                node = symbol_table["(end)"];
                node.position = source.length;
                return node;
            }
            var value = next_token.value;
            var type = next_token.type;
            var symbol;
            switch (type) {
                case 'name':
                case 'variable':
                    symbol = symbol_table["(name)"];
                    break;
                case 'operator':
                    symbol = symbol_table[value];
                    if (!symbol) {
                        return handleError( {
                            code: "S0204",
                            stack: (new Error()).stack,
                            position: next_token.position,
                            token: value
                        });
                    }
                    break;
                case 'string':
                case 'number':
                case 'value':
                    type = "literal";
                    symbol = symbol_table["(literal)"];
                    break;
                case 'regex':
                    type = "regex";
                    symbol = symbol_table["(regex)"];
                    break;
                    /* istanbul ignore next */
                default:
                    return handleError( {
                        code: "S0205",
                        stack: (new Error()).stack,
                        position: next_token.position,
                        token: value
                    });
            }

            node = Object.create(symbol);
            node.value = value;
            node.type = type;
            node.position = next_token.position;
            return node;
        };

        // Pratt's algorithm
        var expression = function (rbp) {
            var left;
            var t = node;
            advance(null, true);
            left = t.nud();
            while (rbp < node.lbp) {
                t = node;
                advance();
                left = t.led(left);
            }
            return left;
        };

        var terminal = function(id) {
            var s = symbol(id, 0);
            s.nud = function() {
                return this;
            };
        };

        // match infix operators
        // <expression> <operator> <expression>
        // left associative
        var infix = function (id, bp, led) {
            var bindingPower = bp || operators[id];
            var s = symbol(id, bindingPower);
            s.led = led || function (left) {
                this.lhs = left;
                this.rhs = expression(bindingPower);
                this.type = "binary";
                return this;
            };
            return s;
        };

        // match infix operators
        // <expression> <operator> <expression>
        // right associative
        var infixr = function (id, bp, led) {
            var bindingPower = bp || operators[id];
            var s = symbol(id, bindingPower);
            s.led = led || function (left) {
                this.lhs = left;
                this.rhs = expression(bindingPower - 1); // subtract 1 from bindingPower for right associative operators
                this.type = "binary";
                return this;
            };
            return s;
        };

        // match prefix operators
        // <operator> <expression>
        var prefix = function (id, nud) {
            var s = symbol(id);
            s.nud = nud || function () {
                this.expression = expression(70);
                this.type = "unary";
                return this;
            };
            return s;
        };

        terminal("(end)");
        terminal("(name)");
        terminal("(literal)");
        terminal("(regex)");
        symbol(":");
        symbol(";");
        symbol(",");
        symbol(")");
        symbol("]");
        symbol("}");
        symbol(".."); // range operator
        infix("."); // field reference
        infix("+"); // numeric addition
        infix("-"); // numeric subtraction
        infix("*"); // numeric multiplication
        infix("/"); // numeric division
        infix("%"); // numeric modulus
        infix("="); // equality
        infix("<"); // less than
        infix(">"); // greater than
        infix("!="); // not equal to
        infix("<="); // less than or equal
        infix(">="); // greater than or equal
        infix("&"); // string concatenation
        infix("and"); // Boolean AND
        infix("or"); // Boolean OR
        infix("in"); // is member of array
        terminal("and"); // the 'keywords' can also be used as terminals (field names)
        terminal("or"); //
        terminal("in"); //
        infixr(":="); // bind variable
        prefix("-"); // unary numeric negation
        infix("~>"); // function application

        infixr("(error)", 10, function(left) {
            this.lhs = left;

            this.error = node.error;
            this.remaining = remainingTokens();
            this.type = 'error';
            return this;
        });

        // field wildcard (single level)
        prefix('*', function () {
            this.type = "wildcard";
            return this;
        });

        // descendant wildcard (multi-level)
        prefix('**', function () {
            this.type = "descendant";
            return this;
        });

        // function invocation
        infix("(", operators['('], function (left) {
            // left is is what we are trying to invoke
            this.procedure = left;
            this.type = 'function';
            this.arguments = [];
            if (node.id !== ')') {
                for (;;) {
                    if (node.type === 'operator' && node.id === '?') {
                        // partial function application
                        this.type = 'partial';
                        this.arguments.push(node);
                        advance('?');
                    } else {
                        this.arguments.push(expression(0));
                    }
                    if (node.id !== ',') break;
                    advance(',');
                }
            }
            advance(")", true);
            // if the name of the function is 'function' or λ, then this is function definition (lambda function)
            if (left.type === 'name' && (left.value === 'function' || left.value === '\u03BB')) {
                // all of the args must be VARIABLE tokens
                this.arguments.forEach(function (arg, index) {
                    if (arg.type !== 'variable') {
                        return handleError( {
                            code: "S0208",
                            stack: (new Error()).stack,
                            position: arg.position,
                            token: arg.value,
                            value: index + 1
                        });
                    }
                });
                this.type = 'lambda';
                // is the next token a '<' - if so, parse the function signature
                if(node.id === '<') {
                    var sigPos = node.position;
                    var depth = 1;
                    var sig = '<';
                    while(depth > 0 && node.id !== '{' && node.id !== '(end)') {
                        var tok = advance();
                        if(tok.id === '>') {
                            depth--;
                        } else if(tok.id === '<') {
                            depth++;
                        }
                        sig += tok.value;
                    }
                    advance('>');
                    try {
                        this.signature = parseSignature(sig);
                    } catch(err) {
                        // insert the position into this error
                        err.position = sigPos + err.offset;
                        return handleError( err );
                    }
                }
                // parse the function body
                advance('{');
                this.body = expression(0);
                advance('}');
            }
            return this;
        });

        // parenthesis - block expression
        prefix("(", function () {
            var expressions = [];
            while (node.id !== ")") {
                expressions.push(expression(0));
                if (node.id !== ";") {
                    break;
                }
                advance(";");
            }
            advance(")", true);
            this.type = 'block';
            this.expressions = expressions;
            return this;
        });

        // array constructor
        prefix("[", function () {
            var a = [];
            if (node.id !== "]") {
                for (;;) {
                    var item = expression(0);
                    if (node.id === "..") {
                        // range operator
                        var range = {type: "binary", value: "..", position: node.position, lhs: item};
                        advance("..");
                        range.rhs = expression(0);
                        item = range;
                    }
                    a.push(item);
                    if (node.id !== ",") {
                        break;
                    }
                    advance(",");
                }
            }
            advance("]", true);
            this.expressions = a;
            this.type = "unary";
            return this;
        });

        // filter - predicate or array index
        infix("[", operators['['], function (left) {
            if(node.id === "]") {
                // empty predicate means maintain singleton arrays in the output
                var step = left;
                while(step && step.type === 'binary' && step.value === '[') {
                    step = step.lhs;
                }
                step.keepArray = true;
                advance("]");
                return left;
            } else {
                this.lhs = left;
                this.rhs = expression(operators[']']);
                this.type = 'binary';
                advance("]", true);
                return this;
            }
        });

        // order-by
        infix("^", operators['^'], function (left) {
            advance("(");
            var terms = [];
            for(;;) {
                var term = {
                    descending: false
                };
                if (node.id === "<") {
                    // ascending sort
                    advance("<");
                } else if (node.id === ">") {
                    // descending sort
                    term.descending = true;
                    advance(">");
                } else {
                    //unspecified - default to ascending
                }
                term.expression = expression(0);
                terms.push(term);
                if(node.id !== ",") {
                    break;
                }
                advance(",");
            }
            advance(")");
            this.lhs = left;
            this.rhs = terms;
            this.type = 'binary';
            return this;
        });

        var objectParser = function (left) {
            var a = [];
            if (node.id !== "}") {
                for (;;) {
                    var n = expression(0);
                    advance(":");
                    var v = expression(0);
                    a.push([n, v]); // holds an array of name/value expression pairs
                    if (node.id !== ",") {
                        break;
                    }
                    advance(",");
                }
            }
            advance("}", true);
            if(typeof left === 'undefined') {
                // NUD - unary prefix form
                this.lhs = a;
                this.type = "unary";
            } else {
                // LED - binary infix form
                this.lhs = left;
                this.rhs = a;
                this.type = 'binary';
            }
            return this;
        };

        // object constructor
        prefix("{", objectParser);

        // object grouping
        infix("{", operators['{'], objectParser);

        // if/then/else ternary operator ?:
        infix("?", operators['?'], function (left) {
            this.type = 'condition';
            this.condition = left;
            this.then = expression(0);
            if (node.id === ':') {
                // else condition
                advance(":");
                this.else = expression(0);
            }
            return this;
        });

        // object transformer
        prefix("|", function () {
            this.type = 'transform';
            this.pattern = expression(0);
            advance('|');
            this.update = expression(0);
            if(node.id === ',') {
                advance(',');
                this.delete = expression(0);
            }
            advance('|');
            return this;
        });

        // tail call optimization
        // this is invoked by the post parser to analyse lambda functions to see
        // if they make a tail call.  If so, it is replaced by a thunk which will
        // be invoked by the trampoline loop during function application.
        // This enables tail-recursive functions to be written without growing the stack
        var tail_call_optimize = function(expr) {
            var result;
            if(expr.type === 'function') {
                var thunk = {type: 'lambda', thunk: true, arguments: [], position: expr.position};
                thunk.body = expr;
                result = thunk;
            } else if(expr.type === 'condition') {
                // analyse both branches
                expr.then = tail_call_optimize(expr.then);
                if(typeof expr.else !== 'undefined') {
                    expr.else = tail_call_optimize(expr.else);
                }
                result = expr;
            } else if(expr.type === 'block') {
                // only the last expression in the block
                var length = expr.expressions.length;
                if(length > 0) {
                    expr.expressions[length - 1] = tail_call_optimize(expr.expressions[length - 1]);
                }
                result = expr;
            } else {
                result = expr;
            }
            return result;
        };

        // post-parse stage
        // the purpose of this is flatten the parts of the AST representing location paths,
        // converting them to arrays of steps which in turn may contain arrays of predicates.
        // following this, nodes containing '.' and '[' should be eliminated from the AST.
        var ast_optimize = function (expr) {
            var result;
            switch (expr.type) {
                case 'binary':
                    switch (expr.value) {
                        case '.':
                            var lstep = ast_optimize(expr.lhs);
                            result = {type: 'path', steps: []};
                            if (lstep.type === 'path') {
                                Array.prototype.push.apply(result.steps, lstep.steps);
                            } else {
                                result.steps = [lstep];
                            }
                            var rest = ast_optimize(expr.rhs);
                            if(rest.type === 'function' &&
                              rest.procedure.type === 'path' &&
                              rest.procedure.steps.length === 1 &&
                              rest.procedure.steps[0].type === 'name' &&
                              result.steps[result.steps.length-1].type === 'function') {
                                // next function in chain of functions - will override a thenable
                                result.steps[result.steps.length-1].nextFunction = rest.procedure.steps[0].value;
                            }
                            if(rest.type !== 'path') {
                                rest = {type: 'path', steps: [rest]};
                            }
                            Array.prototype.push.apply(result.steps, rest.steps);
                            // any steps within a path that are literals, should be changed to 'name'
                            result.steps.filter(function(step) {
                                return step.type === 'literal';
                            }).forEach(function(lit) {
                                lit.type = 'name';
                            });
                            // any step that signals keeping a singleton array, should be flagged on the path
                            if(result.steps.filter(function(step) { return step.keepArray === true;}).length > 0) {
                                result.keepSingletonArray = true;
                            }
                            // if first step is a path constructor, flag it for special handling
                            if(result.steps[0].type === 'unary' && result.steps[0].value === '[') {
                                result.steps[0].consarray = true;
                            }
                            break;
                        case '[':
                            // predicated step
                            // LHS is a step or a predicated step
                            // RHS is the predicate expr
                            result = ast_optimize(expr.lhs);
                            var step = result;
                            if(result.type === 'path') {
                                step = result.steps[result.steps.length - 1];
                            }
                            if (typeof step.group !== 'undefined') {
                                throw {
                                    code: "S0209",
                                    stack: (new Error()).stack,
                                    position: expr.position
                                };
                            }
                            if (typeof step.predicate === 'undefined') {
                                step.predicate = [];
                            }
                            step.predicate.push(ast_optimize(expr.rhs));
                            break;
                        case '{':
                            // group-by
                            // LHS is a step or a predicated step
                            // RHS is the object constructor expr
                            result = ast_optimize(expr.lhs);
                            if (typeof result.group !== 'undefined') {
                                throw {
                                    code: "S0210",
                                    stack: (new Error()).stack,
                                    position: expr.position
                                };
                            }
                            // object constructor - process each pair
                            result.group = {
                                lhs: expr.rhs.map(function (pair) {
                                    return [ast_optimize(pair[0]), ast_optimize(pair[1])];
                                }),
                                position: expr.position
                            };
                            break;
                        case '^':
                            // order-by
                            // LHS is the array to be ordered
                            // RHS defines the terms
                            result = {type: 'sort', value: expr.value, position: expr.position};
                            result.lhs = ast_optimize(expr.lhs);
                            result.rhs = expr.rhs.map(function (terms) {
                                return {
                                    descending: terms.descending,
                                    expression: ast_optimize(terms.expression)
                                };
                            });
                            break;
                        case ':=':
                            result = {type: 'bind', value: expr.value, position: expr.position};
                            result.lhs = ast_optimize(expr.lhs);
                            result.rhs = ast_optimize(expr.rhs);
                            break;
                        case '~>':
                            result = {type: 'apply', value: expr.value, position: expr.position};
                            result.lhs = ast_optimize(expr.lhs);
                            result.rhs = ast_optimize(expr.rhs);
                            break;
                        default:
                            result = {type: expr.type, value: expr.value, position: expr.position};
                            result.lhs = ast_optimize(expr.lhs);
                            result.rhs = ast_optimize(expr.rhs);
                    }
                    break;
                case 'unary':
                    result = {type: expr.type, value: expr.value, position: expr.position};
                    if (expr.value === '[') {
                        // array constructor - process each item
                        result.expressions = expr.expressions.map(function (item) {
                            return ast_optimize(item);
                        });
                    } else if (expr.value === '{') {
                        // object constructor - process each pair
                        result.lhs = expr.lhs.map(function (pair) {
                            return [ast_optimize(pair[0]), ast_optimize(pair[1])];
                        });
                    } else {
                        // all other unary expressions - just process the expression
                        result.expression = ast_optimize(expr.expression);
                        // if unary minus on a number, then pre-process
                        if (expr.value === '-' && result.expression.type === 'literal' && isNumeric(result.expression.value)) {
                            result = result.expression;
                            result.value = -result.value;
                        }
                    }
                    break;
                case 'function':
                case 'partial':
                    result = {type: expr.type, name: expr.name, value: expr.value, position: expr.position};
                    result.arguments = expr.arguments.map(function (arg) {
                        return ast_optimize(arg);
                    });
                    result.procedure = ast_optimize(expr.procedure);
                    break;
                case 'lambda':
                    result = {type: expr.type, arguments: expr.arguments, signature: expr.signature, position: expr.position};
                    var body = ast_optimize(expr.body);
                    result.body = tail_call_optimize(body);
                    break;
                case 'condition':
                    result = {type: expr.type, position: expr.position};
                    result.condition = ast_optimize(expr.condition);
                    result.then = ast_optimize(expr.then);
                    if (typeof expr.else !== 'undefined') {
                        result.else = ast_optimize(expr.else);
                    }
                    break;
                case 'transform':
                    result = {type: expr.type, position: expr.position};
                    result.pattern = ast_optimize(expr.pattern);
                    result.update = ast_optimize(expr.update);
                    if(typeof expr.delete !== 'undefined') {
                        result.delete = ast_optimize(expr.delete);
                    }
                    break;
                case 'block':
                    result = {type: expr.type, position: expr.position};
                    // array of expressions - process each one
                    result.expressions = expr.expressions.map(function (item) {
                        return ast_optimize(item);
                    });
                    // TODO scan the array of expressions to see if any of them assign variables
                    // if so, need to mark the block as one that needs to create a new frame
                    break;
                case 'name':
                    result = {type: 'path', steps: [expr]};
                    if(expr.keepArray) {
                        result.keepSingletonArray = true;
                    }
                    break;
                case 'literal':
                case 'wildcard':
                case 'descendant':
                case 'variable':
                case 'regex':
                    result = expr;
                    break;
                case 'operator':
                    // the tokens 'and' and 'or' might have been used as a name rather than an operator
                    if (expr.value === 'and' || expr.value === 'or' || expr.value === 'in') {
                        expr.type = 'name';
                        result = ast_optimize(expr);
                    } else /* istanbul ignore else */ if (expr.value === '?') {
                        // partial application
                        result = expr;
                    } else {
                        throw {
                            code: "S0201",
                            stack: (new Error()).stack,
                            position: expr.position,
                            token: expr.value
                        };
                    }
                    break;
                case 'error':
                    result = expr;
                    if(expr.lhs) {
                        result = ast_optimize(expr.lhs);
                    }
                    break;
                default:
                    var code = "S0206";
                    /* istanbul ignore else */
                    if (expr.id === '(end)') {
                        code = "S0207";
                    }
                    var err = {
                        code: code,
                        position: expr.position,
                        token: expr.value
                    };
                    if(recover) {
                        errors.push(err);
                        return {type: 'error', error: err};
                    } else {
                        err.stack = (new Error()).stack;
                        throw err;
                    }
            }
            return result;
        };

        // now invoke the tokenizer and the parser and return the syntax tree
        lexer = tokenizer(source);
        advance();
        // parse the tokens
        var expr = expression(0);
        if (node.id !== '(end)') {
            var err = {
                code: "S0201",
                position: node.position,
                token: node.value
            };
            handleError(err);
        }
        expr = ast_optimize(expr);

        if(errors.length > 0) {
            expr.errors = errors;
        }

        return expr;
    };

    // Start of Evaluator code

    var staticFrame = createFrame(null);

    /**
     * Check if value is a finite number
     * @param {float} n - number to evaluate
     * @returns {boolean} True if n is a finite number
     */
    function isNumeric(n) {
        var isNum = false;
        if(typeof n === 'number') {
            var num = parseFloat(n);
            isNum = !isNaN(num);
            if (isNum && !isFinite(num)) {
                throw {
                    code: "D1001",
                    value: n,
                    stack: (new Error()).stack
                };
            }
        }
        return isNum;
    }

    /**
     * Returns true if the arg is an array of strings
     * @param {*} arg - the item to test
     * @returns {boolean} True if arg is an array of strings
     */
    function isArrayOfStrings(arg) {
        var result = false;
        /* istanbul ignore else */
        if(Array.isArray(arg)) {
            result = (arg.filter(function(item){return typeof item !== 'string';}).length === 0);
        }
        return result;
    }

    /**
     * Returns true if the arg is an array of numbers
     * @param {*} arg - the item to test
     * @returns {boolean} True if arg is an array of numbers
     */
    function isArrayOfNumbers(arg) {
        var result = false;
        if(Array.isArray(arg)) {
            result = (arg.filter(function(item){return !isNumeric(item);}).length === 0);
        }
        return result;
    }

    // Polyfill
    /* istanbul ignore next */
    Number.isInteger = Number.isInteger || function(value) {
        return typeof value === "number" &&
          isFinite(value) &&
          Math.floor(value) === value;
    };

    /**
     * Evaluate expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluate(expr, input, environment) {
        var result;

        var entryCallback = environment.lookup('__evaluate_entry');
        if(entryCallback) {
            entryCallback(expr, input, environment);
        }

        switch (expr.type) {
            case 'path':
                result = yield * evaluatePath(expr.steps, input, environment);
                result = normalizeSequence(result, expr.keepSingletonArray);
                break;
            case 'binary':
                result = yield * evaluateBinary(expr, input, environment);
                break;
            case 'unary':
                result = yield * evaluateUnary(expr, input, environment);
                break;
            case 'name':
                result = evaluateName(expr, input, environment);
                break;
            case 'literal':
                result = evaluateLiteral(expr, input, environment);
                break;
            case 'wildcard':
                result = evaluateWildcard(expr, input, environment);
                break;
            case 'descendant':
                result = evaluateDescendants(expr, input, environment);
                break;
            case 'condition':
                result = yield * evaluateCondition(expr, input, environment);
                break;
            case 'block':
                result = yield * evaluateBlock(expr, input, environment);
                break;
            case 'bind':
                result = yield * evaluateBindExpression(expr, input, environment);
                break;
            case 'regex':
                result = evaluateRegex(expr, input, environment);
                break;
            case 'function':
                result = yield * evaluateFunction(expr, input, environment);
                break;
            case 'variable':
                result = evaluateVariable(expr, input, environment);
                break;
            case 'lambda':
                result = evaluateLambda(expr, input, environment);
                break;
            case 'partial':
                result = yield * evaluatePartialApplication(expr, input, environment);
                break;
            case 'apply':
                result = yield * evaluateApplyExpression(expr, input, environment);
                break;
            case 'sort':
                result = yield * evaluateSortExpression(expr, input, environment);
                break;
            case 'transform':
                result = evaluateTransformExpression(expr, input, environment);
                break;
        }

        if(environment.lookup('__jsonata_async') &&
          (typeof result === 'undefined' || result === null || typeof result.then !== 'function')) {
            result = Promise.resolve(result);
        }
        if(environment.lookup('__jsonata_async') && typeof result.then === 'function' && expr.nextFunction && typeof result[expr.nextFunction] === 'function') {
            // although this is a 'thenable', it is chaining a different function
            // so don't yield since yielding will trigger the .then()
        } else {
            result = yield result;
        }


        if (expr.hasOwnProperty('predicate')) {
            result = yield * applyPredicates(expr.predicate, result, environment);
            result = normalizeSequence(result);

        }
        if (expr.hasOwnProperty('group')) {
            result = yield * evaluateGroupExpression(expr.group, result, environment);
        }

        var exitCallback = environment.lookup('__evaluate_exit');
        if(exitCallback) {
            exitCallback(expr, input, environment, result);
        }

        return result;
    }

    /**
     * Evaluate path expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluatePath(expr, input, environment) {
        var inputSequence;
        // expr is an array of steps
        // if the first step is a variable reference ($...), including root reference ($$),
        //   then the path is absolute rather than relative
        if (expr[0].type === 'variable') {
            inputSequence = [input]; // dummy singleton sequence for first (absolute) step
        } else if (Array.isArray(input)) {
            inputSequence = input;
        } else {
            // if input is not an array, make it so
            inputSequence = [input];
        }

        var resultSequence;

        // evaluate each step in turn
        for(var ii = 0; ii < expr.length; ii++) {
            var step = expr[ii];

            // if the first step is an explicit array constructor, then just evaluate that (i.e. don't iterate over a context array)
            if(ii === 0 && step.consarray) {
                resultSequence = yield * evaluate(step, inputSequence, environment);
            } else {
                resultSequence = yield * evaluateStep(step, inputSequence, environment);
            }

            if(typeof resultSequence === 'undefined' || resultSequence.length === 0) {
                break;
            }
            inputSequence = resultSequence;
        }

        return resultSequence;
    }

    /**
     * Normalize a JSONata sequence - singleton arrays become atomic values
     * @param {Array} sequence - input sequence
     * @param {Boolean} keepSingleton - keep singleton sequences as arrays
     * @returns {*} normalized sequence
     */
    function normalizeSequence(sequence, keepSingleton) {
        var result;
        if(typeof sequence === 'undefined') {
            result = undefined;
        } else if(!Array.isArray(sequence)) {
            result = sequence;
        } else if (sequence.length === 1) {
            if(keepSingleton) {
                result = sequence;
            } else {
                result = sequence[0];
            }
        } else if (sequence.length > 1) {
            result = sequence;
        }
        return result;
    }

    /**
     * Evaluate a step within a path
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateStep(expr, input, environment) {
        var result = [];


        for(var ii = 0; ii < input.length; ii++) {
            var res = yield * evaluate(expr, input[ii], environment);
            if (!(Array.isArray(res) && (expr.value !== '[' )) && !expr.consarray) {
                res = [res];
            }
            // is res an array - if so, flatten it into the parent array
            res.forEach(function (innerRes) {
                if (typeof innerRes !== 'undefined') {
                    result.push(innerRes);
                }
            });
        }
        return result;
    }

    /**
     * Apply predicates to input data
     * @param {Object} predicates - Predicates
     * @param {Object} input - Input data to apply predicates against
     * @param {Object} environment - Environment
     * @returns {*} Result after applying predicates
     */
    function* applyPredicates(predicates, input, environment) {
        var inputSequence = input;
        // lhs potentially holds an array
        // we want to iterate over the array, and only keep the items that are
        // truthy when applied to the predicate.
        // if the predicate evaluates to an integer, then select that index

        var results = [];
        for(var ii = 0; ii < predicates.length; ii++) {
            var predicate = predicates[ii];
            // if it's not an array, turn it into one
            // since in XPath >= 2.0 an item is equivalent to a singleton sequence of that item
            // if input is not an array, make it so
            if (!Array.isArray(inputSequence)) {
                inputSequence = [inputSequence];
            }
            results = [];
            if (predicate.type === 'literal' && isNumeric(predicate.value)) {
                var index = predicate.value;
                if (!Number.isInteger(index)) {
                    // round it down
                    index = Math.floor(index);
                }
                if (index < 0) {
                    // count in from end of array
                    index = inputSequence.length + index;
                }
                results = inputSequence[index];
            } else {
                results = yield * evaluateFilter(predicate, inputSequence, environment);
            }
            inputSequence = results;
        }
        return results;
    }

    /**
     * Apply filter predicate to input data
     * @param {Object} predicate - filter expression
     * @param {Object} input - Input data to apply predicates against
     * @param {Object} environment - Environment
     * @returns {*} Result after applying predicates
     */
    function* evaluateFilter(predicate, input, environment) {
        var results = [];
        for(var index = 0; index < input.length; index++) {
            var item = input[index];
            var res = yield * evaluate(predicate, item, environment);
            if (isNumeric(res)) {
                res = [res];
            }
            if(isArrayOfNumbers(res)) {
                res.forEach(function(ires) {
                    if (!Number.isInteger(ires)) {
                        // round it down
                        ires = Math.floor(ires);
                    }
                    if (ires < 0) {
                        // count in from end of array
                        ires = input.length + ires;
                    }
                    if (ires === index) {
                        results.push(item);
                    }
                });
            } else if (functionBoolean(res)) { // truthy
                results.push(item);
            }
        }
        return results;
    }

    /**
     * Evaluate binary expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function * evaluateBinary(expr, input, environment) {
        var result;
        var lhs = yield * evaluate(expr.lhs, input, environment);
        var rhs = yield * evaluate(expr.rhs, input, environment);
        var op = expr.value;

        try {
            switch (op) {
                case '+':
                case '-':
                case '*':
                case '/':
                case '%':
                    result = evaluateNumericExpression(lhs, rhs, op);
                    break;
                case '=':
                case '!=':
                case '<':
                case '<=':
                case '>':
                case '>=':
                    result = evaluateComparisonExpression(lhs, rhs, op);
                    break;
                case '&':
                    result = evaluateStringConcat(lhs, rhs);
                    break;
                case 'and':
                case 'or':
                    result = evaluateBooleanExpression(lhs, rhs, op);
                    break;
                case '..':
                    result = evaluateRangeExpression(lhs, rhs);
                    break;
                case 'in':
                    result = evaluateIncludesExpression(lhs, rhs);
                    break;
            }
        } catch(err) {
            err.position = expr.position;
            err.token = op;
            throw err;
        }
        return result;
    }

    /**
     * Evaluate unary expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateUnary(expr, input, environment) {
        var result;

        switch (expr.value) {
            case '-':
                result = yield * evaluate(expr.expression, input, environment);
                if (isNumeric(result)) {
                    result = -result;
                } else {
                    throw {
                        code: "D1002",
                        stack: (new Error()).stack,
                        position: expr.position,
                        token: expr.value,
                        value: result
                    };
                }
                break;
            case '[':
                // array constructor - evaluate each item
                result = [];
                for(var ii = 0; ii < expr.expressions.length; ii++) {
                    var item = expr.expressions[ii];
                    var value = yield * evaluate(item, input, environment);
                    if (typeof value !== 'undefined') {
                        if(item.value === '[') {
                            result.push(value);
                        } else {
                            result = functionAppend(result, value);
                        }
                    }
                }
                break;
            case '{':
                // object constructor - apply grouping
                result = yield * evaluateGroupExpression(expr, input, environment);
                break;

        }
        return result;
    }

    /**
     * Evaluate name object against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function evaluateName(expr, input, environment) {
        // lookup the 'name' item in the input
        var result;
        if (Array.isArray(input)) {
            result = [];
            for(var ii = 0; ii < input.length; ii++) {
                var res =  evaluateName(expr, input[ii], environment);
                if (typeof res !== 'undefined') {
                    result.push(res);
                }
            }
        } else if (input !== null && typeof input === 'object') {
            result = input[expr.value];
        }
        result = normalizeSequence(result);
        return result;
    }

    /**
     * Evaluate literal against input data
     * @param {Object} expr - JSONata expression
     * @returns {*} Evaluated input data
     */
    function evaluateLiteral(expr) {
        return expr.value;
    }

    /**
     * Evaluate wildcard against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @returns {*} Evaluated input data
     */
    function evaluateWildcard(expr, input) {
        var result;
        var results = [];
        if (input !== null && typeof input === 'object') {
            Object.keys(input).forEach(function (key) {
                var value = input[key];
                if(Array.isArray(value)) {
                    value = flatten(value);
                    results = functionAppend(results, value);
                } else {
                    results.push(value);
                }
            });
        }

        result = normalizeSequence(results);
        return result;
    }

    /**
     * Returns a flattened array
     * @param {Array} arg - the array to be flatten
     * @param {Array} flattened - carries the flattened array - if not defined, will initialize to []
     * @returns {Array} - the flattened array
     */
    function flatten(arg, flattened) {
        if(typeof flattened === 'undefined') {
            flattened = [];
        }
        if(Array.isArray(arg)) {
            arg.forEach(function (item) {
                flatten(item, flattened);
            });
        } else {
            flattened.push(arg);
        }
        return flattened;
    }

    /**
     * Evaluate descendants against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @returns {*} Evaluated input data
     */
    function evaluateDescendants(expr, input) {
        var result;
        var resultSequence = [];
        if (typeof input !== 'undefined') {
            // traverse all descendants of this object/array
            recurseDescendants(input, resultSequence);
            if (resultSequence.length === 1) {
                result = resultSequence[0];
            } else {
                result = resultSequence;
            }
        }
        return result;
    }

    /**
     * Recurse through descendants
     * @param {Object} input - Input data
     * @param {Object} results - Results
     */
    function recurseDescendants(input, results) {
        // this is the equivalent of //* in XPath
        if (!Array.isArray(input)) {
            results.push(input);
        }
        if (Array.isArray(input)) {
            input.forEach(function (member) {
                recurseDescendants(member, results);
            });
        } else if (input !== null && typeof input === 'object') {
            Object.keys(input).forEach(function (key) {
                recurseDescendants(input[key], results);
            });
        }
    }

    /**
     * Evaluate numeric expression against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @param {Object} op - opcode
     * @returns {*} Result
     */
    function evaluateNumericExpression(lhs, rhs, op) {
        var result;

        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {
            // if either side is undefined, the result is undefined
            return result;
        }

        if (!isNumeric(lhs)) {
            throw {
                code: "T2001",
                stack: (new Error()).stack,
                value: lhs
            };
        }
        if (!isNumeric(rhs)) {
            throw {
                code: "T2002",
                stack: (new Error()).stack,
                value: rhs
            };
        }

        switch (op) {
            case '+':
                result = lhs + rhs;
                break;
            case '-':
                result = lhs - rhs;
                break;
            case '*':
                result = lhs * rhs;
                break;
            case '/':
                result = lhs / rhs;
                break;
            case '%':
                result = lhs % rhs;
                break;
        }
        return result;
    }

    /**
     * Evaluate comparison expression against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @param {Object} op - opcode
     * @returns {*} Result
     */
    function evaluateComparisonExpression(lhs, rhs, op) {
        var result;

        // type checks
        var ltype = typeof lhs;
        var rtype = typeof rhs;

        if (ltype === 'undefined' || rtype === 'undefined') {
            // if either side is undefined, the result is false
            return false;
        }

        var validate = function() {
            // if aa or bb are not string or numeric values, then throw an error
            if (!(ltype === 'string' || ltype === 'number') || !(rtype === 'string' || rtype === 'number')) {
                throw {
                    code: "T2010",
                    stack: (new Error()).stack,
                    value: !(ltype === 'string' || ltype === 'number') ? lhs : rhs
                };
            }

            //if aa and bb are not of the same type
            if (ltype !== rtype) {
                throw {
                    code: "T2009",
                    stack: (new Error()).stack,
                    value: lhs,
                    value2: rhs
                };
            }
        };

        switch (op) {
            case '=':
                result = lhs === rhs;
                break;
            case '!=':
                result = (lhs !== rhs);
                break;
            case '<':
                validate();
                result = lhs < rhs;
                break;
            case '<=':
                validate();
                result = lhs <= rhs;
                break;
            case '>':
                validate();
                result = lhs > rhs;
                break;
            case '>=':
                validate();
                result = lhs >= rhs;
                break;
        }
        return result;
    }

    /**
     * Inclusion operator - in
     *
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @returns {boolean} - true if lhs is a member of rhs
     */
    function evaluateIncludesExpression(lhs, rhs) {
        var result = false;

        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {
            // if either side is undefined, the result is false
            return false;
        }

        if(!Array.isArray(rhs)) {
            rhs = [rhs];
        }

        for(var i = 0; i < rhs.length; i++) {
            if(rhs[i] === lhs) {
                result = true;
                break;
            }
        }

        return result;
    }

    /**
     * Evaluate boolean expression against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @param {Object} op - opcode
     * @returns {*} Result
     */
    function evaluateBooleanExpression(lhs, rhs, op) {
        var result;

        switch (op) {
            case 'and':
                result = functionBoolean(lhs) && functionBoolean(rhs);
                break;
            case 'or':
                result = functionBoolean(lhs) || functionBoolean(rhs);
                break;
        }
        return result;
    }

    /**
     * Evaluate string concatenation against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @returns {string|*} Concatenated string
     */
    function evaluateStringConcat(lhs, rhs) {
        var result;

        var lstr = '';
        var rstr = '';
        if (typeof lhs !== 'undefined') {
            lstr = functionString(lhs);
        }
        if (typeof rhs !== 'undefined') {
            rstr = functionString(rhs);
        }

        result = lstr.concat(rstr);
        return result;
    }

    /**
     * Evaluate group expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {{}} Evaluated input data
     */
    function* evaluateGroupExpression(expr, input, environment) {
        var result = {};
        var groups = {};
        // group the input sequence by 'key' expression
        if (!Array.isArray(input)) {
            input = [input];
        }
        for(var itemIndex = 0; itemIndex < input.length; itemIndex++) {
            var item = input[itemIndex];
            for(var pairIndex = 0; pairIndex < expr.lhs.length; pairIndex++) {
                var pair = expr.lhs[pairIndex];
                var key = yield * evaluate(pair[0], item, environment);
                // key has to be a string
                if (typeof  key !== 'string') {
                    throw {
                        code: "T1003",
                        stack: (new Error()).stack,
                        position: expr.position,
                        value: key
                    };
                }
                var entry = {data: item, expr: pair[1]};
                if (groups.hasOwnProperty(key)) {
                    // a value already exists in this slot
                    // append it as an array
                    groups[key].data = functionAppend(groups[key].data, item);
                } else {
                    groups[key] = entry;
                }
            }
        }

        // iterate over the groups to evaluate the 'value' expression
        for (key in groups) {
            entry = groups[key];
            var value = yield * evaluate(entry.expr, entry.data, environment);
            if(typeof value !== 'undefined') {
                result[key] = value;
            }
        }

        return result;
    }

    /**
     * Evaluate range expression against input data
     * @param {Object} lhs - LHS value
     * @param {Object} rhs - RHS value
     * @returns {Array} Resultant array
     */
    function evaluateRangeExpression(lhs, rhs) {
        var result;

        if (typeof lhs === 'undefined' || typeof rhs === 'undefined') {
            // if either side is undefined, the result is undefined
            return result;
        }

        if (lhs > rhs) {
            // if the lhs is greater than the rhs, return undefined
            return result;
        }

        if (!Number.isInteger(lhs)) {
            throw {
                code: "T2003",
                stack: (new Error()).stack,
                value: lhs
            };
        }
        if (!Number.isInteger(rhs)) {
            throw {
                code: "T2004",
                stack: (new Error()).stack,
                value: rhs
            };
        }

        result = new Array(rhs - lhs + 1);
        for (var item = lhs, index = 0; item <= rhs; item++, index++) {
            result[index] = item;
        }
        return result;
    }

    /**
     * Evaluate bind expression against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateBindExpression(expr, input, environment) {
        // The RHS is the expression to evaluate
        // The LHS is the name of the variable to bind to - should be a VARIABLE token
        var value = yield * evaluate(expr.rhs, input, environment);
        if (expr.lhs.type !== 'variable') {
            throw {
                code: "D2005",
                stack: (new Error()).stack,
                position: expr.position,
                token: expr.value,
                value: expr.lhs.type === 'path' ? expr.lhs.steps[0].value : expr.lhs.value
            };
        }
        environment.bind(expr.lhs.value, value);
        return value;
    }

    /**
     * Evaluate condition against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateCondition(expr, input, environment) {
        var result;
        var condition = yield * evaluate(expr.condition, input, environment);
        if (functionBoolean(condition)) {
            result = yield * evaluate(expr.then, input, environment);
        } else if (typeof expr.else !== 'undefined') {
            result = yield * evaluate(expr.else, input, environment);
        }
        return result;
    }

    /**
     * Evaluate block against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateBlock(expr, input, environment) {
        var result;
        // create a new frame to limit the scope of variable assignments
        // TODO, only do this if the post-parse stage has flagged this as required
        var frame = createFrame(environment);
        // invoke each expression in turn
        // only return the result of the last one
        for(var ii = 0; ii < expr.expressions.length; ii++) {
            result = yield * evaluate(expr.expressions[ii], input, frame);
        }

        return result;
    }

    /**
     * Prepare a regex
     * @param {Object} expr - expression containing regex
     * @returns {Function} Higher order function representing prepared regex
     */
    function evaluateRegex(expr) {
        expr.value.lastIndex = 0;
        var closure = function(str) {
            var re = expr.value;
            var result;
            var match = re.exec(str);
            if(match !== null) {
                result = {
                    match: match[0],
                    start: match.index,
                    end: match.index + match[0].length,
                    groups: []
                };
                if(match.length > 1) {
                    for(var i = 1; i < match.length; i++) {
                        result.groups.push(match[i]);
                    }
                }
                result.next = function() {
                    if(re.lastIndex >= str.length) {
                        return undefined;
                    } else {
                        var next = closure(str);
                        if(next && next.match === '' && re.lastIndex === expr.value.lastIndex) {
                            // matches zero length string; this will never progress
                            throw {
                                code: "D1004",
                                stack: (new Error()).stack,
                                position: expr.position,
                                value: expr.value.source
                            };
                        }
                        return next;
                    }
                };
            }

            return result;
        };
        return closure;
    }

    /**
     * Evaluate variable against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function evaluateVariable(expr, input, environment) {
        // lookup the variable value in the environment
        var result;
        // if the variable name is empty string, then it refers to context value
        if (expr.value === '') {
            result = input;
        } else {
            result = environment.lookup(expr.value);
        }
        return result;
    }

    /**
     * sort / order-by operator
     * @param {Object} expr - AST for operator
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Ordered sequence
     */
    function* evaluateSortExpression(expr, input, environment) {
        var result;

        // evaluate the lhs, then sort the results in order according to rhs expression
        var lhs = yield * evaluate(expr.lhs, input, environment);

        // sort the lhs array
        // use comparator function
        var comparator = function(a, b) {
            // expr.rhs is an array of order-by in priority order
            var comp = 0;
            for(var index = 0; comp === 0 && index < expr.rhs.length; index++) {
                var term = expr.rhs[index];
                //evaluate the rhs expression in the context of a
                var aa = driveGenerator(term.expression, a, environment);
                //evaluate the rhs expression in the context of b
                var bb = driveGenerator(term.expression, b, environment);

                // type checks
                var atype = typeof aa;
                var btype = typeof bb;
                // undefined should be last in sort order
                if(atype === 'undefined') {
                    // swap them, unless btype is also undefined
                    comp = (btype === 'undefined') ? 0 : 1;
                    continue;
                }
                if(btype === 'undefined') {
                    comp = -1;
                    continue;
                }

                // if aa or bb are not string or numeric values, then throw an error
                if(!(atype === 'string' || atype === 'number') || !(btype === 'string' || btype === 'number')) {
                    throw {
                        code: "T2008",
                        stack: (new Error()).stack,
                        position: expr.position,
                        value: !(atype === 'string' || atype === 'number') ? aa : bb
                    };
                }

                //if aa and bb are not of the same type
                if(atype !== btype) {
                    throw {
                        code: "T2007",
                        stack: (new Error()).stack,
                        position: expr.position,
                        value: aa,
                        value2: bb
                    };
                }
                if(aa === bb) {
                    // both the same - move on to next term
                    continue;
                } else if (aa < bb) {
                    comp = -1;
                } else {
                    comp = 1;
                }
                if(term.descending === true) {
                    comp = -comp;
                }
            }
            // only swap a & b if comp equals 1
            return comp === 1;
        };

        result = functionSort(lhs, comparator);

        return result;
    }

    /**
     * create a transformer function
     * @param {Object} expr - AST for operator
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} tranformer function
     */
    function evaluateTransformExpression(expr, input, environment) {
        // create a function to implement the transform definition
        var transformer = function*(obj) { // signature <(oa):o>
            // undefined inputs always return undefined
            if(typeof obj === 'undefined') {
                return undefined;
            }

            // this function returns a copy of obj with changes specified by the pattern/operation
            var cloneFunction = environment.lookup('clone');
            if(!isFunction(cloneFunction)) {
                // throw type error
                throw {
                    code: "T2013",
                    stack: (new Error()).stack,
                    position: expr.position
                };
            }
            var result = yield * apply(cloneFunction, [obj], environment);
            var matches = yield * evaluate(expr.pattern, result, environment);
            if(typeof matches !== 'undefined') {
                if(!Array.isArray(matches)) {
                    matches = [matches];
                }
                for(var ii = 0; ii < matches.length; ii++) {
                    var match = matches[ii];
                    // evaluate the update value for each match
                    var update = yield * evaluate(expr.update, match, environment);
                    // update must be an object
                    var updateType = typeof update;
                    if(updateType !== 'undefined') {
                        if(updateType !== 'object' || update === null) {
                            // throw type error
                            throw {
                                code: "T2011",
                                stack: (new Error()).stack,
                                position: expr.update.position,
                                value: update
                            };
                        }
                        // merge the update
                        for(var prop in update) {
                            match[prop] = update[prop];
                        }
                    }

                    // delete, if specified, must be an array of strings (or single string)
                    if(typeof expr.delete !== 'undefined') {
                        var deletions = yield * evaluate(expr.delete, match, environment);
                        if(typeof deletions !== 'undefined') {
                            var val = deletions;
                            if (!Array.isArray(deletions)) {
                                deletions = [deletions];
                            }
                            if (!isArrayOfStrings(deletions)) {
                                // throw type error
                                throw {
                                    code: "T2012",
                                    stack: (new Error()).stack,
                                    position: expr.delete.position,
                                    value: val
                                };
                            }
                            for (var jj = 0; jj < deletions.length; jj++) {
                                delete match[deletions[jj]];
                            }
                        }
                    }
                }
            }

            return result;
        };

        return defineFunction(transformer, '<(oa):o>');
    }

    /**
     * Evaluate an expression by driving the generator to completion
     * Used when it's not possible to yield
     * @param {Object} expr - AST
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} result
     */
    function driveGenerator(expr, input, environment) {
        var gen = evaluate(expr, input, environment);
        // returns a generator - so iterate over it
        var comp = gen.next();
        while (!comp.done) {
            comp = gen.next(comp.value);
        }
        return comp.value;
    }

    var chain = driveGenerator(parser('function($f, $g) { function($x){ $g($f($x)) } }'), null, staticFrame);

    /**
     * Apply the function on the RHS using the sequence on the LHS as the first argument
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluateApplyExpression(expr, input, environment) {
        var result;


        if(expr.rhs.type === 'function') {
            // this is a function _invocation_; invoke it with lhs expression as the first argument
            expr.rhs.arguments.unshift(expr.lhs);
            result = yield * evaluateFunction(expr.rhs, input, environment);
            expr.rhs.arguments.shift();
        } else {
            var lhs = yield * evaluate(expr.lhs, input, environment);
            var func = yield * evaluate(expr.rhs, input, environment);

            if(!isFunction(func)) {
                throw {
                    code: "T2006",
                    stack: (new Error()).stack,
                    position: expr.position,
                    value: func
                };
            }

            if(isFunction(lhs)) {
                // this is function chaining (func1 ~> func2)
                // λ($f, $g) { λ($x){ $g($f($x)) } }
                result = yield * apply(chain, [lhs, func], environment, null);
            } else {
                result = yield * apply(func, [lhs], environment, null);
            }

        }

        return result;
    }

    /**
     *
     * @param {Object} arg - expression to test
     * @returns {boolean} - true if it is a function (lambda or built-in)
     */
    function isFunction(arg) {
        return ((arg && (arg._jsonata_function === true || arg._jsonata_lambda === true)) || typeof arg === 'function');
    }

    /**
     * Tests whether arg is a lambda function
     * @param {*} arg - the value to test
     * @returns {boolean} - true if it is a lambda function
     */
    function isLambda(arg) {
        return arg && arg._jsonata_lambda === true;
    }

    /**
     * @param {Object} arg - expression to test
     * @returns {boolean} - true if it is a generator i.e. the result from calling a
     * generator function
     */
    function isGenerator(arg) {
        return (
            typeof arg === 'object' &&
            arg !== null &&
            Symbol.iterator in arg &&
            typeof arg[Symbol.iterator] === 'function' &&
            'next' in arg &&
            typeof arg.next === 'function'
        );
    }

    /**
     * Evaluate function against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @param {Object} [applyto] - LHS of ~> operator
     * @returns {*} Evaluated input data
     */
    function* evaluateFunction(expr, input, environment) {
        var result;

        // create the procedure
        // can't assume that expr.procedure is a lambda type directly
        // could be an expression that evaluates to a function (e.g. variable reference, parens expr etc.
        // evaluate it generically first, then check that it is a function.  Throw error if not.
        var proc = yield * evaluate(expr.procedure, input, environment);

        if (typeof proc === 'undefined' && expr.procedure.type === 'path' && environment.lookup(expr.procedure.steps[0].value)) {
            // help the user out here if they simply forgot the leading $
            throw {
                code: "T1005",
                stack: (new Error()).stack,
                position: expr.position,
                token: expr.procedure.steps[0].value
            };
        }

        var evaluatedArgs = [];
        // eager evaluation - evaluate the arguments
        for (var jj = 0; jj < expr.arguments.length; jj++) {
            // only evaluate 'eager' arguments at this stage; wrap the 'lazy' ones in a closure
            evaluatedArgs.push(yield* evaluate(expr.arguments[jj], input, environment));
        }
        // apply the procedure
        try {
            // if(input instanceof Object) {
            //     Object.defineProperty(input, '__env__', {
            //         enumerable: false,
            //         configurable: true,
            //         get: function () {
            //             return environment;
            //         }
            //     });
            // }
            result = yield * apply(proc, evaluatedArgs, input);
        } catch (err) {
            // add the position field to the error
            err.position = expr.position;
            // and the function identifier
            err.token = expr.procedure.type === 'path' ? expr.procedure.steps[0].value : expr.procedure.value;
            throw err;
        }
        return result;
    }

    /**
     * Apply procedure or function
     * @param {Object} proc - Procedure
     * @param {Array} args - Arguments
     * @param {Object} self - Self
     * @returns {*} Result of procedure
     */
    function* apply(proc, args, self) {
        var result;
        result = yield * applyInner(proc, args, self);
        while(isLambda(result) && result.thunk === true) {
            // trampoline loop - this gets invoked as a result of tail-call optimization
            // the function returned a tail-call thunk
            // unpack it, evaluate its arguments, and apply the tail call
            var next = yield * evaluate(result.body.procedure, result.input, result.environment);
            var evaluatedArgs = [];
            for(var ii = 0; ii < result.body.arguments.length; ii++) {
                evaluatedArgs.push(yield * evaluate(result.body.arguments[ii], result.input, result.environment));
            }

            result = yield * applyInner(next, evaluatedArgs, self);
        }
        return result;
    }

    /**
     * Apply procedure or function
     * @param {Object} proc - Procedure
     * @param {Array} args - Arguments
     * @param {Object} self - Self
     * @returns {*} Result of procedure
     */
    function* applyInner(proc, args, self) {
        var result;
        var validatedArgs = args;
        if(proc) {
            validatedArgs = validateArguments(proc.signature, args, self);
        }
        if (isLambda(proc)) {
            result = yield * applyProcedure(proc, validatedArgs);
        } else if (proc && proc._jsonata_function === true) {
            result = proc.implementation.apply(self, validatedArgs);
            // `proc.implementation` might be a generator function
            // and `result` might be a generator - if so, yield
            if(isGenerator(result)) {
                result = yield *result;
            }
        } else if (typeof proc === 'function') {
            result = proc.apply(self, validatedArgs);
            /* istanbul ignore next */
            if(isGenerator(result)) {
                result = yield *result;
            }
        } else {
            throw {
                code: "T1006",
                stack: (new Error()).stack
            };
        }
        return result;
    }

    /**
     * Evaluate lambda against input data
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {{lambda: boolean, input: *, environment: *, arguments: *, body: *}} Evaluated input data
     */
    function evaluateLambda(expr, input, environment) {
        // make a function (closure)
        var procedure = {
            _jsonata_lambda: true,
            input: input,
            environment: environment,
            arguments: expr.arguments,
            signature: expr.signature,
            body: expr.body
        };
        if(expr.thunk === true) {
            procedure.thunk = true;
        }
        return procedure;
    }

    /**
     * Evaluate partial application
     * @param {Object} expr - JSONata expression
     * @param {Object} input - Input data to evaluate against
     * @param {Object} environment - Environment
     * @returns {*} Evaluated input data
     */
    function* evaluatePartialApplication(expr, input, environment) {
        // partially apply a function
        var result;
        // evaluate the arguments
        var evaluatedArgs = [];
        for(var ii = 0; ii < expr.arguments.length; ii++) {
            var arg = expr.arguments[ii];
            if (arg.type === 'operator' && arg.value === '?') {
                evaluatedArgs.push(arg);
            } else {
                evaluatedArgs.push(yield * evaluate(arg, input, environment));
            }
        }
        // lookup the procedure
        var proc = yield * evaluate(expr.procedure, input, environment);
        if (typeof proc === 'undefined' && expr.procedure.type === 'path' && environment.lookup(expr.procedure.steps[0].value)) {
            // help the user out here if they simply forgot the leading $
            throw {
                code: "T1007",
                stack: (new Error()).stack,
                position: expr.position,
                token: expr.procedure.steps[0].value
            };
        }
        if (isLambda(proc)) {
            result = partialApplyProcedure(proc, evaluatedArgs);
        } else if (proc && proc._jsonata_function === true) {
            result = partialApplyNativeFunction(proc.implementation, evaluatedArgs);
        } else if (typeof proc === 'function') {
            result = partialApplyNativeFunction(proc, evaluatedArgs);
        } else {
            throw {
                code: "T1008",
                stack: (new Error()).stack,
                position: expr.position,
                token: expr.procedure.type === 'path' ? expr.procedure.steps[0].value : expr.procedure.value
            };
        }
        return result;
    }

    /**
     * Validate the arguments against the signature validator (if it exists)
     * @param {Function} signature - validator function
     * @param {Array} args - function arguments
     * @param {*} context - context value
     * @returns {Array} - validated arguments
     */
    function validateArguments(signature, args, context) {
        if(typeof signature === 'undefined') {
            // nothing to validate
            return args;
        }
        var validatedArgs = signature.validate(args, context);
        return validatedArgs;
    }

    /**
     * Apply procedure
     * @param {Object} proc - Procedure
     * @param {Array} args - Arguments
     * @returns {*} Result of procedure
     */
    function* applyProcedure(proc, args) {
        var result;
        var env = createFrame(proc.environment);
        proc.arguments.forEach(function (param, index) {
            env.bind(param.value, args[index]);
        });
        if (typeof proc.body === 'function') {
            // this is a lambda that wraps a native function - generated by partially evaluating a native
            result = yield * applyNativeFunction(proc.body, env);
        } else {
            result = yield * evaluate(proc.body, proc.input, env);
        }
        return result;
    }

    /**
     * Partially apply procedure
     * @param {Object} proc - Procedure
     * @param {Array} args - Arguments
     * @returns {{lambda: boolean, input: *, environment: {bind, lookup}, arguments: Array, body: *}} Result of partially applied procedure
     */
    function partialApplyProcedure(proc, args) {
        // create a closure, bind the supplied parameters and return a function that takes the remaining (?) parameters
        var env = createFrame(proc.environment);
        var unboundArgs = [];
        proc.arguments.forEach(function (param, index) {
            var arg = args[index];
            if (arg && arg.type === 'operator' && arg.value === '?') {
                unboundArgs.push(param);
            } else {
                env.bind(param.value, arg);
            }
        });
        var procedure = {
            _jsonata_lambda: true,
            input: proc.input,
            environment: env,
            arguments: unboundArgs,
            body: proc.body
        };
        return procedure;
    }

    /**
     * Partially apply native function
     * @param {Function} native - Native function
     * @param {Array} args - Arguments
     * @returns {{lambda: boolean, input: *, environment: {bind, lookup}, arguments: Array, body: *}} Result of partially applying native function
     */
    function partialApplyNativeFunction(native, args) {
        // create a lambda function that wraps and invokes the native function
        // get the list of declared arguments from the native function
        // this has to be picked out from the toString() value
        var sigArgs = getNativeFunctionArguments(native);
        sigArgs = sigArgs.map(function (sigArg) {
            return '$' + sigArg.trim();
        });
        var body = 'function(' + sigArgs.join(', ') + '){ _ }';

        var bodyAST = parser(body);
        bodyAST.body = native;

        var partial = partialApplyProcedure(bodyAST, args);
        return partial;
    }

    /**
     * Apply native function
     * @param {Object} proc - Procedure
     * @param {Object} env - Environment
     * @returns {*} Result of applying native function
     */
    function* applyNativeFunction(proc, env) {
        var sigArgs = getNativeFunctionArguments(proc);
        // generate the array of arguments for invoking the function - look them up in the environment
        var args = sigArgs.map(function (sigArg) {
            return env.lookup(sigArg.trim());
        });

        var result = proc.apply(null, args);
        if(isGenerator(result)) {
            result = yield * result;
        }
        return result;
    }

    /**
     * Get native function arguments
     * @param {Function} func - Function
     * @returns {*|Array} Native function arguments
     */
    function getNativeFunctionArguments(func) {
        var signature = func.toString();
        var sigParens = /\(([^)]*)\)/.exec(signature)[1]; // the contents of the parens
        var sigArgs = sigParens.split(',');
        return sigArgs;
    }

    /**
     * Creates a function definition
     * @param {Function} func - function implementation in Javascript
     * @param {string} signature - JSONata function signature definition
     * @returns {{implementation: *, signature: *}} function definition
     */
    function defineFunction(func, signature) {
        var definition = {
            _jsonata_function: true,
            implementation: func
        };
        if(typeof signature !== 'undefined') {
            definition.signature = parseSignature(signature);
        }
        return definition;
    }

    /**
     * Sum function
     * @param {Object} args - Arguments
     * @returns {number} Total value of arguments
     */
    function functionSum(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined') {
            return undefined;
        }

        var total = 0;
        args.forEach(function(num){total += num;});
        return total;
    }

    /**
     * Count function
     * @param {Object} args - Arguments
     * @returns {number} Number of elements in the array
     */
    function functionCount(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined') {
            return 0;
        }

        return args.length;
    }

    /**
     * Max function
     * @param {Object} args - Arguments
     * @returns {number} Max element in the array
     */
    function functionMax(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined' || args.length === 0) {
            return undefined;
        }

        return Math.max.apply(Math, args);
    }

    /**
     * Min function
     * @param {Object} args - Arguments
     * @returns {number} Min element in the array
     */
    function functionMin(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined' || args.length === 0) {
            return undefined;
        }

        return Math.min.apply(Math, args);
    }

    /**
     * Average function
     * @param {Object} args - Arguments
     * @returns {number} Average element in the array
     */
    function functionAverage(args) {
        // undefined inputs always return undefined
        if(typeof args === 'undefined' || args.length === 0) {
            return undefined;
        }

        var total = 0;
        args.forEach(function(num){total += num;});
        return total/args.length;
    }

    /**
     * Stingify arguments
     * @param {Object} arg - Arguments
     * @returns {String} String from arguments
     */
    function functionString(arg) {
        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        var str;

        if (typeof arg === 'string') {
            // already a string
            str = arg;
        } else if(isFunction(arg)) {
            // functions (built-in and lambda convert to empty string
            str = '';
        } else if (typeof arg === 'number' && !isFinite(arg)) {
            throw {
                code: "D3001",
                value: arg,
                stack: (new Error()).stack
            };
        } else
            str = JSON.stringify(arg, function (key, val) {
                return (typeof val !== 'undefined' && val !== null && val.toPrecision && isNumeric(val)) ? Number(val.toPrecision(13)) :
                    (val && isFunction(val)) ? '' : val;
            });
        return str;
    }

    /**
     * Create substring based on character number and length
     * @param {String} str - String to evaluate
     * @param {Integer} start - Character number to start substring
     * @param {Integer} [length] - Number of characters in substring
     * @returns {string|*} Substring
     */
    function functionSubstring(str, start, length) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        return str.substr(start, length);
    }

    /**
     * Create substring up until a character
     * @param {String} str - String to evaluate
     * @param {String} chars - Character to define substring boundary
     * @returns {*} Substring
     */
    function functionSubstringBefore(str, chars) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        var pos = str.indexOf(chars);
        if (pos > -1) {
            return str.substr(0, pos);
        } else {
            return str;
        }
    }

    /**
     * Create substring after a character
     * @param {String} str - String to evaluate
     * @param {String} chars - Character to define substring boundary
     * @returns {*} Substring
     */
    function functionSubstringAfter(str, chars) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        var pos = str.indexOf(chars);
        if (pos > -1) {
            return str.substr(pos + chars.length);
        } else {
            return str;
        }
    }

    /**
     * Lowercase a string
     * @param {String} str - String to evaluate
     * @returns {string} Lowercase string
     */
    function functionLowercase(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        return str.toLowerCase();
    }

    /**
     * Uppercase a string
     * @param {String} str - String to evaluate
     * @returns {string} Uppercase string
     */
    function functionUppercase(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        return str.toUpperCase();
    }

    /**
     * length of a string
     * @param {String} str - string
     * @returns {Number} The number of characters in the string
     */
    function functionLength(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        return str.length;
    }

    /**
     * Normalize and trim whitespace within a string
     * @param {string} str - string to be trimmed
     * @returns {string} - trimmed string
     */
    function functionTrim(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        // normalize whitespace
        var result = str.replace(/[ \t\n\r]+/gm, ' ');
        if(result.charAt(0) === ' ') {
            // strip leading space
            result = result.substring(1);
        }
        if(result.charAt(result.length - 1) === ' ') {
            // strip trailing space
            result = result.substring(0, result.length - 1);
        }
        return result;
    }

    /**
     * Pad a string to a minimum width by adding characters to the start or end
     * @param {string} str - string to be padded
     * @param {number} width - the minimum width; +ve pads to the right, -ve pads to the left
     * @param {string} [char] - the pad character(s); defaults to ' '
     * @returns {string} - padded string
     */
    function functionPad(str, width, char) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        if(typeof char === 'undefined' || char.length === 0) {
            char = ' ';
        }

        var result;
        var padLength = Math.abs(width) - str.length;
        if(padLength > 0) {
            var padding = (new Array(padLength + 1)).join(char);
            if(char.length > 1) {
                padding = padding.substring(0, padLength);
            }
            if(width > 0) {
                result = str + padding;
            } else {
                result = padding + str;
            }
        } else {
            result = str;
        }
        return result;
    }

    /**
     * Tests if the str contains the token
     * @param {String} str - string to test
     * @param {String} token - substring or regex to find
     * @returns {Boolean} - true if str contains token
     */
    function functionContains(str, token) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        var result;

        if(typeof token === 'string') {
            result = (str.indexOf(token) !== -1);
        } else {
            var matches = token(str);
            result = (typeof matches !== 'undefined');
        }

        return result;
    }

    /**
     * Match a string with a regex returning an array of object containing details of each match
     * @param {String} str - string
     * @param {String} regex - the regex applied to the string
     * @param {Integer} [limit] - max number of matches to return
     * @returns {Array} The array of match objects
     */
    function functionMatch(str, regex, limit) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        // limit, if specified, must be a non-negative number
        if(limit < 0) {
            throw {
                stack: (new Error()).stack,
                value: limit,
                code: 'D3040',
                index: 3
            };
        }

        var result = [];

        if(typeof limit === 'undefined' || limit > 0) {
            var count = 0;
            var matches = regex(str);
            if (typeof matches !== 'undefined') {
                while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {
                    result.push({
                        match: matches.match,
                        index: matches.start,
                        groups: matches.groups
                    });
                    matches = matches.next();
                    count++;
                }
            }
        }

        return result;
    }

    /**
     * Match a string with a regex returning an array of object containing details of each match
     * @param {String} str - string
     * @param {String} pattern - the substring/regex applied to the string
     * @param {String} replacement - text to replace the matched substrings
     * @param {Integer} [limit] - max number of matches to return
     * @returns {Array} The array of match objects
     */
    function* functionReplace(str, pattern, replacement, limit) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        // pattern cannot be an empty string
        if(pattern === '') {
            throw {
                code: "D3010",
                stack: (new Error()).stack,
                value: pattern,
                index: 2
            };
        }

        // limit, if specified, must be a non-negative number
        if(limit < 0) {
            throw {
                code: "D3011",
                stack: (new Error()).stack,
                value: limit,
                index: 4
            };
        }

        var replacer;
        if(typeof replacement === 'string') {
            replacer = function (regexMatch) {
                var substitute = '';
                // scan forward, copying the replacement text into the substitute string
                // and replace any occurrence of $n with the values matched by the regex
                var position = 0;
                var index = replacement.indexOf('$', position);
                while (index !== -1 && position < replacement.length) {
                    substitute += replacement.substring(position, index);
                    position = index + 1;
                    var dollarVal = replacement.charAt(position);
                    if (dollarVal === '$') {
                        // literal $
                        substitute += '$';
                        position++;
                    } else if (dollarVal === '0') {
                        substitute += regexMatch.match;
                        position++;
                    } else {
                        var maxDigits;
                        if(regexMatch.groups.length === 0) {
                            // no sub-matches; any $ followed by a digit will be replaced by an empty string
                            maxDigits = 1;
                        } else {
                            // max number of digits to parse following the $
                            maxDigits = Math.floor(Math.log(regexMatch.groups.length) * Math.LOG10E) + 1;
                        }
                        index = parseInt(replacement.substring(position, position + maxDigits), 10);
                        if(maxDigits > 1 && index > regexMatch.groups.length) {
                            index = parseInt(replacement.substring(position, position + maxDigits - 1), 10);
                        }
                        if (!isNaN(index)) {
                            if(regexMatch.groups.length > 0 ) {
                                var submatch = regexMatch.groups[index - 1];
                                if (typeof submatch !== 'undefined') {
                                    substitute += submatch;
                                }
                            }
                            position += index.toString().length;
                        } else {
                            // not a capture group, treat the $ as literal
                            substitute += '$';
                        }
                    }
                    index = replacement.indexOf('$', position);
                }
                substitute += replacement.substring(position);
                return substitute;
            };
        } else {
            replacer = replacement;
        }

        var result = '';
        var position = 0;

        if(typeof limit === 'undefined' || limit > 0) {
            var count = 0;
            if(typeof pattern === 'string') {
                var index = str.indexOf(pattern, position);
                while(index !== -1 && (typeof limit === 'undefined' || count < limit)) {
                    result += str.substring(position, index);
                    result += replacement;
                    position = index + pattern.length;
                    count++;
                    index = str.indexOf(pattern, position);
                }
                result += str.substring(position);
            } else {
                var matches = pattern(str);
                if (typeof matches !== 'undefined') {
                    while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {
                        result += str.substring(position, matches.start);
                        var replacedWith = yield * apply(replacer, [matches], null);
                        // check replacedWith is a string
                        if(typeof replacedWith === 'string') {
                            result += replacedWith;
                        } else {
                            // not a string - throw error
                            throw {
                                code: "D3012",
                                stack: (new Error()).stack,
                                value: replacedWith
                            };
                        }
                        position = matches.start + matches.match.length;
                        count++;
                        matches = matches.next();
                    }
                    result += str.substring(position);
                } else {
                    result = str;
                }
            }
        } else {
            result = str;
        }

        return result;
    }

    /**
     * Base64 encode a string
     * @param {String} str - string
     * @returns {String} Base 64 encoding of the binary data
     */
    function functionBase64encode(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }
        // Use btoa in a browser, or Buffer in Node.js

        var btoa = typeof window !== 'undefined' ?
            /* istanbul ignore next */ window.btoa :
            function(str) {
                // Simply doing `new Buffer` at this point causes Browserify to pull
                // in the entire Buffer browser library, which is large and unnecessary.
                // Using `global.Buffer` defeats this.
                return new global.Buffer(str, 'binary').toString('base64');
            };
        return btoa(str);
    }

    /**
     * Base64 decode a string
     * @param {String} str - string
     * @returns {String} Base 64 encoding of the binary data
     */
    function functionBase64decode(str) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }
        // Use btoa in a browser, or Buffer in Node.js
        var atob = typeof window !== 'undefined' ?
            /* istanbul ignore next */ window.atob :
            function(str) {
                // Simply doing `new Buffer` at this point causes Browserify to pull
                // in the entire Buffer browser library, which is large and unnecessary.
                // Using `global.Buffer` defeats this.
                return new global.Buffer(str, 'base64').toString('binary');
            };
        return atob(str);
    }

    /**
     * Split a string into an array of substrings
     * @param {String} str - string
     * @param {String} separator - the token or regex that splits the string
     * @param {Integer} [limit] - max number of substrings
     * @returns {Array} The array of string
     */
    function functionSplit(str, separator, limit) {
        // undefined inputs always return undefined
        if(typeof str === 'undefined') {
            return undefined;
        }

        // limit, if specified, must be a non-negative number
        if(limit < 0) {
            throw {
                code: "D3020",
                stack: (new Error()).stack,
                value: limit,
                index: 3
            };
        }

        var result = [];

        if(typeof limit === 'undefined' || limit > 0) {
            if (typeof separator === 'string') {
                result = str.split(separator, limit);
            } else {
                var count = 0;
                var matches = separator(str);
                if (typeof matches !== 'undefined') {
                    var start = 0;
                    while (typeof matches !== 'undefined' && (typeof limit === 'undefined' || count < limit)) {
                        result.push(str.substring(start, matches.start));
                        start = matches.end;
                        matches = matches.next();
                        count++;
                    }
                    if(typeof limit === 'undefined' || count < limit) {
                        result.push(str.substring(start));
                    }
                } else {
                    result = [str];
                }
            }
        }

        return result;
    }

    /**
     * Join an array of strings
     * @param {Array} strs - array of string
     * @param {String} [separator] - the token that splits the string
     * @returns {String} The concatenated string
     */
    function functionJoin(strs, separator) {
        // undefined inputs always return undefined
        if(typeof strs === 'undefined') {
            return undefined;
        }

        // if separator is not specified, default to empty string
        if(typeof separator === 'undefined') {
            separator = "";
        }

        return strs.join(separator);
    }

    /**
     * Formats a number into a decimal string representation using XPath 3.1 F&O fn:format-number spec
     * @param {number} value - number to format
     * @param {String} picture - picture string definition
     * @param {Object} [options] - override locale defaults
     * @returns {String} The formatted string
     */
    function functionFormatNumber(value, picture, options) {
        var defaults = {
            "decimal-separator": ".",
            "grouping-separator": ",",
            "exponent-separator": "e",
            "infinity": "Infinity",
            "minus-sign": "-",
            "NaN": "NaN",
            "percent": "%",
            "per-mille": "\u2030",
            "zero-digit": "0",
            "digit": "#",
            "pattern-separator": ";"
        };

        // if `options` is specified, then its entries override defaults
        var properties = defaults;
        if(typeof options !== 'undefined') {
            Object.keys(options).forEach(function (key) {
                properties[key] = options[key];
            });
        }

        var decimalDigitFamily = [];
        var zeroCharCode = properties['zero-digit'].charCodeAt(0);
        for(var ii = zeroCharCode; ii < zeroCharCode + 10; ii++) {
            decimalDigitFamily.push(String.fromCharCode(ii));
        }

        var activeChars = decimalDigitFamily.concat([properties['decimal-separator'], properties['exponent-separator'], properties['grouping-separator'], properties.digit, properties['pattern-separator']]);

        var subPictures = picture.split(properties['pattern-separator']);

        if(subPictures.length > 2) {
            throw {
                code: 'D3080',
                stack: (new Error()).stack
            };
        }

        var splitParts = function(subpicture) {
            var prefix = (function() {
                var ch;
                for(var ii = 0; ii < subpicture.length; ii++) {
                    ch = subpicture.charAt(ii);
                    if(activeChars.indexOf(ch) !== -1 && ch !== properties['exponent-separator']) {
                        return subpicture.substring(0, ii);
                    }
                }
            })();
            var suffix = (function() {
                var ch;
                for(var ii = subpicture.length - 1; ii >= 0; ii--) {
                    ch = subpicture.charAt(ii);
                    if(activeChars.indexOf(ch) !== -1 && ch !== properties['exponent-separator']) {
                        return subpicture.substring(ii + 1);
                    }
                }
            })();
            var activePart = subpicture.substring(prefix.length, subpicture.length - suffix.length);
            var mantissaPart, exponentPart, integerPart, fractionalPart;
            var exponentPosition = subpicture.indexOf(properties['exponent-separator'], prefix.length);
            if(exponentPosition === -1 || exponentPosition > subpicture.length - suffix.length) {
                mantissaPart = activePart;
                exponentPart = undefined;
            } else {
                mantissaPart = activePart.substring(0, exponentPosition);
                exponentPart = activePart.substring(exponentPosition + 1);
            }
            var decimalPosition = mantissaPart.indexOf(properties['decimal-separator']);
            if(decimalPosition === -1) {
                integerPart = mantissaPart;
                fractionalPart = suffix;
            } else {
                integerPart = mantissaPart.substring(0, decimalPosition);
                fractionalPart = mantissaPart.substring(decimalPosition + 1);
            }
            return {
                prefix: prefix,
                suffix: suffix,
                activePart: activePart,
                mantissaPart: mantissaPart,
                exponentPart: exponentPart,
                integerPart: integerPart,
                fractionalPart: fractionalPart,
                subpicture: subpicture
            };
        };

        // validate the picture string, F&O 4.7.3
        var validate = function(parts) {
            var error;
            var ii;
            var subpicture = parts.subpicture;
            var decimalPos = subpicture.indexOf(properties['decimal-separator']);
            if(decimalPos !== subpicture.lastIndexOf(properties['decimal-separator'])) {
                error = 'D3081';
            }
            if(subpicture.indexOf(properties.percent) !== subpicture.lastIndexOf(properties.percent)) {
                error = 'D3082';
            }
            if(subpicture.indexOf(properties['per-mille']) !== subpicture.lastIndexOf(properties['per-mille'])) {
                error = 'D3083';
            }
            if(subpicture.indexOf(properties.percent) !== -1 && subpicture.indexOf(properties['per-mille']) !== -1) {
                error = 'D3084';
            }
            var valid = false;
            for(ii = 0; ii < parts.mantissaPart.length; ii++) {
                var ch = parts.mantissaPart.charAt(ii);
                if(decimalDigitFamily.indexOf(ch) !== -1 || ch === properties.digit) {
                    valid = true;
                    break;
                }
            }
            if(!valid) {
                error = 'D3085';
            }
            var charTypes = parts.activePart.split('').map(function(char) {
                return activeChars.indexOf(char) === -1 ? 'p' : 'a';
            }).join('');
            if(charTypes.indexOf('p') !== -1) {
                error = 'D3086';
            }
            if(decimalPos !== -1) {
                if(subpicture.charAt(decimalPos - 1) === properties['grouping-separator'] || subpicture.charAt(decimalPos + 1) === properties['grouping-separator']) {
                    error = 'D3087';
                }
            } else if(parts.integerPart.charAt(parts.integerPart.length - 1) === properties['grouping-separator']) {
                error = 'D3088';
            }
            if(subpicture.indexOf(properties['grouping-separator'] + properties['grouping-separator']) !== -1) {
                error = 'D3089';
            }
            var optionalDigitPos = parts.integerPart.indexOf(properties.digit);
            if(optionalDigitPos !== -1 && parts.integerPart.substring(0, optionalDigitPos).split('').filter(function(char) {
                return decimalDigitFamily.indexOf(char) > -1;
            }).length > 0) {
                error = 'D3090';
            }
            optionalDigitPos = parts.fractionalPart.lastIndexOf(properties.digit);
            if(optionalDigitPos !== -1 && parts.fractionalPart.substring(optionalDigitPos).split('').filter(function(char) {
                return decimalDigitFamily.indexOf(char) > -1;
            }).length > 0) {
                error = 'D3091';
            }
            var exponentExists = (typeof parts.exponentPart === 'string');
            if(exponentExists && parts.exponentPart.length > 0 && (subpicture.indexOf(properties.percent) !== -1 || subpicture.indexOf(properties['per-mille']) !== -1)) {
                error = 'D3092';
            }
            if(exponentExists && (parts.exponentPart.length === 0 || parts.exponentPart.split('').filter(function(char) {
                return decimalDigitFamily.indexOf(char) === -1;
            }).length > 0)) {
                error = 'D3093';
            }
            if(error) {
                throw {
                    code: error,
                    stack: (new Error()).stack
                };
            }
        };

        // analyse the picture string, F&O 4.7.4
        var analyse = function(parts) {
            var getGroupingPositions = function(part, toLeft) {
                var positions = [];
                var groupingPosition = part.indexOf(properties['grouping-separator']);
                while(groupingPosition !== -1) {
                    var charsToTheRight = (toLeft ? part.substring(0, groupingPosition) : part.substring(groupingPosition)).split('').filter(function(char) {
                        return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit;
                    }).length;
                    positions.push(charsToTheRight);
                    groupingPosition = parts.integerPart.indexOf(properties['grouping-separator'], groupingPosition + 1);
                }
                return positions;
            };
            var integerPartGroupingPositions = getGroupingPositions(parts.integerPart);
            var regular = function(indexes) {
                // are the grouping positions regular? i.e. same interval between each of them
                if(indexes.length === 0) {
                    return 0;
                }
                var gcd = function(a, b) {
                    return b === 0 ? a : gcd(b, a % b);
                };
                // find the greatest common divisor of all the positions
                var factor = indexes.reduce(gcd);
                // is every position separated by this divisor? If so, it's regular
                for(var index = 1; index <= indexes.length; index++) {
                    if(indexes.indexOf(index * factor) === -1) {
                        return 0;
                    }
                }
                return factor;
            };

            var regularGrouping = regular(integerPartGroupingPositions);
            var fractionalPartGroupingPositions = getGroupingPositions(parts.fractionalPart, true);

            var minimumIntegerPartSize = parts.integerPart.split('').filter(function(char) { return decimalDigitFamily.indexOf(char) !== -1; }).length;
            var scalingFactor = minimumIntegerPartSize;

            var fractionalPartArray = parts.fractionalPart.split('');
            var minimumFactionalPartSize = fractionalPartArray.filter(function(char) { return decimalDigitFamily.indexOf(char) !== -1; }).length;
            var maximumFactionalPartSize = fractionalPartArray.filter(function(char) { return decimalDigitFamily.indexOf(char) !== -1 || char === properties.digit; }).length;
            var exponentPresent = typeof parts.exponentPart === 'string';
            if(minimumIntegerPartSize === 0 && maximumFactionalPartSize === 0) {
                if(exponentPresent) {
                    minimumFactionalPartSize = 1;
                    maximumFactionalPartSize = 1;
                } else {
                    minimumIntegerPartSize = 1;
                }
            }
            if(exponentPresent && minimumIntegerPartSize === 0 && parts.integerPart.indexOf(properties.digit) !== -1) {
                minimumIntegerPartSize = 1;
            }
            if(minimumIntegerPartSize === 0 && minimumFactionalPartSize === 0) {
                minimumFactionalPartSize = 1;
            }
            var minimumExponentSize = 0;
            if(exponentPresent) {
                minimumExponentSize = parts.exponentPart.split('').filter(function(char) { return decimalDigitFamily.indexOf(char) !== -1; }).length;
            }

            return {
                integerPartGroupingPositions: integerPartGroupingPositions,
                regularGrouping: regularGrouping,
                minimumIntegerPartSize: minimumIntegerPartSize,
                scalingFactor: scalingFactor,
                prefix: parts.prefix,
                fractionalPartGroupingPositions: fractionalPartGroupingPositions,
                minimumFactionalPartSize: minimumFactionalPartSize,
                maximumFactionalPartSize: maximumFactionalPartSize,
                minimumExponentSize: minimumExponentSize,
                suffix: parts.suffix,
                picture: parts.subpicture
            };
        };

        var parts = subPictures.map(splitParts);
        parts.forEach(validate);

        var variables = parts.map(analyse);

        if(variables.length === 1) {
            variables.push(JSON.parse(JSON.stringify(variables[0])));
            variables[1].prefix = properties['minus-sign'] + variables[1].prefix;
        }

        // TODO cache the result of the analysis

        // format the number
        // bullet 1: TODO: NaN - not sure we'd ever get this in JSON
        var pic;
        // bullet 2:
        if(value >= 0) {
            pic = variables[0];
        } else {
            pic = variables[1];
        }
        var adjustedNumber;
        // bullet 3:
        if(pic.picture.indexOf(properties.percent) !== -1) {
            adjustedNumber = value * 100;
        } else if(pic.picture.indexOf(properties['per-mille']) !== -1) {
            adjustedNumber = value * 1000;
        } else {
            adjustedNumber = value;
        }
        // bullet 4:
        // TODO: infinity - not sure we'd ever get this in JSON
        // bullet 5:
        var mantissa, exponent;
        if(pic.minimumExponentSize === 0) {
            mantissa = adjustedNumber;
        } else {
            // mantissa * 10^exponent = adjustedNumber
            var maxMantissa = Math.pow(10, pic.scalingFactor);
            var minMantissa = Math.pow(10, pic.scalingFactor - 1);
            mantissa = adjustedNumber;
            exponent = 0;
            while(mantissa < minMantissa) {
                mantissa *= 10;
                exponent -= 1;
            }
            while(mantissa > maxMantissa) {
                mantissa /= 10;
                exponent += 1;
            }
        }
        // bullet 6:
        var roundedNumber = functionRound(mantissa, pic.maximumFactionalPartSize);
        // bullet 7:
        var makeString = function(value, dp) {
            var str = Math.abs(value).toFixed(dp);
            if (properties['zero-digit'] !== '0') {
                str = str.split('').map(function (digit) {
                    if(digit >= '0' && digit <='9') {
                        return decimalDigitFamily[digit.charCodeAt(0) - 48];
                    } else {
                        return digit;
                    }
                }).join('');
            }
            return str;
        };
        var stringValue = makeString(roundedNumber, pic.maximumFactionalPartSize);
        var decimalPos = stringValue.indexOf('.');
        if(decimalPos === -1) {
            stringValue = stringValue + properties['decimal-separator'];
        } else {
            stringValue = stringValue.replace('.', properties['decimal-separator']);
        }
        while(stringValue.charAt(0) === properties['zero-digit']) {
            stringValue = stringValue.substring(1);
        }
        while(stringValue.charAt(stringValue.length - 1) === properties['zero-digit']) {
            stringValue = stringValue.substring(0, stringValue.length - 1);
        }
        // bullets 8 & 9:
        decimalPos = stringValue.indexOf(properties['decimal-separator']);
        var padLeft = pic.minimumIntegerPartSize - decimalPos;
        var padRight = pic.minimumFactionalPartSize - (stringValue.length - decimalPos - 1);
        stringValue = (padLeft > 0 ? new Array(padLeft + 1).join('0') : '') + stringValue;
        stringValue = stringValue + (padRight > 0 ? new Array(padRight + 1).join('0') : '');
        decimalPos = stringValue.indexOf(properties['decimal-separator']);
        // bullet 10:
        if(pic.regularGrouping > 0) {
            var groupCount = Math.floor((decimalPos - 1) / pic.regularGrouping);
            for(var group = 1; group <= groupCount; group++) {
                stringValue = [stringValue.slice(0, decimalPos - group * pic.regularGrouping), properties['grouping-separator'], stringValue.slice(decimalPos - group * pic.regularGrouping)].join('');
            }
        } else {
            pic.integerPartGroupingPositions.forEach(function (pos) {
                stringValue = [stringValue.slice(0, decimalPos - pos), properties['grouping-separator'], stringValue.slice(decimalPos - pos)].join('');
                decimalPos++;
            });
        }
        // bullet 11:
        decimalPos = stringValue.indexOf(properties['decimal-separator']);
        pic.fractionalPartGroupingPositions.forEach(function(pos) {
            stringValue = [stringValue.slice(0, pos + decimalPos + 1), properties['grouping-separator'], stringValue.slice(pos + decimalPos + 1)].join('');
        });
        // bullet 12:
        decimalPos = stringValue.indexOf(properties['decimal-separator']);
        if(pic.picture.indexOf(properties['decimal-separator']) === -1 || decimalPos === stringValue.length - 1) {
            stringValue = stringValue.substring(0, stringValue.length - 1);
        }
        // bullet 13:
        if(typeof exponent !== 'undefined') {
            var stringExponent = makeString(exponent, 0);
            padLeft = pic.minimumExponentSize - stringExponent.length;
            if(padLeft > 0) {
                stringExponent = new Array(padLeft + 1).join('0') + stringExponent;
            }
            stringValue = stringValue + properties['exponent-separator'] + (exponent < 0 ? properties['minus-sign'] : '') + stringExponent;
        }
        // bullet 14:
        stringValue = pic.prefix + stringValue + pic.suffix;
        return stringValue;
    }

    /**
     * Converts a number to a string using a specified number base
     * @param {string} value - the number to convert
     * @param {number} [radix] - the number base; must be between 2 and 36. Defaults to 10
     * @returns {string} - the converted string
     */
    function functionFormatBase(value, radix) {
        // undefined inputs always return undefined
        if(typeof value === 'undefined') {
            return undefined;
        }

        value = functionRound(value);

        if(typeof radix === 'undefined') {
            radix = 10;
        } else {
            radix = functionRound(radix);
        }

        if(radix < 2 || radix > 36) {
            throw {
                code: 'D3100',
                stack: (new Error()).stack,
                value: radix
            };

        }

        var result = value.toString(radix);

        return result;
    }

    /**
     * Cast argument to number
     * @param {Object} arg - Argument
     * @returns {Number} numeric value of argument
     */
    function functionNumber(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        if (typeof arg === 'number') {
            // already a number
            result = arg;
        } else if(typeof arg === 'string' && /^-?(0|([1-9][0-9]*))(\.[0-9]+)?([Ee][-+]?[0-9]+)?$/.test(arg) && !isNaN(parseFloat(arg)) && isFinite(arg)) {
            result = parseFloat(arg);
        } else {
            throw {
                code: "D3030",
                value: arg,
                stack: (new Error()).stack,
                index: 1
            };
        }
        return result;
    }

    /**
     * Absolute value of a number
     * @param {Number} arg - Argument
     * @returns {Number} absolute value of argument
     */
    function functionAbs(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        result = Math.abs(arg);
        return result;
    }

    /**
     * Rounds a number down to integer
     * @param {Number} arg - Argument
     * @returns {Number} rounded integer
     */
    function functionFloor(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        result = Math.floor(arg);
        return result;
    }

    /**
     * Rounds a number up to integer
     * @param {Number} arg - Argument
     * @returns {Number} rounded integer
     */
    function functionCeil(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        result = Math.ceil(arg);
        return result;
    }

    /**
     * Round to half even
     * @param {Number} arg - Argument
     * @param {Number} precision - number of decimal places
     * @returns {Number} rounded integer
     */
    function functionRound(arg, precision) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        if(precision) {
            // shift the decimal place - this needs to be done in a string since multiplying
            // by a power of ten can introduce floating point precision errors which mess up
            // this rounding algorithm - See 'Decimal rounding' in
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round
            // Shift
            var value = arg.toString().split('e');
            arg = +(value[0] + 'e' + (value[1] ? (+value[1] + precision) : precision));

        }

        // round up to nearest int
        result = Math.round(arg);
        var diff = result - arg;
        if(Math.abs(diff) === 0.5 && Math.abs(result % 2) === 1) {
            // rounded the wrong way - adjust to nearest even number
            result = result - 1;
        }
        if(precision) {
            // Shift back
            value = result.toString().split('e');
            /* istanbul ignore next */
            result = +(value[0] + 'e' + (value[1] ? (+value[1] - precision) : -precision));
        }
        if(Object.is(result, -0)) { // ESLint rule 'no-compare-neg-zero' suggests this way
            // JSON doesn't do -0
            result = 0;
        }
        return result;
    }

    /**
     * Square root of number
     * @param {Number} arg - Argument
     * @returns {Number} square root
     */
    function functionSqrt(arg) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        if(arg < 0) {
            throw {
                stack: (new Error()).stack,
                code: "D3060",
                index: 1,
                value: arg
            };
        }

        result = Math.sqrt(arg);

        return result;
    }

    /**
     * Raises number to the power of the second number
     * @param {Number} arg - the base
     * @param {Number} exp - the exponent
     * @returns {Number} rounded integer
     */
    function functionPower(arg, exp) {
        var result;

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        result = Math.pow(arg, exp);

        if(!isFinite(result)) {
            throw {
                stack: (new Error()).stack,
                code: "D3061",
                index: 1,
                value: arg,
                exp: exp
            };
        }

        return result;
    }

    /**
     * Returns a random number 0 <= n < 1
     * @returns {number} random number
     */
    function functionRandom() {
        return Math.random();
    }

    /**
     * Evaluate an input and return a boolean
     * @param {*} arg - Arguments
     * @returns {boolean} Boolean
     */
    function functionBoolean(arg) {
        // cast arg to its effective boolean value
        // boolean: unchanged
        // string: zero-length -> false; otherwise -> true
        // number: 0 -> false; otherwise -> true
        // null -> false
        // array: empty -> false; length > 1 -> true
        // object: empty -> false; non-empty -> true
        // function -> false

        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        var result = false;
        if (Array.isArray(arg)) {
            if (arg.length === 1) {
                result = functionBoolean(arg[0]);
            } else if (arg.length > 1) {
                var trues = arg.filter(function(val) {return functionBoolean(val);});
                result = trues.length > 0;
            }
        } else if (typeof arg === 'string') {
            if (arg.length > 0) {
                result = true;
            }
        } else if (isNumeric(arg)) {
            if (arg !== 0) {
                result = true;
            }
        } else if (arg !== null && typeof arg === 'object') {
            if (Object.keys(arg).length > 0) {
                // make sure it's not a lambda function
                if (!(isLambda(arg) || arg._jsonata_function)) {
                    result = true;
                }
            }
        } else if (typeof arg === 'boolean' && arg === true) {
            result = true;
        }
        return result;
    }

    /**
     * returns the Boolean NOT of the arg
     * @param {*} arg - argument
     * @returns {boolean} - NOT arg
     */
    function functionNot(arg) {
        return !functionBoolean(arg);
    }

    /**
     * Create a map from an array of arguments
     * @param {Array} [arr] - array to map over
     * @param {Function} func - function to apply
     * @returns {Array} Map array
     */
    function* functionMap(arr, func) {
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        var result = [];
        // do the map - iterate over the arrays, and invoke func
        for (var i = 0; i < arr.length; i++) {
            var func_args = [arr[i]]; // the first arg (value) is required
            // the other two are optional - only supply it if the function can take it
            var length = typeof func === 'function' ? func.length :
                func._jsonata_function === true ? func.implementation.length : func.arguments.length;
            if(length >= 2) {
                func_args.push(i);
            }
            if(length >= 3) {
                func_args.push(arr);
            }
            // invoke func
            var res = yield * apply(func, func_args, null);
            if(typeof res !== 'undefined') {
                result.push(res);
            }
        }

        return result;
    }

    // This generator function does not have a yield(), presumably to make it
    // consistent with other similar functions.
    /**
     * Create a map from an array of arguments
     * @param {Array} [arr] - array to filter
     * @param {Function} func - predicate function
     * @returns {Array} Map array
     */
    function* functionFilter(arr, func) { // eslint-disable-line require-yield
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        var result = [];

        var predicate = function (value, index, array) {
            var it = apply(func, [value, index, array], null);
            // returns a generator - so iterate over it
            var res = it.next();
            while (!res.done) {
                res = it.next(res.value);
            }
            return res.value;
        };

        for(var i = 0; i < arr.length; i++) {
            var entry = arr[i];
            if(functionBoolean(predicate(entry, i, arr))) {
                result.push(entry);
            }
        }

        return result;
    }

    /**
     * Convolves (zips) each value from a set of arrays
     * @param {Array} [args] - arrays to zip
     * @returns {Array} Zipped array
     */
    function functionZip() {
        // this can take a variable number of arguments
        var result = [];
        var args = Array.prototype.slice.call(arguments);
        // length of the shortest array
        var length = Math.min.apply(Math, args.map(function(arg) {
            if(Array.isArray(arg)) {
                return arg.length;
            }
            return 0;
        }));
        for(var i = 0; i < length; i++) {
            var tuple = args.map((arg) => {return arg[i];});
            result.push(tuple);
        }
        return result;
    }

    /**
     * Fold left function
     * @param {Array} sequence - Sequence
     * @param {Function} func - Function
     * @param {Object} init - Initial value
     * @returns {*} Result
     */
    function* functionFoldLeft(sequence, func, init) {
        // undefined inputs always return undefined
        if(typeof sequence === 'undefined') {
            return undefined;
        }

        var result;

        if (!(func.length === 2 || (func._jsonata_function === true && func.implementation.length === 2) || func.arguments.length === 2)) {
            throw {
                stack: (new Error()).stack,
                code: "D3050",
                index: 1
            };
        }

        var index;
        if (typeof init === 'undefined' && sequence.length > 0) {
            result = sequence[0];
            index = 1;
        } else {
            result = init;
            index = 0;
        }

        while (index < sequence.length) {
            result = yield * apply(func, [result, sequence[index]], null);
            index++;
        }

        return result;
    }

    /**
     * Return keys for an object
     * @param {Object} arg - Object
     * @returns {Array} Array of keys
     */
    function functionKeys(arg) {
        var result = [];

        if(Array.isArray(arg)) {
            // merge the keys of all of the items in the array
            var merge = {};
            arg.forEach(function(item) {
                var keys = functionKeys(item);
                if(Array.isArray(keys)) {
                    keys.forEach(function(key) {
                        merge[key] = true;
                    });
                }
            });
            result = functionKeys(merge);
        } else if(arg !== null && typeof arg === 'object' && !(isLambda(arg))) {
            result = Object.keys(arg);
            if(result.length === 0) {
                result = undefined;
            }
        } else {
            result = undefined;
        }
        return result;
    }

    /**
     * Return value from an object for a given key
     * @param {Object} object - Object
     * @param {String} key - Key in object
     * @returns {*} Value of key in object
     */
    function functionLookup(object, key) {
        var result = evaluateName({value: key}, object);
        return result;
    }

    /**
     * Append second argument to first
     * @param {Array|Object} arg1 - First argument
     * @param {Array|Object} arg2 - Second argument
     * @returns {*} Appended arguments
     */
    function functionAppend(arg1, arg2) {
        // disregard undefined args
        if (typeof arg1 === 'undefined') {
            return arg2;
        }
        if (typeof arg2 === 'undefined') {
            return arg1;
        }
        // if either argument is not an array, make it so
        if (!Array.isArray(arg1)) {
            arg1 = [arg1];
        }
        if (!Array.isArray(arg2)) {
            arg2 = [arg2];
        }
        Array.prototype.push.apply(arg1, arg2);
        return arg1;
    }

    /**
     * Determines if the argument is undefined
     * @param {*} arg - argument
     * @returns {boolean} False if argument undefined, otherwise true
     */
    function functionExists(arg){
        if (typeof arg === 'undefined') {
            return false;
        } else {
            return true;
        }
    }

    /**
     * Splits an object into an array of object with one property each
     * @param {*} arg - the object to split
     * @returns {*} - the array
     */
    function functionSpread(arg) {
        var result = [];

        if(Array.isArray(arg)) {
            // spread all of the items in the array
            arg.forEach(function(item) {
                result = functionAppend(result, functionSpread(item));
            });
        } else if(arg !== null && typeof arg === 'object' && !isLambda(arg)) {
            for(var key in arg) {
                var obj = {};
                obj[key] = arg[key];
                result.push(obj);
            }
        } else {
            result = arg;
        }
        return result;
    }

    /**
     * Merges an array of objects into a single object.  Duplicate properties are
     * overridden by entries later in the array
     * @param {*} arg - the objects to merge
     * @returns {*} - the object
     */
    function functionMerge(arg) {
        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        var result = {};

        arg.forEach(function(obj) {
            for(var prop in obj) {
                result[prop] = obj[prop];
            }
        });
        return result;
    }

    /**
     * Reverses the order of items in an array
     * @param {Array} arr - the array to reverse
     * @returns {Array} - the reversed array
     */
    function functionReverse(arr) {
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        if(arr.length <= 1) {
            return arr;
        }

        var length = arr.length;
        var result = new Array(length);
        for(var i = 0; i < length; i++) {
            result[length - i - 1] = arr[i];
        }

        return result;
    }

    /**
     *
     * @param {*} obj - the input object to iterate over
     * @param {*} func - the function to apply to each key/value pair
     * @returns {Array} - the resultant array
     */
    function* functionEach(obj, func) {
        var result = [];

        for(var key in obj) {
            var func_args = [obj[key], key];
            // invoke func
            result.push(yield * apply(func, func_args, null));
        }

        return result;
    }

    /**
     * Implements the merge sort (stable) with optional comparator function
     *
     * @param {Array} arr - the array to sort
     * @param {*} comparator - comparator function
     * @returns {Array} - sorted array
     */
    function functionSort(arr, comparator) {
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        if(arr.length <= 1) {
            return arr;
        }

        var comp;
        if(typeof comparator === 'undefined') {
            // inject a default comparator - only works for numeric or string arrays
            if (!isArrayOfNumbers(arr) && !isArrayOfStrings(arr)) {
                throw {
                    stack: (new Error()).stack,
                    code: "D3070",
                    index: 1
                };
            }

            comp = function (a, b) {
                return a > b;
            };
        } else if(typeof comparator === 'function') {
            // for internal usage of functionSort (i.e. order-by syntax)
            comp = comparator;
        } else {
            comp = function (a, b) {
                var it = apply(comparator, [a, b], null);
                // returns a generator - so iterate over it
                var comp = it.next();
                while (!comp.done) {
                    comp = it.next(comp.value);
                }
                return comp.value;
            };
        }

        var merge = function(l, r) {
            var merge_iter = function(result, left, right) {
                if (left.length === 0) {
                    Array.prototype.push.apply(result, right);
                } else if (right.length === 0) {
                    Array.prototype.push.apply(result, left);
                } else if (comp(left[0], right[0])) { // invoke the comparator function
                    // if it returns true - swap left and right
                    result.push(right[0]);
                    merge_iter(result, left, right.slice(1));
                } else {
                    // otherwise keep the same order
                    result.push(left[0]);
                    merge_iter(result, left.slice(1), right);
                }
            };
            var merged = [];
            merge_iter(merged, l, r);
            return merged;
        };

        var sort = function(array) {
            if(array.length <= 1) {
                return array;
            } else {
                var middle = Math.floor(array.length / 2);
                var left = array.slice(0, middle);
                var right = array.slice(middle);
                left = sort(left);
                right = sort(right);
                return merge(left, right);
            }
        };

        var result = sort(arr);

        return result;
    }

    /**
     * Randomly shuffles the contents of an array
     * @param {Array} arr - the input array
     * @returns {Array} the shuffled array
     */
    function functionShuffle(arr) {
        // undefined inputs always return undefined
        if(typeof arr === 'undefined') {
            return undefined;
        }

        if(arr.length <= 1) {
            return arr;
        }

        // shuffle using the 'inside-out' variant of the Fisher-Yates algorithm
        var result = new Array(arr.length);
        for(var i = 0; i < arr.length; i++) {
            var j = Math.floor(Math.random() * (i + 1)); // random integer such that 0 ≤ j ≤ i
            if(i !== j) {
                result[i] = result[j];
            }
            result[j] = arr[i];
        }

        return result;
    }

    /**
     * Applies a predicate function to each key/value pair in an object, and returns an object containing
     * only the key/value pairs that passed the predicate
     *
     * @param {object} arg - the object to be sifted
     * @param {object} func - the predicate function (lambda or native)
     * @returns {object} - sifted object
     */
    function functionSift(arg, func) {
        var result = {};

        var predicate = function (value, key, object) {
            var it = apply(func, [value, key, object], null);
            // returns a generator - so iterate over it
            var res = it.next();
            while (!res.done) {
                res = it.next(res.value);
            }
            return res.value;
        };

        for(var item in arg) {
            var entry = arg[item];
            if(functionBoolean(predicate(entry, item, arg))) {
                result[item] = entry;
            }
        }

        // empty objects should be changed to undefined
        if(Object.keys(result).length === 0) {
            result = undefined;
        }

        return result;
    }

    // Regular expression to match an ISO 8601 formatted timestamp
    var iso8601regex = new RegExp('^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z)$');

    /**
     * Converts an ISO 8601 timestamp to milliseconds since the epoch
     *
     * @param {string} timestamp - the ISO 8601 timestamp to be converted
     * @returns {Number} - milliseconds since the epoch
     */
    function functionToMillis(timestamp) {
        // undefined inputs always return undefined
        if(typeof timestamp === 'undefined') {
            return undefined;
        }

        if(!iso8601regex.test(timestamp)) {
            throw {
                stack: (new Error()).stack,
                code: "D3110",
                value: timestamp
            };
        }

        return Date.parse(timestamp);
    }

    /**
     * Converts milliseconds since the epoch to an ISO 8601 timestamp
     * @param {Number} millis - milliseconds since the epoch to be converted
     * @returns {String} - an ISO 8601 formatted timestamp
     */
    function functionFromMillis(millis) {
        // undefined inputs always return undefined
        if(typeof millis === 'undefined') {
            return undefined;
        }

        return new Date(millis).toISOString();
    }

    /**
     * Clones an object
     * @param {Object} arg - object to clone (deep copy)
     * @returns {*} - the cloned object
     */
    function functionClone(arg) {
        // undefined inputs always return undefined
        if(typeof arg === 'undefined') {
            return undefined;
        }

        return JSON.parse(functionString(arg));
    }

    /**
     * Create frame
     * @param {Object} enclosingEnvironment - Enclosing environment
     * @returns {{bind: bind, lookup: lookup}} Created frame
     */
    function createFrame(enclosingEnvironment) {
        var bindings = {};
        return {
            bind: function (name, value) {
                bindings[name] = value;
            },
            lookup: function (name) {
                var value;
                if(bindings.hasOwnProperty(name)) {
                    value = bindings[name];
                } else if (enclosingEnvironment) {
                    value = enclosingEnvironment.lookup(name);
                }
                return value;
            }
        };
    }

    // Function registration
    staticFrame.bind('sum', defineFunction(functionSum, '<a<n>:n>'));
    staticFrame.bind('count', defineFunction(functionCount, '<a:n>'));
    staticFrame.bind('max', defineFunction(functionMax, '<a<n>:n>'));
    staticFrame.bind('min', defineFunction(functionMin, '<a<n>:n>'));
    staticFrame.bind('average', defineFunction(functionAverage, '<a<n>:n>'));
    staticFrame.bind('string', defineFunction(functionString, '<x-:s>'));
    staticFrame.bind('substring', defineFunction(functionSubstring, '<s-nn?:s>'));
    staticFrame.bind('substringBefore', defineFunction(functionSubstringBefore, '<s-s:s>'));
    staticFrame.bind('substringAfter', defineFunction(functionSubstringAfter, '<s-s:s>'));
    staticFrame.bind('lowercase', defineFunction(functionLowercase, '<s-:s>'));
    staticFrame.bind('uppercase', defineFunction(functionUppercase, '<s-:s>'));
    staticFrame.bind('length', defineFunction(functionLength, '<s-:n>'));
    staticFrame.bind('trim', defineFunction(functionTrim, '<s-:s>'));
    staticFrame.bind('pad', defineFunction(functionPad, '<s-ns?:s>'));
    staticFrame.bind('match', defineFunction(functionMatch, '<s-f<s:o>n?:a<o>>'));
    staticFrame.bind('contains', defineFunction(functionContains, '<s-(sf):b>')); // TODO <s-(sf<s:o>):b>
    staticFrame.bind('replace', defineFunction(functionReplace, '<s-(sf)(sf)n?:s>')); // TODO <s-(sf<s:o>)(sf<o:s>)n?:s>
    staticFrame.bind('split', defineFunction(functionSplit, '<s-(sf)n?:a<s>>')); // TODO <s-(sf<s:o>)n?:a<s>>
    staticFrame.bind('join', defineFunction(functionJoin, '<a<s>s?:s>'));
    staticFrame.bind('formatNumber', defineFunction(functionFormatNumber, '<n-so?:s>'));
    staticFrame.bind('formatBase', defineFunction(functionFormatBase, '<n-n?:s>'));
    staticFrame.bind('number', defineFunction(functionNumber, '<(ns)-:n>'));
    staticFrame.bind('floor', defineFunction(functionFloor, '<n-:n>'));
    staticFrame.bind('ceil', defineFunction(functionCeil, '<n-:n>'));
    staticFrame.bind('round', defineFunction(functionRound, '<n-n?:n>'));
    staticFrame.bind('abs', defineFunction(functionAbs, '<n-:n>'));
    staticFrame.bind('sqrt', defineFunction(functionSqrt, '<n-:n>'));
    staticFrame.bind('power', defineFunction(functionPower, '<n-n:n>'));
    staticFrame.bind('random', defineFunction(functionRandom, '<:n>'));
    staticFrame.bind('boolean', defineFunction(functionBoolean, '<x-:b>'));
    staticFrame.bind('not', defineFunction(functionNot, '<x-:b>'));
    staticFrame.bind('map', defineFunction(functionMap, '<af>'));
    staticFrame.bind('zip', defineFunction(functionZip, '<a+>'));
    staticFrame.bind('filter', defineFunction(functionFilter, '<af>'));
    staticFrame.bind('reduce', defineFunction(functionFoldLeft, '<afj?:j>')); // TODO <f<jj:j>a<j>j?:j>
    staticFrame.bind('sift', defineFunction(functionSift, '<o-f?:o>'));
    staticFrame.bind('keys', defineFunction(functionKeys, '<x-:a<s>>'));
    staticFrame.bind('lookup', defineFunction(functionLookup, '<x-s:x>'));
    staticFrame.bind('append', defineFunction(functionAppend, '<xx:a>'));
    staticFrame.bind('exists', defineFunction(functionExists, '<x:b>'));
    staticFrame.bind('spread', defineFunction(functionSpread, '<x-:a<o>>'));
    staticFrame.bind('merge', defineFunction(functionMerge, '<a<o>:o>'));
    staticFrame.bind('reverse', defineFunction(functionReverse, '<a:a>'));
    staticFrame.bind('each', defineFunction(functionEach, '<o-f:a>'));
    staticFrame.bind('sort', defineFunction(functionSort, '<af?:a>'));
    staticFrame.bind('shuffle', defineFunction(functionShuffle, '<a:a>'));
    staticFrame.bind('base64encode', defineFunction(functionBase64encode, '<s-:s>'));
    staticFrame.bind('base64decode', defineFunction(functionBase64decode, '<s-:s>'));
    staticFrame.bind('toMillis', defineFunction(functionToMillis, '<s-:n>'));
    staticFrame.bind('fromMillis', defineFunction(functionFromMillis, '<n-:s>'));
    staticFrame.bind('clone', defineFunction(functionClone, '<(oa)-:o>'));

    /**
     * Error codes
     *
     */
    var errorCodes = {
        "S0101": "String literal must be terminated by a matching quote",
        "S0102": "Number out of range: {{token}}",
        "S0103": "Unsupported escape sequence: \\{{token}}",
        "S0104": "The escape sequence \\u must be followed by 4 hex digits",
        "S0105": "Quoted property name must be terminated with a backquote (`)",
        "S0201": "Syntax error: {{token}}",
        "S0202": "Expected {{value}}, got {{token}}",
        "S0203": "Expected {{value}} before end of expression",
        "S0204": "Unknown operator: {{token}}",
        "S0205": "Unexpected token: {{token}}",
        "S0206": "Unknown expression type: {{token}}",
        "S0207": "Unexpected end of expression",
        "S0208": "Parameter {{value}} of function definition must be a variable name (start with $)",
        "S0209": "A predicate cannot follow a grouping expression in a step",
        "S0210": "Each step can only have one grouping expression",
        "S0211": "The symbol {{token}} cannot be used as a unary operator",
        "S0301": "Empty regular expressions are not allowed",
        "S0302": "No terminating / in regular expression",
        "S0402": "Choice groups containing parameterized types are not supported",
        "S0401": "Type parameters can only be applied to functions and arrays",
        "S0500": "Attempted to evaluate an expression containing syntax error(s)",
        "T0410": "Argument {{index}} of function {{token}} does not match function signature",
        "T0411": "Context value is not a compatible type with argument {{index}} of function {{token}}",
        "T0412": "Argument {{index}} of function {{token}} must be an array of {{type}}",
        "D1001": "Number out of range: {{value}}",
        "D1002": "Cannot negate a non-numeric value: {{value}}",
        "T1003": "Key in object structure must evaluate to a string; got: {{value}}",
        "D1004": "Regular expression matches zero length string",
        "T1005": "Attempted to invoke a non-function. Did you mean ${{{token}}}?",
        "T1006": "Attempted to invoke a non-function",
        "T1007": "Attempted to partially apply a non-function. Did you mean ${{{token}}}?",
        "T1008": "Attempted to partially apply a non-function",
        "T2001": "The left side of the {{token}} operator must evaluate to a number",
        "T2002": "The right side of the {{token}} operator must evaluate to a number",
        "T2003": "The left side of the range operator (..) must evaluate to an integer",
        "T2004": "The right side of the range operator (..) must evaluate to an integer",
        "D2005": "The left side of := must be a variable name (start with $)",
        "T2006": "The right side of the function application operator ~> must be a function",
        "T2007": "Type mismatch when comparing values {{value}} and {{value2}} in order-by clause",
        "T2008": "The expressions within an order-by clause must evaluate to numeric or string values",
        "T2009": "The values {{value}} and {{value2}} either side of operator {{token}} must be of the same data type",
        "T2010": "The expressions either side of operator {{token}} must evaluate to numeric or string values",
        "T2011": "The insert/update clause of the transform expression must evaluate to an object: {{value}}",
        "T2012": "The delete clause of the transform expression must evaluate to a string or array of strings: {{value}}",
        "T2013": "The transform expression clones the input object using the $clone() function.  This has been overridden in the current scope by a non-function.",
        "D3001": "Attempting to invoke string function on Infinity or NaN",
        "D3010": "Second argument of replace function cannot be an empty string",
        "D3011": "Fourth argument of replace function must evaluate to a positive number",
        "D3012": "Attempted to replace a matched string with a non-string value",
        "D3020": "Third argument of split function must evaluate to a positive number",
        "D3030": "Unable to cast value to a number: {{value}}",
        "D3040": "Third argument of match function must evaluate to a positive number",
        "D3050": "First argument of reduce function must be a function with two arguments",
        "D3060": "The sqrt function cannot be applied to a negative number: {{value}}",
        "D3061": "The power function has resulted in a value that cannot be represented as a JSON number: base={{value}}, exponent={{exp}}",
        "D3070": "The single argument form of the sort function can only be applied to an array of strings or an array of numbers.  Use the second argument to specify a comparison function",
        "D3080": "The picture string must only contain a maximum of two sub-pictures",
        "D3081": "The sub-picture must not contain more than one instance of the 'decimal-separator' character",
        "D3082": "The sub-picture must not contain more than one instance of the 'percent' character",
        "D3083": "The sub-picture must not contain more than one instance of the 'per-mille' character",
        "D3084": "The sub-picture must not contain both a 'percent' and a 'per-mille' character",
        "D3085": "The mantissa part of a sub-picture must contain at least one character that is either an 'optional digit character' or a member of the 'decimal digit family'",
        "D3086": "The sub-picture must not contain a passive character that is preceded by an active character and that is followed by another active character",
        "D3087": "The sub-picture must not contain a 'grouping-separator' character that appears adjacent to a 'decimal-separator' character",
        "D3088": "The sub-picture must not contain a 'grouping-separator' at the end of the integer part",
        "D3089": "The sub-picture must not contain two adjacent instances of the 'grouping-separator' character",
        "D3090": "The integer part of the sub-picture must not contain a member of the 'decimal digit family' that is followed by an instance of the 'optional digit character'",
        "D3091": "The fractional part of the sub-picture must not contain an instance of the 'optional digit character' that is followed by a member of the 'decimal digit family'",
        "D3092": "A sub-picture that contains a 'percent' or 'per-mille' character must not contain a character treated as an 'exponent-separator'",
        "D3093": "The exponent part of the sub-picture must comprise only of one or more characters that are members of the 'decimal digit family'",
        "D3100": "The radix of the formatBase function must be between 2 and 36.  It was given {{value}}",
        "D3110": "The argument of the toMillis function must be an ISO 8601 formatted timestamp. Given {{value}}"
    };

    /**
     * lookup a message template from the catalog and substitute the inserts
     * @param {string} err - error code to lookup
     * @returns {string} message
     */
    function lookupMessage(err) {
        var message = 'Unknown error';
        if(typeof err.message !== 'undefined') {
            message = err.message;
        }
        var template = errorCodes[err.code];
        if(typeof template !== 'undefined') {
            // if there are any handlebars, replace them with the field references
            // triple braces - replace with value
            // double braces - replace with json stringified value
            message = template.replace(/\{\{\{([^}]+)}}}/g, function() {
                return err[arguments[1]];
            });
            message = message.replace(/\{\{([^}]+)}}/g, function() {
                return JSON.stringify(err[arguments[1]]);
            });
        }
        return message;
    }

    /**
     * JSONata
     * @param {Object} expr - JSONata expression
     * @param {boolean} options - recover: attempt to recover on parse error
     * @returns {{evaluate: evaluate, assign: assign}} Evaluated expression
     */
    function jsonata(expr, options) {
        var ast;
        var errors;
        try {
            ast = parser(expr, options && options.recover);
            errors = ast.errors;
            delete ast.errors;
        } catch(err) {
            // insert error message into structure
            err.message = lookupMessage(err);
            throw err;
        }
        var environment = createFrame(staticFrame);

        var timestamp = new Date(); // will be overridden on each call to evalute()
        environment.bind('now', defineFunction(function() {
            return timestamp.toJSON();
        }, '<:s>'));
        environment.bind('millis', defineFunction(function() {
            return timestamp.getTime();
        }, '<:n>'));

        return {
            evaluate: function (input, bindings, callback) {
                // throw if the expression compiled with syntax errors
                if(typeof errors !== 'undefined') {
                    var err = {
                        code: 'S0500',
                        position: 0
                    };
                    err.message = lookupMessage(err);
                    throw err;
                }

                if (typeof bindings !== 'undefined') {
                    var exec_env;
                    // the variable bindings have been passed in - create a frame to hold these
                    exec_env = createFrame(environment);
                    for (var v in bindings) {
                        exec_env.bind(v, bindings[v]);
                    }
                } else {
                    exec_env = environment;
                }
                // put the input document into the environment as the root object
                exec_env.bind('$', input);

                // capture the timestamp and put it in the execution environment
                // the $now() and $millis() functions will return this value - whenever it is called
                timestamp = new Date();

                var result, it;
                // if a callback function is supplied, then drive the generator in a promise chain
                if(typeof callback === 'function') {
                    exec_env.bind('__jsonata_async', true);
                    var thenHandler = function (response) {
                        result = it.next(response);
                        if (result.done) {
                            callback(null, result.value);
                        } else {
                            result.value.then(thenHandler)
                                .catch(function (err) {
                                    err.message = lookupMessage(err);
                                    callback(err, null);
                                });
                        }
                    };
                    it = evaluate(ast, input, exec_env);
                    result = it.next();
                    result.value.then(thenHandler);
                } else {
                    // no callback function - drive the generator to completion synchronously
                    try {
                        it = evaluate(ast, input, exec_env);
                        result = it.next();
                        while (!result.done) {
                            result = it.next(result.value);
                        }
                        return result.value;
                    } catch (err) {
                        // insert error message into structure
                        err.message = lookupMessage(err);
                        throw err;
                    }
                }
            },
            assign: function (name, value) {
                environment.bind(name, value);
            },
            registerFunction: function(name, implementation, signature) {
                var func = defineFunction(implementation, signature);
                environment.bind(name, func);
            },
            ast: function() {
                return ast;
            },
            errors: function() {
                return errors;
            }
        };
    }

    jsonata.parser = parser; // TODO remove this in a future release - use ast() instead

    return jsonata;

})();

// node.js only - export the jsonata and parser functions
// istanbul ignore else
if(typeof module !== 'undefined') {
    module.exports = jsonata;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],60:[function(require,module,exports){
(function (process){
'use strict';

var loglevel = require('loglevel');
var chalk = require('chalk');

var loggers = {};

module.exports = getLogger;

function getLogger() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$level = _ref.level,
      level = _ref$level === undefined ? getDefaultLevel() : _ref$level,
      _ref$prefix = _ref.prefix,
      prefix = _ref$prefix === undefined ? '' : _ref$prefix;

  if (loggers[prefix]) {
    return loggers[prefix];
  }
  var coloredPrefix = prefix ? `${chalk.dim(prefix)} ` : '';
  var levelPrefix = {
    TRACE: chalk.dim('[TRACE]'),
    DEBUG: chalk.cyan('[DEBUG]'),
    INFO: chalk.blue('[INFO]'),
    WARN: chalk.yellow('[WARN]'),
    ERROR: chalk.red('[ERROR]')
  };

  var logger = loglevel.getLogger(`${prefix}-logger`);

  // this is the plugin "api"
  var originalFactory = logger.methodFactory;
  logger.methodFactory = methodFactory;

  var originalSetLevel = logger.setLevel;
  logger.setLevel = setLevel;
  logger.setLevel(level);
  loggers[prefix] = logger;
  return logger;

  function methodFactory() {
    for (var _len = arguments.length, factoryArgs = Array(_len), _key = 0; _key < _len; _key++) {
      factoryArgs[_key] = arguments[_key];
    }

    var logLevel = factoryArgs[0];

    var rawMethod = originalFactory.apply(undefined, factoryArgs);
    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return rawMethod.apply(undefined, [`${coloredPrefix}${levelPrefix[logLevel.toUpperCase()]}:`].concat(args));
    };
  }

  function setLevel(levelToSetTo) {
    var persist = false; // uses browser localStorage
    return originalSetLevel.call(logger, levelToSetTo, persist);
  }
}

function getDefaultLevel() {
  var logLevel = process.env.LOG_LEVEL;

  if (logLevel === 'undefined' || !logLevel) {
    return 'warn';
  }
  return logLevel;
}
}).call(this,require('_process'))

},{"_process":3,"chalk":51,"loglevel":61}],61:[function(require,module,exports){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (typeof define === 'function' && define.amd) {
        define(definition);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = definition();
    } else {
        root.log = definition();
    }
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));

},{}],62:[function(require,module,exports){
(function (global){
var performance = global.performance || {};

var present = (function () {
  var names = ['now', 'webkitNow', 'msNow', 'mozNow', 'oNow'];
  while (names.length) {
    var name = names.shift();
    if (name in performance) {
      return performance[name].bind(performance);
    }
  }

  var dateNow = Date.now || function () { return new Date().getTime(); };
  var navigationStart = (performance.timing || {}).navigationStart || dateNow();
  return function () {
    return dateNow() - navigationStart;
  };
}());

present.performanceNow = performance.now;
present.noConflict = function () {
  performance.now = present.performanceNow;
};
present.conflict = function () {
  performance.now = present;
};
present.conflict();

module.exports = present;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],63:[function(require,module,exports){
// Export ./lib/randgen

module.exports = require("./lib/randgen");

},{"./lib/randgen":64}],64:[function(require,module,exports){
/*jslint indent: 2, plusplus: true, sloppy: true */
// Generate uniformly distributed random numbers
// Gives a random number on the interval [min, max).
// If discrete is true, the number will be an integer.
function runif(min, max, discrete) {
  if (min === undefined) {
    min = 0;
  }
  if (max === undefined) {
    max = 1;
  }
  if (discrete === undefined) {
    discrete = false;
  }
  if (discrete) {
    return Math.floor(runif(min, max, false));
  }
  return Math.random() * (max - min) + min;
}

// Generate normally-distributed random nubmers
// Algorithm adapted from:
// http://c-faq.com/lib/gaussian.html
function rnorm(mean, stdev) {
  var u1, u2, v1, v2, s;
  if (mean === undefined) {
    mean = 0.0;
  }
  if (stdev === undefined) {
    stdev = 1.0;
  }
  if (rnorm.v2 === null) {
    do {
      u1 = Math.random();
      u2 = Math.random();

      v1 = 2 * u1 - 1;
      v2 = 2 * u2 - 1;
      s = v1 * v1 + v2 * v2;
    } while (s === 0 || s >= 1);

    rnorm.v2 = v2 * Math.sqrt(-2 * Math.log(s) / s);
    return stdev * v1 * Math.sqrt(-2 * Math.log(s) / s) + mean;
  }

  v2 = rnorm.v2;
  rnorm.v2 = null;
  return stdev * v2 + mean;
}

rnorm.v2 = null;

// Generate Chi-square distributed random numbers
function rchisq(degreesOfFreedom) {
  if (degreesOfFreedom === undefined) {
    degreesOfFreedom = 1;
  }
  var i, z, sum = 0.0;
  for (i = 0; i < degreesOfFreedom; i++) {
    z = rnorm();
    sum += z * z;
  }

  return sum;
}

// Generate Poisson distributed random numbers
function rpoisson(lambda) {
  if (lambda === undefined) {
    lambda = 1;
  }
  var l = Math.exp(-lambda),
    k = 0,
    p = 1.0;
  do {
    k++;
    p *= Math.random();
  } while (p > l);

  return k - 1;
}

// Generate Cauchy distributed random numbers
function rcauchy(loc, scale) {
  if (loc === undefined) {
    loc = 0.0;
  }
  if (scale === undefined) {
    scale = 1.0;
  }
  var n2, n1 = rnorm();
  do {
    n2 = rnorm();
  } while (n2 === 0.0);

  return loc + scale * n1 / n2;
}

// Bernoulli distribution: gives 1 with probability p
function rbernoulli(p) {
  return Math.random() < p ? 1 : 0;
}

// Vectorize a random generator
function vectorize(generator) {
  return function () {
    var n, result, i, args;
    args = [].slice.call(arguments)
    n = args.shift();
    result = [];
    for (i = 0; i < n; i++) {
      result.push(generator.apply(this, args));
    }
    return result;
  };
}

// Generate a histogram from a list of numbers
function histogram(data, binCount) {
  binCount = binCount || 10;

  var bins, i, scaled,
    max = Math.max.apply(this, data),
    min = Math.min.apply(this, data);

  // edge case: max == min
  if (max === min) {
    return [data.length];
  }

  bins = [];

  // zero each bin
  for (i = 0; i < binCount; i++) {
    bins.push(0);
  }

  for (i = 0; i < data.length; i++) {
    // scale it to be between 0 and 1
    scaled = (data[i] - min) / (max - min);

    // scale it up to the histogram size
    scaled *= binCount;

    // drop it in a bin
    scaled = Math.floor(scaled);

    // edge case: the max
    if (scaled === binCount) { scaled--; }

    bins[scaled]++;
  }

  return bins;
}

/**
 * Get a random element from a list
 */
function rlist(list) {
  return list[runif(0, list.length, true)];
}

exports.runif = runif;
exports.rnorm = rnorm;
exports.rchisq = rchisq;
exports.rpoisson = rpoisson;
exports.rcauchy = rcauchy;
exports.rbernoulli = rbernoulli;
exports.rlist = rlist;

exports.rvunif = vectorize(runif);
exports.rvnorm = vectorize(rnorm);
exports.rvchisq = vectorize(rchisq);
exports.rvpoisson = vectorize(rpoisson);
exports.rvcauchy = vectorize(rcauchy);
exports.rvbernoulli = vectorize(rbernoulli);
exports.rvlist = vectorize(rlist);

exports.histogram = histogram;

},{}],65:[function(require,module,exports){
'use strict';
var ansiRegex = require('ansi-regex')();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};

},{"ansi-regex":47}],66:[function(require,module,exports){
/* jshint node: true */
"use strict";
function makeArrayFrom(obj) {
  return Array.prototype.slice.apply(obj);
}
var
  PENDING = "pending",
  RESOLVED = "resolved",
  REJECTED = "rejected";

function SynchronousPromise(handler) {
  this.status = PENDING;
  this._continuations = [];
  this._parent = null;
  this._paused = false;
  if (handler) {
    handler.call(
      this,
      this._continueWith.bind(this),
      this._failWith.bind(this)
    );
  }
}

function looksLikeAPromise(obj) {
  return obj && typeof (obj.then) === "function";
}

SynchronousPromise.prototype = {
  then: function (nextFn, catchFn) {
    var next = SynchronousPromise.unresolved()._setParent(this);
    if (this._isRejected()) {
      if (this._paused) {
        this._continuations.push({
          promise: next,
          nextFn: nextFn,
          catchFn: catchFn
        });
        return next;
      }
      if (catchFn) {
        try {
          var catchResult = catchFn(this._error);
          if (looksLikeAPromise(catchResult)) {
            this._chainPromiseData(catchResult, next);
            return next;
          } else {
            return SynchronousPromise.resolve(catchResult)._setParent(this);
          }
        } catch (e) {
          return SynchronousPromise.reject(e)._setParent(this);
        }
      }
      return SynchronousPromise.reject(this._error)._setParent(this);
    }
    this._continuations.push({
      promise: next,
      nextFn: nextFn,
      catchFn: catchFn
    });
    this._runResolutions();
    return next;
  },
  catch: function (handler) {
    if (this._isResolved()) {
      return SynchronousPromise.resolve(this._data)._setParent(this);
    }
    var next = SynchronousPromise.unresolved()._setParent(this);
    this._continuations.push({
      promise: next,
      catchFn: handler
    });
    this._runRejections();
    return next;
  },
  pause: function () {
    this._paused = true;
    return this;
  },
  resume: function () {
    var firstPaused = this._findFirstPaused();
    if (firstPaused) {
      firstPaused._paused = false;
      firstPaused._runResolutions();
      firstPaused._runRejections();
    }
    return this;
  },
  _findAncestry: function () {
    return this._continuations.reduce(function (acc, cur) {
      if (cur.promise) {
        var node = {
          promise: cur.promise,
          children: cur.promise._findAncestry()
        };
        acc.push(node);
      }
      return acc;
    }, []);
  },
  _setParent: function (parent) {
    if (this._parent) {
      throw new Error("parent already set");
    }
    this._parent = parent;
    return this;
  },
  _continueWith: function (data) {
    var firstPending = this._findFirstPending();
    if (firstPending) {
      firstPending._data = data;
      firstPending._setResolved();
    }
  },
  _findFirstPending: function () {
    return this._findFirstAncestor(function (test) {
      return test._isPending && test._isPending();
    });
  },
  _findFirstPaused: function () {
    return this._findFirstAncestor(function (test) {
      return test._paused;
    });
  },
  _findFirstAncestor: function (matching) {
    var test = this;
    var result;
    while (test) {
      if (matching(test)) {
        result = test;
      }
      test = test._parent;
    }
    return result;
  },
  _failWith: function (error) {
    var firstRejected = this._findFirstPending();
    if (firstRejected) {
      firstRejected._error = error;
      firstRejected._setRejected();
    }
  },
  _takeContinuations: function () {
    return this._continuations.splice(0, this._continuations.length);
  },
  _runRejections: function () {
    if (this._paused || !this._isRejected()) {
      return;
    }
    var
      error = this._error,
      continuations = this._takeContinuations(),
      self = this;
    continuations.forEach(function (cont) {
      if (cont.catchFn) {
        var catchResult = cont.catchFn(error);
        self._handleUserFunctionResult(catchResult, cont.promise);
      } else {
        cont.promise.reject(error);
      }
    });
  },
  _runResolutions: function () {
    if (this._paused || !this._isResolved()) {
      return;
    }
    var continuations = this._takeContinuations();
    if (looksLikeAPromise(this._data)) {
      return this._handleWhenResolvedDataIsPromise(this._data);
    }
    var data = this._data;
    var self = this;
    continuations.forEach(function (cont) {
      if (cont.nextFn) {
        try {
          var result = cont.nextFn(data);
          self._handleUserFunctionResult(result, cont.promise);
        } catch (e) {
          self._handleResolutionError(e, cont);
        }
      } else if (cont.promise) {
        cont.promise.resolve(data);
      }
    });
  },
  _handleResolutionError: function (e, continuation) {
    this._setRejected();
    if (continuation.catchFn) {
      try {
        continuation.catchFn(e);
        return;
      } catch (e2) {
        e = e2;
      }
    }
    if (continuation.promise) {
      continuation.promise.reject(e);
    }
  },
  _handleWhenResolvedDataIsPromise: function (data) {
    var self = this;
    return data.then(function (result) {
      self._data = result;
      self._runResolutions();
    }).catch(function (error) {
      self._error = error;
      self._setRejected();
      self._runRejections();
    });
  },
  _handleUserFunctionResult: function (data, nextSynchronousPromise) {
    if (looksLikeAPromise(data)) {
      this._chainPromiseData(data, nextSynchronousPromise);
    } else {
      nextSynchronousPromise.resolve(data);
    }
  },
  _chainPromiseData: function (promiseData, nextSynchronousPromise) {
    promiseData.then(function (newData) {
      nextSynchronousPromise.resolve(newData);
    }).catch(function (newError) {
      nextSynchronousPromise.reject(newError);
    });
  },
  _setResolved: function () {
    this.status = RESOLVED;
    if (!this._paused) {
      this._runResolutions();
    }
  },
  _setRejected: function () {
    this.status = REJECTED;
    if (!this._paused) {
      this._runRejections();
    }
  },
  _isPending: function () {
    return this.status === PENDING;
  },
  _isResolved: function () {
    return this.status === RESOLVED;
  },
  _isRejected: function () {
    return this.status === REJECTED;
  }
};

SynchronousPromise.resolve = function (result) {
  return new SynchronousPromise(function (resolve, reject) {
    if (looksLikeAPromise(result)) {
      result.then(function (newResult) {
        resolve(newResult);
      }).catch(function (error) {
        reject(error);
      });
    } else {
      resolve(result);
    }
  });
};

SynchronousPromise.reject = function (result) {
  return new SynchronousPromise(function (resolve, reject) {
    reject(result);
  });
};

SynchronousPromise.unresolved = function () {
  return new SynchronousPromise(function (resolve, reject) {
    this.resolve = resolve;
    this.reject = reject;
  });
};

SynchronousPromise.all = function () {
  var args = makeArrayFrom(arguments);
  if (Array.isArray(args[0])) {
    args = args[0];
  }
  if (!args.length) {
    return SynchronousPromise.resolve([]);
  }
  return new SynchronousPromise(function (resolve, reject) {
    var
      allData = [],
      numResolved = 0,
      doResolve = function () {
        if (numResolved === args.length) {
          resolve(allData);
        }
      },
      rejected = false,
      doReject = function (err) {
        if (rejected) {
          return;
        }
        rejected = true;
        reject(err);
      };
    args.forEach(function (arg, idx) {
      SynchronousPromise.resolve(arg).then(function (thisResult) {
        allData[idx] = thisResult;
        numResolved += 1;
        doResolve();
      }).catch(function (err) {
        doReject(err);
      });
    });
  });
};

/* jshint ignore:start */
if (Promise === SynchronousPromise) {
  throw new Error("Please use SynchronousPromise.installGlobally() to install globally");
}
var RealPromise = Promise;
SynchronousPromise.installGlobally = function(__awaiter) {
  if (Promise === SynchronousPromise) {
    return __awaiter;
  } 
  var result = patchAwaiterIfRequired(__awaiter);
  Promise = SynchronousPromise;
  return result;
};

SynchronousPromise.uninstallGlobally = function() {
  if (Promise === SynchronousPromise) {
    Promise = RealPromise;
  }
};

function patchAwaiterIfRequired(__awaiter) {
  if (typeof(__awaiter) === "undefined" || __awaiter.__patched) {
    return __awaiter;
  }
  var originalAwaiter = __awaiter;
  __awaiter = function() {
    var Promise = RealPromise;
    originalAwaiter.apply(this, makeArrayFrom(arguments));
  };
  __awaiter.__patched = true;
  return __awaiter;
}
/* jshint ignore:end */

module.exports = {
  SynchronousPromise: SynchronousPromise
};
},{}],67:[function(require,module,exports){
"use strict";

// Plugin to add 'property' (as in personal property) property to Players when they are initialized. Meant to be used for
// simulations involving personal posessions, for instance economic simulations.

// NashJS engine components
var Engine = require("../lib/engine")

// Game state
var { registry, gamePopulation } = Engine.Backend.State;

// Let's add some PlayerList functionality
var { PlayerList } = Engine.Backend.Classes;


var BalanceSheet = function() {

	// Variables to store settings, and defaults
	var settings = {
		addBalanceSheetOnClaim: true,
		cleanZeros: true,
		negativeAssets: false
	}
	//TODO make negativeAssets (and negativeLiabilities) work


	// Assets Classes

	// Claim parent class
	var Claim = function(claimant, amount) {
		// Add balance sheet if necessary and permitted
		if (!claimant.balanceSheet) {
			if (settings.addBalanceSheetOnClaim) addEntries(registry.players[claimant.id()])
			// Fail if not permitted to add necessary balance sheet.
			else return false;
		}

		this.amount = amount;
		this.claimant = claimant
		claimant.endow(this)
		return true;
	}

	// End ownership claim
	Claim.prototype.erase = function() {
		this.claimant.revoke(this)
		this.claimant = null;
		this.amount = 0
	}

	// Merge claims if they're the same family but different amounts
	Claim.prototype.merge = function(otherClaim) {
		if (this.claimant !== otherClaim.claimant) return false
		// Add amounts
		this.amount = this.amount + otherClaim.amount

		// Remove from balance sheet
		otherClaim.erase();
	}

	// Split this into two separate claims, with different amounts
	Claim.prototype.split = function(newAmount) {
		var clone = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
		clone.amount = newAmount;
		this.amount = this.amount - newAmount;
		this.claimant.endow(clone, false)
		return clone;
	}

	// Transfer to new owner
	Claim.prototype.transfer = function(newClaimant, amount = "all") {
		// Add balance sheet if necessary and permitted
		if (!newClaimant.balanceSheet) {
			if (settings.addBalanceSheetOnClaim) addEntries(registry.players[newClaimant.id()])
			// Fail if not permitted to add necessary balance sheet.
			else return false;
		}

		// Transfer all of it
		if (amount == "all" || amount == this.amount) {
			var oldClaimant = this.claimant;
			this.claimant.revoke(this);
			this.claimant = newClaimant;
			newClaimant.endow(this);

		}
		// or only a portion
		else {
			var newClaim = this.split(amount);
			newClaim.transfer(newClaimant, "all")
			cleanAsset(this)
		}

	}



	// Claims on real things (like cars, houses, gold)
	var RealClaim = function(claimant, good, amount) {
		if (!Claim.call(this, claimant, amount)) return false;
		this.good = good;
	}
	RealClaim.prototype = Object.create(Claim.prototype)
	RealClaim.prototype.constructor = RealClaim

	// Lose value by percentage
	RealClaim.prototype.depreciate = function(rate = .1) {
		this.amount = this.amount * (1 - rate)
	}

	// Add good enforcement to merge
	RealClaim.prototype.merge = function(otherClaim) {
		if (this.good === otherClaim.good) return Claim.prototype.merge.call(this, otherClaim);
	}

	// Replace player object with id when stringifying
	RealClaim.prototype.toJSON = function() {
		return {
			claimant: this.claimant.id(),
			good: this.good,
			amount: this.amount
		}
	}

	// Claims on other entities with balance sheets
	var FinancialClaim = function(claimant, claimed, amount, instrument = "Debt") {
		// Add balance sheet if necessary and permitted
		if (!claimed.balanceSheet) {
			if (settings.addBalanceSheetOnClaim) addEntries(registry.players[claimed.id()])
			// Fail if not permitted to add necessary balance sheet.
			else return false;
		}
		this.claimed = claimed;
		this.instrument = instrument;

		if (!Claim.call(this, claimant, amount)) return false;

		claimed.indebt(this)
	}
	FinancialClaim.prototype = Object.create(Claim.prototype)
	FinancialClaim.prototype.constructor = FinancialClaim

	// Add to erase function, to erase from claimed's balance sheet too
	FinancialClaim.prototype.erase = function() {
		var bs = registry.players[this.claimed.id()].balanceSheet.liabilities
		bs.splice(bs.indexOf(this), 1)
		this.claimed = null;

		return Claim.prototype.erase.call(this)
	}

	// Add claimed enforcement to merge
	FinancialClaim.prototype.merge = function(otherClaim) {
		if (this.claimed === otherClaim.claimed) return Claim.prototype.merge.call(this, otherClaim);
	}


	// Add to split function, to split on claimed's balance sheet too
	FinancialClaim.prototype.split = function(newAmount) {
		var clone = Claim.prototype.split.call(this, newAmount);
		clone.claimed.indebt(clone, false);
		return clone;
	}

	// Replace player object with id when stringifying
	FinancialClaim.prototype.toJSON = function() {
		return {
			claimant: this.claimant.id(),
			claimed: this.claimed.id(),
			instrument: this.instrument,
			amount: this.amount
		}
	}


	// Clean the similar claims on the claimant supplied
	var cleanAsset = function(claim) {
		var bs = registry.players[claim.claimant.id()].balanceSheet.assets;

		var dirty = bs.filter(function(entry) {
			return (entry !== claim && entry.good === claim.good && entry.instrument === claim.instrument);
		})

		dirty.forEach(function(dirt) {
			claim.merge(dirt)
		})

		if (settings.cleanZeros && claim.amount == 0) claim.erase()
	}

	var cleanLiability = function(claim) {
		var bs = registry.players[claim.claimed.id()].balanceSheet.liabilities;

		var dirty = bs.filter(function(entry) {
			return (entry !== claim && entry.claimant === claim.claimant && entry.instrument === claim.instrument);
		})

		dirty.forEach(function(dirt) {
			claim.merge(dirt)
		})

		if (settings.cleanZeros && claim.amount == 0) claim.erase
	}



	// Add balance sheet object and methods to player.
	var addEntries = function(player) {

		//_player properties/methods
		player.balanceSheet = { assets: [], liabilities: [] }

		/*
		var lookup = function(type) {
			this.reduce(function(accumulator, value) {
				if (type === value.good) accumulator += value.amount
				else if (type instanceof Object && type.instrument == value.instrument && (type.claimed === value.claimed))
					accumulator += value.amount
				return accumulator;
			}, 0)
		}
		player.balanceSheet.assets.lookup = lookup;
		player.balanceSheet.liabilities.lookup = lookup;
		*/

		player.netWorth = function() {

			var assets = this.balanceSheet.assets.reduce(function(accumulator, currentValue) {
				return accumulator + currentValue.amount
			}, 0);

			var liabilities = this.balanceSheet.liabilities.reduce(function(accumulator,
				currentValue) {
				return accumulator + currentValue.amount
			}, 0);

			return assets - liabilities;
		}

		// User interface
		player.interface.balanceSheet = function() {
			return JSON.parse(JSON.stringify(registry.players[player.id].balanceSheet));
		}

		player.interface.netWorth = function() {
			return registry.players[player.id].netWorth();
		}

		// TODO validate object.
		player.interface.endow = function(asset, clean = true) {
			if (asset instanceof Claim) {
				registry.players[player.id].balanceSheet.assets.push(asset);
				if (clean) cleanAsset(asset);
			}
		}

		player.interface.indebt = function(liability, clean = true) {
			if (liability instanceof FinancialClaim) {
				registry.players[player.id].balanceSheet.liabilities.push(
					liability);
				if (clean) cleanLiability(liability);
			}
		}

		player.interface.revoke = function(asset) {
			if (asset instanceof Claim) {
				var bs = registry.players[player.id].balanceSheet.assets
				bs.splice(bs.indexOf(asset), 1)
			}
		}

		// TODO convert this over
		player.interface.lend = function(borrower, amount, instrument = "Debt") {
			return new FinancialClaim(player.interface, borrower, amount, instrument)
		}
	}



	// The plugin object.
	var Plugin = {
		name: "balance-sheet-complex",

		settings: function(parameters = {}) {
			Object.assign(settings, parameters)
		},

		// Option to initialize by creating 'property' for a group of players.
		init(players = []) {
			// Add some playerlist functionality
			PlayerList.prototype.balanceSheets = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet();
					else return null;
				})
			};

			PlayerList.prototype.assets = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet().assets;
					else return null;
				})
			};

			PlayerList.prototype.liabilities = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet().liabilities;
					else return null;
				})
			};

			PlayerList.prototype.netWorth = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.netWorth();
					else return null;
				})
			};

			PlayerList.prototype.zeroBalanceSheets = function() {
				this.forEach(function(player) {
					addEntries(player)
				});
				return this;
			}

			// Add bs for specified players
			players.forEach(function(player) {
				addEntries(registry.players[player.id()]);
			})
		},

		// If we've init-ed alredy, just add bs's to the current player list if they don't have already
		require(players = []) {
			players.forEach(function(player) {
				if (!player.balanceSheet) addEntries(registry.players[player.id()]);
			});
		},

		stop() {
			// remove prototype addEntries
			delete PlayerList.prototype.balanceSheets;
			delete PlayerList.prototype.assets;
			delete PlayerList.prototype.liabilities;
			delete PlayerList.prototype.netWorth;

			// delete balance sheet properties from every player and interface.
			gamePopulation().forEach(function(player) {
				delete player.balanceSheet;
				delete player.netWorth;
				delete player.interface.balanceSheet;
				delete player.interface.netWorth;
				delete player.interface.endowAssets;
				delete player.interface.lend;
			})
		},

		// Public classes for asset/liability
		publicIfActive: {
			RealClaim,
			FinancialClaim
		},

		// create property and interface function when player is created
		'player-create': addEntries,

		// Blank property when player is re-initialized
		"player-reinitialize" (player) {
			player.balanceSheet = { assets: [], liabilities: [] }
		}
	}

	return Plugin;
}



module.exports = BalanceSheet;

},{"../lib/engine":6}],68:[function(require,module,exports){
"use strict";

// Plugin to add 'property' (as in personal property) property to Players when they are initialized. Meant to be used for
// simulations involving personal posessions, for instance economic simulations.

// NashJS engine components
var Engine = require("../lib/engine")

// Game state
var { registry, gamePopulation } = Engine.Backend.State;

// Let's add some PlayerList functionality
var { PlayerList } = Engine.Backend.Classes;


var BalanceSheet = function() {

	var addEntries = function(player) {
		//_player properties/methods
		player.balanceSheet = { assets: {}, liabilities: {} }

		player.netWorth = function() {

			var assets = Object.entries(this.balanceSheet.assets).reduce(function(accumulator, currentValue) {
				return accumulator + currentValue[1]
			}, 0);

			var liabilities = Object.entries(this.balanceSheet.liabilities).reduce(function(accumulator,
				currentValue) {
				return accumulator + currentValue[1]
			}, 0);

			return assets - liabilities;
		}

		// User interface
		player.interface.balanceSheet = function() {
			return JSON.parse(JSON.stringify(registry.players[player.id].balanceSheet));
		}

		player.interface.netWorth = function() {
			return registry.players[player.id].netWorth();
		}

		// TODO validate object. Should be of form {apples:2, dogs:1}
		player.interface.endowAssets = function(assetObject) {

			Object.assign(registry.players[player.id].balanceSheet.assets, assetObject)
		}

		player.interface.lend = function(loanObject) {
			//TODO validate object. Should be of form {player1:{mortgage:10}}
			var lender = registry.players[player.id].balanceSheet.assets
			Object.entries(loanObject).forEach(function(loanTo) {
				var debts;
				lender[loanTo[0]] ?
					debts = lender[loanTo[0]] : debts = lender[loanTo[0]] = {};

				Object.entries(loanTo[1]).forEach(function(newLoan) {
					debts[newLoan[0]] ? debts[newLoan[0]] += newLoan[1] : debts[newLoan[0]] = newLoan[1]
					registry.players[loanTo[0]].balanceSheet.liabilities[newLoan[0]] ? registry.players[loanTo[0]].balanceSheet
						.liabilities[newLoan[0]] += newLoan[1] : registry.players[loanTo[0]].balanceSheet.liabilities[
							newLoan[0]] = newLoan[1];
				});
			});
		}
	}



	// The plugin object.
	var Plugin = {
		name: "balance-sheet",

		// Option to initialize by creating 'property' for a group of players.
		init(players = []) {
			// Add some playerlist functionality
			PlayerList.prototype.balanceSheets = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet();
					else return null;
				})
			};

			PlayerList.prototype.assets = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet().assets;
					else return null;
				})
			};

			PlayerList.prototype.liabilities = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.interface.balanceSheet().liabilities;
					else return null;
				})
			};

			PlayerList.prototype.netWorth = function() {
				return this.map(function(player) {
					if (player.balanceSheet) return player.netWorth();
					else return null;
				})
			};

			PlayerList.prototype.zeroBalanceSheets = function() {
				this.forEach(function(player) {
					addEntries(player)
				});
				return this;
			}

			// Add bs for specified players
			players.forEach(function(player) {
				addEntries(registry.players[player.id()]);
			})
		},

		// If we've init-ed alredy, just add bs's to the current player list if they don't have already
		require(players = []) {
			players.forEach(function(player) {
				if (!player.balanceSheet) addEntries(registry.players[player.id()]);
			});
		},

		stop() {
			// remove prototype addEntries
			delete PlayerList.prototype.balanceSheets;
			delete PlayerList.prototype.assets;
			delete PlayerList.prototype.liabilities;
			delete PlayerList.prototype.netWorth;

			// delete balance sheet properties from every player and interface.
			gamePopulation().forEach(function(player) {
				delete player.balanceSheet;
				delete player.netWorth;
				delete player.interface.balanceSheet;
				delete player.interface.netWorth;
				delete player.interface.endowAssets;
				delete player.interface.lend;
			})
		},

		// create property and interface function when player is created
		'player-create': addEntries,

		// Blank property when player is re-initialized
		"player-reinitialize" (player) {
			player.balanceSheet = { assets: [], liabilities: [] }
		}
	}

	return Plugin;
}


module.exports = BalanceSheet;

},{"../lib/engine":6}],69:[function(require,module,exports){
module.exports = {
	"condense-next-summary-preview": false,
	"clear-history-on-play": true,
	"init-log-level": "info",
	"init-sync-mode": "async"
}

},{}],70:[function(require,module,exports){
"use strict";

// game pieces
var prisonerDilemma = require("./iterated-prisoner-dilemma").createGenerator;
var roundRobin = require("./round-robin");

// NashJS engine components
var Engine = require("../lib/engine")

var { Loop } = Engine.Frontend.Playables;

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")
var { generatePopulation } = Engine.Backend.HelperFunctions("tournament");

// Population interfaces
var { Population } = Engine.Frontend.Population;


var AxelrodTournament = gameWrapper(function(players, parameters = {}) {
	var { generatePlayers = true, repeats = 5, gameLength = 200 } = parameters;

	// Either create an entire population
	if (generatePlayers) {
		// Get two sets of players. The second is so players can play themselves
		players = generatePopulation();
		var copies = generatePopulation();
		parameters.copies = copies;
	}

	// or use the supplied players
	else if (players) {
		// do nothing
	} else {
		// or use the players already present
		players = Population().onlyAlive().onlyAvailable();
	}

	// assign parameters and generate the game
	parameters.initializePlayers = players;
	var iteration = roundRobin(players, prisonerDilemma(gameLength), parameters);

	return Loop(iteration, repeats, { id: "Axelrod-Tournament" });
});



module.exports = AxelrodTournament;

},{"../lib/engine":6,"./iterated-prisoner-dilemma":75,"./round-robin":81}],71:[function(require,module,exports){
"use strict";

//base game
var TwoPlayerNormal = require("./simple-normal");

// helper functions
var { gameWrapper } = require("../lib/engine").Backend.HelperFunctions("stock-games")


// Battle of the Sexes
var BattleOfTheSexes = gameWrapper(function(players, parameters = {}) {
	parameters.id = parameters.id || "Battle-of-the-Sexes";

	var choices = [
		["Opera", "Football"],
		["Opera", "Football"]
	];
	var payoffs = [
		[
			[2, 1],
			[0, 0]
		],
		[
			[0, 0],
			[1, 2]
		]
	];

	return TwoPlayerNormal(players, choices, payoffs, parameters);
});

module.exports = BattleOfTheSexes;

},{"../lib/engine":6,"./simple-normal":82}],72:[function(require,module,exports){
"use strict";

// NashJS engine components
var Engine = require("../lib/engine")

// User data
var { Population } = Engine.Frontend

// Playables
var { Lambda, Simultaneous, Sequence, Loop } = Engine.Frontend.Playables;

// Helper functions
var { isFunction } = Engine.Backend.HelperFunctions("general");


//Cultural evolution
//
// TODO: add instructions here
function CulturalEvolution(gameGenerator, numLoops = 1, {
	id = "CulturalEvolution",
	gameProbability = .25,
	pairProbability = .25,
	generatePopulation = null,
	loop = true
} = {}) {

	if (loop && isNaN(numLoops)) throw new Error("CulturalEvolution argument 'numLoops must be a number");
	if (!isFunction(gameGenerator)) throw new Error(
		"CulturalEvolution argument 'gameGenerator' must be a function");
	if (isNaN(gameProbability) || gameProbability < 0 || gameProbability > 1) throw new Error(
		"CulturalEvolution argument 'gameProbability' must be between 0 and 1");
	if (isNaN(pairProbability) || pairProbability < 0 || pairProbability > 1) throw new Error(
		"CulturalEvolution argument 'pairProbability' must be between 0 and 1");

	// Generate population if user wants us to.
	if (isFunction(generatePopulation)) generatePopulation();

	//Reset the scores each round.
	var ResetScores = Lambda(function() {
		Population().onlyAlive().resetScores();
	});

	// Calculate number of matches
	var n = Math.floor(Population().onlyAlive().length * gameProbability);

	// Create matches.
	var matches = [...Array(n)]
	for (var i = 0; i < n; i++) {
		matches[i] = gameGenerator();
		if (!matches[i].play) throw new Error("CulturalEvolution argument 'gameGenerator' must return a Playable");
	}

	//Run all matches simultaneously
	var Round = Simultaneous(matches);

	//Calculate number of pairings
	var n = Math.floor(Population().onlyAlive().length * pairProbability)

	//Create pairings
	var pairings = [...Array(n)];
	for (i = 0; i < n; i++) {

		pairings[i] = Lambda(function() {

			//Find some available players
			var pool = Population().onlyAlive().onlyAvailable();
			var p1 = pool[Math.floor(Math.random() * pool.length)];
			var p2 = pool[Math.floor(Math.random() * pool.length)];

			//Mark them busy
			p1.busy();
			p2.busy();

			// Assign strategy of player with higher score
			if (p1.score() > p2.score()) p2.assign(p1.strategy());
			else if (p1.score() == p2.score()) null;
			else p1.assign(p2.strategy());

			//Return value of player ids, so the log makes some sense.
			return [p1.id(), p2.id()];
		});
	}

	// Run pairings simultaneously
	var Pairing = Simultaneous(pairings);

	// After pairings, mark all players as available.
	var ReleasePlayers = Lambda(function() {
		Population().onlyAlive().release();
	});

	// Define the game.
	Round(ResetScores);
	Pairing(Round);
	ReleasePlayers(Pairing);
	var Iteration = Sequence(ResetScores, ReleasePlayers);

	// User can set loop parameter to false, to avoid wrapping this in a loop.
	if (loop)
		var CE = Loop(Iteration, numLoops, { playableParameters: { initializePlayers: true } });
	else
		var CE = Iteration;

	return CE;
}

//TODO: fix parameters. User should be able to supply parameters which either
// end up as parameters for the Loop or the Sequence.


module.exports = CulturalEvolution;

},{"../lib/engine":6}],73:[function(require,module,exports){
"use strict";

// base game
var TwoPlayerNormal = require("./simple-normal").TwoPlayerNormal;

// NashJS engine components
var Engine = require("../lib/engine")

// Nash engine components
var { Sequence, Lambda } = Engine.Frontend.Playables;

// Game state
var { registry } = Engine.Backend.State

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// We'll need the 'balance-sheet' plugin
var PluginManager = Engine.Backend.PluginManager;

function invertTerms(termsOfTrade) {
	var inverse = {}
	Object.entries(termsOfTrade).forEach(function(term) {
		if (term[0] == "borrow") {
			inverse.lend = term[1]
		} else if (term[0] == "lend") {
			inverse.borrow = term[1]
		} else {
			inverse[term[0]] = term[1] * -1
		}
	});
	return inverse;
}

// termsOfTrade should be an object reflecting the outcomes for player 1.
// Example {apple:2, orange:-2}. To borrow or lend, create a sub-object describing the loan terms.
// eg {apple:2, borrow:{IOU:5}}, or {couch:-10, lend:{'credit card':50}}
var Exchange = gameWrapper(function(players, termsOfTrade = {}, parameters = {}) {
	var { utilityFunctions, utilityMode = "absolute", initialEndowment = [{}, {}] } = parameters //utilityFunctions should be an array of 2 functions, which take a results object and return a change in utility
	parameters.id = "Exchange" || parameters.id;




	// To play this game, players will need a balance sheet. This plugin will add balance sheets to the players,
	// as well as ensure that new players are created with one, and that they are re-initialized properly.
	var balanceSheet = PluginManager.package("balance-sheet-complex").require(players);
	balanceSheet.settings({ cleanZeros: false })

	var p1 = registry.players[players[0].id()];
	var p2 = registry.players[players[1].id()];

	// Do initial endowments if there are any. Format same as for terms of trade.
	initialEndowment.forEach(function(endowment, index) {
		var player = players[index]
		var invertPlayer = players[Number(!index)]
		Object.entries(endowment).forEach(function(term) {
			if (term[0] == "borrow") {
				var loanTerms = Object.entries(term[1])[0]
				new balanceSheet.FinancialClaim(invertPlayer, player, loanTerms[1], loanTerms[0])
			} else if (term[0] == "lend") {
				var loanTerms = Object.entries(term[1])[0]
				new balanceSheet.FinancialClaim(player, invertPlayer, loanTerms[1], loanTerms[0])
			} else {
				new balanceSheet.RealClaim(player, term[0], term[1])
			}
		})
	})

	// The actual playable
	var Decision = TwoPlayerNormal(players, [
		["Accept", "Reject"],
		["Accept", "Reject"]
	], null, {
		id: "Decision",
		informationFilter: function(info) { //TODO might need to wrap user-supplied informationFilter?
			info.termsOfTrade = {
				[p1.id]: termsOfTrade,
				[p2.id]: invertTerms(termsOfTrade)
			}
			return info;
		}
	})

	// Distribute the goods
	var Distribute = Lambda(function() {

		var results = [];

		Object.entries(termsOfTrade).forEach(function(term) {
			if (term[0] == "borrow") {
				var loanTerms = Object.entries(term[1])[0]
				var loan = new balanceSheet.FinancialClaim(p2.interface, p1.interface, loanTerms[1], loanTerms[0])

				results.push({
					player: p1.id,
					borrow: {
						[loanTerms[0]]: loanTerms[1]
					}
				});

				results.push({
					player: p2.id,
					lend: {
						[p1.id]: {
							[loanTerms[0]]: loanTerms[1]
						}
					}
				});

			} else if (term[0] == "lend") {
				var loanTerms = Object.entries(term[1])[0]
				var loan = new balanceSheet.FinancialClaim(p1.interface, p2.interface, loanTerms[1], loanTerms[0])

				results.push({
					player: p2.id,
					borrow: {
						[loanTerms[0]]: loanTerms[1]
					}
				});

				results.push({
					player: p1.id,
					lend: {
						[p2.id]: {
							[loanTerms[0]]: loanTerms[1]
						}
					}
				});

			} else {
				var good = new balanceSheet.RealClaim(p1.interface, term[0], 0)
				good.transfer(p2.interface, term[1] * -1)

				results.push({ player: p1.id, [term[0]]: term[1] });
				results.push({ player: p2.id, [term[0]]: -1 * term[1] });
			}
		});


		if (utilityFunctions) {

			p1.score = utilityMode.toLowerCase() == "relative" ? p1.score + utilityFunctions[0](results) :
				utilityFunctions[0](results)
			p2.score = utilityMode.toLowerCase() == "relative" ? p2.score + utilityFunctions[1](results) :
				utilityFunctions[1](results)
		}

		return results;
	}, { id: "Distribution" });

	//But only do it if the trade goes through.
	Distribute(Decision.Accept.Accept())



	return Sequence(Decision, Distribute, parameters);
}, {
	argumentValidator(players, termsOfTrade) {
		// TODO: validate parameters
		return true;
	}

});

module.exports = Exchange;

},{"../lib/engine":6,"./simple-normal":82}],74:[function(require,module,exports){
"use strict";

var StockGames = {
	//Game skeletons
	"Two-Player Normal": require("./simple-normal").TwoPlayerNormal,
	"Normal": require("./simple-normal").Normal,
	"Simple Zero-Sum": require("./simple-zero-sum"),

	// Classic games
	"Battle Of The Sexes": require("./battle-of-the-sexes"),
	"Matching Pennies": require("./matching-pennies"),
	"Prisoner's Dilemma": require("./prisoner-dilemma"),
	"Rock-Paper-Scissors": require("./rock-paper-scissors"),

	// Iterated games
	"Iterated": require("./iterated"),
	"Iterated Prisoner's Dilemma": require("./iterated-prisoner-dilemma"),

	// Evolutionary games
	"Cultural Evolution": require("./cultural-evolution"),

	//Tournaments
	"Round Robin": require("./round-robin"),
	"Axelrod Tournament": require("./axelrod-tournament"),

	// Probability Theory
	"Monty Hall": require("./monty-hall"),

	//Neoclassical economics
	"Exchange": require("./exchange-complex"),

	// Function to display loaded query shortcuts.
	queries() {
		return Object.keys(registry.queries).map(function(query) {
			return {
				[query]: registry.queries[query].description
			}
		})
	}
};



module.exports = StockGames;

},{"./axelrod-tournament":70,"./battle-of-the-sexes":71,"./cultural-evolution":72,"./exchange-complex":73,"./iterated":76,"./iterated-prisoner-dilemma":75,"./matching-pennies":77,"./monty-hall":78,"./prisoner-dilemma":79,"./rock-paper-scissors":80,"./round-robin":81,"./simple-normal":82,"./simple-zero-sum":83}],75:[function(require,module,exports){
"use strict";

// Base game
var prisonerDilemma = require("./prisoner-dilemma").createGenerator();

// NashJS engine components
var Engine = require("../lib/engine")

// game engine
var { Loop } = Engine.Frontend.Playables;

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// Game utility
var Iterated = require("./iterated")



var IteratedPrisonerDilemma = gameWrapper(function(players, numberIterations = 50, parameters = {}) {
	return Iterated(players, prisonerDilemma, "Prisoner-Dilemma", numberIterations, parameters)
}, {
	queries: [{
			shortcut: "@IPD-choices",
			query: "$map($.[action].results, function($l){$l.result})",
			description: "Results, organized by round."
		},
		{
			shortcut: "@IPD-players",
			query: "$map($.[action].results, function($l){$l.player})",
			description: "Players, organized by round."
		},
		{
			shortcut: "@IPD-payouts",
			query: "$.action.payouts",
			description: "Payouts, as array of objects."
		}
	],
	strategyLoader() {
		return [{
				name: "Tit For Tat",
				description: "Do whatever your opponent did last turn. Cooperate if this is the first turn.",
				strategy: function titForTat() {
					this.choose = function(choices, information) {
						if (information.opponent.history.length) return information.opponent.history[information.opponent
								.history.length - 1]
							.result
						else return "Cooperate";
					}
				}
			},
			{
				name: "Grudger",
				description: "Cooperate until your opponent doesn't, then Defect.",
				strategy: function grudger() {
					this.cooperating = true

					this.choose = function(choices, information) {

						// If opponent just defected, then stop cooperating
						if (information.opponent.history.length) {
							if (information.opponent.history[information.opponent.history.length - 1].result == "Defect") this
								.cooperating = false;
						}

						if (this.cooperating) return "Cooperate";
						else return "Defect";
					}
				}
			},

			{
				name: "Naive Prober",
				description: "Like Tit For Tat, but occasionally Defects with small probability",
				strategy: function prober(probability = 0.1) {
					this.choose = function(choices, information) {
						if (Math.random() < probability) return "Defect";

						if (information.opponent.history.length) return information.opponent.history[information.opponent
								.history.length - 1]
							.result
						else return "Cooperate";
					}
				}
			},

			{
				name: "Tit For Two Tats",
				description: "Cooperates on the first move, then Defects only when the opponent Defects two times",
				strategy: function TF2T() {
					this.choose = function(choices, information) {
						if (information.opponent.history.length > 1) {
							if (information.opponent.history[information.opponent.history.length - 1].result == "Defect" &&
								information.opponent.history[information.opponent.history.length - 2].result == "Defect") return "Defect";
							else return "Cooperate";
						} else return "Cooperate";
					}
				}
			}

		]
	}
});
// TODO validate arguments

module.exports = IteratedPrisonerDilemma

},{"../lib/engine":6,"./iterated":76,"./prisoner-dilemma":79}],76:[function(require,module,exports){
"use strict";

// NashJS engine components
var Engine = require("../lib/engine")

// game engine
var { Loop } = Engine.Frontend.Playables;

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")


var Iterated = gameWrapper(function(players, gameGenerator, gameName, numberIterations = 50, parameters = {}) {

	var { parameters: gameParameters = {} } = parameters

	gameParameters.id = gameParameters.id || gameName
	parameters.id = parameters.id || "Iterated-" + gameName;

	return Loop(gameGenerator(players, gameParameters), numberIterations, parameters);
})

// TODO validate arguments

module.exports = Iterated;

},{"../lib/engine":6}],77:[function(require,module,exports){
"use strict";

// base game
var SimpleZeroSum = require("./simple-zero-sum");

// NashJS engine components
var Engine = require("../lib/engine")

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// Play-time logic
var { Expression } = Engine.Frontend


var MatchingPennies = gameWrapper(function(players, parameters = {}) {
	parameters.id = parameters.id || "Matching-Pennies";
	payoff = parameters.payoff || 1;

	var win = payoff;
	var lose = Expression(function() {
		return -payoff;
	});

	var choices = [
		["Heads", "Tails"],
		["Heads", "Tails"]
	];

	var payoffs = [
		[win, lose],
		[lose, win]
	];

	return SimpleZeroSum(players, choices, payoffs, parameters);
});

// Matching Pennies
module.exports = MatchingPennies;

},{"../lib/engine":6,"./simple-zero-sum":83}],78:[function(require,module,exports){
"use strict"

// NashJS engine components
var Engine = require("../lib/engine");

// Playables
var { Choice, Lambda } = Engine.Frontend.Playables;

// logic
var { Variable, ComplexVariable } = Engine.Frontend

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games");


var MontyHall = gameWrapper(function(player, parameters = {}) {
	parameters.id = parameters.id || "Monty-Hall"
	var numDoors = parameters.numDoors || 3;
	var numPrizes = parameters.numPrizes || 1;
	var numReveals = parameters.numReveals || 1;
	var prize = parameters.prize || 5;

	// Allow array or single player
	if (Array.isArray(player)) player = player[0]

	//Generate list of doors
	var doors = [];
	for (var i = 0; i < numDoors; i++) {
		doors.push("Door " + i.toString())
	}

	var Choose = Choice(player, doors, { id: "Choose" });


	var prizes
	var scores = Array.apply(null, Array(doors.length)).map(function() {
		return Variable(0)
	})

	//Need to set this here in order for scoring to work
	var doors2 = ComplexVariable(doors.slice());

	var Reveal = Lambda(function({ history }) {

		// Re-initialize payoffs.
		prizes = []
		for (var i = 0; i < scores.length; i++) {
			scores[i].set(0)
		}

		// What door did the player open?
		var playerChoice = history.log.query("$[choice='" + Choose.id() + "'][-1]").result // TODO does this work?

		// Select which doors have prizes
		var revealFrom = doors.slice(); // Copy the doors list
		for (var i = 0; i < numPrizes; i++) {
			var prizeIndex = Math.floor(Math.random() * revealFrom.length) // Select a door from the doors copy
			prizes.push(revealFrom[prizeIndex]) // Add the prize to the lists
			scores[prizeIndex].set(prize) // Set payoffs appropriately
			revealFrom.splice(prizeIndex, 1) // Remove the prized door from the doors copy, so that we don't select it more than once
		}

		//Remove player choice from doors copy
		var playerChoiceIndex = revealFrom.indexOf(playerChoice)
		if (playerChoiceIndex > -1) revealFrom.splice(playerChoiceIndex, 1)

		// Choose doors to reveal
		var reveal = [];
		for (var i = 0; i < numReveals; i++) {
			reveal.push(revealFrom[Math.floor(Math.random()) * revealFrom.length])
		}

		// Copy doors list to send onward, then remove the revealed doors from list
		doors2.set(doors.slice()); // Need to set this here so revealing to work
		for (var i = 0; i < reveal.length; i++) {
			let index = doors2.indexOf(reveal[i])
			doors2().splice(index, 1)
		}

		return reveal.length == 1 ? reveal[0] : reveal;
	}, { id: "Reveal" })

	var SecondChoice = Choice(player, doors2, { id: "Stay-or-Switch", usePayoffs: true });
	SecondChoice.setAllPayoffs(scores)

	Reveal(Choose)
	SecondChoice(Reveal)

	return Sequence(Choose, SecondChoice, parameters);
}, {

	strategyLoader() {
		return [{
				name: "Always Switch",
				description: "Randomly select a door. Then, always switch to a different one.",

				strategy: function alwaysSwitch() {

					this.door = null;

					this.choose = function(options, information) {
						var choice
						if (this.door) {
							options.splice(options.indexOf(this.door), 1)
							this.door = null;
							choice = options[Math.floor(Math.random() * options.length)]
						} else {
							choice = options[Math.floor(Math.random() * options.length)]
							this.door = choice
						}

						return choice
					}
				}
			},
			{
				name: "Always Stay",
				description: "Randomly select a door. Then, always stay with that door.",

				strategy: function alwaysStay() {
					this.door = null;

					//TODO add strategy description feature
					this.choose = function(options, information) {
						var choice
						if (this.door) {
							choice = this.door
							this.door = null;

						} else {
							choice = options[Math.floor(Math.random() * options.length)]
							this.door = choice
						}

						return choice
					}
				}
			}
		]
	}
})

module.exports = MontyHall

},{"../lib/engine":6}],79:[function(require,module,exports){
"use strict";

// base game
var TwoPlayerNormal = require("./simple-normal").TwoPlayerNormal;

//NashJS engine components
var Engine = require("../lib/engine")

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games");

// play-time logic
var { Variable, Expression } = Engine.Frontend;


var prisonerDilemma = gameWrapper(function(players, parameters = {}) {
	parameters.id = parameters.id || "Prisoner-Dilemma";
	var payoffs = parameters.payoffs || [Variable(1), Variable(2), Variable(3), Variable(4)];


	// sort numbers because the wrong order would screw up the game
	payoffs.sort()
	var sucker = payoffs[0]
	var punishment = payoffs[1]
	var reward = payoffs[2]
	var temptation = payoffs[3]


	var choices = [
		["Cooperate", "Defect"],
		["Cooperate", "Defect"]
	];
	var gamePayoffs = [
		[
			[reward, reward],
			[sucker, temptation]
		],
		[
			[temptation, sucker],
			[punishment, punishment]
		]
	];

	return TwoPlayerNormal(players, choices, gamePayoffs, parameters);
});


module.exports = prisonerDilemma;

},{"../lib/engine":6,"./simple-normal":82}],80:[function(require,module,exports){
"use strict";

// base game
var SimpleZeroSum = require("./simple-zero-sum");

var Engine = require("../lib/engine")

// helper functions
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// Play-time logic
var { Expression } = Engine.Frontend


// Rock-Paper-Scissors
var RockPaperScissors = gameWrapper(function(players, parameters = {}) {
	parameters.id = parameters.id || "Rock-Paper-Scissors";
	parameters.payoff = parameters.payoff || 1;

	var win = parameters.payoff;
	var lose = Expression(function() {
		return -payoff;
	});

	var choices = [
		["Rock", "Paper", "Scissors"],
		["Rock", "Paper", "Scissors"]
	];
	var payoffs = [
		[0, lose, win],
		[win, 0, lose],
		[lose, win, 0]
	];

	return SimpleZeroSum(players, choices, payoffs, parameters);
});

module.exports = RockPaperScissors

},{"../lib/engine":6,"./simple-zero-sum":83}],81:[function(require,module,exports){
"use strict";

//NashJS Engine
var Engine = require("../lib/engine")

// helper function
var { shuffle } = Engine.Backend.HelperFunctions("general");
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// nashJS engine component
var { Sequence, Simultaneous } = Engine.Frontend.Playables;

//for information mechanics
var { Information, History, PlayerList } = Engine.Backend.Classes;


// gameGenerator should be a function whose first argument is an array of players
var RoundRobin = gameWrapper(function(players, gameGenerator, parameters = {}) {
	parameters.id = parameters.id || "Round-Robin";
	parameters.initializePlayers = parameters.initializePlayers && true;

	// Create array of each combination of players
	var matches = [];

	players.forEach(function(player1, index1) {
		for (var index2 = 0; index2 < index1; index2++) {
			matches.push([players[index2], player1]);
		}

		// optional parameter 'copies.' Pass an extra copy of each player, to play themselves
		if (parameters.copies) matches.push([parameters.copies[index1], player1]);
	});

	//randomize the order
	shuffle(matches);

	// Track scores
	var scoresRecord = [];

	//
	var addRound = function(players, parameters = {}) {
		// information mechanics and other parameters
		var population = new PlayerList(players).generator
		parameters.compartmentalize = { population }
		parameters.initializePlayers = population;

		// generate round
		var round = gameGenerator(players, parameters);

		// track the scores
		var recordScores = Lambda(function() {
			var score = {}
			for (let [strategy, scores] of Object.entries(population().scoresByStrategy())) {
				if (Array.isArray(scores)) {
					if (scores.length == 1) scores = scores[0]
					score[strategy] = scores;
				}
			}
			scoresRecord.push(score);

			//return score for history
			return score;
		}, { id: "Record-Scores" });

		//Chain together
		recordScores(round);

		// return both
		return [round, recordScores
			// ,Sequence(round, recordScores) // Uncomment for Simultaneous implementation
		];
	};



	// Sequential implementation
	// load the first match manually
	var [firstRound, firstRecord] = addRound(
		matches.shift(),
		parameters.parameters
	);

	//then load subsequent matches
	var record = firstRecord;
	var lastRecord, lastRound;

	matches.forEach(function(match) {
		[lastRound, lastRecord] = addRound(match, parameters.parameters);

		lastRound(record);
		record = lastRecord;
	});


	return Sequence(firstRound, lastRecord, parameters);

	/* // Simultaneous implementation
	var rounds = [];
	matches.forEach(function(match) {
	  rounds.push(addRound(match, parameters.gameParameters)[2]);
	});

	return Simultaneous(rounds, parameters); */
});

module.exports = RoundRobin;

},{"../lib/engine":6}],82:[function(require,module,exports){
"use strict";

//Game engine
var Engine = require("../lib/engine")

//Helper functions
var { isFunction } = Engine.Backend.HelperFunctions("general")
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games")

// Playables
var { Turn, Choice, RandomPlayerChoice } = Engine.Frontend.Playables;

//Play-time Logic
var { RandomVariable } = Engine.Frontend


var Normal = gameWrapper(function(players, choiceLists, payoffs = null, parameters = {}) {

		//propogate the information filter
		parameters.parameters ? parameters.parameters.informationFilter = parameters.informationFilter :
			parameters.parameters = { informationFilter: parameters.informationFilter }

		// construct the choices
		var choices = choiceLists.map(function(list, index) {
			return players == "random" ? RandomPlayerChoice(list, parameters.parameters) : Choice(players[index],
				list, parameters.parameters);
		});

		var game = Turn(choices, parameters);

		if (payoffs) game.setAllPayoffs(payoffs);

		return game;
	}, {
		queries: [{
				shortcut: "@N-choices",
				query: "$.results{player:result}",
				description: "Normal: Players and their choice."
			},
			{
				shortcut: "@N-payouts",
				query: "$.payouts",
				description: "Normal: Payouts object, by player."
			},
			{
				shortcut: "@N-players",
				query: "$.results.player",
				description: "Normal: Who played."
			}
		],
		strategyLoader: function() {
			return [{
					strategy: function chooseFirst() {
						this.choose = function(choices, information) {
							return choices[0]
						}
					},
					name: "Choose First",
					description: "Always choose first available option."
				},

				{
					strategy: function chooseSecond() {
						this.choose = function(choices, information) {
							return choices[1]
						}
					},
					name: "Choose Second",
					description: "Always choose second available option."
				},

				{
					strategy: function randomize(choices = [0, 1]) {
						// Creating a map will make picking a random value easier
						choices = choices.map(function(item, index) {
							return [index, item]
						});
						var choiceMap = new Map(choices)

						this.choose = function(choices, information) {
							return choices[choiceMap.get(Math.floor(Math.random() * choiceMap.size))];
						}
					},
					name: "Randomize",
					description: "Choose randomly from available options."
				}
			];
		}
	} // 										TODO: validate all arguments
);


var TwoPlayerNormal = gameWrapper(function(players, choices, payoffs = null, parameters = {}) {

	// Information mechanics.. There are only two players, so we can have a 'me' and 'opponent' entry.
	// If user supplied an information filter, wrap that filter in ours.
	var { informationFilter } = parameters;
	if (!isFunction(informationFilter)) informationFilter = null;

	// Wrap the user's filter
	var wrappedFilter = function(information) {
		// Figure out who I am and who the opponent is
		var me = information.me.id
		var players = [information.turn.choices[0].choice.player, information.turn.choices[1].choice.player]
		var opponent = players.splice(players.indexOf(me), 1) && players[0];

		// add entry for opponent
		var opponentDetail = information.population.filter(function(player) {
			return (player.id == opponent)
		})[0];
		information.opponent = opponentDetail;

		// run the user's information filter
		if (informationFilter) information = informationFilter(information);

		return information;
	}

	// Pass the information filter
	parameters.informationFilter = wrappedFilter

	return Normal(players, choices, payoffs, parameters)
}); //				 																												TODO: may want to validate arguments here too



module.exports = { TwoPlayerNormal, Normal };

},{"../lib/engine":6}],83:[function(require,module,exports){
"use strict";

// base game
var TwoPlayerNormal = require("./simple-normal").TwoPlayerNormal;

// NashJS components
var Engine = require("../lib/engine")

// Game state controller
var { registry } = Engine.Backend.State
var { gameWrapper } = Engine.Backend.HelperFunctions("stock-games");

// Play-time logic
var { Variable, Expression } = Engine.Frontend;

/* beautify preserve:start */
var SimpleZeroSum = gameWrapper(function(players, choices, payoffs = [[0, 0],	[0, 0]], parameters={}) {
/* beautify preserve:end */

	var game = TwoPlayerNormal(players, choices, null, parameters)

	var e;

	choices[0].forEach(function(choice0, index0) {
		choices[1].forEach(function(choice1, index1) {

			// Set expression
			e = Expression(function() {
				//Return the negative payoff, or zero
				return (0 - registry.turns[game.id()].payoffsImplicit[choice0][choice1][0] || 0);
			});

			//Set payoffs
			game[choice0][choice1]([payoffs[index0][index1], e]);
		});
	});

	return game;
}); //					TODO: validate arguments



module.exports = SimpleZeroSum;

},{"../lib/engine":6,"./simple-normal":82}]},{},[5])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwiLi4vLi4vLi4vLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJpbmRleC5qcyIsImxhYi9sYWIuanMiLCJsaWIvZW5naW5lLmpzIiwibGliL2hlbHBlci1mdW5jdGlvbnMvZ2VuZXJhbC5qcyIsImxpYi9oZWxwZXItZnVuY3Rpb25zL2luZGV4LmpzIiwibGliL2hlbHBlci1mdW5jdGlvbnMvbG9naWMuanMiLCJsaWIvaGVscGVyLWZ1bmN0aW9ucy9wbGF5YWJsZS5qcyIsImxpYi9oZWxwZXItZnVuY3Rpb25zL3BsYXllci5qcyIsImxpYi9oZWxwZXItZnVuY3Rpb25zL3N0YXRlLmpzIiwibGliL2hlbHBlci1mdW5jdGlvbnMvc3RvY2stZ2FtZXMuanMiLCJsaWIvaGVscGVyLWZ1bmN0aW9ucy90b3VybmFtZW50LmpzIiwibGliL2hlbHBlci1mdW5jdGlvbnMvdHVybi5qcyIsImxpYi9oaXN0b3J5LmpzIiwibGliL2luZm9ybWF0aW9uLmpzIiwibGliL2xvZ2dlci5qcyIsImxpYi9sb2dpYy5qcyIsImxpYi9wbGF5YWJsZXMvY2hvaWNlLmpzIiwibGliL3BsYXlhYmxlcy9jb25zZWN1dGl2ZS5qcyIsImxpYi9wbGF5YWJsZXMvaGFsdC1pZi5qcyIsImxpYi9wbGF5YWJsZXMvaW5kZXguanMiLCJsaWIvcGxheWFibGVzL2xhbWJkYS5qcyIsImxpYi9wbGF5YWJsZXMvbG9vcC5qcyIsImxpYi9wbGF5YWJsZXMvcGxheWFibGUuanMiLCJsaWIvcGxheWFibGVzL3BvcHVsYXRpb24tZHluYW1pY3MuanMiLCJsaWIvcGxheWFibGVzL3JhbmRvbS1wbGF5ZXItY2hvaWNlLmpzIiwibGliL3BsYXlhYmxlcy9yYW5nZS5qcyIsImxpYi9wbGF5YWJsZXMvc2VxdWVuY2UuanMiLCJsaWIvcGxheWFibGVzL3NpbXVsdGFuZW91cy5qcyIsImxpYi9wbGF5YWJsZXMvc3RvY2hhc3RpYy1oYWx0LmpzIiwibGliL3BsYXlhYmxlcy9zdG9jaGFzdGljTG9vcC5qcyIsImxpYi9wbGF5YWJsZXMvdHVybi5qcyIsImxpYi9wbGF5ZXIuanMiLCJsaWIvcGx1Z2luLW1hbmFnZXIvYXN5bmMtY3R4LmpzIiwibGliL3BsdWdpbi1tYW5hZ2VyL2luZGV4LmpzIiwibGliL3BsdWdpbi1tYW5hZ2VyL3BsdWdpbi1jYWxsYmFjay1lcnJvci5qcyIsImxpYi9wbHVnaW4tbWFuYWdlci9wbHVnaW4tbmFtZS1lcnJvci5qcyIsImxpYi9wbHVnaW4tbWFuYWdlci93YXRlcmZhbGwtY3R4LmpzIiwibGliL3BvcHVsYXRpb24uanMiLCJsaWIvcXVlcnkuanMiLCJsaWIvc3RhdGUuanMiLCJsaWIvc3RyYXRlZ3ktbG9hZGVyLmpzIiwibGliL3N0cmF0ZWd5LmpzIiwibGliL3N1bW1hcnkuanMiLCJub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hbnNpLXN0eWxlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hc3luYy9kaXN0L2FzeW5jLmpzIiwibm9kZV9tb2R1bGVzL2NhbGxhYmxlLWluc3RhbmNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NoYWxrL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NoYWxrL25vZGVfbW9kdWxlcy9zdXBwb3J0cy1jb2xvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lc2NhcGUtc3RyaW5nLXJlZ2V4cC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lc3ByaW1hL2Rpc3QvZXNwcmltYS5qcyIsIm5vZGVfbW9kdWxlcy9leHByZXNzaW9uLXNhbmRib3gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXhwcmVzc2lvbi1zYW5kYm94L2xpYi9tYWtlLXNhZmUuanMiLCJub2RlX21vZHVsZXMvaGFzLWFuc2kvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbi1iZWF1dGlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uYXRhL2pzb25hdGEuanMiLCJub2RlX21vZHVsZXMvbG9nbGV2ZWwtY29sb3JlZC1sZXZlbC1wcmVmaXgvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanMiLCJub2RlX21vZHVsZXMvcHJlc2VudC9saWIvcHJlc2VudC1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JhbmRnZW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmFuZGdlbi9saWIvcmFuZGdlbi5qcyIsIm5vZGVfbW9kdWxlcy9zdHJpcC1hbnNpL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N5bmNocm9ub3VzLXByb21pc2UvaW5kZXguanMiLCJwbHVnaW5zL2JhbGFuY2Utc2hlZXQtY29tcGxleC5qcyIsInBsdWdpbnMvYmFsYW5jZS1zaGVldC5qcyIsInNldHRpbmdzLmpzIiwic3RvY2stZ2FtZXMvYXhlbHJvZC10b3VybmFtZW50LmpzIiwic3RvY2stZ2FtZXMvYmF0dGxlLW9mLXRoZS1zZXhlcy5qcyIsInN0b2NrLWdhbWVzL2N1bHR1cmFsLWV2b2x1dGlvbi5qcyIsInN0b2NrLWdhbWVzL2V4Y2hhbmdlLWNvbXBsZXguanMiLCJzdG9jay1nYW1lcy9pbmRleC5qcyIsInN0b2NrLWdhbWVzL2l0ZXJhdGVkLXByaXNvbmVyLWRpbGVtbWEuanMiLCJzdG9jay1nYW1lcy9pdGVyYXRlZC5qcyIsInN0b2NrLWdhbWVzL21hdGNoaW5nLXBlbm5pZXMuanMiLCJzdG9jay1nYW1lcy9tb250eS1oYWxsLmpzIiwic3RvY2stZ2FtZXMvcHJpc29uZXItZGlsZW1tYS5qcyIsInN0b2NrLWdhbWVzL3JvY2stcGFwZXItc2Npc3NvcnMuanMiLCJzdG9jay1nYW1lcy9yb3VuZC1yb2Jpbi5qcyIsInN0b2NrLWdhbWVzL3NpbXBsZS1ub3JtYWwuanMiLCJzdG9jay1nYW1lcy9zaW1wbGUtemVyby1zdW0uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3orS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzaU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsMkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc31yZXR1cm4gZX0pKCkiLCIiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvL01haW4gbW9kdWxlIGNvZGVcclxudmFyIE5hc2hKUyA9IHJlcXVpcmUoJy4vbGliL2VuZ2luZScpLkZyb250ZW5kO1xyXG5cclxuLy9TdG9jay1nYW1lc1xyXG5OYXNoSlMuU3RvY2tHYW1lcyA9IHJlcXVpcmUoJy4vc3RvY2stZ2FtZXMnKTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5hc2hKUztcclxuIiwiKHtcclxuXHRQbGF5ZXIsXHJcblx0X1BsYXllcixcclxuXHRnYW1lUG9wdWxhdGlvbixcclxuXHRQb3B1bGF0aW9uLFxyXG5cdFBsYXllckxpc3QsXHJcblx0cmVnaXN0ZXJTdHJhdGVneSxcclxuXHRTdHJhdGVnaWVzLFxyXG5cdHN0cmF0ZWd5TG9hZGVyLFxyXG5cdF9leHBvc2UsXHJcblx0cmVnaXN0cnksXHJcblx0VmFyaWFibGUsXHJcblx0RXhwcmVzc2lvbixcclxuXHRSYW5kb21WYXJpYWJsZSxcclxuXHRDb21wbGV4VmFyaWFibGUsXHJcblx0SGlzdG9yeSxcclxuXHRRdWVyaWVzLFxyXG5cdGV4Y2x1ZGVkUGxheWVycyxcclxuXHRzdGFydFJFUEwsXHJcblx0bmhpc3RvcnksXHJcblx0SW5mb3JtYXRpb24sXHJcblx0UGVyZmVjdEluZm9ybWF0aW9uLFxyXG5cdFBsdWdpbk1hbmFnZXIsXHJcblx0c3luY01vZGVcclxufSA9IHJlcXVpcmUoXCIuLi9pbmRleFwiKSk7XHJcbih7XHJcblx0Q2hvaWNlLFxyXG5cdFJhbmdlLFxyXG5cdFR1cm4sXHJcblx0U2VxdWVuY2UsXHJcblx0Q29uc2VjdXRpdmUsXHJcblx0TG9vcCxcclxuXHRTdG9jaGFzdGljTG9vcCxcclxuXHRIYWx0SWYsXHJcblx0U3RvY2hhc3RpY0hhbHQsXHJcblx0TGFtYmRhLFxyXG5cdFJhbmRvbVBsYXllckNob2ljZSxcclxuXHRQb3B1bGF0aW9uRHluYW1pY3MsXHJcblx0U2ltdWx0YW5lb3VzXHJcbn0gPSByZXF1aXJlKFwiLi4vaW5kZXhcIikuUGxheWFibGVzKTtcclxuU3RvY2tHYW1lcyA9IHJlcXVpcmUoXCIuLi9pbmRleFwiKS5TdG9ja0dhbWVzO1xyXG5cclxuXHJcblxyXG5wMSA9IFBsYXllcigpO1xyXG5wMiA9IFBsYXllcigpO1xyXG5wMyA9IFBsYXllcigpO1xyXG5pcGQgPSBTdG9ja0dhbWVzW1wiSXRlcmF0ZWQgUHJpc29uZXIncyBEaWxlbW1hXCJdKFtwMSwgcDJdLCAyMClcclxuLypcclxuU3RvY2tHYW1lc1tcIlByaXNvbmVyJ3MgRGlsZW1tYVwiXShbcDEsIHAyXSlcclxuXHJcbnAxLmFzc2lnbihcImNob29zZUZpcnN0XCIpXHJcbnAyLmFzc2lnbihcInJhbmRvbWl6ZVwiKTtcclxuXHJcbnAzID0gUGxheWVyKCk7XHJcbnAzLmFzc2lnbihcImNob29zZVNlY29uZFwiKTtcclxucDQgPSBQbGF5ZXIoKTtcclxucDQuYXNzaWduKFwicmFuZG9taXplXCIpXHJcblxyXG5jMSA9IENob2ljZShwMSwgW1wiY29vcGVyYXRlXCIsIFwiZGVmZWN0XCJdKTtcclxuLy9jMVsnbGVmdCddKDUpIDtcclxuLy9jMVsncmlnaHQnXSgyKTtcclxuYzIgPSBDaG9pY2UocDIsIFtcIkNvb3BlcmF0ZVwiLCBcIkRlZmVjdFwiXSk7XHJcbi8vYzJbJ3VwJ10oMSk7XHJcbi8vYzJbJ2Rvd24nXSg3KTtcclxuXHJcbnQyID0gVHVybihbYzEsIGMyXSk7XHJcbnQzID0gVHVybihbYzEsIGMyXSk7XHJcbnQ0ID0gVHVybihbYzEsIGMyXSk7XHJcbnQ1ID0gVHVybihbYzEsIGMyXSk7XHJcbnMxID0gU2ltdWx0YW5lb3VzKFt0MiwgdDMsIHQ0LCB0NV0pXHJcblxyXG5jID0gQ29uc2VjdXRpdmUoW1xyXG5cdFR1cm4oW2MxLCBjMl0pLFxyXG5cdFR1cm4oW2MyLCBjMV0pLFxyXG5cdENob2ljZShwMSwgW1wiY29vcGVyYXRlXCIsIFwiZGVmZWN0XCJdKSxcclxuXHRMYW1iZGEoZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKFwiaGlcIikgfSksXHJcblx0SGFsdElmKGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZSB9KVxyXG5dKVxyXG5cclxuYzMgPSBSYW5kb21QbGF5ZXJDaG9pY2UoW1wiY29vcGVyYXRlXCIsIFwiZGVmZWN0XCJdKTtcclxuYzQgPSBSYW5kb21QbGF5ZXJDaG9pY2UoW1wiQ29vcGVyYXRlXCIsIFwiRGVmZWN0XCJdKTtcclxuXHJcbnQxID0gVHVybihbYzMsIGM0XSk7XHJcblxyXG52MSA9IG5ldyBWYXJpYWJsZSgzKTtcclxuXHJcbnQxLmRlZmVjdC5EZWZlY3QoWzIsIDJdKTtcclxudDEuZGVmZWN0LkNvb3BlcmF0ZShbNCwgMV0pO1xyXG50MS5jb29wZXJhdGUuRGVmZWN0KFsxLCA0XSk7XHJcbnQxLmNvb3BlcmF0ZS5Db29wZXJhdGUoW3YxLCB2MV0pO1xyXG5cclxuTDEgPSBMYW1iZGEoZnVuY3Rpb24oKSB7XHJcblx0djEuc2V0KHYxICsgMSk7XHJcbn0pO1xyXG5cclxucGQxID0gUG9wdWxhdGlvbkR5bmFtaWNzKDEuNSwgMSk7XHJcblxyXG5oMiA9IEhhbHRJZihmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gUG9wdWxhdGlvbigpLm9ubHlBbGl2ZSgpLmxlbmd0aCA9PSAwO1xyXG59KTtcclxuXHJcbkwxKHQxKTtcclxucGQxKEwxKTtcclxuaDIocGQxKTtcclxuXHJcbi8vczEgPSBTZXF1ZW5jZSh0MSwgaDIpO1xyXG5cclxuLy9sMSA9IExvb3AoczEsIDEwLCB7IGxvZ0NvbnRpbnVlOiB0cnVlIH0pO1xyXG5cclxuLy9jb25zb2xlLmxvZyhfZXhwb3NlKHQxKS5uZXh0KVxyXG4vL2NvbnNvbGUubG9nKF9leHBvc2UodDEpLm5leHQuY29vcGVyYXRlLkNvb3BlcmF0ZSlcclxuXHJcbmgyID0gSGFsdElmKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBQb3B1bGF0aW9uKCkub25seUFsaXZlKCkubGVuZ3RoID09IDA7XHJcbn0pO1xyXG5cclxuTDIgPSBMYW1iZGEoZnVuY3Rpb24oKSB7XHJcblx0cDEua2lsbCgpO1xyXG59KTtcclxuXHJcbnQyKEwyKTtcclxuXHJcbmdlbmVyYXRlUG9wdWxhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdGZvciAoaSA9IDA7IGkgPCAzMDsgaSsrKSB7XHJcblx0XHRQbGF5ZXIoeyBhc3NpZ246IFwiY2hvb3NlRmlyc3RcIiB9KTtcclxuXHR9XHJcblx0Zm9yIChpID0gMDsgaSA8IDMwOyBpKyspIHtcclxuXHRcdFBsYXllcih7IGFzc2lnbjogXCJjaG9vc2VTZWNvbmRcIiB9KTtcclxuXHR9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBnYW1lR2VuZXJhdG9yKCkge1xyXG5cdHZhciB0ID0gVHVybihbXHJcblx0XHRSYW5kb21QbGF5ZXJDaG9pY2UoW1wiY29vcGVyYXRlXCIsIFwiZGVmZWN0XCJdKSxcclxuXHRcdFJhbmRvbVBsYXllckNob2ljZShbXCJDb29wZXJhdGVcIiwgXCJEZWZlY3RcIl0pXHJcblx0XSk7XHJcblxyXG5cdHQuZGVmZWN0LkRlZmVjdChbMiwgMl0pO1xyXG5cdHQuZGVmZWN0LkNvb3BlcmF0ZShbNCwgMV0pO1xyXG5cdHQuY29vcGVyYXRlLkRlZmVjdChbMSwgNF0pO1xyXG5cdHQuY29vcGVyYXRlLkNvb3BlcmF0ZShbMywgM10pO1xyXG5cclxuXHRyZXR1cm4gdDtcclxufVxyXG4vL1xyXG4vL1xyXG4vL1xyXG5cclxuLy9DRSA9IFN0b2NrR2FtZXNbXCJDdWx0dXJhbCBFdm9sdXRpb25cIl0oZ2FtZUdlbmVyYXRvciwgMSwge2dlbmVyYXRlUG9wdWxhdGlvbn0pO1xyXG5cclxuLy9uID0gU3RvY2tHYW1lc1tcIlR3by1QbGF5ZXIgTm9ybWFsXCJdKHAxLHAyLFtbXCJsZWZ0XCIsXCJyaWdodFwiXSxbXCJ1cFwiLFwiZG93blwiXV0pO1xyXG4vL3BkMSA9IFN0b2NrR2FtZXNbXCJQcmlzb25lcidzIERpbGVtbWFcIl0oW3AxLCBwMl0pO1xyXG4vL3BkMiA9IFN0b2NrR2FtZXNbXCJQcmlzb25lcidzIERpbGVtbWFcIl0oW3AzLCBwNF0pO1xyXG5cclxuLy9zID0gU2ltdWx0YW5lb3VzKFtwZDEsIHBkMl0pXHJcblxyXG52MiA9IFZhcmlhYmxlKDEpO1xyXG5cclxuLy9uID0gU3RvY2tHYW1lc1tcIlNpbXBsZSBaZXJvLVN1bVwiXShwMSxwMixbW1wibGVmdFwiLFwicmlnaHRcIl0sW1widXBcIixcImRvd25cIl1dLCBbW3YyLDJdLFszLDRdXSk7XHJcblxyXG4vL3JwYyA9IFN0b2NrR2FtZXNbXCJSb2NrLVBhcGVyLVNjaXNzb3JzXCJdKFtwMSwgcDJdKTtcclxuLy90ID0gU3RvY2tHYW1lc1tcIkF4ZWxyb2QgVG91cm5hbWVudFwiXTtcclxuLy90ID0gU3RvY2tHYW1lc1tcIkl0ZXJhdGVkIFByaXNvbmVyJ3MgRGlsZW1tYVwiXShbcDEsIHAyXSk7XHJcbi8vVGhlIGNvZGUgYmVsb3cgaXMgdG8gcnVuIHRoZSByZXBsIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxyXG4vL3ZhciB0b1JlcGwgPSB7X2V4cG9zZSwgcmVnaXN0cnksUGxheWVyLENob2ljZSxUdXJuLFNlcXVlbmNlLExvb3AsU3RvY2hhc3RpY0xvb3AsSGFsdElmLCBTdG9jaGFzdGljSGFsdCwgTGFtYmRhLCBwMSxjMSxjMix0MX07XHJcbi8vc3RhcnRSRVBMKHRvUmVwbCk7XHJcbiovXHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gTG9hZCBzZXR0aW5ncyBpbmZvcm1hdGlvblxyXG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKFwiLi4vc2V0dGluZ3NcIik7XHJcbi8vIG9iamVjdCBmb3IgdXNlciB0byBjaGFuZ2Ugc2V0dGluZ3NcclxuZnVuY3Rpb24gc2V0dGluZ3Moc2V0dGluZywgdmFsdWUpIHtcclxuXHRTZXR0aW5nc1tzZXR0aW5nXSA9IHZhbHVlXHJcbn1cclxuXHJcblxyXG4vLyBTdGFydCBwbHVnLWluIG1hbmFnZXJcclxudmFyIFBsdWdpbk1hbmFnZXIgPSByZXF1aXJlKFwiLi9wbHVnaW4tbWFuYWdlclwiKVxyXG5QbHVnaW5NYW5hZ2VyLnN0YXJ0KGZ1bmN0aW9uKCkge30pXHJcblxyXG5cclxuLy9Mb2dnaW5nXHJcbnZhciBsb2cgPSByZXF1aXJlKFwiLi9sb2dnZXJcIik7XHJcbmxvZy5zZXRMZXZlbChTZXR0aW5nc1tcImluaXQtbG9nLWxldmVsXCJdKTtcclxubG9nKFwiaW5mb1wiLCBcIlN0YXJ0aW5nIE5hc2hKU1wiKTtcclxuXHJcblxyXG4vL0dhbWUgc3RhdGUgY29udHJvbGxlcnNcclxudmFyIHsgcmVnaXN0cnksIGlkQ291bnRlcnMgfSA9IHJlcXVpcmUoJy4vc3RhdGUnKTtcclxucmVnaXN0cnkuU2V0dGluZ3MgPSBTZXR0aW5nc1xyXG5cclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiBsb2FkZXJcclxudmFyIEhlbHBlckZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4vaGVscGVyLWZ1bmN0aW9ucycpO1xyXG5cclxuLy8gU3luYyBtb2RlXHJcbnZhciB7IHN5bmNNb2RlIH0gPSBIZWxwZXJGdW5jdGlvbnMoXCJzdGF0ZVwiKVxyXG5zeW5jTW9kZShTZXR0aW5nc1tcImluaXQtc3luYy1tb2RlXCJdKTtcclxuXHJcbi8vIFF1ZXJ5IGxhbmd1YWdlIGFuZCBzaG9ydGN1dHNcclxudmFyIHsgUXVlcmllcywgUXVlcnksIFF1ZXJ5UmVzdWx0LCBldmFsdWF0ZVF1ZXJ5LCByZWdpc3RlclF1ZXJ5T2JqZWN0IH0gPSByZXF1aXJlKFwiLi9xdWVyeVwiKTtcclxuXHJcblxyXG4vLyBIaXN0b3J5XHJcbnZhciB7IGdhbWVIaXN0b3J5LCB1c2VyR2FtZUhpc3RvcnksIEhpc3RvcnksIFVzZXJIaXN0b3J5IH0gPSByZXF1aXJlKCcuL2hpc3RvcnknKTtcclxuXHJcblxyXG4vL1BsYXllcnNcclxudmFyIHsgX1BsYXllciwgUGxheWVyIH0gPSByZXF1aXJlKCcuL3BsYXllcicpO1xyXG5yZWdpc3RyeS5fYWRkVHlwZV8oXCJwbGF5ZXJzXCIpO1xyXG5pZENvdW50ZXJzLl9hZGRUeXBlXyhcInBsYXllclwiKTtcclxuXHJcblxyXG4vL1BvcHVsYXRpb25cclxudmFyIHsgZ2FtZVBvcHVsYXRpb24sIFBvcHVsYXRpb24sIFBsYXllckxpc3QsIFVzZXJQbGF5ZXJMaXN0IH0gPSByZXF1aXJlKCcuL3BvcHVsYXRpb24nKTtcclxuXHJcblxyXG4vL0luZm9ybWF0aW9uIG1lY2hhbmljc1xyXG52YXIgeyBJbmZvcm1hdGlvbiwgUGVyZmVjdEluZm9ybWF0aW9uIH0gPSByZXF1aXJlKFwiLi9pbmZvcm1hdGlvblwiKTtcclxuXHJcblxyXG4vL1BsYXlhYmxlc1xyXG52YXIgeyBwbGF5YWJsZUNsYXNzZXMsIHBsYXlhYmxlSW50ZXJmYWNlcyB9ID0gcmVxdWlyZSgnLi9wbGF5YWJsZXMvJylcclxuZm9yICh2YXIgX2NsYXNzIGluIHBsYXlhYmxlQ2xhc3Nlcykge1xyXG5cdHJlZ2lzdHJ5Ll9hZGRUeXBlXyhwbGF5YWJsZUNsYXNzZXNbX2NsYXNzXS5yZWdpc3RyeU5hbWUpO1xyXG5cdGlkQ291bnRlcnMuX2FkZFR5cGVfKHBsYXlhYmxlQ2xhc3Nlc1tfY2xhc3NdLmNvdW50ZXJOYW1lKTtcclxufVxyXG5cclxuLy9TeW1ib2xpYyBMb2dpY1xyXG52YXIge1xyXG5cdHZhcmlhYmxlUHJvdG90eXBlLFxyXG5cdFZhcmlhYmxlLFxyXG5cdGV4cHJlc3Npb25Qcm90b3R5cGUsXHJcblx0RXhwcmVzc2lvbixcclxuXHRSYW5kb21WYXJpYWJsZSxcclxuXHRDb21wbGV4VmFyaWFibGVcclxufSA9IHJlcXVpcmUoXCIuL2xvZ2ljXCIpO1xyXG5cclxuXHJcbi8vU3RyYXRlZ2llc1xyXG5yZWdpc3RyeS5fYWRkVHlwZV8oXCJzdHJhdGVnaWVzXCIpO1xyXG5pZENvdW50ZXJzLl9hZGRUeXBlXyhcInN0cmF0ZWd5XCIpO1xyXG5cclxudmFyIHsgcmVnaXN0ZXJTdHJhdGVneSwgcmVnaXN0ZXJTdHJhdGVneU9iamVjdCwgU3RyYXRlZ2llcyB9ID0gcmVxdWlyZSgnLi9zdHJhdGVneScpO1xyXG52YXIgeyBsb2FkU3RyYXRlZ3ksIGxvYWRTdHJhdGVneUZvbGRlciB9ID0gcmVxdWlyZSgnLi9zdHJhdGVneS1sb2FkZXInKTtcclxuXHJcblxyXG5cclxuXHJcbi8vVEhJUyBGVU5DVElPTiBJUyBPTkxZIEZPUiBERUJVR0dJTkcuIFJFTU9WRSBJVCBGUk9NIE1PRFVMRSBFWFBPUlRTIFdIRU4gUFVCTElTSElOR1xyXG5mdW5jdGlvbiBFeHBvc2UoaW50ZXJmYWNlUGxheWFibGUpIHtcclxuXHRyZXR1cm4gcmVnaXN0cnkucGxheWFibGVzW2ludGVyZmFjZVBsYXlhYmxlLmlkKCldO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gc3RhcnRSRVBMKHRvUkVQTCkge1xyXG5cdHZhciByZXBsID0gcmVxdWlyZShcInJlcGxcIik7XHJcblxyXG5cdHZhciByZXBsU2VydmVyID0gcmVwbC5zdGFydCh7XHJcblx0XHRwcm9tcHQ6IFwiTmFzaCA+PiBcIlxyXG5cdH0pO1xyXG5cclxuXHRPYmplY3QuYXNzaWduKHJlcGxTZXJ2ZXIuY29udGV4dCwgdG9SRVBMKTtcclxufVxyXG5cclxuXHJcblxyXG52YXIgRW5naW5lID0ge1xyXG5cdEZyb250ZW5kOiB7XHJcblx0XHRQbGF5ZXIsXHJcblx0XHQvL19QbGF5ZXIsIC8vUkVNT1ZFIFRISVMgTElORSBXSEVOIFBVQkxJU0hJTkdcclxuXHRcdC8vZ2FtZVBvcHVsYXRpb24sIC8vUkVNT1ZFIFRISVMgTElORSBXSEVOIFBVQkxJU0hJTkdcclxuXHRcdCdQbGF5ZXJMaXN0JzogVXNlclBsYXllckxpc3QsXHJcblx0XHRQb3B1bGF0aW9uLFxyXG5cdFx0Ly9JbmZvcm1hdGlvbiwgLy9SRU1PVkUgVEhJUyBMSU5FIFdIRU4gUFVCTElTSElOR1xyXG5cdFx0Ly9QZXJmZWN0SW5mb3JtYXRpb24sIC8vUkVNT1ZFIFRISVMgTElORSBXSEVOIFBVQkxJU0hJTkdcclxuXHRcdCdQbGF5YWJsZXMnOiBwbGF5YWJsZUludGVyZmFjZXMsXHJcblx0XHRyZWdpc3RlclN0cmF0ZWd5LFxyXG5cdFx0cmVnaXN0ZXJTdHJhdGVneU9iamVjdCxcclxuXHRcdFN0cmF0ZWdpZXMsXHJcblx0XHRsb2FkU3RyYXRlZ3ksXHJcblx0XHRsb2FkU3RyYXRlZ3lGb2xkZXIsXHJcblx0XHRIaXN0b3J5OiB1c2VyR2FtZUhpc3RvcnksXHJcblx0XHRRdWVyaWVzLFxyXG5cdFx0Ly9FeHBvc2UsIC8vUkVNT1ZFIFRISVMgTElORSBXSEVOIFBVQkxJU0hJTkdcclxuXHRcdC8vcmVnaXN0cnksIC8vUkVNT1ZFIFRISVMgTElORSBXSEVOIFBVQkxJU0hJTkdcclxuXHRcdHN0YXJ0UkVQTCwgLy9TaG91bGQgdGhpcyBsaW5lIGJlIHJlbW92ZWQgd2hlbiBwdWJsaXNoaW5nP1xyXG5cdFx0VmFyaWFibGUsXHJcblx0XHRFeHByZXNzaW9uLFxyXG5cdFx0UmFuZG9tVmFyaWFibGUsXHJcblx0XHRDb21wbGV4VmFyaWFibGUsXHJcblx0XHRzeW5jTW9kZVxyXG5cdFx0Ly9QbHVnaW5NYW5hZ2VyIC8vUkVNT1ZFIFRISVMgTElORSBXSEVOIFBVQkxJU0hJTkdcclxuXHR9LFxyXG5cclxuXHRCYWNrZW5kOiB7XHJcblx0XHRsb2dnZXI6IGxvZyxcclxuXHRcdFN0YXRlOiB7IHJlZ2lzdHJ5LCBpZENvdW50ZXJzLCBnYW1lSGlzdG9yeSwgZ2FtZVBvcHVsYXRpb24sIFBlcmZlY3RJbmZvcm1hdGlvbiB9LFxyXG5cdFx0Q2xhc3Nlczoge1xyXG5cdFx0XHRQbGF5ZXI6IF9QbGF5ZXIsXHJcblx0XHRcdEhpc3RvcnksXHJcblx0XHRcdFVzZXJIaXN0b3J5LFxyXG5cdFx0XHRQbGF5ZXJMaXN0LFxyXG5cdFx0XHRVc2VyUGxheWVyTGlzdCxcclxuXHRcdFx0SW5mb3JtYXRpb24sXHJcblx0XHRcdFBsYXlhYmxlQ2xhc3NlczogeyBwbGF5YWJsZUNsYXNzZXMgfSxcclxuXHRcdFx0UXVlcnksXHJcblx0XHRcdFF1ZXJ5UmVzdWx0LFxyXG5cdFx0XHR2YXJpYWJsZVByb3RvdHlwZSxcclxuXHRcdFx0ZXhwcmVzc2lvblByb3RvdHlwZVxyXG5cdFx0fSxcclxuXHRcdEhlbHBlckZ1bmN0aW9ucyxcclxuXHRcdFBsdWdpbk1hbmFnZXIsXHJcblx0XHRyZWdpc3RlclF1ZXJ5T2JqZWN0LFxyXG5cdFx0RXhwb3NlXHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVuZ2luZTtcclxuIiwidmFyIGdlbmVyYWwgPSB7XHJcblx0Ly9DaGVjayBpZiB2YXJpYWJsZSBpcyBhbiBPYmplY3RcclxuXHRpc09iamVjdChhKSB7XHJcblx0XHRyZXR1cm4gISFhICYmIGEuY29uc3RydWN0b3IgPT09IE9iamVjdDtcclxuXHR9LFxyXG5cclxuXHQvL1doYXQgZG8geW91IHRoaW5rP1xyXG5cdGlzRnVuY3Rpb24oYSkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBhID09PSBcImZ1bmN0aW9uXCI7XHJcblx0fSxcclxuXHJcblx0Ly9Qcm92aWRlIGEgZnVuY3Rpb24sIGEgY29udGV4dCAoJ3RoaXMnKSwgYW5kIGFuIGFyZ3VtZW50IGFycmF5LlxyXG5cdC8vUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZC5cclxuXHRhcHBseUJpbmQoZnVuYywgdGhhdCwgYXJnQXJyYXkpIHtcclxuXHRcdHJldHVybiBmdW5jLmJpbmQuYXBwbHkoZnVuYywgW3RoYXRdLmNvbmNhdChhcmdBcnJheSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vV3JhcHMgYSBmdW5jdGlvbiB0byBlbnN1cmUgaXQgb25seSBnZXRzIGNhbGxlZCBvbmUgdGltZS5cclxuXHRvbmNlKGZuLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgcmVzdWx0O1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcclxuXHRcdFx0aWYgKGZuKSB7XHJcblx0XHRcdFx0cmVzdWx0ID0gZm4uYXBwbHkoY29udGV4dCB8fCB0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRcdGZuID0gbnVsbDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gUmFuZG9tbHkgcmUtb3JkZXIgYXJyYXlcclxuXHRzaHVmZmxlKGFycmF5KSB7XHJcblx0XHR2YXIgY3VycmVudEluZGV4ID0gYXJyYXkubGVuZ3RoLFxyXG5cdFx0XHR0ZW1wb3JhcnlWYWx1ZSxcclxuXHRcdFx0cmFuZG9tSW5kZXg7XHJcblxyXG5cdFx0Ly8gV2hpbGUgdGhlcmUgcmVtYWluIGVsZW1lbnRzIHRvIHNodWZmbGUuLi5cclxuXHRcdHdoaWxlICgwICE9PSBjdXJyZW50SW5kZXgpIHtcclxuXHRcdFx0Ly8gUGljayBhIHJlbWFpbmluZyBlbGVtZW50Li4uXHJcblx0XHRcdHJhbmRvbUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY3VycmVudEluZGV4KTtcclxuXHRcdFx0Y3VycmVudEluZGV4IC09IDE7XHJcblxyXG5cdFx0XHQvLyBBbmQgc3dhcCBpdCB3aXRoIHRoZSBjdXJyZW50IGVsZW1lbnQuXHJcblx0XHRcdHRlbXBvcmFyeVZhbHVlID0gYXJyYXlbY3VycmVudEluZGV4XTtcclxuXHRcdFx0YXJyYXlbY3VycmVudEluZGV4XSA9IGFycmF5W3JhbmRvbUluZGV4XTtcclxuXHRcdFx0YXJyYXlbcmFuZG9tSW5kZXhdID0gdGVtcG9yYXJ5VmFsdWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cdH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhbDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcclxuXHJcbmxvZyhcImRlYnVnXCIsIFwiaGVscGVyRnVuY3Rpb25zLWluZGV4OiBMb2FkaW5nIGhlbHBlciBmdW5jdGlvbnMgbG9hZGVyLlwiKTtcclxuXHJcbi8qXHJcbnZhciBnZW5lcmFsICA9IHJlcXVpcmUoJy4vZ2VuZXJhbCcpO1xyXG52YXIgcGxheWVyICAgPSByZXF1aXJlKCcuL3BsYXllcicpO1xyXG52YXIgcGxheWFibGUgPSByZXF1aXJlKCcuL3BsYXlhYmxlJyk7XHJcbnZhciB0dXJuIFx0ID0gcmVxdWlyZSgnLi90dXJuJyk7XHJcbnZhciBzdGF0ZSBcdCA9IHJlcXVpcmUoJy4vc3RhdGUnKTsgXHJcbiovXHJcblxyXG5mdW5jdGlvbiBsb2FkZXIoZmlsZSkge1xyXG5cdHJldHVybiByZXF1aXJlKFwiLi9cIiArIGZpbGUgKyBcIi5qc1wiKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBsb2FkZXI7XHJcbi8vbW9kdWxlLmV4cG9ydHMgPSB7Z2VuZXJhbCwgcGxheWVyLCBwbGF5YWJsZSwgdHVybiwgc3RhdGV9O1xyXG5cclxuLy8gSGFjayB0byBjb21waWxlIEdsb2IgZmlsZXMgKGluIGJyb3dzZXJpZnkpLiBEb27CtHQgY2FsbCB0aGlzIGZ1bmN0aW9uIVxyXG4oZnVuY3Rpb24oKSB7XHJcblx0cmVxdWlyZSgnLi9nZW5lcmFsLmpzJyk7cmVxdWlyZSgnLi9pbmRleC5qcycpO3JlcXVpcmUoJy4vbG9naWMuanMnKTtyZXF1aXJlKCcuL3BsYXlhYmxlLmpzJyk7cmVxdWlyZSgnLi9wbGF5ZXIuanMnKTtyZXF1aXJlKCcuL3N0YXRlLmpzJyk7cmVxdWlyZSgnLi9zdG9jay1nYW1lcy5qcycpO3JlcXVpcmUoJy4vdG91cm5hbWVudC5qcycpO3JlcXVpcmUoJy4vdHVybi5qcycpO1xyXG59KTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9naWMgPSB7XHJcblxyXG5cdC8vIENoZWNrIHRvIHNlZSBpZiBvYmplY3QgaXMgVmFyaWFibGUvRXhwcmVzc2lvbiBvciBub3QuIFJldHVybnMgdHJ1ZS9mYWxzZVxyXG5cdGlzTG9naWMobG9naWMpIHtcclxuXHJcblx0XHRpZiAobG9naWMgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBsb2dpYyA9PSBsb2dpYyAqIDEpIHJldHVybiB0cnVlXHJcblx0XHRlbHNlIHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGxvZ2ljO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciB7IFN5bmNocm9ub3VzUHJvbWlzZSB9ID0gcmVxdWlyZSgnc3luY2hyb25vdXMtcHJvbWlzZScpO1xyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKCcuLi9zdGF0ZScpO1xyXG5cclxudmFyIHBsYXlhYmxlID0ge1xyXG5cdC8vIEdlbmVyYXRlcyB0aGUgZnVuY3Rpb24gdGhhdCBnZXRzIHJldHVybmVkIHdoZW4gYSBQbGF5YWJsZSBpcyBjYWxsZWQsIHdoaWNoIGNhbiB0aGVuIGJlIGNhbGxlZCB0byBjaGFpbiBwbGF5YWJsZXMgdG9nZXRoZXIuXHJcblx0Y2hhaW5lckdlbmVyYXRvcihleHRlcm5hbE9iaiwgaW50ZXJuYWxPYmopIHtcclxuXHRcdGV4dGVybmFsT2JqID0gdGhpcztcclxuXHRcdHJldHVybiBmdW5jdGlvbihzb3VyY2UpIHtcclxuXHRcdFx0dmFyIHByZXZpb3VzUGxheWFibGUsIHBhdGg7XHJcblxyXG5cdFx0XHQvL1RPRE86IHZlcmlmeSB0aGF0IHNvdXJjZSBpcyB0aGUgcmlnaHQgdHlwZVxyXG5cclxuXHRcdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5hbGwoW2Z1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmIChzb3VyY2UgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHNvdXJjZSBpbnN0YW5jZW9mIFN5bmNocm9ub3VzUHJvbWlzZSkge1xyXG5cdFx0XHRcdFx0c291cmNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdFx0XHRcdHByZXZpb3VzUGxheWFibGUgPSByZWdpc3RyeS5wbGF5YWJsZXNbcmVzdWx0LnBsYXlhYmxlLmlkKCldO1xyXG5cdFx0XHRcdFx0XHRwYXRoID0gcmVzdWx0LnBhdGhcclxuXHRcdFx0XHRcdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKCk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKClcclxuXHRcdFx0fSgpLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHNvdXJjZSBpbnN0YW5jZW9mIFN5bmNocm9ub3VzUHJvbWlzZSkpIHtcclxuXHRcdFx0XHRcdHByZXZpb3VzUGxheWFibGUgPSByZWdpc3RyeS5wbGF5YWJsZXNbc291cmNlLmlkKCldO1xyXG5cdFx0XHRcdFx0cGF0aCA9IHNvdXJjZS5wYXRoO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoKTtcclxuXHRcdFx0fSgpXSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHJcblx0XHRcdFx0aWYgKHBhdGggPT0gXCJhbGxcIikgcHJldmlvdXNQbGF5YWJsZS5hZGROZXh0KGludGVybmFsT2JqKTtcclxuXHRcdFx0XHRlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRvdXRjb21lVHJlZUdldFZhbHVlKHByZXZpb3VzUGxheWFibGUubmV4dCwgcGF0aCkucHVzaChpbnRlcm5hbE9iaik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL3ByZXZpb3VzUGxheWFibGUubmV4dFtzZWxlY3RlZF0ucHVzaChfY2hvaWNlKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKHtcclxuXHRcdFx0XHRcdCdwbGF5YWJsZSc6IGV4dGVybmFsT2JqLFxyXG5cdFx0XHRcdFx0cGF0aDogXCJhbGxcIlxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblxyXG5cdC8vVXNlIHRvIHNldCBldmVyeSB2YWx1ZSBvZiBhbiBvdXRjb21lIHRyZWVcclxuXHRvdXRjb21lVHJlZUFkZEFsbCh0cmVlLCB2YWx1ZSkge1xyXG5cclxuXHRcdC8vSWYgaXQncyBhbiBhcnJheSwgdGhlbiB3ZSdyZSBhbHJlYWR5IGRvbmUuXHJcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xyXG5cdFx0XHR0cmVlLnB1c2godmFsdWUpOyAvL1VzZSBwdXNoIGhlcmUgYmVjYXVzZSB0aGlzIHdpbGwgYmUgYSB1bmlxdWUgYXJyYXlcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciByZWN1cnNlID0gZnVuY3Rpb24ob2JqLCB2YWwpIHtcclxuXHJcblx0XHRcdFx0Zm9yICh2YXIga2V5cyBpbiBvYmopIHtcclxuXHJcblx0XHRcdFx0XHQvL0lmIG5vIGtleXMgbGVmdCB0byB0cmF2ZXJzZSwgdGhlbiBhc3NpZ24gdmFsdWUuIElmIG5vdCwgcmVjdXJzZS5cclxuXHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KG9ialtrZXlzXSkpIHtcclxuXHRcdFx0XHRcdFx0b2JqW2tleXNdID0gb2JqW2tleXNdLnNsaWNlKCkuY29uY2F0KHZhbCk7IC8vVXNlIHNsaWNlLWNvbmNhdCBoZXJlIGJlY2F1c2UgdGhpcyBtaWdodCBub3QgYmUgYSB1bmlxdWUgYXJyYXkgKHRoZSBjcmVhdGlvbiBwcm9jZXNzIGR1cGxpY2F0ZXMgdGhlbSlcclxuXHRcdFx0XHRcdH0gZWxzZSByZWN1cnNlKG9ialtrZXlzXSwgdmFsKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0XHRyZWN1cnNlKHRyZWUsIHZhbHVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0Ly9UcmF2ZXJzZSBhbiBvdXRjb21lIHRyZWUgdG8gb2J0YWluIHRoZSB2YWx1ZSBmb3IgYSBkZXNpcmVkIGtleS1zZXRcclxuXHQvL0FyZ3VtZW50IG9uZSBpcyBhIG5lc3RlZCBvYmplY3QsIHdoaWxlIGFyZ3VtZW50IDIgaXMgYW4gYXJyYXkgb2Yga2V5cyBmb3IgdGhlIG9iamVjdCwgMSBsYXllciBhdCBhIHRpbWUuXHJcblx0b3V0Y29tZVRyZWVHZXRWYWx1ZSh0cmVlLCBzZWxlY3Rvcikge1xyXG5cclxuXHRcdC8vRmluZCB0aGUgbmV4dCBpdGVtIGluIHRoZSBjaGFpbiBhc3NvY2lhdGVkIHdpdGggdGhlIHJlc3VsdGFudCBvdXRjb21lXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZWN0b3IubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dHJlZSA9IHRyZWVbc2VsZWN0b3JbaV1dO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cmVlO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvL1RyYXZlcnNlIGFuIG91dGNvbWUgdHJlZSB0byBzZXQgdGhlIHZhbHVlIGZvciBhIGRlc2lyZWQga2V5LXNldFxyXG5cdC8vQXJndW1lbnQgb25lIGlzIGEgbmVzdGVkIG9iamVjdCwgd2hpbGUgYXJndW1lbnQgMiBpcyBhbiBhcnJheSBvZiBrZXlzIGZvciB0aGUgb2JqZWN0LCAxIGxheWVyIGF0IGEgdGltZS5cclxuXHRvdXRjb21lVHJlZVNldFZhbHVlKHRyZWUsIHNlbGVjdG9yLCB2YWx1ZSkge1xyXG5cclxuXHRcdC8vRmluZCB0aGUgbmV4dCBpdGVtIGluIHRoZSBjaGFpbiBhc3NvY2lhdGVkIHdpdGggdGhlIHJlc3VsdGFudCBvdXRjb21lXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZWN0b3IubGVuZ3RoIC0gMTsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRyZWUgPSB0cmVlW3NlbGVjdG9yW2ldXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJlZVtzZWxlY3RvcltpXV0gPSB2YWx1ZTtcclxuXHR9XHJcbn1cclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBwbGF5YWJsZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyAgR2FtZSBzdGF0ZVxyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZShcIi4uL3N0YXRlXCIpO1xyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uXHJcbnZhciB7IGlzRnVuY3Rpb24gfSA9IHJlcXVpcmUoXCIuL2dlbmVyYWxcIik7XHJcblxyXG4vLyBQbGF5ZXIgY2xhYXNzXHJcbnZhciB7IF9QbGF5ZXIgfSA9IHJlcXVpcmUoXCIuLi9wbGF5ZXJcIik7XHJcblxyXG4vLyBQb3B1bGF0aW9uXHJcbnZhciB7IGdhbWVQb3B1bGF0aW9uIH0gPSByZXF1aXJlKFwiLi4vcG9wdWxhdGlvblwiKVxyXG5cclxuLy8gUGx1Z2luc1xyXG52YXIgUGx1Z2luTWFuYWdlciA9IHJlcXVpcmUoXCIuLi9wbHVnaW4tbWFuYWdlci9cIilcclxuXHJcbnZhciBwbGF5ZXIgPSB7XHJcblxyXG5cdC8vcmVzZXQgYWxsIHBsYXllcnMuIFJlY3JlYXRlIGZyb20gY2xhc3MsIHJlLWFzc2lnbiBzdHJhdGVneSwgbG9vcCB0aHJvdWdoIG9iamVjdHMgdGhhdCByZWZlcmVuY2UgcGxheWVyIHRvIHNldCBuZXcgcmVmZXJlbmNlLiByZXN1bHQgYXJndW1lbnQgaXMgb25seSBmb3IgcGFzcy10aHJvdWdoLlxyXG5cdHJlaW5pdGlhbGl6ZVBsYXllcnMocG9wdWxhdGlvbiA9IFwiYWxsXCIsIHJlc3VsdCA9IG51bGwpIHtcclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgb2xkUGxheWVyLCBzdHJhdGVneSwgc3RyYXRlZ3lBcmdzLCBwYXJhbWV0ZXJzO1xyXG5cclxuXHRcdFx0Ly8gaWYgbm8gcG9wdWxhdGlvbiBpcyBzdXBwbGllZCwgZmV0Y2ggZXZlcnlib2R5XHJcblx0XHRcdGlmIChwb3B1bGF0aW9uID09PSBcImFsbFwiKSBwb3B1bGF0aW9uID0gT2JqZWN0LmtleXMocmVnaXN0cnkucGxheWVycylcclxuXHRcdFx0ZWxzZShwb3B1bGF0aW9uID0gcG9wdWxhdGlvbi5pZHMoKSlcclxuXHJcblx0XHRcdC8vUmVkZWZpbmUgZWFjaCBwbGF5ZXJcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb3B1bGF0aW9uLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIHBsYXllciA9IHBvcHVsYXRpb25baV07XHJcblxyXG5cdFx0XHRcdG9sZFBsYXllciA9IHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyXTtcclxuXHRcdFx0XHRzdHJhdGVneSA9IG9sZFBsYXllci5zdHJhdGVneSA/IG9sZFBsYXllci5zdHJhdGVneS5faWQgOiBudWxsO1xyXG5cdFx0XHRcdHN0cmF0ZWd5QXJncyA9IHN0cmF0ZWd5ID8gb2xkUGxheWVyLnN0cmF0ZWd5Ll9hcmdzIDogW107XHJcblx0XHRcdFx0cGFyYW1ldGVycyA9IHt9OyAvL1RPRE86IHdoZW4gYWRkaW5nIHBsYXllciBwYXJhbWV0ZXJzLCBiZSBzdXJlIHRoZXkncmUgaW5jbHVkZWQgaGVyZVxyXG5cclxuXHRcdFx0XHRyZWdpc3RyeS5wbGF5ZXJzW3BsYXllcl0gPSBuZXcgX1BsYXllcihvbGRQbGF5ZXIuaWQsIHBhcmFtZXRlcnMpO1xyXG5cdFx0XHRcdHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyXS5pbnRlcmZhY2UgPSBvbGRQbGF5ZXIuaW50ZXJmYWNlO1xyXG5cdFx0XHRcdHN0cmF0ZWd5ICYmIHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyXS5hc3NpZ24oc3RyYXRlZ3ksIC4uLnN0cmF0ZWd5QXJncyk7XHJcblxyXG5cdFx0XHRcdC8vIFBsdWdpbiwgdG8gYWx0ZXIgcGxheWVycyBpbiByZS1pbml0aWFsaXphdGlvblxyXG5cdFx0XHRcdFBsdWdpbk1hbmFnZXIucnVuKFwicGxheWVyLXJlaW5pdGlhbGl6ZVwiLCByZWdpc3RyeS5wbGF5ZXJzW3BsYXllcl0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL0ZvciBlYWNoIGNob2ljZSwgcmVjcmVhdGUgcGxheWVyIHJlZmVyZW5jZXNcclxuXHRcdFx0Zm9yICh2YXIgY2hvaWNlIGluIHJlZ2lzdHJ5LmRlY2lzaW9ucykge1xyXG5cdFx0XHRcdGlmIChyZWdpc3RyeS5kZWNpc2lvbnNbY2hvaWNlXS5wbGF5ZXIpXHJcblx0XHRcdFx0XHRyZWdpc3RyeS5kZWNpc2lvbnNbY2hvaWNlXS5wbGF5ZXIgPSByZWdpc3RyeS5wbGF5ZXJzW3JlZ2lzdHJ5LmRlY2lzaW9uc1tjaG9pY2VdLnBsYXllci5pZF07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcGxheWVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxuXHJcbi8vIFN0YXRlIHZhcmlhYmxlc1xyXG52YXIgeyBpZENvdW50ZXJzLCByZWdpc3RyeSB9ID0gcmVxdWlyZSgnLi4vc3RhdGUnKTtcclxuXHJcbi8vIEV4dGVybmFsIGRlcGVuZGVuY3lcclxudmFyIHsgU3luY2hyb25vdXNQcm9taXNlIH0gPSByZXF1aXJlKFwic3luY2hyb25vdXMtcHJvbWlzZVwiKTtcclxuXHJcbnZhciBzdGF0ZSA9IHtcclxuXHJcblx0Ly9IYW5kbGUgSUQgc2V0dGluZyBmb3IgYWxsIG9iamVjdHMgdGhhdCBnZXQgc3RvcmVkIGluIHRoZSByZWdpc3RyeVxyXG5cdGlkSGFuZGxlcjogZnVuY3Rpb24gaWRIYW5kbGVyKGlkLCB0eXBlLCByZWN1cnNpbmcgPSBmYWxzZSkge1xyXG5cdFx0Ly9Bc3NpZ24gaWRcclxuXHJcblx0XHRpZENvdW50ZXJzW3R5cGVdKys7XHJcblx0XHR2YXIgY291bnRlciA9IGlkQ291bnRlcnNbdHlwZV07XHJcblxyXG5cdFx0aWYgKCFpZCkge1xyXG5cdFx0XHRyZXR1cm4gdHlwZSArIGNvdW50ZXIudG9TdHJpbmcoKTtcclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyBDaGVjayB0aGF0IGlkIGlzbid0IHRha2VuLiBJZiBpdCBpcywgY29uc3RydWN0IGEgbmV3IG9uZS5cclxuXHJcblx0XHRcdC8vQ29uc3RydWN0IGxpc3Qgb2YgYWxsIG9iamVjdHMgYnkgZXh0cmFjdGluZyBhbGwgcmVnaXN0cnkgZW50cmllc1xyXG5cdFx0XHR2YXIgaXRlbXMgPSBbXVxyXG5cdFx0XHRPYmplY3Qua2V5cyhyZWdpc3RyeSkuZm9yRWFjaChmdW5jdGlvbihyZWcpIHsgaXRlbXMucHVzaC5hcHBseShpdGVtcywgT2JqZWN0LmtleXMocmVnaXN0cnlbcmVnXSkpIH0pXHJcblxyXG5cdFx0XHQvLyBpZiBpZCBpcyBhbHJlYWR5IHRha2VuLCBnZW5lcmF0ZSBhIG5ldyBvbmUgYnkgYWRkaW5nIGEgbnVtYmVyIGF0IHRoZSBlbmQuXHJcblx0XHRcdGlmIChpdGVtcy5pbmRleE9mKGlkKSA+IC0xKSB7XHJcblxyXG5cdFx0XHRcdHZhciBtYXRjaCwgb2xkTnVtLCBleHAsIG5ld0lkO1xyXG5cdFx0XHRcdHZhciBvbGRJZCA9IGlkO1xyXG5cclxuXHRcdFx0XHRkbyB7XHJcblx0XHRcdFx0XHQvLyBUaGlzIGZpbmRzIGEgbnVtYmVyIGF0IHRoZSBlbmQsIGFuZCBpbmNyZW1lbnRzIGl0LCBvciBzdGFydHMgd2l0aCAxIGlmIHRoZXJlIHdhc24ndCBvbmUuXHJcblx0XHRcdFx0XHRtYXRjaCA9IC9cXGQrJC8uZXhlYyhpZCk7XHJcblx0XHRcdFx0XHRvbGROdW0gPSBtYXRjaCA/IG1hdGNoWzBdIDogXCJcIjtcclxuXHRcdFx0XHRcdGV4cCA9IG5ldyBSZWdFeHAob2xkTnVtICsgXCIkXCIpO1xyXG5cdFx0XHRcdFx0aWQgPSBpZC5yZXBsYWNlKGV4cCwgTnVtYmVyKG9sZE51bSkgKyAxKVxyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0d2hpbGUgKGl0ZW1zLmluZGV4T2YoaWQpID4gLTEpXHJcblxyXG5cdFx0XHRcdC8vIExvZyB3YXJuaW5nXHJcblx0XHRcdFx0bG9nKFwid2FyblwiLCBcIklEIFwiICsgb2xkSWQgKyBcIiBpcyB0YWtlbi4gVXNpbmcgaW5zdGVhZCBcIiArIGlkKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGlkXHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQ2hhbmdlIHByb21pc2VzIHRvIHN5bmNcclxuXHRzeW5jTW9kZShzeW5jID0gXCJzeW5jXCIpIHtcclxuXHRcdGZvciAobGV0IHByb3Agb2YgW1wicmVzb2x2ZVwiLCBcInJlamVjdFwiLCBcImFsbFwiXSkge1xyXG5cdFx0XHRpZiAoc3luYy50b0xvd2VyQ2FzZSgpID09IFwic3luY1wiKSB7XHJcblx0XHRcdFx0cmVnaXN0cnkuUHJvbWlzZVtwcm9wXSA9IFN5bmNocm9ub3VzUHJvbWlzZVtwcm9wXS5iaW5kKFN5bmNocm9ub3VzUHJvbWlzZSk7XHJcblx0XHRcdFx0cmVnaXN0cnkuUHJvbWlzZS5tb2RlID0gXCJzeW5jXCJcclxuXHRcdFx0XHRyZWdpc3RyeS5TZXR0aW5nc1tcImNsZWFyLWhpc3Rvcnktb24tcGxheVwiXSA9IGZhbHNlXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVnaXN0cnkuUHJvbWlzZVtwcm9wXSA9IFByb21pc2VbcHJvcF0uYmluZChQcm9taXNlKVxyXG5cdFx0XHRcdHJlZ2lzdHJ5LlByb21pc2UubW9kZSA9IFwiYXN5bmNcIlxyXG5cdFx0XHRcdHJlZ2lzdHJ5LlNldHRpbmdzW1wiY2xlYXItaGlzdG9yeS1vbi1wbGF5XCJdID0gdHJ1ZVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc3RhdGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gU3RyYXRlZ3kgcmVnaXN0cmF0aW9uXHJcbnZhciB7IHJlZ2lzdGVyU3RyYXRlZ3lPYmplY3QgfSA9IHJlcXVpcmUoXCIuLi9lbmdpbmVcIikuRnJvbnRlbmQ7XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlzRnVuY3Rpb24sIG9uY2UgfSA9IHJlcXVpcmUoXCIuL2dlbmVyYWxcIik7XHJcblxyXG4vL0V4dGVybmFsIGRlcGVuZGVuY3lcclxudmFyIGVzcHJpbWEgPSByZXF1aXJlKFwiZXNwcmltYVwiKTtcclxuXHJcblxyXG4vLyBGb3IgaGFuZGxpbmcgcXVlcmllc1xyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZShcIi4uL2VuZ2luZVwiKS5CYWNrZW5kLlN0YXRlXHJcbnZhciB7IHJlZ2lzdGVyUXVlcnlPYmplY3QgfSA9IHJlcXVpcmUoXCIuLi9lbmdpbmVcIikuQmFja2VuZFxyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoXCIuL3N0YXRlXCIpXHJcblxyXG5cclxuXHJcbnZhciBzdG9ja0dhbWVzID0ge1xyXG5cdC8vIHV0aWxpdHkgZnVuY3Rpb24gdG8gY3JlYXRlIHR3byB3YXlzIHRvIGNhbGwgYSBnYW1lLCBlaXRoZXIgd2l0aCBhbGwgdGhlIGFyZ3VtZW50cywgb3IgY3VycmllZCwgd2hlcmUgdGhlIHJldHVybmVkIGZ1bmN0aW9uIHRha2VzIHBsYXllcnMgYW5kIHBhcmFtZXRlcnNcclxuXHQvLyBUaGUgY29tYmluZVBhcmFtZXRlcnMgc2V0dGluZyB3aWxsXHJcblx0Z2FtZVdyYXBwZXIoZ2FtZSwge1xyXG5cdFx0YXJndW1lbnRWYWxpZGF0b3IgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0sXHJcblx0XHRjb21iaW5lUGFyYW1ldGVycyA9IHRydWUsXHJcblx0XHRnYW1lRGVzY3JpcHRpb24gPSBcIk5vIGRlc2NyaXB0aW9uIGdpdmVuLlwiLFxyXG5cdFx0c3RyYXRlZ3lMb2FkZXIgPSBudWxsLFxyXG5cdFx0cXVlcmllcyA9IG51bGxcclxuXHR9ID0ge30pIHtcclxuXHJcblx0XHR2YXIgZ2VuZXJhdGU7XHJcblxyXG5cdFx0Ly8gSWYgdGhlcmUncyBhIHN0cmF0ZWd5IGxvYWRlciwgbWFrZSBzdXJlIGl0IG9ubHkgcnVucyBvbmNlXHJcblx0XHR2YXIgbG9hZFN0cmF0ZWdpZXNcclxuXHRcdGlmIChpc0Z1bmN0aW9uKHN0cmF0ZWd5TG9hZGVyKSkgbG9hZFN0cmF0ZWdpZXMgPSBvbmNlKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gcmVnaXN0ZXJTdHJhdGVneU9iamVjdChzdHJhdGVneUxvYWRlcigpKTtcclxuXHRcdH0pO1xyXG5cdFx0ZWxzZSBsb2FkU3RyYXRlZ2llcyA9IGZ1bmN0aW9uKCkge31cclxuXHJcblx0XHQvLyBJZiB0aGVyZSdzIGEgcXVlcnkgbG9hZGVyLCBtYWtlIHN1cmUgaXQgb25seSBydW5zIG9uY2VcclxuXHRcdHZhciBsb2FkUXVlcmllc1xyXG5cdFx0aWYgKHF1ZXJpZXMpIGxvYWRRdWVyaWVzID0gb25jZShmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHJlZ2lzdGVyUXVlcnlPYmplY3QocXVlcmllcyk7XHJcblx0XHR9KTtcclxuXHRcdGVsc2UgbG9hZFF1ZXJpZXMgPSBmdW5jdGlvbigpIHt9XHJcblxyXG5cdFx0Ly8gcnVuIHRoZSBnYW1lLiBPcHRpb25hbGx5LCB2YWxpZGF0ZSB0aGUgYXJndW1lbnRzIGFuZCBsb2FkIHN0cmFnZWllcyBmaXJzdFxyXG5cdFx0Z2VuZXJhdGUgPSBmdW5jdGlvbiguLi5hcmdzKSB7XHJcblx0XHRcdHZhciByZXN1bHQgPSBhcmd1bWVudFZhbGlkYXRvciguLi5hcmdzKVxyXG5cdFx0XHRpZiAocmVzdWx0ID09PSB0cnVlKSB7XHJcblx0XHRcdFx0bG9hZFN0cmF0ZWdpZXMoKTtcclxuXHRcdFx0XHRsb2FkUXVlcmllcygpO1xyXG5cdFx0XHRcdHJldHVybiBnYW1lKC4uLmFyZ3MpO1xyXG5cdFx0XHR9IGVsc2UgdGhyb3cgbmV3IEVycm9yKHJlc3VsdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY3JlYXRlcyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBnYW1lLCB3aGljaCBhY2NlcHRzIHRoZSBmaXJzdCBhcmd1bWVudCAocGxheWVycykgYW5kIGxhc3QgYXJndW1lbnQgKHBhcmFtZXRlcnMpLCBhbmQgcGFzc2VzIGl0IGZvcndhcmQuXHJcblx0XHQvLyBJZiBjb21iaW5lUGFyYW1ldGVycyBpcyBzZXQgdG8gdHJ1ZSwgdGhlbiB0aGUgc2Vjb25kIGFyZ3VtZW50IG9mIHRoZSByZXR1cm5lZCBmdW5jdGlvbiB3aWxsIGdldCBtZXJnZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudFxyXG5cdFx0Ly8gZ2l2ZW4gd2hlbiBnZW5lcmF0b3IgaXMgY2FsbGVkLlxyXG5cdFx0Z2VuZXJhdGUuY3JlYXRlR2VuZXJhdG9yID0gZnVuY3Rpb24oLi4uYXJncykge1xyXG5cclxuXHRcdFx0dmFyIGdhbWVDb2RlID0gZXNwcmltYS5wYXJzZVNjcmlwdChcIihcIiArIGdhbWUudG9TdHJpbmcoKSArIFwiKVwiKVxyXG5cclxuXHRcdFx0dmFyIGdhbWVBcmdzID0gZ2FtZUNvZGUuYm9keVswXS5leHByZXNzaW9uLnBhcmFtc1xyXG5cdFx0XHR2YXIgbGFzdEFyZyA9IGdhbWVBcmdzW2dhbWVBcmdzLmxlbmd0aCAtIDFdXHJcblxyXG5cdFx0XHR2YXIgb3JpZ2luYWxQYXJhbWV0ZXJzXHJcblx0XHRcdGlmICgobGFzdEFyZy5uYW1lICYmIGxhc3RBcmcubmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInBhcmFtZXRlcnNcIikgfHwgbGFzdEFyZy50eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIiB8fFxyXG5cdFx0XHRcdChsYXN0QXJnLnR5cGUgPT0gXCJBc3NpZ25tZW50UGF0dGVyblwiICYmIGxhc3RBcmcubGVmdC50eXBlID09IFwiT2JqZWN0UGF0dGVyblwiKSkge1xyXG5cdFx0XHRcdC8vIENoZWNrIHRoYXQgdGhlIGdhbWUgYXJndW1lbnRzIGFuZCBjcmVhdGVHZW5lcmF0b3IgYXJndW1lbnRzIGFyZSB0aGUgY29ycmVjdCBsZW5ndGhzLiBjcmVhdGVHZW5lcmF0b3Igc2hvdWxkIGJlXHJcblx0XHRcdFx0Ly8gMSBsZXNzIHRoYW4gZ2FtZSwgYmVjYXVzZSBwbGF5ZXJzIGlzIG9taXR0ZWQuXHJcblx0XHRcdFx0Ly8gVE9ETzogdXNlIGVzcHJpbWEgdG8gYWxsb3cgcGxheWVycyB0byBiZSBhbnl3aGVyZSBpbiB0aGUgZ2FtZSBkZWZpbml0aW9uIChvciBldmVuIG9taXR0ZWQpIHJhdGhlciB0aGFuIGZpcnN0XHJcblx0XHRcdFx0aWYgKGFyZ3MubGVuZ3RoID09IGdhbWVBcmdzLmxlbmd0aCAtIDEpIG9yaWdpbmFsUGFyYW1ldGVycyA9IGFyZ3MucG9wKCk7XHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24ocGxheWVycywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblxyXG5cdFx0XHRcdC8vIElmIGNvbWJpbmluZyBwYXJhbWV0ZXJzLCBtZXJnZSBhbmQgcmVtb3ZlIGZyb20gYXJndW1lbnRzXHJcblx0XHRcdFx0aWYgKGNvbWJpbmVQYXJhbWV0ZXJzICYmIG9yaWdpbmFsUGFyYW1ldGVycykgcGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbmFsUGFyYW1ldGVycyxcclxuXHRcdFx0XHRcdHBhcmFtZXRlcnMpXHJcblxyXG5cdFx0XHRcdHJldHVybiBnZW5lcmF0ZShwbGF5ZXJzLCAuLi5hcmdzLCBwYXJhbWV0ZXJzKVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQWxsb3cgZm9yIGdhbWUgZGVzY3JpcHRpb24gZmVhdHVyZVxyXG5cdFx0Z2VuZXJhdGUuZGVzY3JpcHRpb24gPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIGdhbWVEZXNjcmlwdGlvbjtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gRGlzcGxheSBhbnkgcXVlcmllc1xyXG5cdFx0Z2VuZXJhdGUucXVlcmllcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gcXVlcmllcztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2VuZXJhdGU7XHJcblx0fVxyXG5cclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc3RvY2tHYW1lcztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBTdHJhdGVnaWVzXHJcbnZhciB7IFN0cmF0ZWdpZXMgfSA9IHJlcXVpcmUoXCIuLi9zdHJhdGVneVwiKTtcclxuXHJcbi8vIFBsYXllcnNcclxudmFyIHsgUGxheWVyIH0gPSByZXF1aXJlKFwiLi4vcGxheWVyXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0Ly8gQ3JlYXRlIGEgcGxheWVyIGZvciBlYWNoIGF2YWlsYWJsZSBzdHJhdGVneVxyXG5cdGdlbmVyYXRlUG9wdWxhdGlvbigpIHtcclxuXHRcdHZhciBwbGF5ZXJzID0gW107XHJcblxyXG5cdFx0U3RyYXRlZ2llcygpLmZvckVhY2goZnVuY3Rpb24oc3RyYXRlZ3kpIHtcclxuXHRcdFx0cGxheWVycy5wdXNoKFBsYXllcih7IGFzc2lnbjogc3RyYXRlZ3kgfSkpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHBsYXllcnM7XHJcblx0fVxyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciB7IFN5bmNocm9ub3VzUHJvbWlzZSB9ID0gcmVxdWlyZSgnc3luY2hyb25vdXMtcHJvbWlzZScpO1xyXG5cclxudmFyIHR1cm4gPSB7XHJcblxyXG5cdC8vUmVjdXJzZSB0aHJvdWdoIHRoZSBvcHRpb25zIGluIGlucHV0LCBhbmQgd3JpdGUgdmFsIHRvIG91dHB1dC5cclxuXHRyZWN1cnNlOiBmdW5jdGlvbiByZWN1cnNlKGlucHV0LCBvdXRwdXQsIHZhbCwgdmFsR2VuZXJhdG9yID0gZnVuY3Rpb24oKSB7fSwgcGF0aCA9IFtdKSB7XHJcblxyXG5cclxuXHRcdC8vU2luY2Ugd2Ugc2xpY2UgdGhlIGFycmF5IGVhY2ggdGltZSwgaWYgdGhlcmUgYXJlIG5vIG1vcmUgZW50cmllcyBsZWZ0IHRoZW4gd2UncmUgZG9uZSB3aXRoIHRoaXMgYnJhbmNoLlxyXG5cdFx0aWYgKGlucHV0Lmxlbmd0aCA9PSAwKSByZXR1cm4gcGF0aFxyXG5cclxuXHJcblx0XHQvL0Ftb25nIGFsbCB2YWx1ZXMgZnJvbSB0aGUgYXJyYXlcclxuXHRcdHJldHVybiBpbnB1dFswXS5tYXAoZnVuY3Rpb24oaXRlbSkge1xyXG5cdFx0XHR2YXIgdmFsdWU7XHJcblx0XHRcdHZhciBzcGxpdFBhdGggPSBwYXRoLnNsaWNlKDApLmNvbmNhdChpdGVtKTtcclxuXHJcblx0XHRcdC8vSWYgdGhlcmUgYXJlIG1vcmUgaXRlbXMgdG8gaXRlcmF0ZSBvdmVyLCBpbmNsdWRlIHRoZW0gaW4gdGhlIG91dHB1dCB0aGVuIHJlY3Vyc2UuXHJcblx0XHRcdC8vSWYgbm90LCBwdXQgaW4gdGhlIG5ldyB2YWx1ZS5cclxuXHRcdFx0aWYgKGlucHV0Lmxlbmd0aCA9PSAxKSB7XHJcblxyXG5cdFx0XHRcdC8vSWYgdmFsIGlzIGEgZnVuY3Rpb24sIHdyYXAgaXQgaW4gYSBmdW5jdGlvbiB0aGF0IHdpbGwgZ2V0IHN1cHBsaWVkIGFuIGFyZ3VtZW50IHdpdGggd2hlcmUgd2UgYXJlXHJcblx0XHRcdFx0aWYgKHR5cGVvZiB2YWwgPT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRcdFx0XHR2YWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHR2YXIgYXJncyA9IFtzcGxpdFBhdGhdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHZhbC5hcHBseShudWxsLCBhcmdzKTtcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fSBlbHNlIHZhbHVlID0gdmFsIHx8IHZhbEdlbmVyYXRvcihzcGxpdFBhdGgpO1xyXG5cclxuXHRcdFx0XHRvdXRwdXRbaXRlbV0gPSB2YWx1ZTtcclxuXHRcdFx0fSBlbHNlIG91dHB1dFtpdGVtXSA9IHt9O1xyXG5cclxuXHJcblx0XHRcdHJldHVybiByZWN1cnNlKGlucHV0LnNsaWNlKDEpLCBvdXRwdXRbaXRlbV0sIHZhbCwgdmFsR2VuZXJhdG9yLCBzcGxpdFBhdGgpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gdHVybjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgeyBldmFsdWF0ZVF1ZXJ5IH0gPSByZXF1aXJlKFwiLi9xdWVyeVwiKVxyXG5cclxudmFyIHsgcmVnaXN0cnkgfSA9IHJlcXVpcmUoXCIuL3N0YXRlXCIpXHJcblxyXG52YXIgeyBpc09iamVjdCwgaXNGdW5jdGlvbiB9ID0gcmVxdWlyZShcIi4vaGVscGVyLWZ1bmN0aW9uc1wiKShcImdlbmVyYWxcIik7XHJcblxyXG4vL0V4dGVuc2lvbiBvZiBhcnJheSB0byBoYW5kbGUgaGlzdG9yeSBsaXN0cy5cclxuZnVuY3Rpb24gSGlzdG9yeSguLi5hcmdzKSB7XHJcblx0aWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIGFyZ3MgPSBhcmdzWzBdO1xyXG5cclxuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJncywgSGlzdG9yeS5wcm90b3R5cGUpO1xyXG5cclxuXHRhcmdzLmxvZyA9IGFyZ3Muc2xpY2UoKTtcclxuXHRhcmdzLmxvZy50cmVlID0gYXJncztcclxuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJncy5sb2csIEhpc3RvcnkucHJvdG90eXBlKTtcclxuXHJcblx0YXJncy5zY29yZXMgPSBbXTtcclxuXHRhcmdzLnNjb3Jlcy50cmVlID0gYXJncztcclxuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJncy5zY29yZXMsIEhpc3RvcnkucHJvdG90eXBlKTtcclxuXHJcblx0cmV0dXJuIGFyZ3M7XHJcbn1cclxuXHJcbkhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBcnJheS5wcm90b3R5cGUpO1xyXG5IaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhpc3Rvcnk7XHJcblxyXG4vL1RvIGFkZCBlbnRyeVxyXG5IaXN0b3J5LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihlbnRyeSkge1xyXG5cdC8vQWRkIHRvIGhpc3RvcnkgYW5kIHRvIGxvZ1xyXG5cdHRoaXMucHVzaChlbnRyeSk7XHJcblx0aWYgKHRoaXMubG9nKSB0aGlzLmxvZy5wdXNoKGVudHJ5KTtcclxuXHJcblx0Ly9DeWNsZSB1cCB0aGUgcGFyZW50IHRyZWUsIGFkZCB0byBlYWNoIGxvZ1xyXG5cdHZhciBjaGVjayA9IHRoaXM7XHJcblx0aWYgKGNoZWNrLnRyZWUgaW5zdGFuY2VvZiBIaXN0b3J5ICYmIGNoZWNrLnRyZWUucGFyZW50IGluc3RhbmNlb2YgSGlzdG9yeSkge1xyXG5cdFx0Y2hlY2sudHJlZS5wYXJlbnQubG9nLmFkZChlbnRyeSk7XHJcblx0fVxyXG5cdGlmIChjaGVjay5wYXJlbnQgaW5zdGFuY2VvZiBIaXN0b3J5KSB7XHJcblx0XHRjaGVjay5wYXJlbnQubG9nLmFkZChlbnRyeSk7XHJcblx0fVxyXG5cclxuXHQvL0lmIHdlJ3JlIGJlaW5nIGNhbGxlZCBmclxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vVG8gYWRkIGVudHJ5IHdpdGhvdXQgbG9nZ2luZyAoZm9yIHBsYXlhYmxlcyB0aGF0IHdvdWxkIGxpa2UgdGhlIHRyZWUgaGlzdG9yeVxyXG4vL3RvIGJlIHN0cnVjdHVyZWQgZGlmZmVyZW50bHkgdGhhbiB0aGUgbG9nIGhpc3RvcnkuXHJcbkhpc3RvcnkucHJvdG90eXBlLmFkZE5vTG9nID0gZnVuY3Rpb24oZW50cnkpIHtcclxuXHR0aGlzLnB1c2goZW50cnkpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuXHJcbkhpc3RvcnkucHJvdG90eXBlLmFkZFNjb3JlcyA9IGZ1bmN0aW9uKGVudHJ5KSB7XHJcblx0Ly9BZGQgdG8gaGlzdG9yeVxyXG5cdHRoaXMuc2NvcmVzLnB1c2goZW50cnkpO1xyXG5cclxuXHQvL0N5Y2xlIHVwIHRoZSBwYXJlbnQgdHJlZSwgYWRkIHRvIGVhY2ggbG9nXHJcblx0dmFyIGNoZWNrID0gdGhpcztcclxuXHRpZiAoY2hlY2sucGFyZW50IGluc3RhbmNlb2YgSGlzdG9yeSkge1xyXG5cdFx0Y2hlY2sucGFyZW50LmFkZFNjb3JlcyhlbnRyeSk7XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuXHJcbi8vQSB0ZW1wb3JhcnkgSGlzdG9yeSB0aGF0IGNhbiBiZSBtZXJnZWQgYmFjayBpbiBsYXRlci4gVGhlIGNoaWxkIGFuZCBwYXJlbnQgYXJlIGxpbmtlZCB1bnRpbCAub3JwaGFuKCkgaXMgY2FsbGVkLlxyXG5IaXN0b3J5LnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uKHBhcmVudCA9IHRoaXMpIHtcclxuXHR2YXIgaCA9IG5ldyBIaXN0b3J5KCk7XHJcblx0aC5wYXJlbnQgPSBwYXJlbnQ7XHJcblx0cmV0dXJuIGg7XHJcbn07XHJcblxyXG4vL1NhbWUgYXMgLmNoaWxkIGV4Y2VwdCBpbmNsdWRlcyBwcmlvciBwYXJlbnQgaGlzdG9yeSB3aGVuIC5wcmludCgpIGlzIGNhbGxlZC5cclxuSGlzdG9yeS5wcm90b3R5cGUuY2hpbGRXaXRoQ29udGVudCA9IGZ1bmN0aW9uKHBhcmVudCA9IHRoaXMpIHtcclxuXHR2YXIgc3RvcmVkTG9nID0gcGFyZW50LnNsaWNlKCk7XHJcblx0dmFyIHN0b3JlZFNjb3JlcyA9IHBhcmVudC5zbGljZSgpO1xyXG5cclxuXHR2YXIgaCA9IG5ldyBIaXN0b3J5KCk7XHJcblxyXG5cclxuXHRoLmxvZy5wcmludCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0SGlzdG9yeS5wcm90b3R5cGUucHJpbnQuY2FsbChzdG9yZWRMb2cuY29uY2F0KGgubG9nKSlcclxuXHR9XHJcblx0aC5zY29yZXMucHJpbnQgPSBmdW5jdGlvbigpIHtcclxuXHRcdEhpc3RvcnkucHJvdG90eXBlLnByaW50LmNhbGwoc3RvcmVkU2NvcmVzLmNvbmNhdChoLnNjb3JlcykpXHJcblx0fVxyXG5cclxuXHRoLnBhcmVudCA9IHBhcmVudDtcclxuXHRyZXR1cm4gaDtcclxufTtcclxuXHJcbi8vVGhpcyBzZXZlcnMgdGhlIGxpbmsgYmV0d2VlbiB0aGUgdGVtcG9yYXJ5IGhpc3RvcnkgYW5kIGl0cyBwYXJlbnQuIFVzZSB0aGlzIHdoZW4gbWVyZ2luZyBjb21wb3NpdGUgZW50cmllcy5cclxuSGlzdG9yeS5wcm90b3R5cGUub3JwaGFuID0gZnVuY3Rpb24oKSB7XHJcblx0ZGVsZXRlIHRoaXMucGFyZW50O1xyXG5cdGRlbGV0ZSB0aGlzLmxvZztcclxuXHRkZWxldGUgdGhpcy5zY29yZXM7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vL0NsZWFyIGhpc3RvcnlcclxuSGlzdG9yeS5wcm90b3R5cGUuY2xlYXJIaXN0b3J5ID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5zcGxpY2UoMCwgdGhpcy5sZW5ndGgpO1xyXG5cdGlmICh0aGlzLmxvZykgdGhpcy5sb2cuc3BsaWNlKDAsIHRoaXMubG9nLmxlbmd0aCk7XHJcblx0aWYgKHRoaXMuc2NvcmVzKSB0aGlzLnNjb3Jlcy5zcGxpY2UoMCwgdGhpcy5zY29yZXMubGVuZ3RoKTtcclxuXHRkZWxldGUgdGhpcy5wYXJlbnQ7XHJcbn07XHJcblxyXG4vL0VuZCB0aGUgZ2FtZS5cclxuSGlzdG9yeS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5zdG9wID0gdHJ1ZTtcclxuXHRpZiAodGhpcy5wYXJlbnQpIHRoaXMucGFyZW50LmVuZCgpO1xyXG59O1xyXG5cclxuLy9HZXQgYSBwYXJ0aWN1bGFyIHNvcnQgb2YgZW50cnksIGVnLiBUdXJuLlxyXG5IaXN0b3J5LnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24odHlwZSkge1xyXG5cdHJldHVybiBuZXcgSGlzdG9yeShcclxuXHRcdHRoaXMuZmlsdGVyKGZ1bmN0aW9uKGVudHJ5KSB7XHJcblx0XHRcdC8vSWYgaXQncyBub3QgYW4gb2JqZWN0LCBkb24ndCBldmVuIGJvdGhlci5cclxuXHRcdFx0aWYgKCFpc09iamVjdChlbnRyeSkpIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdGZvciAodmFyIGtleSBpbiBlbnRyeSkge1xyXG5cdFx0XHRcdGlmIChrZXkgPT0gdHlwZSkgcmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH0pXHJcblx0KTtcclxufTtcclxuXHJcbkhpc3RvcnkucHJvdG90eXBlLm1vc3RSZWNlbnQgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpc1t0aGlzLmxlbmd0aCAtIDFdXHJcbn1cclxuXHJcbi8vSGVscCByZWFkIHRoZSBoaXN0b3J5IGluIENocm9tZSB3aXRoIGxlc3MgY2x1dHRlci5cclxuSGlzdG9yeS5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgaGlzdG9yeSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcykpO1xyXG5cdGhpc3RvcnkucXVlcnkgPSBIaXN0b3J5LnByb3RvdHlwZS5xdWVyeVxyXG5cdHJldHVybiBoaXN0b3J5O1xyXG59O1xyXG5cclxuSGlzdG9yeS5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbihxdWVyeVN0cmluZywgLi4uYXJncykge1xyXG5cdHJldHVybiBldmFsdWF0ZVF1ZXJ5KHF1ZXJ5U3RyaW5nLCB0aGlzLCAuLi5hcmdzKVxyXG59XHJcblxyXG4vL1N1cHBseSBhbiBlbnRyeSwgaXQgd2lsbCBjaGVjayBmb3IgYSBwcm9wZXJ0eSB0aGF0IGlzIGEgSGlzdG9yeVxyXG5IaXN0b3J5LnByb3RvdHlwZS5yZWN1cnNlID0gZnVuY3Rpb24odHlwZSkge1xyXG5cdHZhciBsaXN0ID0gdGhpcztcclxuXHJcblx0cmV0dXJuIG5ldyBIaXN0b3J5KFxyXG5cdFx0bGlzdC5tYXAoZnVuY3Rpb24oZW50cnkpIHtcclxuXHRcdFx0Zm9yICh2YXIga2V5IGluIGVudHJ5KSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coa2V5LCBlbnRyeSk7XHJcblx0XHRcdFx0aWYgKGVudHJ5W2tleV0gaW5zdGFuY2VvZiBIaXN0b3J5KSByZXR1cm4gZW50cnlba2V5XS5yZWN1cnNlKHR5cGUpO1xyXG5cdFx0XHRcdGVsc2UgaWYgKGtleSA9PSB0eXBlKSByZXR1cm4gZW50cnk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9KVxyXG5cdCk7XHJcbn07XHJcblxyXG4vL0FjY2VwdCBhIEhpc3RvcnkgYW5kIHJldHVybiBvbmUgc3VpdGFibGUgZm9yIHRoZSB1c2VyXHJcbmZ1bmN0aW9uIFVzZXJIaXN0b3J5KGhpc3RvcnkpIHtcclxuXHR2YXIgdXNlckhpc3RvcnkgPSBoaXN0b3J5Lm1hcChmdW5jdGlvbihlbnRyeSkge1xyXG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZW50cnkpKTtcclxuXHR9KTtcclxuXHRpZiAoaGlzdG9yeS5sb2cpIHtcclxuXHRcdHVzZXJIaXN0b3J5LmxvZyA9IG5ldyBVc2VySGlzdG9yeShoaXN0b3J5LmxvZylcclxuXHR9O1xyXG5cdGlmIChoaXN0b3J5LnNjb3Jlcykge1xyXG5cdFx0dXNlckhpc3Rvcnkuc2NvcmVzID0gbmV3IFVzZXJIaXN0b3J5KGhpc3Rvcnkuc2NvcmVzKVxyXG5cdH1cclxuXHJcblx0T2JqZWN0LnNldFByb3RvdHlwZU9mKHVzZXJIaXN0b3J5LCBVc2VySGlzdG9yeS5wcm90b3R5cGUpO1xyXG5cclxuXHQvL0F0dGFjaCBtZXRob2RzIGZyb20gSGlzdG9yeSwgd3JhcHBlZCBpbiBhIGZ1bmN0aW9uLiBJZiB0aG9zZSBtZXRob2RzIHJldHVybiBhIGhpc3RvcnksXHJcblx0Ly90aGVuIHRoZSBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgdGhhdCB0byBhIHVzZXJIaXN0b3J5LlxyXG5cdGZvciAodmFyIG1ldGhvZCBpbiBIaXN0b3J5LnByb3RvdHlwZSkge1xyXG5cdFx0aWYgKGlzRnVuY3Rpb24oaGlzdG9yeVttZXRob2RdKSkge1xyXG5cdFx0XHRpZiAobWV0aG9kICE9IFwiY29uc3RydWN0b3JcIilcclxuXHRcdFx0XHR1c2VySGlzdG9yeVttZXRob2RdID0gKGZ1bmN0aW9uKG1ldGhvZCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gaGlzdG9yeVttZXRob2RdLmFwcGx5KGhpc3RvcnksIGFyZ3VtZW50cyk7XHJcblx0XHRcdFx0XHRcdGlmIChyZXN1bHQgaW5zdGFuY2VvZiBIaXN0b3J5KSByZXR1cm4gbmV3IFVzZXJIaXN0b3J5KHJlc3VsdCk7XHJcblx0XHRcdFx0XHRcdGVsc2UgaWYgKGlzT2JqZWN0KHJlc3VsdCkpXHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XHJcblx0XHRcdFx0XHRcdGVsc2UgcmV0dXJuIHJlc3VsdDtcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fSkobWV0aG9kKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB1c2VySGlzdG9yeTtcclxufVxyXG5cclxuVXNlckhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShIaXN0b3J5LnByb3RvdHlwZSk7XHJcblVzZXJIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVzZXJIaXN0b3J5O1xyXG5cclxudmFyIGdhbWVIaXN0b3J5ID0gbmV3IEhpc3RvcnkoKTsgLy9UT0RPOiBhZGQgY2hvaWNlLW9ubHkgaGlzdG9yeVxyXG5cclxudmFyIHVzZXJHYW1lSGlzdG9yeSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgVXNlckhpc3RvcnkoZ2FtZUhpc3RvcnkpXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBIaXN0b3J5LCBVc2VySGlzdG9yeSwgZ2FtZUhpc3RvcnksIHVzZXJHYW1lSGlzdG9yeSB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vV2hlbiBhIHN0cmF0ZWd5J3MgLmNob29zZSgpIGZ1bmN0aW9uIGlzIGNhbGxlZCwgaXQgaXMgZ2l2ZW4gYW4gaW5mb3JtYXRpb24gc2V0LiBUaGF0IGRhdGEgaXMgYSBsaW1pdGVkIG1hcCBvZiB0aGUgaW50ZXJuYWwgb2JqZWN0cyBvZiB0aGUgZ2FtZSBlbmdpbmUsIGluY2x1ZGluZyBpbmZvcm1hdGlvbiBvbiB0aGUgZ2FtZSBoaXN0b3J5IGFuZCB0aGUgcGxheWVycy4gVGhpcyBpcyB0aHJlYWRlZCB0aHJvdWdoIHBsYXlhYmxlcywgbXVjaCBsaWtlIEhpc3RvcnksIHNvIHRoYXQgYSBwYXJlbnQgcGxheWFibGUgY2FuIHNwZWNpZnkgYW4gaW5mb3JtYXRpb24gc2V0IGZvciB0aGUgcGxheWFibGVzIGl0IGNhbGxzLCBvciBlbHNlIHRoZSBkZWZhdWx0IGNvbnN0cnVjdGlvbiB3aWxsIGJlIHVzZWQuIEFkZGl0aW9uYWxseSwgdGhlIHVzZXIgY2FuIHByb3ZpZGUgYSBmaWx0ZXIgZnVuY3Rpb24sIHRvIHNlbGVjdGl2ZWx5IGRlbGV0ZSAob3IgYWRkKSBpbmZvcm1hdGlvbiBlbGVtZW50cyBiZWZvcmUgdGhleSBhcmUgcGFzc2VkIHRvIC5jaG9vc2UoKS5cclxuXHJcbi8vSGlzdG9yeSBmdW5jdGlvbnNcclxudmFyIHsgZ2FtZUhpc3RvcnksIEhpc3RvcnkgfSA9IHJlcXVpcmUoJy4vaGlzdG9yeScpO1xyXG5cclxuLy9Qb3B1bGF0aW9uIGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lUG9wdWxhdGlvbiwgUGxheWVyTGlzdCB9ID0gcmVxdWlyZSgnLi9wb3B1bGF0aW9uJyk7XHJcblxyXG5cclxuZnVuY3Rpb24gSW5mb3JtYXRpb24oaGlzdG9yeSA9IGdhbWVIaXN0b3J5LCBwb3B1bGF0aW9uID0gZ2FtZVBvcHVsYXRpb24sIHsgcGFyZW50SGlzdG9yeSA9IFtdIH0gPSB7fSkge1xyXG5cdHRoaXMuaGlzdG9yeSA9IGhpc3Rvcnk7XHJcblx0dGhpcy5wb3B1bGF0aW9uID0gcG9wdWxhdGlvbjtcclxuXHJcblx0Ly8gUmVjb3JkIGFueSBoaXN0b3J5IGVudHJpZXMgdGhhdCBuZWVkIHRvIGJlIGFkZGVkIHRvIHRoZSByZWNvcmRzXHJcblx0dGhpcy5wYXJlbnRIaXN0b3J5ID0gcGFyZW50SGlzdG9yeS5zbGljZSgwKTtcclxuXHJcblx0dGhpcy5hZGRpdGlvbmFsID0gW107XHJcblxyXG5cdHRoaXMudXBkYXRlKCk7XHJcbn07XHJcblxyXG4vL0NoZWNrIHRoZSBzb3VyY2UgdGhlbiBjYWNoZSBhIGhhcmQtY29weS5cclxuSW5mb3JtYXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHBsYXllciwgbG9jYWwpIHtcclxuXHR0aGlzLmluZm9Qb3B1bGF0aW9uID0gdGhpcy5wb3B1bGF0aW9uKCkuaW5mbygpO1xyXG5cclxuXHR0aGlzLmluZm9IaXN0b3J5ID0ge1xyXG5cdFx0bG9nOiB0aGlzLnBhcmVudEhpc3RvcnkuY29uY2F0KHRoaXMuaGlzdG9yeS5sb2cpLFxyXG5cdFx0c2NvcmVzOiB0aGlzLmhpc3Rvcnkuc2NvcmVzXHJcblx0XHRcdC5zbGljZSgwKVxyXG5cdH07XHJcblxyXG5cdHRoaXMuYWRkaXRpb25hbCA9IFtdO1xyXG5cclxuXHQvL1JldHVybiB2YWx1ZS4gTWltaWNzIC5kZWxpdmVyKClcclxuXHR2YXIgaW5mb3JtYXRpb24gPSB7XHJcblx0XHRoaXN0b3J5OiB7IGxvZzogdGhpcy5pbmZvSGlzdG9yeS5sb2csIHNjb3JlczogdGhpcy5pbmZvSGlzdG9yeS5zY29yZXMgfSxcclxuXHRcdHBvcHVsYXRpb246IHRoaXNcclxuXHRcdFx0LmluZm9Qb3B1bGF0aW9uXHJcblx0fVxyXG5cdGlmIChwbGF5ZXIpIGluZm9ybWF0aW9uLm1lID0gaW5mb3JtYXRpb24ucG9wdWxhdGlvbi5nZXQocGxheWVyLmlkKTtcclxuXHRpZiAobG9jYWwpIE9iamVjdC5hc3NpZ24oaW5mb3JtYXRpb24sIGxvY2FsKTtcclxuXHJcblx0cmV0dXJuIGluZm9ybWF0aW9uO1xyXG59O1xyXG5cclxuLy9DbG9uZSB0aGUgY2FjaGVkIGNvcGllcyBhbmQgcHJvdmlkZSB0aGVtLiBXaWxsIGRlbGl2ZXIgdGhlIHNhbWUgdGhpbmcgZXZlcnkgdGltZSB1bnRpbCB1cGRhdGUgaXMgY2FsbGVkLlxyXG5JbmZvcm1hdGlvbi5wcm90b3R5cGUuZGVsaXZlciA9IGZ1bmN0aW9uKHBsYXllciwgbG9jYWwpIHtcclxuXHR2YXIgaW5mb3JtYXRpb24gPSB7XHJcblx0XHRoaXN0b3J5OiB7IGxvZzogdGhpcy5pbmZvSGlzdG9yeS5sb2csIHNjb3JlczogdGhpcy5pbmZvSGlzdG9yeS5zY29yZXMgfSxcclxuXHRcdHBvcHVsYXRpb246IHRoaXNcclxuXHRcdFx0LmluZm9Qb3B1bGF0aW9uXHJcblx0fVxyXG5cclxuXHJcblx0aWYgKHBsYXllcikgaW5mb3JtYXRpb24ubWUgPSBpbmZvcm1hdGlvbi5wb3B1bGF0aW9uLmdldChwbGF5ZXIuaWQpO1xyXG5cdGlmIChsb2NhbCkgT2JqZWN0LmFzc2lnbihpbmZvcm1hdGlvbiwgbG9jYWwpO1xyXG5cdGlmICh0aGlzLmFkZGl0aW9uYWwpIHRoaXMuYWRkaXRpb25hbC5mb3JFYWNoKGZ1bmN0aW9uKGVudHJ5KSB7IE9iamVjdC5hc3NpZ24oaW5mb3JtYXRpb24sIGVudHJ5KSB9KTtcclxuXHJcblx0cmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5mb3JtYXRpb24pKTtcclxufTtcclxuXHJcbi8vVGhpcyBwcm9iYWJseSBkb2Vzbid0IG5lZWQgdG8gYmUgYSBzZXBhcmF0ZSBmdW5jdGlvbiwgYnV0IGFkZGluZyBpdCBpbiBjYXNlIGl0IGV4cGFuZHMgbGF0ZXIuXHJcbkluZm9ybWF0aW9uLnByb3RvdHlwZS5hZGRBZGRpdGlvbmFsID0gZnVuY3Rpb24oZW50cnkgPSBudWxsKSB7XHJcblx0aWYgKGVudHJ5KSB0aGlzLmFkZGl0aW9uYWwucHVzaChlbnRyeSk7XHJcbn07XHJcblxyXG4vL01ha2UgY29weSBvZiB0aGlzIGluZm9ybWF0aW9uIGZ1bmN0aW9uLCB3aGljaCBhbGxvd3MgZm9yIHVwZGF0aW5nIGFuZCBmcmVlemluZy5cclxuSW5mb3JtYXRpb24ucHJvdG90eXBlLmNoaWxkID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGluZm9ybWF0aW9uID0gbmV3IEluZm9ybWF0aW9uKHRoaXMuaGlzdG9yeSwgdGhpcy5wb3B1bGF0aW9uLCB7IHBhcmVudEhpc3Rvcnk6IHRoaXMucGFyZW50SGlzdG9yeSB9KTtcclxuXHJcblx0cmV0dXJuIGluZm9ybWF0aW9uO1xyXG59O1xyXG5cclxuXHJcblxyXG4vL0dhbWUgc3RhdGUsIGFuYWxvZ291cyB0byBnYW1lSGlzdG9yeVxyXG52YXIgUGVyZmVjdEluZm9ybWF0aW9uID0gbmV3IEluZm9ybWF0aW9uKGdhbWVIaXN0b3J5LCBnYW1lUG9wdWxhdGlvbik7XHJcblxyXG4vL092ZXJ3cml0ZSAuZGVsaXZlcigpLiBQZXJmZWN0SW5mb3JtYXRpb24gaXMgYWx3YXlzIHVwLXRvLWRhdGUhIFRodXMgbm8gbmVlZCB0byBkbyBhIDJuZCBKU09OLnN0cmluZ2lmeS5cclxuUGVyZmVjdEluZm9ybWF0aW9uLmRlbGl2ZXIgPSBmdW5jdGlvbihwbGF5ZXIsIGxvY2FsKSB7XHJcblxyXG5cdHZhciBpbmZvcm1hdGlvbiA9IHRoaXMudXBkYXRlKHBsYXllciwgbG9jYWwpO1xyXG5cclxuXHRpZiAocGxheWVyKSBpbmZvcm1hdGlvbi5tZSA9IGluZm9ybWF0aW9uLnBvcHVsYXRpb24uZ2V0KHBsYXllci5pZCk7XHJcblx0aWYgKGxvY2FsKSBPYmplY3QuYXNzaWduKGluZm9ybWF0aW9uLCBsb2NhbCk7XHJcblxyXG5cdHJldHVybiBpbmZvcm1hdGlvbjtcclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgSW5mb3JtYXRpb24sIFBlcmZlY3RJbmZvcm1hdGlvbiB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG52YXIgbG9nZ2VyID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGFyZ3MgPSBbLi4uYXJndW1lbnRzXTtcclxuXHR2YXIgbGV2ZWwgPSAoYXJnc1swXSA9PSBcInNpbGx5XCIgfHwgIWFyZ3NbMF0pID8gXCJ0cmFjZVwiIDogYXJnc1swXTtcclxuXHR2YXIgbGV2ZWwgPSBsZXZlbCA9PSBcIndhcm5pbmdcIiA/IFwid2FyblwiIDogbGV2ZWw7XHJcblx0YXJncy5zaGlmdCgpO1xyXG5cclxuXHRsb2dnZXIubG9nZ2VyW2xldmVsXS5hcHBseShsb2dnZXIubG9nZ2VyLCBhcmdzKTtcclxufTtcclxuXHJcbi8vbG9nZ2VyLmxvZ2dlciA9IGNvbnNvbGU7XHRcdFx0XHRcdC8vVE9ETyBjbGVhbiB0aGlzIGFsbCB1cCBhIGxvdC5cclxuXHJcbnZhciBnZXRMb2dnZXIgPSByZXF1aXJlKFwibG9nbGV2ZWwtY29sb3JlZC1sZXZlbC1wcmVmaXhcIik7XHJcbnZhciBvcHRpb25zID0geyBwcmVmaXg6ICduYXNoSlMnLCBsZXZlbDogJ3RyYWNlJyB9XHJcbmxvZ2dlci5sb2dnZXIgPSBnZXRMb2dnZXIob3B0aW9ucylcclxuXHJcbmxvZ2dlci5zZXRMZXZlbCA9IGZ1bmN0aW9uKGxldmVsKSB7XHJcblx0bG9nZ2VyLmxvZ2dlci5sZXZlbCA9IGxldmVsO1xyXG5cdGxvZ2dlci5sb2dnZXIuc2V0TGV2ZWwobGV2ZWwpXHJcbn07XHJcblxyXG4vKlxyXG5sb2dnZXIudXNlV2luc3RvbiA9IGZ1bmN0aW9uKCl7XHJcblxyXG5cdHZhciB3aW5zdG9uID0gcmVxdWlyZSgnd2luc3RvbicpO1xyXG5cdHZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xyXG5cclxuXHR3aW5zdG9uLmxldmVsID0gXCJ3YXJuXCI7XHJcblxyXG5cdHdpbnN0b24uY2xlYXIoKVxyXG5cdHdpbnN0b24uYWRkKHdpbnN0b24udHJhbnNwb3J0cy5Db25zb2xlLCB7XHJcblx0XHRsZXZlbDogJ3RyYWNlJyxcclxuXHRcdHByZXR0eVByaW50OiAgZnVuY3Rpb24gKCBvYmplY3QgKXtcclxuXHRcdFx0cmV0dXJuIHV0aWwuaW5zcGVjdChvYmplY3QpO1xyXG5cdFx0fSxcclxuXHRcdGNvbG9yaXplOiB0cnVlLFxyXG5cdFx0c2lsZW50OiBmYWxzZSxcclxuXHRcdHRpbWVzdGFtcDogZmFsc2VcclxuXHR9KTtcclxuXHJcblx0dGhpcy5sb2dnZXIgPSB3aW5zdG9uO1xyXG59O1xyXG4qL1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBsb2dnZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpc0Z1bmN0aW9uIH0gPSByZXF1aXJlKFwiLi9oZWxwZXItZnVuY3Rpb25zXCIpKFwiZ2VuZXJhbFwiKTtcclxuXHJcbi8vIEV4dGVuZCBmdW5jdGlvbiwgdGhlIHNuZWFreSB3YXkuXHJcbnZhciB2YXJpYWJsZVByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRnVuY3Rpb24ucHJvdG90eXBlKTtcclxuXHJcbnZhcmlhYmxlUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZnVuY3Rpb24odmFsdWUsIHsgZW5mb3JjZU51bWJlciA9IHRydWUgfSA9IHt9KSB7XHJcblx0dmFyIHZhcmlhYmxlID0gdGhpcztcclxuXHR2YXJpYWJsZS52YWx1ZSA9IGVuZm9yY2VOdW1iZXIgPyB2YWx1ZSAqIDEgOiB2YWx1ZTtcclxuXHR2YXJpYWJsZS5lbmZvcmNlTnVtYmVyID0gZW5mb3JjZU51bWJlclxyXG5cclxuXHR0aGlzLmlkID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gX3BsYXlhYmxlLmlkO1xyXG5cdH07IC8vVE9ETzogd29yayBvbiBpZHMgYW5kIHJlZ2lzdHJhdGlvblxyXG59O1xyXG5cclxudmFyaWFibGVQcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLnZhbHVlO1xyXG59O1xyXG5cclxudmFyaWFibGVQcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuY2FsbCgpO1xyXG59O1xyXG52YXJpYWJsZVByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmNhbGwoKTtcclxufTtcclxudmFyaWFibGVQcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmNhbGwoKTtcclxufTtcclxuXHJcbnZhcmlhYmxlUHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XHJcblx0dGhpcy52YWx1ZSA9IHRoaXMuZW5mb3JjZU51bWJlciA/IG5ld1ZhbHVlICogMSA6IG5ld1ZhbHVlXHJcblx0cmV0dXJuIHRoaXMudmFsdWU7XHJcbn07XHJcblxyXG4vL1JlcHVycG9zZSB0aGUgdmVyeS1zaW1pbGFyIGNvZGUgZm9yIFZhcmlhYmxlLCBidXQgcmUtd3JpdGUgY2VydGFpbiBrZXlzXHJcbnZhciBleHByZXNzaW9uUHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGdW5jdGlvbi5wcm90b3R5cGUpO1xyXG5cclxuZXhwcmVzc2lvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcclxuXHRpZiAoIWlzRnVuY3Rpb24oZXhwcmVzc2lvbikpIGxvZyhcImVycm9yXCIsIFwiRXhwcmVzc2lvbiBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xyXG5cclxuXHR2YXIgdmFsdWUgPSBleHByZXNzaW9uKCk7XHJcblx0aWYgKGlzTmFOKHZhbHVlKSkgbG9nKFwiZXJyb3JcIiwgXCJFeHByZXNzaW9uIG11c3QgcmV0dXJuIGEgbnVtYmVyXCIpOyAvL1RPRE86IHNob3VsZCBFeHByZXNzaW9ucy9WYXJpYWJsZXMgYWxsb3cgc3RyaW5ncz9cclxuXHJcblx0dGhpcy52YWx1ZSA9IGV4cHJlc3Npb247XHJcblxyXG5cdHJldHVybiB2YWx1ZTtcclxufTtcclxuXHJcbmV4cHJlc3Npb25Qcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLnZhbHVlKCkgKiAxO1xyXG59O1xyXG5cclxuZXhwcmVzc2lvblByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5jYWxsKCk7XHJcbn07XHJcbmV4cHJlc3Npb25Qcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5jYWxsKCk7XHJcbn07XHJcbmV4cHJlc3Npb25Qcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmNhbGwoKTtcclxufTtcclxuXHJcbmV4cHJlc3Npb25Qcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmV3RXhwcmVzc2lvbikge1xyXG5cdGlmICghaXNGdW5jdGlvbihuZXdFeHByZXNzaW9uKSlcclxuXHRcdGxvZyhcImVycm9yXCIsIFwiRXhwcmVzc2lvbiBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xyXG5cclxuXHR2YXIgdmFsdWUgPSBuZXdFeHByZXNzaW9uKCk7XHJcblx0dGhpcy52YWx1ZSA9IG5ld0V4cHJlc3Npb247XHJcblxyXG5cdHJldHVybiB2YWx1ZTtcclxufTtcclxuXHJcbi8vUHJvZHVjZXMgdGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBwcm9kdWNlIHRoZSBlbmQgcmVzdWx0LiBUaGlzIHBhcnQgaXMgcmV1c2FibGUgaWYgeW91IG5lZWQgdG8gZG8gdGhpcyBhZ2Fpbi5cclxudmFyIGNsYXNzRmFjdG9yeSA9IGZ1bmN0aW9uKHByb3RvKSB7XHJcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGYgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIGYuY2FsbC5hcHBseShmLCBhcmd1bWVudHMpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJjb25zdHJ1Y3RvclwiLCB7XHJcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuXHRcdFx0d3JpdGFibGU6IHRydWVcclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwiY2FsbFwiLCB7XHJcblx0XHRcdHdyaXRhYmxlOiB0cnVlXHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcInRvU3RyaW5nXCIsIHtcclxuXHRcdFx0d3JpdGFibGU6IHRydWVcclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwidmFsdWVPZlwiLCB7XHJcblx0XHRcdHdyaXRhYmxlOiB0cnVlXHJcblx0XHR9KTtcclxuXHJcblx0XHRPYmplY3Qua2V5cyhwcm90bykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuXHRcdFx0ZltrZXldID0gcHJvdG9ba2V5XTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdGYuY29uc3RydWN0b3IuYXBwbHkoZiwgYXJndW1lbnRzKTtcclxuXHJcblx0XHRyZXR1cm4gZjtcclxuXHR9O1xyXG59O1xyXG5cclxudmFyIFZhcmlhYmxlID0gY2xhc3NGYWN0b3J5KHZhcmlhYmxlUHJvdG90eXBlKTtcclxudmFyIEV4cHJlc3Npb24gPSBjbGFzc0ZhY3RvcnkoZXhwcmVzc2lvblByb3RvdHlwZSk7XHJcbi8vIGNhbGxlZCBhczogdmFyIGluc3RhbmNlID0gVmFyaWFibGUoKTtcclxuXHJcbi8vIEEgcHJlLWJ1aWx0IEV4cHJlc3Npb24gZ2VuZXJhdG9yLCBmb3IgZ2VuZXJhdGluZyByYW5kb20gbnVtYmVyc1xyXG52YXIgUmFuZG9tVmFyaWFibGUgPSBmdW5jdGlvbih7IGxvd2VyYm91bmQgPSAwLCB1cHBlcmJvdW5kID0gMTAsIGdlbmVyYXRvciA9IFwidW5pZm9ybVwiIH0pIHtcclxuXHJcblx0aWYgKGlzRnVuY3Rpb24oZ2VuZXJhdG9yKSkge1xyXG5cdFx0dmFyIGV4cHJlc3Npb24gPSBFeHByZXNzaW9uKGdlbmVyYXRvcik7XHJcblx0XHRleHByZXNzaW9uLmdlbmVyYXRvciA9IGdlbmVyYXRvcjtcclxuXHRcdHJldHVybiBleHByZXNzaW9uO1xyXG5cclxuXHR9IGVsc2UgaWYgKGdlbmVyYXRvci50b0xvd2VyQ2FzZSgpID09IFwidW5pZm9ybVwiKSB7XHJcblx0XHRnZW5lcmF0b3IgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICh1cHBlcmJvdW5kIC0gbG93ZXJib3VuZCArIDEpICsgbG93ZXJib3VuZCk7XHJcblx0XHR9O1xyXG5cdFx0Ly9cdFRPRE86IGFkZCBtb3JlIGRpc3RyaWJ1dGlvbnMgaGVyZS5cclxuXHR9XHJcblxyXG5cdHJldHVybiBFeHByZXNzaW9uKGdlbmVyYXRvcik7XHJcbn07XHJcblxyXG5cclxuXHJcbi8vIEEgd2F5IHRvIGhhdmUgVmFyaWFibGVzIHdoaWNoIGFyZSBtb3JlIGNvbXBsaWNhdGVkIHRoaW5ncywgbGlrZSBhcnJheXMgb3Igb2JlY3RzXHJcbnZhciBDb21wbGV4VmFyaWFibGUgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdHZhciB2YXJpYWJsZSA9IFZhcmlhYmxlKHZhbHVlLCB7IGVuZm9yY2VOdW1iZXI6IGZhbHNlIH0pXHJcblxyXG5cdHZhciBleGNsdWRlTGlzdCA9IFtcInNldFwiLCBcImNhbGxcIiwgXCJ0b0pTT05cIiwgXCJ0b1N0cmluZ1wiLCBcInZhbHVlT2ZcIl1cclxuXHJcblx0dmFyIGhhbmRsZXIgPSB7XHJcblx0XHRnZXQodGFyZ2V0LCBrZXkpIHtcclxuXHRcdFx0dmFyIHByb3A7XHJcblx0XHRcdGlmIChleGNsdWRlTGlzdC5pbmRleE9mKGtleSkgPiAtMSkgcHJvcCA9IHRhcmdldFtrZXldLmJpbmQodGFyZ2V0KTtcclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0cHJvcCA9IHRhcmdldC52YWx1ZVtrZXldXHJcblx0XHRcdFx0aWYgKGlzRnVuY3Rpb24ocHJvcCkpIHByb3AgPSBwcm9wLmJpbmQodGFyZ2V0LnZhbHVlKVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcHJvcFxyXG5cdFx0fSxcclxuXHRcdHNldCh0YXJnZXQsIGtleSwgcHJvcCkge1xyXG5cdFx0XHR0YXJnZXQudmFsdWVba2V5XSA9IHByb3A7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gbmV3IFByb3h5KHZhcmlhYmxlLCBoYW5kbGVyKVxyXG59XHJcblxyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHR2YXJpYWJsZVByb3RvdHlwZSxcclxuXHRWYXJpYWJsZSxcclxuXHRleHByZXNzaW9uUHJvdG90eXBlLFxyXG5cdEV4cHJlc3Npb24sXHJcblx0UmFuZG9tVmFyaWFibGUsXHJcblx0Q29tcGxleFZhcmlhYmxlXHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XHJcbmxvZyhcImRlYnVnXCIsIFwiTG9hZGluZyBDbGFzczogQ2hvaWNlXCIpO1xyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKFwiLi4vc3RhdGVcIik7XHJcbnZhciBQcm9taXNlID0gcmVnaXN0cnkuUHJvbWlzZTsgLy8gRm9yIHN5bmMgbW9kZVxyXG5cclxudmFyIHsgZ2FtZUhpc3RvcnkgfSA9IHJlcXVpcmUoXCIuLi9oaXN0b3J5XCIpO1xyXG52YXIgeyBQZXJmZWN0SW5mb3JtYXRpb24gfSA9IHJlcXVpcmUoXCIuLi9pbmZvcm1hdGlvblwiKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXItZnVuY3Rpb25zXCIpKFwic3RhdGVcIik7XHJcbnZhciB7IGlzRnVuY3Rpb24gfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXItZnVuY3Rpb25zXCIpKFwiZ2VuZXJhbFwiKTtcclxudmFyIHsgY2hhaW5lckdlbmVyYXRvciB9ID0gcmVxdWlyZShcIi4uL2hlbHBlci1mdW5jdGlvbnNcIikoXCJwbGF5YWJsZVwiKTtcclxuXHJcbi8vUGFyZW50IGNsYXNzXHJcbnZhciB7IEJyYW5jaCwgX1BsYXlhYmxlLCBQbGF5YWJsZSB9ID0gcmVxdWlyZShcIi4vcGxheWFibGVcIik7XHJcblxyXG5cclxuLy8gQnJhbmNoIHN1YmNsYXNzXHJcbnZhciBDaG9pY2VCcmFuY2ggPSAoZnVuY3Rpb24oKSB7XHJcblx0Ly8gUHJpdmF0ZSBkYXRhXHJcblx0dmFyIF9jaG9pY2VzID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcblx0Y2xhc3MgQ2hvaWNlQnJhbmNoIGV4dGVuZHMgQnJhbmNoIHtcclxuXHRcdGNvbnN0cnVjdG9yKHBhdGgsIF9jaG9pY2UpIHtcclxuXHRcdFx0c3VwZXIocGF0aCwgX2Nob2ljZS5pbnRlcmZhY2UpXHJcblx0XHRcdF9jaG9pY2VzLnNldCh0aGlzLCBfY2hvaWNlKVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRoZSBfX2NhbGxfXyBmdW5jdGlvbiwgdGhpcyB3aWxsIHNldCB0aGUgcGF5b2ZmIG9mIHRoZSBicmFuY2hcclxuXHRcdHBheW9mZihwYXlvZmYpIHtcclxuXHRcdFx0dmFyIF9jaG9pY2UgPSBfY2hvaWNlcy5nZXQodGhpcylcclxuXHRcdFx0aWYgKCFpc05hTihwYXlvZmYpKSBfY2hvaWNlLnBheW9mZnNbdGhpcy5wYXRoWzBdXSA9IHBheW9mZjtcclxuXHRcdFx0ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDaG9pY2UgcGF5b2ZmIG11c3QgYmUgYSBudW1iZXIuXCIpXHJcblx0XHRcdHJldHVybiBzdXBlci5wYXlvZmYoKVxyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gQ2hvaWNlQnJhbmNoO1xyXG59KSgpXHJcblxyXG5cclxuXHJcbi8vIEhpZGRlbiBjbGFzcyBmb3IgQ2hvaWNlIHBsYXlhYmxlXHJcbmNsYXNzIF9DaG9pY2UgZXh0ZW5kcyBfUGxheWFibGUge1xyXG5cdGNvbnN0cnVjdG9yKGlkLCBwbGF5ZXIsIG9wdGlvbnMsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdFx0c3VwZXIoaWQsIHBhcmFtZXRlcnMpXHJcblxyXG5cdFx0dGhpcy5wbGF5ZXIgPSByZWdpc3RyeS5wbGF5ZXJzW3BsYXllcl07XHJcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG5cdFx0dGhpcy5kZWZhdWx0T3B0aW9uID0gcGFyYW1ldGVycy5kZWZhdWx0T3B0aW9uIHx8IG9wdGlvbnNbMF07IC8vVE9ETzogbWFrZSBkZWZhdWx0T3B0aW9uIGZ1bmN0aW9uYWxcclxuXHRcdHRoaXMucGxheWVyTWV0aG9kID0gcGFyYW1ldGVycy5wbGF5ZXJNZXRob2QgfHwgXCJjaG9vc2VcIlxyXG5cdFx0dGhpcy5pbmZvcm1hdGlvbkZpbHRlciA9IHBhcmFtZXRlcnMuaW5mb3JtYXRpb25GaWx0ZXIgfHwgbnVsbDtcclxuXHRcdHRoaXMudXNlUGF5b2ZmcyA9IHBhcmFtZXRlcnMudXNlUGF5b2ZmcyB8fCBmYWxzZTtcclxuXHRcdHRoaXMuemVyb1BheW9mZnMoKSAvL0NyZWF0ZSBwYXlvZmZzIGFueXdheSBpbiBjYXNlIHdlIHVzZSB0aGVtIGxhdGVyXHJcblxyXG5cdFx0dGhpcy5uZXh0ID0ge307XHJcblxyXG5cdFx0dmFyIGNob2ljZSA9IHRoaXM7XHJcblx0XHR0aGlzLm9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRcdGNob2ljZS5uZXh0W2l0ZW1dID0gW107XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cclxuXHRwbGF5KHtcclxuXHRcdHVzZVBheW9mZnMgPSB0aGlzLnVzZVBheW9mZnMsXHJcblx0XHRoaXN0b3J5ID0gZ2FtZUhpc3RvcnksXHJcblx0XHRpbmZvcm1hdGlvbjogcmF3SW5mb3JtYXRpb24gPSBQZXJmZWN0SW5mb3JtYXRpb24sXHJcblx0XHRyZWxlYXNlUGxheWVyID0gdHJ1ZSxcclxuXHRcdGluZm9ybWF0aW9uRmlsdGVyID0gdGhpcy5pbmZvcm1hdGlvbkZpbHRlcixcclxuXHRcdF9jb21waWxlSW5mb3JtYXRpb24gPSBudWxsXHJcblx0fSA9IHt9KSB7XHJcblx0XHR2YXIgY2hvaWNlID0gdGhpcztcclxuXHJcblx0XHRpZiAoIWNob2ljZS5wbGF5ZXIuYWxpdmUpXHJcblx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdCh7XHJcblx0XHRcdFx0cmVzdWx0OiBjaG9pY2UuaWQgKyBcIjogUGxheWVyIFwiICsgY2hvaWNlLnBsYXllci5pZCArIFwiIGlzIGRlYWQuXCJcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0Ly9XaGlsZSB0aGlzIGNob2ljZSBpcyBoYXBwZW5pbmcsIGRvbid0IGFsbG93IG90aGVyIGNob2ljZXMgdG8gdXNlIHRoaXMgcGxheWVyLlxyXG5cdFx0Y2hvaWNlLnBsYXllci5hdmFpbGFibGUgPSBmYWxzZTtcclxuXHJcblx0XHQvL0luZm9ybWF0aW9uIG1lY2hhbmljcy4gSWYgd2UncmUgZGVhbGluZyB3aXRoIFBlcmZlY3RJbmZvcm1hdGlvbiwgdGhpcyB3b24ndCBnZXQgZGVsaXZlcmVkLCBzbyB3ZSdsbCBpbmNsdWRlIGl0IGluIHRoZSBjYWxsIHRvIC5kZWxpdmVyKCkuIElmIHdlJ3JlIHVzaW5nIGFuIGluZm9ybWF0aW9uIHN1cHBsaWVkIGZyb20gc29tZSBvdGhlciBwbGF5YWJsZSwgdGhlbiB0aGV5IGNhbiBkbyB3aGF0IHRoZXkgbGlrZSB3aXRoIGl0LlxyXG5cdFx0dmFyIGNob2ljZUluZm8gPSB7XHJcblx0XHRcdGNob2ljZToge1xyXG5cdFx0XHRcdGlkOiBjaG9pY2UuaWQsXHJcblx0XHRcdFx0cGxheWVyOiBjaG9pY2UucGxheWVyLmlkLFxyXG5cdFx0XHRcdG9wdGlvbnM6IGNob2ljZS5vcHRpb25zXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0XHRyYXdJbmZvcm1hdGlvbi5hZGRBZGRpdGlvbmFsKGNob2ljZUluZm8pO1xyXG5cdFx0Ly9QZXJmb3JtIHNvbWUgZGF0YSBwcm9jZXNzaW5nIGlmIG90aGVyIHBsYXlhYmxlcyBuZWVkIGl0LlxyXG5cdFx0aWYgKF9jb21waWxlSW5mb3JtYXRpb24pIF9jb21waWxlSW5mb3JtYXRpb24ocmF3SW5mb3JtYXRpb24pO1xyXG5cclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxyXG5cdFx0XHQudGhlbihmdW5jdGlvbigpIHtcclxuXHRcdFx0XHQvL1ByZXAgaW5mb3JtYXRpb25cclxuXHRcdFx0XHR2YXIgaW5mb3JtYXRpb24gPSByYXdJbmZvcm1hdGlvbi5kZWxpdmVyKGNob2ljZS5wbGF5ZXIsIGNob2ljZUluZm8pO1xyXG5cdFx0XHRcdGlmIChpbmZvcm1hdGlvbkZpbHRlcikgaW5mb3JtYXRpb24gPSBpbmZvcm1hdGlvbkZpbHRlcihpbmZvcm1hdGlvbik7XHJcblxyXG5cdFx0XHRcdHJldHVybiBjaG9pY2UucGxheWVyLmNob29zZShjaG9pY2Uub3B0aW9ucy5zbGljZSgwKSwgaW5mb3JtYXRpb24sIGNob2ljZS5wbGF5ZXJNZXRob2QpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0XHR2YXIgcGxheWVyID0gY2hvaWNlLnBsYXllcjtcclxuXHRcdFx0XHR2YXIgaWQgPSBjaG9pY2UuaWQ7XHJcblxyXG5cdFx0XHRcdC8vQWRkIHRvIHBsYXllcidzIGluZGl2aWR1YWwgaGlzdG9yeTtcclxuXHRcdFx0XHRwbGF5ZXIuaGlzdG9yeS5wdXNoKHtcclxuXHRcdFx0XHRcdGNob2ljZTogaWQsXHJcblx0XHRcdFx0XHRvcHRpb25zOiBjaG9pY2Uub3B0aW9ucyxcclxuXHRcdFx0XHRcdHJlc3VsdFxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRyZXN1bHQgPSByZXN1bHQgfHwgY2hvaWNlLmRlZmF1bHRPcHRpb247XHJcblxyXG5cdFx0XHRcdHZhciByZXN1bHRPYmplY3QgPSB7XHJcblx0XHRcdFx0XHRyZXN1bHQsXHJcblx0XHRcdFx0XHRoaXN0b3J5RW50cnk6IHtcclxuXHRcdFx0XHRcdFx0Y2hvaWNlOiBpZCxcclxuXHRcdFx0XHRcdFx0cGxheWVyOiBwbGF5ZXIuaWQsXHJcblx0XHRcdFx0XHRcdHJlc3VsdFxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdC8vVGhpcyB3aWxsIHByb2JhYmx5IG9ubHkgaGFwcGVuIGlmIGl0J3MgYSBzaW5nbGUtcGxheWVyIGdhbWUsIG90aGVyd2lzZSB3ZSdsbCB1c2UgcGxheW9mZnMgZGVmaW5lZCBpbiBhIFR1cm5cclxuXHRcdFx0XHRpZiAodXNlUGF5b2Zmcykge1xyXG5cdFx0XHRcdFx0dmFyIHBheW91dCA9IGNob2ljZS5wYXlvZmZzW3Jlc3VsdF07XHJcblxyXG5cdFx0XHRcdFx0cGxheWVyLnNjb3JlICs9IHBheW91dDtcclxuXHJcblx0XHRcdFx0XHQvL3RyYWNrIHRoZSBwYXlvZmZcclxuXHRcdFx0XHRcdHZhciBzY29yZUVudHJ5ID0ge1xyXG5cdFx0XHRcdFx0XHRjaG9pY2U6IGlkLFxyXG5cdFx0XHRcdFx0XHRwYXlvdXRzOiB7XHJcblx0XHRcdFx0XHRcdFx0W3BsYXllci5pZF06IHBheW91dFxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0aGlzdG9yeS5hZGRTY29yZXMoc2NvcmVFbnRyeSk7XHJcblxyXG5cdFx0XHRcdFx0cmVzdWx0T2JqZWN0Lmhpc3RvcnlFbnRyeS5wYXlvdXRzID0ge1xyXG5cdFx0XHRcdFx0XHRbcGxheWVyLmlkXTogcGF5b3V0XHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bG9nKFxyXG5cdFx0XHRcdFx0XCJzaWxseVwiLFxyXG5cdFx0XHRcdFx0XCJfQ2hvaWNlLnBsYXk6IHJlbW92aW5nIGZyb20gb2NjdXBpZWRQbGF5ZXJzOiBcIixcclxuXHRcdFx0XHRcdGNob2ljZS5wbGF5ZXIuaWRcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHRcdGlmIChyZWxlYXNlUGxheWVyKSBjaG9pY2UucmVsZWFzZVBsYXllcigpO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdE9iamVjdCk7XHJcblx0XHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdC8vUmVsZWFzZSBwbGF5ZXIgZnJvbSBleGNsdWRlZCBwbGF5ZXJzIGxpc3QsIHNvIHRoYXQgb3RoZXIgb2JqZWN0cyBjYW4gdXNlIGl0LlxyXG5cdHJlbGVhc2VQbGF5ZXIoKSB7XHJcblx0XHR0aGlzLnBsYXllci5hdmFpbGFibGUgPSB0cnVlO1xyXG5cdH07XHJcblxyXG5cdGZpbmROZXh0KHsgcmVzdWx0IH0gPSB7fSkge1xyXG5cdFx0cmV0dXJuIHRoaXMubmV4dFtyZXN1bHQucmVzdWx0XTtcclxuXHR9O1xyXG5cclxuXHRnZW5lcmF0ZUJyYW5jaGVzKCkge1xyXG5cdFx0dmFyIF9jaG9pY2UgPSB0aGlzO1xyXG5cdFx0dmFyIGNob2ljZSA9IF9jaG9pY2UuaW50ZXJmYWNlXHJcblxyXG5cdFx0X2Nob2ljZS5vcHRpb25zLmZvckVhY2goZnVuY3Rpb24ob3B0aW9uKSB7XHJcblx0XHRcdGNob2ljZVtvcHRpb25dID0gbmV3IENob2ljZUJyYW5jaChbb3B0aW9uXSwgX2Nob2ljZSlcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdHN1bW1hcnlUaGlzKHN1bW1hcnkpIHtcclxuXHRcdHN1bW1hcnkoXCJwbGF5ZXJcIiwgdGhpcy5wbGF5ZXIuaWQpO1xyXG5cdFx0c3VtbWFyeShcIm9wdGlvbnNcIiwgdGhpcy5vcHRpb25zLnNsaWNlKCkpO1xyXG5cdFx0Ly8gSW5jbHVkZSBtZXRob2QsIGJ1dCBvbmx5IGlmIGl0J3Mgbm90IHRoZSBkZWZhdWx0LlxyXG5cdFx0aWYgKHRoaXMucGxheWVyTWV0aG9kICE9IFwiY2hvb3NlXCIpIHN1bW1hcnkoXCJtZXRob2RcIiwgdGhpcy5wbGF5ZXJNZXRob2QpXHJcblxyXG5cdFx0cmV0dXJuIHN1bW1hcnk7XHJcblx0fTtcclxuXHJcblx0Ly9UT0RPOiB1bi1mdWNrIHRoaXMuXHJcblx0c3VtbWFyeU5leHQoc3VtbWFyeSkge1xyXG5cdFx0Ly8gY29uc3RydWN0IHRoZSB0cmVlIGluIHRoZSBzdW1tYXJ5IGJhc2VkIG9uIGF2YWlsYWJsZSBvcHRpb25zXHJcblx0XHR2YXIgY291bnQgPSAwXHJcblx0XHRzdW1tYXJ5LnRyZWVBcnJheShcIm5leHRcIiwgW3RoaXMub3B0aW9uc10sIHRoaXMubmV4dCwgZnVuY3Rpb24ocGxheWFibGUsIHBhdGgsIHN1bW1hcnkpIHtcclxuXHRcdFx0Y291bnQrKztcclxuXHRcdFx0cmV0dXJuIHBsYXlhYmxlLnN1bW1hcml6ZShzdW1tYXJ5KVxyXG5cdFx0fSlcclxuXHJcblx0XHQvLyBpZiB0aGVyZSdzIG5vIHJlc3VsdCwgZGVsZXRlIHRoZSB0YWcgdG8gYXZvaWQgY2x1dHRlclxyXG5cdFx0aWYgKCFjb3VudCkgc3VtbWFyeS5kZWxldGUoXCJuZXh0XCIpXHJcblxyXG5cdFx0cmV0dXJuIHN1bW1hcnk7XHJcblx0fTtcclxuXHJcblx0Ly9TZXQgYWxsIHBheW9mZnMgdG8gemVyby5cclxuXHR6ZXJvUGF5b2ZmcygpIHtcclxuXHRcdHZhciBjaG9pY2UgPSB0aGlzO1xyXG5cclxuXHRcdGNob2ljZS5wYXlvZmZzID0ge307XHJcblxyXG5cdFx0Y2hvaWNlLm9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbihvcHRpb24pIHtcclxuXHRcdFx0Y2hvaWNlLnBheW9mZnNbb3B0aW9uXSA9IDA7XHJcblx0XHR9KTtcclxuXHR9O1xyXG59XHJcbl9DaG9pY2UucmVnaXN0cnlOYW1lID0gXCJkZWNpc2lvbnNcIjtcclxuX0Nob2ljZS5jb3VudGVyTmFtZSA9IFwiY2hvaWNlXCI7XHJcblxyXG5cclxuLy8gRnJvbnRlbmQgY2xhc3MgZm9yIENob2ljZVxyXG5jbGFzcyBDaG9pY2UgZXh0ZW5kcyBQbGF5YWJsZSB7XHJcblx0Y29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRcdHZhciBpZCA9IGlkSGFuZGxlcihwYXJhbWV0ZXJzLmlkLCBcImNob2ljZVwiKTtcclxuXHJcblx0XHQvL0lmIGluZm9ybWF0aW9uRmlsdGVyIHdhcyBzdXBwbGllZCwgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uXHJcblx0XHRpZiAocGFyYW1ldGVycy5pbmZvcm1hdGlvbkZpbHRlciAmJiAhaXNGdW5jdGlvbihwYXJhbWV0ZXJzLmluZm9ybWF0aW9uRmlsdGVyKSlcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiaW5mb3JtYXRpb25GaWx0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xyXG5cclxuXHRcdC8vQ3JlYXRlIGJhY2tlbmQgY2hvaWNlIG9iamVjdFxyXG5cdFx0dmFyIF9jaG9pY2UgPSBuZXcgX0Nob2ljZShpZCwgcGxheWVyLmlkKCksIG9wdGlvbnMsIHBhcmFtZXRlcnMpO1xyXG5cclxuXHRcdC8vIFJ1biBQbGF5YWJsZSBjb25zdHJ1Y3RvclxyXG5cdFx0c3VwZXIoX2Nob2ljZSlcclxuXHJcblx0XHRfY2hvaWNlLmdlbmVyYXRlQnJhbmNoZXMoKTtcclxuXHR9XHJcblxyXG5cdC8vVXNlciBjYW4gc2V0IGFsbCBwYXlvZmZzIGF0IG9uY2UgdXNpbmcgYW4gYXJyYXlcclxuXHRzZXRBbGxQYXlvZmZzKHBheW9mZnMpIHtcclxuXHRcdGlmICghQXJyYXkuaXNBcnJheShwYXlvZmZzKSkgdGhyb3cgbmV3IEVycm9yKFwiUGF5b2ZmcyBtdXN0IGJlIGFycmF5XCIpXHJcblxyXG5cdFx0dmFyIGlkID0gdGhpcy5pZCgpXHJcblx0XHR2YXIgb3B0aW9ucyA9IHJlZ2lzdHJ5LmRlY2lzaW9uc1tpZF0ub3B0aW9uc1xyXG5cclxuXHRcdGlmIChwYXlvZmZzLmxlbmd0aCAhPSBvcHRpb25zLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKFxyXG5cdFx0XHRcIlBheW9mZnMgbXVzdCBiZSBzYW1lIGRpbWVuc2lvbnMgYXMgY2hvaWNlIG9wdGlvbnNcIilcclxuXHJcblx0XHRwYXlvZmZzLmZvckVhY2goZnVuY3Rpb24ocGF5b2ZmLCBpbmRleCkge1xyXG5cdFx0XHRyZWdpc3RyeS5kZWNpc2lvbnNbaWRdLnBheW9mZnNbb3B0aW9uc1tpbmRleF1dID0gcGF5b2ZmO1xyXG5cdFx0fSlcclxuXHR9XHJcblxyXG5cdC8vIEEgd2F5IGZvciB0aGUgdXNlciB0byBpbnRlcmFjdCB3aXRoIHRoZSBwYXlvZmZzXHJcblx0cGF5b2ZmcygpIHtcclxuXHRcdHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlZ2lzdHJ5LmRlY2lzaW9uc1t0aGlzLmlkKCldLnBheW9mZnMpKVxyXG5cdH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IENob2ljZUJyYW5jaCwgX0Nob2ljZSwgQ2hvaWNlIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XHJcbmxvZyhcImRlYnVnXCIsIFwiTG9hZGluZyBDbGFzczogQ29uc2VjdXRpdmVcIik7XHJcblxyXG4vL0dhbWUgc3RhdGUgY29udHJvbGxlcnNcclxudmFyIHsgcmVnaXN0cnkgfSA9IHJlcXVpcmUoXCIuLi9zdGF0ZVwiKTtcclxudmFyIFByb21pc2UgPSByZWdpc3RyeS5Qcm9taXNlOyAvLyBGb3Igc3luYyBtb2RlXHJcbnZhciB7IGdhbWVIaXN0b3J5IH0gPSByZXF1aXJlKFwiLi4vaGlzdG9yeVwiKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXItZnVuY3Rpb25zXCIpKFwic3RhdGVcIik7XHJcblxyXG4vL0luZm9ybWF0aW9uXHJcbnZhciB7IEluZm9ybWF0aW9uLCBQZXJmZWN0SW5mb3JtYXRpb24gfSA9IHJlcXVpcmUoXCIuLi9pbmZvcm1hdGlvblwiKTtcclxuXHJcbi8vUGFyZW50IGNsYXNzXHJcbnZhciB7IF9QbGF5YWJsZSwgUGxheWFibGUgfSA9IHJlcXVpcmUoXCIuL3BsYXlhYmxlXCIpO1xyXG5cclxuLy9CYWNrZW5kIGZ1bmN0aW9uIGNsYXNzIGZvciBDb25zZWN1dGl2ZVxyXG5mdW5jdGlvbiBfQ29uc2VjdXRpdmUoaWQsIHBsYXlhYmxlc0FycmF5LCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRfUGxheWFibGUuY2FsbCh0aGlzLCBpZCwgcGFyYW1ldGVycyk7XHJcblxyXG5cdHBsYXlhYmxlc0FycmF5ID0gcGxheWFibGVzQXJyYXkubWFwKGZ1bmN0aW9uKHBsYXlhYmxlKSB7XHJcblx0XHRyZXR1cm4gcmVnaXN0cnkucGxheWFibGVzW3BsYXlhYmxlLmlkKCldXHJcblx0fSlcclxuXHR0aGlzLnBsYXlhYmxlc0FycmF5ID0gcGxheWFibGVzQXJyYXlcclxufVxyXG5fQ29uc2VjdXRpdmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfUGxheWFibGUucHJvdG90eXBlKTtcclxuX0NvbnNlY3V0aXZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9Db25zZWN1dGl2ZTtcclxuXHJcbl9Db25zZWN1dGl2ZS5yZWdpc3RyeU5hbWUgPSBcImNvbnNlY3V0aXZlc1wiO1xyXG5fQ29uc2VjdXRpdmUuY291bnRlck5hbWUgPSBcImNvbnNlY3V0aXZlXCI7XHJcblxyXG5fQ29uc2VjdXRpdmUucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7XHJcblx0aGlzdG9yeSA9IGdhbWVIaXN0b3J5LFxyXG5cdGluZm9ybWF0aW9uID0gdGhpcy5pbmZvcm1hdGlvbiB8fFxyXG5cdFBlcmZlY3RJbmZvcm1hdGlvblxyXG59ID0ge30pIHtcclxuXHJcblx0dmFyIGNvbnNlY3V0aXZlID0gdGhpcztcclxuXHJcblx0Ly9Mb2cgdGhlIGhpc3RvcnkgYXBwcm9wcmlhdGVseVxyXG5cdHZhciBzdGFydEVudHJ5ID0ge1xyXG5cdFx0Y29uc2VjdXRpdmU6IGNvbnNlY3V0aXZlLmlkLFxyXG5cdFx0YWN0aW9uOiBcInN0YXJ0XCJcclxuXHR9O1xyXG5cdGhpc3RvcnkubG9nLmFkZChzdGFydEVudHJ5KTtcclxuXHJcblx0Ly9IaXN0b3J5IG9iamVjdCB0byBnaXZlIHRvIGNvbnNlY3V0aXZlZCBwbGF5YWJsZXMuXHJcblx0dmFyIGNvbnNlY3V0aXZlSGlzdG9yeSA9IGhpc3RvcnkuY2hpbGQoKTtcclxuXHJcblx0Ly9jb21wYXJ0bWVudGFsaXplIGlmIHNldC4gXCJjb21wYXJ0bWVudGFsaXplXCIgbWVhbnMgcGFzcyBvbiBpbmZvcm1hdGlvbiBhcyBpZiB0aGlzIHBsYXlhYmxlIGlzIHRoZSBlbnRpcmUgZ2FtZS5cclxuXHRpZiAoY29uc2VjdXRpdmUuY29tcGFydG1lbnRhbGl6ZSkge1xyXG5cdFx0aW5mb3JtYXRpb24gPSBuZXcgSW5mb3JtYXRpb24oY29uc2VjdXRpdmUuY29tcGFydG1lbnRhbGl6ZS5oaXN0b3J5IHx8IGNvbnNlY3V0aXZlSGlzdG9yeSxcclxuXHRcdFx0Y29uc2VjdXRpdmUuY29tcGFydG1lbnRhbGl6ZS5wb3B1bGF0aW9uIHx8IGluZm9ybWF0aW9uLnBvcHVsYXRpb24pO1xyXG5cdH1cclxuXHJcblx0dmFyIGFjdGlvbiA9IGZ1bmN0aW9uIGFjdGlvbihwbGF5YWJsZXNBcnJheSkge1xyXG5cdFx0Ly9TdG9wIGlmIHRoZSBnYW1lIGlzIG92ZXIuXHJcblx0XHRpZiAoaGlzdG9yeS5zdG9wKSByZXR1cm4geyBwbGF5YWJsZTogY29uc2VjdXRpdmUgfTtcclxuXHJcblx0XHRpZiAocGxheWFibGVzQXJyYXkubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRyZXR1cm4gcGxheWFibGVzQXJyYXkuc2hpZnQoKS5wbGF5KHsgc2hvcnRDaXJjdWl0OiB0cnVlLCBoaXN0b3J5OiBjb25zZWN1dGl2ZUhpc3RvcnksIGluZm9ybWF0aW9uIH0pXHJcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gYWN0aW9uKHBsYXlhYmxlc0FycmF5KSB8fCByZXN1bHRcclxuXHRcdFx0XHR9KVxyXG5cdFx0fSBlbHNlIHJldHVybiBmYWxzZVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGFjdGlvbihjb25zZWN1dGl2ZS5wbGF5YWJsZXNBcnJheS5zbGljZSgpKVxyXG5cdFx0LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdHJlc3VsdC5oaXN0b3J5RW50cnkgPSB7XHJcblx0XHRcdFx0Y29uc2VjdXRpdmU6IGNvbnNlY3V0aXZlLmlkLFxyXG5cdFx0XHRcdGFjdGlvbjogY29uc2VjdXRpdmVIaXN0b3J5Lm9ycGhhbigpXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHQvL1RPRE86IGFkZCBpbmZvcm1hdGlvbiBtZWNoYW5pc21zXHJcblxyXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcblx0XHR9KTtcclxufTtcclxuXHJcbi8vT3ZlcndyaXRlIGhpc3RvcnkgaGFuZGxlciBzbyB0aGF0IHRyZWUgZG9lc24ndCBoYXZlIFwic3RhcnRcIiBhbmQgXCJmaW5pc2hcIiBlbnRyaWVzLlxyXG5fQ29uc2VjdXRpdmUucHJvdG90eXBlLmhhbmRsZUhpc3RvcnkgPSBmdW5jdGlvbih7IGhpc3RvcnkgPSBnYW1lSGlzdG9yeSB9ID0ge30sXHJcblx0cmVzdWx0XHJcbikge1xyXG5cdHZhciBjb25zZWN1dGl2ZSA9IHRoaXM7XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0aGlzdG9yeS5sb2cuYWRkKHtcclxuXHRcdFx0Y29uc2VjdXRpdmU6IGNvbnNlY3V0aXZlLmlkLFxyXG5cdFx0XHRhY3Rpb246IFwiZmluaXNoXCIsXHJcblx0XHRcdGR1cmF0aW9uOiByZXN1bHQuaGlzdG9yeUVudHJ5LmR1cmF0aW9uXHJcblx0XHR9KTtcclxuXHJcblx0XHRoaXN0b3J5LmFkZE5vTG9nKHJlc3VsdC5oaXN0b3J5RW50cnkpO1xyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuLy9UT0RPOiBmaW5pc2ggdGhpcyFcclxuX0NvbnNlY3V0aXZlLnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnksIGVudHJpZXMsIHNob3J0Q2lyY3VpdCkge1xyXG5cdHN1bW1hcnkuYWN0aW9uID0ge307XHJcblxyXG5cdHRoaXMucGxheWFibGVTdGFydC5zdW1tYXJpemUoXHJcblx0XHRzdW1tYXJ5LmFjdGlvbixcclxuXHRcdGVudHJpZXMsXHJcblx0XHQoc2hvcnRDaXJjdWl0ID0gdGhpcy5wbGF5YWJsZUZpbmlzaClcclxuXHQpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gQ29uc2VjdXRpdmUocGxheWFibGVzQXJyYXksIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihwYXJhbWV0ZXJzLmlkLCBcImNvbnNlY3V0aXZlXCIpO1xyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIGxvb3Agb2JqZWN0XHJcblx0dmFyIF9jb25zZWN1dGl2ZSA9IG5ldyBfQ29uc2VjdXRpdmUoaWQsIHBsYXlhYmxlc0FycmF5LCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0Ly9SZXR1cm4gdGhpcyByZWZlcmVuY2Ugb2JqZWN0IHRvIHRoZSB1c2VyLiBSdW4gdGhlIGZ1bmN0aW9uIHRvIHNlbGVjdCBhIHNvdXJjZVxyXG5cdHZhciBjb25zZWN1dGl2ZSA9IFBsYXlhYmxlKF9jb25zZWN1dGl2ZSk7XHJcblxyXG5cdGNvbnNlY3V0aXZlLmlkcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHBsYXlhYmxlc0FycmF5Lm1hcChmdW5jdGlvbihwbGF5YWJsZSkge1xyXG5cdFx0XHRyZXR1cm4gcGxheWFibGUuaWQoKTtcclxuXHRcdH0pXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gY29uc2VjdXRpdmU7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBfQ29uc2VjdXRpdmUsIENvbnNlY3V0aXZlIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgQ2xhc3M6IEhhbHRJZlwiKVxyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKCcuLi9zdGF0ZScpO1xyXG52YXIgUHJvbWlzZSA9IHJlZ2lzdHJ5LlByb21pc2U7IC8vIEZvciBzeW5jIG1vZGVcclxudmFyIHsgZ2FtZUhpc3RvcnkgfSA9IHJlcXVpcmUoJy4uL2hpc3RvcnknKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpc0Z1bmN0aW9uIH0gPSByZXF1aXJlKCcuLi9oZWxwZXItZnVuY3Rpb25zJykoXCJnZW5lcmFsXCIpO1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoJy4uL2hlbHBlci1mdW5jdGlvbnMnKShcInN0YXRlXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9ID0gcmVxdWlyZSgnLi9wbGF5YWJsZScpO1xyXG5cclxuXHJcblxyXG4vL0JhY2tlbmQgZnVuY3Rpb24gY2xhc3MgZm9yIEdhbWVcclxuZnVuY3Rpb24gX0hhbHQoaWQsIHRlc3RDb25kaXRpb24sIHsgbG9nQ29udGludWUgPSBmYWxzZSB9KSB7XHJcblx0X1BsYXlhYmxlLmNhbGwodGhpcywgaWQpO1xyXG5cclxuXHR0aGlzLnRlc3RDb25kaXRpb24gPSB0ZXN0Q29uZGl0aW9uO1xyXG5cdHRoaXMubG9nQ29udGludWUgPSBsb2dDb250aW51ZTtcclxufVxyXG5cclxuX0hhbHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfUGxheWFibGUucHJvdG90eXBlKTtcclxuX0hhbHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gX0hhbHQ7XHJcblxyXG5fSGFsdC5yZWdpc3RyeU5hbWUgPSBcImhhbHRzXCI7XHJcbl9IYWx0LmNvdW50ZXJOYW1lID0gXCJoYWx0SWZcIjtcclxuXHJcbl9IYWx0LnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oeyBpbml0aWFsaXplUGxheWVycyA9IGZhbHNlLCBzaG9ydENpcmN1aXQgPSBmYWxzZSwgaGlzdG9yeSA9IGdhbWVIaXN0b3J5IH0gPSB7fSkge1xyXG5cclxuXHR2YXIgaGFsdCA9IHRoaXM7XHJcblxyXG5cdHZhciByZXN1bHRPYmplY3QgPSB7XHJcblx0XHQncGxheWFibGUnOiBoYWx0LFxyXG5cdFx0J2hpc3RvcnlFbnRyeSc6IHtcclxuXHRcdFx0J2hhbHQnOiBoYWx0LmlkXHJcblx0XHR9XHJcblx0fTtcclxuXHJcblxyXG5cdHZhciB0ZXN0ID0gaGFsdC50ZXN0Q29uZGl0aW9uKCk7XHJcblxyXG5cclxuXHRpZiAodGVzdCkge1xyXG5cdFx0bG9nKFwiaW5mb1wiLCBcIkhhbHRpbmcgYXQgXCIgKyBoYWx0LmlkKVxyXG5cclxuXHRcdHJlc3VsdE9iamVjdC5oaXN0b3J5RW50cnkuYWN0aW9uID0gXCJoYWx0XCI7XHJcblx0XHRyZXN1bHRPYmplY3QucmVzdWx0ID0gXCJIYWx0XCI7XHJcblxyXG5cdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KHJlc3VsdE9iamVjdCk7XHJcblx0fVxyXG5cclxuXHQvL0hhbHQgcHJvYmFibHkgZ2V0cyB1c2VkIGZvciBsb29wcywgYW5kIHdlIG1pZ2h0IG5vdCB3YW50IHRvIHNlZSBsb3RzIG9mIGNvbnRpbnVlIG1lc3NhZ2VzLCBzbyBcImxvZ0NvbnRpbnVlXCIgd2lsbCBvbWl0IHRoZW0uXHJcblx0aWYgKGhhbHQubG9nQ29udGludWUpIHtcclxuXHRcdHJlc3VsdE9iamVjdC5oaXN0b3J5RW50cnkuYWN0aW9uID0gXCJjb250aW51ZVwiO1xyXG5cdH0gZWxzZSBkZWxldGUgcmVzdWx0T2JqZWN0Lmhpc3RvcnlFbnRyeVxyXG5cclxuXHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRPYmplY3QpXHJcbn07XHJcblxyXG5cclxuX0hhbHQucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSkge1xyXG5cdHN1bW1hcnkuY29uZGl0aW9uID0gdGhpcy50ZXN0Q29uZGl0aW9uLnRvU3RyaW5nKCk7XHJcbn1cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gSGFsdElmKHRlc3RDb25kaXRpb24gPSBmdW5jdGlvbigpIHt9LCB7IGlkID0gbnVsbCwgbG9nQ29udGludWUgPSBmYWxzZSB9ID0ge30pIHtcclxuXHR2YXIgaWQgPSBpZEhhbmRsZXIoaWQsIFwiaGFsdElmXCIpXHJcblxyXG5cdGlmICghaXNGdW5jdGlvbih0ZXN0Q29uZGl0aW9uKSkgbG9nKFwid2FyblwiLCBpZCArXHJcblx0XHRcIjogdGVzdENvbmRpdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiwgb3IgZWxzZSBnYW1lIHdpbGwgbm90IGhhbHQuXCIpXHJcblxyXG5cdC8vQ3JlYXRlIGJhY2tlbmQgbG9vcCBvYmplY3RcclxuXHR2YXIgX2hhbHQgPSBuZXcgX0hhbHQoaWQsIHRlc3RDb25kaXRpb24sIHsgbG9nQ29udGludWUgfSk7XHJcblxyXG5cclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIGhhbHQgPSBQbGF5YWJsZShfaGFsdCk7XHJcblx0cmV0dXJuIGhhbHQ7XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX0hhbHQsIEhhbHRJZiB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vTG9hZHMgdGhlIHBsYXlhYmxlcyB0aGF0IHdpbGwgYmUgdXNlZCBieSBOYXNoLiBUaGlzIGlzIGJhc2ljYWxseSB0aGUgY29udHJvbGxlciBsaXN0OiBpZiBpdCdzIG5vdCBpbiB0aGVzZSBsaXN0cyxcclxuLy8gdGhlbiBpdCB3b24ndCBiZSBhdmFpbGFibGUgZm9yIHVzLlxyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XHJcbmxvZyhcImRlYnVnXCIsIFwiTG9hZGluZyBQbGF5YWJsZSBDbGFzc2VzOiBcIik7XHJcblxyXG4vL0V4dGVybmFsIGRlcGVuZGVuY3lcclxudmFyIHByZXNlbnQgPSByZXF1aXJlKFwicHJlc2VudFwiKTtcclxuXHJcbi8vIFV0aWxpdHkgZnVuY3Rpb25cclxudmFyIHsgYXBwbHlCaW5kIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyLWZ1bmN0aW9uc1wiKShcImdlbmVyYWxcIik7XHJcblxyXG4vLyBoaXN0b3J5IGNvbnRyb2xsZXJcclxudmFyIHsgZ2FtZUhpc3RvcnkgfSA9IHJlcXVpcmUoXCIuLi9oaXN0b3J5XCIpXHJcblxyXG4vL1BsYXlhYmxlc1xyXG52YXIgeyBfUGxheWFibGUgfSA9IHJlcXVpcmUoXCIuL3BsYXlhYmxlXCIpO1xyXG52YXIgeyBfQ2hvaWNlLCBDaG9pY2UgfSA9IHJlcXVpcmUoXCIuL2Nob2ljZVwiKTtcclxudmFyIHsgX1JhbmdlLCBSYW5nZSB9ID0gcmVxdWlyZShcIi4vcmFuZ2VcIik7XHJcbnZhciB7IF9UdXJuLCBUdXJuIH0gPSByZXF1aXJlKFwiLi90dXJuXCIpO1xyXG52YXIgeyBfU2VxdWVuY2UsIFNlcXVlbmNlIH0gPSByZXF1aXJlKFwiLi9zZXF1ZW5jZVwiKTtcclxudmFyIHsgX0NvbnNlY3V0aXZlLCBDb25zZWN1dGl2ZSB9ID0gcmVxdWlyZShcIi4vY29uc2VjdXRpdmVcIik7XHJcbnZhciB7IF9Mb29wLCBMb29wIH0gPSByZXF1aXJlKFwiLi9sb29wXCIpO1xyXG52YXIgeyBfU0xvb3AsIFN0b2NoYXN0aWNMb29wIH0gPSByZXF1aXJlKFwiLi9zdG9jaGFzdGljTG9vcFwiKTtcclxudmFyIHsgX0hhbHQsIEhhbHRJZiB9ID0gcmVxdWlyZShcIi4vaGFsdC1pZlwiKTtcclxudmFyIHsgX1NIYWx0LCBTdG9jaGFzdGljSGFsdCB9ID0gcmVxdWlyZShcIi4vc3RvY2hhc3RpYy1oYWx0XCIpO1xyXG52YXIgeyBfTGFtYmRhLCBMYW1iZGEgfSA9IHJlcXVpcmUoXCIuL2xhbWJkYVwiKTtcclxudmFyIHsgX1JQQ2hvaWNlLCBSYW5kb21QbGF5ZXJDaG9pY2UgfSA9IHJlcXVpcmUoXCIuL3JhbmRvbS1wbGF5ZXItY2hvaWNlXCIpO1xyXG52YXIgeyBfUG9wdWxhdGlvbkR5bmFtaWNzLCBQb3B1bGF0aW9uRHluYW1pY3MgfSA9IHJlcXVpcmUoXCIuL3BvcHVsYXRpb24tZHluYW1pY3NcIik7XHJcbnZhciB7IF9TaW11bHRhbmVvdXMsIFNpbXVsdGFuZW91cyB9ID0gcmVxdWlyZShcIi4vc2ltdWx0YW5lb3VzXCIpO1xyXG5cclxuLy9SdW5zIHdoZW4gbG9hZGluZyBQbGF5YWJsZSBjbGFzc2VzLlxyXG5mdW5jdGlvbiBpbml0aWFsaXplUGxheWFibGVDbGFzcyhwbGF5YWJsZUNsYXNzKSB7XHJcblxyXG5cdC8vUmVwbGFjZSB0aGUgLnBsYXkoKSBtZXRob2Qgd2l0aCBhIHdyYXBwZXIgd2hpY2ggY2FsbHMgaXQgYW5kIGEgZmV3IG90aGVyIGZ1bmN0aW9uc1xyXG5cdGlmIChwbGF5YWJsZUNsYXNzLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShcInBsYXlcIikpIHtcclxuXHRcdHBsYXlhYmxlQ2xhc3MucHJvdG90eXBlLnBsYXkgPSAoZnVuY3Rpb24ocGxheSkge1xyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xyXG5cdFx0XHRcdGlmICghYXJnc1swXSkgYXJnc1swXSA9IHt9XHJcblx0XHRcdFx0dmFyIHBsYXlhYmxlID0gdGhpcztcclxuXHJcblx0XHRcdFx0Ly8gU2V0IG91ciBoaXN0b3J5XHJcblx0XHRcdFx0YXJnc1swXS5oaXN0b3J5ID8gbnVsbCA6IGFyZ3NbMF0uaGlzdG9yeSA9IHRoaXMuaGlzdG9yeSB8fCBnYW1lSGlzdG9yeVxyXG5cclxuXHRcdFx0XHQvLyBob3cgdG8gaGFsdCB0aGUgZ2FtZSB3aXRob3V0IGVycm9ycy4gVE9ETyB0aGlzIGlzIHByb2JhYmx5IGZ1Y2tlZFxyXG5cdFx0XHRcdGlmIChhcmdzWzBdLmhpc3Rvcnkuc3RvcCkgcmV0dXJuIHsgcGxheWFibGUgfTtcclxuXHJcblxyXG5cdFx0XHRcdHJldHVybiBfUGxheWFibGUucHJvdG90eXBlLl9zdGFydFRpbWVyXHJcblx0XHRcdFx0XHQuYXBwbHkocGxheWFibGUsIGFyZ3MpXHJcblx0XHRcdFx0XHQudGhlbihhcHBseUJpbmQocGxheWFibGUuY2hlY2tJbml0LCBwbGF5YWJsZSwgYXJncykpXHJcblx0XHRcdFx0XHQudGhlbihhcHBseUJpbmQocGxheWFibGUucHJlUGxheSwgcGxheWFibGUsIGFyZ3MpKVxyXG5cdFx0XHRcdFx0LnRoZW4oYXBwbHlCaW5kKHBsYXksIHBsYXlhYmxlLCBhcmdzKSlcclxuXHRcdFx0XHRcdC50aGVuKGFwcGx5QmluZChwbGF5YWJsZS5wb3N0UGxheSwgcGxheWFibGUsIGFyZ3MpKVxyXG5cdFx0XHRcdFx0LnRoZW4oYXBwbHlCaW5kKF9QbGF5YWJsZS5wcm90b3R5cGUuX3N0b3BUaW1lciwgcGxheWFibGUsIGFyZ3MpKVxyXG5cdFx0XHRcdFx0LnRoZW4oYXBwbHlCaW5kKHBsYXlhYmxlLmhhbmRsZUhpc3RvcnksIHBsYXlhYmxlLCBhcmdzKSlcclxuXHRcdFx0XHRcdC50aGVuKGFwcGx5QmluZChfUGxheWFibGUucHJvdG90eXBlLnByb2NlZWQsIHBsYXlhYmxlLCBhcmdzKSk7XHJcblx0XHRcdH07XHJcblx0XHR9KShwbGF5YWJsZUNsYXNzLnByb3RvdHlwZS5wbGF5KTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRpYWxpemVQbGF5YWJsZUludGVyZmFjZShwbGF5YWJsZUludGVyZmFjZSkge1xyXG5cclxuXHQvLyBjcmVhdGUgYW4gaW5pdGlhbGl6ZXIgdGhhdCBkb2Vzbid0IGhhdmUgdG8gdXNlIFwibmV3XCJcclxuXHRwbGF5YWJsZUludGVyZmFjZS5jcmVhdG9yID0gbmV3IFByb3h5KHBsYXlhYmxlSW50ZXJmYWNlLCB7XHJcblx0XHRhcHBseTogZnVuY3Rpb24odGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSB7XHJcblx0XHRcdHJldHVybiBuZXcgdGFyZ2V0KC4uLmFyZ3VtZW50c0xpc3QpXHJcblx0XHR9XHJcblx0fSlcclxuXHJcblxyXG59XHJcblxyXG5leHBvcnRzLnBsYXlhYmxlQ2xhc3NlcyA9IHtcclxuXHRfUGxheWFibGUsXHJcblx0X0Nob2ljZSxcclxuXHRfUmFuZ2UsXHJcblx0X1R1cm4sXHJcblx0X1NlcXVlbmNlLFxyXG5cdF9Db25zZWN1dGl2ZSxcclxuXHRfTG9vcCxcclxuXHRfU0xvb3AsXHJcblx0X0hhbHQsXHJcblx0X1NIYWx0LFxyXG5cdF9MYW1iZGEsXHJcblx0X1JQQ2hvaWNlLFxyXG5cdF9Qb3B1bGF0aW9uRHluYW1pY3MsXHJcblx0X1NpbXVsdGFuZW91c1xyXG59O1xyXG5leHBvcnRzLnBsYXlhYmxlSW50ZXJmYWNlcyA9IHtcclxuXHRDaG9pY2UsXHJcblx0UmFuZ2UsXHJcblx0VHVybixcclxuXHRTZXF1ZW5jZSxcclxuXHRDb25zZWN1dGl2ZSxcclxuXHRMb29wLFxyXG5cdFN0b2NoYXN0aWNMb29wLFxyXG5cdEhhbHRJZixcclxuXHRTdG9jaGFzdGljSGFsdCxcclxuXHRMYW1iZGEsXHJcblx0UmFuZG9tUGxheWVyQ2hvaWNlLFxyXG5cdFBvcHVsYXRpb25EeW5hbWljcyxcclxuXHRTaW11bHRhbmVvdXNcclxufTtcclxuXHJcblxyXG5mb3IgKHZhciBwbGF5YWJsZUNsYXNzIGluIGV4cG9ydHMucGxheWFibGVDbGFzc2VzKSB7XHJcblx0aWYgKHBsYXlhYmxlQ2xhc3MgIT0gXCJfUGxheWFibGVcIikge1xyXG5cdFx0aW5pdGlhbGl6ZVBsYXlhYmxlQ2xhc3MoZXhwb3J0cy5wbGF5YWJsZUNsYXNzZXNbcGxheWFibGVDbGFzc10pO1xyXG5cdH1cclxufVxyXG5cclxuZm9yICh2YXIgcGxheWFibGVJbnRlcmZhY2UgaW4gZXhwb3J0cy5wbGF5YWJsZUludGVyZmFjZXMpIHtcclxuXHRpZiAocGxheWFibGVJbnRlcmZhY2UgIT0gXCJQbGF5YWJsZVwiKSB7XHJcblx0XHRpbml0aWFsaXplUGxheWFibGVJbnRlcmZhY2UoZXhwb3J0cy5wbGF5YWJsZUludGVyZmFjZXNbcGxheWFibGVJbnRlcmZhY2VdKVxyXG5cdFx0ZXhwb3J0cy5wbGF5YWJsZUludGVyZmFjZXNbcGxheWFibGVJbnRlcmZhY2VdID0gZXhwb3J0cy5wbGF5YWJsZUludGVyZmFjZXNbcGxheWFibGVJbnRlcmZhY2VdLmNyZWF0b3JcclxuXHR9XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XHJcbmxvZyhcImRlYnVnXCIsIFwiTG9hZGluZyBDbGFzczogTGFtYmRhXCIpXHJcblxyXG4vL0dhbWUgc3RhdGUgY29udHJvbGxlcnNcclxudmFyIHsgcmVnaXN0cnkgfSA9IHJlcXVpcmUoJy4uL3N0YXRlJyk7XHJcbnZhciBQcm9taXNlID0gcmVnaXN0cnkuUHJvbWlzZTsgLy8gRm9yIHN5bmMgbW9kZVxyXG52YXIgeyBnYW1lSGlzdG9yeSB9ID0gcmVxdWlyZShcIi4uL2hpc3RvcnlcIik7XHJcblxyXG4vLyBJbmZvcm1hdGlvbiBtZWNoYW5pY3NcclxudmFyIHsgUGVyZmVjdEluZm9ybWF0aW9uIH0gPSByZXF1aXJlKFwiLi4vaW5mb3JtYXRpb25cIik7XHJcblxyXG4vL0hlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgaXNGdW5jdGlvbiB9ID0gcmVxdWlyZSgnLi4vaGVscGVyLWZ1bmN0aW9ucycpKFwiZ2VuZXJhbFwiKTtcclxudmFyIHsgaWRIYW5kbGVyIH0gPSByZXF1aXJlKCcuLi9oZWxwZXItZnVuY3Rpb25zJykoXCJzdGF0ZVwiKTtcclxuXHJcbi8vUGFyZW50IGNsYXNzXHJcbnZhciB7IF9QbGF5YWJsZSwgUGxheWFibGUgfSA9IHJlcXVpcmUoJy4vcGxheWFibGUnKTtcclxuXHJcblxyXG5cclxuLy9CYWNrZW5kIGZ1bmN0aW9uIGNsYXNzIGZvciBHYW1lXHJcbmZ1bmN0aW9uIF9MYW1iZGEoaWQsIGFjdGlvbiwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0X1BsYXlhYmxlLmNhbGwodGhpcywgaWQpO1xyXG5cclxuXHR0aGlzLmFjdGlvbiA9IGFjdGlvbjtcclxufVxyXG5fTGFtYmRhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX1BsYXlhYmxlLnByb3RvdHlwZSk7XHJcbl9MYW1iZGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gX0xhbWJkYVxyXG5cclxuX0xhbWJkYS5yZWdpc3RyeU5hbWUgPSBcImxhbWJkYXNcIjtcclxuX0xhbWJkYS5jb3VudGVyTmFtZSA9IFwibGFtYmRhXCI7XHJcblxyXG5cclxuX0xhbWJkYS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKHtcclxuXHRpbml0aWFsaXplUGxheWVycyA9IGZhbHNlLFxyXG5cdHNob3J0Q2lyY3VpdCA9IGZhbHNlLFxyXG5cdGhpc3RvcnkgPSBnYW1lSGlzdG9yeSxcclxuXHRpbmZvcm1hdGlvbiA9IFBlcmZlY3RJbmZvcm1hdGlvblxyXG59ID0ge30pIHtcclxuXHJcblx0dmFyIGxhbWJkYSA9IHRoaXM7XHJcblxyXG5cdHZhciByZXN1bHQgPSBsYW1iZGEuYWN0aW9uKHsgaGlzdG9yeSwgaW5mb3JtYXRpb24gfSlcclxuXHJcblx0dmFyIHJlc3VsdE9iamVjdCA9IHtcclxuXHRcdHJlc3VsdCxcclxuXHRcdCdwbGF5YWJsZSc6IGxhbWJkYSxcclxuXHRcdGhpc3RvcnlFbnRyeToge1xyXG5cdFx0XHRsYW1iZGE6IGxhbWJkYS5pZCxcclxuXHRcdFx0cmVzdWx0XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRPYmplY3QpXHJcbn07XHJcblxyXG4vLyBTaW1wbGUgaGVscGVyIHRvIGp1c3QgcnVuIHN5bmNocm9ub3VzbHkgd2hhdGV2ZXIgdGhlIExhbWJkYSBpcy4gVXNlZnVsIGZvciBkZWJ1Z2dpbmcuXHJcbl9MYW1iZGEucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmFjdGlvbigpO1xyXG59XHJcblxyXG5fTGFtYmRhLnByb3RvdHlwZS5zdW1tYXJ5VGhpcyA9IGZ1bmN0aW9uKHN1bW1hcnkpIHtcclxuXHRzdW1tYXJ5LmFjdGlvbiA9IHRoaXMuYWN0aW9uLnRvU3RyaW5nKCk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBMYW1iZGEoYWN0aW9uID0gZnVuY3Rpb24oKSB7fSwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHBhcmFtZXRlcnMuaWQsIFwibGFtYmRhXCIpXHJcblxyXG5cdGlmICghaXNGdW5jdGlvbihhY3Rpb24pKSBsb2coXCJ3YXJuXCIsIGlkICsgXCI6IGFjdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbi5cIilcclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBsYW1iZGEgb2JqZWN0XHJcblx0dmFyIF9sYW1iZGEgPSBuZXcgX0xhbWJkYShpZCwgYWN0aW9uLCBwYXJhbWV0ZXJzKTtcclxuXHJcblxyXG5cdC8vUmV0dXJuIHRoaXMgcmVmZXJlbmNlIG9iamVjdCB0byB0aGUgdXNlci4gUnVuIHRoZSBmdW5jdGlvbiB0byBzZWxlY3QgYSBzb3VyY2VcclxuXHR2YXIgbGFtYmRhID0gUGxheWFibGUoX2xhbWJkYSk7XHJcblxyXG5cclxuXHRsYW1iZGEucnVuID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gX2xhbWJkYS5ydW4oKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBsYW1iZGE7XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX0xhbWJkYSwgTGFtYmRhIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XHJcbmxvZyhcImRlYnVnXCIsIFwiTG9hZGluZyBDbGFzczogTG9vcFwiKTtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZShcIi4uL3N0YXRlXCIpO1xyXG52YXIgUHJvbWlzZSA9IHJlZ2lzdHJ5LlByb21pc2U7IC8vIEZvciBzeW5jIG1vZGVcclxudmFyIHsgZ2FtZUhpc3RvcnksIEhpc3RvcnkgfSA9IHJlcXVpcmUoXCIuLi9oaXN0b3J5XCIpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlkSGFuZGxlciB9ID0gcmVxdWlyZShcIi4uL2hlbHBlci1mdW5jdGlvbnNcIikoXCJzdGF0ZVwiKTtcclxudmFyIHsgY2hhaW5lckdlbmVyYXRvciB9ID0gcmVxdWlyZShcIi4uL2hlbHBlci1mdW5jdGlvbnNcIikoXCJwbGF5YWJsZVwiKTtcclxuXHJcbi8vIEluZm9ybWF0aW9uIG1lY2hhbmljc1xyXG52YXIgeyBJbmZvcm1hdGlvbiwgUGVyZmVjdEluZm9ybWF0aW9uIH0gPSByZXF1aXJlKFwiLi4vaW5mb3JtYXRpb25cIik7XHJcbnZhciB7IGdhbWVQb3B1bGF0aW9uIH0gPSByZXF1aXJlKFwiLi4vcG9wdWxhdGlvblwiKTtcclxuXHJcbi8vUGFyZW50IGNsYXNzXHJcbnZhciB7IF9QbGF5YWJsZSwgUGxheWFibGUgfSA9IHJlcXVpcmUoXCIuL3BsYXlhYmxlXCIpO1xyXG5cclxuLy9CYWNrZW5kIGZ1bmN0aW9uIGNsYXNzIGZvciBMb29wXHJcblxyXG5mdW5jdGlvbiBfTG9vcChpZCwgcGxheWFibGUsIGNvdW50LCBwYXJhbWV0ZXJzKSB7XHJcblx0X1BsYXlhYmxlLmNhbGwodGhpcywgaWQsIHBhcmFtZXRlcnMpO1xyXG5cclxuXHR2YXIgeyBsb2dDb250aW51ZSA9IHRydWUsIHBsYXlhYmxlUGFyYW1ldGVycyA9IHt9IH0gPSBwYXJhbWV0ZXJzO1xyXG5cclxuXHR0aGlzLnBsYXlhYmxlID0gcmVnaXN0cnkucGxheWFibGVzW3BsYXlhYmxlLmlkKCldO1xyXG5cdHRoaXMubG9nQ29udGludWUgPSBsb2dDb250aW51ZTtcclxuXHR0aGlzLnBsYXlhYmxlUGFyYW1ldGVycyA9IHBsYXlhYmxlUGFyYW1ldGVycztcclxuXHJcblx0dGhpcy5jb3VudCA9IGNvdW50O1xyXG59XHJcbl9Mb29wLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX1BsYXlhYmxlLnByb3RvdHlwZSk7XHJcbl9Mb29wLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9Mb29wO1xyXG5cclxuX0xvb3AucmVnaXN0cnlOYW1lID0gXCJsb29wc1wiO1xyXG5fTG9vcC5jb3VudGVyTmFtZSA9IFwibG9vcFwiO1xyXG5cclxuX0xvb3AucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7XHJcblx0aGlzdG9yeSA9IHRoaXMuaGlzdG9yeSB8fCBnYW1lSGlzdG9yeSxcclxuXHRpbmZvcm1hdGlvbiA9IHRoaXMuaW5mb3JtYXRpb24gfHwgUGVyZmVjdEluZm9ybWF0aW9uLFxyXG5cdHBsYXlhYmxlUGFyYW1ldGVycyA9IHRoaXMucGxheWFibGVQYXJhbWV0ZXJzXHJcbn0gPSB7fSkge1xyXG5cclxuXHR2YXIgbG9vcCA9IHRoaXM7XHJcblx0bG9vcC5jb3VudGVyID0gMDtcclxuXHJcblx0Ly8gU3BsaXQgdGhlIGhpc3RvcnkgZW50cnlcclxuXHR2YXIgbG9vcEhpc3RvcnkgPSBoaXN0b3J5LmNoaWxkKCk7XHJcblxyXG5cdC8vIGluZm9ybWF0aW9uIG1lY2hhbmljcy5cclxuXHQvL2NvbXBhcnRtZW50YWxpemUgSWYgc2V0XHJcblx0aWYgKGxvb3AuY29tcGFydG1lbnRhbGl6ZSkge1xyXG5cdFx0aW5mb3JtYXRpb24gPSBuZXcgSW5mb3JtYXRpb24obG9vcC5jb21wYXJ0bWVudGFsaXplLmhpc3RvcnkgfHwgbG9vcEhpc3RvcnksXHJcblx0XHRcdGxvb3AuY29tcGFydG1lbnRhbGl6ZS5wb3B1bGF0aW9uIHx8IGluZm9ybWF0aW9uLnBvcHVsYXRpb24pO1xyXG5cdH1cclxuXHQvLyBQYXNzIGFsb25nXHJcblx0cGxheWFibGVQYXJhbWV0ZXJzLmluZm9ybWF0aW9uID0gaW5mb3JtYXRpb25cclxuXHJcblxyXG5cdHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcblxyXG5cdHZhciBhY3Rpb24gPSBmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdC8vSWYgdGhlIGdhbWUgaGFzIGJlZW4gZW5kZWQgZWFybHksIGRvbid0IGNvbnRpbnVlLlxyXG5cdFx0aWYgKGhpc3Rvcnkuc3RvcCkgcmV0dXJuIHsgcGxheWFibGU6IGxvb3AgfTtcclxuXHJcblx0XHRsb29wLmNvdW50ZXIrKztcclxuXHRcdGlmICghcmVzdWx0KSByZXN1bHQgPSB7fTtcclxuXHJcblx0XHQvL0RlYWwgd2l0aCBoaXN0b3J5XHJcblx0XHRoaXN0b3J5LmxvZy5hZGQoe1xyXG5cdFx0XHRsb29wOiBsb29wLmlkLFxyXG5cdFx0XHRsb29wVG86IGxvb3AucGxheWFibGUuaWQsXHJcblx0XHRcdGNvdW50OiBsb29wLmNvdW50ZXJcclxuXHRcdH0pO1xyXG5cclxuXHRcdHBsYXlhYmxlUGFyYW1ldGVycy5zaG9ydENpcmN1aXQgPSB0cnVlO1xyXG5cdFx0cGxheWFibGVQYXJhbWV0ZXJzLmhpc3RvcnkgPSBsb29wSGlzdG9yeTtcclxuXHJcblx0XHRyZXR1cm4gbG9vcC5wbGF5YWJsZS5wbGF5KHBsYXlhYmxlUGFyYW1ldGVycykudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0Ly9SZS1mb3JtYXQgcmVzdWx0LCByZXBsYWNlIHBsYXlhYmxlIHdpdGggTG9vcCBwbGF5YWJsZVxyXG5cdFx0XHRyZXN1bHQucGxheWFibGUgPSBsb29wO1xyXG5cclxuXHRcdFx0Ly9UT0RPOiBhZGQgaW5mb3JtYXRpb24gbWVjaGFuaXNtc1xyXG5cclxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0Ly9SZXBlYXQgdGhlIHBsYXlhYmxlIGxvb3AuY291bnQgdGltZXMsIGJ5IGNoYWluaW5nIHByb21pc2VzLlxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbG9vcC5jb3VudDsgaSsrKSB7XHJcblx0XHRwcm9taXNlID0gcHJvbWlzZS50aGVuKGFjdGlvbik7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0cmVzdWx0Lmhpc3RvcnlFbnRyeSA9IHtcclxuXHRcdFx0bG9vcDogbG9vcC5pZCxcclxuXHRcdFx0Y291bnQ6IGxvb3AuY291bnRlcixcclxuXHRcdFx0YWN0aW9uOiBsb29wSGlzdG9yeS5vcnBoYW4oKVxyXG5cdFx0fTtcclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHR9KTtcclxufTtcclxuXHJcbi8vT3ZlcndyaXRlIGhpc3RvcnkgaGFuZGxlciB0byBwcmV2ZW50IFwibG9vcCBmaW5pc2hlZFwiIGVudHJ5IGZyb20gaGl0dGluZyB0aGUgdHJlZS5cclxuX0xvb3AucHJvdG90eXBlLmhhbmRsZUhpc3RvcnkgPSBmdW5jdGlvbih7XHJcblx0XHRoaXN0b3J5ID0gdGhpcy5oaXN0b3J5IHx8IGdhbWVIaXN0b3J5LFxyXG5cdFx0aW5mb3JtYXRpb24gPSB0aGlzLmluZm9ybWF0aW9uIHx8IFBlcmZlY3RJbmZvcm1hdGlvbixcclxuXHRcdGxvZ0NvbnRpbnVlID0gdGhpcy5sb2dDb250aW51ZVxyXG5cdH0gPSB7fSxcclxuXHRyZXN1bHRcclxuKSB7XHJcblx0dmFyIGxvb3AgPSB0aGlzO1xyXG5cclxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdC8vV3JpdGUgZmluYWwgZW50cnkgaWYgbG9nQ29udGludWUgaXMgc2V0IHRvIHRydWVcclxuXHRcdGlmIChsb2dDb250aW51ZSkge1xyXG5cdFx0XHRoaXN0b3J5LmxvZy5hZGQoe1xyXG5cdFx0XHRcdGxvb3A6IGxvb3AuaWQsXHJcblx0XHRcdFx0bG9vcFRvOiBcIkxvb3AgZmluaXNoZWQuXCIsXHJcblx0XHRcdFx0Y291bnQ6IGxvb3AuY291bnRlclxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRoaXN0b3J5LmFkZE5vTG9nKHJlc3VsdC5oaXN0b3J5RW50cnkpO1xyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fSk7XHJcbn07XHJcblxyXG4vLyBBZGQgZGV0YWlsL25lc3RpbmcgdG8gc3VtbWFyeS5cclxuX0xvb3AucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSwgZW50cmllcykge1xyXG5cdHN1bW1hcnkuY291bnQgPSB0aGlzLmNvdW50O1xyXG5cclxuXHRzdW1tYXJ5LmFjdGlvbiA9IHt9O1xyXG5cdHRoaXMucGxheWFibGUuc3VtbWFyaXplKHN1bW1hcnkuYWN0aW9uLCBlbnRyaWVzLCB0cnVlKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIExvb3AocGxheWFibGUsIGNvdW50ID0gMSwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHBhcmFtZXRlcnMuaWQsIFwibG9vcFwiKTtcclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBsb29wIG9iamVjdFxyXG5cdHZhciBfbG9vcCA9IG5ldyBfTG9vcChpZCwgcGxheWFibGUsIGNvdW50LCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0Ly9SZXR1cm4gdGhpcyByZWZlcmVuY2Ugb2JqZWN0IHRvIHRoZSB1c2VyLiBSdW4gdGhlIGZ1bmN0aW9uIHRvIHNlbGVjdCBhIHNvdXJjZVxyXG5cdHZhciBsb29wID0gUGxheWFibGUoX2xvb3ApO1xyXG5cdHJldHVybiBsb29wO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX0xvb3AsIExvb3AgfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBQbGF5YWJsZVwiKTtcclxuXHJcbnZhciB7IFN5bmNocm9ub3VzUHJvbWlzZSB9ID0gcmVxdWlyZShcInN5bmNocm9ub3VzLXByb21pc2VcIik7XHJcbnZhciBwcmVzZW50ID0gcmVxdWlyZShcInByZXNlbnRcIik7XHJcbnZhciBDYWxsYWJsZUluc3RhbmNlID0gcmVxdWlyZSgnY2FsbGFibGUtaW5zdGFuY2UnKTtcclxuXHJcbi8vIERhdGEgc3RydWN0dXJlIGZvciBzdW1tYXJpZXNcclxudmFyIHsgU3VtbWFyeSB9ID0gcmVxdWlyZShcIi4uL3N1bW1hcnlcIilcclxuXHJcblxyXG4vL0dhbWUgc3RhdGUgY29udHJvbGxlcnNcclxudmFyIHsgcmVnaXN0cnksIGlkQ291bnRlcnMgfSA9IHJlcXVpcmUoXCIuLi9zdGF0ZVwiKTtcclxudmFyIFByb21pc2UgPSByZWdpc3RyeS5Qcm9taXNlOyAvLyBGb3Igc3luYyBtb2RlXHJcbnZhciB7IGdhbWVIaXN0b3J5LCBIaXN0b3J5IH0gPSByZXF1aXJlKFwiLi4vaGlzdG9yeVwiKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpc0Z1bmN0aW9uIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyLWZ1bmN0aW9uc1wiKShcImdlbmVyYWxcIik7XHJcbnZhciB7IG91dGNvbWVUcmVlQWRkQWxsLCBvdXRjb21lVHJlZUdldFZhbHVlIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyLWZ1bmN0aW9uc1wiKShcInBsYXlhYmxlXCIpO1xyXG52YXIgeyByZWluaXRpYWxpemVQbGF5ZXJzIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyLWZ1bmN0aW9uc1wiKShcInBsYXllclwiKTtcclxuXHJcbi8vVG8gcmV0dXJuIHRvIHVzZXJcclxudmFyIHsgUG9wdWxhdGlvbiwgUGxheWVyTGlzdCB9ID0gcmVxdWlyZShcIi4uL3BvcHVsYXRpb25cIik7XHJcblxyXG4vLyBGb3IgYmV0dGVyIG9iamVjdCBwcmV2aWV3IHN1bW1hcmllcy5cclxudmFyIGJlYXV0aWZ5ID0gcmVxdWlyZShcImpzb24tYmVhdXRpZnlcIilcclxuXHJcblxyXG4vLyBicmFuY2ggY2xhc3MsIGZvciB0aGUgdXNlciB0byBpbnRlcmFjdCB3aXRoIHdoZW4gdHJlZS1icmFuY2hpbmcsIHRvIHJlcGxhY2UgcHJvbWlzZXNcclxuLy8gRXh0ZW5kIHRoaXMgYnJhbmNoIGFuZCBhZGQgYSBwYXlvZmYgZnVuY3Rpb24gZm9yIGVhY2ggY2FzZSAoVHVybiwgQ2hvaWNlLCBldGMpXHJcbi8vIHBhdGggaXMgYW4gb3JkZXJlZCBhcnJheSBvZiBicmFuY2hlczsgcGxheWFibGUgaXMgYSB1c2VyIGludGVyZmFjZVxyXG52YXIgQnJhbmNoID0gY2xhc3MgQnJhbmNoIGV4dGVuZHMgQ2FsbGFibGVJbnN0YW5jZSB7XHJcblx0Y29uc3RydWN0b3IocGF0aCwgcGxheWFibGUpIHtcclxuXHRcdHN1cGVyKFwicGF5b2ZmXCIpO1xyXG5cdFx0dGhpcy5wYXRoID0gcGF0aDtcclxuXHRcdHRoaXMucGxheWFibGUgPSBwbGF5YWJsZTtcclxuXHRcdHJldHVyblxyXG5cdH1cclxuXHJcblx0dG9TdHJpbmcoKSB7XHJcblx0XHRyZXR1cm4gXCJCcmFuY2hcIlxyXG5cdH1cclxuXHJcblx0cGF5b2ZmKHBheW9mZikge1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbi8vIEJhc2UgY2xhc3MgZm9yIHN5c3RlbS1zaWRlIF9QbGF5YWJsZXNcclxuY2xhc3MgX1BsYXlhYmxlIHtcclxuXHRjb25zdHJ1Y3RvcihpZCwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0XHR0aGlzLmlkID0gaWQ7XHJcblx0XHR0aGlzLm5leHQgPSBbXTsgLy8gRGVmYXVsdCBuZXh0LW1hcCBpcyBhbiBhcnJheSwgYnV0IGNlcnRhaW4gcGxheWFibGVzIG1pZ2h0IHVzZSBzb21ldGhpbmcgZWxzZVxyXG5cdFx0cmVnaXN0cnkucGxheWFibGVzW2lkXSA9IHRoaXM7XHJcblx0XHRpZiAodGhpcy5jb25zdHJ1Y3Rvci5yZWdpc3RyeU5hbWUgIT0gXCJwbGF5YWJsZXNcIikgcmVnaXN0cnlbdGhpcy5jb25zdHJ1Y3Rvci5yZWdpc3RyeU5hbWVdW2lkXSA9IHRoaXM7XHJcblx0XHRpZENvdW50ZXJzLnBsYXlhYmxlKys7XHJcblxyXG5cdFx0cGFyYW1ldGVycy5jb21wYXJ0bWVudGFsaXplID8gdGhpcy5jb21wYXJ0bWVudGFsaXplID0gcGFyYW1ldGVycy5jb21wYXJ0bWVudGFsaXplIDogbnVsbDtcclxuXHRcdHBhcmFtZXRlcnMuaGlzdG9yeSA/ICh0aGlzLmhpc3RvcnkgPSBwYXJhbWV0ZXJzLmhpc3RvcnkpIDogbnVsbDtcclxuXHRcdHBhcmFtZXRlcnMuaW5mb3JtYXRpb24gPyAodGhpcy5pbmZvcm1hdGlvbiA9IHBhcmFtZXRlcnMuaW5mb3JtYXRpb24pIDogbnVsbDtcclxuXHRcdHBhcmFtZXRlcnMuaW5pdGlhbGl6ZVBsYXllcnMgPyAodGhpcy5pbml0aWFsaXplUGxheWVycyA9IHBhcmFtZXRlcnMuaW5pdGlhbGl6ZVBsYXllcnMpIDogbnVsbDtcclxuXHR9XHJcblxyXG5cdC8vQ2FsbGVkIGJlZm9yZSAucGxheSgpIHRvIHN0YXJ0IHRpbWluZy5cclxuXHRfc3RhcnRUaW1lcigpIHtcclxuXHRcdHRoaXMuX3RpbWVyID0gcHJlc2VudCgpO1xyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG5cdH07XHJcblxyXG5cclxuXHQvL0FkZCByZWZlcmVuY2UgdG8gbmV4dCBwbGF5YWJsZSBicmFuY2gsIHRvIGNoYWluIHBsYXlhYmxlcyB0b2dldGhlci5cclxuXHRhZGROZXh0KG5leHRQbGF5YWJsZSwgcGF0aCA9IFwiYWxsXCIpIHtcclxuXHRcdGlmIChwYXRoID09IFwiYWxsXCIpIG91dGNvbWVUcmVlQWRkQWxsKHRoaXMubmV4dCwgbmV4dFBsYXlhYmxlKTtcclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRvdXRjb21lVHJlZUdldFZhbHVlKHRoaXMubmV4dCwgcGF0aCkucHVzaChuZXh0UGxheWFibGUpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cclxuXHQvL0NhbGxlZCBiZWZvcmUgcHJlUGxheSwgaW5pdGlhbGl6ZSBwbGF5ZXJzIGlmIHRydWUuXHJcblx0Y2hlY2tJbml0KHsgaW5pdGlhbGl6ZVBsYXllcnMgPSB0aGlzLmluaXRpYWxpemVQbGF5ZXJzIH0gPSB7fSwgcmVzdWx0KSB7XHJcblx0XHQvLyBpZiB3ZSBnZXQgc29tZXRoaW5nXHJcblx0XHRpZiAoaW5pdGlhbGl6ZVBsYXllcnMpIHtcclxuXHRcdFx0Ly8gaWYgaXQncyBqdXN0IHRydWUsIHRoZW4gcmVpbml0aWFsaXplIGV2ZXJ5Ym9keVxyXG5cdFx0XHRpZiAoaW5pdGlhbGl6ZVBsYXllcnMgPT09IHRydWUpIHJldHVybiByZWluaXRpYWxpemVQbGF5ZXJzKFwiYWxsXCIsIHJlc3VsdClcclxuXHJcblx0XHRcdC8vIGlmIGl0J3MgYSBwbGF5ZXJMaXN0LCB1c2UgdGhhdFxyXG5cdFx0XHRlbHNlIGlmIChpbml0aWFsaXplUGxheWVycyBpbnN0YW5jZW9mIFBsYXllckxpc3QpIHJldHVybiByZWluaXRpYWxpemVQbGF5ZXJzKGluaXRpYWxpemVQbGF5ZXJzKVxyXG5cclxuXHRcdFx0Ly8gaWYgd2UgZ2V0IGEgZnVuY3Rpb24sIHRoZW4gcnVuIHRoZSBmdW5jdGlvbiBhbmQgY2hlY2sgdGhhdCBpdCdzIHJldHVybmluZyBhIHBsYXllckxpc3RcclxuXHRcdFx0ZWxzZSBpZiAoaXNGdW5jdGlvbihpbml0aWFsaXplUGxheWVycykpIHtcclxuXHRcdFx0XHR2YXIgbGlzdCA9IGluaXRpYWxpemVQbGF5ZXJzKClcclxuXHRcdFx0XHRpZiAobGlzdCBpbnN0YW5jZW9mIFBsYXllckxpc3QpIHJldHVybiByZWluaXRpYWxpemVQbGF5ZXJzKGxpc3QsIHJlc3VsdCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIG90aGVyd2lzZSwgY29udmVydCBpdCB0byBhIHBsYXllckxpc3QgYW5kIGxldCBQbGF5ZXJMaXN0IGRlYWwgd2l0aCBpdC5cclxuXHRcdFx0ZWxzZSByZXR1cm4gcmVpbml0aWFsaXplUGxheWVycyhuZXcgUGxheWVyTGlzdChpbml0aWFsaXplUGxheWVycyksIHJlc3VsdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaWYgd2UgZGlkbid0IGdldCBhbnl0aGluZyBvciBnb3QgZmFsc2UsIHdlJ3JlIGRvbmUgaGVyZS5cclxuXHRcdGVsc2UgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdH07XHJcblxyXG5cclxuXHQvL0NhbGxlZCBiZWZvcmUgLnBsYXkoKSBidXQgYWZ0ZXIgX3N0YXJ0VGltZXIsIG92ZXJ3cml0ZWFibGVcclxuXHRwcmVQbGF5KHt9ID0ge30sIHJlc3VsdCkge1xyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdH07XHJcblxyXG5cdC8vIFRoZSBtYWluIGF0dHJhY3Rpb24uIEVhY2ggY2xhc3Mgc2hvdWxkIG92ZXJ3cml0ZSB0aGlzLihBbmQgaXQgd2lsbCBnZXQgd3JhcHBlZCBhbnl3YXkuIFRoaXMgbW9zdGx5IGV4aXN0cyBmb3IgdGVzdGluZyBwdXJwb3NlcylcclxuXHRwbGF5KHt9ID0ge30sIHJlc3VsdCkge1xyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpXHJcblx0fVxyXG5cclxuXHQvL0NhbGxlZCBhZnRlciAucGxheSgpLCBvdmVyd3JpdGFibGUuXHJcblx0cG9zdFBsYXkoe30gPSB7fSwgcmVzdWx0KSB7XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcblx0fTtcclxuXHJcblx0Ly9DYWxsZWQgYWZ0ZXIgLnBvc3RQbGF5KCkgdG8gc3RvcCB0aW1lciBhbmQgbG9nLlxyXG5cdF9zdG9wVGltZXIoe30gPSB7fSwgcmVzdWx0KSB7XHJcblx0XHRpZiAocmVzdWx0Lmhpc3RvcnlFbnRyeSlcclxuXHRcdFx0cmVzdWx0Lmhpc3RvcnlFbnRyeS5kdXJhdGlvbiA9IHByZXNlbnQoKSAtIHRoaXMuX3RpbWVyO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX3RpbWVyO1xyXG5cclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHR9O1xyXG5cclxuXHQvL0NhbGxlZCBhZnRlciB0aW1lciBzdG9wcywgdG8gd3JpdGUgbG9nLiBPdmVyd2l0ZWFibGUgaWYgcGxheWFibGUgaGFzIHNwZWNpZmljIGxvZ2dpbmcgYmVoYXZpb3IuXHJcblx0aGFuZGxlSGlzdG9yeSh7IGhpc3RvcnkgPSBnYW1lSGlzdG9yeSB9ID0ge30sXHJcblx0XHRyZXN1bHRcclxuXHQpIHtcclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHRpZiAocmVzdWx0Lmhpc3RvcnlFbnRyeSkgaGlzdG9yeS5hZGQocmVzdWx0Lmhpc3RvcnlFbnRyeSk7XHJcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdC8vRGV0ZXJtaW5lIHdoZXRoZXIgdG8gcGxheSBuZXh0LCBhbmQgaWYgc28sIGRvLlxyXG5cdHByb2NlZWQoeyBzaG9ydENpcmN1aXQgfSA9IHt9LCByZXN1bHQpIHtcclxuXHRcdHZhciBwbGF5YWJsZSA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdC8vUmVwbGFjZSByZXBvcnRlZCBwbGF5YWJsZSB3aXRoIGxhdGVzdCBydW5uaW5nIHBsYXlhYmxlICh0aGlzIGlzIG5lY2Vzc2FyeSBmb3Igc2hvcnQtY2lyY3VpdCBsb2dpYylcclxuXHRcdFx0cmVzdWx0LnBsYXlhYmxlID0gcGxheWFibGU7XHJcblxyXG5cdFx0XHQvL1Nob3J0LWNpcmN1aXQgbG9naWMgYWxsb3dzIGhpZ2hlci1vcmRlciBwbGF5YWJsZSB0byBmaWd1cmUgb3V0IHdoYXQgdG8gZG8gbmV4dC5cclxuXHRcdFx0aWYgKHNob3J0Q2lyY3VpdCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHBsYXlhYmxlLnBsYXlOZXh0KHJlc3VsdCk7XHJcblx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHQvL1BsYXkgbmV4dC5cclxuXHRwbGF5TmV4dChyZXN1bHQsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdFx0dmFyIHBsYXlhYmxlID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0Ly9GaW5kIG91dCB3aGVyZSB0byBnbyBuZXh0XHJcblx0XHRcdHZhciBuZXh0ID0gcGxheWFibGUuZmluZE5leHQoeyByZXN1bHQgfSk7XHJcblxyXG5cdFx0XHQvL0lmIHRoZXJlJ3Mgc29tZXdoZXJlIHRvIGdvLCB0aGVuIGdvLlxyXG5cdFx0XHRpZiAobmV4dFswXSBpbnN0YW5jZW9mIF9QbGF5YWJsZSlcclxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoXHJcblx0XHRcdFx0XHRuZXh0Lm1hcChmdW5jdGlvbihwbGF5YWJsZSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gcGxheWFibGUucGxheShwYXJhbWV0ZXJzKTtcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdC8vT3RoZXJ3aXNlLCB3ZSdyZSBkb25lIGhlcmVcclxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0Ly8gUmV0dXJuIHRoZSBuZXh0IHBsYXlhYmxlIGluIHRoZSBzZXF1ZW5jZS4gT3ZlcndyaXRlYWJsZSBmb3IgcGxheWFibGVzIHdpdGggbW9yZSBjb21wbGljYXRlZCBicmFuY2hpbmcuXHJcblx0ZmluZE5leHQoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5uZXh0O1xyXG5cdH07XHJcblxyXG5cclxuXHQvLyBTdW1tYXJpemUgdGhlIGdhbWUgc3RydWN0dXJlLiBDYWxscyBzdW1tYXJ5VGhpcyBhbmQgc3VtbWFyeU5leHQsIHdoaWNoIGFyZSBvdmVyd3JpdGFibGUuXHJcblx0c3VtbWFyaXplKFxyXG5cdFx0c3VtbWFyeSA9IG5ldyBTdW1tYXJ5KCksXHJcblx0XHRzaG9ydENpcmN1aXQgPSBmYWxzZSxcclxuXHRcdG1heEVudHJpZXMgPSAxMFxyXG5cdCkge1xyXG5cdFx0Ly8gU3RhcnQgc3VtbWFyeSBmb3IgdGhpcyBwbGF5YWJsZVxyXG5cdFx0c3VtbWFyeSh0aGlzLmNvbnN0cnVjdG9yLmNvdW50ZXJOYW1lLCB0aGlzLmlkKTtcclxuXHJcblx0XHQvLyBUcmFjayBob3cgbWFueSB0aW1lcyB3ZSd2ZSBiZWVuIGhlcmUgYmVmb3JlLCB0byBhdm9pZCBjaXJjdWxhciByZWN1cnNpb25cclxuXHRcdHN1bW1hcnkuZW50cmllc1t0aGlzLmlkXSA/ICsrc3VtbWFyeS5lbnRyaWVzW3RoaXMuaWRdIDogKHN1bW1hcnkuZW50cmllc1t0aGlzLmlkXSA9IDEpO1xyXG5cdFx0aWYgKHN1bW1hcnkuZW50cmllc1t0aGlzLmlkXSA+IG1heEVudHJpZXMpIHNob3J0Q2lyY3VpdCA9IHRydWU7XHJcblxyXG5cdFx0Ly8gQWRkIHN1bW1hcnlcclxuXHRcdHN1bW1hcnkgPSB0aGlzLnN1bW1hcnlUaGlzKHN1bW1hcnkpO1xyXG5cclxuXHRcdC8vIFByb2NlZWQgdG8gbmV4dCBzdGVwc1xyXG5cdFx0aWYgKCFzaG9ydENpcmN1aXQgfHwgc2hvcnRDaXJjdWl0ICE9PSB0aGlzKVxyXG5cdFx0XHR0aGlzLnN1bW1hcnlOZXh0KHN1bW1hcnkpO1xyXG5cclxuXHRcdHJldHVybiBzdW1tYXJ5O1xyXG5cdH07XHJcblxyXG5cdC8vIEFkZHMgdGhlIHN1bW1hcnkgaW5mb3JtYXRpb24gb24gdGhpcyBwbGF5YWJsZS4gT3ZlcndyaXRlIHRoaXMgaW4gb3JkZXIgdG8gYWRkIHNwZWNpZmljIGluZm9ybWF0aW9uLlxyXG5cdHN1bW1hcnlUaGlzKHN1bW1hcnkgPSB7fSkge1xyXG5cdFx0cmV0dXJuIHN1bW1hcnk7XHJcblx0fTtcclxuXHJcblx0Ly8gQWRkcyBzdW1tYXJ5IGluZm9ybWF0aW9uIGRvd24gdGhlIG5leHQtcGF0aC4gT3ZlcndpdGUgdGhpcyBmb3IgcGxheWFibGVzIHdpdGggbW9yZSBjb21wbGV4IGJyYW5jaGluZy5cclxuXHRzdW1tYXJ5TmV4dChzdW1tYXJ5ID0gbmV3IFN1bW1hcnkoKSkge1xyXG5cdFx0Ly8gSWYgdGhlcmUncyBhIG5leHQtZW50cnlcclxuXHRcdGlmICh0aGlzLm5leHQubGVuZ3RoID4gMCkge1xyXG5cdFx0XHQvLyBMb29wIG92ZXIgZWFjaCBuZXh0LWl0ZW0sIGFuZCBzdW1tYXJpemUgaXQuXHJcblx0XHRcdHN1bW1hcnkuYXJyYXkoXCJuZXh0XCIsIHRoaXMubmV4dCwgZnVuY3Rpb24ocGxheWFibGUsIHN1bW1hcnkpIHtcclxuXHRcdFx0XHRyZXR1cm4gcGxheWFibGUuc3VtbWFyaXplKHN1bW1hcnkpXHJcblx0XHRcdH0pXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHN1bW1hcnk7XHJcblx0fTtcclxuXHJcbn1cclxuX1BsYXlhYmxlLnJlZ2lzdHJ5TmFtZSA9IFwicGxheWFibGVzXCI7XHJcbl9QbGF5YWJsZS5jb3VudGVyTmFtZSA9IFwicGxheWFibGVcIjtcclxuXHJcblxyXG4vLyBCYXNlIGNsYXNzIGZvciBwbGF5YWJsZSB1c2VyLWludGVyZmFjZXNcclxubGV0IFBsYXlhYmxlID0gKGZ1bmN0aW9uKCkge1xyXG5cdC8vICBwcml2YXRlIGRhdGEuIEhpZGUgdGhlIGludGVybmFsIF9wbGF5YWJsZSBmcm9tIHRoZSB1c2VyIGFjY2Vzcy5cclxuXHRsZXQgX3BsYXlhYmxlcyA9IG5ldyBXZWFrTWFwKCk7XHJcblxyXG5cdGNsYXNzIFBsYXlhYmxlIGV4dGVuZHMgQ2FsbGFibGVJbnN0YW5jZSB7XHJcblx0XHQvL292ZXJyaWRlIHRoaXMgb24gZWFjaCBjbGFzcy4gcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBjbGFzcywgdG8gYXZvaWQgdGhlICduZXcnIGtleXdvcmRcclxuXHRcdHN0YXRpYyBjcmVhdG9yKC4uLmFyZ3MpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBQbGF5YWJsZSguLi5hcmdzKVxyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRpYyB0b1N0cmluZygpIHtcclxuXHRcdFx0cmV0dXJuIFwiUGxheWFibGVcIlxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0cnVjdG9yKF9wbGF5YWJsZSkge1xyXG5cdFx0XHRzdXBlcihcImNoYWluXCIpXHJcblx0XHRcdF9wbGF5YWJsZXMuc2V0KHRoaXMsIF9wbGF5YWJsZSk7IC8vIHRoaXMgaXMgcHJpdmF0ZVxyXG5cdFx0XHRfcGxheWFibGUuaW50ZXJmYWNlID0gdGhpc1xyXG5cdFx0fVxyXG5cdFx0Y2hhaW4oc291cmNlKSB7XHJcblx0XHRcdHZhciBwcmV2aW91c1BsYXlhYmxlLCBwYXRoXHJcblxyXG5cdFx0XHQvLyBBY3QgYWNjb3JkaW5nIHRvIHNvdXJjZSB0eXBlXHJcblx0XHRcdGlmIChzb3VyY2UgaW5zdGFuY2VvZiBQbGF5YWJsZSkge1xyXG5cdFx0XHRcdHByZXZpb3VzUGxheWFibGUgPSByZWdpc3RyeS5wbGF5YWJsZXNbc291cmNlLmlkKCldXHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEJyYW5jaCkge1xyXG5cdFx0XHRcdHByZXZpb3VzUGxheWFibGUgPSByZWdpc3RyeS5wbGF5YWJsZXNbc291cmNlLnBsYXlhYmxlLmlkKCldXHJcblxyXG5cdFx0XHR9IGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG9ubHkgY2hhaW4gcGxheWFibGVzLlwiKVxyXG5cclxuXHRcdFx0cGF0aCA9IHNvdXJjZS5wYXRoXHJcblx0XHRcdHZhciBfcGxheWFibGUgPSBfcGxheWFibGVzLmdldCh0aGlzKVxyXG5cclxuXHRcdFx0bG9nKFwiZGVidWdcIiwgXCJBZGRpbmcgbmV4dCBwbGF5YWJsZSB0byBcIiArIHByZXZpb3VzUGxheWFibGUuaWQgKyBcIiwgbm9kZSBcIiArIF9wbGF5YWJsZS5pZCk7XHJcblxyXG5cdFx0XHRwcmV2aW91c1BsYXlhYmxlLmFkZE5leHQoX3BsYXlhYmxlLCBwYXRoKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlkKCkge1xyXG5cdFx0XHRyZXR1cm4gX3BsYXlhYmxlcy5nZXQodGhpcykuaWRcclxuXHRcdH1cclxuXHJcblx0XHRwbGF5KHtcclxuXHRcdFx0aW5pdGlhbGl6ZVBsYXllcnMgPSBmYWxzZSxcclxuXHRcdFx0dXNlUGF5b2ZmcyA9IHRydWUsXHJcblx0XHRcdHNob3J0Q2lyY3VpdCA9IGZhbHNlLFxyXG5cdFx0XHR3cml0ZUhpc3RvcnkgPSB0cnVlLFxyXG5cdFx0XHRjbGVhckhpc3RvcnkgPSByZWdpc3RyeS5TZXR0aW5nc1tcImNsZWFyLWhpc3Rvcnktb24tcGxheVwiXSxcclxuXHRcdFx0cmVsZWFzZVBsYXllcnMgPSB0cnVlXHJcblx0XHR9ID0ge30pIHtcclxuXHJcblx0XHRcdHZhciBfcGxheWFibGUgPSBfcGxheWFibGVzLmdldCh0aGlzKVxyXG5cclxuXHRcdFx0aWYgKGNsZWFySGlzdG9yeSkgZ2FtZUhpc3RvcnkuY2xlYXJIaXN0b3J5KCk7XHJcblxyXG5cdFx0XHR2YXIgaGlzdG9yeSA9IHdyaXRlSGlzdG9yeSA/XHJcblx0XHRcdFx0X3BsYXlhYmxlLmhpc3RvcnkgfHwgZ2FtZUhpc3RvcnkgOlxyXG5cdFx0XHRcdG5ldyBIaXN0b3J5KCk7XHJcblxyXG5cdFx0XHR2YXIgcmV0dXJuVmFsdWUgPSBQcm9taXNlLnJlc29sdmUoKVxyXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIF9wbGF5YWJsZS5wbGF5KHsgaW5pdGlhbGl6ZVBsYXllcnMsIHVzZVBheW9mZnMsIHNob3J0Q2lyY3VpdCwgaGlzdG9yeSwgcmVsZWFzZVBsYXllcnMgfSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQuY2F0Y2goZnVuY3Rpb24ocmVhc29uKSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhyZWFzb24pO1xyXG5cclxuXHRcdFx0XHRcdC8vSWYgdGhlIGdhbWUgd2FzIHN0b3BwZWQgYnkgYSBIYWx0IHBsYXlhYmxlIG9yIGV2ZXJ5Ym9keSdzIGRlYWQsIHdlJ2xsIGVuZCB1cCBoZXJlLCBhbmQgdGhpbmdzIGFyZSBmaW5lLiBKdXN0IGxvZyBpdC5cclxuXHRcdFx0XHRcdGlmIChyZWFzb24ucmVzdWx0ID09IFwiSGFsdFwiKSB7XHJcblx0XHRcdFx0XHRcdGdhbWVIaXN0b3J5LmFkZChyZWFzb24uaGlzdG9yeUVudHJ5KTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFzb24ucmVzdWx0KTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAocmVhc29uLnJlc3VsdCA9PSBcIlBvcHVsYXRpb24gQ29sbGFwc2VcIilcclxuXHRcdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFzb24ucmVzdWx0KTtcclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRoaXN0b3J5LmxvZy5hZGQoeyBlcnJvcjogcmVhc29uIH0pO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHRcdFx0Ly9SZXBsYWNlIHJlc3VsdCwgc28gdGhhdCB1c2VyIGNhbid0IGdldCBhY2Nlc3MgdG8gX3BsYXlhYmxlc1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xyXG5cdFx0XHRcdFx0XHRQb3B1bGF0aW9uOiBQb3B1bGF0aW9uKCksXHJcblx0XHRcdFx0XHRcdGdhbWVIaXN0b3J5XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdC8vIFN5bmNocm9ub3VzUHJvbWlzZSByZXZlYWxzIHRvbyBtdWNoIGRhdGEuIEdvdHRhIGp1c3QgcmV0dXJuIHRoZSByZXN1bHRzLlxyXG5cdFx0XHRpZiAocmVnaXN0cnkuUHJvbWlzZS5tb2RlID09IFwic3luY1wiKSByZXR1cm4gcmV0dXJuVmFsdWUuX2RhdGFcclxuXHRcdFx0cmV0dXJuIHJldHVyblZhbHVlXHJcblx0XHR9XHJcblxyXG5cdFx0c3VtbWFyaXplKCkge1xyXG5cdFx0XHRyZXR1cm4gX3BsYXlhYmxlcy5nZXQodGhpcykuc3VtbWFyaXplKCkucHJpbnQoKVxyXG5cdFx0fVxyXG5cclxuXHRcdHRvU3RyaW5nKCkge1xyXG5cclxuXHRcdFx0Ly8gdGhpcyBmdW5jdGlvbiB3aWxsIGVkaXQgdGhlIHN1bW1hcmllcy5cclxuXHRcdFx0dmFyIHJlcGxhY2VyID0gZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xyXG5cdFx0XHRcdC8vIGlmIHNldCwgc2hvcnRlbiBzdW1tYXJpZXNcclxuXHRcdFx0XHRpZiAocmVnaXN0cnkuU2V0dGluZ3NbXCJjb25kZW5zZS1uZXh0LXN1bW1hcnktcHJldmlld1wiXSAmJiBrZXkgPT0gXCJuZXh0XCIpIHJldHVybiBcIi4uLlwiXHJcblx0XHRcdFx0cmV0dXJuIHZhbHVlXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBiZWF1dGlmeSh0aGlzLnN1bW1hcml6ZSgpLCByZXBsYWNlciwgMiwgNjApXHJcblx0XHR9XHJcblx0fVxyXG5cdC8vIGRlZmF1bHQgYnJhbmNoaW5nIChwcm9iYWJseSBub3Qgc3RyaWN0bHkgbmVjZXNzYXJ5LilcclxuXHRQbGF5YWJsZS5wcm90b3R5cGUucGF0aCA9IFwiYWxsXCI7XHJcblxyXG5cdHJldHVybiBQbGF5YWJsZTtcclxufSkoKTtcclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IEJyYW5jaCwgX1BsYXlhYmxlLCBQbGF5YWJsZSB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxuXHJcbi8vRXh0ZXJuYWwgZGVwZW5kZW5jeVxyXG52YXIgcG9pc3NvbiA9IHJlcXVpcmUoJ3JhbmRnZW4nKS5ycG9pc3NvbjtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZSgnLi4vc3RhdGUnKTtcclxudmFyIFByb21pc2UgPSByZWdpc3RyeS5Qcm9taXNlOyAvLyBGb3Igc3luYyBtb2RlXHJcbnZhciB7IGdhbWVIaXN0b3J5IH0gPSByZXF1aXJlKFwiLi4vaGlzdG9yeVwiKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpc0Z1bmN0aW9uIH0gPSByZXF1aXJlKCcuLi9oZWxwZXItZnVuY3Rpb25zJykoXCJnZW5lcmFsXCIpO1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoJy4uL2hlbHBlci1mdW5jdGlvbnMnKShcInN0YXRlXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9ID0gcmVxdWlyZSgnLi9wbGF5YWJsZScpO1xyXG5cclxuLy9QbGF5ZXIgY29udHJvbGxlcnNcclxudmFyIHsgX1BsYXllciwgUGxheWVyIH0gPSByZXF1aXJlKCcuLi9wbGF5ZXInKTtcclxudmFyIHsgUGxheWVyTGlzdCwgVXNlclBsYXllckxpc3QsIGdhbWVQb3B1bGF0aW9uLCBQb3B1bGF0aW9uIH0gPSByZXF1aXJlKCcuLi9wb3B1bGF0aW9uJyk7XHJcblxyXG4vL1VwZGF0ZSB0aGlzIGVhY2ggdGltZSAucGxheSBpcyBjYWxsZWQsIGJ1dCBsZWF2ZSBpdCBhdmFpbGFibGUgdG8gdGhlIHdob2xlIHNjb3BlIHNvIHRoYXRcclxuLy9ncm93dGggYW5kIGRlY2F5IGNhbiBhY2Nlc3MgaXRcclxudmFyIHBvcHVsYXRpb247XHJcblxyXG4vL0RlZmF1bHQgZ3Jvd3RoIGZ1bmN0aW9uXHJcbnZhciBncm93dGhEZWZhdWx0ID0gZnVuY3Rpb24gZ3Jvd3RoKHBsYXllciwgcG9wdWxhdGlvbiwgYmlydGhSYXRlLCBzZWxlY3RpdmVNdWx0aXBsaWVyKSB7XHJcblx0dmFyIHNjb3JlID0gcGxheWVyLnNjb3JlO1xyXG5cdHZhciBtZWFuID0gcG9wdWxhdGlvbi5zY29yZXNNZWFuKCk7XHJcblx0dmFyIHN0ZCA9IHBvcHVsYXRpb24uc2NvcmVzU3RkKCk7XHJcblxyXG5cdHZhciBaID0gIShpc05hTihzdGQpIHx8IHN0ZCA9PSAwKSA/IChzY29yZSAtIG1lYW4pIC8gc3RkIDogMFxyXG5cclxuXHRjb25zb2xlLmxvZyhzY29yZSwgbWVhbiwgc3RkLCBaKTtcclxuXHJcblx0dmFyIHJhdGUgPSBiaXJ0aFJhdGUgKyBzZWxlY3RpdmVNdWx0aXBsaWVyICogWjtcclxuXHJcblx0dmFyIGdlbmVyYXRlZCA9IHBvaXNzb24ocmF0ZSk7XHJcblx0bG9nKFwic2lsbHlcIiwgXCJncm93dGhEZWZhdWx0OiBnZW5lcmF0ZWQgcmFuZG9tIG51bWJlciBcIiArIGdlbmVyYXRlZC50b1N0cmluZygpICsgXCIgdXNpbmcgcmF0ZSBcIiArIHJhdGUudG9TdHJpbmcoKSk7XHJcblxyXG5cdHJldHVybiBnZW5lcmF0ZWQ7XHJcbn1cclxuXHJcbi8vRGVmYXVsdCBkZWNheSBmdW5jdGlvblxyXG52YXIgZGVjYXlEZWZhdWx0ID0gZnVuY3Rpb24gZGVjYXkocGxheWVyLCBwb3B1bGF0aW9uLCBkZWF0aFJhdGUsIHNlbGVjdGl2ZU11bHRpcGxpZXIpIHtcclxuXHR2YXIgc2NvcmUgPSBwbGF5ZXIuc2NvcmU7XHJcblx0dmFyIG1lYW4gPSBwb3B1bGF0aW9uLnNjb3Jlc01lYW4oKTtcclxuXHR2YXIgc3RkID0gcG9wdWxhdGlvbi5zY29yZXNTdGQoKTtcclxuXHJcblx0Y29uc29sZS5sb2coc2NvcmUsIG1lYW4sIHN0ZCk7XHJcblxyXG5cdHZhciBaID0gIShpc05hTihzdGQpIHx8IHN0ZCA9PSAwKSA/IChzY29yZSAtIG1lYW4pIC8gc3RkIDogMDtcclxuXHJcblx0Y29uc29sZS5sb2coWilcclxuXHR2YXIgcmF0ZSA9IGRlYXRoUmF0ZSAtIHNlbGVjdGl2ZU11bHRpcGxpZXIgKiBaO1xyXG5cclxuXHR2YXIgZ2VuZXJhdGVkID0gcG9pc3NvbihyYXRlKTtcclxuXHRsb2coXCJzaWxseVwiLCBcImRlY2F5RGVmYXVsdDogZ2VuZXJhdGVkIHJhbmRvbSBudW1iZXIgXCIgKyBnZW5lcmF0ZWQudG9TdHJpbmcoKSArIFwiIHVzaW5nIHJhdGUgXCIgKyByYXRlLnRvU3RyaW5nKCkpO1xyXG5cdHJldHVybiBnZW5lcmF0ZWQ7XHJcbn1cclxuXHJcblxyXG5cclxuLy9CYWNrZW5kIGZ1bmN0aW9uIGNsYXNzIGZvciBQb3B1bGF0aW9uRHluYW1pY3NcclxuZnVuY3Rpb24gX1BvcHVsYXRpb25EeW5hbWljcyhpZCwgYmlydGhSYXRlLCBkZWF0aFJhdGUsIHtcclxuXHRncm93dGhGdW5jdGlvbiA9IGdyb3d0aERlZmF1bHQsXHJcblx0ZGVjYXlGdW5jdGlvbiA9XHJcblx0ZGVjYXlEZWZhdWx0LFxyXG5cdHNlbGVjdGl2ZU11bHRpcGxpZXIgPSAuNSxcclxuXHRwbGF5ZXJQYXJhbWV0ZXJzID0ge31cclxufSA9IHt9KSB7XHJcblx0X1BsYXlhYmxlLmNhbGwodGhpcywgaWQpO1xyXG5cclxuXHR2YXIgcGQgPSB0aGlzO1xyXG5cclxuXHR0aGlzLmJpcnRoUmF0ZSA9IGJpcnRoUmF0ZTtcclxuXHR0aGlzLmRlYXRoUmF0ZSA9IGRlYXRoUmF0ZTtcclxuXHR0aGlzLnNlbGVjdGl2ZU11bHRpcGxpZXIgPSBzZWxlY3RpdmVNdWx0aXBsaWVyO1xyXG5cclxuXHQvL1dyYXAgdGhlIGdyb3d0aCBhbmQgZGVjYXkgZnVuY3Rpb25zLCBzbyB0aGF0IHRoZSB1c2VyIGRvZXNuJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCBjYWxsaW5nIHRoaXMuYmlydGhSYXRlIG9yIHRoaXMuZGVhdGhSYXRlXHJcblx0dGhpcy5ncm93dGggPSBmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdGxvZyhcInNpbGx5XCIsIFwiX3BkLmdyb3d0aDogQ2hlY2tpbmcgZ3JvdyBjb25kaXRpb25cIik7XHJcblx0XHRyZXR1cm4gZ3Jvd3RoRnVuY3Rpb24ocGxheWVyLCBwb3B1bGF0aW9uLCBwZC5iaXJ0aFJhdGUsIHBkLnNlbGVjdGl2ZU11bHRpcGxpZXIpXHJcblx0fTtcclxuXHR0aGlzLmRlY2F5ID0gZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRsb2coXCJzaWxseVwiLCBcIl9wZC5kZWNheTogQ2hlY2tpbmcgZGVjYXkgY29uZGl0aW9uXCIpO1xyXG5cdFx0cmV0dXJuIGRlY2F5RnVuY3Rpb24ocGxheWVyLCBwb3B1bGF0aW9uLCBwZC5kZWF0aFJhdGUsIHBkLnNlbGVjdGl2ZU11bHRpcGxpZXIpO1xyXG5cdH07XHJcblxyXG5cdHRoaXMucGxheWVyUGFyYW1ldGVycyA9IHBsYXllclBhcmFtZXRlcnM7XHJcbn1cclxuX1BvcHVsYXRpb25EeW5hbWljcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9QbGF5YWJsZS5wcm90b3R5cGUpO1xyXG5fUG9wdWxhdGlvbkR5bmFtaWNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9Qb3B1bGF0aW9uRHluYW1pY3M7XHJcblxyXG5fUG9wdWxhdGlvbkR5bmFtaWNzLnJlZ2lzdHJ5TmFtZSA9IFwiY29udHJvbGxlcnNcIjtcclxuX1BvcHVsYXRpb25EeW5hbWljcy5jb3VudGVyTmFtZSA9IFwicG9wdWxhdGlvbkR5bmFtaWNzXCI7XHJcblxyXG5cclxuX1BvcHVsYXRpb25EeW5hbWljcy5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKHtcclxuXHRpbml0aWFsaXplUGxheWVycyA9IGZhbHNlLFxyXG5cdHNob3J0Q2lyY3VpdCA9IGZhbHNlLFxyXG5cdGhpc3RvcnkgPVxyXG5cdGdhbWVIaXN0b3J5XHJcbn0gPSB7fSkge1xyXG5cclxuXHR2YXIgcGQgPSB0aGlzO1xyXG5cclxuXHR2YXIgYmlydGhzID0gMDtcclxuXHR2YXIgZGVhdGhzID0gMDtcclxuXHJcblx0Ly9VcGRhdGUgcG9wdWxhdGlvbiB1c2luZyB3aG9ldmVyJ3MgYWxpdmUgY3VycmVudGx5XHJcblx0cG9wdWxhdGlvbiA9IGdhbWVQb3B1bGF0aW9uKCkub25seUFsaXZlKCk7XHJcblxyXG5cclxuXHQvL0tpbGwgY3ljbGVcclxuXHR2YXIga2lsbGVkID0gbmV3IFBsYXllckxpc3QoW10pO1xyXG5cdHBvcHVsYXRpb24uZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdC8vIElmIHRoZSBkZWNheSBmdW5jdGlvbiBpcyByZXR1cm5zIHRydXRoeSwga2lsbC5cclxuXHJcblx0XHRpZiAocGQuZGVjYXkocGxheWVyKSkge1xyXG5cdFx0XHRsb2coXCJzaWxseVwiLCBcIm11c3Qga2lsbC4uLlwiKVxyXG5cdFx0XHRwbGF5ZXIua2lsbCgpO1xyXG5cdFx0XHRkZWF0aHMrKztcclxuXHRcdFx0a2lsbGVkLnB1c2gocGxheWVyKTtcclxuXHRcdFx0bG9nKFwic2lsbHlcIiwgXCJkZWFkXCIpO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0fSk7XHJcblxyXG5cdC8vVXBkYXRlIHVwZGF0ZSBhZ2FpbiB0byBwcmV2ZW50IHRoZSByZWNlbnRseSBkZWNlYXNlZCBmcm9tIHJlcHJvZHVjaW5nXHJcblx0cG9wdWxhdGlvbiA9IGdhbWVQb3B1bGF0aW9uKCkub25seUFsaXZlKCk7XHJcblxyXG5cdGlmIChwb3B1bGF0aW9uLmxlbmd0aCA9PSAwKSB7XHJcblx0XHQvL0V2ZXJ5Ym9keSdzIGRlYWQuIExldCdzIHdyYXAgaXQgdXAuXHJcblx0XHR2YXIgcmVhc29uID0geyByZXN1bHQ6IFwiUG9wdWxhdGlvbiBDb2xsYXBzZVwiLCBwbGF5YWJsZTogcGQgfTtcclxuXHRcdGhpc3RvcnkuZW5kKCk7XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYXNvbik7XHJcblx0fVxyXG5cclxuXHQvL0JpcnRoIGN5Y2xlXHJcblx0dmFyIGJvcm4gPSBuZXcgVXNlclBsYXllckxpc3QoW10pO1xyXG5cdHBvcHVsYXRpb24uZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdC8vQmlydGggd2hhdGV2ZXIgbnVtYmVyIGlzIHJldHVybmVkXHJcblx0XHR2YXIgbnVtQmlydGggPSBwZC5ncm93dGgocGxheWVyKVxyXG5cdFx0Y29uc29sZS5sb2cobnVtQmlydGgpO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPD0gbnVtQmlydGg7IGkrKykge1xyXG5cdFx0XHRsb2coXCJzaWxseVwiLCBcIlBsYXllciBcIiArIHBsYXllci5pZCArIFwiIGdpdmluZyBiaXJ0aCFcIik7XHJcblxyXG5cdFx0XHR2YXIgcGxheWVyUGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHtcclxuXHRcdFx0XHRhc3NpZ246IHBsYXllci5zdHJhdGVneSA/IHBsYXllci5zdHJhdGVneS5faWQgOiBcIlwiLFxyXG5cdFx0XHRcdHBhcmVudDogcGxheWVyLmlkXHJcblx0XHRcdH0sIHBkLnBsYXllclBhcmFtZXRlcnMpO1xyXG5cclxuXHRcdFx0Ym9ybi5wdXNoKFBsYXllcihwbGF5ZXJQYXJhbWV0ZXJzKSk7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cclxuXHR2YXIgcmVzdWx0ID0geyBiaXJ0aHMsIGRlYXRocyB9O1xyXG5cclxuXHR2YXIgcmVzdWx0T2JqZWN0ID0ge1xyXG5cdFx0cmVzdWx0LFxyXG5cdFx0J3BsYXlhYmxlJzogcGQsXHJcblx0XHRoaXN0b3J5RW50cnk6IHtcclxuXHRcdFx0cG9wdWxhdGlvbkR5bmFtaWNzOiBwZC5pZCxcclxuXHRcdFx0cmVzdWx0XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRPYmplY3QpO1xyXG59O1xyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBQb3B1bGF0aW9uRHluYW1pY3MoYmlydGhSYXRlID0gLjA1LCBkZWF0aFJhdGUgPSAuMDUsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihwYXJhbWV0ZXJzLmlkLCBcInBvcHVsYXRpb25EeW5hbWljc1wiKVxyXG5cclxuXHRpZiAocGFyYW1ldGVycy5ncm93dGggJiYgIWlzRnVuY3Rpb24oZ3Jvd3RoKSkgbG9nKFwiZXJyb3JcIiwgaWQgKyBcIjogZ3Jvd3RoIHNob3VsZCBiZSBhIGZ1bmN0aW9uLlwiKTtcclxuXHRpZiAocGFyYW1ldGVycy5kZWNheSAmJiAhaXNGdW5jdGlvbihkZWNheSkpIGxvZyhcImVycm9yXCIsIGlkICsgXCI6IGRlY2F5IHNob3VsZCBiZSBhIGZ1bmN0aW9uLlwiKTtcclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBsYW1iZGEgb2JqZWN0XHJcblx0dmFyIF9wZCA9IG5ldyBfUG9wdWxhdGlvbkR5bmFtaWNzKGlkLCBiaXJ0aFJhdGUsIGRlYXRoUmF0ZSwgcGFyYW1ldGVycyk7XHJcblxyXG5cclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIHBkID0gUGxheWFibGUoX3BkKTtcclxuXHRyZXR1cm4gcGQ7XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX1BvcHVsYXRpb25EeW5hbWljcywgUG9wdWxhdGlvbkR5bmFtaWNzIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xyXG5sb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgQ2xhc3M6IFJhbmRvbVBsYXllckNob2ljZVwiKVxyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5LCBnYW1lSGlzdG9yeSwgb2NjdXBpZWRQbGF5ZXJzIH0gPSByZXF1aXJlKCcuLi9zdGF0ZScpO1xyXG52YXIgUHJvbWlzZSA9IHJlZ2lzdHJ5LlByb21pc2U7IC8vIEZvciBzeW5jIG1vZGVcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoJy4uL2hlbHBlci1mdW5jdGlvbnMnKShcInN0YXRlXCIpO1xyXG52YXIgeyBjaGFpbmVyR2VuZXJhdG9yIH0gPSByZXF1aXJlKCcuLi9oZWxwZXItZnVuY3Rpb25zJykoXCJwbGF5YWJsZVwiKTtcclxuXHJcbi8vUGFyZW50IGNsYXNzXHJcbnZhciB7IF9QbGF5YWJsZSwgUGxheWFibGUgfSA9IHJlcXVpcmUoJy4vcGxheWFibGUnKTtcclxudmFyIHsgX0Nob2ljZSwgQ2hvaWNlIH0gPSByZXF1aXJlKCcuL2Nob2ljZScpO1xyXG5cclxuLy9Qb3B1bGF0aW9uIGhlbHBlcnNcclxudmFyIHsgUGxheWVyTGlzdCB9ID0gcmVxdWlyZSgnLi4vcG9wdWxhdGlvbicpO1xyXG5cclxuXHJcbi8vQmFja2VuZCBmdW5jdGlvbiBjbGFzcyBmb3IgUlBDaG9pY2VcclxuZnVuY3Rpb24gX1JQQ2hvaWNlKGlkLCBvcHRpb25zLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHJcblx0Ly9JZiB0aGV5IHNwZWNpZnkgcGxheWVycyB0byBkcmF3IGZyb20sIHVzZSBvbmx5IHRoYXQgbGlzdC4gT3RoZXJ3aXNlLCB1c2Ugd2hvZXZlcidzIGFyb3VuZC5cclxuXHR0aGlzLmluY2x1ZGVQbGF5ZXJzID0gcGFyYW1ldGVycy5pbmNsdWRlUGxheWVycyB8fCBcImFsbFwiO1xyXG5cclxuXHR0aGlzLmV4Y2x1ZGVQbGF5ZXJzID0gcGFyYW1ldGVycy5leGNsdWRlUGxheWVycyA/IG5ldyBQbGF5ZXJMaXN0KHBhcmFtZXRlcnMuZXhjbHVkZVBsYXllcnMpIDogbmV3IFBsYXllckxpc3QoKVxyXG5cclxuXHR0aGlzLmdlbmVyYXRvciA9IE1hdGgucmFuZG9tO1xyXG5cclxuXHR2YXIgcGxheWVyID0gbnVsbDtcclxuXHJcblxyXG5cdF9DaG9pY2UuY2FsbCh0aGlzLCBpZCwgcGxheWVyLCBvcHRpb25zLCBwYXJhbWV0ZXJzKTtcclxufVxyXG5cclxuX1JQQ2hvaWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX0Nob2ljZS5wcm90b3R5cGUpO1xyXG5fUlBDaG9pY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gX1JQQ2hvaWNlO1xyXG5cclxuX1JQQ2hvaWNlLnJlZ2lzdHJ5TmFtZSA9IFwiY2hvaWNlc1wiO1xyXG5fUlBDaG9pY2UuY291bnRlck5hbWUgPSBcInJhbmRvbVBsYXllckNob2ljZVwiO1xyXG5cclxuXHJcblxyXG4vL1NlbGVjdCB0aGUgcGxheWVyIHRvIG1ha2UgdGhlIGNob2ljZVxyXG5fUlBDaG9pY2UucHJvdG90eXBlLmNob29zZVBsYXllciA9IGZ1bmN0aW9uIGNob29zZVBsYXllcigpIHtcclxuXHJcblx0dmFyIHJwQ2hvaWNlID0gdGhpcztcclxuXHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0Ly9GaW5kIHBsYXllcnMgdG8gY2hvb3NlIGZyb21cclxuXHRcdHZhciBwb29sID0gbmV3IFBsYXllckxpc3QocnBDaG9pY2UuaW5jbHVkZVBsYXllcnMpLm9ubHlBbGl2ZSgpLm9ubHlBdmFpbGFibGUoKS5leGNsdWRlKHJwQ2hvaWNlLmV4Y2x1ZGVQbGF5ZXJzKVxyXG5cdFx0aWYgKHBvb2wubGVuZ3RoID09IDApIHJldHVybiBQcm9taXNlLnJlamVjdChcIk5vIGF2YWlsYWJsZSBwbGF5ZXJzLlwiKTtcclxuXHJcblx0XHRsb2coXCJzaWxseVwiLCBcInJwQ2hvaWNlLmNob29zZVBsYXllcjogY2hvb3NpbmcgZnJvb20gcG9vbDogXCIgKyBwb29sLmlkcygpKTtcclxuXHJcblx0XHR2YXIgcmFuZG9tTnVtYmVyID0gTWF0aC5mbG9vcihycENob2ljZS5nZW5lcmF0b3IoKSAqIHBvb2wubGVuZ3RoKTtcclxuXHRcdHZhciBjYW5kaWRhdGUgPSBwb29sW3JhbmRvbU51bWJlcl07XHJcblxyXG5cclxuXHRcdGxvZyhcInNpbGx5XCIsIFwicnBDaG9pY2UuY2hvb3NlUGxheWVyOiBzZWxlY3RpbmcgcGxheWVyIFwiLCBjYW5kaWRhdGUuaWQpXHJcblxyXG5cdFx0cnBDaG9pY2UucGxheWVyID0gY2FuZGlkYXRlO1xyXG5cdFx0Y2FuZGlkYXRlLmF2YWlsYWJsZSA9IGZhbHNlO1xyXG5cclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FuZGlkYXRlLmlkKTtcclxuXHR9KTtcclxufTtcclxuXHJcbl9SUENob2ljZS5wcm90b3R5cGUucHJlUGxheSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmNob29zZVBsYXllcigpO1xyXG59O1xyXG5cclxuXHJcbl9SUENob2ljZS5wcm90b3R5cGUuc3VtbWFyeVRoaXMgPSBmdW5jdGlvbihzdW1tYXJ5KSB7XHJcblx0c3VtbWFyeS5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG59O1xyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBSYW5kb21QbGF5ZXJDaG9pY2Uob3B0aW9ucywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIHsgaWQgPSBudWxsLCBleGNsdWRlUGxheWVycyA9IFtdLCBwbGF5ZXJMaXN0ID0gbnVsbCB9ID0gcGFyYW1ldGVyc1xyXG5cclxuXHR2YXIgaWQgPSBpZEhhbmRsZXIoaWQsIFwicmFuZG9tUGxheWVyQ2hvaWNlXCIpXHJcblxyXG5cdC8vQ3JlYXRlIGJhY2tlbmQgY2hvaWNlIG9iamVjdFxyXG5cdHZhciBfcnBDaG9pY2UgPSBuZXcgX1JQQ2hvaWNlKGlkLCBvcHRpb25zLCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0Ly9SZXR1cm4gdGhpcyByZWZlcmVuY2Ugb2JqZWN0IHRvIHRoZSB1c2VyLiBSdW4gdGhlIGZ1bmN0aW9uIHRvIHNlbGVjdCBhIHNvdXJjZVxyXG5cdHZhciBycENob2ljZSA9IFBsYXlhYmxlKF9ycENob2ljZSlcclxuXHJcblx0cnBDaG9pY2UucGxheWVyTGlzdCA9IGZ1bmN0aW9uKHBsYXllckxpc3QpIHtcclxuXHRcdGlmIChBcnJheS5pc0FycmF5KHBsYXllckxpc3QpKSBfcnBDaG9pY2UucGxheWVyTGlzdCA9IHBsYXllckxpc3Q7XHJcblx0XHRyZXR1cm4gX3JwQ2hvaWNlLnBsYXllckxpc3RcclxuXHR9O1xyXG5cclxuXHRycENob2ljZS5leGNsdWRlUGxheWVycyA9IGZ1bmN0aW9uKGV4Y2x1ZGVQbGF5ZXJzKSB7XHJcblx0XHRpZiAoQXJyYXkuaXNBcnJheShleGNsdWRlUGxheWVycykpIHtcclxuXHRcdFx0X3JwQ2hvaWNlLmV4Y2x1ZGVQbGF5ZXJzID0gW107XHJcblxyXG5cdFx0XHRleGNsdWRlUGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdF9ycENob2ljZS5leGNsdWRlUGxheWVycy5wdXNoKHBsYXllci5pZCgpKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIF9ycENob2ljZS5leGNsdWRlUGxheWVyc1xyXG5cdH07XHJcblxyXG5cdC8vSW50ZXJmYWNlIHRvIHNwZWNpZnkgc2luZ2xlLXBsYXllciBwYXlvZmZzIGluIHNpbmdsZS1wbGF5ZXIvc2luZ2xlLWNob2ljZSBnYW1lc1xyXG5cdF9ycENob2ljZS56ZXJvUGF5b2ZmcygpO1xyXG5cclxuXHRfcnBDaG9pY2UuZ2VuZXJhdGVDaGFpbmluZ0Z1bmN0aW9ucyhycENob2ljZSk7XHJcblxyXG5cdC8vRnVuY3Rpb24gdG8gc2V0IGFsbCBwYXlvZmZzIGF0IG9uY2VcclxuXHRycENob2ljZS5zZXRBbGxQYXlvZmZzID0gZnVuY3Rpb24ocGF5b2Zmcykge1xyXG5cdFx0Ly9UT0RPOiBtYWtlIHRoaXMgd29yay4gSW5jbHVkZSBlcnJvciBoYW5kbGluZyBpZiBhcnJheSBnaXZlbiBpc24ndCBleHBlY3RlZCBkaW1lbnNpb25zLlxyXG5cdH07XHJcblxyXG5cclxuXHQvL1dheSBmb3IgdXNlciB0byBpbnRlcmFjdCB3aXRoIHBheW9mZnNcclxuXHRycENob2ljZS5wYXlvZmZzID0gZnVuY3Rpb24oKSB7IHJldHVybiByZWdpc3RyeS5kZWNpc2lvbnNbaWRdLnBheW9mZnM7IH07XHJcblxyXG5cdHJldHVybiBycENob2ljZTtcclxufVxyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX1JQQ2hvaWNlLCBSYW5kb21QbGF5ZXJDaG9pY2UgfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBSYW5nZVwiKTtcclxuXHJcbi8vIEV4dGVybmFsIGJhc2UgY2xhc3NcclxudmFyIENhbGxhYmxlSW5zdGFuY2UgPSByZXF1aXJlKFwiY2FsbGFibGUtaW5zdGFuY2VcIilcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZShcIi4uL3N0YXRlXCIpO1xyXG52YXIgUHJvbWlzZSA9IHJlZ2lzdHJ5LlByb21pc2U7IC8vIEZvciBzeW5jIG1vZGVcclxudmFyIHsgZ2FtZUhpc3RvcnkgfSA9IHJlcXVpcmUoXCIuLi9oaXN0b3J5XCIpO1xyXG52YXIgeyBQZXJmZWN0SW5mb3JtYXRpb24gfSA9IHJlcXVpcmUoXCIuLi9pbmZvcm1hdGlvblwiKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXItZnVuY3Rpb25zXCIpKFwic3RhdGVcIik7XHJcbnZhciB7IGlzRnVuY3Rpb24gfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXItZnVuY3Rpb25zXCIpKFwiZ2VuZXJhbFwiKTtcclxudmFyIHsgY2hhaW5lckdlbmVyYXRvciB9ID0gcmVxdWlyZShcIi4uL2hlbHBlci1mdW5jdGlvbnNcIikoXCJwbGF5YWJsZVwiKTtcclxuXHJcbi8vYmFzZSBDbGFzc2VzXHJcbnZhciB7IEJyYW5jaCwgX1BsYXlhYmxlLCBQbGF5YWJsZSB9ID0gcmVxdWlyZShcIi4vcGxheWFibGVcIilcclxuXHJcbi8vIENsYXNzIHRvIGhvbGQgdXNlci1kZWZpbmVkIGV2YWx1YXRvciBmdW5jdGlvbnMsIG1vc3RseSBmb3Igc3BlZWR5IHR5cGUgY29tcGFyaXNvbnNcclxuY2xhc3MgRXZhbHVhdG9yIGV4dGVuZHMgQ2FsbGFibGVJbnN0YW5jZSB7XHJcblx0Y29uc3RydWN0b3IoZnVuYywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0XHRzdXBlcihcInRlc3RcIilcclxuXHRcdHRoaXMuZnVuYyA9IGZ1bmNcclxuXHRcdHRoaXMuaWQgPSBwYXJhbWV0ZXJzLmlkIHx8IGZ1bmMubmFtZSB8fCBcImV2YWx1YXRvclwiXHJcblx0XHR2YXIgZXZhbHVhdG9yID0gdGhpcztcclxuXHRcdHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGV2YWx1YXRvci5pZCB9XHJcblx0fVxyXG5cdHRlc3QodmFsdWUpIHtcclxuXHRcdHJldHVybiB0aGlzLmZ1bmModmFsdWUpXHJcblx0fVxyXG59XHJcblxyXG5cclxuLy8gQnJhbmNoIHN1YmNsYXNzXHJcbnZhciBSYW5nZU91dGNvbWUgPSAoZnVuY3Rpb24oKSB7XHJcblx0Ly8gUHJpdmF0ZSBkYXRhXHJcblx0dmFyIF9yYW5nZXMgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuXHRjbGFzcyBSYW5nZU91dGNvbWUgZXh0ZW5kcyBCcmFuY2gge1xyXG5cdFx0Y29uc3RydWN0b3IoZXZhbHVhdG9yLCBfcmFuZ2UpIHtcclxuXHRcdFx0c3VwZXIoZXZhbHVhdG9yLCBfcmFuZ2UuaW50ZXJmYWNlKVxyXG5cdFx0XHRfcmFuZ2VzLnNldCh0aGlzLCBfcmFuZ2UpXHJcblxyXG5cdFx0XHRfcmFuZ2UubmV4dC5zZXQoZXZhbHVhdG9yLCBbXSkgLy8gYWRkIGJsYW5rIG5leHRtYXAgb25jZSB0aGUgYnJhbmNoIGlzIGRlZmluZWRcclxuXHRcdH1cclxuXHJcblx0XHQvLyBUaGUgX19jYWxsX18gZnVuY3Rpb24sIHRoaXMgd2lsbCBzZXQgdGhlIHBheW9mZiBvZiB0aGUgYnJhbmNoXHJcblx0XHRwYXlvZmYocGF5b2ZmKSB7XHJcblx0XHRcdHZhciBfcmFuZ2UgPSBfcmFuZ2VzLmdldCh0aGlzKVxyXG5cdFx0XHRpZiAoIWlzTmFOKHBheW9mZikpIF9yYW5nZS5wYXlvZmZzLnNldCh0aGlzLnBhdGgsIHBheW9mZik7XHJcblx0XHRcdHJldHVybiBzdXBlci5wYXlvZmYoKVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIFJhbmdlT3V0Y29tZTtcclxufSkoKVxyXG5cclxuXHJcbmNsYXNzIF9SYW5nZSBleHRlbmRzIF9QbGF5YWJsZSB7XHJcblx0Y29uc3RydWN0b3IoaWQsIHBsYXllciwgYm91bmRzLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRcdHN1cGVyKGlkLCBwYXJhbWV0ZXJzKVxyXG5cclxuXHRcdHRoaXMucGxheWVyID0gcmVnaXN0cnkucGxheWVyc1twbGF5ZXJdO1xyXG5cdFx0dGhpcy5ib3VuZHMgPSBib3VuZHM7XHJcblx0XHR0aGlzLmRlZmF1bHRPcHRpb24gPSBwYXJhbWV0ZXJzLmRlZmF1bHRPcHRpb24gfHwgYm91bmRzWzBdO1xyXG5cdFx0dGhpcy5wbGF5ZXJNZXRob2QgPSBwYXJhbWV0ZXJzLnBsYXllck1ldGhvZCB8fCBcInJhbmdlXCJcclxuXHRcdHRoaXMuaW5mb3JtYXRpb25GaWx0ZXIgPSBwYXJhbWV0ZXJzLmluZm9ybWF0aW9uRmlsdGVyIHx8IG51bGw7XHJcblx0XHR0aGlzLnVzZVBheW9mZnMgPSBwYXJhbWV0ZXJzLnVzZVBheW9mZnMgfHwgZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5uZXh0ID0gbmV3IE1hcChbXHJcblx0XHRcdFtcImFsbFwiLCBbXV1cclxuXHRcdF0pIC8vIGFsbCBpcyBmb3IgYW55LW91dGNvbWUgY2FzZXNcclxuXHRcdHRoaXMucGF5b2ZmcyA9IG5ldyBNYXAoKVxyXG5cdH1cclxuXHJcblx0YWRkTmV4dChuZXh0UGxheWFibGUsIHBhdGggPSBcImFsbFwiKSB7XHJcblx0XHRpZiAocGF0aCA9PSBcImFsbFwiKSB0aGlzLm5leHQuZ2V0KFwiYWxsXCIpLnB1c2gobmV4dFBsYXlhYmxlKVxyXG5cdFx0ZWxzZSBpZiAodGhpcy5uZXh0LmhhcyhwYXRoKSkgdGhpcy5uZXh0LmdldChwYXRoKS5wdXNoKG5leHRQbGF5YWJsZSlcclxuXHRcdGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXRoOiBcIi5jb25jYXQocGF0aCkpXHJcblx0fVxyXG5cclxuXHRmaW5kTmV4dCh7IHJlc3VsdCB9ID0ge30pIHtcclxuXHRcdC8vIHJldHVybiB0aGUgXCJhbnkgb3V0Y29tZVwiIGNhc2VzXHJcblx0XHR2YXIgbmV4dCA9IHRoaXMubmV4dC5nZXQoXCJhbGxcIikuc2xpY2UoKVxyXG5cclxuXHRcdC8vIEZvciBlYWNoIGV2YWx1YXRvciwgcnVuIGl0IHdpdGggdGhlIHJlc3VsdCwgYW5kIGlmIHRydWUsIGFkZCB0aG9zZSBwbGF5YWJsZXMgdG8gdGhlIGxpc3RcclxuXHRcdGZvciAodmFyIFtldmFsdWF0b3IsIHBsYXlhYmxlc10gb2YgdGhpcy5uZXh0KSB7XHJcblx0XHRcdGlmIChldmFsdWF0b3IgIT09IFwiYWxsXCIgJiYgZXZhbHVhdG9yKHJlc3VsdC5yZXN1bHQpID09PSB0cnVlKSBuZXh0LnB1c2goLi4ucGxheWFibGVzKVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5leHRcclxuXHR9XHJcblxyXG5cdHBsYXkoe1xyXG5cdFx0dXNlUGF5b2ZmcyA9IHRoaXMudXNlUGF5b2ZmcyxcclxuXHRcdGhpc3RvcnkgPSBnYW1lSGlzdG9yeSxcclxuXHRcdGluZm9ybWF0aW9uOiByYXdJbmZvcm1hdGlvbiA9IFBlcmZlY3RJbmZvcm1hdGlvbixcclxuXHRcdHJlbGVhc2VQbGF5ZXIgPSB0cnVlLFxyXG5cdFx0aW5mb3JtYXRpb25GaWx0ZXIgPSB0aGlzLmluZm9ybWF0aW9uRmlsdGVyLFxyXG5cdFx0X2NvbXBpbGVJbmZvcm1hdGlvbiA9IG51bGxcclxuXHR9ID0ge30pIHtcclxuXHRcdHZhciByYW5nZSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCFyYW5nZS5wbGF5ZXIuYWxpdmUpXHJcblx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdCh7XHJcblx0XHRcdFx0cmVzdWx0OiByYW5nZS5pZCArIFwiOiBQbGF5ZXIgXCIgKyByYW5nZS5wbGF5ZXIuaWQgKyBcIiBpcyBkZWFkLlwiXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdC8vV2hpbGUgdGhpcyByYW5nZSBpcyBoYXBwZW5pbmcsIGRvbid0IGFsbG93IG90aGVyIGNob2ljZXMgdG8gdXNlIHRoaXMgcGxheWVyLlxyXG5cdFx0cmFuZ2UucGxheWVyLmF2YWlsYWJsZSA9IGZhbHNlO1xyXG5cclxuXHRcdC8vSW5mb3JtYXRpb24gbWVjaGFuaWNzLiBJZiB3ZSdyZSBkZWFsaW5nIHdpdGggUGVyZmVjdEluZm9ybWF0aW9uLCB0aGlzIHdvbid0IGdldCBkZWxpdmVyZWQsIHNvIHdlJ2xsIGluY2x1ZGUgaXQgaW4gdGhlIGNhbGwgdG8gLmRlbGl2ZXIoKS4gSWYgd2UncmUgdXNpbmcgYW4gaW5mb3JtYXRpb24gc3VwcGxpZWQgZnJvbSBzb21lIG90aGVyIHBsYXlhYmxlLCB0aGVuIHRoZXkgY2FuIGRvIHdoYXQgdGhleSBsaWtlIHdpdGggaXQuXHJcblx0XHR2YXIgcmFuZ2VJbmZvID0ge1xyXG5cdFx0XHRyYW5nZToge1xyXG5cdFx0XHRcdGlkOiByYW5nZS5pZCxcclxuXHRcdFx0XHRwbGF5ZXI6IHJhbmdlLnBsYXllci5pZCxcclxuXHRcdFx0XHRib3VuZHM6IHJhbmdlLmJvdW5kc1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdFx0cmF3SW5mb3JtYXRpb24uYWRkQWRkaXRpb25hbChyYW5nZUluZm8pO1xyXG5cdFx0Ly9QZXJmb3JtIHNvbWUgZGF0YSBwcm9jZXNzaW5nIGlmIG90aGVyIHBsYXlhYmxlcyBuZWVkIGl0LlxyXG5cdFx0aWYgKF9jb21waWxlSW5mb3JtYXRpb24pIF9jb21waWxlSW5mb3JtYXRpb24ocmF3SW5mb3JtYXRpb24pO1xyXG5cclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxyXG5cdFx0XHQudGhlbihmdW5jdGlvbigpIHtcclxuXHRcdFx0XHQvL1ByZXAgaW5mb3JtYXRpb25cclxuXHRcdFx0XHR2YXIgaW5mb3JtYXRpb24gPSByYXdJbmZvcm1hdGlvbi5kZWxpdmVyKHJhbmdlLnBsYXllciwgcmFuZ2VJbmZvKTtcclxuXHRcdFx0XHRpZiAoaW5mb3JtYXRpb25GaWx0ZXIpIGluZm9ybWF0aW9uID0gaW5mb3JtYXRpb25GaWx0ZXIoaW5mb3JtYXRpb24pO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gcmFuZ2UucGxheWVyLmNob29zZShyYW5nZS5ib3VuZHMuc2xpY2UoMCksIGluZm9ybWF0aW9uLCByYW5nZS5wbGF5ZXJNZXRob2QpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0XHR2YXIgcGxheWVyID0gcmFuZ2UucGxheWVyO1xyXG5cdFx0XHRcdHZhciBpZCA9IHJhbmdlLmlkO1xyXG5cclxuXHRcdFx0XHQvL0FkZCB0byBwbGF5ZXIncyBpbmRpdmlkdWFsIGhpc3Rvcnk7XHJcblx0XHRcdFx0cGxheWVyLmhpc3RvcnkucHVzaCh7XHJcblx0XHRcdFx0XHRyYW5nZTogaWQsXHJcblx0XHRcdFx0XHRib3VuZHM6IHJhbmdlLmJvdW5kcyxcclxuXHRcdFx0XHRcdHJlc3VsdFxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRyZXN1bHQgPSByZXN1bHQgfHwgcmFuZ2UuZGVmYXVsdE9wdGlvbjtcclxuXHJcblx0XHRcdFx0Ly8gRW5mb3JjZSBzb21lIHJ1bGVzIG9uIHJlc3BvbnNlc1xyXG5cdFx0XHRcdHZhciBib3VuZHMgPSByYW5nZS5ib3VuZHNcclxuXHRcdFx0XHRpZiAocmVzdWx0IDwgYm91bmRzWzBdKSByZXN1bHQgPSBib3VuZHNbMF1cclxuXHRcdFx0XHRpZiAocmVzdWx0ID4gYm91bmRzWzFdKSByZXN1bHQgPSBib3VuZHNbMV1cclxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGFuIGluY3JlbWVudCAoYm91bmRzWzJdKSByb3VuZCB0byB0aGUgbmVhcmVzdCBpbmNyZW1lbnRcclxuXHRcdFx0XHRpZiAocmFuZ2UuYm91bmRzWzJdKSB7XHJcblx0XHRcdFx0XHRyZXN1bHQgPSBNYXRoLnJvdW5kKHJlc3VsdCAvIHJhbmdlLmJvdW5kc1syXSkgKiByYW5nZS5ib3VuZHNbMl1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciByZXN1bHRPYmplY3QgPSB7XHJcblx0XHRcdFx0XHRyZXN1bHQsXHJcblx0XHRcdFx0XHRoaXN0b3J5RW50cnk6IHtcclxuXHRcdFx0XHRcdFx0cmFuZ2U6IGlkLFxyXG5cdFx0XHRcdFx0XHRwbGF5ZXI6IHBsYXllci5pZCxcclxuXHRcdFx0XHRcdFx0cmVzdWx0XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fTtcclxuXHJcblxyXG5cdFx0XHRcdC8vVGhpcyB3aWxsIHByb2JhYmx5IG9ubHkgaGFwcGVuIGlmIGl0J3MgYSBzaW5nbGUtcGxheWVyIGdhbWUsIG90aGVyd2lzZSB3ZSdsbCB1c2UgcGxheW9mZnMgZGVmaW5lZCBpbiBhIFR1cm5cclxuXHRcdFx0XHRpZiAodXNlUGF5b2Zmcykge1xyXG5cdFx0XHRcdFx0dmFyIHBheW91dCA9IDA7XHJcblx0XHRcdFx0XHRmb3IgKHZhciBbZXZhbHVhdG9yLCBwYXlvZmZdIG9mIHJhbmdlLnBheW9mZnMuZW50cmllcygpKSB7XHJcblx0XHRcdFx0XHRcdGlmIChldmFsdWF0b3IgPT0gXCJhbGxcIikgcGF5b3V0ICs9IHBheW9mZlxyXG5cdFx0XHRcdFx0XHRlbHNlIGlmIChldmFsdWF0b3IocmVzdWx0KSkgcGF5b3V0ICs9IHBheW9mZlxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHBsYXllci5zY29yZSArPSBwYXlvdXQ7XHJcblxyXG5cdFx0XHRcdFx0Ly90cmFjayB0aGUgcGF5b2ZmXHJcblx0XHRcdFx0XHR2YXIgc2NvcmVFbnRyeSA9IHtcclxuXHRcdFx0XHRcdFx0cmFuZ2U6IGlkLFxyXG5cdFx0XHRcdFx0XHRwYXlvdXRzOiB7XHJcblx0XHRcdFx0XHRcdFx0W3BsYXllci5pZF06IHBheW91dFxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0aGlzdG9yeS5hZGRTY29yZXMoc2NvcmVFbnRyeSk7XHJcblxyXG5cdFx0XHRcdFx0cmVzdWx0T2JqZWN0Lmhpc3RvcnlFbnRyeS5wYXlvdXRzID0ge1xyXG5cdFx0XHRcdFx0XHRbcGxheWVyLmlkXTogcGF5b3V0XHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bG9nKFxyXG5cdFx0XHRcdFx0XCJzaWxseVwiLFxyXG5cdFx0XHRcdFx0XCJfQ2hvaWNlLnBsYXk6IHJlbW92aW5nIGZyb20gb2NjdXBpZWRQbGF5ZXJzOiBcIixcclxuXHRcdFx0XHRcdHJhbmdlLnBsYXllci5pZFxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdFx0aWYgKHJlbGVhc2VQbGF5ZXIpIHJhbmdlLnJlbGVhc2VQbGF5ZXIoKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRPYmplY3QpOyAvL1RPRE86IGFkZCBpbmZvcm1hdGlvbiBtZWNoYW5pc21zXHJcblx0XHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Ly9SZWxlYXNlIHBsYXllciBmcm9tIGV4Y2x1ZGVkIHBsYXllcnMgbGlzdCwgc28gdGhhdCBvdGhlciBvYmplY3RzIGNhbiB1c2UgaXQuXHJcblx0cmVsZWFzZVBsYXllcigpIHtcclxuXHRcdHRoaXMucGxheWVyLmF2YWlsYWJsZSA9IHRydWU7XHJcblx0fTtcclxuXHJcblxyXG5cdHN1bW1hcnlUaGlzKHN1bW1hcnkpIHtcclxuXHRcdHN1bW1hcnkoXCJwbGF5ZXJcIiwgdGhpcy5wbGF5ZXIuaWQpO1xyXG5cdFx0c3VtbWFyeShcImJvdW5kc1wiLCB0aGlzLmJvdW5kcy5zbGljZSgpKTtcclxuXHJcblx0XHRyZXR1cm4gc3VtbWFyeTtcclxuXHR9O1xyXG5cclxuXHJcblx0c3VtbWFyeU5leHQoc3VtbWFyeSkge1xyXG5cdFx0Ly8gY29uc3RydWN0IHRoZSB0cmVlIGluIHRoZSBzdW1tYXJ5IGJhc2VkIG9uIGF2YWlsYWJsZSBib3VuZHNcclxuXHRcdHN1bW1hcnkubWFwQXJyYXkoXCJuZXh0XCIsIHRoaXMubmV4dCwgZnVuY3Rpb24ocGxheWFibGUsIHN1bW1hcnkpIHtcclxuXHRcdFx0cmV0dXJuIHBsYXlhYmxlLnN1bW1hcml6ZShzdW1tYXJ5KVxyXG5cdFx0fSlcclxuXHJcblx0XHQvLyBpZiB0aGVyZSdzIG5vIHJlc3VsdCwgZGVsZXRlIHRoZSB0YWcgdG8gYXZvaWQgY2x1dHRlclxyXG5cdFx0aWYgKHN1bW1hcnkoXCJuZXh0XCIpID09PSB1bmRlZmluZWQpIHN1bW1hcnkuZGVsZXRlKFwibmV4dFwiKVxyXG5cclxuXHRcdHJldHVybiBzdW1tYXJ5O1xyXG5cdH07XHJcblxyXG59XHJcbl9SYW5nZS5yZWdpc3RyeU5hbWUgPSBcImRlY2lzaW9uc1wiO1xyXG5fUmFuZ2UuY291bnRlck5hbWUgPSBcInJhbmdlXCI7XHJcblxyXG5cclxuLy8gVXNlciBvYmplY3QgZm9yIFJhbmdlLlxyXG5jbGFzcyBSYW5nZSBleHRlbmRzIFBsYXlhYmxlIHtcclxuXHRjb25zdHJ1Y3RvcihwbGF5ZXIsIGJvdW5kcywgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0XHR2YXIgaWQgPSBpZEhhbmRsZXIocGFyYW1ldGVycy5pZCwgXCJyYW5nZVwiKTtcclxuXHJcblx0XHQvL0lmIGluZm9ybWF0aW9uRmlsdGVyIHdhcyBzdXBwbGllZCwgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uXHJcblx0XHRpZiAocGFyYW1ldGVycy5pbmZvcm1hdGlvbkZpbHRlciAmJiAhaXNGdW5jdGlvbihwYXJhbWV0ZXJzLmluZm9ybWF0aW9uRmlsdGVyKSlcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiaW5mb3JtYXRpb25GaWx0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xyXG5cclxuXHRcdC8vQ3JlYXRlIGJhY2tlbmQgcmFuZ2Ugb2JqZWN0XHJcblx0XHR2YXIgX3JhbmdlID0gbmV3IF9SYW5nZShpZCwgcGxheWVyLmlkKCksIGJvdW5kcywgcGFyYW1ldGVycyk7XHJcblxyXG5cdFx0Ly8gUnVuIFBsYXlhYmxlIGNvbnN0cnVjdG9yXHJcblx0XHRzdXBlcihfcmFuZ2UpXHJcblx0fVxyXG5cclxuXHQvLyBVc2VyIGNhbiBzdXBwbHkgYSBmdW5jdGlvbiB0byBldmFsdWF0ZSB3aGF0IHRvIGRvIG5leHRcclxuXHRvdXRjb21lKGZ1bmMsIHBhcmFtZXRlcnMpIHtcclxuXHRcdHZhciBldmFsdWF0b3IgPSBuZXcgRXZhbHVhdG9yKGZ1bmMsIHBhcmFtZXRlcnMpXHJcblx0XHRyZXR1cm4gbmV3IFJhbmdlT3V0Y29tZShldmFsdWF0b3IsIHJlZ2lzdHJ5LmRlY2lzaW9uc1t0aGlzLmlkKCldKVxyXG5cdH1cclxuXHJcblx0Ly8gRnVuY3Rpb24gdG8gc2VlIHRoZSByZXN1bHRzIG9mIGEgcGFydGljdWxhciByZXN1bHRcclxuXHRwYXlvZmYoKSB7XHJcblx0XHR2YXIgcmFuZ2UgPSB0aGlzO1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHR2YXIgX3JhbmdlID0gcmVnaXN0cnkuZGVjaXNpb25zW3JhbmdlLmlkKCldXHJcblxyXG5cdFx0XHR2YXIgcGF5b3V0ID0gMDtcclxuXHRcdFx0Zm9yICh2YXIgW2V2YWx1YXRvciwgcGF5b2ZmXSBvZiBfcmFuZ2UucGF5b2Zmcy5lbnRyaWVzKCkpIHtcclxuXHRcdFx0XHRpZiAoZXZhbHVhdG9yID09IFwiYWxsXCIpIHBheW91dCArPSBwYXlvZmZcclxuXHRcdFx0XHRlbHNlIGlmIChldmFsdWF0b3IocmVzdWx0KSkgcGF5b3V0ICs9IHBheW9mZlxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBwYXlvdXRcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IEV2YWx1YXRvciwgUmFuZ2VPdXRjb21lLCBfUmFuZ2UsIFJhbmdlIH1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2xvZ2dlclwiKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBTZXF1ZW5jZVwiKTtcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZShcIi4uL3N0YXRlXCIpO1xyXG52YXIgUHJvbWlzZSA9IHJlZ2lzdHJ5LlByb21pc2U7IC8vIEZvciBzeW5jIG1vZGVcclxudmFyIHsgZ2FtZUhpc3RvcnkgfSA9IHJlcXVpcmUoXCIuLi9oaXN0b3J5XCIpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlkSGFuZGxlciB9ID0gcmVxdWlyZShcIi4uL2hlbHBlci1mdW5jdGlvbnNcIikoXCJzdGF0ZVwiKTtcclxuXHJcbi8vSW5mb3JtYXRpb25cclxudmFyIHsgSW5mb3JtYXRpb24sIFBlcmZlY3RJbmZvcm1hdGlvbiB9ID0gcmVxdWlyZShcIi4uL2luZm9ybWF0aW9uXCIpO1xyXG5cclxuLy9QYXJlbnQgY2xhc3NcclxudmFyIHsgX1BsYXlhYmxlLCBQbGF5YWJsZSB9ID0gcmVxdWlyZShcIi4vcGxheWFibGVcIik7XHJcblxyXG4vL0JhY2tlbmQgZnVuY3Rpb24gY2xhc3MgZm9yIFNlcXVlbmNlXHJcbmZ1bmN0aW9uIF9TZXF1ZW5jZShpZCwgcGxheWFibGVTdGFydCwgcGxheWFibGVGaW5pc2gsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdF9QbGF5YWJsZS5jYWxsKHRoaXMsIGlkLCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0dGhpcy5wbGF5YWJsZVN0YXJ0ID0gcmVnaXN0cnkucGxheWFibGVzW3BsYXlhYmxlU3RhcnQuaWQoKV07XHJcblx0dGhpcy5wbGF5YWJsZUZpbmlzaCA9IHJlZ2lzdHJ5LnBsYXlhYmxlc1twbGF5YWJsZUZpbmlzaC5pZCgpXTtcclxufVxyXG5fU2VxdWVuY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfUGxheWFibGUucHJvdG90eXBlKTtcclxuX1NlcXVlbmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9TZXF1ZW5jZTtcclxuXHJcbl9TZXF1ZW5jZS5yZWdpc3RyeU5hbWUgPSBcInNlcXVlbmNlc1wiO1xyXG5fU2VxdWVuY2UuY291bnRlck5hbWUgPSBcInNlcXVlbmNlXCI7XHJcblxyXG5fU2VxdWVuY2UucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7XHJcblx0aGlzdG9yeSA9IGdhbWVIaXN0b3J5LFxyXG5cdGluZm9ybWF0aW9uID0gdGhpcy5pbmZvcm1hdGlvbiB8fFxyXG5cdFBlcmZlY3RJbmZvcm1hdGlvblxyXG59ID0ge30pIHtcclxuXHJcblx0dmFyIHNlcXVlbmNlID0gdGhpcztcclxuXHJcblx0Ly9Mb2cgdGhlIGhpc3RvcnkgYXBwcm9wcmlhdGVseVxyXG5cdHZhciBzdGFydEVudHJ5ID0ge1xyXG5cdFx0c2VxdWVuY2U6IHNlcXVlbmNlLmlkLFxyXG5cdFx0YWN0aW9uOiBcInN0YXJ0XCJcclxuXHR9O1xyXG5cdGhpc3RvcnkubG9nLmFkZChzdGFydEVudHJ5KTtcclxuXHJcblx0Ly9IaXN0b3J5IG9iamVjdCB0byBnaXZlIHRvIHNlcXVlbmNlZCBwbGF5YWJsZXMuXHJcblx0dmFyIHNlcXVlbmNlSGlzdG9yeSA9IGhpc3RvcnkuY2hpbGQoKTtcclxuXHJcblx0Ly9jb21wYXJ0bWVudGFsaXplIGlmIHNldC4gXCJjb21wYXJ0bWVudGFsaXplXCIgbWVhbnMgcGFzcyBvbiBpbmZvcm1hdGlvbiBhcyBpZiB0aGlzIHBsYXlhYmxlIGlzIHRoZSBlbnRpcmUgZ2FtZS5cclxuXHRpZiAoc2VxdWVuY2UuY29tcGFydG1lbnRhbGl6ZSkge1xyXG5cdFx0aW5mb3JtYXRpb24gPSBuZXcgSW5mb3JtYXRpb24oc2VxdWVuY2UuY29tcGFydG1lbnRhbGl6ZS5oaXN0b3J5IHx8IHNlcXVlbmNlSGlzdG9yeSxcclxuXHRcdFx0c2VxdWVuY2UuY29tcGFydG1lbnRhbGl6ZS5wb3B1bGF0aW9uIHx8IGluZm9ybWF0aW9uLnBvcHVsYXRpb24pO1xyXG5cdH1cclxuXHJcblx0Ly8gUmVjdXJzaW9uIGRvd24gdGhlIGNoYWluIG9mIHBsYXlhYmxlc1xyXG5cdHZhciBhY3Rpb24gPSBmdW5jdGlvbiBhY3Rpb24ocmVzdWx0KSB7XHJcblx0XHQvL1N0b3AgaWYgdGhlIGdhbWUgaXMgb3Zlci5cclxuXHRcdGlmIChoaXN0b3J5LnN0b3ApIHJldHVybiB7IHBsYXlhYmxlOiBzZXF1ZW5jZSB9O1xyXG5cclxuXHRcdC8vT3RoZXJ3aXNlLCByZWN1cnNlIHRvIGZpZ3VyZSBvdXQgd2hhdCB0byBkbyBuZXh0LlxyXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xyXG5cdFx0XHRsb2coXCJzaWxseVwiLCBcInNlcXVlbmNlLnBsYXk6IE5leHQtaXRlbSBpcyBhbiBhcnJheSwgc3BsaXR0aW5nIGludG8gcGllY2VzLlwiKTtcclxuXHJcblx0XHRcdHJldHVybiBQcm9taXNlLmFsbChcclxuXHRcdFx0XHRyZXN1bHQubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdFx0XHRcdGxvZyhcInNpbGx5XCIsIFwic2VxdWVuY2UucGxheTogcmVjdXJzaW5nIG9uXCIsIGl0ZW0pO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGFjdGlvbihpdGVtKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChyZXN1bHQucGxheWFibGUgIT09IHNlcXVlbmNlLnBsYXlhYmxlRmluaXNoKSB7XHJcblx0XHRcdGxvZyhcInNpbGx5XCIsIHJlc3VsdCk7XHJcblxyXG5cdFx0XHRpZiAocmVzdWx0LnBsYXlhYmxlLmZpbmROZXh0KHsgcmVzdWx0IH0pLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRsb2coXCJzaWxseVwiLCBcIlBsYXlhYmxlIGhhcyBuZXh0LWl0ZW0sIGNvbnRpbnVpbmcgZG93biBjaGFpbi5cIik7XHJcblxyXG5cdFx0XHRcdHJldHVybiByZXN1bHQucGxheWFibGUucGxheU5leHQocmVzdWx0LCB7IHNob3J0Q2lyY3VpdDogdHJ1ZSwgaGlzdG9yeTogc2VxdWVuY2VIaXN0b3J5LCBpbmZvcm1hdGlvbiB9KVxyXG5cdFx0XHRcdFx0LnRoZW4oYWN0aW9uKTsgLy9SZXBlYXQgZm9yIG5leHQgcGxheWFibGUgaW4gY2hhaW5cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIHNlcXVlbmNlLnBsYXlhYmxlU3RhcnRcclxuXHRcdC5wbGF5KHsgc2hvcnRDaXJjdWl0OiB0cnVlLCBoaXN0b3J5OiBzZXF1ZW5jZUhpc3RvcnksIGluZm9ybWF0aW9uIH0pXHJcblx0XHQudGhlbihhY3Rpb24pXHJcblx0XHQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0cmVzdWx0Lmhpc3RvcnlFbnRyeSA9IHtcclxuXHRcdFx0XHRzZXF1ZW5jZTogc2VxdWVuY2UuaWQsXHJcblx0XHRcdFx0YWN0aW9uOiBzZXF1ZW5jZUhpc3Rvcnkub3JwaGFuKClcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdC8vVE9ETzogYWRkIGluZm9ybWF0aW9uIG1lY2hhbmlzbXNcclxuXHJcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHRcdH0pO1xyXG59O1xyXG5cclxuLy9PdmVyd3JpdGUgaGlzdG9yeSBoYW5kbGVyIHNvIHRoYXQgdHJlZSBkb2Vzbid0IGhhdmUgXCJzdGFydFwiIGFuZCBcImZpbmlzaFwiIGVudHJpZXMuXHJcbl9TZXF1ZW5jZS5wcm90b3R5cGUuaGFuZGxlSGlzdG9yeSA9IGZ1bmN0aW9uKHsgaGlzdG9yeSA9IGdhbWVIaXN0b3J5IH0gPSB7fSxcclxuXHRyZXN1bHRcclxuKSB7XHJcblx0dmFyIHNlcXVlbmNlID0gdGhpcztcclxuXHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRoaXN0b3J5LmxvZy5hZGQoe1xyXG5cdFx0XHRzZXF1ZW5jZTogc2VxdWVuY2UuaWQsXHJcblx0XHRcdGFjdGlvbjogXCJmaW5pc2hcIixcclxuXHRcdFx0ZHVyYXRpb246IHJlc3VsdC5oaXN0b3J5RW50cnkuZHVyYXRpb25cclxuXHRcdH0pO1xyXG5cclxuXHRcdGhpc3RvcnkuYWRkTm9Mb2cocmVzdWx0Lmhpc3RvcnlFbnRyeSk7XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcblx0fSk7XHJcbn07XHJcblxyXG4vL1RPRE86IGZpbmlzaCB0aGlzIVxyXG5fU2VxdWVuY2UucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSwgZW50cmllcywgc2hvcnRDaXJjdWl0KSB7XHJcblx0c3VtbWFyeS5hY3Rpb24gPSB7fTtcclxuXHJcblx0dGhpcy5wbGF5YWJsZVN0YXJ0LnN1bW1hcml6ZShcclxuXHRcdHN1bW1hcnkuYWN0aW9uLFxyXG5cdFx0ZW50cmllcyxcclxuXHRcdChzaG9ydENpcmN1aXQgPSB0aGlzLnBsYXlhYmxlRmluaXNoKVxyXG5cdCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBTZXF1ZW5jZShwbGF5YWJsZVN0YXJ0LCBwbGF5YWJsZUZpbmlzaCwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKHBhcmFtZXRlcnMuaWQsIFwic2VxdWVuY2VcIik7XHJcblxyXG5cdC8vQ3JlYXRlIGJhY2tlbmQgbG9vcCBvYmplY3RcclxuXHR2YXIgX3NlcXVlbmNlID0gbmV3IF9TZXF1ZW5jZShpZCwgcGxheWFibGVTdGFydCwgcGxheWFibGVGaW5pc2gsIHBhcmFtZXRlcnMpO1xyXG5cclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIHNlcXVlbmNlID0gUGxheWFibGUoX3NlcXVlbmNlKTtcclxuXHRyZXR1cm4gc2VxdWVuY2U7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBfU2VxdWVuY2UsIFNlcXVlbmNlIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlzT2JqZWN0IH0gPSByZXF1aXJlKCcuLi9oZWxwZXItZnVuY3Rpb25zJykoXCJnZW5lcmFsXCIpO1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoJy4uL2hlbHBlci1mdW5jdGlvbnMnKShcInN0YXRlXCIpO1xyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKCcuLi9zdGF0ZScpO1xyXG52YXIgUHJvbWlzZSA9IHJlZ2lzdHJ5LlByb21pc2U7IC8vIEZvciBzeW5jIG1vZGVcclxuXHJcbi8vUGFyZW50IGNsYXNzXHJcbnZhciB7IF9QbGF5YWJsZSwgUGxheWFibGUgfSA9IHJlcXVpcmUoJy4vcGxheWFibGUnKTtcclxuXHJcbi8vIEluZm9ybWF0aW9uIG1lY2hhbmljc1xyXG52YXIgeyBJbmZvcm1hdGlvbiwgUGVyZmVjdEluZm9ybWF0aW9uIH0gPSByZXF1aXJlKCcuLi9pbmZvcm1hdGlvbicpO1xyXG5cclxuXHJcbi8vQmFja2VuZCBjbGFzc1xyXG5mdW5jdGlvbiBfU2ltdWx0YW5lb3VzKGlkLCBwbGF5YWJsZUFycmF5LCB7IHBsYXlhYmxlUGFyYW1ldGVycyA9IHt9IH0gPSB7fSkge1xyXG5cdF9QbGF5YWJsZS5jYWxsKHRoaXMsIGlkKTtcclxuXHJcblx0dGhpcy5wbGF5YWJsZUFycmF5ID0gcGxheWFibGVBcnJheTtcclxuXHR0aGlzLnBsYXlhYmxlUGFyYW1ldGVycyA9IHBsYXlhYmxlUGFyYW1ldGVycztcclxufVxyXG5cclxuX1NpbXVsdGFuZW91cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9QbGF5YWJsZS5wcm90b3R5cGUpO1xyXG5fU2ltdWx0YW5lb3VzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9TaW11bHRhbmVvdXM7XHJcblxyXG5fU2ltdWx0YW5lb3VzLnJlZ2lzdHJ5TmFtZSA9IFwiY29udHJvbGxlcnNcIjtcclxuX1NpbXVsdGFuZW91cy5jb3VudGVyTmFtZSA9IFwic2ltdWx0YW5lb3VzXCI7XHJcblxyXG5cclxuLy9TaW11bHRhbmVvdXMgUHJvbWlzZS5hbGwncyB0aGUgcGxheWFibGVzLCB3aGljaCBjYXVzZXMgdGhlbSB0byBydW4gbWVzaGVkLlxyXG5fU2ltdWx0YW5lb3VzLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oeyBoaXN0b3J5ID0gZ2FtZUhpc3RvcnksIGluZm9ybWF0aW9uID0gUGVyZmVjdEluZm9ybWF0aW9uIH0gPSB7fSkge1xyXG5cclxuXHR2YXIgc2ltdWx0YW5lb3VzID0gdGhpcztcclxuXHJcblx0Ly8gRGVhbCB3aXRoIGhpc3RvcnkuIExvZyBzdGFydCwgdGhlbiBzcGxpdCBoaXN0b3J5IGZvciBjaGlsZHJlbiBwbGF5YWJsZXMgdG8gZmlsbCBpbi5cclxuXHRoaXN0b3J5LmxvZy5hZGQoe1xyXG5cdFx0c2ltdWx0YW5lb3VzOiBzaW11bHRhbmVvdXMuaWQsXHJcblx0XHRhY3Rpb246IFwiU2ltdWx0YW5lb3VzIHN0YXJ0LlwiXHJcblx0fSk7XHJcblx0dmFyIHNpbXVsdGFuZW91c0hpc3RvcnkgPSBbXVxyXG5cclxuXHJcblxyXG5cdC8vVE9ETzogaXMgaW5mb3JtYXRpb24gbWVjaGFuaWNzIGNvcnJlY3Q/XHJcblxyXG5cdHJldHVybiBQcm9taXNlLmFsbChzaW11bHRhbmVvdXMucGxheWFibGVBcnJheS5tYXAoZnVuY3Rpb24ocGxheWFibGUpIHtcclxuXHJcblx0XHR2YXIgYnJhbmNoSGlzdG9yeSA9IGhpc3RvcnkuY2hpbGQoKTtcclxuXHRcdHNpbXVsdGFuZW91c0hpc3RvcnkucHVzaChicmFuY2hIaXN0b3J5KVxyXG5cclxuXHRcdC8vIEluZm9ybWF0aW9uIG1lY2hhbmljc1xyXG5cdFx0dmFyIGluZm9Qb3B1bGF0aW9uLCBwYXJlbnRIaXN0b3J5LCBpbmZvSGlzdG9yeSA9IGJyYW5jaEhpc3Rvcnk7XHJcblx0XHQvL2NvbXBhcnRtZW50YWxpemUgaWYgc2V0LiBcImNvbXBhcnRtZW50YWxpemVcIiBtZWFucyBwYXNzIG9uIGluZm9ybWF0aW9uIGFzIGlmIHRoaXMgcGxheWFibGUgaXMgdGhlIGVudGlyZSBnYW1lLlxyXG5cdFx0aWYgKHNpbXVsdGFuZW91cy5jb21wYXJ0bWVudGFsaXplKSB7XHJcblx0XHRcdGluZm9Qb3B1bGF0aW9uID0gc2ltdWx0YW5lb3VzLmNvbXBhcnRtZW50YWxpemUucG9wdWxhdGlvbiB8fCBpbmZvcm1hdGlvbi5wb3B1bGF0aW9uO1xyXG5cdFx0XHRwYXJlbnRIaXN0b3J5ID0gc2ltdWx0YW5lb3VzLmNvbXBhcnRtZW50YWxpemUuaGlzdG9yeSB8fCBpbmZvcm1hdGlvbi5oaXN0b3J5O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW5mb1BvcHVsYXRpb24gPSBpbmZvcm1hdGlvbi5wb3B1bGF0aW9uO1xyXG5cdFx0XHRwYXJlbnRIaXN0b3J5ID0gaW5mb3JtYXRpb24uaGlzdG9yeVxyXG5cdFx0fVxyXG5cdFx0dmFyIHNpbXVsdGFuZW91c0luZm9ybWF0aW9uID0gbmV3IEluZm9ybWF0aW9uKGluZm9IaXN0b3J5LCBpbmZvUG9wdWxhdGlvbiwgeyBwYXJlbnRIaXN0b3J5IH0pO1xyXG5cclxuXHJcblxyXG5cdFx0cmV0dXJuIHBsYXlhYmxlLnBsYXkoeyBoaXN0b3J5OiBicmFuY2hIaXN0b3J5LCBpbmZvcm1hdGlvbjogc2ltdWx0YW5lb3VzSW5mb3JtYXRpb24gfSk7XHJcblx0fSkpLnRoZW4oZnVuY3Rpb24ocmVzdWx0QXJyYXkpIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0T2JqZWN0ID0ge1xyXG5cdFx0XHRyZXN1bHRBcnJheSxcclxuXHRcdFx0cGxheWFibGU6IHNpbXVsdGFuZW91cyxcclxuXHRcdFx0aGlzdG9yeUVudHJ5OiB7XHJcblx0XHRcdFx0c2ltdWx0YW5lb3VzOiBzaW11bHRhbmVvdXMuaWQsXHJcblx0XHRcdFx0YWN0aW9uOiBzaW11bHRhbmVvdXNIaXN0b3J5Lm1hcChmdW5jdGlvbihoaXN0b3J5KSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gaGlzdG9yeS5vcnBoYW4oKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdFx0cmV0dXJuIHJlc3VsdE9iamVjdDtcclxuXHR9KTtcclxufTtcclxuXHJcblxyXG5fU2ltdWx0YW5lb3VzLnByb3RvdHlwZS5oYW5kbGVIaXN0b3J5ID0gZnVuY3Rpb24oeyBoaXN0b3J5ID0gZ2FtZUhpc3RvcnkgfSA9IHt9LCByZXN1bHQpIHtcclxuXHJcblx0aGlzdG9yeS5sb2cuYWRkKHtcclxuXHRcdHNpbXVsdGFuZW91czogdGhpcy5pZCxcclxuXHRcdGFjdGlvbjogXCJTaW11bHRhbmVvdXMgY29tcGxldGUuXCJcclxuXHR9KTtcclxuXHJcblx0aGlzdG9yeS5hZGROb0xvZyhyZXN1bHQuaGlzdG9yeUVudHJ5KTtcclxuXHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG59O1xyXG5cclxuX1NpbXVsdGFuZW91cy5wcm90b3R5cGUuc3VtbWFyeVRoaXMgPSBmdW5jdGlvbihzdW1tYXJ5LCBlbnRyaWVzKSB7XHJcblx0c3VtbWFyeS5hY3Rpb24gPSBbXTtcclxuXHJcblx0dGhpcy5wbGF5YWJsZUFycmF5LmZvckVhY2goZnVuY3Rpb24ocGxheWFibGUsIGluZGV4KSB7XHJcblx0XHRzdW1tYXJ5LmFjdGlvbltpbmRleF0gPSB7fVxyXG5cdFx0cGxheWFibGUuc3VtbWFyaXplKHN1bW1hcnkuYWN0aW9uW2luZGV4XSwgZW50cmllcyk7XHJcblx0fSk7XHJcbn1cclxuXHJcblxyXG4vL0Zyb250ZW5kIGNsYXNzXHJcbmZ1bmN0aW9uIFNpbXVsdGFuZW91cyhwbGF5YWJsZUFycmF5LCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHR2YXIgaWQgPSBpZEhhbmRsZXIocGFyYW1ldGVycy5pZCwgXCJzaW11bHRhbmVvdXNcIilcclxuXHJcblx0cGxheWFibGVBcnJheSA9IHBsYXlhYmxlQXJyYXkubWFwKGZ1bmN0aW9uKHBsYXlhYmxlKSB7XHJcblx0XHRyZXR1cm4gcmVnaXN0cnkucGxheWFibGVzW3BsYXlhYmxlLmlkKCldO1xyXG5cdH0pO1xyXG5cclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBpbnN0YW5jZS5cclxuXHR2YXIgX3NpbXVsdGFuZW91cyA9IG5ldyBfU2ltdWx0YW5lb3VzKGlkLCBwbGF5YWJsZUFycmF5LCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0Ly9SZXR1cm4gdGhpcyByZWZlcmVuY2Ugb2JqZWN0IHRvIHRoZSB1c2VyLiBSdW4gdGhlIGZ1bmN0aW9uIHRvIHNlbGVjdCBhIHNvdXJjZVxyXG5cdHZhciBzaW11bHRhbmVvdXMgPSBQbGF5YWJsZShfc2ltdWx0YW5lb3VzKTtcclxuXHRyZXR1cm4gc2ltdWx0YW5lb3VzO1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IF9TaW11bHRhbmVvdXMsIFNpbXVsdGFuZW91cyB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBTdG9jaGFzdGljLUhhbHRcIilcclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSwgZ2FtZUhpc3RvcnkgfSA9IHJlcXVpcmUoJy4uL3N0YXRlJyk7XHJcbnZhciBQcm9taXNlID0gcmVnaXN0cnkuUHJvbWlzZTsgLy8gRm9yIHN5bmMgbW9kZVxyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlzRnVuY3Rpb24gfSA9IHJlcXVpcmUoJy4uL2hlbHBlci1mdW5jdGlvbnMnKShcImdlbmVyYWxcIik7XHJcbnZhciB7IGlkSGFuZGxlciB9ID0gcmVxdWlyZSgnLi4vaGVscGVyLWZ1bmN0aW9ucycpKFwic3RhdGVcIik7XHJcblxyXG4vL1BhcmVudCBjbGFzc1xyXG52YXIgeyBfUGxheWFibGUsIFBsYXlhYmxlIH0gPSByZXF1aXJlKCcuL3BsYXlhYmxlJyk7XHJcbnZhciB7IF9IYWx0LCBIYWx0IH0gPSByZXF1aXJlKCcuL2hhbHQtaWYnKTtcclxuXHJcblxyXG4vL0JhY2tlbmQgZnVuY3Rpb24gY2xhc3MgZm9yIFNIYWx0XHJcbmZ1bmN0aW9uIF9TSGFsdChpZCwgcHJvYmFiaWxpdHksIHBhcmFtZXRlcnMpIHtcclxuXHRfSGFsdC5jYWxsKHRoaXMsIGlkLCBudWxsLCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0dmFyIHNIYWx0ID0gdGhpcztcclxuXHJcblx0dGhpcy5wcm9iYWJpbGl0eSA9IHByb2JhYmlsaXR5O1xyXG5cdHRoaXMuZ2VuZXJhdG9yID0gTWF0aC5yYW5kb207IC8vVE9ETzogYWxsb3cgdXNlciB0byBzcGVjaWZ5IHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXHJcblxyXG5cdHRoaXMudGVzdENvbmRpdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYgKHNIYWx0LmdlbmVyYXRvcigpIDwgc0hhbHQucHJvYmFiaWxpdHkpIHJldHVybiB0cnVlO1xyXG5cdH07XHJcbn1cclxuX1NIYWx0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX0hhbHQucHJvdG90eXBlKTtcclxuX1NIYWx0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF9TSGFsdDtcclxuXHJcbl9TSGFsdC5yZWdpc3RyeU5hbWUgPSBcInNIYWx0c1wiO1xyXG5fU0hhbHQuY291bnRlck5hbWUgPSBcInN0b2NoYXN0aWNIYWx0XCI7XHJcblxyXG4vKlxyXG5fU0hhbHQucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7aW5pdGlhbGl6ZVBsYXllcnM9ZmFsc2UsIHNob3J0Q2lyY3VpdD1mYWxzZX09e30pe1xyXG5cclxuXHR2YXIgc0hhbHQgPSB0aGlzO1xyXG5cdHZhciB0ZXN0ID0gc0hhbHQudGVzdENvbmRpdGlvbigpO1xyXG5cclxuXHRpZiAodGVzdCkge1xyXG5cdFx0bG9nKFwiaW5mb1wiLCBcIkhhbHRpbmcgYXQgXCIgKyBzSGFsdC5pZClcclxuXHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3Qoe1xyXG5cdFx0XHRyZXN1bHQ6XCJIYWx0XCIsXHJcblx0XHRcdHBsYXlhYmxlOnNIYWx0XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHZhciByZXN1bHRPYmplY3QgPSB7XHJcblx0XHQncmVzdWx0JzpcIkNvbnRpbnVlZFwiLFxyXG5cdFx0J3BsYXlhYmxlJzpzSGFsdFxyXG5cdH07XHJcblxyXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0T2JqZWN0KVxyXG5cdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XHJcblxyXG5cdFx0Ly9UT0RPOiBhZGQgaW5mb3JtYXRpb24gbWVjaGFuaXNtc1xyXG5cclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KVxyXG5cdH0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcclxuXHJcblx0XHRyZXR1cm4gc0hhbHQucHJvY2VlZChyZXN1bHQsIHNob3J0Q2lyY3VpdCk7XHJcblx0fSk7XHJcbn07XHJcbiovXHJcblxyXG5fU0hhbHQucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSwgZW50cmllcykge1xyXG5cdHN1bW1hcnkucHJvYmFiaWxpdHkgPSB0aGlzLnByb2JhYmlsaXR5O1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gU3RvY2hhc3RpY0hhbHQocHJvYmFiaWxpdHksIHsgaWQgPSBudWxsLCBsb2dDb250aW51ZSA9IGZhbHNlIH0gPSB7fSkge1xyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihpZCwgXCJzdG9jaGFzdGljSGFsdFwiKVxyXG5cclxuXHRpZiAoaXNOYU4ocHJvYmFiaWxpdHkpIHx8IHByb2JhYmlsaXR5IDwgMCB8fCBwcm9iYWJpbGl0eSA+IDEpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcm9iYWJpbGl0eScpO1xyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIHNIYWx0IG9iamVjdHNcclxuXHR2YXIgX3NIYWx0ID0gbmV3IF9TSGFsdChpZCwgcHJvYmFiaWxpdHksIHsgbG9nQ29udGludWUgfSk7XHJcblxyXG5cclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIHNIYWx0ID0gUGxheWFibGUoX3NIYWx0KTtcclxuXHRyZXR1cm4gc0hhbHQ7XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgX1NIYWx0LCBTdG9jaGFzdGljSGFsdCB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcclxubG9nKFwiZGVidWdcIiwgXCJMb2FkaW5nIENsYXNzOiBTdG9jaGFzdGljTG9vcFwiKVxyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5LCBnYW1lSGlzdG9yeSB9ID0gcmVxdWlyZSgnLi4vc3RhdGUnKTtcclxudmFyIFByb21pc2UgPSByZWdpc3RyeS5Qcm9taXNlOyAvLyBGb3Igc3luYyBtb2RlXHJcblxyXG4vL0hlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgaWRIYW5kbGVyIH0gPSByZXF1aXJlKCcuLi9oZWxwZXItZnVuY3Rpb25zJykoXCJzdGF0ZVwiKTtcclxudmFyIHsgY2hhaW5lckdlbmVyYXRvciB9ID0gcmVxdWlyZSgnLi4vaGVscGVyLWZ1bmN0aW9ucycpKFwicGxheWFibGVcIik7XHJcblxyXG4vL1BhcmVudCBjbGFzc2VzXHJcbnZhciB7IF9QbGF5YWJsZSwgUGxheWFibGUgfSA9IHJlcXVpcmUoJy4vcGxheWFibGUnKTtcclxudmFyIHsgX0xvb3AsIExvb3AgfSA9IHJlcXVpcmUoJy4vbG9vcCcpO1xyXG5cclxuXHJcbi8vQmFja2VuZCBmdW5jdGlvbiBjbGFzcyBmb3IgU3RvY2hhc3RpY0xvb3BcclxuZnVuY3Rpb24gX1NMb29wKGlkLCBwbGF5YWJsZSwgcHJvYmFiaWxpdHksIHBhcmFtZXRlcnMpIHtcclxuXHRfTG9vcC5jYWxsKHRoaXMsIGlkLCBwbGF5YWJsZSwgbnVsbCwgcGFyYW1ldGVycyk7XHJcblxyXG5cdHRoaXMucGxheWFibGUgPSByZWdpc3RyeS5wbGF5YWJsZXNbcGxheWFibGUuaWQoKV07XHJcblxyXG5cdC8vVGhpcyBpbmhlcml0cyBmcm9tIExvb3Agd2hpY2ggdXNlcyBhIGNvdW50LiBEZWxldGUgdGhhdCBhbmQgcmVwbGFjZSB3aXRoIHByb2JhYmlsaXR5LlxyXG5cdGRlbGV0ZSB0aGlzLmNvdW50O1xyXG5cdHRoaXMucHJvYmFiaWxpdHkgPSBwcm9iYWJpbGl0eTtcclxuXHJcblx0dGhpcy5nZW5lcmF0b3IgPSBNYXRoLnJhbmRvbTsgLy9UT0RPOiBhbGxvdyB1c2VyIHRvIHNwZWNpZnkgcmFuZG9tIG51bWJlciBnZW5lcmF0b3JcclxufVxyXG5fU0xvb3AucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfTG9vcC5wcm90b3R5cGUpO1xyXG5fU0xvb3AucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gX1NMb29wO1xyXG5cclxuX1NMb29wLnJlZ2lzdHJ5TmFtZSA9IFwic0xvb3BzXCI7XHJcbl9TTG9vcC5jb3VudGVyTmFtZSA9IFwic3RvY2hhc3RpY0xvb3BcIjtcclxuXHJcblxyXG5fU0xvb3AucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih7XHJcblx0aW5pdGlhbGl6ZVBsYXllcnMgPSBmYWxzZSxcclxuXHRzaG9ydENpcmN1aXQgPSBmYWxzZSxcclxuXHRoaXN0b3J5ID0gZ2FtZUhpc3RvcnksXHJcblx0aW5mb3JtYXRpb246IFBlcmZlY3RJbmZvcm1hdGlvblxyXG59ID0ge30pIHtcclxuXHJcblx0dmFyIHNMb29wID0gdGhpcztcclxuXHRzTG9vcC5jb3VudGVyID0gMDtcclxuXHR2YXIgbG9vcEhpc3RvcnkgPSBoaXN0b3J5LmNoaWxkKCk7XHJcblxyXG5cdGlmIChzTG9vcC5jb21wYXJ0bWVudGFsaXplKSB7XHJcblx0XHRpbmZvcm1hdGlvbiA9IG5ldyBJbmZvcm1hdGlvbihzTG9vcC5jb21wYXJ0bWVudGFsaXplLmhpc3RvcnkgfHwgbG9vcEhpc3RvcnksXHJcblx0XHRcdHNMb29wLmNvbXBhcnRtZW50YWxpemUucG9wdWxhdGlvbiB8fCBpbmZvcm1hdGlvbi5wb3B1bGF0aW9uKTtcclxuXHR9XHJcblxyXG5cclxuXHR2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh7fSk7XHJcblxyXG5cdC8vU2VjdGlvbiB0aGF0IHdpbGwgYmUgbG9vcGVkXHJcblx0dmFyIGFjdGlvbiA9IGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cclxuXHRcdHNMb29wLmNvdW50ZXIrKztcclxuXHRcdGlmICghcmVzdWx0KSByZXN1bHQgPSB7fTtcclxuXHJcblxyXG5cdFx0Ly9EZWFsIHdpdGggaGlzdG9yeVxyXG5cdFx0aGlzdG9yeS5sb2cuYWRkKHtcclxuXHRcdFx0bG9vcDogc0xvb3AuaWQsXHJcblx0XHRcdGxvb3BUbzogc0xvb3AucGxheWFibGUuaWQsXHJcblx0XHRcdGNvdW50OiBzTG9vcC5jb3VudGVyXHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gc0xvb3AucGxheWFibGUucGxheSh7IHNob3J0Q2lyY3VpdDogdHJ1ZSwgaGlzdG9yeTogbG9vcEhpc3RvcnksIGluZm9ybWF0aW9uIH0pXHJcblx0XHRcdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cclxuXHRcdFx0XHRyZXN1bHQucGxheWFibGUgPSBzTG9vcDtcclxuXHRcdFx0XHQvL1RPRE86IGFkZCBpbmZvcm1hdGlvbiBtZWNoYW5pc21zXHJcblxyXG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KVxyXG5cdFx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHJcblx0Ly9HZW5lcmF0ZSByYW5kb20gbnVtYmVycywgcmVwZWF0IHdoaWxlIG51bWJlciBpcyBhYm92ZSBoYWx0aW5nIHByb2JhYmlsaXR5XHJcblx0d2hpbGUgKHNMb29wLmdlbmVyYXRvcigpID4gc0xvb3AucHJvYmFiaWxpdHkpIHtcclxuXHRcdHByb21pc2UgPSBwcm9taXNlLnRoZW4oYWN0aW9uKTtcclxuXHR9XHJcblxyXG5cclxuXHRyZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cclxuXHRcdHJlc3VsdC5oaXN0b3J5RW50cnkgPSB7XHJcblx0XHRcdGxvb3A6IHNMb29wLmlkLFxyXG5cdFx0XHRjb3VudDogc0xvb3AuY291bnRlcixcclxuXHRcdFx0YWN0aW9uOiBsb29wSGlzdG9yeS5vcnBoYW4oKVxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcblx0fSk7XHJcbn07XHJcblxyXG5fU0xvb3AucHJvdG90eXBlLnN1bW1hcnlUaGlzID0gZnVuY3Rpb24oc3VtbWFyeSwgZW50cmllcykge1xyXG5cdHN1bW1hcnkucHJvYmFiaWxpdHkgPSB0aGlzLnByb2JhYmlsaXR5O1xyXG5cclxuXHRzdW1tYXJ5LmFjdGlvbiA9IHt9XHJcblx0dGhpcy5wbGF5YWJsZS5zdW1tYXJpemUoc3VtbWFyeS5hY3Rpb24sIGVudHJpZXMsIHRydWUpXHJcbn1cclxuXHJcblxyXG4vL1VzZXIgaW50ZXJmYWNlXHJcbmZ1bmN0aW9uIFN0b2NoYXN0aWNMb29wKHBsYXlhYmxlLCBwcm9iYWJpbGl0eSA9IC41LCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHR2YXIgaWQgPSBpZEhhbmRsZXIocGFyYW1ldGVycy5pZCwgXCJzdG9jaGFzdGljTG9vcFwiKVxyXG5cclxuXHRpZiAoaXNOYU4ocHJvYmFiaWxpdHkpIHx8IHByb2JhYmlsaXR5IDwgMCB8fCBwcm9iYWJpbGl0eSA+IDEpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcm9iYWJpbGl0eScpO1xyXG5cclxuXHQvL0NyZWF0ZSBiYWNrZW5kIHNMb29wIG9iamVjdFxyXG5cdHZhciBfc0xvb3AgPSBuZXcgX1NMb29wKGlkLCBwbGF5YWJsZSwgcHJvYmFiaWxpdHksIHBhcmFtZXRlcnMpO1xyXG5cclxuXHJcblx0Ly9SZXR1cm4gdGhpcyByZWZlcmVuY2Ugb2JqZWN0IHRvIHRoZSB1c2VyLiBSdW4gdGhlIGZ1bmN0aW9uIHRvIHNlbGVjdCBhIHNvdXJjZVxyXG5cdHZhciBzTG9vcCA9IFBsYXlhYmxlKF9zTG9vcCk7XHJcblx0cmV0dXJuIHNMb29wO1xyXG59XHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0geyBfU0xvb3AsIFN0b2NoYXN0aWNMb29wIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XHJcbmxvZyhcImRlYnVnXCIsIFwiTG9hZGluZyBDbGFzczogVHVyblwiKTtcclxuXHJcbi8vRXh0ZXJuYWwgZGVwZW5kZW5jeVxyXG52YXIgeyBTeW5jaHJvbm91c1Byb21pc2UgfSA9IHJlcXVpcmUoXCJzeW5jaHJvbm91cy1wcm9taXNlXCIpO1xyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlzT2JqZWN0LCBvbmNlIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyLWZ1bmN0aW9uc1wiKShcImdlbmVyYWxcIik7XHJcbnZhciB7IGNoYWluZXJHZW5lcmF0b3IsIG91dGNvbWVUcmVlR2V0VmFsdWUsIG91dGNvbWVUcmVlU2V0VmFsdWUgfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXItZnVuY3Rpb25zXCIpKFxyXG5cdFwicGxheWFibGVcIik7XHJcbnZhciB7IHJlY3Vyc2UgfSA9IHJlcXVpcmUoXCIuLi9oZWxwZXItZnVuY3Rpb25zXCIpKFwidHVyblwiKTtcclxudmFyIHsgaWRIYW5kbGVyIH0gPSByZXF1aXJlKFwiLi4vaGVscGVyLWZ1bmN0aW9uc1wiKShcInN0YXRlXCIpO1xyXG5cclxuLy9HYW1lIHN0YXRlIGNvbnRyb2xsZXJzXHJcbnZhciB7IHJlZ2lzdHJ5IH0gPSByZXF1aXJlKFwiLi4vc3RhdGVcIik7XHJcbnZhciBQcm9taXNlID0gcmVnaXN0cnkuUHJvbWlzZTsgLy8gRm9yIHN5bmMgbW9kZVxyXG52YXIgeyBnYW1lSGlzdG9yeSB9ID0gcmVxdWlyZShcIi4uL2hpc3RvcnlcIik7XHJcbnZhciB7IEluZm9ybWF0aW9uLCBQZXJmZWN0SW5mb3JtYXRpb24gfSA9IHJlcXVpcmUoXCIuLi9pbmZvcm1hdGlvblwiKTtcclxuXHJcbi8vUGFyZW50IGNsYXNzZXNcclxudmFyIHsgQnJhbmNoLCBfUGxheWFibGUsIFBsYXlhYmxlIH0gPSByZXF1aXJlKFwiLi9wbGF5YWJsZVwiKTtcclxudmFyIHsgRXZhbHVhdG9yIH0gPSByZXF1aXJlKFwiLi9yYW5nZVwiKVxyXG5cclxuXHJcbi8vIFR1cm4gaGFzIHRoZSBtb3N0IGNvbXBsZXggYnJhbmNoaW5nIG9mIGFueSBQbGF5YWJsZSwgYmVjYXVzZSBpdHMgc3ViLXBsYXlhYmxlcyBjYW4gYmVcclxuLy8gZWl0aGVyIENob2ljZSBvciBSYW5nZS4gSWYgdGhleSBhcmUgYWxsIENob2ljZXMsIGl0IHVzZXMgYnJhbmNoaW5nIGxpa2UgQ2hvaWNlIGRvZXMuXHJcbi8vIFRoZXJlIGlzIGFuIG91dGNvbWVUcmVlLCBhbiBvYmplY3Qgb2Ygb2JqZWN0cywgd2hlcmUgdGhlIHBhdGggdGhyb3VnaCB0aGVtLCAoZWcuIGxlZnQtPnJpZ2h0LT5kb3duKVxyXG4vLyBkZWZpbmVzIHRoZSByZXNwb25zZXMgb2YgdGhlIHBsYXllcnMgaW4gZWFjaCByZXNwZWN0aXZlIENob2ljZS4gTGlrZSBDaG9pY2VCcmFuY2gsIHRoaXMgdXNlcyB0aGVcclxuLy8gVHVybkJyYW5jaCBjbGFzcyB0byBnZW5lcmF0ZSBjaGFpbmluZyBvYmplY3RzIGFuZCBzZXQgcGF5b2Zmcy5cclxuLy9cclxuLy8gSG93ZXZlciwgaWYgYW55IG9mIHRoZSBzdWItcGxheWFibGVzIGFyZSBSYW5nZSwgdGhlbiBUdXJuIHVzZXMgYSBicmFuY2hpbmcgc3lzdGVtIG1vcmVcclxuLy8gbGlrZSB0aGF0IG9mIFJhbmdlLCBpZSBhbmFsb2dvdXMgdG8gUmFuZ2VPdXRjb21lLCB3ZSdsbCB1c2UgVHVybk91dGNvbWUuIFRoaXMgY3JlYXRlc1xyXG4vLyBicmFuY2hlcyBhbmQgcGF5b2ZmcyBpbiB0aGUgZm9ybSBvZiBhIE1hcCwgd2hlcmUgdGhlIGtleXMgaW4gdGhlIE1hcCBhcmUgRXZhbHVhdG9ycyxcclxuLy8gYW5kIHRoZSB2YWx1ZXMgYXJlIGZvciBicmFuY2hpbmcgYW4gYXJyYXkgb2YgbmV4dCBwbGF5YWJsZXMsIGFuZCBmb3IgcGF5b2ZmcyBhIHZhbHVlIGZvciB0aGVcclxuLy8gcGF5b3V0LiBUaGUgRXZhbHVhdG9yIHdpbGwgYmUgYSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhIFwicmVzdWx0XCIgYXJndW1lbnQsIHdoaWNoIGlzIGFuIGFycmF5IG9mIHRoZVxyXG4vLyByZXNwb25zZXMgZnJvbSBlYWNoIHBsYXllciwgYW5kIHNob3VsZCByZXR1cm4gdHJ1ZSBpZiB0aGUgb3V0Y29tZSBicmFuY2gvcGF5b2ZmIGlzIHN1cHBvc2VkIHRvIGJlXHJcbi8vIHRyaWdnZXJlZCBmb3IgdGhpcyByZXN1bHQuXHJcbi8vXHJcbi8vIFR1cm4gYWxzbyBhbGxvd3MgZm9yIGJvdGggaW1wbGljaXQgYW5kIGV4cGxpY2l0IHBheW9mZnMuIFRoZSBsYXR0ZXIgbmFtZXMgcGxheWVycyBieSBpZCwgaWUuXHJcbi8vIHAxIGdldHMgMiwgd2hpbGUgdGhlIGZvcm1lciByZWZlcnMgdG8gcGxheWVycyB3aG8gYXJlIHVzZWQgYnkgdGhlIHN1Yi1wbGF5YWJsZXMgKENob2ljZSBvciBSYW5nZSlcclxuLy8gdGhhdCBhcmUgYXNzaWduZWQgdG8gdGhlIFR1cm4uIEltcGxpY2l0IHBheW9mZnMgYWxsb3cgZm9yIGEgbW9yZSBkeW5hbWljIGdhbWUgKGllIHVzaW5nIFJhbmRvbVBsYXllckNob2ljZSxcclxuLy8gdGhlIHBsYXllciBjYW4gY2hhbmdlKSB3aGlsZSBleHBsaWNpdCBwYXlvZmZzIGFsbG93IHBsYXllcnMgd2hvIGFyZW4ndCBpbnZvbHZlZCBpbiB0aGUgZGVjaXNpb24gdG8gc3RpbGxcclxuLy8gcmVjZWl2ZSBhIHBheW91dCBvciBwZW5hbHR5LlxyXG4vL1xyXG4vLyBTb29vby4uLiBnb29kIGx1Y2suXHJcblxyXG5cclxuLy8gQnJhbmNoIHN1YmNsYXNzXHJcbnZhciBUdXJuQnJhbmNoID0gKGZ1bmN0aW9uKCkge1xyXG5cdC8vIFByaXZhdGUgZGF0YVxyXG5cdHZhciBfdHVybnMgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuXHRjbGFzcyBUdXJuQnJhbmNoIGV4dGVuZHMgQnJhbmNoIHtcclxuXHRcdGNvbnN0cnVjdG9yKHBhdGgsIF90dXJuKSB7XHJcblx0XHRcdHN1cGVyKHBhdGgsIF90dXJuLmludGVyZmFjZSlcclxuXHRcdFx0X3R1cm5zLnNldCh0aGlzLCBfdHVybilcclxuXHRcdH1cclxuXHJcblx0XHRwYXlvZmYocGF5b2Zmcykge1xyXG5cdFx0XHQvLyBQYXlvZmZzIG5lZWQgdG8gYmUgYXJyYXlcclxuXHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KHBheW9mZnMpKSB0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIHBheW9mZnMgYXJyYXkuXCIpXHJcblxyXG5cdFx0XHR2YXIgX3R1cm4gPSBfdHVybnMuZ2V0KHRoaXMpO1xyXG5cdFx0XHR2YXIgbnVtUGxheWVycyA9IF90dXJuLmRlY2lzaW9ucy5sZW5ndGhcclxuXHRcdFx0dmFyIHBhdGggPSB0aGlzLnBhdGhcclxuXHJcblx0XHRcdC8vQWxsb3cgdGhlIGZpcnN0IGZldyBhcnJheSBlbGVtZW50cyB0byBiZSBpbXBsaWNpdCBwYXlvZmZzLiBDaGVjayB0aGF0IHRoZXkgYXJlIGFjdHVhbGx5IHRoZXJlIGFuZCBhcmUgbnVtYmVycyBvciBudWxsXHJcblx0XHRcdHZhciBpbXBsaWNpdCA9IHBheW9mZnMuc2xpY2UoMCwgbnVtUGxheWVycyk7XHJcblx0XHRcdGlmIChpbXBsaWNpdC5sZW5ndGggPT0gbnVtUGxheWVycyAmJiBpbXBsaWNpdC5ldmVyeShmdW5jdGlvbihwYXlvZmYpIHtcclxuXHRcdFx0XHRcdHJldHVybiAoIWlzTmFOKHBheW9mZikgfHwgcGF5b2ZmID09IG51bGwpO1xyXG5cdFx0XHRcdH0pKSB7XHJcblx0XHRcdFx0b3V0Y29tZVRyZWVTZXRWYWx1ZShfdHVybi5wYXlvZmZzSW1wbGljaXQsIHBhdGgsIGltcGxpY2l0KTtcclxuXHRcdFx0fSBlbHNlIHRocm93IG5ldyBFcnJvcihcIlR1cm4gaW1wbGljaXQgcGF5b2ZmcyBtdXN0IGJlIGNvcnJlY3Qgc2l6ZSBhbmQgZWFjaCBtdXN0IGJlIGEgbnVtYmVyIG9yIG51bGwuXCIpXHJcblxyXG5cclxuXHRcdFx0Ly9BbnkgcmVtYWluaW5nIHNob3VsZCBiZSBhc3NpZ25lZCBhcyBleHBsaWNpdCBwYXlvZmZzLCBpZiB0aGV5J3JlIG9iamVjdHMuXHJcblx0XHRcdHBheW9mZnMuc2xpY2UobnVtUGxheWVycykuZm9yRWFjaChmdW5jdGlvbihleHBsaWNpdCkge1xyXG5cdFx0XHRcdGlmIChpc09iamVjdChleHBsaWNpdCkpXHJcblx0XHRcdFx0XHRvdXRjb21lVHJlZVNldFZhbHVlKF90dXJuLnBheW9mZnNFeHBsaWNpdCwgcGF0aCwgZXhwbGljaXQpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHJldHVybiBzdXBlci5wYXlvZmYoKTtcclxuXHRcdH1cclxuXHJcblx0fVxyXG5cdHJldHVybiBUdXJuQnJhbmNoO1xyXG59KSgpXHJcblxyXG5cclxuXHJcblxyXG4vLyBCcmFuY2ggc3ViY2xhc3NcclxudmFyIFR1cm5PdXRjb21lID0gKGZ1bmN0aW9uKCkge1xyXG5cdC8vIFByaXZhdGUgZGF0YVxyXG5cdHZhciBfdHVybnMgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuXHRjbGFzcyBUdXJuT3V0Y29tZSBleHRlbmRzIEJyYW5jaCB7XHJcblx0XHRjb25zdHJ1Y3RvcihldmFsdWF0b3IsIF90dXJuKSB7XHJcblx0XHRcdHN1cGVyKGV2YWx1YXRvciwgX3R1cm4pXHJcblx0XHRcdF90dXJucy5zZXQodGhpcywgX3R1cm4pXHJcblxyXG5cdFx0XHRfdHVybi5uZXh0LnNldChldmFsdWF0b3IsIFtdKSAvLyBhZGQgYmxhbmsgbmV4dG1hcCBvbmNlIHRoZSBicmFuY2ggaXMgZGVmaW5lZFxyXG5cdFx0fVxyXG5cclxuXHRcdHBheW9mZihwYXlvZmZzKSB7XHJcblx0XHRcdC8vIFBheW9mZnMgbmVlZCB0byBiZSBhcnJheVxyXG5cdFx0XHRpZiAoIUFycmF5LmlzQXJyYXkocGF5b2ZmcykpIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgcGF5b2ZmcyBhcnJheS5cIilcclxuXHJcblx0XHRcdHZhciBfdHVybiA9IF90dXJucy5nZXQodGhpcyk7XHJcblx0XHRcdHZhciBudW1QbGF5ZXJzID0gX3R1cm4uZGVjaXNpb25zLmxlbmd0aFxyXG5cdFx0XHR2YXIgcGF0aCA9IHRoaXMucGF0aFxyXG5cclxuXHRcdFx0Ly9BbGxvdyB0aGUgZmlyc3QgZmV3IGFycmF5IGVsZW1lbnRzIHRvIGJlIGltcGxpY2l0IHBheW9mZnMuIENoZWNrIHRoYXQgdGhleSBhcmUgYWN0dWFsbHkgdGhlcmUgYW5kIGFyZSBudW1iZXJzIG9yIG51bGxcclxuXHRcdFx0dmFyIGltcGxpY2l0ID0gcGF5b2Zmcy5zbGljZSgwLCBudW1QbGF5ZXJzKTtcclxuXHRcdFx0aWYgKGltcGxpY2l0Lmxlbmd0aCA9PSBudW1QbGF5ZXJzICYmIGltcGxpY2l0LmV2ZXJ5KGZ1bmN0aW9uKHBheW9mZikge1xyXG5cdFx0XHRcdFx0cmV0dXJuICghaXNOYU4ocGF5b2ZmKSB8fCBwYXlvZmYgPT0gbnVsbCk7XHJcblx0XHRcdFx0fSkpIHtcclxuXHRcdFx0XHRfdHVybi5wYXlvZmZzSW1wbGljaXQuc2V0KHBhdGgsIGltcGxpY2l0KVxyXG5cdFx0XHR9IGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiVHVybiBpbXBsaWNpdCBwYXlvZmZzIG11c3QgYmUgY29ycmVjdCBzaXplIGFuZCBlYWNoIG11c3QgYmUgYSBudW1iZXIgb3IgbnVsbC5cIilcclxuXHJcblxyXG5cdFx0XHQvL0FueSByZW1haW5pbmcgc2hvdWxkIGJlIGFzc2lnbmVkIGFzIGV4cGxpY2l0IHBheW9mZnMsIGlmIHRoZXkncmUgb2JqZWN0cy5cclxuXHRcdFx0cGF5b2Zmcy5zbGljZShudW1QbGF5ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKGV4cGxpY2l0KSB7XHJcblx0XHRcdFx0aWYgKGlzT2JqZWN0KGV4cGxpY2l0KSkge1xyXG5cclxuXHRcdFx0XHRcdC8vIERvbid0IHVzZSB0aGUgb3JpZ2luYWwgb2JqZWN0IGJlY2F1c2UgdGhlbiB1c2VyIGNvdWxkIHN0aWxsIGhhdmUgYSByZWZlcmVuY2VcclxuXHRcdFx0XHRcdC8vIHRvIGl0LiBJbnN0ZWFkLCBjb3B5IG92ZXIga2V5cy92YWx1ZXMgdGhhdCBhcmUgbnVtYmVycyAodGhpcyB3aWxsIHdvcmsgZm9yIFZhcmlhYmxlcylcclxuXHRcdFx0XHRcdHZhciBvYmogPSB7fVxyXG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGV4cGxpY2l0KSB7XHJcblx0XHRcdFx0XHRcdGlmICghaXNOYU4oZXhwbGljaXRba2V5XSkpIG9ialtrZXldID0gZXhwbGljaXRba2V5XVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0X3R1cm4ucGF5b2Zmc0V4cGxpY2l0LnNldChwYXRoLCBvYmopXHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0cmV0dXJuIHN1cGVyLnBheW9mZigpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIFR1cm5PdXRjb21lO1xyXG59KSgpXHJcblxyXG5cclxuXHJcbmNsYXNzIF9UdXJuIGV4dGVuZHMgX1BsYXlhYmxlIHtcclxuXHRjb25zdHJ1Y3RvcihpZCwgZGVjaXNpb25zLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRcdHN1cGVyKGlkLCBwYXJhbWV0ZXJzKVxyXG5cclxuXHRcdHZhciB0dXJuID0gdGhpcztcclxuXHJcblx0XHR0dXJuLmRlY2lzaW9ucyA9IGRlY2lzaW9ucztcclxuXHJcblx0XHQvLyB0aGUgZGVjaXNpb25NYXAgaXMgYW4gYXJyYXkgb2YgYXJyYXlzLCBlYWNoIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG9wdGlvbnMgaW4gYSBjaG9pY2UuXHJcblx0XHR0dXJuLmRlY2lzaW9uTWFwID0gdHVybi5kZWNpc2lvbnMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdFx0cmV0dXJuIGl0ZW0ub3B0aW9ucyA/IGl0ZW0ub3B0aW9ucyA6IGl0ZW0uYm91bmRzO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gSWYgYW55IG9mIHRoZSBzdWItcGxheWFibGVzIGFyZSBSYW5nZSwgb3IgaWYgc2V0IHRvIGZvcmNlT3V0Y29tZU1vZGUsXHJcblx0XHQvL3RoZW4gd2UnbGwgdXNlIE1hcHMvT3V0Y29tZXMgaW5zdGVhZCBvZiBvYmplY3RzL0JyYW5jaGVzXHJcblx0XHRpZiAocGFyYW1ldGVycy5mb3JjZU91dGNvbWVNb2RlIHx8IHR1cm4uZGVjaXNpb25zLnNvbWUoZnVuY3Rpb24oZGVjaXNpb24pIHtcclxuXHRcdFx0XHRyZXR1cm4gZGVjaXNpb24uY29uc3RydWN0b3IubmFtZSA9PSBcIl9SYW5nZVwiXHJcblx0XHRcdH0pKSB7XHJcblx0XHRcdHR1cm4uYnJhbmNoTW9kZSA9IFwib3V0Y29tZVwiXHJcblx0XHRcdHR1cm4ucGF5b2Zmc0ltcGxpY2l0ID0gbmV3IE1hcCgpO1xyXG5cdFx0XHR0dXJuLnBheW9mZnNFeHBsaWNpdCA9IG5ldyBNYXAoKTtcclxuXHRcdFx0dHVybi5uZXh0ID0gbmV3IE1hcChbXHJcblx0XHRcdFx0W1wiYWxsXCIsIFtdXVxyXG5cdFx0XHRdKSAvLyBhbGwgaXMgZm9yIGFueS1vdXRjb21lIGNhc2VzXHJcblx0XHR9XHJcblx0XHQvLyBJZiBubyBSYW5nZSdzLCBqdXN0IHVzZSBvYmplY3RzIGZvciBzaW1wbGljaXR5XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0dHVybi5icmFuY2hNb2RlID0gXCJ0cmVlXCJcclxuXHRcdFx0dHVybi5wYXlvZmZzSW1wbGljaXQgPSB7fTtcclxuXHRcdFx0dHVybi5wYXlvZmZzRXhwbGljaXQgPSB7fTtcclxuXHRcdFx0dHVybi5uZXh0ID0ge307XHJcblxyXG5cdFx0XHQvLyBOb3cgbGV0J3MgZmlsbCB0aG9zZSBpbiB3aXRoIGJsYW5rIHZhbHVlcy5cclxuXHJcblx0XHRcdGxvZyhcInNpbGx5XCIsIFwiQWRkaW5nIGltcGxpY2l0IHBheW9mZnMgbWFwIHRvIHR1cm4uXCIpO1xyXG5cdFx0XHRyZWN1cnNlKHR1cm4uZGVjaXNpb25NYXAsIHR1cm4ucGF5b2Zmc0ltcGxpY2l0LCBudWxsLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gQXJyYXkodHVybi5kZWNpc2lvbk1hcC5sZW5ndGgpLmZpbGwoMCk7XHJcblx0XHRcdH0pXHJcblxyXG5cdFx0XHRsb2coXCJzaWxseVwiLCBcIkFkZGluZyBleHBsaWNpdCBwYXlvZmZzIG1hcCB0byB0dXJuLlwiKTtcclxuXHRcdFx0cmVjdXJzZSh0dXJuLmRlY2lzaW9uTWFwLCB0dXJuLnBheW9mZnNFeHBsaWNpdCwgbnVsbCwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHt9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0bG9nKFwic2lsbHlcIiwgXCJBZGRpbmcgYmxhbmsgbmV4dCBtYXAgdG8gdHVybi5cIik7XHJcblx0XHRcdHJlY3Vyc2UodHVybi5kZWNpc2lvbk1hcCwgdHVybi5uZXh0LCBudWxsLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gW107XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0Ly9UT0RPOiBlcnJvciBoYW5kbGluZyBoZXJlXHJcblxyXG5cdH1cclxuXHJcblx0YWRkTmV4dChuZXh0UGxheWFibGUsIHBhdGggPSBcImFsbFwiKSB7XHJcblx0XHQvLyBUaGUgbm9ybWFsIFBsYXlhYmxlIGFkZE5leHQgYWxyZWFkeSBzdXBvcnRzIHRyZWUgbW9kZS5cclxuXHRcdGlmICh0aGlzLmJyYW5jaE1vZGUgPT0gXCJ0cmVlXCIpIHJldHVybiBzdXBlci5hZGROZXh0KG5leHRQbGF5YWJsZSwgcGF0aClcclxuXHRcdC8vIGluIG91dGNvbWUgbW9kZTpcclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRpZiAocGF0aCA9PSBcImFsbFwiKSB0aGlzLm5leHQuZ2V0KFwiYWxsXCIpLnB1c2gobmV4dFBsYXlhYmxlKVxyXG5cdFx0XHRlbHNlIGlmICh0aGlzLm5leHQuaGFzKHBhdGgpKSB0aGlzLm5leHQuZ2V0KHBhdGgpLnB1c2gobmV4dFBsYXlhYmxlKVxyXG5cdFx0XHRlbHNlIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGF0aDogXCIuY29uY2F0KHBhdGgpKVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblxyXG5cdC8vIEFkZGluZyBtb3JlIGNvbXBsaWNhdGVkIHN1bW1hcnkgZW50cnlcclxuXHRzdW1tYXJ5VGhpcyhzdW1tYXJ5KSB7XHJcblx0XHQvLyBGZXRjaCBzdW1tYXJpZXMgZm9yIGVhY2ggY2hvaWNlLlxyXG5cdFx0c3VtbWFyeS5hcnJheShcImRlY2lzaW9uc1wiLCB0aGlzLmRlY2lzaW9ucywgZnVuY3Rpb24oZGVjaXNpb24sIHN1bW1hcnkpIHtcclxuXHRcdFx0cmV0dXJuIGRlY2lzaW9uLnN1bW1hcml6ZShzdW1tYXJ5LCB0cnVlKSAvLyBzaG9ydC1jaXJjdWl0IHN1bW1hcnlcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIEluY2x1ZGUgcGF5b2Zmc1xyXG5cdFx0aWYgKHRoaXMuYnJhbmNoTW9kZSA9PSBcInRyZWVcIilcclxuXHRcdFx0c3VtbWFyeShcInBheW9mZnNcIiwgSlNPTi5wYXJzZShcclxuXHRcdFx0XHRKU09OLnN0cmluZ2lmeSh7XHJcblx0XHRcdFx0XHRpbXBsaWNpdDogdGhpcy5wYXlvZmZzSW1wbGljaXQsXHJcblx0XHRcdFx0XHRleHBsaWNpdDogdGhpcy5wYXlvZmZzRXhwbGljaXRcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHQpKVxyXG5cdFx0Ly8gVE9ETzogbWFrZSBwYXlvZmYgc3VtbWFyeSB3b3JrIGZvciBvdXRjb21lIG1vZGUuXHJcblxyXG5cdFx0cmV0dXJuIHN1bW1hcnk7XHJcblx0fTtcclxuXHJcblx0cGxheSh7XHJcblx0XHR1c2VQYXlvZmZzID0gdHJ1ZSxcclxuXHRcdGhpc3RvcnkgPSBnYW1lSGlzdG9yeSxcclxuXHRcdGluZm9ybWF0aW9uID0gUGVyZmVjdEluZm9ybWF0aW9uLFxyXG5cdFx0cmVsZWFzZVBsYXllcnMgPSB0cnVlXHJcblx0fSA9IHt9KSB7XHJcblx0XHR2YXIgdHVybiA9IHRoaXM7XHJcblx0XHR2YXIgY2hvaWNlSGlzdG9yeSA9IGhpc3RvcnkuY2hpbGQoKTtcclxuXHRcdHZhciBjaG9pY2VJbmZvcm1hdGlvbiA9IGluZm9ybWF0aW9uLmNoaWxkKCk7XHJcblxyXG5cdFx0aWYgKHR1cm4uY29tcGFydG1lbnRhbGl6ZSkge1xyXG5cdFx0XHRjaG9pY2VJbmZvcm1hdGlvbiA9IG5ldyBJbmZvcm1hdGlvbih0dXJuLmNvbXBhcnRtZW50YWxpemUuaGlzdG9yeSB8fCBjaG9pY2VIaXN0b3J5LFxyXG5cdFx0XHRcdHR1cm4uY29tcGFydG1lbnRhbGl6ZS5wb3B1bGF0aW9uIHx8IGluZm9ybWF0aW9uLnBvcHVsYXRpb24pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGhpc3RvcnkubG9nLmFkZCh7XHJcblx0XHRcdHR1cm46IHR1cm4uaWQsXHJcblx0XHRcdGRlY2lzaW9uczogdHVybi5kZWNpc2lvbnMubWFwKGZ1bmN0aW9uKGRlY2lzaW9uKSB7XHJcblx0XHRcdFx0cmV0dXJuIGRlY2lzaW9uLmlkO1xyXG5cdFx0XHR9KVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dmFyIGNvbXBpbGVJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uKHJpKSB7XHJcblx0XHRcdC8vSWYgdGhlcmUncyBubyB0dXJuIGVudHJ5LCBjcmVhdGUgb25lLlxyXG5cdFx0XHRpZiAoIWNob2ljZUluZm9ybWF0aW9uLmFkZGl0aW9uYWxbMF0udHVybikge1xyXG5cdFx0XHRcdHZhciB0dXJuSW5mbyA9IHtcclxuXHRcdFx0XHRcdHR1cm46IHtcclxuXHRcdFx0XHRcdFx0aWQ6IHR1cm4uaWQsXHJcblx0XHRcdFx0XHRcdGRlY2lzaW9uczogW10sXHJcblx0XHRcdFx0XHRcdGV4Y2x1ZGUocGxheWVyKSB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuZGVjaXNpb25zLmZpbHRlcihmdW5jdGlvbihkZWNpc2lvbikge1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGRlY2lzaW9uLnBsYXllciA9PSBwbGF5ZXI7XHJcblx0XHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdC8vIFN0aWNrIHR1cm4gaW5mbyBpbiBiZWZvcmUgZGVjaXNpb24gaW5mb3NcclxuXHRcdFx0XHRjaG9pY2VJbmZvcm1hdGlvbi5hZGRpdGlvbmFsLnVuc2hpZnQodHVybkluZm8pO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIG1vdmUgZGVjaXNpb24gaW5mb3MgaW50byB0dXJuIGluZm8uXHJcblx0XHRcdGNob2ljZUluZm9ybWF0aW9uLmFkZGl0aW9uYWxbMF0udHVybi5kZWNpc2lvbnMucHVzaChcclxuXHRcdFx0XHRjaG9pY2VJbmZvcm1hdGlvbi5hZGRpdGlvbmFsLnBvcCgpXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHQvLyBDb3B5IGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gZnJvbSBpbmZvcm1hdGlvbiB0byBjaG9pY2VJbmZvcm1hdGlvblxyXG5cdFx0XHRpbmZvcm1hdGlvbi5hZGRpdGlvbmFsLmZvckVhY2goXHJcblx0XHRcdFx0Y2hvaWNlSW5mb3JtYXRpb24uYWRkQWRkaXRpb25hbC5iaW5kKGNob2ljZUluZm9ybWF0aW9uKVxyXG5cdFx0XHQpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoXHJcblx0XHRcdFx0dHVybi5kZWNpc2lvbnMubWFwKGZ1bmN0aW9uKGNob2ljZSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGNob2ljZS5wbGF5KHtcclxuXHRcdFx0XHRcdFx0c2hvcnRDaXJjdWl0OiB0cnVlLFxyXG5cdFx0XHRcdFx0XHRoaXN0b3J5OiBjaG9pY2VIaXN0b3J5LFxyXG5cdFx0XHRcdFx0XHRpbmZvcm1hdGlvbjogY2hvaWNlSW5mb3JtYXRpb24sXHJcblx0XHRcdFx0XHRcdF9jb21waWxlSW5mb3JtYXRpb246IGNvbXBpbGVJbmZvcm1hdGlvbixcclxuXHRcdFx0XHRcdFx0cmVsZWFzZVBsYXllcnM6IGZhbHNlXHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHQpXHJcblx0XHRcdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdFx0XHRcdC8vUmUtZm9ybWF0IG91dHB1dCBmcm9tIGFycmF5IG9mIENob2ljZSByZXN1bHRzIHRvIHNpbmdsZSBUdXJuIHJlc3VsdFxyXG5cdFx0XHRcdC8vQW5kIHJlbGVhc2UgcGxheWVyc1xyXG5cdFx0XHRcdHZhciByZXN1bHRQYXRoID0gcmVzdWx0Lm1hcChmdW5jdGlvbihjaG9pY2UsIGluZGV4KSB7XHJcblx0XHRcdFx0XHRpZiAocmVsZWFzZVBsYXllcnMpIHR1cm4uZGVjaXNpb25zW2luZGV4XS5yZWxlYXNlUGxheWVyKCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gY2hvaWNlLnJlc3VsdDtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0Ly9QYXNzIGFsb25nIHJlc3VsdHMgYW5kIHJlY29yZCBoaXN0b3J5XHJcblx0XHRcdFx0dmFyIHJlc3VsdE9iamVjdCA9IHtcclxuXHRcdFx0XHRcdHJlc3VsdDogcmVzdWx0UGF0aCxcclxuXHRcdFx0XHRcdHBsYXlhYmxlOiB0dXJuLFxyXG5cdFx0XHRcdFx0aGlzdG9yeUVudHJ5OiB7XHJcblx0XHRcdFx0XHRcdHR1cm46IHR1cm4uaWQsXHJcblx0XHRcdFx0XHRcdHJlc3VsdHM6IGNob2ljZUhpc3Rvcnkub3JwaGFuKCksXHJcblx0XHRcdFx0XHRcdHBheW91dHM6IHt9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRPYmplY3QpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuXHRcdFx0XHQvL0ltcGxlbWVudCBwYXlvZmZzXHJcblx0XHRcdFx0aWYgKHVzZVBheW9mZnMpIHtcclxuXHRcdFx0XHRcdHZhciBpbXBsaWNpdFBheW9mZnMgPSBvdXRjb21lVHJlZUdldFZhbHVlKFxyXG5cdFx0XHRcdFx0XHR0dXJuLnBheW9mZnNJbXBsaWNpdCxcclxuXHRcdFx0XHRcdFx0cmVzdWx0LnJlc3VsdFxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdHZhciBleHBsaWNpdFBheW9mZnMgPSBvdXRjb21lVHJlZUdldFZhbHVlKFxyXG5cdFx0XHRcdFx0XHR0dXJuLnBheW9mZnNFeHBsaWNpdCxcclxuXHRcdFx0XHRcdFx0cmVzdWx0LnJlc3VsdFxyXG5cdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHQvLyBGb3IgdGhlIGxvZ1xyXG5cdFx0XHRcdFx0dmFyIHBheW91dHMgPSB7fTtcclxuXHJcblx0XHRcdFx0XHRpbXBsaWNpdFBheW9mZnMuZm9yRWFjaChmdW5jdGlvbihwYXlvZmYsIGluZGV4KSB7XHJcblx0XHRcdFx0XHRcdC8vIERvIG5vdGhpbmcgaWYgcGF5b2ZmIGlzIHplcm8uXHJcblx0XHRcdFx0XHRcdGlmIChwYXlvZmYgPT0gMCkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gZmV0Y2ggcGxheWVyIGFuZCBpbmNyZW1lbnQgc2NvcmVcclxuXHRcdFx0XHRcdFx0dmFyIHBsYXllciA9IHR1cm4uZGVjaXNpb25zW2luZGV4XS5wbGF5ZXI7XHJcblx0XHRcdFx0XHRcdHBsYXllci5zY29yZSArPSBwYXlvZmY7XHJcblxyXG5cdFx0XHRcdFx0XHQvL0FuZCBpbmNsdWRlIGl0IGluIHRoZSBsb2cgZW50cnlcclxuXHRcdFx0XHRcdFx0cGF5b3V0c1twbGF5ZXIuaWRdID0gTnVtYmVyKHBheW9mZik7XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKHZhciBwbGF5ZXIgaW4gZXhwbGljaXRQYXlvZmZzKSB7XHJcblx0XHRcdFx0XHRcdHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyXS5zY29yZSArPSBleHBsaWNpdFBheW9mZnNbcGxheWVyXTtcclxuXHJcblx0XHRcdFx0XHRcdC8vQW5kIGluY2x1ZGUgaXQgaW4gdGhlIGxvZyBlbnRyeVxyXG5cdFx0XHRcdFx0XHRwYXlvdXRzW3BsYXllcl0gPSBOdW1iZXIoZXhwbGljaXRQYXlvZmZzW3BsYXllcl0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vTG9nIGZvciB0aGUgc2NvcmVzIGxvZ1xyXG5cdFx0XHRcdFx0dmFyIHNjb3JlRW50cnkgPSB7XHJcblx0XHRcdFx0XHRcdHR1cm46IHR1cm4uaWQsXHJcblx0XHRcdFx0XHRcdHJlc3VsdDogcmVzdWx0LnJlc3VsdCxcclxuXHRcdFx0XHRcdFx0cGF5b3V0czogcGF5b3V0c1xyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdGhpc3RvcnkuYWRkU2NvcmVzKHNjb3JlRW50cnkpO1xyXG5cclxuXHJcblx0XHRcdFx0XHQvLyBMb2cgZm9yIHRoZSBnYW1lIGhpc3RvcnlcclxuXHRcdFx0XHRcdHJlc3VsdC5oaXN0b3J5RW50cnkucGF5b3V0cyA9IHBheW91dHM7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7IC8vVE9ETzogYWRkIGluZm9ybWF0aW9uIG1lY2hhbmlzbXNcclxuXHRcdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvL092ZXJ3cml0ZSBkZWZhdWx0IGhpc3RvcnkgaGFuZGxlciwgYmVjYXVzZSB3ZSBkb24ndCB3YW50IGEgc2Vjb25kIGVudHJ5IGluIHRoZSB0cmVlXHJcblx0aGFuZGxlSGlzdG9yeSh7IGhpc3RvcnkgPSBnYW1lSGlzdG9yeSB9ID0ge30sIHJlc3VsdCkge1xyXG5cdFx0aGlzdG9yeS5hZGROb0xvZyhyZXN1bHQuaGlzdG9yeUVudHJ5KTtcclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuXHR9O1xyXG5cclxuXHQvLyBGaW5kIHRoZSBuZXh0IHRoaW5nIHRvIGRvLlxyXG5cdGZpbmROZXh0KHsgcmVzdWx0IH0gPSB7fSkge1xyXG5cdFx0dmFyIG5leHQ7XHJcblxyXG5cdFx0Ly8gSW4gYnJhbmNoIG1vZGUsIGdldCB0aGUgbmV4dCBpdGVtcyBmcm9tIHRoZSBuZXh0IHRyZWUuXHJcblx0XHRpZiAodGhpcy5icmFuY2hNb2RlID09IFwidHJlZVwiKSB7XHJcblx0XHRcdG5leHQgPSBvdXRjb21lVHJlZUdldFZhbHVlKHRoaXMubmV4dCwgcmVzdWx0LnJlc3VsdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaW4gb3V0Y29tZSBtb2RlLCBpdGVyYXRlIG92ZXIgdGhlIE1hcC5cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHQvLyByZXR1cm4gdGhlIFwiYW55IG91dGNvbWVcIiBjYXNlc1xyXG5cdFx0XHRuZXh0ID0gdGhpcy5uZXh0LmdldChcImFsbFwiKS5zbGljZSgpXHJcblxyXG5cdFx0XHQvLyBGb3IgZWFjaCBldmFsdWF0b3IsIHJ1biBpdCB3aXRoIHRoZSByZXN1bHQsIGFuZCBpZiB0cnVlLCBhZGQgdGhvc2UgcGxheWFibGVzIHRvIHRoZSBsaXN0XHJcblx0XHRcdGZvciAodmFyIFtldmFsdWF0b3IsIHBsYXlhYmxlc10gb2YgdGhpcy5uZXh0KSB7XHJcblx0XHRcdFx0aWYgKGV2YWx1YXRvciAhPT0gXCJhbGxcIiAmJiBldmFsdWF0b3IocmVzdWx0LnJlc3VsdCkgPT09IHRydWUpIG5leHQucHVzaCguLi5wbGF5YWJsZXMpXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV4dDtcclxuXHR9O1xyXG5cclxuXHJcblx0Z2VuZXJhdGVCcmFuY2hlcygpIHtcclxuXHRcdHZhciBfdHVybiA9IHRoaXM7XHJcblx0XHQvLyBJbiBvdXRjb21lIChSYW5nZSkgbW9kZSwgZG9uJ3QgZXZlbiBib3RoZXIuXHJcblx0XHRpZiAoX3R1cm4uYnJhbmNoTW9kZSA9PSBcIm91dGNvbWVcIikgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdC8vIEtlZXAgYW4gZWFzeSB0cmFjayBvZiB0aGUgYnJhbmNoZXMsIHdoaWNoIHdpbGwgaGVscCBmb3Igc2V0QWxsUGF5b2Zmc1xyXG5cdFx0X3R1cm4uYnJhbmNoZXMgPSBbXVxyXG5cdFx0dmFyIHR1cm4gPSBfdHVybi5pbnRlcmZhY2U7XHJcblxyXG5cdFx0cmVjdXJzZShfdHVybi5kZWNpc2lvbk1hcCwgdHVybiwgbnVsbCwgZnVuY3Rpb24ocGF0aCkge1xyXG5cdFx0XHRsZXQgYnJhbmNoID0gbmV3IFR1cm5CcmFuY2gocGF0aCwgX3R1cm4pXHJcblx0XHRcdF90dXJuLmJyYW5jaGVzLnB1c2goYnJhbmNoKVxyXG5cdFx0XHRyZXR1cm4gYnJhbmNoXHJcblx0XHR9KVxyXG5cclxuXHRcdHJldHVybiB0cnVlXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gUmVwbGFjZWQgd2l0aCBnZW5lcmF0ZUJyYW5jaGVzLCBkZWxldGUgd2hlbiB5b3UgZmVlbCBjb25maWRlbnQgYWJvdXQgaXQuXHJcblx0Z2VuZXJhdGVDaGFpbmluZ0Z1bmN0aW9ucygpIHtcclxuXHRcdHZhciBfdHVybiA9IHRoaXM7XHJcblx0XHR2YXIgdHVybiA9IF90dXJuLmludGVyZmFjZTtcclxuXHJcblx0XHQvL0NyZWF0ZSBwYXlvZmYgc2V0dGVyL2JyYW5jaCByb3V0ZXIgZnVuY3Rpb25zLlxyXG5cdFx0Ly9yZWN1cnNlIGFkZHMgYSB3cmFwcGVyIGFyb3VuZCB0aGlzIGZ1bmN0aW9uIHdoaWNoIHN1cHBsaWVzIHRoZSBwYXRoLlxyXG5cdFx0cmVjdXJzZShfdHVybi5kZWNpc2lvbk1hcCwgdHVybiwgZnVuY3Rpb24ocGF0aCwgcGF5b2Zmcykge1xyXG5cdFx0XHQvL0lmIHVzZXIgc3VwcGxpZWQgcGF5b2ZmcyBpbiBhcnJheSBmb3JtLCB0aGVuIHRyYW5zbGF0ZSB0byBvYmplY3QgYmFzZWQgb24gd2hpY2ggcGxheWVycyBhcmUgaW52b2x2ZWQgaW4gdGhlIGRlY2lzaW9uc1xyXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShwYXlvZmZzKSkge1xyXG5cdFx0XHRcdGlmIChwYXlvZmZzLmxlbmd0aCAhPT0gX3R1cm4uZGVjaXNpb25zLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0Ly9JZiBhcnJheSBpc24ndCByaWdodCBsZW5ndGgsIHRoZW4gdGhpcyBpcyB1bmludGVsbGlnaWJsZS5cclxuXHRcdFx0XHRcdGxvZyhcclxuXHRcdFx0XHRcdFx0XCJlcnJvclwiLFxyXG5cdFx0XHRcdFx0XHRcIlBheW9mZiBhcnJheSBkb2VzIG5vdCBtYXRjaCBUdXJuIGRpbWVuc2lvbnMsIGNhbm5vdCBhc3NpZ24gcGF5b2Zmcy5cIlxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJQYXlvZmYgYXJyYXkgaXMgbm90IGNvcnJlY3QgbGVuZ3RoXCIpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciBvcmlnaW5hbFBheW9mZnMgPSBwYXlvZmZzLnNsaWNlKCk7XHJcblx0XHRcdFx0cGF5b2ZmcyA9IHt9O1xyXG5cclxuXHRcdFx0XHRvdXRjb21lVHJlZVNldFZhbHVlKF90dXJuLnBheW9mZnNJbXBsaWNpdCwgcGF0aCwgb3JpZ2luYWxQYXlvZmZzKTtcclxuXHRcdFx0fSBlbHNlIGlmIChpc09iamVjdChwYXlvZmZzKSkge1xyXG5cdFx0XHRcdHBheW9mZnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHBheW9mZnMpKTtcclxuXHRcdFx0XHRvdXRjb21lVHJlZVNldFZhbHVlKF90dXJuLnBheW9mZnNFeHBsaWNpdCwgcGF0aCwgcGF5b2Zmcyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZSh7XHJcblx0XHRcdFx0cGxheWFibGU6IHR1cm4sXHJcblx0XHRcdFx0cGF0aDogcGF0aFxyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG59XHJcbl9UdXJuLnJlZ2lzdHJ5TmFtZSA9IFwidHVybnNcIjtcclxuX1R1cm4uY291bnRlck5hbWUgPSBcInR1cm5cIjtcclxuXHJcblxyXG5cclxuXHJcbl9UdXJuLnByb3RvdHlwZS5zZXRBbGxQYXlvZmZzID0gZnVuY3Rpb24ocGF5b2ZmQXJyYXkpIHtcclxuXHR2YXIgdHVybiA9IHRoaXM7XHJcblxyXG5cdC8vUmVjdXJzZSB0aHJvdWdoIHRoZSBvcHRpb25zIGluIGlucHV0LCB0byBjb21lIHVwIHdpdGggYSBwYXRoIHRvIGV2ZXJ5IGNvbWJpbmF0aW9uIG9mIG9wdGlvbnMgaW4gdGhlIGFycmF5IG9mIGFycmF5cy5cclxuXHRmdW5jdGlvbiByZWN1cnNlKGlucHV0LCBudW1QbGF5ZXJzLCBwYXlvZmZzLCBwYXRoID0gW10sIGNvb3JkaW5hdGVzID0gW10pIHtcclxuXHJcblx0XHQvL1NpbmNlIHdlIHNsaWNlIHRoZSBhcnJheSBlYWNoIHRpbWUsIGlmIHRoZXJlIGFyZSBubyBtb3JlIGVudHJpZXMgbGVmdCB0aGVuIHdlJ3JlIGRvbmUgd2l0aCB0aGlzIGJyYW5jaC5cclxuXHRcdGlmIChpbnB1dC5sZW5ndGggPT0gMCkgcmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKHBhdGgpO1xyXG5cclxuXHRcdC8vQW1vbmcgYWxsIHZhbHVlcyBmcm9tIHRoZSBhcnJheVxyXG5cdFx0cmV0dXJuIGlucHV0WzBdLm1hcChmdW5jdGlvbihpdGVtLCBpbmRleCkge1xyXG5cdFx0XHR2YXIgc3BsaXRQYXRoID0gcGF0aC5zbGljZSgwKS5jb25jYXQoaXRlbSk7XHJcblx0XHRcdHZhciBzcGxpdENvb3JkaW5hdGVzID0gY29vcmRpbmF0ZXMuc2xpY2UoMCkuY29uY2F0KGluZGV4KTtcclxuXHRcdFx0dmFyIHNwbGl0UGF5b2ZmcyA9IHBheW9mZnNbaW5kZXhdO1xyXG5cclxuXHRcdFx0Ly9JZiB3ZSdyZSBhdCB0aGUgbGFzdCBwb3NpdGlvbiBpbiB0aGUgYXJyYXkgb2Ygb3B0aW9ucywgdGhlbiB3ZSBoYXZlIGEgY29tcGxldGUgcGF0aC5cclxuXHRcdFx0aWYgKGlucHV0Lmxlbmd0aCA9PSAxKSB7XHJcblx0XHRcdFx0LyogeW91IG1pZ2h0IG5lZWQgdGhlc2UgbGF0ZXJcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhcInBhdGggXCIsIHNwbGl0UGF0aCk7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCJjb29yZGluYXRlcyBcIiwgc3BsaXRDb29yZGluYXRlcylcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhcInBheW9mZiBcIixzcGxpdFBheW9mZnMpXHJcblx0XHRcdFx0Ki9cclxuXHJcblx0XHRcdFx0c3BsaXRQYXlvZmZzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzcGxpdFBheW9mZnMpKTtcclxuXHJcblx0XHRcdFx0Ly9BbGxvdyB0aGUgZmlyc3QgZmV3IGFycmF5IGVsZW1lbnRzIHRvIGJlIGltcGxpY2l0IHBheW9mZnMuIENoZWNrIHRoYXQgdGhleSBhcmUgYWN0dWFsbHkgdGhlcmUgYW5kIGFyZSBudW1iZXJzXHJcblx0XHRcdFx0dmFyIGltcGxpY2l0ID0gc3BsaXRQYXlvZmZzLnNsaWNlKDAsIG51bVBsYXllcnMpO1xyXG5cdFx0XHRcdGlmIChcclxuXHRcdFx0XHRcdGltcGxpY2l0Lmxlbmd0aCA9PSBudW1QbGF5ZXJzICYmXHJcblx0XHRcdFx0XHRpbXBsaWNpdC5ldmVyeShmdW5jdGlvbihwYXlvZmYpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuICFpc05hTihwYXlvZmYpO1xyXG5cdFx0XHRcdFx0fSlcclxuXHRcdFx0XHQpIHtcclxuXHRcdFx0XHRcdG91dGNvbWVUcmVlU2V0VmFsdWUodHVybi5wYXlvZmZzSW1wbGljaXQsIHNwbGl0UGF0aCwgaW1wbGljaXQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly9BbnkgcmVtYWluaW5nIHNob3VsZCBiZSBhc3NpZ25lZCBhcyBleHBsaWNpdCBwYXlvZmZzLCBpZiB0aGV5J3JlIG9iamVjdHMuXHJcblx0XHRcdFx0c3BsaXRQYXlvZmZzLnNsaWNlKG51bVBsYXllcnMpLmZvckVhY2goZnVuY3Rpb24oZXhwbGljaXQpIHtcclxuXHRcdFx0XHRcdGlmIChpc09iamVjdChleHBsaWNpdCkpXHJcblx0XHRcdFx0XHRcdG91dGNvbWVUcmVlU2V0VmFsdWUodHVybi5wYXlvZmZzRXhwbGljaXQsIHNwbGl0UGF0aCwgZXhwbGljaXQpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL0lmIHRoZXJlIGFyZSBtb3JlIGl0ZW1zIHRvIGl0ZXJhdGUgb3ZlciwgaW5jbHVkZSB0aGVtIGluIHRoZSBvdXRwdXQgdGhlbiByZWN1cnNlLlxyXG5cdFx0XHRyZXR1cm4gcmVjdXJzZShcclxuXHRcdFx0XHRpbnB1dC5zbGljZSgxKSxcclxuXHRcdFx0XHRudW1QbGF5ZXJzLFxyXG5cdFx0XHRcdHNwbGl0UGF5b2ZmcyxcclxuXHRcdFx0XHRzcGxpdFBhdGgsXHJcblx0XHRcdFx0c3BsaXRDb29yZGluYXRlc1xyXG5cdFx0XHQpO1xyXG5cdFx0fSlcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVjdXJzZSh0dXJuLmRlY2lzaW9uTWFwLCB0dXJuLmRlY2lzaW9ucy5sZW5ndGgsIHBheW9mZkFycmF5KS5jYXRjaChcclxuXHRcdGZ1bmN0aW9uKHJlYXNvbikge1xyXG5cdFx0XHRsb2coXCJlcnJvclwiLCByZWFzb24pO1xyXG5cdFx0fVxyXG5cdCk7XHJcbn07XHJcblxyXG5cclxuX1R1cm4ucHJvdG90eXBlLnN1bW1hcnlOZXh0ID0gZnVuY3Rpb24oc3VtbWFyeSwgZW50cmllcykge1xyXG5cdHZhciB0dXJuID0gdGhpcztcclxuXHJcblx0Ly8gQ3JlYXRlIG1hcFxyXG5cdHN1bW1hcnkubmV4dCA9IHt9O1xyXG5cdHZhciBjb3VudCA9IDA7XHJcblx0cmVjdXJzZSh0aGlzLmRlY2lzaW9uTWFwLCBzdW1tYXJ5Lm5leHQsIG51bGwsIGZ1bmN0aW9uKHBhdGgpIHtcclxuXHRcdHJldHVybiBvdXRjb21lVHJlZUdldFZhbHVlKHR1cm4ubmV4dCwgcGF0aCkubWFwKGZ1bmN0aW9uKHBsYXlhYmxlKSB7XHJcblx0XHRcdCsrY291bnQ7XHJcblx0XHRcdHJldHVybiBwbGF5YWJsZS5zdW1tYXJpemUoKTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cclxuXHQvLyBJZiB0aGVyZSBpcyBubyBuZXh0LCBkZWxldGUgdGhlIGtleS5cclxuXHRpZiAoY291bnQgPT0gMCkgZGVsZXRlIHN1bW1hcnkubmV4dDtcclxufTtcclxuXHJcblxyXG5cclxuZnVuY3Rpb24gVHVybihkZWNpc2lvbnMsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihwYXJhbWV0ZXJzLmlkLCBcInR1cm5cIik7XHJcblxyXG5cdGRlY2lzaW9ucyA9IGRlY2lzaW9ucy5tYXAoZnVuY3Rpb24oY2hvaWNlKSB7XHJcblx0XHRyZXR1cm4gcmVnaXN0cnkuZGVjaXNpb25zW2Nob2ljZS5pZCgpXTtcclxuXHR9KTtcclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBjaG9pY2Ugb2JqZWN0XHJcblx0dmFyIF90dXJuID0gbmV3IF9UdXJuKGlkLCBkZWNpc2lvbnMsIHBhcmFtZXRlcnMpO1xyXG5cclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXIuIFJ1biB0aGUgZnVuY3Rpb24gdG8gc2VsZWN0IGEgc291cmNlXHJcblx0dmFyIHR1cm4gPSBuZXcgUGxheWFibGUoX3R1cm4pO1xyXG5cclxuXHRfdHVybi5nZW5lcmF0ZUJyYW5jaGVzKCk7XHJcblxyXG5cclxuXHR0dXJuLm91dGNvbWUgPSBmdW5jdGlvbihmdW5jLCBwYXJhbWV0ZXJzKSB7XHJcblx0XHR2YXIgZXZhbHVhdG9yID0gbmV3IEV2YWx1YXRvcihmdW5jLCBwYXJhbWV0ZXJzKVxyXG5cdFx0cmV0dXJuIG5ldyBUdXJuT3V0Y29tZShldmFsdWF0b3IsIHJlZ2lzdHJ5LnR1cm5zW3RoaXMuaWQoKV0pXHJcblx0fVxyXG5cclxuXHQvL0Z1bmN0aW9uIHRvIHNldCBhbGwgcGF5b2ZmcyBhdCBvbmNlXHJcblx0dHVybi5zZXRBbGxQYXlvZmZzID0gZnVuY3Rpb24ocGF5b2Zmcykge1xyXG5cdFx0Ly9UT0RPOiBJbmNsdWRlIGVycm9yIGhhbmRsaW5nIGlmIGFycmF5IGdpdmVuIGlzbid0IGV4cGVjdGVkIGRpbWVuc2lvbnMuXHJcblx0XHRfdHVybi5zZXRBbGxQYXlvZmZzKHBheW9mZnMpO1xyXG5cdH07XHJcblxyXG5cdC8vV2F5IGZvciB1c2VyIHRvIGludGVyYWN0IHdpdGggcGF5b2Zmc1xyXG5cdHR1cm4ucGF5b2ZmcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoXHJcblx0XHRcdEpTT04uc3RyaW5naWZ5KHtcclxuXHRcdFx0XHRpbXBsaWNpdDogX3R1cm4ucGF5b2Zmc0ltcGxpY2l0LFxyXG5cdFx0XHRcdGV4cGxpY2l0OiBfdHVybi5wYXlvZmZzRXhwbGljaXRcclxuXHRcdFx0fSlcclxuXHRcdCk7XHJcblx0fTtcclxuXHJcblx0Ly8gUmV0dXJucyB0aGUgcGF5b2ZmcyBpbiBuZXN0ZWQgYXJyYXkgZm9ybSwgdG8gbWFrZSBjbG9uaW5nIGVhc2llciwgaWUuIHQyLnNldEFsbFBheW9mZnModDEucGF5b2Zmc01hdHJpeCgpKVxyXG5cdHR1cm4ucGF5b2Zmc01hdHJpeCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdC8vIHJlY3Vyc2lvbiB0byBjb25zdHJ1Y3QgcGF5b2ZmIG1hdHJpeFxyXG5cdFx0dmFyIG1hcHBlciA9IGZ1bmN0aW9uKG9iaiwgcGF0aCA9IFtdKSB7XHJcblx0XHRcdC8vSWYgaXQncyBhbiBhcnJheSwgdGhlbiB3ZSd2ZSByZWFjaGVkIHRoZSBwYXlvZmZzXHJcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcclxuXHRcdFx0XHR2YXIgcGF5b2ZmID0gb2JqLnNsaWNlKDApXHJcblx0XHRcdFx0Ly8gQWRkIGV4cGxpY2l0IHBheW9mZnMgdG9vXHJcblx0XHRcdFx0dmFyIGV4cGxpY2l0ID0gb3V0Y29tZVRyZWVHZXRWYWx1ZShfdHVybi5wYXlvZmZzRXhwbGljaXQsIHBhdGgpO1xyXG5cclxuXHRcdFx0XHQvLyBPbmx5IGFkZCBhbiBlbnRyeSBpZiB0aGUgZXhwbGljaXQgcGF5b2ZmcyBvYmplY3QgaXMgbm90IGVtcHR5XHJcblx0XHRcdFx0cmV0dXJuIE9iamVjdC5rZXlzKGV4cGxpY2l0KS5sZW5ndGggPiAwID8gcGF5b2ZmLmNvbmNhdChbb3V0Y29tZVRyZWVHZXRWYWx1ZShfdHVybi5wYXlvZmZzRXhwbGljaXQsXHJcblx0XHRcdFx0XHRwYXRoKV0pIDogcGF5b2ZmXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIE90aGVyd2lzZSwgZGlnIGluIGRlZXBlclxyXG5cdFx0XHRlbHNlIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrZXkpIHsgcmV0dXJuIG1hcHBlcihvYmpba2V5XSwgcGF0aC5zbGljZSgwKS5jb25jYXQoW2tleV0pKSB9KVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG1hcHBlcihfdHVybi5wYXlvZmZzSW1wbGljaXQpXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdHVybjtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IFR1cm5CcmFuY2gsIFR1cm5PdXRjb21lLCBfVHVybiwgVHVybiB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBsb2cgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xyXG5cclxuXHJcbi8vR2FtZSBzdGF0ZSBjb250cm9sbGVyc1xyXG52YXIgeyByZWdpc3RyeSB9ID0gcmVxdWlyZSgnLi9zdGF0ZScpO1xyXG52YXIgUHJvbWlzZSA9IHJlZ2lzdHJ5LlByb21pc2VcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoJy4vaGVscGVyLWZ1bmN0aW9ucycpKFwic3RhdGVcIik7XHJcbnZhciB7IGNoYWluZXJHZW5lcmF0b3IgfSA9IHJlcXVpcmUoJy4vaGVscGVyLWZ1bmN0aW9ucycpKFwicGxheWFibGVcIik7XHJcblxyXG52YXIgeyBVc2VySGlzdG9yeSB9ID0gcmVxdWlyZSgnLi9oaXN0b3J5Jyk7XHJcblxyXG4vLyBQbHVnaW5zXHJcbnZhciBQbHVnaW5NYW5hZ2VyID0gcmVxdWlyZShcIi4vcGx1Z2luLW1hbmFnZXJcIilcclxuXHJcblxyXG4vLyBJbnRlcm5hbCBwbGF5ZXIgb2JqZWN0XHJcbmNsYXNzIF9QbGF5ZXIge1xyXG5cdGNvbnN0cnVjdG9yKGlkLCB7IHJvbGUgPSBcIlwiLCBhc3NpZ24gPSBudWxsIH0gPSB7fSkge1xyXG5cdFx0bG9nKCdzaWxseScsICdDcmVhdGluZyBpbnRlcmFsIHBsYXllciBvYmplY3QuJyk7XHJcblxyXG5cdFx0dGhpcy5pZCA9IGlkXHJcblx0XHR0aGlzLnJvbGUgPSByb2xlLnRvU3RyaW5nKCk7XHJcblxyXG5cdFx0dGhpcy5oaXN0b3J5ID0gW107XHJcblx0XHR0aGlzLnNjb3JlID0gMFxyXG5cdFx0dGhpcy5hbGl2ZSA9IHRydWU7XHJcblx0XHR0aGlzLmF2YWlsYWJsZSA9IHRydWU7XHJcblxyXG5cdFx0aWYgKGFzc2lnbikgdGhpcy5hc3NpZ24oYXNzaWduKTtcclxuXHJcblx0XHRyZWdpc3RyeS5wbGF5ZXJzW2lkXSA9IHRoaXM7XHJcblx0fVxyXG5cclxuXHQvL0Fzc2lnbiBzdHJhdGVneSB0byBwbGF5ZXJcclxuXHRhc3NpZ24oc3RyYXRlZ3ksIC4uLmFyZ3MpIHtcclxuXHJcblx0XHQvL1RPRE86IHZlcmlmeSBzdHJhdGVneSB0eXBlXHJcblx0XHRpZiAocmVnaXN0cnkuc3RyYXRlZ2llc1tzdHJhdGVneV0pIHtcclxuXHJcblx0XHRcdC8vIGRvbid0IGFsbG93IGluY29ycmVjdCByb2xlcywgYnV0IG9ubHkgaWYgcm9sZXMgZXhpc3QgZm9yIGJvdGggcGxheWVyIGFuZCBzdHJhdGVneVxyXG5cdFx0XHRpZiAocmVnaXN0cnkuc3RyYXRlZ2llc1tzdHJhdGVneV0ucm9sZSAmJiB0aGlzLnJvbGUgJiYgcmVnaXN0cnkuc3RyYXRlZ2llc1tzdHJhdGVneV0ucm9sZSAhPSB0aGlzLnJvbGUpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXHJcblx0XHRcdFx0XHRcIkNhbm5vdCBhc3NpZ24gc3RyYXRlZ3kgJHtzdHJhdGVneX0gKHJvbGUgJHtyZWdpc3RyeS5zdHJhdGVnaWVzW3N0cmF0ZWd5XS5yb2xlfSkgdG8gcGxheWVyICR7dGhpcy5pZH0gKHJvbGUgJHt0aGlzLnJvbGV9KVwiXHJcblx0XHRcdFx0KVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBhc3NpZ24gc3RyYXRlZ3lcclxuXHRcdFx0dGhpcy5zdHJhdGVneSA9IG5ldyByZWdpc3RyeS5zdHJhdGVnaWVzW3N0cmF0ZWd5XSguLi5hcmdzKTtcclxuXHRcdFx0dGhpcy5zdHJhdGVneS5faWQgPSBzdHJhdGVneVxyXG5cdFx0XHR0aGlzLnN0cmF0ZWd5Ll9hcmdzID0gYXJnc1xyXG5cdFx0fSBlbHNlIHRocm93IG5ldyBFcnJvcihcIlN0cmF0ZWd5ICdcIiArIHN0cmF0ZWd5ICsgXCInIGlzIG5vdCBkZWZpbmVkXCIpO1xyXG5cdH07XHJcblxyXG5cdC8vQ2FsbCBzdHJhdGVneSB0byBtYWtlIGEgY2hvaWNlXHJcblx0Y2hvb3NlKG9wdGlvbnMsIGluZm9ybWF0aW9uID0ge30sIHBsYXllck1ldGhvZCA9IFwiY2hvb3NlXCIpIHtcclxuXHRcdHZhciBwbGF5ZXIgPSB0aGlzO1xyXG5cdFx0aWYgKHBsYXllci5zdHJhdGVneSkge1xyXG5cdFx0XHRsZXQgcmVzdWx0ID0gcGxheWVyLnN0cmF0ZWd5W3BsYXllck1ldGhvZF0ob3B0aW9ucywgaW5mb3JtYXRpb24pXHJcblx0XHRcdGlmIChyZXN1bHQpIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0LnRvU3RyaW5nKCkpO1xyXG5cdFx0XHQvLyBJZiBubyByZXNwb25zZSwgZ2l2ZSB3YXJuaW5nXHJcblx0XHRcdGVsc2UgbG9nKFwid2FybmluZ1wiLCBcIk5vIHJlc3BvbnNlIGZyb20gcGxheWVyIFwiICsgcGxheWVyLmlkICsgXCIuIFVzaW5nIGRlZmF1bHQgb3B0aW9uLlwiKVxyXG5cdFx0fVxyXG5cdFx0Ly8gSWYgbm8gc3RyYXRlZ3ksIGdpdmUgd2FybmluZ1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRsb2coXCJ3YXJuaW5nXCIsIFwiTm8gc3RyYXRlZ3kgYXNzaWduZWQgdG8gcGxheWVyIFwiICsgcGxheWVyLmlkICsgXCIuIFVzaW5nIGRlZmF1bHQgb3B0aW9uLlwiKTtcclxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XHJcblx0fTtcclxuXHJcblx0Ly9UYWtlcyBhIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoKSkgY29weSBvZiBfcGxheWVyLiBSZXR1cm5zIGEgY2xlYW5lZCB1cCB2ZXJzaW9uXHJcblx0aW5mb0NsZWFuKGluZm9PYmplY3QpIHtcclxuXHRcdGRlbGV0ZSBpbmZvT2JqZWN0LmludGVyZmFjZTtcclxuXHRcdGluZm9PYmplY3Quc3RyYXRlZ3kgPSBpbmZvT2JqZWN0LnN0cmF0ZWd5ID8gaW5mb09iamVjdC5zdHJhdGVneS5faWQgOiBudWxsO1xyXG5cclxuXHRcdHJldHVybiBpbmZvT2JqZWN0O1xyXG5cdH07XHJcblxyXG5cdC8vS2lsbCBwbGF5ZXIuIFRPRE86IGFkZCBwbGF5ZXIgdG8gc29tZSBzb3J0IG9mIFwiZGVhZFwiIGxpc3QgdG8gYXZvaWQgYmVpbmcgcGlja2VkIHRvIGRvIHRoaW5ncy5cclxuXHRraWxsKCkge1xyXG5cdFx0dGhpcy5hbGl2ZSA9IGZhbHNlO1xyXG5cdH07XHJcbn1cclxuXHJcblxyXG4vL01ha2UgYSBjb3B5IG9mIHRoZSBwbGF5ZXIsIGluIG9yZGVyIHRvIHRha2UgYSBzbmFwc2hvdC4gLy8vL1RPRE8gdHJ5IHRoaXMgYWdhaW4gc29tZXRpbWUuXHJcbi8qXHJcbl9QbGF5ZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKXtcclxuXHQvL01ha2UgbmV3IGNvcHkuIERvbid0IGtlZXAgbW9yZSB0aGFuIG9uZS5cclxuXHRkZWxldGUgdGhpcy5jb3B5XHJcblxyXG5cdHZhciBjbG9uZSA9IG5ldyBfUGxheWVyKHRoaXMuaWQpO1xyXG5cclxuXHQvL0xvb3AgdGhyb3VnaCBwcm9wZXJ0aWVzIGFuZCBhc3NpZ24gdGhlbS5cclxuXHRmb3IgKHZhciBrZXkgaW4gdGhpcyl7XHJcblx0XHRjbG9uZVtrZXldID0gdGhpc1trZXldO1xyXG5cdH1cclxuXHQvL0RvIG5vdCBhZGQgdG8gcmVnaXN0cnkuIFRoaXMgd2lsbCBrZWVwIGR1cGxpY2F0ZXMgb3V0IG9mIHBvcHVsYXRpb24uXHJcblxyXG5cdC8vRG8gYWRkIHJlZmVyZW5jZSBzbyB3ZSBjYW4gZmluZCBpdCBhZ2Fpbi5cclxuXHR0aGlzLmNvcHkgPSBjbG9uZTtcclxuXHJcblx0cmV0dXJuIGNsb25lO1xyXG59O1xyXG4qL1xyXG5cclxuXHJcbi8vQ2xhc3MgdGhhdCBpcyB0aGUgcmVmZXJlbmNlIGZvciB0aGUgdXNlciB0byBob2xkIG9udG9cclxuZnVuY3Rpb24gcGxheWVyKCkge31cclxuXHJcblxyXG4vL0Zyb250ZW5kIGZvciBQbGF5ZXJcclxuZnVuY3Rpb24gUGxheWVyKHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihwYXJhbWV0ZXJzLmlkLCBcInBsYXllclwiKTtcclxuXHJcblx0Ly9DcmVhdGUgYmFja2VuZCBwbGF5ZXIgb2JqZWN0XHJcblx0dmFyIF9wbGF5ZXIgPSBuZXcgX1BsYXllcihpZCwgcGFyYW1ldGVycyk7XHJcblxyXG5cclxuXHQvL1JldHVybiB0aGlzIHJlZmVyZW5jZSBvYmplY3QgdG8gdGhlIHVzZXJcclxuXHR2YXIgcGxheWVySW50ZXJmYWNlID0gbmV3IHBsYXllcigpOyAvL1Byb2JhYmx5IGFkZCBmdW5jdGlvbmFsaXR5IGhlcmVcclxuXHJcblx0Ly9UYWctYmFjay4gU3RvcmUgdGhlIGZyb250LWVuZCBvYmplY3QgaW4gdGhlIGJhY2stZW5kIG9iamVjdCwgZm9yIHJldHJpZXZhbFxyXG5cdF9wbGF5ZXIuaW50ZXJmYWNlID0gcGxheWVySW50ZXJmYWNlO1xyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2UuYWxpdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiByZWdpc3RyeS5wbGF5ZXJzW2lkXS5hbGl2ZTtcclxuXHR9XHJcblxyXG5cdHBsYXllckludGVyZmFjZS5hc3NpZ24gPSBmdW5jdGlvbihzdHJhdGVneSwgLi4uYXJncykge1xyXG5cdFx0cmVnaXN0cnkucGxheWVyc1tpZF0uYXNzaWduKHN0cmF0ZWd5LCAuLi5hcmdzKTtcclxuXHR9O1xyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2UuaGlzdG9yeSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBVc2VySGlzdG9yeShyZWdpc3RyeS5wbGF5ZXJzW2lkXS5oaXN0b3J5KTtcclxuXHR9O1xyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2UuaWQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGlkOyB9O1xyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2UuaXNBdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiByZWdpc3RyeS5wbGF5ZXJzW2lkXS5hdmFpbGFibGVcclxuXHR9O1xyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2Uua2lsbCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmVnaXN0cnkucGxheWVyc1tpZF0ua2lsbCgpO1xyXG5cdH1cclxuXHJcblx0cGxheWVySW50ZXJmYWNlLm1hcmtBdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJlZ2lzdHJ5LnBsYXllcnNbaWRdLmF2YWlsYWJsZSA9IHRydWU7XHJcblx0fTtcclxuXHJcblx0cGxheWVySW50ZXJmYWNlLm1hcmtCdXN5ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZWdpc3RyeS5wbGF5ZXJzW2lkXS5hdmFpbGFibGUgPSBmYWxzZTtcclxuXHR9O1xyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2Uucm9sZSA9IGZ1bmN0aW9uKHJvbGUpIHtcclxuXHRcdGlmIChyb2xlKSByZWdpc3RyeS5wbGF5ZXJzW2lkXS5yb2xlID0gcm9sZS50b1N0cmluZygpO1xyXG5cdFx0cmV0dXJuIHJlZ2lzdHJ5LnBsYXllcnNbaWRdLnJvbGVcclxuXHR9XHJcblxyXG5cdHBsYXllckludGVyZmFjZS5yZXNldFNjb3JlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZWdpc3RyeS5wbGF5ZXJzW2lkXS5zY29yZSA9IDA7XHJcblx0fVxyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2Uuc2NvcmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiByZWdpc3RyeS5wbGF5ZXJzW2lkXS5zY29yZTtcclxuXHR9O1xyXG5cclxuXHRwbGF5ZXJJbnRlcmZhY2Uuc3RyYXRlZ3kgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiByZWdpc3RyeS5wbGF5ZXJzW2lkXS5zdHJhdGVneS5faWQ7XHJcblx0fTtcclxuXHJcblx0Ly8gUExVR0lOOiBydW4gYWZ0ZXIgcGxheWVyIGNyZWF0aW9uXHJcblx0UGx1Z2luTWFuYWdlci5ydW4oXCJwbGF5ZXItY3JlYXRlXCIsIF9wbGF5ZXIpXHJcblxyXG5cdHJldHVybiBwbGF5ZXJJbnRlcmZhY2VcclxufVxyXG5cclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IF9QbGF5ZXIsIFBsYXllciB9O1xyXG4iLCIvKipcclxuICpcclxuICogQHR5cGUge3t9fVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEFzeW5jQ3R4KGNhbGxiYWNrKSB7XHJcblx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cdHRoaXMuc3luYyA9IHRydWU7XHJcbn1cclxuXHJcbkFzeW5jQ3R4LnByb3RvdHlwZS5hc3luYyA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuc3luYyA9IGZhbHNlO1xyXG5cdHJldHVybiB0aGlzLmNhbGxiYWNrO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgYW4gQVBJIG1lYW50IHRvIGJlIHVzZWQgb25seSBmcm9tIHN5bmNocm9ub3VzXHJcbiAqIGNhbGxiYWNrcyBpbnRvIGFuIGFzeW5jaHJvbm91cyBsaWtlIGhvb2suXHJcbiAqXHJcbiAqIGl0IHJlcHJlc2VudCBjb250aW51aXR5IGZyb20gdGhlIFwic3luYygpXCIgb3IgXCJ3YXRlcmZhbGwoKVwiXHJcbiAqIHBsdWdpbiBtYW5hZ2VtZW50XHJcbiAqL1xyXG5Bc3luY0N0eC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjYWxsYmFjayA9IHRoaXMuYXN5bmMoKTtcclxuXHRjYWxsYmFjayh0cnVlKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQXN5bmNDdHg7IiwiLy8gU3RvbGVuIGxpYmVyYWxseSBhbmQgYnJhemVubHkgZnJvbSBcInBvbGl0ZS1wbHVnaW4tbWFuYWdlclwiLlxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbmNvbnN0IHBsdWdpbkRpcmVjdG9yeVBhdGggPSBcIi4uLy4uL3BsdWdpbnMvXCJcclxuLy8gSGFjayB0byBjb21waWxlIEdsb2IgZmlsZXMgZm9yIGJyb3dzZXJpZnkuIERvbsK0dCBjYWxsIHRoaXMgZnVuY3Rpb24hXHJcbmZ1bmN0aW9uICRfRE9OT1RDQUxMKCkge1xyXG5cdHJlcXVpcmUoJy4uLy4uL3BsdWdpbnMvYmFsYW5jZS1zaGVldC1jb21wbGV4LmpzJyk7cmVxdWlyZSgnLi4vLi4vcGx1Z2lucy9iYWxhbmNlLXNoZWV0LmpzJylcclxufVxyXG5cclxuLyoqXHJcbiAqIFBvbGl0ZSBQbHVnaW4gTWFuYWdlclxyXG4gKiByZWdpc3RlciBhbmQgcnVuIGhvb2tzIGdyYW50aW5nIGV4dGVuZGFiaWxpdHlcclxuICpcclxuICovXHJcblxyXG5cclxuLy8gR2xvYmFsIERlcGVuZGVuY2llc1xyXG52YXIgZnMgPSByZXF1aXJlKCdmcycpLFxyXG5cdHBhdGggPSByZXF1aXJlKCdwYXRoJyksXHJcblx0YXN5bmMgPSByZXF1aXJlKCdhc3luYycpLFxyXG5cclxuXHQvLyBMb2NhbCBNb2R1bGVzXHJcblx0QXN5bmNDdHggPSByZXF1aXJlKCcuL2FzeW5jLWN0eCcpLFxyXG5cdFdhdGVyZmFsbEN0eCA9IHJlcXVpcmUoJy4vd2F0ZXJmYWxsLWN0eCcpLFxyXG5cdFBsdWdpbk5hbWVFcnJvciA9IHJlcXVpcmUoJy4vcGx1Z2luLW5hbWUtZXJyb3InKSxcclxuXHRQbHVnaW5DYWxsYmFja0Vycm9yID0gcmVxdWlyZSgnLi9wbHVnaW4tY2FsbGJhY2stZXJyb3InKTtcclxuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuLy8gLS0tW1sgICBDIE8gTiBTIFQgUiBVIEMgVCBPIFIgICBBIE4gRCAgIEwgSSBGIEUgQyBZIEMgTCBFICAgVSBUIEkgTCBJIFQgSSBFIFMgICBdXS0tIC8vXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG5cclxudmFyIFBsdWdpbk1hbmFnZXIgPSB7fSxcclxuXHRwYWNrYWdlcyA9IFtdLFxyXG5cdHBhY2thZ2VOYW1lcyA9IFtdLFxyXG5cdGhvb2tzID0ge30sXHJcblx0c2tpcFByb3BzID0gWydtb2R1bGUnLCAnbmFtZScsICdwcmlvcml0eScsICdhY3RpdmUnLCAnaW5pdCcsICdyZXF1aXJlJywgJ3N0b3AnLCAncHVibGljJywgJ3NldHRpbmdzJ107XHJcblxyXG5cclxuXHJcblBsdWdpbk1hbmFnZXIucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuXHRwYWNrYWdlcyA9IFtdO1xyXG5cdHBhY2thZ2VOYW1lcyA9IFtdO1xyXG5cdGhvb2tzID0ge307XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQXBwbHkgcGFja2FnZSBzb3J0aW5nLFxyXG4gKiByZWdpc3RlciBwYWNrYWdlcyBpbnRvIGhvb2tzLFxyXG4gKiBydW4gcGFja2FnZXMgaW5pdCgpIG1ldGhvZFxyXG4gKi9cclxuUGx1Z2luTWFuYWdlci5zdGFydCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblxyXG5cdHZhciBzZWxmID0gdGhpcyxcclxuXHRcdGluaXRzID0gW107XHJcblxyXG5cdC8vIHNvcnQgYnkgcHJpb3JpdGllc1xyXG5cdHBhY2thZ2VzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0cmV0dXJuIGEucHJpb3JpdHkgPiBiLnByaW9yaXR5O1xyXG5cdH0pO1xyXG5cclxuXHQvLyByZWdpc3RlciBpbml0ICYgaG9va3NcclxuXHQvLyBob29rcyBhcmUgYWxsIGZ1bmN0aW9ucyB3aG8gYXJlIG5vdCBzcGVjaWFsIHByb3BlcnRpZXNcclxuXHQvLyBpZGVudGlmaWVkIGJ5IFwic2tpcFByb3BzXCIgbGlzdFxyXG5cdHBhY2thZ2VzLmZvckVhY2goZnVuY3Rpb24ocGtnKSB7XHJcblx0XHRpZiAocGtnLmluaXQpIHtcclxuXHRcdFx0aW5pdHMucHVzaChwa2cuaW5pdCk7XHJcblx0XHR9XHJcblx0XHRmb3IgKHZhciBwcm9wIGluIHBrZykge1xyXG5cdFx0XHRpZiAoc2tpcFByb3BzLmluZGV4T2YocHJvcCkgPT09IC0xICYmIHR5cGVvZiBwa2dbcHJvcF0gPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdFBsdWdpbk1hbmFnZXIucmVnaXN0ZXJIb29rKHByb3AsIHBrZ1twcm9wXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0Ly8gcnVuIGFsbCBwYWNrYWdlLmluaXQoKSBtZXRob2QgaW4gc2VyaWVzIVxyXG5cdGlmIChpbml0cy5sZW5ndGgpIHtcclxuXHRcdGFzeW5jLmVhY2hTZXJpZXMoaW5pdHMsIGZ1bmN0aW9uKGZuLCBkb25lKSB7XHJcblxyXG5cdFx0XHR2YXIgY29udGV4dCA9IG5ldyBBc3luY0N0eChkb25lKSxcclxuXHRcdFx0XHRyZXN1bHQgPSBmbi5hcHBseShjb250ZXh0KTtcclxuXHJcblx0XHRcdC8vIHN5bmMgZmFsc2Ugc3RvcCBpbml0aWFsaXphdGlvbiBjeWNsZSFcclxuXHRcdFx0aWYgKGNvbnRleHQuc3luYykge1xyXG5cdFx0XHRcdGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHNlbGYpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRkb25lKHJlc3VsdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSwgY2FsbGJhY2suYmluZCh0aGlzKSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGNhbGxiYWNrLmNhbGwoc2VsZik7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG4vLyAtLS1bWyAgIEggTyBPIEsgUyAgIEEgUCBJICAgXV0tLS0gLy9cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblxyXG5QbHVnaW5NYW5hZ2VyLnJlZ2lzdGVySG9vayA9IGZ1bmN0aW9uKGhvb2tOYW1lLCBob29rRm4sIGhvb2tQcmlvcml0eSA9IDEwMCkge1xyXG5cdGhvb2tGbi5wcmlvcml0eSA9IGhvb2tQcmlvcml0eTtcclxuXHJcblx0aWYgKCFob29rc1tob29rTmFtZV0pIHtcclxuXHRcdGhvb2tzW2hvb2tOYW1lXSA9IFtdO1xyXG5cdH1cclxuXHJcblx0aG9va3NbaG9va05hbWVdLnB1c2goaG9va0ZuKTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG5QbHVnaW5NYW5hZ2VyLmlzRW1wdHkgPSBmdW5jdGlvbihob29rTmFtZSkge1xyXG5cdGlmIChob29rc1tob29rTmFtZV0gJiYgaG9va3NbaG9va05hbWVdLmxlbmd0aCkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSdW4gcmVnaXN0ZXJlZCBob29rIGNhbGxiYWNrcyBpbiBzZXJpZXNcclxuICogKGl0IHN1cHBvcnRzIGFzeW5jaHJvbm91cyBjYWxsYmFja3MpXHJcbiAqL1xyXG5QbHVnaW5NYW5hZ2VyLnJ1biA9IGZ1bmN0aW9uKGhvb2tOYW1lLCAuLi5hcmdzKSB7XHJcblxyXG5cdC8vIFVzZSB0aGUgcnVuV2l0aENhbGxiYWNrIGJ1dCB3aXRoIGJsYW5rIGNhbGxiYWNrLlxyXG5cdFBsdWdpbk1hbmFnZXIucnVuV2l0aENhbGxiYWNrKGhvb2tOYW1lLCAuLi5hcmdzLCBmdW5jdGlvbigpIHt9KVxyXG59O1xyXG5cclxuLy8gU2FtZSBhcyBhYm92ZSwgYnV0IHVzZSBsYXN0IGFyZ3VtZW50IGFzIGNhbGxiYWNrXHJcblBsdWdpbk1hbmFnZXIucnVuV2l0aENhbGxiYWNrID0gZnVuY3Rpb24oaG9va05hbWUsIC4uLmFyZ3MpIHtcclxuXHJcblx0Ly8gY29sbGVjdCBob29rTmFtZSBwcm9wZXJ0eVxyXG5cdGlmICghaG9va05hbWUpIHRocm93IG5ldyBQbHVnaW5OYW1lRXJyb3IoJ21pc3NpbmcgcGx1Z2luIG5hbWUhJyk7XHJcblxyXG5cdC8vIG9idGFpbiBhc3luYyBjYWxsYmFja1xyXG5cdGlmICghYXJncy5sZW5ndGggfHwgdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0dGhyb3cgbmV3IFBsdWdpbkNhbGxiYWNrRXJyb3IoJ1snICsgaG9va05hbWUgKyAnXSBtaXNzaW5nIGNhbGxiYWNrIGZvciBhc3luYyBwbHVnaW4hJyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XHJcblx0fVxyXG5cclxuXHJcblx0Ly8gY2hlY2sgZm9yIHNvbWUgY2FsbGJhY2tzIGV4aXN0YW5jZVxyXG5cdC8vIFs/Pz9dIG1heSBnaXZlIG91dCBhbiBleGNlcHRpb24gd2hlbiBubyBjYWxsYmFja3Mgd2VyZSBmb3VuZCFcclxuXHRpZiAoIWhvb2tzW2hvb2tOYW1lXSB8fCAhaG9va3NbaG9va05hbWVdLmxlbmd0aCkge1xyXG5cdFx0Y2FsbGJhY2soZmFsc2UpO1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Ly8gU29ydCBob29rcyBieSBwcmlvcml0eVxyXG5cdGhvb2tzW2hvb2tOYW1lXS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdHJldHVybiBhLnByaW9yaXR5ID4gYi5wcmlvcml0eVxyXG5cdH0pXHJcblxyXG5cdC8vIHJ1biBhc3luYyBxdWVxdWVcclxuXHQvLyBOT1RFOiBhIHN0ZXAgZnVuY3Rpb24gc2hvdWxkIHN0b3AgdGhlIHF1ZXF1ZSBieSBkb25lKHRydWUpXHJcblx0YXN5bmMuZWFjaFNlcmllcyhob29rc1tob29rTmFtZV0sIGZ1bmN0aW9uKGZuLCBkb25lKSB7XHJcblx0XHR2YXIgY29udGV4dCA9IG5ldyBBc3luY0N0eChkb25lKSxcclxuXHRcdFx0cmVzdWx0ID0gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblxyXG5cdFx0aWYgKGNvbnRleHQuc3luYykge1xyXG5cdFx0XHRpZiAocmVzdWx0ID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZG9uZShyZXN1bHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSwgY2FsbGJhY2spO1xyXG5cclxuXHRyZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJ1biByZWdpc3RlcmVkIGhvb2sgY2FsbGJhY2tzIGluIHBhcmFsbGVsXHJcbiAqIChpdCBzdXBwb3J0cyBhc3luY2hyb25vdXMgY2FsbGJhY2tzKVxyXG4gKiBAcGFyYW0gaG9va05hbWVcclxuICovXHJcblxyXG5QbHVnaW5NYW5hZ2VyLnBhcmFsbGVsID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHZhciBob29rTmFtZSA9ICcnLFxyXG5cdFx0Y2FsbGJhY2sgPSBudWxsLFxyXG5cdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcblxyXG5cdC8vIGNvbGxlY3QgaG9va05hbWUgcHJvcGVydHlcclxuXHRpZiAoIWFyZ3MubGVuZ3RoKSB7XHJcblx0XHR0aHJvdyBuZXcgUGx1Z2luTmFtZUVycm9yKCdtaXNzaW5nIHBsdWdpbiBuYW1lIScpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRob29rTmFtZSA9IGFyZ3Muc2hpZnQoKTtcclxuXHR9XHJcblxyXG5cdC8vIG9idGFpbiBhc3luYyBjYWxsYmFja1xyXG5cdGlmICghYXJncy5sZW5ndGggfHwgdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0dGhyb3cgbmV3IFBsdWdpbkNhbGxiYWNrRXJyb3IoJ1snICsgaG9va05hbWUgKyAnXSBtaXNzaW5nIGNhbGxiYWNrIGZvciBhc3luYyBwbHVnaW4hJyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGNhbGxiYWNrID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xyXG5cdH1cclxuXHJcblx0Ly8gY2hlY2sgZm9yIHNvbWUgY2FsbGJhY2tzIGV4aXN0YW5jZVxyXG5cdC8vIFs/Pz9dIG1heSBnaXZlIG91dCBhbiBleGNlcHRpb24gd2hlbiBubyBjYWxsYmFja3Mgd2VyZSBmb3VuZCFcclxuXHRpZiAoIWhvb2tzW2hvb2tOYW1lXSB8fCAhaG9va3NbaG9va05hbWVdLmxlbmd0aCkge1xyXG5cdFx0Y2FsbGJhY2soZmFsc2UpO1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Ly8gcnVuIGFzeW5jIGluIHBhcmFsbGVsXHJcblx0Ly8gTk9URTogYSBzdGVwIGZ1bmN0aW9uIHNob3VsZCBzdG9wIHRoZSBxdWVxdWUgYnkgZG9uZSh0cnVlKVxyXG5cdGFzeW5jLmVhY2goaG9va3NbaG9va05hbWVdLCBmdW5jdGlvbihmbiwgZG9uZSkge1xyXG5cdFx0dmFyIGNvbnRleHQgPSBuZXcgQXN5bmNDdHgoZG9uZSksXHJcblx0XHRcdHJlc3VsdCA9IGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG5cclxuXHRcdC8vIGhhbmRsZSBzeW5jIGNhbGxiYWNrc1xyXG5cdFx0aWYgKGNvbnRleHQuc3luYykge1xyXG5cdFx0XHRkb25lKHJlc3VsdCk7XHJcblx0XHR9XHJcblx0fSwgY2FsbGJhY2spO1xyXG5cclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogV0FURVJGQUxMXHJcbiAqIFJ1biBhIGhvb2sgYXMgYSBub3JtYWwgZnVuY3Rpb24gaW4gYSBmdWxseSBzeW5jcm9ub3VzIG1vZGVcclxuICogRWFjaCBob29rRm4gc2hvdWxkIHJldHVybiBhIHZhbHVlIHdobydzIGZvcndhcmQgYXMgZmlyc3QgYXJndW1lbnQgZm9yIHRoZSBuZXh0IG9uZVxyXG4gKiBsYXN0IGhvb2tGbiByZXR1cm4gdmFsdWUgaXMgdGhlIGZpbmFsIG91dHB1dFxyXG4gKi9cclxuUGx1Z2luTWFuYWdlci53YXRlcmZhbGwgPSBmdW5jdGlvbihob29rTmFtZSkge1xyXG5cclxuXHRpZiAoIWhvb2tOYW1lKSB7XHJcblx0XHR0aHJvdyBuZXcgUGx1Z2luTmFtZUVycm9yKCdtaXNzaW5nIHBsdWdpbiBuYW1lIScpO1xyXG5cdH1cclxuXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG5cdGFyZ3Muc2hpZnQoKTtcclxuXHJcblx0aWYgKGhvb2tzW2hvb2tOYW1lXSkge1xyXG5cdFx0Ly8gdXNlIGtub3duIGV4Y2VwdGlvbiB0byBleGl0IGZvckVhY2ggY3ljbGUgaW1wbGVtZW50aW5nIGEgc3RvcHBhYmxlIHdhdGVmYWxsXHJcblx0XHQvLyAoaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNjQxMzQ3L2hvdy10by1zaG9ydC1jaXJjdWl0LWFycmF5LWZvcmVhY2gtbGlrZS1jYWxsaW5nLWJyZWFrP2Fuc3dlcnRhYj12b3RlcyN0YWItdG9wKVxyXG5cdFx0dmFyIFdhdGVyZmFsbEJyZWFrRXhjZXB0aW9uID0ge307XHJcblx0XHR0cnkge1xyXG5cdFx0XHRob29rc1tob29rTmFtZV0uZm9yRWFjaChmdW5jdGlvbihmbikge1xyXG5cdFx0XHRcdHZhciBjb250ZXh0ID0gbmV3IFdhdGVyZmFsbEN0eCgpLFxyXG5cdFx0XHRcdFx0cmVzdWx0ID0gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblxyXG5cdFx0XHRcdGlmIChhcmdzLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0YXJnc1swXSA9IHJlc3VsdDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjb250ZXh0LnN0b3BwZWQpIHtcclxuXHRcdFx0XHRcdHRocm93IFdhdGVyZmFsbEJyZWFrRXhjZXB0aW9uO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0pO1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRpZiAoZSAhPT0gV2F0ZXJmYWxsQnJlYWtFeGNlcHRpb24pIHRocm93IGU7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAoYXJncy5sZW5ndGgpIHtcclxuXHRcdHJldHVybiBhcmdzWzBdO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcbi8vIC0tLVtbICAgUCBBIEMgSyBBIEcgRSBTICAgQSBQIEkgICBdXS0tLSAvL1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHJcbmZ1bmN0aW9uIGdldFBhY2thZ2VCeU5hbWUobmFtZSkge1xyXG5cdHZhciBsaXN0ID0gcGFja2FnZXMuZmlsdGVyKGZ1bmN0aW9uKHBrZykgeyByZXR1cm4gKHBrZy5uYW1lID09PSBuYW1lKSB9KVxyXG5cdGlmIChsaXN0Lmxlbmd0aCA9PSAxKSByZXR1cm4gbGlzdFswXVxyXG5cdGVsc2UgcmV0dXJuIGxpc3Q7XHJcbn1cclxuXHJcbi8vIFBhY2thZ2UgY2xhc3NcclxuZnVuY3Rpb24gUGFja2FnZShtb2R1bGUsIG5hbWUgPSBudWxsLCBjb250ZXh0ID0gbnVsbCkge1xyXG5cdC8vIEJhc2ljIGFzc2lnbm1lbnQgYW5kIGRlZmF1bHQgdmFsdWVzXHJcblx0T2JqZWN0LmFzc2lnbih0aGlzLCB7XHJcblx0XHRtb2R1bGUsXHJcblx0XHRuYW1lLFxyXG5cdFx0cHJpb3JpdHk6IDEwMCxcclxuXHRcdGFjdGl2ZTogZmFsc2UsXHJcblx0XHRpbml0OiBmdW5jdGlvbigpIHt9LFxyXG5cdFx0cmVxdWlyZTogZnVuY3Rpb24oKSB7fSxcclxuXHRcdHN0b3A6IGZ1bmN0aW9uKCkge30sXHJcblx0XHRzZXR0aW5nczogZnVuY3Rpb24oKSB7fSxcclxuXHRcdHB1YmxpYzoge31cclxuXHR9KVxyXG5cdC8vIFBhY2thZ2UtZGVmaW5lZCB2YWx1ZXMgYW5kIGhvb2tzXHJcblx0T2JqZWN0LmFzc2lnbih0aGlzLCBtb2R1bGUoY29udGV4dCB8fCB7fSkpXHJcblxyXG5cdC8vIGFkZCB0byByZWdpc3RyeVxyXG5cdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHRoZSBzYW1lIG1vZHVsZSBiZWluZyBsb2FkZWQgdHdpY2UsIG9yIGRpZmZlcmVudCBtb2R1bGVzIHdpdGggdGhlIHNhbWUgbmFtZVxyXG5cdGlmIChwYWNrYWdlTmFtZXMuaW5jbHVkZXModGhpcy5uYW1lKSkge1xyXG5cdFx0aWYgKHRoaXMubW9kdWxlID09PSBnZXRQYWNrYWdlQnlOYW1lKHRoaXMubmFtZSkubW9kdWxlKSB7XHJcblx0XHRcdC8vIFNhbWUgbW9kdWxlLiBEbyBub3RoaW5nXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBEaWZmZXJlbnQgbW9kdWxlcyB3aXRoIHNhbWUgbmFtZSwgaGFuZGxlIG5hbWUgY29uZmxpY3QuXHJcblx0XHRcdC8vVE9ETzogZmlndXJlIG91dCBob3cgdG8gaGFuZGxlIG5hbWUgY29uZmxpY3QuXHJcblx0XHR9XHJcblx0fVxyXG5cdC8vIE5vIG5hbWUgY29uZmxpY3QsIGFkZCB0byByZWdpc3RyeVxyXG5cdGVsc2Uge1xyXG5cdFx0cGFja2FnZXMucHVzaCh0aGlzKTtcclxuXHRcdHBhY2thZ2VOYW1lcy5wdXNoKHRoaXMubmFtZSlcclxuXHR9XHJcbn1cclxuXHJcblBhY2thZ2UucHJvdG90eXBlLnJlZ2lzdGVySG9va3MgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgcGtnID0gdGhpcztcclxuXHRmb3IgKHZhciBwcm9wIGluIHBrZykge1xyXG5cdFx0aWYgKHNraXBQcm9wcy5pbmRleE9mKHByb3ApID09PSAtMSAmJiB0eXBlb2YgcGtnW3Byb3BdID09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0UGx1Z2luTWFuYWdlci5yZWdpc3Rlckhvb2socHJvcCwgcGtnW3Byb3BdKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbi8vIENyZWF0ZSBpbnRlcmZhY2UgZm9yIHVzZXIgdG8gaW50ZXJhY3Qgd2l0aCBwYWNrYWdlLlxyXG5mdW5jdGlvbiBQYWNrYWdlSW50ZXJmYWNlKHBrZykge1xyXG5cclxuXHQvLyBNZXJnZSBhbnkgcHVibGljIGl0ZW1zIHNwZWNpZmllZCBieSB0aGUgcGFja2FnZSB3aXRoIHRoaXMgaW50ZXJmYWNlIGZvcm1hdFxyXG5cdHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwa2cucHVibGljLCB7XHJcblx0XHRuYW1lOiBmdW5jdGlvbigpIHsgcmV0dXJuIHBrZy5uYW1lIH0sXHJcblx0XHRwcmlvcml0eTogZnVuY3Rpb24oKSB7IHJldHVybiBwa2cucHJpb3JpdHkgfSxcclxuXHRcdGFjdGl2ZTogZnVuY3Rpb24oKSB7IHJldHVybiBwa2cuYWN0aXZlIH0sXHJcblxyXG5cdFx0aW5pdDogZnVuY3Rpb24oLi4uYXJncykge1xyXG5cdFx0XHRwa2cuaW5pdCguLi5hcmdzKTtcclxuXHRcdFx0cGtnLnJlZ2lzdGVySG9va3MoKTtcclxuXHRcdFx0cGtnLmFjdGl2ZSA9IHRydWU7XHJcblx0XHRcdHJldHVybiBPYmplY3QuYXNzaWduKHRoaXMsIHBrZy5wdWJsaWNJZkFjdGl2ZSk7XHJcblx0XHR9LFxyXG5cdFx0cmVxdWlyZTogZnVuY3Rpb24oLi4uYXJncykge1xyXG5cdFx0XHRpZiAocGtnLmFjdGl2ZSkgcGtnLnJlcXVpcmUoLi4uYXJncyk7XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHBrZy5pbml0KC4uLmFyZ3MpO1xyXG5cdFx0XHRcdHBrZy5yZWdpc3Rlckhvb2tzKCk7XHJcblx0XHRcdFx0T2JqZWN0LmFzc2lnbih0aGlzLCBwa2cucHVibGljSWZBY3RpdmUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHBrZy5hY3RpdmUgPSB0cnVlO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9LFxyXG5cdFx0c3RvcDogZnVuY3Rpb24oLi4uYXJncykge1xyXG5cdFx0XHRpZiAocGtnLmFjdGl2ZSkgcGtnLnN0b3AoLi4uYXJncyk7XHJcblx0XHRcdHBrZy5hY3RpdmUgPSBmYWxzZTtcclxuXHRcdH0sXHJcblx0XHRzZXR0aW5nczogZnVuY3Rpb24oLi4uYXJncykge1xyXG5cdFx0XHRyZXR1cm4gcGtnLnNldHRpbmdzKC4uLmFyZ3MpO1xyXG5cdFx0fVxyXG5cclxuXHR9LCBwa2cuYWN0aXZlID8gcGtnLnB1YmxpY0lmQWN0aXZlIDogbnVsbCk7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBMb2FkIGEgcGx1Z2luIHBhY2thZ2UgYnkgZm9sZGVyIHBhdGhcclxuICogQHBhcmFtIHNvdXJjZUZvbGRlclxyXG4gKi9cclxuUGx1Z2luTWFuYWdlci5wYWNrYWdlID0gZnVuY3Rpb24oc291cmNlLCBjb250ZXh0KSB7XHJcblx0aWYgKHBhY2thZ2VOYW1lcy5pbmNsdWRlcyhzb3VyY2UpKSB7XHJcblx0XHQvLyBBbHJlYWR5IGxvYWRlZCBtb2R1bGUsIGp1c3QgcmV0dXJuIGl0XHJcblx0XHRyZXR1cm4gUGFja2FnZUludGVyZmFjZShnZXRQYWNrYWdlQnlOYW1lKHNvdXJjZSkpXHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBuYW1lID0gcGF0aC5iYXNlbmFtZShzb3VyY2UpLFxyXG5cdFx0XHRtb2R1bGUgPSByZXF1aXJlKHBsdWdpbkRpcmVjdG9yeVBhdGggKyBzb3VyY2UgKyAnLmpzJylcclxuXHJcblx0XHQvLyBvYnRhaW4gcGFja2FnZSBpbmZvcm1hdGlvbnMgYW5kIGFwcGx5IHNvbWUgZGVmYXVsdCB2YWx1ZXNcclxuXHRcdHZhciBwa2cgPSBuZXcgUGFja2FnZShtb2R1bGUsIG5hbWUsIGNvbnRleHQpXHJcblx0XHRyZXR1cm4gUGFja2FnZUludGVyZmFjZShwa2cpXHJcblx0fVxyXG59XHJcblxyXG4vKlxyXG5cdFx0XHRsb2FkOiBmdW5jdGlvbihjYWxsYmFjayA9IGZ1bmN0aW9uKCkge30sIC4uLmluaXRBcmdzKSB7XHJcblx0XHRcdFx0dmFyIHNlbGYgPSBwbSxcclxuXHRcdFx0XHRcdGluaXRzID0gW10sXHJcblxyXG5cclxuXHRcdFx0XHRcdC8vIHJlZ2lzdGVyIGluaXQgJiBob29rc1xyXG5cdFx0XHRcdFx0Ly8gaG9va3MgYXJlIGFsbCBmdW5jdGlvbnMgd2hvIGFyZSBub3Qgc3BlY2lhbCBwcm9wZXJ0aWVzXHJcblx0XHRcdFx0XHQvLyBpZGVudGlmaWVkIGJ5IFwic2tpcFByb3BzXCIgbGlzdFxyXG5cclxuXHRcdFx0XHRcdGlmIChwa2cuaW5pdCkge1xyXG5cdFx0XHRcdFx0XHRpbml0cy5wdXNoKHBrZy5pbml0KTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRcdC8vIHJ1biBhbGwgcGFja2FnZS5pbml0KCkgbWV0aG9kIGluIHNlcmllcyEgLy9FRElUOiB3aWxsIG9ubHkgYmUgdGhlIG9uZVxyXG5cdFx0XHRcdGlmIChpbml0cy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdGFzeW5jLmVhY2hTZXJpZXMoaW5pdHMsIGZ1bmN0aW9uKGZuLCBkb25lKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgY29udGV4dCA9IG5ldyBBc3luY0N0eChkb25lKSxcclxuXHRcdFx0XHRcdFx0XHRyZXN1bHQgPSBmbi5hcHBseShjb250ZXh0LCBpbml0QXJncyk7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBzeW5jIGZhbHNlIHN0b3AgaW5pdGlhbGl6YXRpb24gY3ljbGUhXHJcblx0XHRcdFx0XHRcdGlmIChjb250ZXh0LnN5bmMpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAocmVzdWx0ID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2suY2FsbChzZWxmKTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0ZG9uZShyZXN1bHQpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0sIGNhbGxiYWNrLmJpbmQoc2VsZikpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHNlbGYpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHNlbGY7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cdH07XHJcbiovXHJcblxyXG4vKiogVE9ETzogdGhpcyBkb2Vzbid0IHdvcmsgcmlnaHQgbm93XHJcbiAqIExvYWQgYWxsIHBhY2thZ2VzIGZyb20gYSBnaXZlbiBmb2xkZXIgcGF0aFxyXG4gKiAoc3luY3Jvbm91cylcclxuICovXHJcblBsdWdpbk1hbmFnZXIucmVnaXN0ZXJNYW55ID0gZnVuY3Rpb24oc291cmNlRm9sZGVyLCBjb250ZXh0KSB7XHJcblx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuXHRpZiAoZnMuZXhpc3RzU3luYyhzb3VyY2VGb2xkZXIpKSB7XHJcblx0XHRmcy5yZWFkZGlyU3luYyhzb3VyY2VGb2xkZXIpLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG5cdFx0XHR2YXIgaXRlbVBhdGggPSBzb3VyY2VGb2xkZXIgKyAnLycgKyBpdGVtLFxyXG5cdFx0XHRcdGl0ZW1TdGF0ID0gZnMubHN0YXRTeW5jKGl0ZW1QYXRoKTtcclxuXHJcblx0XHRcdGlmIChpdGVtU3RhdC5pc0RpcmVjdG9yeSgpKSB7XHJcblx0XHRcdFx0c2VsZi5sb2FkUGFja2FnZShpdGVtUGF0aCwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBsdWdpbk1hbmFnZXJcclxuIiwiXHJcbmZ1bmN0aW9uIFBsdWdpbkNhbGxiYWNrRXJyb3IobWVzc2FnZSkge1xyXG5cdHRoaXMubmFtZSA9IFwiUGx1Z2luQ2FsbGJhY2tFcnJvclwiO1xyXG5cdHRoaXMubWVzc2FnZSA9IChtZXNzYWdlIHx8IFwiXCIpO1xyXG59XHJcblxyXG5cclxuUGx1Z2luQ2FsbGJhY2tFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcclxuUGx1Z2luQ2FsbGJhY2tFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbHVnaW5DYWxsYmFja0Vycm9yO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQbHVnaW5DYWxsYmFja0Vycm9yOyIsIlxyXG5mdW5jdGlvbiBQbHVnaW5OYW1lRXJyb3IobWVzc2FnZSkge1xyXG5cdHRoaXMubmFtZSA9IFwiUGx1Z2luTmFtZUVycm9yXCI7XHJcblx0dGhpcy5tZXNzYWdlID0gKG1lc3NhZ2UgfHwgXCJcIik7XHJcbn1cclxuXHJcblxyXG5QbHVnaW5OYW1lRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XHJcblBsdWdpbk5hbWVFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbHVnaW5OYW1lRXJyb3I7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBsdWdpbk5hbWVFcnJvcjsiLCIvKipcclxuICpcclxuICogQHR5cGUge3t9fVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIFdhdGVyZmFsbEN0eCgpIHtcclxuXHR0aGlzLnN0b3BwZWQgPSBmYWxzZTtcclxufVxyXG5cclxuV2F0ZXJmYWxsQ3R4LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5zdG9wcGVkID0gdHJ1ZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gV2F0ZXJmYWxsQ3R4OyIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpc0Z1bmN0aW9uLCBpc09iamVjdCB9ID0gcmVxdWlyZShcIi4vaGVscGVyLWZ1bmN0aW9uc1wiKShcImdlbmVyYWxcIik7XHJcblxyXG4vL0dhbWUgc3RhdGUgY29udHJvbGxlcnNcclxudmFyIHsgcmVnaXN0cnkgfSA9IHJlcXVpcmUoXCIuL3N0YXRlXCIpO1xyXG5cclxudmFyIHsgX1BsYXllciB9ID0gcmVxdWlyZShcIi4vcGxheWVyXCIpO1xyXG5cclxuLy9DbGFzcyBQbGF5ZXJMaXN0IGlzIGEgbGlzdCBvZiBwbGF5ZXJzIHdoaWNoIGluY2x1ZGVzIHNvbWUgZXh0cmEgZnVuY3Rpb25hbGl0eS4gVXNlclBsYXllckxpc3QgdGFrZXMgYSBwbGF5ZXJMaXN0IGFuZFxyXG4vL3Nhbml0aXplcyBpdCBmb3IgdGhlIHVzZXIgKGllIHJldHVybnMgLmludGVyZmFjZSBmb3IgZWFjaCBwbGF5ZXIpLlxyXG5cclxuZnVuY3Rpb24gUGxheWVyTGlzdCguLi5hcmdzKSB7XHJcblx0aWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIGFyZ3MgPSBhcmdzWzBdLnNsaWNlKDApO1xyXG5cdGlmIChhcmdzID09IFwiYWxsXCIpIHJldHVybiBnYW1lUG9wdWxhdGlvbigpO1xyXG5cclxuXHQvLyBXZSdsbCBuZWVkIHRvIHJldGFpbiB0aGUgb3JpZ2luYWwgYXJndW1lbnRzIGluIG9yZGVyIHRvIGNyZWF0ZSB0aGUgZ2VuZXJhdG9yXHJcblx0dmFyIG9yaWdpbmFsQXJncyA9IFtdXHJcblxyXG5cdC8vIExvb3Agb3ZlciB0aGUgYXJndW1lbnRzLCBzYXZlIHRoZSBvcmlnaW5hbHMsIHBhcnNlIHRoZW0gdG8gX3BsYXllcnNcclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gYXJncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0b3JpZ2luYWxBcmdzLnB1c2goYXJnc1tpXSk7XHJcblx0XHRpZiAoaXNGdW5jdGlvbihhcmdzW2ldLmlkKSkgYXJnc1tpXSA9IHJlZ2lzdHJ5LnBsYXllcnNbYXJnc1tpXS5pZCgpXTtcclxuXHRcdGVsc2UgaWYgKHR5cGVvZiBhcmdzW2ldID09PSAnc3RyaW5nJykgYXJnc1tpXSA9IHJlZ2lzdHJ5LnBsYXllcnNbYXJnc1tpXV1cclxuXHR9XHJcblxyXG5cdE9iamVjdC5zZXRQcm90b3R5cGVPZihhcmdzLCBQbGF5ZXJMaXN0LnByb3RvdHlwZSk7XHJcblxyXG5cdC8vIHJldHVybnMgdGhlIHNhbWUgcGxheWVybGlzdCwgYnV0IHVwZGF0ZWQsIHVzaW5nIHRoZSBvcmlnaW5hbCBhcmdzLlxyXG5cdGFyZ3MuZ2VuZXJhdG9yID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBsYXllckxpc3Qob3JpZ2luYWxBcmdzKTtcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gYXJncztcclxufVxyXG5cclxuUGxheWVyTGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFycmF5LnByb3RvdHlwZSk7XHJcblBsYXllckxpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGxheWVyTGlzdDtcclxuXHJcblxyXG4vLyBBc3NpZ24gYSBzdHJhdGVneSBlbiBtYXNzZVxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5hc3NpZ24gPSBmdW5jdGlvbihzdHJhdGVneU5hbWUpIHtcclxuXHR0aGlzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRwbGF5ZXIuYXNzaWduKHN0cmF0ZWd5TmFtZSlcclxuXHR9KVxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5cclxuLy9SZXR1cm4gYSBQbGF5ZXJMaXN0IG1pbnVzIHRoZSBzcGVjaWZpZWQgcGxheWVycy5cclxuLy9Bcmd1bWVudCBjYW4gYmUgX3BsYXllciwgaW50ZXJmYWNlLCBvciBhIHBsYXllcidzIGlkLlxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5leGNsdWRlID0gZnVuY3Rpb24ocGxheWVyQXJnKSB7XHJcblx0aWYgKEFycmF5LmlzQXJyYXkocGxheWVyQXJnKSlcclxuXHRcdHJldHVybiBwbGF5ZXJBcmcucmVkdWNlKGZ1bmN0aW9uKHJ1bm5pbmcsIGl0ZW0pIHtcclxuXHRcdFx0cmV0dXJuIHJ1bm5pbmcuZXhjbHVkZShpdGVtKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRyZXR1cm4gbmV3IFBsYXllckxpc3QoXHJcblx0XHR0aGlzLmZpbHRlcihmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0aWYgKFxyXG5cdFx0XHRcdHBsYXllckFyZyA9PT0gcGxheWVyIHx8XHJcblx0XHRcdFx0cGxheWVyQXJnID09IHBsYXllci5pbnRlcmZhY2UgfHxcclxuXHRcdFx0XHRwbGF5ZXJBcmcgPT0gcGxheWVyLmlkIHx8XHJcblx0XHRcdFx0KGlzT2JqZWN0KHBsYXllckFyZykgJiYgcGxheWVyQXJnLmlkID09IHBsYXllci5pZClcclxuXHRcdFx0KVxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0ZWxzZSByZXR1cm4gdHJ1ZTtcclxuXHRcdH0pXHJcblx0KTtcclxufTtcclxuXHJcblxyXG4vLyBQbGFjZWhvbGRlciBmb3IgZ2VuZXJhdG9yIG1ldGhvZC5cclxuUGxheWVyTGlzdC5wcm90b3R5cGUuZ2VuZXJhdG9yID0gZnVuY3Rpb24oKSB7XHJcblx0Ly8gVGhpcyB3aWxsIGdldCBzaGFkb3dlZCB3aGVuIHRoZSBjb25zdHJ1Y3RvciBpcyBjYWxsZWQsIGJ1dCBpdCBuZWVkcyB0byBiZSBoZXJlIHNvIHRoYXQgdGhlXHJcblx0Ly8gVXNlclBsYXllckxpc3QgYW5kIEluZm9QbGF5ZXJMaXN0IGNvbnN0cnVjdG9ycyBjYW4gc2VlIGl0LlxyXG59XHJcblxyXG5cclxuLy9DcmVhdGUgYW4gSW5mb1BsYXllckxpc3Qgb3V0IG9mIHRoaXMgUGxheWVyTGlzdC4gVXNlZnVsIGZvciBnZXR0aW5nIHN1bW1hcnkgdmlldy5cclxuUGxheWVyTGlzdC5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgSW5mb1BsYXllckxpc3QodGhpcyk7XHJcbn07XHJcblxyXG5cclxuLy9SZXR1cm4gYXJyYXkgb2YgaWRzIG9mIGVhY2ggcGxheWVyIGluIHRoZSBsaXN0XHJcblBsYXllckxpc3QucHJvdG90eXBlLmlkcyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHJldHVybiBwbGF5ZXIuaWQ7XHJcblx0fSk7XHJcbn07XHJcblxyXG5cclxuLy9LaWxsIGFsbCBwbGF5ZXJzIGluIHRoZSBwbGF5ZXJMaXN0XHJcblBsYXllckxpc3QucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRwbGF5ZXIua2lsbCgpO1xyXG5cdH0pO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuXHJcbi8vUmV0dXJucyB0aGUgc2luZ2xlIHBsYXllciB3aXRoIHRoZSBoaWdoZXN0IHNjb3JlXHJcblBsYXllckxpc3QucHJvdG90eXBlLmxlYWRlciA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBwbGF5ZXJzID0gdGhpcy5zbGljZSgpO1xyXG5cclxuXHRwbGF5ZXJzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0cmV0dXJuIGIuc2NvcmUgLSBhLnNjb3JlO1xyXG5cdH0pO1xyXG5cclxuXHRwbGF5ZXJzID0gcGxheWVycy5maWx0ZXIoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRyZXR1cm4gcGxheWVyLnNjb3JlID09IHBsYXllcnNbMF0uc2NvcmVcclxuXHR9KVxyXG5cclxuXHJcblx0cmV0dXJuIHBsYXllcnMubGVuZ3RoID4gMSA/IG5ldyBQbGF5ZXJMaXN0KHBsYXllcnMpIDogcGxheWVyc1swXTtcclxufTtcclxuXHJcblxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0cGxheWVyLmF2YWlsYWJsZSA9IHRydWU7XHJcblx0fSk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5cclxuXHJcbi8vUmV0dXJuIGEgcGxheWVyTGlzdCB3aXRoIG9ubHkgdGhlIHBsYXllcnMgd2hvIGFyZSBhdmFpbGFibGVcclxuUGxheWVyTGlzdC5wcm90b3R5cGUub25seUFsaXZlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBQbGF5ZXJMaXN0KFxyXG5cdFx0dGhpcy5maWx0ZXIoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdHJldHVybiBwbGF5ZXIuYWxpdmU7XHJcblx0XHR9KVxyXG5cdCk7XHJcbn07XHJcblxyXG5cclxuLy9SZXR1cm4gYSBwbGF5ZXJMaXN0IHdpdGggb25seSB0aGUgcGxheWVycyB3aG8gYXJlIGF2YWlsYWJsZVxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5vbmx5QXZhaWxhYmxlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBQbGF5ZXJMaXN0KFxyXG5cdFx0dGhpcy5maWx0ZXIoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdHJldHVybiBwbGF5ZXIuYXZhaWxhYmxlO1xyXG5cdFx0fSlcclxuXHQpO1xyXG59O1xyXG5cclxuXHJcbi8vUmV0dXJucyBhbiBhcnJheSBvZiBzY29yZXMgb2YgZWFjaCBwbGF5ZXIgaW4gdGhlIGxpc3RcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuc2NvcmVzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIHNjb3JlcyA9IFtdO1xyXG5cclxuXHR0aGlzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRzY29yZXMucHVzaChwbGF5ZXIuc2NvcmUpOyAvL1VzZSB0aGUgaW50ZXJmYWNlIGZ1bmN0aW9uIHRvIGF2b2lkIHVzZXJzIHJlLWFzc2lnbmluZyB0aGUgcmVmZXJlbmNlXHJcblx0fSk7XHJcblx0cmV0dXJuIHNjb3JlcztcclxufTtcclxuXHJcblxyXG4vLyBSZXR1cm5zIGFuIG9iamVjdCB3aGVyZSBlYWNoIGtleSBpcyBhIHN0cmF0ZWd5IGFuZCBlYWNoIHZhbHVlIGlzIGFuIGFycmF5IG9mIHRoZSBzY29yZXMgb2YgcGxheWVycyB3aXRoIHRoYXQgc3RyYXRlZ3kuXHJcbi8vIFRPRE86IGZpbmlzaCAudG90YWwoKSBtZXRob2QsIHdoaWNoIHdpbGwgc3VtIHRoZSBhcnJheXMgKGR1cGxpY2F0aW5nIC5zY29yZXNCeVN0cmF0ZWd5VG90YWxzKVxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5zY29yZXNCeVN0cmF0ZWd5ID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIHNjb3JlcyA9IHt9O1xyXG5cdHZhciBsaXN0ID0gdGhpcztcclxuXHJcblx0bGlzdC5zdHJhdGVnaWVzKCkubWFwKGZ1bmN0aW9uKHN0cmF0ZWd5KSB7XHJcblx0XHRzY29yZXNbc3RyYXRlZ3ldID0gbGlzdC51c2luZ1N0cmF0ZWd5KHN0cmF0ZWd5KS5zY29yZXMoKTtcclxuXHR9KTtcclxuXHJcblx0c2NvcmVzLnRvdGFsID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgc2NvcmUgPSB7fTtcclxuXHRcdHZhciBzY29yZXMgPSB0aGlzO1xyXG5cdFx0T2JqZWN0LmtleXMoc2NvcmVzKS5mb3JFYWNoKGZ1bmN0aW9uKHN0cmF0ZWd5KSB7XHJcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHNjb3Jlc1tzdHJhdGVneV0pKSBzY29yZVtzdHJhdGVneV0gPSBzY29yZXNbc3RyYXRlZ3ldLnJlZHVjZShmdW5jdGlvbihhLCBiKSB7XHJcblx0XHRcdFx0cmV0dXJuIGEgKyBiO1xyXG5cdFx0XHR9LCAwKTtcclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIHNjb3JlO1xyXG5cdH07XHJcblxyXG5cdHJldHVybiBzY29yZXM7XHJcbn07XHJcblxyXG4vLyBSZXR1cm5zIGFuIG9iamVjdCB3aGVyZSBlYWNoIGtleSBpcyBhIHN0cmF0ZWd5IGFuZCBlYWNoIHZhbHVlIGlzIHRoZSBzdW0gb2Ygc2NvcmVzIG9mIGFsbCBwbGF5ZXJzIHdpdGggdGhhdCB2YWx1ZVxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS5zY29yZXNCeVN0cmF0ZWd5VG90YWxzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIHNjb3JlcyA9IHt9O1xyXG5cdHZhciBsaXN0ID0gdGhpcztcclxuXHJcblx0bGlzdC5zdHJhdGVnaWVzKCkubWFwKGZ1bmN0aW9uKHN0cmF0ZWd5KSB7XHJcblx0XHRzY29yZXNbc3RyYXRlZ3ldID0gbGlzdFxyXG5cdFx0XHQudXNpbmdTdHJhdGVneShzdHJhdGVneSlcclxuXHRcdFx0LnNjb3JlcygpXHJcblx0XHRcdC5yZWR1Y2UoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0XHRcdHJldHVybiBhICsgYjtcclxuXHRcdFx0fSwgMCk7XHJcblx0fSk7XHJcblxyXG5cdHJldHVybiBzY29yZXM7XHJcbn07XHJcblxyXG4vL1JldHVybnMgYW4gb2JqZWN0IHdoZXJlIHRoZSBrZXlzIGFyZSB0aGUgcGxheWVyIGlkcyBhbmQgdGhlIHZhbHVlc1xyXG4vL2FyZSB0aGUgcGxheWVycycgc2NvcmVcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuc2NvcmVzT2JqZWN0ID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIHNjb3JlcyA9IHt9O1xyXG5cclxuXHR0aGlzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRzY29yZXNbcGxheWVyLmlkXSA9IHBsYXllci5zY29yZTtcclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIHNjb3JlcztcclxufTtcclxuXHJcbi8vTWVhbiBvZiB0aGUgc2NvcmVzXHJcblBsYXllckxpc3QucHJvdG90eXBlLnNjb3Jlc01lYW4gPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc2NvcmVzID0gdGhpcy5zY29yZXMoKTtcclxuXHJcblx0dmFyIG1lYW4gPVxyXG5cdFx0c2NvcmVzLnJlZHVjZShmdW5jdGlvbihzdW0sIHZhbHVlKSB7XHJcblx0XHRcdHJldHVybiBzdW0gKyB2YWx1ZTtcclxuXHRcdH0sIDApIC8gc2NvcmVzLmxlbmd0aDtcclxuXHJcblx0cmV0dXJuIG1lYW47XHJcbn07XHJcblxyXG4vL0FycmF5IHdpdGggMiBlbnRyaWVzLCB0aGUgbG93ZXN0IGFuZCBoaWdoZXN0IHNjb3JlXHJcblBsYXllckxpc3QucHJvdG90eXBlLnNjb3Jlc1JhbmdlID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIHNjb3JlcyA9IHRoaXMuc2NvcmVzKCk7XHJcblxyXG5cdHNjb3Jlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdHJldHVybiBhIC0gYjtcclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIFtzY29yZXNbMF0sIHNjb3Jlc1tzY29yZXMubGVuZ3RoIC0gMV1dO1xyXG59O1xyXG5cclxuLy9UaGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSBzY29yZXNcclxuUGxheWVyTGlzdC5wcm90b3R5cGUuc2NvcmVzU3RkID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIHNjb3JlcyA9IHRoaXMuc2NvcmVzKCk7XHJcblx0dmFyIG1lYW4gPSB0aGlzLnNjb3Jlc01lYW4oKTtcclxuXHJcblx0dmFyIHZhcmlhbmNlID1cclxuXHRcdHNjb3Jlcy5yZWR1Y2UoZnVuY3Rpb24oc3VtLCB2YWx1ZSkge1xyXG5cdFx0XHRyZXR1cm4gc3VtICsgTWF0aC5wb3codmFsdWUgLSBtZWFuLCAyKTtcclxuXHRcdH0sIDApIC8gc2NvcmVzLmxlbmd0aDtcclxuXHJcblx0dmFyIHN0ZCA9IE1hdGguc3FydCh2YXJpYW5jZSk7XHJcblxyXG5cdHJldHVybiBzdGQ7XHJcbn07XHJcblxyXG5cclxuLy9SZXR1cm4gYW4gYXJyYXkgb2YgdGhlIHN0cmF0ZWd5IG9mIGVhY2ggcGxheWVyIGluIHRoZSBsaXN0XHJcblBsYXllckxpc3QucHJvdG90eXBlLnN0cmF0ZWdpZXMgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRyZXR1cm4gcGxheWVyLnN0cmF0ZWd5ID8gcGxheWVyLnN0cmF0ZWd5Ll9pZCA6IFwiXCI7XHJcblx0fSk7XHJcbn07XHJcblxyXG4vL1JldHVybiBhIFBsYXllckxpc3Qgd2l0aCBvbmx5IHBsYXllcnMgdXNpbmcgYSBnaXZlbiBzdHJhdGVneVxyXG5QbGF5ZXJMaXN0LnByb3RvdHlwZS51c2luZ1N0cmF0ZWd5ID0gZnVuY3Rpb24oc3RyYXRlZ3kpIHtcclxuXHRyZXR1cm4gbmV3IFBsYXllckxpc3QoXHJcblx0XHR0aGlzLmZpbHRlcihmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0aWYgKFxyXG5cdFx0XHRcdHBsYXllci5zdHJhdGVneSA9PSBzdHJhdGVneSB8fFxyXG5cdFx0XHRcdHBsYXllci5zdHJhdGVneS5faWQgPT0gc3RyYXRlZ3kgfHxcclxuXHRcdFx0XHQoaXNGdW5jdGlvbihzdHJhdGVneSkgJiYgcGxheWVyLnN0cmF0ZWd5IGluc3RhbmNlb2Ygc3RyYXRlZ3kpXHJcblx0XHRcdClcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0ZWxzZSByZXR1cm4gZmFsc2U7XHJcblx0XHR9KVxyXG5cdCk7XHJcbn07XHJcblxyXG4vKlxyXG5cclxuVE9ETyBmaWd1cmUgb3V0IGhvdyB0byBtYWtlIHRoaXMgd29ya1xyXG5cclxuLy9SZXR1cm5zIGFuIG9iamVjdCB3aGVyZSB0aGUga2V5cyBhcmUgc3RyYXRlZ3kgbmFtZXMgYW5kIHRoZSB2YWx1ZXMgYXJlIGFycmF5cyBvZiBwbGF5ZXJzLlxyXG4vL1RoaXMgbmVlZHMgdG8gYmUgb3ZlcnJpZGRlbiBvbiB0aGUgVXNlclBsYXllckxpc3QgcHJvdG90eXBlLCBiZWNhdXNlIHRoZSBub3JtYWwgd3JhcHBlciBsb2dpY1xyXG4vL2ZvciBVc2VyUGxheWVyTGlzdCBjYW5ub3Qgc2FuaXRpemUgdGhpcy5cclxuUGxheWVyTGlzdC5wcm90b3R5cGUuYnlTdHJhdGVneSA9IGZ1bmN0aW9uKCl7XHJcblx0dmFyIGxpc3QgPSB0aGlzO1xyXG5cdHZhciBkYXRhID0ge307XHJcblxyXG5cdE9iamVjdC5rZXlzKHJlZ2lzdHJ5LnN0cmF0ZWdpZXMpLmZvckVhY2goZnVuY3Rpb24oc3RyYXRlZ3kpe1xyXG5cdFx0ZGF0YVtzdHJhdGVneV0gPSBsaXN0LnVzaW5nU3RyYXRlZ3koc3RyYXRlZ3kpO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxufTtcclxuKi9cclxuXHJcbi8vUmV0dXJucyBhbiBvYmplY3Qgd2hlcmUgdGhlIGtleXMgYXJlIGVhY2ggc3RyYXRlZ3kgYW5kIHRoZSB2YWx1ZXNcclxuLy9hcmUgdGhlIG51bWJlciBvZiBwbGF5ZXJzIGluIHRoZSBsaXN0IHdobyBhcmUgdXNpbmcgaXQuXHJcblBsYXllckxpc3QucHJvdG90eXBlLnN0cmF0ZWd5RGlzdHJpYnV0aW9uID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGNvdW50cyA9IHt9O1xyXG5cclxuXHR0aGlzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHR2YXIgcyA9IHBsYXllci5zdHJhdGVneS5faWQ7XHJcblx0XHRjb3VudHNbc10gPSAoY291bnRzW3NdIHx8IDApICsgMTtcclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIGNvdW50cztcclxufTtcclxuXHJcblxyXG5cclxuUGxheWVyTGlzdC5wcm90b3R5cGUucmVzZXRTY29yZXMgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRwbGF5ZXIuc2NvcmUgPSAwO1xyXG5cdH0pO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy9BY2NlcHQgYSBQbGF5ZXJMaXN0IGFuZCByZXR1cm4gb25lIHN1aXRhYmxlIGZvciB0aGUgdXNlciwgb3IgY3JlYXRlIGEgcGxheWVybGlzdCBhbmQgcmV0dXJuIG9uZSBzdWl0YWJsZSBmb3IgdGhlIHVzZXJcclxuZnVuY3Rpb24gVXNlclBsYXllckxpc3QoLi4ucGxheWVyTGlzdCkge1xyXG5cdGlmIChBcnJheS5pc0FycmF5KHBsYXllckxpc3RbMF0pKSBwbGF5ZXJMaXN0ID0gcGxheWVyTGlzdFswXTtcclxuXHJcblx0Ly8gSWYgd2UndmUgZ290IGEgcGxheWVyTGlzdCwgcmV0dXJuIHRoZSBpbnRlcmZhY2Ugb2YgZWFjaCBwbGF5ZXJcclxuXHRpZiAocGxheWVyTGlzdCBpbnN0YW5jZW9mIFBsYXllckxpc3QpIHtcclxuXHRcdHZhciB1c2VyUGxheWVyTGlzdCA9IHBsYXllckxpc3QubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRyZXR1cm4gcGxheWVyLmludGVyZmFjZTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHQvLyBJZiBub3QsIGZpcnN0IGNyZWF0ZSBhIHBsYXllckxpc3QsIHRoZW4gY2FsbCB0aGlzIGZ1bmN0aW9uIGFnYWluIHRvIHdyYXAgaXQuXHJcblx0ZWxzZSByZXR1cm4gbmV3IFVzZXJQbGF5ZXJMaXN0KG5ldyBQbGF5ZXJMaXN0KHBsYXllckxpc3QpKTtcclxuXHJcblx0T2JqZWN0LnNldFByb3RvdHlwZU9mKHVzZXJQbGF5ZXJMaXN0LCBVc2VyUGxheWVyTGlzdC5wcm90b3R5cGUpO1xyXG5cclxuXHQvL0F0dGFjaCBtZXRob2RzIGZyb20gUGxheWVyTGlzdCwgd3JhcHBlZCBpbiBhIGZ1bmN0aW9uLiBJZiB0aG9zZSBtZXRob2RzIHJldHVybiBhIHBsYXllckxpc3QsXHJcblx0Ly90aGVuIHRoZSBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgdGhhdCB0byBhIFVzZXJQbGF5ZXJMaXN0LlxyXG5cdGZvciAodmFyIG1ldGhvZCBpbiBQbGF5ZXJMaXN0LnByb3RvdHlwZSkge1xyXG5cdFx0aWYgKGlzRnVuY3Rpb24ocGxheWVyTGlzdFttZXRob2RdKSkge1xyXG5cdFx0XHRpZiAobWV0aG9kICE9IFwiY29uc3RydWN0b3JcIilcclxuXHRcdFx0XHR1c2VyUGxheWVyTGlzdFttZXRob2RdID0gKGZ1bmN0aW9uKG1ldGhvZCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gcGxheWVyTGlzdFttZXRob2RdLmFwcGx5KHBsYXllckxpc3QsIGFyZ3VtZW50cyk7XHJcblx0XHRcdFx0XHRcdGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQbGF5ZXJMaXN0KSByZXR1cm4gbmV3IFVzZXJQbGF5ZXJMaXN0KHJlc3VsdCk7XHJcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIF9QbGF5ZXIpIHJldHVybiByZXN1bHQuaW50ZXJmYWNlO1xyXG5cdFx0XHRcdFx0XHRlbHNlIHJldHVybiByZXN1bHQ7XHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH0pKG1ldGhvZCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdXNlclBsYXllckxpc3Q7XHJcbn1cclxuXHJcblVzZXJQbGF5ZXJMaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGxheWVyTGlzdC5wcm90b3R5cGUpO1xyXG5Vc2VyUGxheWVyTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVc2VyUGxheWVyTGlzdDtcclxuXHJcbi8vQWNjZXB0IGEgUGxheWVyTGlzdCBhbmQgcmV0dXJuIG9uZSBzdWl0YWJsZSBmb3IgYSBzdHJhdGVneSBpbmZvcm1hdGlvbiBzZXQuXHJcbmZ1bmN0aW9uIEluZm9QbGF5ZXJMaXN0KHBsYXllckxpc3QpIHtcclxuXHR2YXIgaW5mb1BsYXllckxpc3QgPSBwbGF5ZXJMaXN0Lm1hcChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHJldHVybiBwbGF5ZXIuaW5mb0NsZWFuKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocGxheWVyKSkpO1xyXG5cdH0pO1xyXG5cclxuXHRPYmplY3Quc2V0UHJvdG90eXBlT2YoaW5mb1BsYXllckxpc3QsIEluZm9QbGF5ZXJMaXN0LnByb3RvdHlwZSk7XHJcblxyXG5cdC8vQXR0YWNoIHNlbGVjdGVkIG1ldGhvZHMgZnJvbSBQbGF5ZXJMaXN0LCB3cmFwcGVkIGluIGEgZnVuY3Rpb24uIElmIHRob3NlIG1ldGhvZHMgcmV0dXJuIGEgcGxheWVyTGlzdCxcclxuXHQvL3RoZW4gdGhlIGZ1bmN0aW9uIHdpbGwgY29udmVydCB0aGF0IHRvIGFuIEluZm9QbGF5ZXJMaXN0LlxyXG5cdHZhciBtZXRob2RzVG9JbmNsdWRlID0gW1xyXG5cdFx0XCJvbmx5QWxpdmVcIixcclxuXHRcdFwib25seUF2YWlsYWJsZVwiLFxyXG5cdFx0XCJpZHNcIixcclxuXHRcdFwiZXhjbHVkZVwiLFxyXG5cdFx0XCJnZW5lcmF0b3JcIixcclxuXHRcdFwic3RyYXRlZ2llc1wiLFxyXG5cdFx0XCJ1c2luZ1N0cmF0ZWd5XCIsXHJcblx0XHRcInN0cmF0ZWd5RGlzdHJpYnV0aW9uXCIsXHJcblx0XHRcInNjb3Jlc1wiLFxyXG5cdFx0XCJzY29yZXNPYmplY3RcIixcclxuXHRcdFwic2NvcmVzTWVhblwiLFxyXG5cdFx0XCJzY29yZXNSYW5nZVwiLFxyXG5cdFx0XCJzY29yZXNTdGRcIixcclxuXHRcdFwibGVhZGVyXCJcclxuXHRdO1xyXG5cclxuXHRmb3IgKHZhciBtZXRob2QgaW4gUGxheWVyTGlzdC5wcm90b3R5cGUpIHtcclxuXHRcdGlmIChpc0Z1bmN0aW9uKHBsYXllckxpc3RbbWV0aG9kXSkpIHtcclxuXHRcdFx0aWYgKG1ldGhvZHNUb0luY2x1ZGUuaW5kZXhPZihtZXRob2QpID4gLTEpXHJcblx0XHRcdFx0aW5mb1BsYXllckxpc3RbbWV0aG9kXSA9IChmdW5jdGlvbihtZXRob2QpIHtcclxuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHJlc3VsdCA9IHBsYXllckxpc3RbbWV0aG9kXS5hcHBseShwbGF5ZXJMaXN0LCBhcmd1bWVudHMpO1xyXG5cdFx0XHRcdFx0XHRpZiAocmVzdWx0IGluc3RhbmNlb2YgUGxheWVyTGlzdCkgcmV0dXJuIG5ldyBJbmZvUGxheWVyTGlzdChyZXN1bHQpO1xyXG5cdFx0XHRcdFx0XHRlbHNlIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBfUGxheWVyKVxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQuaW5mb0NsZWFuKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzdWx0KSkpO1xyXG5cdFx0XHRcdFx0XHRlbHNlIHJldHVybiByZXN1bHQ7XHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH0pKG1ldGhvZCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gaW5mb1BsYXllckxpc3Q7XHJcbn1cclxuXHJcbkluZm9QbGF5ZXJMaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXJyYXkucHJvdG90eXBlKTtcclxuSW5mb1BsYXllckxpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW5mb1BsYXllckxpc3Q7XHJcblxyXG4vL0V4dHJhIG1ldGhvZCB0byByZXR1cm4gYSBzaW5nbGUgcGxheWVyIGZyb20gYW4gaW5mb1BsYXllckxpc3RcclxuSW5mb1BsYXllckxpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHBsYXllcklEKSB7XHJcblx0cmV0dXJuIHRoaXMuZmluZChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdHJldHVybiBwbGF5ZXIuaWQgPT0gcGxheWVySUQ7XHJcblx0fSk7XHJcbn07XHJcblxyXG4vL0dlbmVyYXRlcyBhIFBsYXllckxpc3QgY29udGFpbmluZyBhbGwgcGxheWVycy5cclxudmFyIGdhbWVQb3B1bGF0aW9uID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIHBvcHVsYXRpb24gPSBbXTtcclxuXHJcblx0Zm9yICh2YXIgcGxheWVyIGluIHJlZ2lzdHJ5LnBsYXllcnMpIHtcclxuXHRcdHBvcHVsYXRpb24ucHVzaChyZWdpc3RyeS5wbGF5ZXJzW3BsYXllcl0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ldyBQbGF5ZXJMaXN0KHBvcHVsYXRpb24pO1xyXG59O1xyXG5cclxuLy9Eb2VzIHRoZSBzYW1lLCBidXQgYSBVc2VyUGxheWVyTGlzdFxyXG52YXIgUG9wdWxhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBuZXcgVXNlclBsYXllckxpc3QoZ2FtZVBvcHVsYXRpb24oKSk7XHJcbn07XHJcblxyXG4vL0RvZXMgdGhlIHNhbWUsIGJ1dCBhbiBJbmZvUGxheWVyTGlzdFxyXG52YXIgSW5mb1BvcHVsYXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IEluZm9QbGF5ZXJMaXN0KGdhbWVQb3B1bGF0aW9uKCkpO1xyXG59O1xyXG5cclxuLy9BIHNob3J0LWhhbmQgdG8gcmV0dXJuIHRvdGFsIHBvcHVsYXRpb24gc2l6ZSB3aXRob3V0IGNyZWF0aW5nIGEgUGxheWVyTGlzdFxyXG5Qb3B1bGF0aW9uLnNpemUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gT2JqZWN0LmtleXMocmVnaXN0cnkucGxheWVycykubGVuZ3RoO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0UGxheWVyTGlzdCxcclxuXHRVc2VyUGxheWVyTGlzdCxcclxuXHRJbmZvUGxheWVyTGlzdCxcclxuXHRnYW1lUG9wdWxhdGlvbixcclxuXHRQb3B1bGF0aW9uLFxyXG5cdEluZm9Qb3B1bGF0aW9uXHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gRXh0ZXJuYWwgZGVwZW5kZW5jeVxyXG52YXIganNvbmF0YSA9IHJlcXVpcmUoXCJqc29uYXRhXCIpO1xyXG5cclxuLy8gR2FtZSBzdGF0ZVxyXG52YXIgeyByZWdpc3RyeSwgaWRDb3VudGVycyB9ID0gcmVxdWlyZShcIi4vc3RhdGVcIilcclxudmFyIHsgaWRIYW5kbGVyIH0gPSByZXF1aXJlKCcuL2hlbHBlci1mdW5jdGlvbnMnKShcInN0YXRlXCIpO1xyXG5yZWdpc3RyeS5fYWRkVHlwZV8oXCJxdWVyaWVzXCIpXHJcbmlkQ291bnRlcnMuX2FkZFR5cGVfKFwicXVlcnlcIilcclxuXHJcblxyXG52YXIgcmVnaXN0ZXJRdWVyeU9iamVjdCA9IGZ1bmN0aW9uKHF1ZXJ5T2JqZWN0LCBnYW1lTmFtZSkge1xyXG5cdC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBxdWVyaWVzLCByZWN1cnNlXHJcblx0aWYgKEFycmF5LmlzQXJyYXkocXVlcnlPYmplY3QpKSByZXR1cm4gcXVlcnlPYmplY3QubWFwKGZ1bmN0aW9uKHF1ZXJ5KSB7XHJcblx0XHRyZXR1cm4gcmVnaXN0ZXJRdWVyeU9iamVjdChxdWVyeSlcclxuXHR9KTtcclxuXHJcblx0dmFyIHsgc2hvcnRjdXQsIHF1ZXJ5LCBkZXNjcmlwdGlvbiA9IFwiTm8gZGVzY3JpcHRpb24gZ2l2ZW4uXCIgfSA9IHF1ZXJ5T2JqZWN0O1xyXG5cdC8vIEVuZm9yY2UgbmFtaW5nIGNvbnZlbnRpb24sIGZpcnN0IGNoYXJhY3RlciAnQCdcclxuXHRpZiAoc2hvcnRjdXRbMF0gIT0gXCJAXCIpIHNob3J0Y3V0ID0gXCJAXCIuY29uY2F0KHNob3J0Y3V0KVxyXG5cclxuXHQvLyBDaGVjayBmb3IgZHVwbGljYXRlcy4gQWJvcnQgaWYgc28sIGJ1dCByZXR1cm4gdGhlIGRhdGEgZm9yIGRpc3BsYXkgcHVycG9zZXMuXHJcblx0aWYgKHJlZ2lzdHJ5LnF1ZXJpZXNbc2hvcnRjdXRdICYmIHJlZ2lzdHJ5LnF1ZXJpZXNbc2hvcnRjdXRdLnF1ZXJ5ID09IHF1ZXJ5ICYmXHJcblx0XHRyZWdpc3RyeS5xdWVyaWVzW3Nob3J0Y3V0XS5kZXNjcmlwdGlvbiA9PSBkZXNjcmlwdGlvbilcclxuXHRcdHJldHVybiB7IHNob3J0Y3V0LCBkZXNjcmlwdGlvbiB9O1xyXG5cclxuXHQvLyBhc3NpZ24gaWQgYW5kIGFkZCB0byByZWdpc3RyeVxyXG5cdHZhciBpZCA9IGlkSGFuZGxlcihzaG9ydGN1dCwgXCJxdWVyeVwiKVxyXG5cdHJlZ2lzdHJ5LnF1ZXJpZXNbaWRdID0geyBxdWVyeSwgZGVzY3JpcHRpb24gfVxyXG5cclxuXHQvL3JldHVybiB0aGUgZGF0YSBmb3IgZGlzcGxheSBwdXJwb3Nlc1xyXG5cdHJldHVybiB7IHNob3J0Y3V0OiBpZCwgZGVzY3JpcHRpb24gfVxyXG59XHJcblxyXG5cclxuLy8gVGhlIGNvZGUgd2hpY2ggZXZhbHVhdGVzIGFsbCBxdWVyaWVzLCBubyBtYXR0ZXIgd2hlcmUgdGhleSBjb21lIGZyb20uXHJcbmZ1bmN0aW9uIGV2YWx1YXRlUXVlcnkocXVlcnlTdHJpbmcsIHRhcmdldCwgLi4uYXJncykge1xyXG5cdC8vIENoZWNrIGZvciBwcmUtcHJvZ3JhbW1lZCBxdWVyeSwgZGVzaWduYXRlZCBieSAnQCdcclxuXHRpZiAocXVlcnlTdHJpbmdbMF0gPT0gXCJAXCIgJiYgcmVnaXN0cnkucXVlcmllc1txdWVyeVN0cmluZ10pIHF1ZXJ5U3RyaW5nID0gcmVnaXN0cnkucXVlcmllc1txdWVyeVN0cmluZ10ucXVlcnlcclxuXHRlbHNlIGlmIChxdWVyeVN0cmluZ1swXSA9PSBcIkBcIikgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5zbGljZSgxKVxyXG5cclxuXHRyZXR1cm4gbmV3IFF1ZXJ5UmVzdWx0KHF1ZXJ5U3RyaW5nLCBqc29uYXRhKHF1ZXJ5U3RyaW5nKS5ldmFsdWF0ZSh0YXJnZXQsIC4uLmFyZ3MpKS5wYWNrKCk7XHJcbn1cclxuXHJcblxyXG4vLyBPYmplY3QgdG8gcGFzcyBhcm91bmQgcXVlcmllc1xyXG5mdW5jdGlvbiBRdWVyeShzaG9ydGN1dCwgcXVlcnksIGRlc2NyaXB0aW9uLCBmb3JtYXQgPSBcInNob3J0Y3V0XCIpIHtcclxuXHJcblx0aWYgKGZvcm1hdCA9PSBcInNhdmVcIikge1xyXG5cdFx0dGhpcy5zYXZlU2hvcnRjdXQgPSBmdW5jdGlvbihzaG9ydGN1dCwgZGVzY3JpcHRpb24pIHtcclxuXHRcdFx0cmV0dXJuIHJlZ2lzdGVyUXVlcnlPYmplY3QoeyBxdWVyeTogdGhpcy5xdWVyeSwgc2hvcnRjdXQsIGRlc2NyaXB0aW9uIH0pXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBPbmx5IGluY2x1ZGUgcmVxdWVzdGVkIHByb3BlcnRpZXMsIHRvIGF2b2lkIHZpc3VhbCBjbHV0dGVyXHJcblx0aWYgKGZvcm1hdCA9PSBcImNvZGVcIiB8fCBmb3JtYXQgPT0gXCJzYXZlXCIgfHwgZm9ybWF0ID09IFwiYWxsXCIpIHRoaXMucXVlcnkgPSBxdWVyeTtcclxuXHRpZiAoZm9ybWF0ID09IFwic2hvcnRjdXRcIiB8fCBmb3JtYXQgPT0gXCJhbGxcIikge1xyXG5cdFx0dGhpcy5zaG9ydGN1dCA9IHNob3J0Y3V0XHJcblxyXG5cdFx0aWYgKGZvcm1hdCAhPT0gXCJhbGxcIikge1xyXG5cdFx0XHQvLyBOb3JtYWxseSB3ZSdkIHVzZSB0aGUgcHJvdG90eXBlIG1ldGhvZCB0byBzYXZlIG1lbW9yeSwgYnV0IGluIHRoaXMgY2FzZSBpdCB3b24ndCB3b3JrLCBzbyBhdHRhY2ggYW5vdGhlclxyXG5cdFx0XHR0aGlzLmV2YWx1YXRlID0gZnVuY3Rpb24odGFyZ2V0LCAuLi5hcmdzKSB7XHJcblx0XHRcdFx0cmV0dXJuIGV2YWx1YXRlUXVlcnkocXVlcnksIHRhcmdldCwgLi4uYXJncyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cdHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvblxyXG59XHJcblxyXG5RdWVyeS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbih0YXJnZXQsIC4uLmFyZ3MpIHtcclxuXHRyZXR1cm4gZXZhbHVhdGVRdWVyeSh0aGlzLnF1ZXJ5LCB0YXJnZXQsIC4uLmFyZ3MpXHJcbn07XHJcblxyXG5cclxuXHJcbi8vIEEgY2xhc3MgdG8gc2hhcmUgcmVzdWx0cyB3aXRoLiBBIHNpbXBsZSBRdWVyeVJlc3VsdCBoYXMgYSBgcmVzdWx0YCBhbmRcclxuLy8gYSBgcXVlcnlTdHJpbmdgIHByb3BlcnR5LCBhbmQgYSBgLnBhY2tgIG1ldGhvZC4gQ2FsbGluZyBgLnBhY2tgIHdpbGxcclxuLy8gY3JlYXRlIGEgbmV3IG9iamVjdCB3aG9zZSB2YWx1ZSBpcyB0aGUgYHJlc3VsdGAgcHJvcGVydHksIGJ1dCB3aG9zZVxyXG4vL3Byb3RvdHlwZSBpcyB0aGUgb3JpZ2luYWwgb2JqZWN0LiBUaGlzIGdpdmVzIGEgY2xlYW4gcmVzdWx0LCB0aGF0IHN0aWxsXHJcbi8vIGhhcyBhIGAucXVlcnlTdHJpbmdgIHByb3BlcnR5LCB0byB2aWV3IHRoZSBzdHJpbmcgdGhhdCBnZW5lcmF0ZWQgaXQuXHJcbmZ1bmN0aW9uIFF1ZXJ5UmVzdWx0KHF1ZXJ5LCByZXN1bHQpIHtcclxuXHQvLyBDYW4ndCBhZGQgcHJvcGVydGllcyB0byB1bmRlZmluZWQsIHRvIGNoYW5nZSB0byBhIHN0cmluZ1xyXG5cdGlmIChyZXN1bHQgPT0gdW5kZWZpbmVkKSByZXN1bHQgPSB7fVxyXG5cclxuXHR0aGlzLnF1ZXJ5ID0gcXVlcnlcclxuXHR0aGlzLnJlc3VsdCA9IHJlc3VsdFxyXG59XHJcblF1ZXJ5UmVzdWx0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXJyYXkucHJvdG90eXBlKVxyXG5RdWVyeVJlc3VsdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBRdWVyeVJlc3VsdDtcclxuXHJcbi8vIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgaXMgdGhlIHJlc3VsdHMgb2YgdGhlIHF1ZXJ5LCBidXQgd2hvc2VcclxuLy8gcHJvdG90eXBlIGNvbnRhaW5zIC5xdWVyeSAodW5sZXNzIHRoZSByZXN1bHQgd2FzIGp1c3QgYSBzdHJpbmcpXHJcblF1ZXJ5UmVzdWx0LnByb3RvdHlwZS5wYWNrID0gZnVuY3Rpb24oKSB7XHJcblx0Ly8gSWYgcmVzdWx0IGlzIHN0cmluZyxcclxuXHRpZiAodHlwZW9mIHRoaXMucmVzdWx0ID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHR2YXIgcGFja2VkID0gbmV3IFN0cmluZyh0aGlzLnJlc3VsdClcclxuXHRcdHBhY2tlZC5xdWVyeSA9IHRoaXMucXVlcnlcclxuXHRcdHJldHVybiBwYWNrZWQ7XHJcblx0fVxyXG5cdC8vIElmIGl0J3MgYXJyYXlcclxuXHRlbHNlIGlmIChBcnJheS5pc0FycmF5KHRoaXMucmVzdWx0KSkge1xyXG5cdFx0dmFyIHBhY2tlZCA9IE9iamVjdC5jcmVhdGUodGhpcylcclxuXHRcdHBhY2tlZC5wdXNoKC4uLnRoaXMucmVzdWx0KVxyXG5cdFx0cmV0dXJuIHBhY2tlZFxyXG5cdH1cclxuXHQvL05vcm1hbCBvYmplY3RcclxuXHRlbHNlIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUodGhpcyksIHRoaXMucmVzdWx0KVxyXG59XHJcblxyXG5cclxuLy8gVXNlciBvYmplY3QgZm9yIGRlYWxpbmcgd2l0aCB0aGVzZSB0aGluZ3MuXHJcbmZ1bmN0aW9uIFF1ZXJpZXMocXVlcnlTdHJpbmcsIHRhcmdldCwgLi4uYXJncykge1xyXG5cdC8vIElmIG5vIHF1ZXJ5IHN0cmluZywgZGlzcGxheSBhbGwgYXZhaWxhYmxlIHNob3J0Y3V0c1xyXG5cdGlmICghcXVlcnlTdHJpbmcpIHtcclxuXHRcdHJldHVybiBPYmplY3Qua2V5cyhyZWdpc3RyeS5xdWVyaWVzKS5tYXAoZnVuY3Rpb24ocXVlcnkpIHtcclxuXHRcdFx0dmFyIHEgPSByZWdpc3RyeS5xdWVyaWVzW3F1ZXJ5XVxyXG5cdFx0XHRyZXR1cm4gbmV3IFF1ZXJ5KHF1ZXJ5LCBxLnF1ZXJ5LCBxLmRlc2NyaXB0aW9uLCBcInNob3J0Y3V0XCIpXHJcblx0XHR9KVxyXG5cdH1cclxuXHQvLyBJZiBxdWVyeSBzdHJpbmcsIGVpdGhlciBydW4gcXVlcnkgb3IgcmV0dXJuIHF1ZXJ5XHJcblx0ZWxzZSB7XHJcblx0XHQvLyBJZiBubyB0YXJnZXQsIHJldHVybiBxdWVyeVxyXG5cdFx0aWYgKCF0YXJnZXQpIHtcclxuXHRcdFx0dmFyIHEgPSByZWdpc3RyeS5xdWVyaWVzW3F1ZXJ5U3RyaW5nXVxyXG5cdFx0XHRpZiAocSkgcmV0dXJuIG5ldyBRdWVyeShxdWVyeVN0cmluZywgcS5xdWVyeSwgcS5kZXNjcmlwdGlvbiwgXCJjb2RlXCIpXHJcblx0XHRcdGVsc2UgcmV0dXJuIG5ldyBRdWVyeShudWxsLCBxdWVyeVN0cmluZywgbnVsbCwgXCJzYXZlXCIpXHJcblx0XHR9XHJcblx0XHQvLyBJZiB5ZXMgdGFyZ2V0LCBydW4gcXVlcnkgb24gdGFyZ2V0IGFuZCByZXR1cm4gcmVzdWx0XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0cmV0dXJuIGV2YWx1YXRlUXVlcnkocXVlcnlTdHJpbmcsIHRhcmdldCwgLi4uYXJncylcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgUXVlcmllcywgUXVlcnksIFF1ZXJ5UmVzdWx0LCBldmFsdWF0ZVF1ZXJ5LCByZWdpc3RlclF1ZXJ5T2JqZWN0IH1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgbG9nID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcclxuXHJcbmxvZyhcImRlYnVnXCIsIFwic3RhdGU6IENyZWF0aW5nIGdhbWUgc3RhdGUgdmFyaWFibGVzLlwiKVxyXG5cclxuXHJcbnZhciByZWdpc3RyeSA9IHt9XHJcbnJlZ2lzdHJ5LlByb21pc2UgPSB7fTsgLy8gTmVjZXNzYXJ5IGZvciBzeW5jIG1vZGVcclxucmVnaXN0cnkuX2FkZFR5cGVfID0gZnVuY3Rpb24odHlwZSkge1xyXG5cdHJlZ2lzdHJ5W3R5cGVdID0ge307XHJcblx0bG9nKFwic2lsbHlcIiwgXCJzdGF0ZTogYWRkaW5nIHJlZ2lzdHJ5IGVudHJ5OiBcIiwgdHlwZSlcclxufTtcclxuXHJcblxyXG52YXIgaWRDb3VudGVycyA9IHt9XHJcbmlkQ291bnRlcnMuX2FkZFR5cGVfID0gZnVuY3Rpb24odHlwZSkge1xyXG5cdGlkQ291bnRlcnNbdHlwZV0gPSAwXHJcblx0bG9nKFwic2lsbHlcIiwgXCJzdGF0ZTogYWRkaW5nIGNvdW50ZXIgZW50cnk6IFwiLCB0eXBlKVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IHJlZ2lzdHJ5LCBpZENvdW50ZXJzIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuY29uc3QgbmFzaE5hbWUgPSBcIi4vY29yZVwiOyAvL0NoYW5nZSB0aGlzIHdoZW4gcHVibGlzaGVkLCBwcm9iYWJseSB0byAnbmFzaC1qcydcclxuXHJcbnZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcclxuXHJcbnZhciB7IHJlZ2lzdGVyU3RyYXRlZ3ksIHJlZ2lzdGVyU3RyYXRlZ3lPYmplY3QgfSA9IHJlcXVpcmUoJy4vc3RyYXRlZ3knKTtcclxuXHJcbi8vQ2hlY2sgdG8gc2VlIGlmIHBhcnNlZCBleHByZXNzaW9uIGlzIGNhbGwgdG8gcmVxdWlyZSBvciBldmFsXHJcbmZ1bmN0aW9uIGlzQmFubmVkQ2FsbChub2RlKSB7XHJcblx0cmV0dXJuIChub2RlLnR5cGUgPT09ICdDYWxsRXhwcmVzc2lvbicpICYmXHJcblx0XHQobm9kZS5jYWxsZWUudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKSAmJlxyXG5cdFx0KG5vZGUuY2FsbGVlLm9iamVjdC50eXBlID09PSAnSWRlbnRpZmllcicpICYmXHJcblx0XHQoKG5vZGUuY2FsbGVlLm9iamVjdC5uYW1lID09PSAncmVxdWlyZScpIHx8IChub2RlLmNhbGxlZS5vYmplY3QubmFtZSA9PT0gJ2V2YWwnKSk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiByZW1vdmVDYWxscyhzb3VyY2UpIHtcclxuXHRjb25zdCBlbnRyaWVzID0gW107XHJcblx0ZXNwcmltYS5wYXJzZVNjcmlwdChzb3VyY2UsIHt9LCBmdW5jdGlvbihub2RlLCBtZXRhKSB7XHJcblx0XHRpZiAoaXNCYW5uZWRDYWxsKG5vZGUpKSB7XHJcblx0XHRcdGVudHJpZXMucHVzaCh7XHJcblx0XHRcdFx0c3RhcnQ6IG1ldGEuc3RhcnQub2Zmc2V0LFxyXG5cdFx0XHRcdGVuZDogbWV0YS5lbmQub2Zmc2V0XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdGVudHJpZXMuc29ydCgoYSwgYikgPT4geyByZXR1cm4gYi5lbmQgLSBhLmVuZCB9KS5mb3JFYWNoKG4gPT4ge1xyXG5cdFx0c291cmNlID0gc291cmNlLnNsaWNlKDAsIG4uc3RhcnQpICsgXCIgbnVsbDsgXCIgKyBzb3VyY2Uuc2xpY2Uobi5lbmQpO1xyXG5cdH0pO1xyXG5cdHJldHVybiBzb3VyY2U7XHJcbn1cclxuXHJcblxyXG5cclxudmFyIGxvYWRTdHJhdGVneSA9IGZ1bmN0aW9uKGZpbGVwYXRoLCB0cnVzdGVkID0gZmFsc2UpIHtcclxuXHR2YXIgY29tcGlsZXIgPSByZXF1aXJlKCdleHByZXNzaW9uLXNhbmRib3gnKTtcclxuXHJcblx0dmFyIHNvdXJjZSA9IGZzLnJlYWRGaWxlU3luYyhmaWxlcGF0aCk7XHJcblxyXG5cdGlmICghdHJ1c3RlZCkge1xyXG5cdFx0dmFyIG9yaWdpbmFsU291cmNlID0gc291cmNlO1xyXG5cdFx0dmFyIHBhcnNlZFNvdXJjZSA9IHJlbW92ZUNhbGxzKHNvdXJjZSk7XHJcblxyXG5cdFx0aWYgKG9yaWdpbmFsU291cmNlICE9IHBhcnNlZFNvdXJjZSkgdGhyb3cgbmV3IEVycm9yKFwiU3RyYXRlZ3kgXCIgKyBmaWxlcGF0aCArIFwiIHVzZXMgcmVxdWlyZSBvciBldmFsLlwiKTtcclxuXHR9XHJcblxyXG5cdHNvdXJjZSA9IFwiXFxcInVzZSBzdHJpY3RcXFwiOyBcXG4gXCIgKyBzb3VyY2U7XHJcblx0Y29tcGlsZXIoc291cmNlKSh7IHJlZ2lzdGVyU3RyYXRlZ3ksIHJlZ2lzdGVyU3RyYXRlZ3lPYmplY3QgfSk7XHJcblxyXG59OyAvL1RPRE86IGNoYW5nZSB0aGlzIHNvIHRoYXQgc3RyYXRlZ2llcyBjYW4ndCByZXF1aXJlIGFueSBtb2R1bGVzLlxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBsb2FkU3RyYXRlZ3lGb2xkZXIocGF0aCwgdHJ1c3RlZCA9IGZhbHNlKSB7XHJcblx0dmFyIGZpbGVzID0gZnMucmVhZGRpclN5bmMocGF0aCk7XHJcblx0ZmlsZXMuZm9yRWFjaChmdW5jdGlvbihmaWxlKSB7XHJcblx0XHR2YXIgZmlsZVBhdGggPSBwYXRoICsgJy8nICsgZmlsZTtcclxuXHRcdGxvYWRTdHJhdGVneShmaWxlcGF0aCk7XHJcblx0fSk7XHJcbn07XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IGxvYWRTdHJhdGVneSwgbG9hZFN0cmF0ZWd5Rm9sZGVyIH07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIGxvZyA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XHJcblxyXG4vL0phdmFzY3JpcHQgY29kZSBwYXJzZXJcclxudmFyIGVzcHJpbWEgPSByZXF1aXJlKCdlc3ByaW1hJyk7XHJcblxyXG4vL0dhbWUgc3RhdGUgY29udHJvbGxlcnNcclxudmFyIHsgcmVnaXN0cnkgfSA9IHJlcXVpcmUoJy4vc3RhdGUnKTtcclxuXHJcbi8vSGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBpZEhhbmRsZXIgfSA9IHJlcXVpcmUoJy4vaGVscGVyLWZ1bmN0aW9ucycpKFwic3RhdGVcIik7XHJcblxyXG5cclxuXHJcbi8vVXNlciBpbnRlcmZhY2UgdG8gZGVjbGFyZSBzdHJhdGVneSB0eXBlLlxyXG5mdW5jdGlvbiByZWdpc3RlclN0cmF0ZWd5KHN0cmF0ZWd5LCBuYW1lLCBkZXNjcmlwdGlvbiA9IFwiTm8gZGVzY3JpcHRpb24gZ2l2ZW4uXCIsIHJvbGUgPSBcIlwiKSB7XHJcblx0dmFyIGlkID0gaWRIYW5kbGVyKG5hbWUsIFwic3RyYXRlZ3lcIik7XHJcblxyXG5cdGlmIChpZCAhPT0gbmFtZSkge1xyXG5cdFx0Ly9UaGVyZSB3YXMgYWxyZWFkeSBhIHN0cmF0ZWd5IHJlZ2lzdGVyZWQgd2l0aCB0aGlzIG5hbWUuXHJcblx0XHQvL0NoZWNrIHRvIHNlZSBpZiBpdCdzIHRoZSBzYW1lIHN0cmF0ZWd5IG9yIG5vdC5cclxuXHRcdGlmIChyZWdpc3RyeS5zdHJhdGVnaWVzW2lkXSAhPT0gc3RyYXRlZ3kpIHtcclxuXHRcdFx0Ly9UaGV5J3JlIGRpZmZlcmVudCwgc28gd2UgaGF2ZSBhIG5hbWUgY29uZmxpY3QuXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlN0cmF0ZWd5IG5hbWUgY29uZmxpY3Qgd2l0aCBcIiArIG5hbWUpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIFRoZXkncmUgdGhlIHNhbWUsIGRvIG5vdGhpbmcuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gTm8gbmFtZSBjb25mbGljdCBhbmQgc3RyYXRlZ3kgbm90IGxvYWRlZCB5ZXQuIEFkZCB0byByZWdpc3RyeS5cclxuXHRsb2coXCJkZWJ1Z1wiLCBcIkxvYWRpbmcgc3RyYXRlZ3kgJ1wiICsgaWQgKyBcIidcIilcclxuXHRzdHJhdGVneS5yb2xlID0gcm9sZTtcclxuXHRzdHJhdGVneS5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xyXG5cdHJlZ2lzdHJ5LnN0cmF0ZWdpZXNbaWRdID0gc3RyYXRlZ3k7XHJcblx0cmV0dXJuIG5hbWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyU3RyYXRlZ3lPYmplY3Qoc3RyYXRlZ3lPYmplY3QpIHtcclxuXHQvLyBJZiBtdWx0aXBsZSBzdHJhdGVnaWVzLCBzcGxpdCBpbnRvIGluZGl2aWR1YWxzXHJcblx0aWYgKEFycmF5LmlzQXJyYXkoc3RyYXRlZ3lPYmplY3QpKSByZXR1cm4gc3RyYXRlZ3lPYmplY3QubWFwKHJlZ2lzdGVyU3RyYXRlZ3lPYmplY3QpXHJcblxyXG5cdHJldHVybiByZWdpc3RlclN0cmF0ZWd5KHN0cmF0ZWd5T2JqZWN0LnN0cmF0ZWd5LCBzdHJhdGVneU9iamVjdC5uYW1lLCBzdHJhdGVneU9iamVjdC5kZXNjcmlwdGlvbixcclxuXHRcdHN0cmF0ZWd5T2JqZWN0LnJvbGUpXHJcbn1cclxuXHJcbi8vU3RyaXAgb3V0IHJlcXVpcmVzIGFuZCBzdWNoXHJcbmZ1bmN0aW9uIHNhbml0aXplU3RyYXRlZ3koc3RyYXRlZ3kpIHtcclxuXHQvLyBjb25zb2xlLmxvZyh4KSBvciBjb25zb2xlWydlcnJvciddKHkpXHJcblx0ZnVuY3Rpb24gaXNSZXF1aXJlQ2FsbChub2RlKSB7XHJcblx0XHRyZXR1cm4gKG5vZGUudHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJykgJiZcclxuXHRcdFx0KG5vZGUuY2FsbGVlLnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykgJiZcclxuXHRcdFx0KG5vZGUuY2FsbGVlLm9iamVjdC50eXBlID09PSAnSWRlbnRpZmllcicpICYmXHJcblx0XHRcdChub2RlLmNhbGxlZS5vYmplY3QubmFtZSA9PT0gJ3JlcXVpcmUnKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlbW92ZUNhbGxzKHNvdXJjZSkge1xyXG5cdFx0Y29uc3QgZW50cmllcyA9IFtdO1xyXG5cdFx0ZXNwcmltYS5wYXJzZVNjcmlwdChzb3VyY2UsIHt9LCBmdW5jdGlvbihub2RlLCBtZXRhKSB7XHJcblx0XHRcdGlmIChpc1JlcXVpcmVDYWxsKG5vZGUpKSB7XHJcblx0XHRcdFx0ZW50cmllcy5wdXNoKHtcclxuXHRcdFx0XHRcdHN0YXJ0OiBtZXRhLnN0YXJ0Lm9mZnNldCxcclxuXHRcdFx0XHRcdGVuZDogbWV0YS5lbmQub2Zmc2V0XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0ZW50cmllcy5zb3J0KChhLCBiKSA9PiB7IHJldHVybiBiLmVuZCAtIGEuZW5kIH0pLmZvckVhY2gobiA9PiB7XHJcblx0XHRcdHNvdXJjZSA9IHNvdXJjZS5zbGljZSgwLCBuLnN0YXJ0KSArIHNvdXJjZS5zbGljZShuLmVuZCk7XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiBzb3VyY2U7XHJcblx0fVxyXG5cclxuXHRyZW1vdmVDYWxscyhzdHJhdGVneS50b1N0cmluZygpKTtcclxuXHJcbn1cclxuXHJcbi8vUmV0dXJucyB0byB0aGUgdXNlciBhbiBhcnJheSBvZiBhbGwgcmVnaXN0ZXJlZCBzdHJhdGVnaWVzLiBUT0RPOiBoYXZlIHRoaXMgbWlycm9yIFBsYXllckxpc3QsIHRvIHByb3ZpZGUgZnVuY3Rpb25hbGl0eSBsaWtlIG9ubHlBbGl2ZSBhbmQgc2NvcmVzT2JqZWN0LlxyXG5mdW5jdGlvbiBTdHJhdGVnaWVzKCkge1xyXG5cdHZhciBzdHJhdGVnaWVzID0gW107XHJcblx0Zm9yICh2YXIgc3RyYXRlZ3kgaW4gcmVnaXN0cnkuc3RyYXRlZ2llcykgc3RyYXRlZ2llcy5wdXNoKHN0cmF0ZWd5KTtcclxuXHRyZXR1cm4gc3RyYXRlZ2llcztcclxufTtcclxuXHJcblxyXG5TdHJhdGVnaWVzLmJ5Um9sZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciByb2xlcyA9IHsgbm9uZTogW10gfVxyXG5cdGZvciAodmFyIHN0cmF0ZWd5IGluIHJlZ2lzdHJ5LnN0cmF0ZWdpZXMpXHJcblx0XHRpZiAocmVnaXN0cnkuc3RyYXRlZ2llc1tzdHJhdGVneV0ucm9sZSkgcm9sZXNbcmVnaXN0cnkuc3RyYXRlZ2llc1tzdHJhdGVneV0ucm9sZV0gPSBbXTtcclxuXHRmb3IgKHZhciBzdHJhdGVneSBpbiByZWdpc3RyeS5zdHJhdGVnaWVzKSB7XHJcblx0XHRsZXQgcm9sZSA9IHJlZ2lzdHJ5LnN0cmF0ZWdpZXNbc3RyYXRlZ3ldLnJvbGU7XHJcblx0XHRpZiAocm9sZSkgcm9sZXNbcm9sZV0ucHVzaChzdHJhdGVneSk7XHJcblx0XHRlbHNlIHJvbGVzLm5vbmUucHVzaChzdHJhdGVneSlcclxuXHR9XHJcblx0cmV0dXJuIHJvbGVzO1xyXG59XHJcblxyXG5cclxuLy8gRmV0Y2ggdGhlIGRlc2NyaXB0aW9ucyBvZiB0aGUgc3RyYXRlZ2llcy5cclxuU3RyYXRlZ2llcy5kZXNjcmlwdGlvbnMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgc3RyYXRlZ2llcyA9IHt9O1xyXG5cdGZvciAodmFyIHN0cmF0ZWd5IGluIHJlZ2lzdHJ5LnN0cmF0ZWdpZXMpIHN0cmF0ZWdpZXNbc3RyYXRlZ3ldID0gcmVnaXN0cnkuc3RyYXRlZ2llc1tzdHJhdGVneV0uZGVzY3JpcHRpb247XHJcblx0cmV0dXJuIHN0cmF0ZWdpZXM7XHJcbn1cclxuXHJcblxyXG4vLyBBIGJ1aWx0LWluIHN0cmF0ZWd5IGZvciBkZXYgZGVidWdnaW5nLiBUaGlzIHN0cmF0ZWd5IHdpbGwgYmUgY3JlYXRlZCBidXQgZG8gbm90aGluZ1xyXG5TdHJhdGVnaWVzLmR1bW15ID0gZnVuY3Rpb24oKSB7XHJcblx0cmVnaXN0ZXJTdHJhdGVneShmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuY2hvb3NlID0gZnVuY3Rpb24ob3B0aW9ucywgaW5mb3JtYXRpb24pIHtcclxuXHRcdFx0cmV0dXJuXHJcblx0XHR9XHJcblx0fSwgXCJkdW1teVwiKVxyXG5cdHJldHVybiBcImR1bW15XCJcclxufVxyXG5cclxuU3RyYXRlZ2llcy5xdWljayA9IGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZHMgPSBbXSkge1xyXG5cclxuXHRtZXRob2RzLnB1c2goXCJjaG9vc2VcIilcclxuXHRtZXRob2RzLnB1c2goXCJyYW5nZVwiKVxyXG5cclxuXHRyZWdpc3RlclN0cmF0ZWd5KGZ1bmN0aW9uKCkge1xyXG5cdFx0Zm9yICh2YXIgbWV0aG9kIG9mIG1ldGhvZHMpIHRoaXNbbWV0aG9kXSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGluZm9ybWF0aW9uKSB7XHJcblx0XHRcdHJldHVybiAoZnVuYyhvcHRpb25zLCBpbmZvcm1hdGlvbikpXHJcblx0XHR9XHJcblx0fSwgXCJxdWlja1wiKVxyXG5cdHJldHVybiBcInF1aWNrXCJcclxufVxyXG5cclxuLy8gQSBidWlsdC1pbiBkZWJ1Z2dpbmcgc3RyYXRlZ3kuIENhbGxpbmcgdGhpcyBmdW5jdGlvbiBsb2FkcyB0aGUgc3RyYXRlZ3kuXHJcbi8vIFRoZSBzdHJhdGVneSBqdXN0IGNhbGxlcyAnZGVidWdnZXInIHdoZW4gYXNrZWQgdG8gY2hvb3NlLlxyXG5TdHJhdGVnaWVzLmRlYnVnZ2VyID0gZnVuY3Rpb24obWV0aG9kcyA9IFtdKSB7XHJcblx0cmVnaXN0ZXJTdHJhdGVneShmdW5jdGlvbigpIHtcclxuXHJcblx0XHR0aGlzLmNob29zZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGluZm9ybWF0aW9uKSB7XHJcblx0XHRcdGRlYnVnZ2VyO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMucmFuZ2UgPSBmdW5jdGlvbihib3VuZHMsIGluZm9ybWF0aW9uKSB7XHJcblx0XHRcdGRlYnVnZ2VyO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFyYml0cmFyeSB1c2VyIG1ldGhvZHNcclxuXHRcdGZvciAodmFyIG1ldGhvZCBvZiBtZXRob2RzKSB0aGlzW21ldGhvZF0gPSBmdW5jdGlvbihvcHRpb25zLCBpbmZvcm1hdGlvbikgeyBkZWJ1Z2dlcjsgfVxyXG5cclxuXHR9LCBcImRlYnVnZ2VyXCIpXHJcblx0cmV0dXJuIFwiZGVidWdnZXJcIlxyXG59XHJcblxyXG5cclxuU3RyYXRlZ2llcy5sb2dnZXIgPSBmdW5jdGlvbihtZXRob2RzID0gW10pIHtcclxuXHRyZWdpc3RlclN0cmF0ZWd5KGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHRoaXMuY2hvb3NlID0gZnVuY3Rpb24ob3B0aW9ucywgaW5mb3JtYXRpb24pIHtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJPcHRpb25zOiBcIiwgb3B0aW9ucyk7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiSW5mb3JtYXRpb246IFwiLCBpbmZvcm1hdGlvbilcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnJhbmdlID0gZnVuY3Rpb24oYm91bmRzLCBpbmZvcm1hdGlvbikge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIkJvdW5kczogXCIsIGJvdW5kcyk7XHJcblx0XHRcdGNvbnNvbGUubG9nKFwiSW5mb3JtYXRpb246IFwiLCBpbmZvcm1hdGlvbilcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBtZXRob2Qgb2YgbWV0aG9kcylcclxuXHRcdFx0dGhpc1ttZXRob2RdID0gZnVuY3Rpb24ob3B0aW9ucywgaW5mb3JtYXRpb24pIHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIk9wdGlvbnM6IFwiLCBvcHRpb25zKTtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIkluZm9ybWF0aW9uOiBcIiwgaW5mb3JtYXRpb24pXHJcblx0XHRcdH1cclxuXHJcblx0fSwgXCJsb2dnZXJcIilcclxuXHRyZXR1cm4gXCJsb2dnZXJcIlxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgcmVnaXN0ZXJTdHJhdGVneSwgcmVnaXN0ZXJTdHJhdGVneU9iamVjdCwgU3RyYXRlZ2llcyB9O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIEJhc2UgY2xhc3MsIGV4dGVybmFsIGRlcGVuZGVuY3lcclxudmFyIENhbGxhYmxlSW5zdGFuY2UgPSByZXF1aXJlKCdjYWxsYWJsZS1pbnN0YW5jZScpO1xyXG5cclxuLy8gVG8gYWlkIHdpdGggdHJlZS1icmFuY2hpbmdcclxudmFyIHsgcmVjdXJzZSB9ID0gcmVxdWlyZShcIi4vaGVscGVyLWZ1bmN0aW9uc1wiKShcInR1cm5cIik7XHJcbnZhciB7IG91dGNvbWVUcmVlR2V0VmFsdWUgfSA9IHJlcXVpcmUoXCIuL2hlbHBlci1mdW5jdGlvbnNcIikoXCJwbGF5YWJsZVwiKTtcclxuXHJcbi8vIERhdGEgc3RydWN0dXJlIGZvciBwbGF5YWJsZSBzdW1tYXJ5IHBhc3NpbmcuIENhbGxhYmxlIHdpdGggYSBuYW1lLCBjcmVhdGluZyBhIHN1Yi1icmFuY2guXHJcbi8vICdlbnRyaWVzJyBjYW4gYmUgdXNlZCB0byBrZWVwIHRyYWNrIG9mIGluc3RhbmNlcyBvZiBhIHBhcnRpY3VsYXIgcGxheWFibGUsIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuXHJcbmNsYXNzIFN1bW1hcnkgZXh0ZW5kcyBDYWxsYWJsZUluc3RhbmNlIHtcclxuXHRjb25zdHJ1Y3RvcihlbnRyaWVzID0ge30pIHtcclxuXHRcdHN1cGVyKFwia2V5XCIpXHJcblx0XHR0aGlzLnN1bW1hcnkgPSB7fVxyXG5cdFx0dGhpcy5lbnRyaWVzID0gZW50cmllc1xyXG5cdH1cclxuXHJcblx0Ly8gY3JlYXRlIGEga2V5IGluIHRoZSBzdW1tYXJ5LCBhbmQgZmlsbCBpdCB3aXRoIHZhbHVlXHJcblx0a2V5KGtleU5hbWUsIHZhbHVlKSB7XHJcblx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkgdGhpcy5zdW1tYXJ5W2tleU5hbWVdID0gdmFsdWVcclxuXHRcdHJldHVybiB0aGlzLnN1bW1hcnlba2V5TmFtZV1cclxuXHR9XHJcblxyXG5cclxuXHRkZWxldGUoa2V5TmFtZSkge1xyXG5cdFx0ZGVsZXRlIHRoaXMuc3VtbWFyeVtrZXlOYW1lXVxyXG5cdH1cclxuXHJcblxyXG5cdC8vIGNyZWF0ZSBhIGJyYW5jaCAoa2V5KSBpbiB0aGUgc3VtbWFyeSB3aGljaCB3aWxsIGl0c2VsZiBoYXZlIGEgU3VtbWFyeSwgd2l0aCB0aGUgc2FtZSBlbnRyeSBsaXN0ICh0byBwcmV2ZW50IGNpcmNsZXMpXHJcblx0YnJhbmNoKGJyYW5jaE5hbWUpIHtcclxuXHRcdHRoaXMuc3VtbWFyeVticmFuY2hOYW1lXSA9IG5ldyBTdW1tYXJ5KHRoaXMuZW50cmllcylcclxuXHRcdHJldHVybiB0aGlzLnN1bW1hcnlbYnJhbmNoTmFtZV1cclxuXHR9XHJcblxyXG5cclxuXHQvLyBjcmVhdGUgYSBicmFuY2ggKGtleSkgd2hpY2ggd2lsbCBoYXZlIGFuIGFycmF5IG9mIFN1bW1hcmllcyAoYWxsIHdpdGggdGhlIHNhbWUgZW50cnkgbGlzdClcclxuXHRhcnJheShicmFuY2hOYW1lLCBhcnJheSwgZnVuYywgYXJyYXlJZk9uZSA9IGZhbHNlKSB7XHJcblx0XHR2YXIgc3VtbWFyeSA9IHRoaXNcclxuXHRcdHN1bW1hcnkuc3VtbWFyeVticmFuY2hOYW1lXSA9IGFycmF5Lm1hcChmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRcdHZhciBpdGVtU3VtbWFyeSA9IG5ldyBTdW1tYXJ5KHN1bW1hcnkuZW50cmllcylcclxuXHRcdFx0dmFyIHJlc3VsdCA9IGZ1bmMoaXRlbSwgaXRlbVN1bW1hcnkpXHJcblx0XHRcdHJldHVybiByZXN1bHQgPyByZXN1bHQgOiBpdGVtU3VtbWFyeSAvLyBpbiBjYXNlIHRoZXkgZm9yZ2V0IHRvIHJldHVyblxyXG5cdFx0fSlcclxuXHJcblx0XHQvLyBJZiBvbmx5IG9uZSBlbnRyeSwgbm8gbmVlZCBmb3IgYXJyYXlcclxuXHRcdGlmICghYXJyYXlJZk9uZSAmJiBzdW1tYXJ5LnN1bW1hcnlbYnJhbmNoTmFtZV0ubGVuZ3RoID09IDEpIHN1bW1hcnkuc3VtbWFyeVticmFuY2hOYW1lXSA9IHN1bW1hcnkuc3VtbWFyeVtcclxuXHRcdFx0YnJhbmNoTmFtZV1bMF1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cclxuXHQvLyBjcmVhdGUgYSBicmFuY2ggKGtleSkgZnJvbSBhIHRyZWUgKG91dGNvbWVUcmVlKSwgd2hlcmUgdGhlIHZhbHVlcyBkZWVwZXN0IGluIHRoZSB0cmVlIHdpbGwgYmUgU3VtbWFyaWVzIChhbGwgd2l0aCB0aGUgc2FtZSBlbnRyaWVzIGxpc3QpXHJcblx0dHJlZShicmFuY2hOYW1lLCB0cmVlTWFwLCB0cmVlLCBmdW5jLCB0cmVlSWZJZGVudGljYWwgPSBmYWxzZSkge1xyXG5cdFx0dmFyIHN1bW1hcnkgPSB0aGlzO1xyXG5cdFx0dmFyIGl0ZW1zID0gW11cclxuXHRcdHZhciB0ZW1wVHJlZSA9IHt9XHJcblxyXG5cdFx0cmVjdXJzZSh0cmVlTWFwLCB0ZW1wVHJlZSwgbnVsbCwgZnVuY3Rpb24ocGF0aCkge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG91dGNvbWVUcmVlR2V0VmFsdWUodHJlZSwgcGF0aClcclxuXHRcdFx0aXRlbXMucHVzaChpdGVtKVxyXG5cclxuXHRcdFx0dmFyIGl0ZW1TdW1tYXJ5ID0gbmV3IFN1bW1hcnkoc3VtbWFyeS5lbnRyaWVzKVxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gZnVuYyhpdGVtLCBwYXRoLCBpdGVtU3VtbWFyeSlcclxuXHRcdFx0cmV0dXJuIHJlc3VsdCA/IHJlc3VsdCA6IGl0ZW1TdW1tYXJ5XHJcblx0XHR9KVxyXG5cclxuXHRcdHZhciBhcmVJZGVudGljYWwgPSBpdGVtcy5ldmVyeShmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRcdHJldHVybiAoaXRlbSA9PT0gaXRlbXNbMF0pXHJcblx0XHR9KVxyXG5cclxuXHRcdGlmIChhcmVJZGVudGljYWwgJiYgIXRyZWVJZklkZW50aWNhbCkgc3VtbWFyeS5zdW1tYXJ5W2JyYW5jaE5hbWVdID0gaXRlbXNbMF1cclxuXHRcdGVsc2Ugc3VtbWFyeS5zdW1tYXJ5W2JyYW5jaE5hbWVdID0gdGVtcFRyZWVcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cclxuXHQvLyBjcmVhdGUgYSBicmFuY2ggKGtleSkgZnJvbSBhIHRyZWUgKG91dGNvbWVUcmVlKSwgd2hlcmUgdGhlIHZhbHVlcyBkZWVwZXN0IGluIHRoZSB0cmVlIHdpbGwgYmUgYXJyYXlzIG9mIFN1bW1hcmllcyAoYWxsIHdpdGggdGhlIHNhbWUgZW50cmllcyBsaXN0KVxyXG5cdHRyZWVBcnJheShicmFuY2hOYW1lLCB0cmVlTWFwLCB0cmVlLCBmdW5jLCB7IGFycmF5SWZPbmUgPSBmYWxzZSwgdHJlZUlmSWRlbnRpY2FsID0gZmFsc2UgfSA9IHt9KSB7XHJcblx0XHR2YXIgc3VtbWFyeSA9IHRoaXM7XHJcblx0XHR2YXIgaXRlbXMgPSBbXVxyXG5cdFx0dmFyIHByb2Nlc3NlZEl0ZW0gLy8gd2lsbCBob2xkIG9udG8gdGhlIGxhc3QgaXRlbSwgdGhlbiBnZXQgdXNlZCBhcyB0aGUgZW5kIHJlc3VsdCBpZiBpdGVtcyBhcmUgaWRlbnRpY2FsXHJcblx0XHR2YXIgdGVtcFRyZWUgPSB7fVxyXG5cclxuXHRcdC8vIHVzaW5nIHRyZWVNYXAgYXMgYSBndWlkZSwgd3JpdGUgdG8gdGVtcFRyZWUsIHRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgZnVuY3Rpb25cclxuXHRcdHJlY3Vyc2UodHJlZU1hcCwgdGVtcFRyZWUsIG51bGwsIGZ1bmN0aW9uKHBhdGgpIHtcclxuXHRcdFx0dmFyIGFycmF5ID0gb3V0Y29tZVRyZWVHZXRWYWx1ZSh0cmVlLCBwYXRoKVxyXG5cdFx0XHRpdGVtcy5wdXNoKGFycmF5KVxyXG5cclxuXHRcdFx0Ly8gcHJvY2VzcyB0aGUgcmF3IGlucHV0IGludG8gYSBTdW1tYXJ5LCB1c2luZyB0aGUgdXNlci1wcm92aWRlZCBmdW5jdGlvblxyXG5cdFx0XHRhcnJheSA9IGFycmF5Lm1hcChmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRcdFx0dmFyIGl0ZW1TdW1tYXJ5ID0gbmV3IFN1bW1hcnkoc3VtbWFyeS5lbnRyaWVzKVxyXG5cdFx0XHRcdHZhciByZXN1bHQgPSBmdW5jKGl0ZW0sIHBhdGgsIGl0ZW1TdW1tYXJ5KVxyXG5cdFx0XHRcdHByb2Nlc3NlZEl0ZW0gPSByZXN1bHRcclxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0ID8gcmVzdWx0IDogaXRlbVN1bW1hcnlcclxuXHRcdFx0fSlcclxuXHRcdFx0Ly8gYnkgZGVmYXVsdCwgcmVwbGFjZSBzaW5nbGUtbGVuZ3RoIGFycmF5cyB3aXRoIHRoZSB2YWx1ZVxyXG5cdFx0XHRpZiAoIWFycmF5SWZPbmUgJiYgYXJyYXkubGVuZ3RoID09IDEpIHtcclxuXHRcdFx0XHRhcnJheSA9IGFycmF5WzBdXHJcblx0XHRcdFx0aXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0gPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXVswXVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gYXJyYXlcclxuXHRcdH0pXHJcblxyXG5cdFx0dmFyIGFyZUlkZW50aWNhbCA9IGl0ZW1zLmV2ZXJ5KGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdFx0cmV0dXJuIChpdGVtID09IGl0ZW1zWzBdKVxyXG5cdFx0fSlcclxuXHJcblx0XHRpZiAoYXJlSWRlbnRpY2FsICYmICF0cmVlSWZJZGVudGljYWwpIHtcclxuXHRcdFx0Ly8ganVzdCB1c2UgdGhlIGl0ZW0gcmF0aGVyIHRoYW4gdGhlIHdob2xlIHRyZWUgb2Ygc3VwZXJmbHVvdXMgaW5mb3JtYXRpb25cclxuXHRcdFx0c3VtbWFyeS5zdW1tYXJ5W2JyYW5jaE5hbWVdID0gcHJvY2Vzc2VkSXRlbVxyXG5cclxuXHRcdFx0Ly90cnkgdG8gY3V0IGRvd24gb24gZW50cnkgbGlzdCBkdXBsaWNhdGVzXHJcblx0XHRcdC8vIGllLiBpZiBhIENob2ljZSB3aXRoIDEwIG9wdGlvbnMgaGFzIHRoZSBzYW1lIG5leHQgaXRlbSBmb3IgYWxsIG9mIHRoZW0sXHJcblx0XHRcdC8vIHRoYXQgZG9lc24ndCBtZWFuIHdlJ3ZlIGJlZW4gY2lyY2xpbmcgMTAgdGltZXMuXHJcblx0XHRcdGlmIChpdGVtcy5pZCkgc3VtbWFyeS5lbnRyaWVzW2l0ZW1zLmlkXSA9IHN1bW1hcnkuZW50cmllc1tpdGVtcy5pZF0gLSBpdGVtcy5sZW5ndGggKyAxXHJcblx0XHR9IGVsc2Ugc3VtbWFyeS5zdW1tYXJ5W2JyYW5jaE5hbWVdID0gdGVtcFRyZWVcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdG1hcEFycmF5KGJyYW5jaE5hbWUsIG1hcCwgZnVuYywgeyBhcnJheUlmT25lID0gZmFsc2UsIGNvbmRlbnNlQWxsID0gdHJ1ZSB9ID0ge30pIHtcclxuXHRcdHZhciBzdW1tYXJ5ID0gdGhpcztcclxuXHRcdHN1bW1hcnkuc3VtbWFyeVticmFuY2hOYW1lXSA9IFtdXHJcblxyXG5cdFx0Ly8gaXRlcmF0ZSBvdmVyIHRoZSBtYXAsIHByb2Nlc3MgdGhlIHZhbHVlXHJcblx0XHRmb3IgKHZhciBba2V5LCB2YWx1ZV0gb2YgbWFwLmVudHJpZXMoKSkge1xyXG5cdFx0XHR2YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRcdFx0dmFyIGl0ZW1TdW1tYXJ5ID0gbmV3IFN1bW1hcnkoc3VtbWFyeS5lbnRyaWVzKVxyXG5cdFx0XHRcdHZhciByZXN1bHQgPSBmdW5jKGl0ZW0sIGl0ZW1TdW1tYXJ5KVxyXG5cdFx0XHRcdHJldHVybiByZXN1bHQgPyByZXN1bHQgOiBpdGVtU3VtbWFyeSAvLyBJbiBjYXNlIHRoZXkgZm9yZ2V0IHRvIHJldHVybiB0aGUgc3VtbWFyeVxyXG5cdFx0XHR9KVxyXG5cdFx0XHQvLyBjb25kZW5zZSBieSBkZWZhdWx0XHJcblx0XHRcdGlmICghYXJyYXlJZk9uZSAmJiB2YWx1ZS5sZW5ndGggPT0gMSkgdmFsdWUgPSB2YWx1ZVswXVxyXG5cclxuXHRcdFx0c3VtbWFyeS5zdW1tYXJ5W2JyYW5jaE5hbWVdLnB1c2goe1xyXG5cdFx0XHRcdFtrZXkucGF0aCB8fCBrZXkubmFtZSB8fCBrZXldOiB2YWx1ZVxyXG5cdFx0XHR9KVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNvbmRlbnNlIGJ5IGRlZmF1bHQgKHR1cm4gc2luZ2xldCBhcnJheSBpbnRvIHZhbHVlLCB0dXJuIHNpbmdsZXQgXCJhbGxcIiBvYmplY3QgaW50byB2YWx1ZSlcclxuXHRcdGlmICghYXJyYXlJZk9uZSAmJiBzdW1tYXJ5LnN1bW1hcnlbYnJhbmNoTmFtZV0ubGVuZ3RoID09IDEpIHtcclxuXHRcdFx0c3VtbWFyeS5zdW1tYXJ5W2JyYW5jaE5hbWVdID0gc3VtbWFyeS5zdW1tYXJ5W2JyYW5jaE5hbWVdWzBdXHJcblx0XHRcdGlmIChjb25kZW5zZUFsbCAmJiBzdW1tYXJ5LnN1bW1hcnlbYnJhbmNoTmFtZV0uYWxsKSBzdW1tYXJ5LnN1bW1hcnlbYnJhbmNoTmFtZV0gPSBzdW1tYXJ5LnN1bW1hcnlbXHJcblx0XHRcdFx0YnJhbmNoTmFtZV0uYWxsXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHJcblx0Ly8gVE9ETzogTWVhbnQgdG8gY29sbGFwc2Ugc3VtbWFyaWVzIGludG8gc2ltcGxlIG9iamVjdHMuIFRocyBpcyBnb2luZyB0byByZXF1aXJlIHNvbWUgd29yay4uLlxyXG5cdHByaW50KCkge1xyXG5cclxuXHRcdC8vIHJlY3Vyc2l2ZSBmdW5jdGlvbiB0byBoYW5kbGUgbmVzdGVkIG9iamVjdHMgaW4gdGhlIHN1bW1hcnlcclxuXHRcdGZ1bmN0aW9uIGNyYXdsKGlucHV0KSB7XHJcblx0XHRcdGlmIChpbnB1dCBpbnN0YW5jZW9mIFN1bW1hcnkpIHJldHVybiBpbnB1dC5wcmludCgpXHJcblx0XHRcdGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgT2JqZWN0KSB7XHJcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGlucHV0KSB7XHJcblx0XHRcdFx0XHRpbnB1dFtrZXldID0gY3Jhd2woaW5wdXRba2V5XSlcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGlucHV0XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gTG9vcCBvdmVyIHN1bW1hcnkga2V5cyBhbmQgcmVjdXJzZSBvdmVyIG9uZXMgdGhhdCBhcmUgc3VtbWFyaWVzXHJcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5zdW1tYXJ5KSB7XHJcblx0XHRcdGlmICh0aGlzLnN1bW1hcnlba2V5XSBpbnN0YW5jZW9mIFN1bW1hcnkpIHRoaXMuc3VtbWFyeVtrZXldID0gdGhpcy5zdW1tYXJ5W2tleV0ucHJpbnQoKVxyXG5cdFx0XHQvLyBpZiB0aGUga2V5IGlzIGFuIGFycmF5LCBsb29wIHRocm91Z2ggdGhlIGl0ZW1zLCBhbmQgY29sbGFwc2UgYW55IHRoYXQgYXJlIHN1bW1hcmllc1xyXG5cdFx0XHRlbHNlIGlmIChBcnJheS5pc0FycmF5KHRoaXMuc3VtbWFyeVtrZXldKSkgdGhpcy5zdW1tYXJ5W2tleV0gPSB0aGlzLnN1bW1hcnlba2V5XS5tYXAoZnVuY3Rpb24oaXRlbSkge1xyXG5cdFx0XHRcdGlmIChpdGVtIGluc3RhbmNlb2YgU3VtbWFyeSkgcmV0dXJuIGl0ZW0ucHJpbnQoKVxyXG5cdFx0XHRcdGVsc2UgcmV0dXJuIGNyYXdsKGl0ZW0pXHJcblx0XHRcdH0pXHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuc3VtbWFyeVtrZXldID0gY3Jhd2wodGhpcy5zdW1tYXJ5W2tleV0pXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zdW1tYXJ5XHJcblx0fVxyXG5cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IFN1bW1hcnkgfVxyXG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIC9bXFx1MDAxYlxcdTAwOWJdW1soKSM7P10qKD86WzAtOV17MSw0fSg/OjtbMC05XXswLDR9KSopP1swLTlBLVBSWmNmLW5xcnk9PjxdL2c7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhc3NlbWJsZVN0eWxlcyAoKSB7XG5cdHZhciBzdHlsZXMgPSB7XG5cdFx0bW9kaWZpZXJzOiB7XG5cdFx0XHRyZXNldDogWzAsIDBdLFxuXHRcdFx0Ym9sZDogWzEsIDIyXSwgLy8gMjEgaXNuJ3Qgd2lkZWx5IHN1cHBvcnRlZCBhbmQgMjIgZG9lcyB0aGUgc2FtZSB0aGluZ1xuXHRcdFx0ZGltOiBbMiwgMjJdLFxuXHRcdFx0aXRhbGljOiBbMywgMjNdLFxuXHRcdFx0dW5kZXJsaW5lOiBbNCwgMjRdLFxuXHRcdFx0aW52ZXJzZTogWzcsIDI3XSxcblx0XHRcdGhpZGRlbjogWzgsIDI4XSxcblx0XHRcdHN0cmlrZXRocm91Z2g6IFs5LCAyOV1cblx0XHR9LFxuXHRcdGNvbG9yczoge1xuXHRcdFx0YmxhY2s6IFszMCwgMzldLFxuXHRcdFx0cmVkOiBbMzEsIDM5XSxcblx0XHRcdGdyZWVuOiBbMzIsIDM5XSxcblx0XHRcdHllbGxvdzogWzMzLCAzOV0sXG5cdFx0XHRibHVlOiBbMzQsIDM5XSxcblx0XHRcdG1hZ2VudGE6IFszNSwgMzldLFxuXHRcdFx0Y3lhbjogWzM2LCAzOV0sXG5cdFx0XHR3aGl0ZTogWzM3LCAzOV0sXG5cdFx0XHRncmF5OiBbOTAsIDM5XVxuXHRcdH0sXG5cdFx0YmdDb2xvcnM6IHtcblx0XHRcdGJnQmxhY2s6IFs0MCwgNDldLFxuXHRcdFx0YmdSZWQ6IFs0MSwgNDldLFxuXHRcdFx0YmdHcmVlbjogWzQyLCA0OV0sXG5cdFx0XHRiZ1llbGxvdzogWzQzLCA0OV0sXG5cdFx0XHRiZ0JsdWU6IFs0NCwgNDldLFxuXHRcdFx0YmdNYWdlbnRhOiBbNDUsIDQ5XSxcblx0XHRcdGJnQ3lhbjogWzQ2LCA0OV0sXG5cdFx0XHRiZ1doaXRlOiBbNDcsIDQ5XVxuXHRcdH1cblx0fTtcblxuXHQvLyBmaXggaHVtYW5zXG5cdHN0eWxlcy5jb2xvcnMuZ3JleSA9IHN0eWxlcy5jb2xvcnMuZ3JheTtcblxuXHRPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwTmFtZSkge1xuXHRcdHZhciBncm91cCA9IHN0eWxlc1tncm91cE5hbWVdO1xuXG5cdFx0T2JqZWN0LmtleXMoZ3JvdXApLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xuXHRcdFx0dmFyIHN0eWxlID0gZ3JvdXBbc3R5bGVOYW1lXTtcblxuXHRcdFx0c3R5bGVzW3N0eWxlTmFtZV0gPSBncm91cFtzdHlsZU5hbWVdID0ge1xuXHRcdFx0XHRvcGVuOiAnXFx1MDAxYlsnICsgc3R5bGVbMF0gKyAnbScsXG5cdFx0XHRcdGNsb3NlOiAnXFx1MDAxYlsnICsgc3R5bGVbMV0gKyAnbSdcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCBncm91cE5hbWUsIHtcblx0XHRcdHZhbHVlOiBncm91cCxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdFx0fSk7XG5cdH0pO1xuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsICdleHBvcnRzJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGFzc2VtYmxlU3R5bGVzXG59KTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC5hc3luYyA9IGdsb2JhbC5hc3luYyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gc2xpY2UoYXJyYXlMaWtlLCBzdGFydCkge1xuICAgIHN0YXJ0ID0gc3RhcnR8MDtcbiAgICB2YXIgbmV3TGVuID0gTWF0aC5tYXgoYXJyYXlMaWtlLmxlbmd0aCAtIHN0YXJ0LCAwKTtcbiAgICB2YXIgbmV3QXJyID0gQXJyYXkobmV3TGVuKTtcbiAgICBmb3IodmFyIGlkeCA9IDA7IGlkeCA8IG5ld0xlbjsgaWR4KyspICB7XG4gICAgICAgIG5ld0FycltpZHhdID0gYXJyYXlMaWtlW3N0YXJ0ICsgaWR4XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0Fycjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29udGludWF0aW9uIGZ1bmN0aW9uIHdpdGggc29tZSBhcmd1bWVudHMgYWxyZWFkeSBhcHBsaWVkLlxuICpcbiAqIFVzZWZ1bCBhcyBhIHNob3J0aGFuZCB3aGVuIGNvbWJpbmVkIHdpdGggb3RoZXIgY29udHJvbCBmbG93IGZ1bmN0aW9ucy4gQW55XG4gKiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBhcmUgYWRkZWQgdG8gdGhlIGFyZ3VtZW50c1xuICogb3JpZ2luYWxseSBwYXNzZWQgdG8gYXBwbHkuXG4gKlxuICogQG5hbWUgYXBwbHlcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB5b3Ugd2FudCB0byBldmVudHVhbGx5IGFwcGx5IGFsbFxuICogYXJndW1lbnRzIHRvLiBJbnZva2VzIHdpdGggKGFyZ3VtZW50cy4uLikuXG4gKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHlcbiAqIHdoZW4gdGhlIGNvbnRpbnVhdGlvbiBpcyBjYWxsZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHRoZSBwYXJ0aWFsbHktYXBwbGllZCBmdW5jdGlvblxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyB1c2luZyBhcHBseVxuICogYXN5bmMucGFyYWxsZWwoW1xuICogICAgIGFzeW5jLmFwcGx5KGZzLndyaXRlRmlsZSwgJ3Rlc3RmaWxlMScsICd0ZXN0MScpLFxuICogICAgIGFzeW5jLmFwcGx5KGZzLndyaXRlRmlsZSwgJ3Rlc3RmaWxlMicsICd0ZXN0MicpXG4gKiBdKTtcbiAqXG4gKlxuICogLy8gdGhlIHNhbWUgcHJvY2VzcyB3aXRob3V0IHVzaW5nIGFwcGx5XG4gKiBhc3luYy5wYXJhbGxlbChbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgZnMud3JpdGVGaWxlKCd0ZXN0ZmlsZTEnLCAndGVzdDEnLCBjYWxsYmFjayk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBmcy53cml0ZUZpbGUoJ3Rlc3RmaWxlMicsICd0ZXN0MicsIGNhbGxiYWNrKTtcbiAqICAgICB9XG4gKiBdKTtcbiAqXG4gKiAvLyBJdCdzIHBvc3NpYmxlIHRvIHBhc3MgYW55IG51bWJlciBvZiBhZGRpdGlvbmFsIGFyZ3VtZW50cyB3aGVuIGNhbGxpbmcgdGhlXG4gKiAvLyBjb250aW51YXRpb246XG4gKlxuICogbm9kZT4gdmFyIGZuID0gYXN5bmMuYXBwbHkoc3lzLnB1dHMsICdvbmUnKTtcbiAqIG5vZGU+IGZuKCd0d28nLCAndGhyZWUnKTtcbiAqIG9uZVxuICogdHdvXG4gKiB0aHJlZVxuICovXG52YXIgYXBwbHkgPSBmdW5jdGlvbihmbi8qLCAuLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKC8qY2FsbEFyZ3MqLykge1xuICAgICAgICB2YXIgY2FsbEFyZ3MgPSBzbGljZShhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoY2FsbEFyZ3MpKTtcbiAgICB9O1xufTtcblxudmFyIGluaXRpYWxQYXJhbXMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC8qLi4uYXJncywgY2FsbGJhY2sqLykge1xuICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgIGZuLmNhbGwodGhpcywgYXJncywgY2FsbGJhY2spO1xuICAgIH07XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxudmFyIGhhc1NldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgJiYgc2V0SW1tZWRpYXRlO1xudmFyIGhhc05leHRUaWNrID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBmYWxsYmFjayhmbikge1xuICAgIHNldFRpbWVvdXQoZm4sIDApO1xufVxuXG5mdW5jdGlvbiB3cmFwKGRlZmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmbi8qLCAuLi5hcmdzKi8pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxudmFyIF9kZWZlcjtcblxuaWYgKGhhc1NldEltbWVkaWF0ZSkge1xuICAgIF9kZWZlciA9IHNldEltbWVkaWF0ZTtcbn0gZWxzZSBpZiAoaGFzTmV4dFRpY2spIHtcbiAgICBfZGVmZXIgPSBwcm9jZXNzLm5leHRUaWNrO1xufSBlbHNlIHtcbiAgICBfZGVmZXIgPSBmYWxsYmFjaztcbn1cblxudmFyIHNldEltbWVkaWF0ZSQxID0gd3JhcChfZGVmZXIpO1xuXG4vKipcbiAqIFRha2UgYSBzeW5jIGZ1bmN0aW9uIGFuZCBtYWtlIGl0IGFzeW5jLCBwYXNzaW5nIGl0cyByZXR1cm4gdmFsdWUgdG8gYVxuICogY2FsbGJhY2suIFRoaXMgaXMgdXNlZnVsIGZvciBwbHVnZ2luZyBzeW5jIGZ1bmN0aW9ucyBpbnRvIGEgd2F0ZXJmYWxsLFxuICogc2VyaWVzLCBvciBvdGhlciBhc3luYyBmdW5jdGlvbnMuIEFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBnZW5lcmF0ZWRcbiAqIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIChleGNlcHQgZm9yIHRoZSBmaW5hbFxuICogY2FsbGJhY2sgYXJndW1lbnQpLiBFcnJvcnMgdGhyb3duIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjay5cbiAqXG4gKiBJZiB0aGUgZnVuY3Rpb24gcGFzc2VkIHRvIGBhc3luY2lmeWAgcmV0dXJucyBhIFByb21pc2UsIHRoYXQgcHJvbWlzZXMnc1xuICogcmVzb2x2ZWQvcmVqZWN0ZWQgc3RhdGUgd2lsbCBiZSB1c2VkIHRvIGNhbGwgdGhlIGNhbGxiYWNrLCByYXRoZXIgdGhhbiBzaW1wbHlcbiAqIHRoZSBzeW5jaHJvbm91cyByZXR1cm4gdmFsdWUuXG4gKlxuICogVGhpcyBhbHNvIG1lYW5zIHlvdSBjYW4gYXN5bmNpZnkgRVMyMDE3IGBhc3luY2AgZnVuY3Rpb25zLlxuICpcbiAqIEBuYW1lIGFzeW5jaWZ5XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgd3JhcFN5bmNcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gVGhlIHN5bmNocm9ub3VzIGZ1bmN0aW9uLCBvciBQcm9taXNlLXJldHVybmluZ1xuICogZnVuY3Rpb24gdG8gY29udmVydCB0byBhbiB7QGxpbmsgQXN5bmNGdW5jdGlvbn0uXG4gKiBAcmV0dXJucyB7QXN5bmNGdW5jdGlvbn0gQW4gYXN5bmNocm9ub3VzIHdyYXBwZXIgb2YgdGhlIGBmdW5jYC4gVG8gYmVcbiAqIGludm9rZWQgd2l0aCBgKGFyZ3MuLi4sIGNhbGxiYWNrKWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIHBhc3NpbmcgYSByZWd1bGFyIHN5bmNocm9ub3VzIGZ1bmN0aW9uXG4gKiBhc3luYy53YXRlcmZhbGwoW1xuICogICAgIGFzeW5jLmFwcGx5KGZzLnJlYWRGaWxlLCBmaWxlbmFtZSwgXCJ1dGY4XCIpLFxuICogICAgIGFzeW5jLmFzeW5jaWZ5KEpTT04ucGFyc2UpLFxuICogICAgIGZ1bmN0aW9uIChkYXRhLCBuZXh0KSB7XG4gKiAgICAgICAgIC8vIGRhdGEgaXMgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIHRoZSB0ZXh0LlxuICogICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwYXJzaW5nIGVycm9yLCBpdCB3b3VsZCBoYXZlIGJlZW4gY2F1Z2h0LlxuICogICAgIH1cbiAqIF0sIGNhbGxiYWNrKTtcbiAqXG4gKiAvLyBwYXNzaW5nIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgcHJvbWlzZVxuICogYXN5bmMud2F0ZXJmYWxsKFtcbiAqICAgICBhc3luYy5hcHBseShmcy5yZWFkRmlsZSwgZmlsZW5hbWUsIFwidXRmOFwiKSxcbiAqICAgICBhc3luYy5hc3luY2lmeShmdW5jdGlvbiAoY29udGVudHMpIHtcbiAqICAgICAgICAgcmV0dXJuIGRiLm1vZGVsLmNyZWF0ZShjb250ZW50cyk7XG4gKiAgICAgfSksXG4gKiAgICAgZnVuY3Rpb24gKG1vZGVsLCBuZXh0KSB7XG4gKiAgICAgICAgIC8vIGBtb2RlbGAgaXMgdGhlIGluc3RhbnRpYXRlZCBtb2RlbCBvYmplY3QuXG4gKiAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBlcnJvciwgdGhpcyBmdW5jdGlvbiB3b3VsZCBiZSBza2lwcGVkLlxuICogICAgIH1cbiAqIF0sIGNhbGxiYWNrKTtcbiAqXG4gKiAvLyBlczIwMTcgZXhhbXBsZSwgdGhvdWdoIGBhc3luY2lmeWAgaXMgbm90IG5lZWRlZCBpZiB5b3VyIEpTIGVudmlyb25tZW50XG4gKiAvLyBzdXBwb3J0cyBhc3luYyBmdW5jdGlvbnMgb3V0IG9mIHRoZSBib3hcbiAqIHZhciBxID0gYXN5bmMucXVldWUoYXN5bmMuYXN5bmNpZnkoYXN5bmMgZnVuY3Rpb24oZmlsZSkge1xuICogICAgIHZhciBpbnRlcm1lZGlhdGVTdGVwID0gYXdhaXQgcHJvY2Vzc0ZpbGUoZmlsZSk7XG4gKiAgICAgcmV0dXJuIGF3YWl0IHNvbWVQcm9taXNlKGludGVybWVkaWF0ZVN0ZXApXG4gKiB9KSk7XG4gKlxuICogcS5wdXNoKGZpbGVzKTtcbiAqL1xuZnVuY3Rpb24gYXN5bmNpZnkoZnVuYykge1xuICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHJlc3VsdCBpcyBQcm9taXNlIG9iamVjdFxuICAgICAgICBpZiAoaXNPYmplY3QocmVzdWx0KSAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2soY2FsbGJhY2ssIG51bGwsIHZhbHVlKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIGludm9rZUNhbGxiYWNrKGNhbGxiYWNrLCBlcnIubWVzc2FnZSA/IGVyciA6IG5ldyBFcnJvcihlcnIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBpbnZva2VDYWxsYmFjayhjYWxsYmFjaywgZXJyb3IsIHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IsIHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZSQxKHJldGhyb3csIGUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmV0aHJvdyhlcnJvcikge1xuICAgIHRocm93IGVycm9yO1xufVxuXG52YXIgc3VwcG9ydHNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBpc0FzeW5jKGZuKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRzU3ltYm9sICYmIGZuW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdBc3luY0Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gd3JhcEFzeW5jKGFzeW5jRm4pIHtcbiAgICByZXR1cm4gaXNBc3luYyhhc3luY0ZuKSA/IGFzeW5jaWZ5KGFzeW5jRm4pIDogYXN5bmNGbjtcbn1cblxuZnVuY3Rpb24gYXBwbHlFYWNoJDEoZWFjaGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZucy8qLCAuLi5hcmdzKi8pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICB2YXIgZ28gPSBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZWFjaGZuKGZucywgZnVuY3Rpb24gKGZuLCBjYikge1xuICAgICAgICAgICAgICAgIHdyYXBBc3luYyhmbikuYXBwbHkodGhhdCwgYXJncy5jb25jYXQoY2IpKTtcbiAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGdvLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdvO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wkMSA9IHJvb3QuU3ltYm9sO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWckMSA9IFN5bWJvbCQxID8gU3ltYm9sJDEudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnJDEpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWckMV07XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kMSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyQxID0gb2JqZWN0UHJvdG8kMS50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZyQxLmNhbGwodmFsdWUpO1xufVxuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJztcbnZhciB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wkMSA/IFN5bWJvbCQxLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJztcbnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbnZhciBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xudmFyIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8vIEEgdGVtcG9yYXJ5IHZhbHVlIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGxvb3Agc2hvdWxkIGJlIGJyb2tlbi5cbi8vIFNlZSAjMTA2NCwgIzEyOTNcbnZhciBicmVha0xvb3AgPSB7fTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxuZnVuY3Rpb24gb25jZShmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChmbiA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICB2YXIgY2FsbEZuID0gZm47XG4gICAgICAgIGZuID0gbnVsbDtcbiAgICAgICAgY2FsbEZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxudmFyIGl0ZXJhdG9yU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG5cbnZhciBnZXRJdGVyYXRvciA9IGZ1bmN0aW9uIChjb2xsKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yU3ltYm9sICYmIGNvbGxbaXRlcmF0b3JTeW1ib2xdICYmIGNvbGxbaXRlcmF0b3JTeW1ib2xdKCk7XG59O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDMgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQyID0gb2JqZWN0UHJvdG8kMy5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90byQzLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eSQyLmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIkMSA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIkMSA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnJDEgPSAnW29iamVjdCBBcmd1bWVudHNdJztcbnZhciBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XSc7XG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJztcbnZhciBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nO1xudmFyIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJztcbnZhciBmdW5jVGFnJDEgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nO1xudmFyIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nO1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xudmFyIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nO1xudmFyIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xudmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xudmFyIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xudmFyIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJztcbnZhciBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc7XG52YXIgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nO1xudmFyIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nO1xudmFyIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nO1xudmFyIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nO1xudmFyIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSc7XG52YXIgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJztcbnZhciB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZyQxXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnJDFdID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMkMSA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUkMSA9IGZyZWVFeHBvcnRzJDEgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyQxID0gZnJlZU1vZHVsZSQxICYmIGZyZWVNb2R1bGUkMS5leHBvcnRzID09PSBmcmVlRXhwb3J0cyQxO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMkMSAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUkMSAmJiBmcmVlTW9kdWxlJDEucmVxdWlyZSAmJiBmcmVlTW9kdWxlJDEucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDIgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQxID0gb2JqZWN0UHJvdG8kMi5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eSQxLmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQ1ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90byQ1O1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQ0ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkMyA9IG9iamVjdFByb3RvJDQuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQzLmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlJdGVyYXRvcihjb2xsKSB7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gY29sbC5sZW5ndGg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHJldHVybiArK2kgPCBsZW4gPyB7dmFsdWU6IGNvbGxbaV0sIGtleTogaX0gOiBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRVMyMDE1SXRlcmF0b3IoaXRlcmF0b3IpIHtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIgaXRlbSA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZW0uZG9uZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpKys7XG4gICAgICAgIHJldHVybiB7dmFsdWU6IGl0ZW0udmFsdWUsIGtleTogaX07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3RJdGVyYXRvcihvYmopIHtcbiAgICB2YXIgb2tleXMgPSBrZXlzKG9iaik7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gb2tleXMubGVuZ3RoO1xuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIga2V5ID0gb2tleXNbKytpXTtcbiAgICAgICAgcmV0dXJuIGkgPCBsZW4gPyB7dmFsdWU6IG9ialtrZXldLCBrZXk6IGtleX0gOiBudWxsO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGl0ZXJhdG9yKGNvbGwpIHtcbiAgICBpZiAoaXNBcnJheUxpa2UoY29sbCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFycmF5SXRlcmF0b3IoY29sbCk7XG4gICAgfVxuXG4gICAgdmFyIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoY29sbCk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yID8gY3JlYXRlRVMyMDE1SXRlcmF0b3IoaXRlcmF0b3IpIDogY3JlYXRlT2JqZWN0SXRlcmF0b3IoY29sbCk7XG59XG5cbmZ1bmN0aW9uIG9ubHlPbmNlKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZm4gPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIHdhcyBhbHJlYWR5IGNhbGxlZC5cIik7XG4gICAgICAgIHZhciBjYWxsRm4gPSBmbjtcbiAgICAgICAgZm4gPSBudWxsO1xuICAgICAgICBjYWxsRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBfZWFjaE9mTGltaXQobGltaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICAgICAgaWYgKGxpbWl0IDw9IDAgfHwgIW9iaikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXh0RWxlbSA9IGl0ZXJhdG9yKG9iaik7XG4gICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgIHZhciBydW5uaW5nID0gMDtcbiAgICAgICAgdmFyIGxvb3BpbmcgPSBmYWxzZTtcblxuICAgICAgICBmdW5jdGlvbiBpdGVyYXRlZUNhbGxiYWNrKGVyciwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJ1bm5pbmcgLT0gMTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IGJyZWFrTG9vcCB8fCAoZG9uZSAmJiBydW5uaW5nIDw9IDApKSB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWxvb3BpbmcpIHtcbiAgICAgICAgICAgICAgICByZXBsZW5pc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxlbmlzaCAoKSB7XG4gICAgICAgICAgICBsb29waW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChydW5uaW5nIDwgbGltaXQgJiYgIWRvbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IG5leHRFbGVtKCk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydW5uaW5nIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnVubmluZyArPSAxO1xuICAgICAgICAgICAgICAgIGl0ZXJhdGVlKGVsZW0udmFsdWUsIGVsZW0ua2V5LCBvbmx5T25jZShpdGVyYXRlZUNhbGxiYWNrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb29waW5nID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXBsZW5pc2goKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZWFjaE9mYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gKiB0aW1lLlxuICpcbiAqIEBuYW1lIGVhY2hPZkxpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5lYWNoT2Zde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNoT2Z9XG4gKiBAYWxpYXMgZm9yRWFjaE9mTGltaXRcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaFxuICogaXRlbSBpbiBgY29sbGAuIFRoZSBga2V5YCBpcyB0aGUgaXRlbSdzIGtleSwgb3IgaW5kZXggaW4gdGhlIGNhc2Ugb2YgYW5cbiAqIGFycmF5LlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBJbnZva2VkIHdpdGggKGVycikuXG4gKi9cbmZ1bmN0aW9uIGVhY2hPZkxpbWl0KGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBfZWFjaE9mTGltaXQobGltaXQpKGNvbGwsIHdyYXBBc3luYyhpdGVyYXRlZSksIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZG9MaW1pdChmbiwgbGltaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZuKGl0ZXJhYmxlLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbiAgICB9O1xufVxuXG4vLyBlYWNoT2YgaW1wbGVtZW50YXRpb24gb3B0aW1pemVkIGZvciBhcnJheS1saWtlc1xuZnVuY3Rpb24gZWFjaE9mQXJyYXlMaWtlKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICBjb21wbGV0ZWQgPSAwLFxuICAgICAgICBsZW5ndGggPSBjb2xsLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yQ2FsbGJhY2soZXJyLCB2YWx1ZSkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9IGVsc2UgaWYgKCgrK2NvbXBsZXRlZCA9PT0gbGVuZ3RoKSB8fCB2YWx1ZSA9PT0gYnJlYWtMb29wKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBpdGVyYXRlZShjb2xsW2luZGV4XSwgaW5kZXgsIG9ubHlPbmNlKGl0ZXJhdG9yQ2FsbGJhY2spKTtcbiAgICB9XG59XG5cbi8vIGEgZ2VuZXJpYyB2ZXJzaW9uIG9mIGVhY2hPZiB3aGljaCBjYW4gaGFuZGxlIGFycmF5LCBvYmplY3QsIGFuZCBpdGVyYXRvciBjYXNlcy5cbnZhciBlYWNoT2ZHZW5lcmljID0gZG9MaW1pdChlYWNoT2ZMaW1pdCwgSW5maW5pdHkpO1xuXG4vKipcbiAqIExpa2UgW2BlYWNoYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9LCBleGNlcHQgdGhhdCBpdCBwYXNzZXMgdGhlIGtleSAob3IgaW5kZXgpIGFzIHRoZSBzZWNvbmQgYXJndW1lbnRcbiAqIHRvIHRoZSBpdGVyYXRlZS5cbiAqXG4gKiBAbmFtZSBlYWNoT2ZcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBhbGlhcyBmb3JFYWNoT2ZcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAc2VlIFthc3luYy5lYWNoXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH1cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2hcbiAqIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGBrZXlgIGlzIHRoZSBpdGVtJ3Mga2V5LCBvciBpbmRleCBpbiB0aGUgY2FzZSBvZiBhbiBhcnJheS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqID0ge2RldjogXCIvZGV2Lmpzb25cIiwgdGVzdDogXCIvdGVzdC5qc29uXCIsIHByb2Q6IFwiL3Byb2QuanNvblwifTtcbiAqIHZhciBjb25maWdzID0ge307XG4gKlxuICogYXN5bmMuZm9yRWFjaE9mKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXksIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMucmVhZEZpbGUoX19kaXJuYW1lICsgdmFsdWUsIFwidXRmOFwiLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gKiAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICogICAgICAgICB0cnkge1xuICogICAgICAgICAgICAgY29uZmlnc1trZXldID0gSlNPTi5wYXJzZShkYXRhKTtcbiAqICAgICAgICAgfSBjYXRjaCAoZSkge1xuICogICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICogICAgICAgICB9XG4gKiAgICAgICAgIGNhbGxiYWNrKCk7XG4gKiAgICAgfSk7XG4gKiB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgaWYgKGVycikgY29uc29sZS5lcnJvcihlcnIubWVzc2FnZSk7XG4gKiAgICAgLy8gY29uZmlncyBpcyBub3cgYSBtYXAgb2YgSlNPTiBkYXRhXG4gKiAgICAgZG9Tb21ldGhpbmdXaXRoKGNvbmZpZ3MpO1xuICogfSk7XG4gKi9cbnZhciBlYWNoT2YgPSBmdW5jdGlvbihjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZWFjaE9mSW1wbGVtZW50YXRpb24gPSBpc0FycmF5TGlrZShjb2xsKSA/IGVhY2hPZkFycmF5TGlrZSA6IGVhY2hPZkdlbmVyaWM7XG4gICAgZWFjaE9mSW1wbGVtZW50YXRpb24oY29sbCwgd3JhcEFzeW5jKGl0ZXJhdGVlKSwgY2FsbGJhY2spO1xufTtcblxuZnVuY3Rpb24gZG9QYXJhbGxlbChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZuKGVhY2hPZiwgb2JqLCB3cmFwQXN5bmMoaXRlcmF0ZWUpLCBjYWxsYmFjayk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gX2FzeW5jTWFwKGVhY2hmbiwgYXJyLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gICAgYXJyID0gYXJyIHx8IFtdO1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuXG4gICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHZhbHVlLCBfLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaW5kZXggPSBjb3VudGVyKys7XG4gICAgICAgIF9pdGVyYXRlZSh2YWx1ZSwgZnVuY3Rpb24gKGVyciwgdikge1xuICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSB2O1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFByb2R1Y2VzIGEgbmV3IGNvbGxlY3Rpb24gb2YgdmFsdWVzIGJ5IG1hcHBpbmcgZWFjaCB2YWx1ZSBpbiBgY29sbGAgdGhyb3VnaFxuICogdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24uIFRoZSBgaXRlcmF0ZWVgIGlzIGNhbGxlZCB3aXRoIGFuIGl0ZW0gZnJvbSBgY29sbGBcbiAqIGFuZCBhIGNhbGxiYWNrIGZvciB3aGVuIGl0IGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nLiBFYWNoIG9mIHRoZXNlIGNhbGxiYWNrXG4gKiB0YWtlcyAyIGFyZ3VtZW50czogYW4gYGVycm9yYCwgYW5kIHRoZSB0cmFuc2Zvcm1lZCBpdGVtIGZyb20gYGNvbGxgLiBJZlxuICogYGl0ZXJhdGVlYCBwYXNzZXMgYW4gZXJyb3IgdG8gaXRzIGNhbGxiYWNrLCB0aGUgbWFpbiBgY2FsbGJhY2tgIChmb3IgdGhlXG4gKiBgbWFwYCBmdW5jdGlvbikgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLlxuICpcbiAqIE5vdGUsIHRoYXQgc2luY2UgdGhpcyBmdW5jdGlvbiBhcHBsaWVzIHRoZSBgaXRlcmF0ZWVgIHRvIGVhY2ggaXRlbSBpblxuICogcGFyYWxsZWwsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyB3aWxsIGNvbXBsZXRlXG4gKiBpbiBvcmRlci4gSG93ZXZlciwgdGhlIHJlc3VsdHMgYXJyYXkgd2lsbCBiZSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbiAqIG9yaWdpbmFsIGBjb2xsYC5cbiAqXG4gKiBJZiBgbWFwYCBpcyBwYXNzZWQgYW4gT2JqZWN0LCB0aGUgcmVzdWx0cyB3aWxsIGJlIGFuIEFycmF5LiAgVGhlIHJlc3VsdHNcbiAqIHdpbGwgcm91Z2hseSBiZSBpbiB0aGUgb3JkZXIgb2YgdGhlIG9yaWdpbmFsIE9iamVjdHMnIGtleXMgKGJ1dCB0aGlzIGNhblxuICogdmFyeSBhY3Jvc3MgSmF2YVNjcmlwdCBlbmdpbmVzKS5cbiAqXG4gKiBAbmFtZSBtYXBcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIGl0ZW0uXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIEFycmF5IG9mIHRoZVxuICogdHJhbnNmb3JtZWQgaXRlbXMgZnJvbSB0aGUgYGNvbGxgLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLm1hcChbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmcy5zdGF0LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAvLyByZXN1bHRzIGlzIG5vdyBhbiBhcnJheSBvZiBzdGF0cyBmb3IgZWFjaCBmaWxlXG4gKiB9KTtcbiAqL1xudmFyIG1hcCA9IGRvUGFyYWxsZWwoX2FzeW5jTWFwKTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBwcm92aWRlZCBhcmd1bWVudHMgdG8gZWFjaCBmdW5jdGlvbiBpbiB0aGUgYXJyYXksIGNhbGxpbmdcbiAqIGBjYWxsYmFja2AgYWZ0ZXIgYWxsIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZC4gSWYgeW91IG9ubHkgcHJvdmlkZSB0aGUgZmlyc3RcbiAqIGFyZ3VtZW50LCBgZm5zYCwgdGhlbiBpdCB3aWxsIHJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIGxldHMgeW91IHBhc3MgaW4gdGhlXG4gKiBhcmd1bWVudHMgYXMgaWYgaXQgd2VyZSBhIHNpbmdsZSBmdW5jdGlvbiBjYWxsLiBJZiBtb3JlIGFyZ3VtZW50cyBhcmVcbiAqIHByb3ZpZGVkLCBgY2FsbGJhY2tgIGlzIHJlcXVpcmVkIHdoaWxlIGBhcmdzYCBpcyBzdGlsbCBvcHRpb25hbC5cbiAqXG4gKiBAbmFtZSBhcHBseUVhY2hcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBmbnMgLSBBIGNvbGxlY3Rpb24gb2Yge0BsaW5rIEFzeW5jRnVuY3Rpb259c1xuICogdG8gYWxsIGNhbGwgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHNcbiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIC0gYW55IG51bWJlciBvZiBzZXBhcmF0ZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGVcbiAqIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIHRoZSBmaW5hbCBhcmd1bWVudCBzaG91bGQgYmUgdGhlIGNhbGxiYWNrLFxuICogY2FsbGVkIHdoZW4gYWxsIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZCBwcm9jZXNzaW5nLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIElmIG9ubHkgdGhlIGZpcnN0IGFyZ3VtZW50LCBgZm5zYCwgaXMgcHJvdmlkZWQsIGl0IHdpbGxcbiAqIHJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIGxldHMgeW91IHBhc3MgaW4gdGhlIGFyZ3VtZW50cyBhcyBpZiBpdCB3ZXJlIGEgc2luZ2xlXG4gKiBmdW5jdGlvbiBjYWxsLiBUaGUgc2lnbmF0dXJlIGlzIGAoLi5hcmdzLCBjYWxsYmFjaylgLiBJZiBpbnZva2VkIHdpdGggYW55XG4gKiBhcmd1bWVudHMsIGBjYWxsYmFja2AgaXMgcmVxdWlyZWQuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLmFwcGx5RWFjaChbZW5hYmxlU2VhcmNoLCB1cGRhdGVTY2hlbWFdLCAnYnVja2V0JywgY2FsbGJhY2spO1xuICpcbiAqIC8vIHBhcnRpYWwgYXBwbGljYXRpb24gZXhhbXBsZTpcbiAqIGFzeW5jLmVhY2goXG4gKiAgICAgYnVja2V0cyxcbiAqICAgICBhc3luYy5hcHBseUVhY2goW2VuYWJsZVNlYXJjaCwgdXBkYXRlU2NoZW1hXSksXG4gKiAgICAgY2FsbGJhY2tcbiAqICk7XG4gKi9cbnZhciBhcHBseUVhY2ggPSBhcHBseUVhY2gkMShtYXApO1xuXG5mdW5jdGlvbiBkb1BhcmFsbGVsTGltaXQoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZm4oX2VhY2hPZkxpbWl0KGxpbWl0KSwgb2JqLCB3cmFwQXN5bmMoaXRlcmF0ZWUpLCBjYWxsYmFjayk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIG1hcExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5tYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCBpdGVtLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyBhbiBhcnJheSBvZiB0aGVcbiAqIHRyYW5zZm9ybWVkIGl0ZW1zIGZyb20gdGhlIGBjb2xsYC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICovXG52YXIgbWFwTGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2FzeW5jTWFwKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBtYXBTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLm1hcF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH1cbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIGl0ZW0uXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5IG9mIHRoZVxuICogdHJhbnNmb3JtZWQgaXRlbXMgZnJvbSB0aGUgYGNvbGxgLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKi9cbnZhciBtYXBTZXJpZXMgPSBkb0xpbWl0KG1hcExpbWl0LCAxKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGFwcGx5RWFjaGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5hcHBseUVhY2h9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBhcHBseUVhY2hTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmFwcGx5RWFjaF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmFwcGx5RWFjaH1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBmbnMgLSBBIGNvbGxlY3Rpb24gb2Yge0BsaW5rIEFzeW5jRnVuY3Rpb259cyB0byBhbGxcbiAqIGNhbGwgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHNcbiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIC0gYW55IG51bWJlciBvZiBzZXBhcmF0ZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGVcbiAqIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIHRoZSBmaW5hbCBhcmd1bWVudCBzaG91bGQgYmUgdGhlIGNhbGxiYWNrLFxuICogY2FsbGVkIHdoZW4gYWxsIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZCBwcm9jZXNzaW5nLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIElmIG9ubHkgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBpdCB3aWxsIHJldHVyblxuICogYSBmdW5jdGlvbiB3aGljaCBsZXRzIHlvdSBwYXNzIGluIHRoZSBhcmd1bWVudHMgYXMgaWYgaXQgd2VyZSBhIHNpbmdsZVxuICogZnVuY3Rpb24gY2FsbC5cbiAqL1xudmFyIGFwcGx5RWFjaFNlcmllcyA9IGFwcGx5RWFjaCQxKG1hcFNlcmllcyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGJlc3Qgb3JkZXIgZm9yIHJ1bm5pbmcgdGhlIHtAbGluayBBc3luY0Z1bmN0aW9ufXMgaW4gYHRhc2tzYCwgYmFzZWQgb25cbiAqIHRoZWlyIHJlcXVpcmVtZW50cy4gRWFjaCBmdW5jdGlvbiBjYW4gb3B0aW9uYWxseSBkZXBlbmQgb24gb3RoZXIgZnVuY3Rpb25zXG4gKiBiZWluZyBjb21wbGV0ZWQgZmlyc3QsIGFuZCBlYWNoIGZ1bmN0aW9uIGlzIHJ1biBhcyBzb29uIGFzIGl0cyByZXF1aXJlbWVudHNcbiAqIGFyZSBzYXRpc2ZpZWQuXG4gKlxuICogSWYgYW55IG9mIHRoZSB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIHBhc3MgYW4gZXJyb3IgdG8gdGhlaXIgY2FsbGJhY2ssIHRoZSBgYXV0b2Agc2VxdWVuY2VcbiAqIHdpbGwgc3RvcC4gRnVydGhlciB0YXNrcyB3aWxsIG5vdCBleGVjdXRlIChzbyBhbnkgb3RoZXIgZnVuY3Rpb25zIGRlcGVuZGluZ1xuICogb24gaXQgd2lsbCBub3QgcnVuKSwgYW5kIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlXG4gKiBlcnJvci5cbiAqXG4gKiB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIGFsc28gcmVjZWl2ZSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVzdWx0cyBvZiBmdW5jdGlvbnMgd2hpY2hcbiAqIGhhdmUgY29tcGxldGVkIHNvIGZhciBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIGlmIHRoZXkgaGF2ZSBkZXBlbmRlbmNpZXMuIElmIGFcbiAqIHRhc2sgZnVuY3Rpb24gaGFzIG5vIGRlcGVuZGVuY2llcywgaXQgd2lsbCBvbmx5IGJlIHBhc3NlZCBhIGNhbGxiYWNrLlxuICpcbiAqIEBuYW1lIGF1dG9cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXNrcyAtIEFuIG9iamVjdC4gRWFjaCBvZiBpdHMgcHJvcGVydGllcyBpcyBlaXRoZXIgYVxuICogZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2YgcmVxdWlyZW1lbnRzLCB3aXRoIHRoZSB7QGxpbmsgQXN5bmNGdW5jdGlvbn0gaXRzZWxmIHRoZSBsYXN0IGl0ZW1cbiAqIGluIHRoZSBhcnJheS4gVGhlIG9iamVjdCdzIGtleSBvZiBhIHByb3BlcnR5IHNlcnZlcyBhcyB0aGUgbmFtZSBvZiB0aGUgdGFza1xuICogZGVmaW5lZCBieSB0aGF0IHByb3BlcnR5LCBpLmUuIGNhbiBiZSB1c2VkIHdoZW4gc3BlY2lmeWluZyByZXF1aXJlbWVudHMgZm9yXG4gKiBvdGhlciB0YXNrcy4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIG9uZSBvciB0d28gYXJndW1lbnRzOlxuICogKiBhIGByZXN1bHRzYCBvYmplY3QsIGNvbnRhaW5pbmcgdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzbHkgZXhlY3V0ZWRcbiAqICAgZnVuY3Rpb25zLCBvbmx5IHBhc3NlZCBpZiB0aGUgdGFzayBoYXMgYW55IGRlcGVuZGVuY2llcyxcbiAqICogYSBgY2FsbGJhY2soZXJyLCByZXN1bHQpYCBmdW5jdGlvbiwgd2hpY2ggbXVzdCBiZSBjYWxsZWQgd2hlbiBmaW5pc2hlZCxcbiAqICAgcGFzc2luZyBhbiBgZXJyb3JgICh3aGljaCBjYW4gYmUgYG51bGxgKSBhbmQgdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24nc1xuICogICBleGVjdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbmN5PUluZmluaXR5XSAtIEFuIG9wdGlvbmFsIGBpbnRlZ2VyYCBmb3JcbiAqIGRldGVybWluaW5nIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0YXNrcyB0aGF0IGNhbiBiZSBydW4gaW4gcGFyYWxsZWwuIEJ5XG4gKiBkZWZhdWx0LCBhcyBtYW55IGFzIHBvc3NpYmxlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICogdGhlIHRhc2tzIGhhdmUgYmVlbiBjb21wbGV0ZWQuIEl0IHJlY2VpdmVzIHRoZSBgZXJyYCBhcmd1bWVudCBpZiBhbnkgYHRhc2tzYFxuICogcGFzcyBhbiBlcnJvciB0byB0aGVpciBjYWxsYmFjay4gUmVzdWx0cyBhcmUgYWx3YXlzIHJldHVybmVkOyBob3dldmVyLCBpZiBhblxuICogZXJyb3Igb2NjdXJzLCBubyBmdXJ0aGVyIGB0YXNrc2Agd2lsbCBiZSBwZXJmb3JtZWQsIGFuZCB0aGUgcmVzdWx0cyBvYmplY3RcbiAqIHdpbGwgb25seSBjb250YWluIHBhcnRpYWwgcmVzdWx0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMgdW5kZWZpbmVkXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLmF1dG8oe1xuICogICAgIC8vIHRoaXMgZnVuY3Rpb24gd2lsbCBqdXN0IGJlIHBhc3NlZCBhIGNhbGxiYWNrXG4gKiAgICAgcmVhZERhdGE6IGFzeW5jLmFwcGx5KGZzLnJlYWRGaWxlLCAnZGF0YS50eHQnLCAndXRmLTgnKSxcbiAqICAgICBzaG93RGF0YTogWydyZWFkRGF0YScsIGZ1bmN0aW9uKHJlc3VsdHMsIGNiKSB7XG4gKiAgICAgICAgIC8vIHJlc3VsdHMucmVhZERhdGEgaXMgdGhlIGZpbGUncyBjb250ZW50c1xuICogICAgICAgICAvLyAuLi5cbiAqICAgICB9XVxuICogfSwgY2FsbGJhY2spO1xuICpcbiAqIGFzeW5jLmF1dG8oe1xuICogICAgIGdldF9kYXRhOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBjb25zb2xlLmxvZygnaW4gZ2V0X2RhdGEnKTtcbiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBnZXQgc29tZSBkYXRhXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdkYXRhJywgJ2NvbnZlcnRlZCB0byBhcnJheScpO1xuICogICAgIH0sXG4gKiAgICAgbWFrZV9mb2xkZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCdpbiBtYWtlX2ZvbGRlcicpO1xuICogICAgICAgICAvLyBhc3luYyBjb2RlIHRvIGNyZWF0ZSBhIGRpcmVjdG9yeSB0byBzdG9yZSBhIGZpbGUgaW5cbiAqICAgICAgICAgLy8gdGhpcyBpcyBydW4gYXQgdGhlIHNhbWUgdGltZSBhcyBnZXR0aW5nIHRoZSBkYXRhXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmb2xkZXInKTtcbiAqICAgICB9LFxuICogICAgIHdyaXRlX2ZpbGU6IFsnZ2V0X2RhdGEnLCAnbWFrZV9mb2xkZXInLCBmdW5jdGlvbihyZXN1bHRzLCBjYWxsYmFjaykge1xuICogICAgICAgICBjb25zb2xlLmxvZygnaW4gd3JpdGVfZmlsZScsIEpTT04uc3RyaW5naWZ5KHJlc3VsdHMpKTtcbiAqICAgICAgICAgLy8gb25jZSB0aGVyZSBpcyBzb21lIGRhdGEgYW5kIHRoZSBkaXJlY3RvcnkgZXhpc3RzLFxuICogICAgICAgICAvLyB3cml0ZSB0aGUgZGF0YSB0byBhIGZpbGUgaW4gdGhlIGRpcmVjdG9yeVxuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZmlsZW5hbWUnKTtcbiAqICAgICB9XSxcbiAqICAgICBlbWFpbF9saW5rOiBbJ3dyaXRlX2ZpbGUnLCBmdW5jdGlvbihyZXN1bHRzLCBjYWxsYmFjaykge1xuICogICAgICAgICBjb25zb2xlLmxvZygnaW4gZW1haWxfbGluaycsIEpTT04uc3RyaW5naWZ5KHJlc3VsdHMpKTtcbiAqICAgICAgICAgLy8gb25jZSB0aGUgZmlsZSBpcyB3cml0dGVuIGxldCdzIGVtYWlsIGEgbGluayB0byBpdC4uLlxuICogICAgICAgICAvLyByZXN1bHRzLndyaXRlX2ZpbGUgY29udGFpbnMgdGhlIGZpbGVuYW1lIHJldHVybmVkIGJ5IHdyaXRlX2ZpbGUuXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6cmVzdWx0cy53cml0ZV9maWxlLCAnZW1haWwnOid1c2VyQGV4YW1wbGUuY29tJ30pO1xuICogICAgIH1dXG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZXJyID0gJywgZXJyKTtcbiAqICAgICBjb25zb2xlLmxvZygncmVzdWx0cyA9ICcsIHJlc3VsdHMpO1xuICogfSk7XG4gKi9cbnZhciBhdXRvID0gZnVuY3Rpb24gKHRhc2tzLCBjb25jdXJyZW5jeSwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNvbmN1cnJlbmN5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGNvbmN1cnJlbmN5IGlzIG9wdGlvbmFsLCBzaGlmdCB0aGUgYXJncy5cbiAgICAgICAgY2FsbGJhY2sgPSBjb25jdXJyZW5jeTtcbiAgICAgICAgY29uY3VycmVuY3kgPSBudWxsO1xuICAgIH1cbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgdmFyIGtleXMkJDEgPSBrZXlzKHRhc2tzKTtcbiAgICB2YXIgbnVtVGFza3MgPSBrZXlzJCQxLmxlbmd0aDtcbiAgICBpZiAoIW51bVRhc2tzKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG4gICAgaWYgKCFjb25jdXJyZW5jeSkge1xuICAgICAgICBjb25jdXJyZW5jeSA9IG51bVRhc2tzO1xuICAgIH1cblxuICAgIHZhciByZXN1bHRzID0ge307XG4gICAgdmFyIHJ1bm5pbmdUYXNrcyA9IDA7XG4gICAgdmFyIGhhc0Vycm9yID0gZmFsc2U7XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHZhciByZWFkeVRhc2tzID0gW107XG5cbiAgICAvLyBmb3IgY3ljbGUgZGV0ZWN0aW9uOlxuICAgIHZhciByZWFkeVRvQ2hlY2sgPSBbXTsgLy8gdGFza3MgdGhhdCBoYXZlIGJlZW4gaWRlbnRpZmllZCBhcyByZWFjaGFibGVcbiAgICAvLyB3aXRob3V0IHRoZSBwb3NzaWJpbGl0eSBvZiByZXR1cm5pbmcgdG8gYW4gYW5jZXN0b3IgdGFza1xuICAgIHZhciB1bmNoZWNrZWREZXBlbmRlbmNpZXMgPSB7fTtcblxuICAgIGJhc2VGb3JPd24odGFza3MsIGZ1bmN0aW9uICh0YXNrLCBrZXkpIHtcbiAgICAgICAgaWYgKCFpc0FycmF5KHRhc2spKSB7XG4gICAgICAgICAgICAvLyBubyBkZXBlbmRlbmNpZXNcbiAgICAgICAgICAgIGVucXVldWVUYXNrKGtleSwgW3Rhc2tdKTtcbiAgICAgICAgICAgIHJlYWR5VG9DaGVjay5wdXNoKGtleSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gdGFzay5zbGljZSgwLCB0YXNrLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgcmVtYWluaW5nRGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzLmxlbmd0aDtcbiAgICAgICAgaWYgKHJlbWFpbmluZ0RlcGVuZGVuY2llcyA9PT0gMCkge1xuICAgICAgICAgICAgZW5xdWV1ZVRhc2soa2V5LCB0YXNrKTtcbiAgICAgICAgICAgIHJlYWR5VG9DaGVjay5wdXNoKGtleSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdW5jaGVja2VkRGVwZW5kZW5jaWVzW2tleV0gPSByZW1haW5pbmdEZXBlbmRlbmNpZXM7XG5cbiAgICAgICAgYXJyYXlFYWNoKGRlcGVuZGVuY2llcywgZnVuY3Rpb24gKGRlcGVuZGVuY3lOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIXRhc2tzW2RlcGVuZGVuY3lOYW1lXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXN5bmMuYXV0byB0YXNrIGAnICsga2V5ICtcbiAgICAgICAgICAgICAgICAgICAgJ2AgaGFzIGEgbm9uLWV4aXN0ZW50IGRlcGVuZGVuY3kgYCcgK1xuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5TmFtZSArICdgIGluICcgK1xuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMuam9pbignLCAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRMaXN0ZW5lcihkZXBlbmRlbmN5TmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZ0RlcGVuZGVuY2llcy0tO1xuICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmdEZXBlbmRlbmNpZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZW5xdWV1ZVRhc2soa2V5LCB0YXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjaGVja0ZvckRlYWRsb2NrcygpO1xuICAgIHByb2Nlc3NRdWV1ZSgpO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZVRhc2soa2V5LCB0YXNrKSB7XG4gICAgICAgIHJlYWR5VGFza3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBydW5UYXNrKGtleSwgdGFzayk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NRdWV1ZSgpIHtcbiAgICAgICAgaWYgKHJlYWR5VGFza3MubGVuZ3RoID09PSAwICYmIHJ1bm5pbmdUYXNrcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlKHJlYWR5VGFza3MubGVuZ3RoICYmIHJ1bm5pbmdUYXNrcyA8IGNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICB2YXIgcnVuID0gcmVhZHlUYXNrcy5zaGlmdCgpO1xuICAgICAgICAgICAgcnVuKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZExpc3RlbmVyKHRhc2tOYW1lLCBmbikge1xuICAgICAgICB2YXIgdGFza0xpc3RlbmVycyA9IGxpc3RlbmVyc1t0YXNrTmFtZV07XG4gICAgICAgIGlmICghdGFza0xpc3RlbmVycykge1xuICAgICAgICAgICAgdGFza0xpc3RlbmVycyA9IGxpc3RlbmVyc1t0YXNrTmFtZV0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhc2tMaXN0ZW5lcnMucHVzaChmbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGFza0NvbXBsZXRlKHRhc2tOYW1lKSB7XG4gICAgICAgIHZhciB0YXNrTGlzdGVuZXJzID0gbGlzdGVuZXJzW3Rhc2tOYW1lXSB8fCBbXTtcbiAgICAgICAgYXJyYXlFYWNoKHRhc2tMaXN0ZW5lcnMsIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2Nlc3NRdWV1ZSgpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gcnVuVGFzayhrZXksIHRhc2spIHtcbiAgICAgICAgaWYgKGhhc0Vycm9yKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHRhc2tDYWxsYmFjayA9IG9ubHlPbmNlKGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gICAgICAgICAgICBydW5uaW5nVGFza3MtLTtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNhZmVSZXN1bHRzID0ge307XG4gICAgICAgICAgICAgICAgYmFzZUZvck93bihyZXN1bHRzLCBmdW5jdGlvbih2YWwsIHJrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNbcmtleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgc2FmZVJlc3VsdHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgdGFza0NvbXBsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJ1bm5pbmdUYXNrcysrO1xuICAgICAgICB2YXIgdGFza0ZuID0gd3JhcEFzeW5jKHRhc2tbdGFzay5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmICh0YXNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRhc2tGbihyZXN1bHRzLCB0YXNrQ2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFza0ZuKHRhc2tDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0ZvckRlYWRsb2NrcygpIHtcbiAgICAgICAgLy8gS2FobidzIGFsZ29yaXRobVxuICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub3BvbG9naWNhbF9zb3J0aW5nI0thaG4uMjdzX2FsZ29yaXRobVxuICAgICAgICAvLyBodHRwOi8vY29ubmFsbGUuYmxvZ3Nwb3QuY29tLzIwMTMvMTAvdG9wb2xvZ2ljYWwtc29ydGluZ2thaG4tYWxnb3JpdGhtLmh0bWxcbiAgICAgICAgdmFyIGN1cnJlbnRUYXNrO1xuICAgICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICAgIHdoaWxlIChyZWFkeVRvQ2hlY2subGVuZ3RoKSB7XG4gICAgICAgICAgICBjdXJyZW50VGFzayA9IHJlYWR5VG9DaGVjay5wb3AoKTtcbiAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgICAgIGFycmF5RWFjaChnZXREZXBlbmRlbnRzKGN1cnJlbnRUYXNrKSwgZnVuY3Rpb24gKGRlcGVuZGVudCkge1xuICAgICAgICAgICAgICAgIGlmICgtLXVuY2hlY2tlZERlcGVuZGVuY2llc1tkZXBlbmRlbnRdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWR5VG9DaGVjay5wdXNoKGRlcGVuZGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY291bnRlciAhPT0gbnVtVGFza3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnYXN5bmMuYXV0byBjYW5ub3QgZXhlY3V0ZSB0YXNrcyBkdWUgdG8gYSByZWN1cnNpdmUgZGVwZW5kZW5jeSdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREZXBlbmRlbnRzKHRhc2tOYW1lKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgYmFzZUZvck93bih0YXNrcywgZnVuY3Rpb24gKHRhc2ssIGtleSkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodGFzaykgJiYgYmFzZUluZGV4T2YodGFzaywgdGFza05hbWUsIDApID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sJDEgPyBTeW1ib2wkMS5wcm90b3R5cGUgOiB1bmRlZmluZWQ7XG52YXIgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gIH1cbiAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5ndGg7XG4gIH1cbiAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICBzdGFydCA+Pj49IDA7XG5cbiAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gKi9cbmZ1bmN0aW9uIGNhc3RTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZDtcbiAgcmV0dXJuICghc3RhcnQgJiYgZW5kID49IGxlbmd0aCkgPyBhcnJheSA6IGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG59XG5cbi8qKlxuICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBzdHJpbmcgc3ltYm9sXG4gKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gKi9cbmZ1bmN0aW9uIGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICB2YXIgaW5kZXggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICB3aGlsZSAoaW5kZXgtLSAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cbiAgcmV0dXJuIGluZGV4O1xufVxuXG4vKipcbiAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1TdGFydGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgc3RyaW5nIHN5bWJvbFxuICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAqL1xuZnVuY3Rpb24gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cbiAgcmV0dXJuIGluZGV4O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xufVxuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJztcbnZhciByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJztcbnZhciByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZic7XG52YXIgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJztcbnZhciByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2U7XG52YXIgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG52YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbn1cblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UkMSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJztcbnZhciByc0NvbWJvTWFya3NSYW5nZSQxID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnO1xudmFyIHJlQ29tYm9IYWxmTWFya3NSYW5nZSQxID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnO1xudmFyIHJzQ29tYm9TeW1ib2xzUmFuZ2UkMSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJztcbnZhciByc0NvbWJvUmFuZ2UkMSA9IHJzQ29tYm9NYXJrc1JhbmdlJDEgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UkMTtcbnZhciByc1ZhclJhbmdlJDEgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSQxICsgJ10nO1xudmFyIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UkMSArICddJztcbnZhciByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJztcbnZhciByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknO1xudmFyIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UkMSArICddJztcbnZhciByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nO1xudmFyIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJztcbnZhciByc1pXSiQxID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JztcbnZhciByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UkMSArICddPyc7XG52YXIgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiQxICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonO1xudmFyIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbjtcbnZhciByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbnZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICA/IHVuaWNvZGVUb0FycmF5KHN0cmluZylcbiAgICA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKlxuICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50cmltKCcgIGFiYyAgJyk7XG4gKiAvLyA9PiAnYWJjJ1xuICpcbiAqIF8udHJpbSgnLV8tYWJjLV8tJywgJ18tJyk7XG4gKiAvLyA9PiAnYWJjJ1xuICpcbiAqIF8ubWFwKFsnICBmb28gICcsICcgIGJhciAgJ10sIF8udHJpbSk7XG4gKiAvLyA9PiBbJ2ZvbycsICdiYXInXVxuICovXG5mdW5jdGlvbiB0cmltKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB9XG4gIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cbiAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICBjaHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShjaGFycyksXG4gICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSxcbiAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykgKyAxO1xuXG4gIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQsIGVuZCkuam9pbignJyk7XG59XG5cbnZhciBGTl9BUkdTID0gL14oPzphc3luY1xccyspPyhmdW5jdGlvbik/XFxzKlteXFwoXSpcXChcXHMqKFteXFwpXSopXFwpL207XG52YXIgRk5fQVJHX1NQTElUID0gLywvO1xudmFyIEZOX0FSRyA9IC8oPS4rKT8oXFxzKikkLztcbnZhciBTVFJJUF9DT01NRU5UUyA9IC8oKFxcL1xcLy4qJCl8KFxcL1xcKltcXHNcXFNdKj9cXCpcXC8pKS9tZztcblxuZnVuY3Rpb24gcGFyc2VQYXJhbXMoZnVuYykge1xuICAgIGZ1bmMgPSBmdW5jLnRvU3RyaW5nKCkucmVwbGFjZShTVFJJUF9DT01NRU5UUywgJycpO1xuICAgIGZ1bmMgPSBmdW5jLm1hdGNoKEZOX0FSR1MpWzJdLnJlcGxhY2UoJyAnLCAnJyk7XG4gICAgZnVuYyA9IGZ1bmMgPyBmdW5jLnNwbGl0KEZOX0FSR19TUExJVCkgOiBbXTtcbiAgICBmdW5jID0gZnVuYy5tYXAoZnVuY3Rpb24gKGFyZyl7XG4gICAgICAgIHJldHVybiB0cmltKGFyZy5yZXBsYWNlKEZOX0FSRywgJycpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuYztcbn1cblxuLyoqXG4gKiBBIGRlcGVuZGVuY3ktaW5qZWN0ZWQgdmVyc2lvbiBvZiB0aGUgW2FzeW5jLmF1dG9de0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5hdXRvfSBmdW5jdGlvbi4gRGVwZW5kZW50XG4gKiB0YXNrcyBhcmUgc3BlY2lmaWVkIGFzIHBhcmFtZXRlcnMgdG8gdGhlIGZ1bmN0aW9uLCBhZnRlciB0aGUgdXN1YWwgY2FsbGJhY2tcbiAqIHBhcmFtZXRlciwgd2l0aCB0aGUgcGFyYW1ldGVyIG5hbWVzIG1hdGNoaW5nIHRoZSBuYW1lcyBvZiB0aGUgdGFza3MgaXRcbiAqIGRlcGVuZHMgb24uIFRoaXMgY2FuIHByb3ZpZGUgZXZlbiBtb3JlIHJlYWRhYmxlIHRhc2sgZ3JhcGhzIHdoaWNoIGNhbiBiZVxuICogZWFzaWVyIHRvIG1haW50YWluLlxuICpcbiAqIElmIGEgZmluYWwgY2FsbGJhY2sgaXMgc3BlY2lmaWVkLCB0aGUgdGFzayByZXN1bHRzIGFyZSBzaW1pbGFybHkgaW5qZWN0ZWQsXG4gKiBzcGVjaWZpZWQgYXMgbmFtZWQgcGFyYW1ldGVycyBhZnRlciB0aGUgaW5pdGlhbCBlcnJvciBwYXJhbWV0ZXIuXG4gKlxuICogVGhlIGF1dG9JbmplY3QgZnVuY3Rpb24gaXMgcHVyZWx5IHN5bnRhY3RpYyBzdWdhciBhbmQgaXRzIHNlbWFudGljcyBhcmVcbiAqIG90aGVyd2lzZSBlcXVpdmFsZW50IHRvIFthc3luYy5hdXRvXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXV0b30uXG4gKlxuICogQG5hbWUgYXV0b0luamVjdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuYXV0b117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmF1dG99XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge09iamVjdH0gdGFza3MgLSBBbiBvYmplY3QsIGVhY2ggb2Ygd2hvc2UgcHJvcGVydGllcyBpcyBhbiB7QGxpbmsgQXN5bmNGdW5jdGlvbn0gb2ZcbiAqIHRoZSBmb3JtICdmdW5jKFtkZXBlbmRlbmNpZXMuLi5dLCBjYWxsYmFjaykuIFRoZSBvYmplY3QncyBrZXkgb2YgYSBwcm9wZXJ0eVxuICogc2VydmVzIGFzIHRoZSBuYW1lIG9mIHRoZSB0YXNrIGRlZmluZWQgYnkgdGhhdCBwcm9wZXJ0eSwgaS5lLiBjYW4gYmUgdXNlZFxuICogd2hlbiBzcGVjaWZ5aW5nIHJlcXVpcmVtZW50cyBmb3Igb3RoZXIgdGFza3MuXG4gKiAqIFRoZSBgY2FsbGJhY2tgIHBhcmFtZXRlciBpcyBhIGBjYWxsYmFjayhlcnIsIHJlc3VsdClgIHdoaWNoIG11c3QgYmUgY2FsbGVkXG4gKiAgIHdoZW4gZmluaXNoZWQsIHBhc3NpbmcgYW4gYGVycm9yYCAod2hpY2ggY2FuIGJlIGBudWxsYCkgYW5kIHRoZSByZXN1bHQgb2ZcbiAqICAgdGhlIGZ1bmN0aW9uJ3MgZXhlY3V0aW9uLiBUaGUgcmVtYWluaW5nIHBhcmFtZXRlcnMgbmFtZSBvdGhlciB0YXNrcyBvblxuICogICB3aGljaCB0aGUgdGFzayBpcyBkZXBlbmRlbnQsIGFuZCB0aGUgcmVzdWx0cyBmcm9tIHRob3NlIHRhc2tzIGFyZSB0aGVcbiAqICAgYXJndW1lbnRzIG9mIHRob3NlIHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiB0aGUgdGFza3MgaGF2ZSBiZWVuIGNvbXBsZXRlZC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgIGFyZ3VtZW50IGlmIGFueSBgdGFza3NgXG4gKiBwYXNzIGFuIGVycm9yIHRvIHRoZWlyIGNhbGxiYWNrLCBhbmQgYSBgcmVzdWx0c2Agb2JqZWN0IHdpdGggYW55IGNvbXBsZXRlZFxuICogdGFzayByZXN1bHRzLCBzaW1pbGFyIHRvIGBhdXRvYC5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gIFRoZSBleGFtcGxlIGZyb20gYGF1dG9gIGNhbiBiZSByZXdyaXR0ZW4gYXMgZm9sbG93czpcbiAqIGFzeW5jLmF1dG9JbmplY3Qoe1xuICogICAgIGdldF9kYXRhOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAvLyBhc3luYyBjb2RlIHRvIGdldCBzb21lIGRhdGFcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RhdGEnLCAnY29udmVydGVkIHRvIGFycmF5Jyk7XG4gKiAgICAgfSxcbiAqICAgICBtYWtlX2ZvbGRlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBjcmVhdGUgYSBkaXJlY3RvcnkgdG8gc3RvcmUgYSBmaWxlIGluXG4gKiAgICAgICAgIC8vIHRoaXMgaXMgcnVuIGF0IHRoZSBzYW1lIHRpbWUgYXMgZ2V0dGluZyB0aGUgZGF0YVxuICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZm9sZGVyJyk7XG4gKiAgICAgfSxcbiAqICAgICB3cml0ZV9maWxlOiBmdW5jdGlvbihnZXRfZGF0YSwgbWFrZV9mb2xkZXIsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIG9uY2UgdGhlcmUgaXMgc29tZSBkYXRhIGFuZCB0aGUgZGlyZWN0b3J5IGV4aXN0cyxcbiAqICAgICAgICAgLy8gd3JpdGUgdGhlIGRhdGEgdG8gYSBmaWxlIGluIHRoZSBkaXJlY3RvcnlcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZpbGVuYW1lJyk7XG4gKiAgICAgfSxcbiAqICAgICBlbWFpbF9saW5rOiBmdW5jdGlvbih3cml0ZV9maWxlLCBjYWxsYmFjaykge1xuICogICAgICAgICAvLyBvbmNlIHRoZSBmaWxlIGlzIHdyaXR0ZW4gbGV0J3MgZW1haWwgYSBsaW5rIHRvIGl0Li4uXG4gKiAgICAgICAgIC8vIHdyaXRlX2ZpbGUgY29udGFpbnMgdGhlIGZpbGVuYW1lIHJldHVybmVkIGJ5IHdyaXRlX2ZpbGUuXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6d3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTtcbiAqICAgICB9XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZXJyID0gJywgZXJyKTtcbiAqICAgICBjb25zb2xlLmxvZygnZW1haWxfbGluayA9ICcsIHJlc3VsdHMuZW1haWxfbGluayk7XG4gKiB9KTtcbiAqXG4gKiAvLyBJZiB5b3UgYXJlIHVzaW5nIGEgSlMgbWluaWZpZXIgdGhhdCBtYW5nbGVzIHBhcmFtZXRlciBuYW1lcywgYGF1dG9JbmplY3RgXG4gKiAvLyB3aWxsIG5vdCB3b3JrIHdpdGggcGxhaW4gZnVuY3Rpb25zLCBzaW5jZSB0aGUgcGFyYW1ldGVyIG5hbWVzIHdpbGwgYmVcbiAqIC8vIGNvbGxhcHNlZCB0byBhIHNpbmdsZSBsZXR0ZXIgaWRlbnRpZmllci4gIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHlvdSBjYW5cbiAqIC8vIGV4cGxpY2l0bHkgc3BlY2lmeSB0aGUgbmFtZXMgb2YgdGhlIHBhcmFtZXRlcnMgeW91ciB0YXNrIGZ1bmN0aW9uIG5lZWRzXG4gKiAvLyBpbiBhbiBhcnJheSwgc2ltaWxhciB0byBBbmd1bGFyLmpzIGRlcGVuZGVuY3kgaW5qZWN0aW9uLlxuICpcbiAqIC8vIFRoaXMgc3RpbGwgaGFzIGFuIGFkdmFudGFnZSBvdmVyIHBsYWluIGBhdXRvYCwgc2luY2UgdGhlIHJlc3VsdHMgYSB0YXNrXG4gKiAvLyBkZXBlbmRzIG9uIGFyZSBzdGlsbCBzcHJlYWQgaW50byBhcmd1bWVudHMuXG4gKiBhc3luYy5hdXRvSW5qZWN0KHtcbiAqICAgICAvLy4uLlxuICogICAgIHdyaXRlX2ZpbGU6IFsnZ2V0X2RhdGEnLCAnbWFrZV9mb2xkZXInLCBmdW5jdGlvbihnZXRfZGF0YSwgbWFrZV9mb2xkZXIsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmaWxlbmFtZScpO1xuICogICAgIH1dLFxuICogICAgIGVtYWlsX2xpbms6IFsnd3JpdGVfZmlsZScsIGZ1bmN0aW9uKHdyaXRlX2ZpbGUsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6d3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTtcbiAqICAgICB9XVxuICogICAgIC8vLi4uXG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZXJyID0gJywgZXJyKTtcbiAqICAgICBjb25zb2xlLmxvZygnZW1haWxfbGluayA9ICcsIHJlc3VsdHMuZW1haWxfbGluayk7XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gYXV0b0luamVjdCh0YXNrcywgY2FsbGJhY2spIHtcbiAgICB2YXIgbmV3VGFza3MgPSB7fTtcblxuICAgIGJhc2VGb3JPd24odGFza3MsIGZ1bmN0aW9uICh0YXNrRm4sIGtleSkge1xuICAgICAgICB2YXIgcGFyYW1zO1xuICAgICAgICB2YXIgZm5Jc0FzeW5jID0gaXNBc3luYyh0YXNrRm4pO1xuICAgICAgICB2YXIgaGFzTm9EZXBzID1cbiAgICAgICAgICAgICghZm5Jc0FzeW5jICYmIHRhc2tGbi5sZW5ndGggPT09IDEpIHx8XG4gICAgICAgICAgICAoZm5Jc0FzeW5jICYmIHRhc2tGbi5sZW5ndGggPT09IDApO1xuXG4gICAgICAgIGlmIChpc0FycmF5KHRhc2tGbikpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHRhc2tGbi5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICB0YXNrRm4gPSB0YXNrRm5bdGFza0ZuLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICBuZXdUYXNrc1trZXldID0gcGFyYW1zLmNvbmNhdChwYXJhbXMubGVuZ3RoID4gMCA/IG5ld1Rhc2sgOiB0YXNrRm4pO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc05vRGVwcykge1xuICAgICAgICAgICAgLy8gbm8gZGVwZW5kZW5jaWVzLCB1c2UgdGhlIGZ1bmN0aW9uIGFzLWlzXG4gICAgICAgICAgICBuZXdUYXNrc1trZXldID0gdGFza0ZuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0gcGFyc2VQYXJhbXModGFza0ZuKTtcbiAgICAgICAgICAgIGlmICh0YXNrRm4ubGVuZ3RoID09PSAwICYmICFmbklzQXN5bmMgJiYgcGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF1dG9JbmplY3QgdGFzayBmdW5jdGlvbnMgcmVxdWlyZSBleHBsaWNpdCBwYXJhbWV0ZXJzLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGNhbGxiYWNrIHBhcmFtXG4gICAgICAgICAgICBpZiAoIWZuSXNBc3luYykgcGFyYW1zLnBvcCgpO1xuXG4gICAgICAgICAgICBuZXdUYXNrc1trZXldID0gcGFyYW1zLmNvbmNhdChuZXdUYXNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG5ld1Rhc2socmVzdWx0cywgdGFza0NiKSB7XG4gICAgICAgICAgICB2YXIgbmV3QXJncyA9IGFycmF5TWFwKHBhcmFtcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0c1tuYW1lXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3QXJncy5wdXNoKHRhc2tDYik7XG4gICAgICAgICAgICB3cmFwQXN5bmModGFza0ZuKS5hcHBseShudWxsLCBuZXdBcmdzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYXV0byhuZXdUYXNrcywgY2FsbGJhY2spO1xufVxuXG4vLyBTaW1wbGUgZG91Ymx5IGxpbmtlZCBsaXN0IChodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VibHlfbGlua2VkX2xpc3QpIGltcGxlbWVudGF0aW9uXG4vLyB1c2VkIGZvciBxdWV1ZXMuIFRoaXMgaW1wbGVtZW50YXRpb24gYXNzdW1lcyB0aGF0IHRoZSBub2RlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyIGNhbiBiZSBtb2RpZmllZFxuLy8gdG8gYWRqdXN0IHRoZSBuZXh0IGFuZCBsYXN0IHByb3BlcnRpZXMuIFdlIGltcGxlbWVudCBvbmx5IHRoZSBtaW5pbWFsIGZ1bmN0aW9uYWxpdHlcbi8vIGZvciBxdWV1ZSBzdXBwb3J0LlxuZnVuY3Rpb24gRExMKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBzZXRJbml0aWFsKGRsbCwgbm9kZSkge1xuICAgIGRsbC5sZW5ndGggPSAxO1xuICAgIGRsbC5oZWFkID0gZGxsLnRhaWwgPSBub2RlO1xufVxuXG5ETEwucHJvdG90eXBlLnJlbW92ZUxpbmsgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUucHJldikgbm9kZS5wcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgZWxzZSB0aGlzLmhlYWQgPSBub2RlLm5leHQ7XG4gICAgaWYgKG5vZGUubmV4dCkgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XG4gICAgZWxzZSB0aGlzLnRhaWwgPSBub2RlLnByZXY7XG5cbiAgICBub2RlLnByZXYgPSBub2RlLm5leHQgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoIC09IDE7XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ETEwucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHdoaWxlKHRoaXMuaGVhZCkgdGhpcy5zaGlmdCgpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuRExMLnByb3RvdHlwZS5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uKG5vZGUsIG5ld05vZGUpIHtcbiAgICBuZXdOb2RlLnByZXYgPSBub2RlO1xuICAgIG5ld05vZGUubmV4dCA9IG5vZGUubmV4dDtcbiAgICBpZiAobm9kZS5uZXh0KSBub2RlLm5leHQucHJldiA9IG5ld05vZGU7XG4gICAgZWxzZSB0aGlzLnRhaWwgPSBuZXdOb2RlO1xuICAgIG5vZGUubmV4dCA9IG5ld05vZGU7XG4gICAgdGhpcy5sZW5ndGggKz0gMTtcbn07XG5cbkRMTC5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24obm9kZSwgbmV3Tm9kZSkge1xuICAgIG5ld05vZGUucHJldiA9IG5vZGUucHJldjtcbiAgICBuZXdOb2RlLm5leHQgPSBub2RlO1xuICAgIGlmIChub2RlLnByZXYpIG5vZGUucHJldi5uZXh0ID0gbmV3Tm9kZTtcbiAgICBlbHNlIHRoaXMuaGVhZCA9IG5ld05vZGU7XG4gICAgbm9kZS5wcmV2ID0gbmV3Tm9kZTtcbiAgICB0aGlzLmxlbmd0aCArPSAxO1xufTtcblxuRExMLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICh0aGlzLmhlYWQpIHRoaXMuaW5zZXJ0QmVmb3JlKHRoaXMuaGVhZCwgbm9kZSk7XG4gICAgZWxzZSBzZXRJbml0aWFsKHRoaXMsIG5vZGUpO1xufTtcblxuRExMLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICh0aGlzLnRhaWwpIHRoaXMuaW5zZXJ0QWZ0ZXIodGhpcy50YWlsLCBub2RlKTtcbiAgICBlbHNlIHNldEluaXRpYWwodGhpcywgbm9kZSk7XG59O1xuXG5ETEwucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVhZCAmJiB0aGlzLnJlbW92ZUxpbmsodGhpcy5oZWFkKTtcbn07XG5cbkRMTC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGFpbCAmJiB0aGlzLnJlbW92ZUxpbmsodGhpcy50YWlsKTtcbn07XG5cbkRMTC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyID0gQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIHZhciBjdXJyID0gdGhpcy5oZWFkO1xuICAgIGZvcih2YXIgaWR4ID0gMDsgaWR4IDwgdGhpcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGFycltpZHhdID0gY3Vyci5kYXRhO1xuICAgICAgICBjdXJyID0gY3Vyci5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufTtcblxuRExMLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAodGVzdEZuKSB7XG4gICAgdmFyIGN1cnIgPSB0aGlzLmhlYWQ7XG4gICAgd2hpbGUoISFjdXJyKSB7XG4gICAgICAgIHZhciBuZXh0ID0gY3Vyci5uZXh0O1xuICAgICAgICBpZiAodGVzdEZuKGN1cnIpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpbmsoY3Vycik7XG4gICAgICAgIH1cbiAgICAgICAgY3VyciA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcXVldWUod29ya2VyLCBjb25jdXJyZW5jeSwgcGF5bG9hZCkge1xuICAgIGlmIChjb25jdXJyZW5jeSA9PSBudWxsKSB7XG4gICAgICAgIGNvbmN1cnJlbmN5ID0gMTtcbiAgICB9XG4gICAgZWxzZSBpZihjb25jdXJyZW5jeSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmN1cnJlbmN5IG11c3Qgbm90IGJlIHplcm8nKTtcbiAgICB9XG5cbiAgICB2YXIgX3dvcmtlciA9IHdyYXBBc3luYyh3b3JrZXIpO1xuICAgIHZhciBudW1SdW5uaW5nID0gMDtcbiAgICB2YXIgd29ya2Vyc0xpc3QgPSBbXTtcblxuICAgIHZhciBwcm9jZXNzaW5nU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gX2luc2VydChkYXRhLCBpbnNlcnRBdEZyb250LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGFzayBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIWlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwICYmIHEuaWRsZSgpKSB7XG4gICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xuICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YVtpXSxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2sgfHwgbm9vcFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGluc2VydEF0RnJvbnQpIHtcbiAgICAgICAgICAgICAgICBxLl90YXNrcy51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxLl90YXNrcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm9jZXNzaW5nU2NoZWR1bGVkKSB7XG4gICAgICAgICAgICBwcm9jZXNzaW5nU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX25leHQodGFza3MpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVycil7XG4gICAgICAgICAgICBudW1SdW5uaW5nIC09IDE7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGFza3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc1tpXTtcblxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGJhc2VJbmRleE9mKHdvcmtlcnNMaXN0LCB0YXNrLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2Vyc0xpc3Quc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXJzTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRhc2suY2FsbGJhY2suYXBwbHkodGFzaywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBxLmVycm9yKGVyciwgdGFzay5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChudW1SdW5uaW5nIDw9IChxLmNvbmN1cnJlbmN5IC0gcS5idWZmZXIpICkge1xuICAgICAgICAgICAgICAgIHEudW5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHEuaWRsZSgpKSB7XG4gICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcS5wcm9jZXNzKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgIHZhciBxID0ge1xuICAgICAgICBfdGFza3M6IG5ldyBETEwoKSxcbiAgICAgICAgY29uY3VycmVuY3k6IGNvbmN1cnJlbmN5LFxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICBzYXR1cmF0ZWQ6IG5vb3AsXG4gICAgICAgIHVuc2F0dXJhdGVkOm5vb3AsXG4gICAgICAgIGJ1ZmZlcjogY29uY3VycmVuY3kgLyA0LFxuICAgICAgICBlbXB0eTogbm9vcCxcbiAgICAgICAgZHJhaW46IG5vb3AsXG4gICAgICAgIGVycm9yOiBub29wLFxuICAgICAgICBzdGFydGVkOiBmYWxzZSxcbiAgICAgICAgcGF1c2VkOiBmYWxzZSxcbiAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBfaW5zZXJ0KGRhdGEsIGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIGtpbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHEuZHJhaW4gPSBub29wO1xuICAgICAgICAgICAgcS5fdGFza3MuZW1wdHkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zaGlmdDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBfaW5zZXJ0KGRhdGEsIHRydWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAodGVzdEZuKSB7XG4gICAgICAgICAgICBxLl90YXNrcy5yZW1vdmUodGVzdEZuKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQXZvaWQgdHJ5aW5nIHRvIHN0YXJ0IHRvbyBtYW55IHByb2Nlc3Npbmcgb3BlcmF0aW9ucy4gVGhpcyBjYW4gb2NjdXJcbiAgICAgICAgICAgIC8vIHdoZW4gY2FsbGJhY2tzIHJlc29sdmUgc3luY2hyb25vdXNseSAoIzEyNjcpLlxuICAgICAgICAgICAgaWYgKGlzUHJvY2Vzc2luZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSghcS5wYXVzZWQgJiYgbnVtUnVubmluZyA8IHEuY29uY3VycmVuY3kgJiYgcS5fdGFza3MubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICB2YXIgdGFza3MgPSBbXSwgZGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBsID0gcS5fdGFza3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChxLnBheWxvYWQpIGwgPSBNYXRoLm1pbihsLCBxLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gcS5fdGFza3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgd29ya2Vyc0xpc3QucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKG5vZGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbnVtUnVubmluZyArPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKHEuX3Rhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBxLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG51bVJ1bm5pbmcgPT09IHEuY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2IgPSBvbmx5T25jZShfbmV4dCh0YXNrcykpO1xuICAgICAgICAgICAgICAgIF93b3JrZXIoZGF0YSwgY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHEuX3Rhc2tzLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVJ1bm5pbmc7XG4gICAgICAgIH0sXG4gICAgICAgIHdvcmtlcnNMaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gd29ya2Vyc0xpc3Q7XG4gICAgICAgIH0sXG4gICAgICAgIGlkbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHEuX3Rhc2tzLmxlbmd0aCArIG51bVJ1bm5pbmcgPT09IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBxLnBhdXNlZCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHEucGF1c2VkID09PSBmYWxzZSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgIHEucGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUkMShxLnByb2Nlc3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcTtcbn1cblxuLyoqXG4gKiBBIGNhcmdvIG9mIHRhc2tzIGZvciB0aGUgd29ya2VyIGZ1bmN0aW9uIHRvIGNvbXBsZXRlLiBDYXJnbyBpbmhlcml0cyBhbGwgb2ZcbiAqIHRoZSBzYW1lIG1ldGhvZHMgYW5kIGV2ZW50IGNhbGxiYWNrcyBhcyBbYHF1ZXVlYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnF1ZXVlfS5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhcmdvT2JqZWN0XG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBsZW5ndGggLSBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbnVtYmVyIG9mIGl0ZW1zXG4gKiB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZC4gSW52b2tlIGxpa2UgYGNhcmdvLmxlbmd0aCgpYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwYXlsb2FkIC0gQW4gYGludGVnZXJgIGZvciBkZXRlcm1pbmluZyBob3cgbWFueSB0YXNrc1xuICogc2hvdWxkIGJlIHByb2Nlc3MgcGVyIHJvdW5kLiBUaGlzIHByb3BlcnR5IGNhbiBiZSBjaGFuZ2VkIGFmdGVyIGEgYGNhcmdvYCBpc1xuICogY3JlYXRlZCB0byBhbHRlciB0aGUgcGF5bG9hZCBvbi10aGUtZmx5LlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcHVzaCAtIEFkZHMgYHRhc2tgIHRvIHRoZSBgcXVldWVgLiBUaGUgY2FsbGJhY2sgaXNcbiAqIGNhbGxlZCBvbmNlIHRoZSBgd29ya2VyYCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZyB0aGUgdGFzay4gSW5zdGVhZCBvZiBhXG4gKiBzaW5nbGUgdGFzaywgYW4gYXJyYXkgb2YgYHRhc2tzYCBjYW4gYmUgc3VibWl0dGVkLiBUaGUgcmVzcGVjdGl2ZSBjYWxsYmFjayBpc1xuICogdXNlZCBmb3IgZXZlcnkgdGFzayBpbiB0aGUgbGlzdC4gSW52b2tlIGxpa2UgYGNhcmdvLnB1c2godGFzaywgW2NhbGxiYWNrXSlgLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gc2F0dXJhdGVkIC0gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZVxuICogYHF1ZXVlLmxlbmd0aCgpYCBoaXRzIHRoZSBjb25jdXJyZW5jeSBhbmQgZnVydGhlciB0YXNrcyB3aWxsIGJlIHF1ZXVlZC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVtcHR5IC0gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBsYXN0IGl0ZW1cbiAqIGZyb20gdGhlIGBxdWV1ZWAgaXMgZ2l2ZW4gdG8gYSBgd29ya2VyYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRyYWluIC0gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBsYXN0IGl0ZW1cbiAqIGZyb20gdGhlIGBxdWV1ZWAgaGFzIHJldHVybmVkIGZyb20gdGhlIGB3b3JrZXJgLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaWRsZSAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGZhbHNlIGlmIHRoZXJlIGFyZSBpdGVtc1xuICogd2FpdGluZyBvciBiZWluZyBwcm9jZXNzZWQsIG9yIHRydWUgaWYgbm90LiBJbnZva2UgbGlrZSBgY2FyZ28uaWRsZSgpYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHBhdXNlIC0gYSBmdW5jdGlvbiB0aGF0IHBhdXNlcyB0aGUgcHJvY2Vzc2luZyBvZiB0YXNrc1xuICogdW50aWwgYHJlc3VtZSgpYCBpcyBjYWxsZWQuIEludm9rZSBsaWtlIGBjYXJnby5wYXVzZSgpYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHJlc3VtZSAtIGEgZnVuY3Rpb24gdGhhdCByZXN1bWVzIHRoZSBwcm9jZXNzaW5nIG9mXG4gKiBxdWV1ZWQgdGFza3Mgd2hlbiB0aGUgcXVldWUgaXMgcGF1c2VkLiBJbnZva2UgbGlrZSBgY2FyZ28ucmVzdW1lKClgLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0ga2lsbCAtIGEgZnVuY3Rpb24gdGhhdCByZW1vdmVzIHRoZSBgZHJhaW5gIGNhbGxiYWNrIGFuZFxuICogZW1wdGllcyByZW1haW5pbmcgdGFza3MgZnJvbSB0aGUgcXVldWUgZm9yY2luZyBpdCB0byBnbyBpZGxlLiBJbnZva2UgbGlrZSBgY2FyZ28ua2lsbCgpYC5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgY2FyZ29gIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgcGF5bG9hZC4gVGFza3MgYWRkZWQgdG8gdGhlXG4gKiBjYXJnbyB3aWxsIGJlIHByb2Nlc3NlZCBhbHRvZ2V0aGVyICh1cCB0byB0aGUgYHBheWxvYWRgIGxpbWl0KS4gSWYgdGhlXG4gKiBgd29ya2VyYCBpcyBpbiBwcm9ncmVzcywgdGhlIHRhc2sgaXMgcXVldWVkIHVudGlsIGl0IGJlY29tZXMgYXZhaWxhYmxlLiBPbmNlXG4gKiB0aGUgYHdvcmtlcmAgaGFzIGNvbXBsZXRlZCBzb21lIHRhc2tzLCBlYWNoIGNhbGxiYWNrIG9mIHRob3NlIHRhc2tzIGlzXG4gKiBjYWxsZWQuIENoZWNrIG91dCBbdGhlc2VdKGh0dHBzOi8vY2Ftby5naXRodWJ1c2VyY29udGVudC5jb20vNmJiZDM2ZjRjZjViMzVhMGYxMWE5NmRjZDJlOTc3MTFmZmMyZmIzNy82ODc0NzQ3MDczM2EyZjJmNjYyZTYzNmM2Zjc1NjQyZTY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTczNzM2NTc0NzMyZjMxMzYzNzM2MzgzNzMxMmYzNjM4MzEzMDM4MmY2MjYyNjMzMDYzNjY2MjMwMmQzNTY2MzIzOTJkMzEzMTY1MzIyZDM5MzczNDY2MmQzMzMzMzkzNzYzMzYzNDY0NjMzODM1MzgyZTY3Njk2NikgW2FuaW1hdGlvbnNdKGh0dHBzOi8vY2Ftby5naXRodWJ1c2VyY29udGVudC5jb20vZjQ4MTBlMDBlMWM1ZjVmOGFkZGJlM2U5ZjQ5MDY0ZmQ1ZDEwMjY5OS82ODc0NzQ3MDczM2EyZjJmNjYyZTYzNmM2Zjc1NjQyZTY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTczNzM2NTc0NzMyZjMxMzYzNzM2MzgzNzMxMmYzNjM4MzEzMDMxMmYzODM0NjMzOTMyMzAzNjM2MmQzNTY2MzIzOTJkMzEzMTY1MzIyZDM4MzEzNDY2MmQzOTY0MzM2NDMwMzIzNDMxMzM2MjY2NjQyZTY3Njk2NilcbiAqIGZvciBob3cgYGNhcmdvYCBhbmQgYHF1ZXVlYCB3b3JrLlxuICpcbiAqIFdoaWxlIFtgcXVldWVgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9IHBhc3NlcyBvbmx5IG9uZSB0YXNrIHRvIG9uZSBvZiBhIGdyb3VwIG9mIHdvcmtlcnNcbiAqIGF0IGEgdGltZSwgY2FyZ28gcGFzc2VzIGFuIGFycmF5IG9mIHRhc2tzIHRvIGEgc2luZ2xlIHdvcmtlciwgcmVwZWF0aW5nXG4gKiB3aGVuIHRoZSB3b3JrZXIgaXMgZmluaXNoZWQuXG4gKlxuICogQG5hbWUgY2FyZ29cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnF1ZXVlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHdvcmtlciAtIEFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBmb3IgcHJvY2Vzc2luZyBhbiBhcnJheVxuICogb2YgcXVldWVkIHRhc2tzLiBJbnZva2VkIHdpdGggYCh0YXNrcywgY2FsbGJhY2spYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGF5bG9hZD1JbmZpbml0eV0gLSBBbiBvcHRpb25hbCBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nXG4gKiBob3cgbWFueSB0YXNrcyBzaG91bGQgYmUgcHJvY2Vzc2VkIHBlciByb3VuZDsgaWYgb21pdHRlZCwgdGhlIGRlZmF1bHQgaXNcbiAqIHVubGltaXRlZC5cbiAqIEByZXR1cm5zIHttb2R1bGU6Q29udHJvbEZsb3cuQ2FyZ29PYmplY3R9IEEgY2FyZ28gb2JqZWN0IHRvIG1hbmFnZSB0aGUgdGFza3MuIENhbGxiYWNrcyBjYW5cbiAqIGF0dGFjaGVkIGFzIGNlcnRhaW4gcHJvcGVydGllcyB0byBsaXN0ZW4gZm9yIHNwZWNpZmljIGV2ZW50cyBkdXJpbmcgdGhlXG4gKiBsaWZlY3ljbGUgb2YgdGhlIGNhcmdvIGFuZCBpbm5lciBxdWV1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gY3JlYXRlIGEgY2FyZ28gb2JqZWN0IHdpdGggcGF5bG9hZCAyXG4gKiB2YXIgY2FyZ28gPSBhc3luYy5jYXJnbyhmdW5jdGlvbih0YXNrcywgY2FsbGJhY2spIHtcbiAqICAgICBmb3IgKHZhciBpPTA7IGk8dGFza3MubGVuZ3RoOyBpKyspIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coJ2hlbGxvICcgKyB0YXNrc1tpXS5uYW1lKTtcbiAqICAgICB9XG4gKiAgICAgY2FsbGJhY2soKTtcbiAqIH0sIDIpO1xuICpcbiAqIC8vIGFkZCBzb21lIGl0ZW1zXG4gKiBjYXJnby5wdXNoKHtuYW1lOiAnZm9vJ30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGZvbycpO1xuICogfSk7XG4gKiBjYXJnby5wdXNoKHtuYW1lOiAnYmFyJ30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpO1xuICogfSk7XG4gKiBjYXJnby5wdXNoKHtuYW1lOiAnYmF6J30sIGZ1bmN0aW9uKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJheicpO1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGNhcmdvKHdvcmtlciwgcGF5bG9hZCkge1xuICAgIHJldHVybiBxdWV1ZSh3b3JrZXIsIDEsIHBheWxvYWQpO1xufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZWFjaE9mYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGVhY2hPZlNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZWFjaE9mXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaE9mfVxuICogQGFsaWFzIGZvckVhY2hPZlNlcmllc1xuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICovXG52YXIgZWFjaE9mU2VyaWVzID0gZG9MaW1pdChlYWNoT2ZMaW1pdCwgMSk7XG5cbi8qKlxuICogUmVkdWNlcyBgY29sbGAgaW50byBhIHNpbmdsZSB2YWx1ZSB1c2luZyBhbiBhc3luYyBgaXRlcmF0ZWVgIHRvIHJldHVybiBlYWNoXG4gKiBzdWNjZXNzaXZlIHN0ZXAuIGBtZW1vYCBpcyB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLiBUaGlzIGZ1bmN0aW9uXG4gKiBvbmx5IG9wZXJhdGVzIGluIHNlcmllcy5cbiAqXG4gKiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgaXQgbWF5IG1ha2Ugc2Vuc2UgdG8gc3BsaXQgYSBjYWxsIHRvIHRoaXMgZnVuY3Rpb25cbiAqIGludG8gYSBwYXJhbGxlbCBtYXAsIGFuZCB0aGVuIHVzZSB0aGUgbm9ybWFsIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBvbiB0aGVcbiAqIHJlc3VsdHMuIFRoaXMgZnVuY3Rpb24gaXMgZm9yIHNpdHVhdGlvbnMgd2hlcmUgZWFjaCBzdGVwIGluIHRoZSByZWR1Y3Rpb25cbiAqIG5lZWRzIHRvIGJlIGFzeW5jOyBpZiB5b3UgY2FuIGdldCB0aGUgZGF0YSBiZWZvcmUgcmVkdWNpbmcgaXQsIHRoZW4gaXQnc1xuICogcHJvYmFibHkgYSBnb29kIGlkZWEgdG8gZG8gc28uXG4gKlxuICogQG5hbWUgcmVkdWNlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgaW5qZWN0XG4gKiBAYWxpYXMgZm9sZGxcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0geyp9IG1lbW8gLSBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gYXBwbGllZCB0byBlYWNoIGl0ZW0gaW4gdGhlXG4gKiBhcnJheSB0byBwcm9kdWNlIHRoZSBuZXh0IHN0ZXAgaW4gdGhlIHJlZHVjdGlvbi5cbiAqIFRoZSBgaXRlcmF0ZWVgIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSBuZXh0IHN0YXRlIG9mIHRoZSByZWR1Y3Rpb24uXG4gKiBJZiB0aGUgaXRlcmF0ZWUgY29tcGxldGUgd2l0aCBhbiBlcnJvciwgdGhlIHJlZHVjdGlvbiBpcyBzdG9wcGVkIGFuZCB0aGVcbiAqIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuXG4gKiBJbnZva2VkIHdpdGggKG1lbW8sIGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgaXMgdGhlIHJlZHVjZWQgdmFsdWUuIEludm9rZWQgd2l0aFxuICogKGVyciwgcmVzdWx0KS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMucmVkdWNlKFsxLDIsM10sIDAsIGZ1bmN0aW9uKG1lbW8sIGl0ZW0sIGNhbGxiYWNrKSB7XG4gKiAgICAgLy8gcG9pbnRsZXNzIGFzeW5jOlxuICogICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1lbW8gKyBpdGVtKVxuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgaXMgbm93IGVxdWFsIHRvIHRoZSBsYXN0IHZhbHVlIG9mIG1lbW8sIHdoaWNoIGlzIDZcbiAqIH0pO1xuICovXG5mdW5jdGlvbiByZWR1Y2UoY29sbCwgbWVtbywgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgIGVhY2hPZlNlcmllcyhjb2xsLCBmdW5jdGlvbih4LCBpLCBjYWxsYmFjaykge1xuICAgICAgICBfaXRlcmF0ZWUobWVtbywgeCwgZnVuY3Rpb24oZXJyLCB2KSB7XG4gICAgICAgICAgICBtZW1vID0gdjtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIsIG1lbW8pO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFZlcnNpb24gb2YgdGhlIGNvbXBvc2UgZnVuY3Rpb24gdGhhdCBpcyBtb3JlIG5hdHVyYWwgdG8gcmVhZC4gRWFjaCBmdW5jdGlvblxuICogY29uc3VtZXMgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMgZnVuY3Rpb24uIEl0IGlzIHRoZSBlcXVpdmFsZW50IG9mXG4gKiBbY29tcG9zZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmNvbXBvc2V9IHdpdGggdGhlIGFyZ3VtZW50cyByZXZlcnNlZC5cbiAqXG4gKiBFYWNoIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjb21wb3NlZCBmdW5jdGlvbi5cbiAqXG4gKiBAbmFtZSBzZXFcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmNvbXBvc2Vde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5jb21wb3NlfVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHsuLi5Bc3luY0Z1bmN0aW9ufSBmdW5jdGlvbnMgLSB0aGUgYXN5bmNocm9ub3VzIGZ1bmN0aW9ucyB0byBjb21wb3NlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBjb21wb3NlcyB0aGUgYGZ1bmN0aW9uc2AgaW4gb3JkZXJcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gUmVxdWlyZXMgbG9kYXNoIChvciB1bmRlcnNjb3JlKSwgZXhwcmVzczMgYW5kIGRyZXNlbmRlJ3Mgb3JtMi5cbiAqIC8vIFBhcnQgb2YgYW4gYXBwLCB0aGF0IGZldGNoZXMgY2F0cyBvZiB0aGUgbG9nZ2VkIHVzZXIuXG4gKiAvLyBUaGlzIGV4YW1wbGUgdXNlcyBgc2VxYCBmdW5jdGlvbiB0byBhdm9pZCBvdmVybmVzdGluZyBhbmQgZXJyb3JcbiAqIC8vIGhhbmRsaW5nIGNsdXR0ZXIuXG4gKiBhcHAuZ2V0KCcvY2F0cycsIGZ1bmN0aW9uKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gKiAgICAgdmFyIFVzZXIgPSByZXF1ZXN0Lm1vZGVscy5Vc2VyO1xuICogICAgIGFzeW5jLnNlcShcbiAqICAgICAgICAgXy5iaW5kKFVzZXIuZ2V0LCBVc2VyKSwgIC8vICdVc2VyLmdldCcgaGFzIHNpZ25hdHVyZSAoaWQsIGNhbGxiYWNrKGVyciwgZGF0YSkpXG4gKiAgICAgICAgIGZ1bmN0aW9uKHVzZXIsIGZuKSB7XG4gKiAgICAgICAgICAgICB1c2VyLmdldENhdHMoZm4pOyAgICAgIC8vICdnZXRDYXRzJyBoYXMgc2lnbmF0dXJlIChjYWxsYmFjayhlcnIsIGRhdGEpKVxuICogICAgICAgICB9XG4gKiAgICAgKShyZXEuc2Vzc2lvbi51c2VyX2lkLCBmdW5jdGlvbiAoZXJyLCBjYXRzKSB7XG4gKiAgICAgICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAqICAgICAgICAgICAgIHJlc3BvbnNlLmpzb24oeyBzdGF0dXM6ICdlcnJvcicsIG1lc3NhZ2U6IGVyci5tZXNzYWdlIH0pO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgICAgcmVzcG9uc2UuanNvbih7IHN0YXR1czogJ29rJywgbWVzc2FnZTogJ0NhdHMgZm91bmQnLCBkYXRhOiBjYXRzIH0pO1xuICogICAgICAgICB9XG4gKiAgICAgfSk7XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gc2VxKC8qLi4uZnVuY3Rpb25zKi8pIHtcbiAgICB2YXIgX2Z1bmN0aW9ucyA9IGFycmF5TWFwKGFyZ3VtZW50cywgd3JhcEFzeW5jKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oLyouLi5hcmdzKi8pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMpO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGNiID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodHlwZW9mIGNiID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFyZ3MucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYiA9IG5vb3A7XG4gICAgICAgIH1cblxuICAgICAgICByZWR1Y2UoX2Z1bmN0aW9ucywgYXJncywgZnVuY3Rpb24obmV3YXJncywgZm4sIGNiKSB7XG4gICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBuZXdhcmdzLmNvbmNhdChmdW5jdGlvbihlcnIvKiwgLi4ubmV4dGFyZ3MqLykge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0YXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgY2IoZXJyLCBuZXh0YXJncyk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgY2IuYXBwbHkodGhhdCwgW2Vycl0uY29uY2F0KHJlc3VsdHMpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gd2hpY2ggaXMgYSBjb21wb3NpdGlvbiBvZiB0aGUgcGFzc2VkIGFzeW5jaHJvbm91c1xuICogZnVuY3Rpb25zLiBFYWNoIGZ1bmN0aW9uIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXRcbiAqIGZvbGxvd3MuIENvbXBvc2luZyBmdW5jdGlvbnMgYGYoKWAsIGBnKClgLCBhbmQgYGgoKWAgd291bGQgcHJvZHVjZSB0aGUgcmVzdWx0XG4gKiBvZiBgZihnKGgoKSkpYCwgb25seSB0aGlzIHZlcnNpb24gdXNlcyBjYWxsYmFja3MgdG8gb2J0YWluIHRoZSByZXR1cm4gdmFsdWVzLlxuICpcbiAqIEVhY2ggZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNvbXBvc2VkIGZ1bmN0aW9uLlxuICpcbiAqIEBuYW1lIGNvbXBvc2VcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7Li4uQXN5bmNGdW5jdGlvbn0gZnVuY3Rpb25zIC0gdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMgdG8gY29tcG9zZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zZWRcbiAqIGFzeW5jaHJvbm91cyBgZnVuY3Rpb25zYFxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBhZGQxKG4sIGNhbGxiYWNrKSB7XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIG4gKyAxKTtcbiAqICAgICB9LCAxMCk7XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gbXVsMyhuLCBjYWxsYmFjaykge1xuICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCBuICogMyk7XG4gKiAgICAgfSwgMTApO1xuICogfVxuICpcbiAqIHZhciBhZGQxbXVsMyA9IGFzeW5jLmNvbXBvc2UobXVsMywgYWRkMSk7XG4gKiBhZGQxbXVsMyg0LCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyAxNVxuICogfSk7XG4gKi9cbnZhciBjb21wb3NlID0gZnVuY3Rpb24oLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gc2VxLmFwcGx5KG51bGwsIHNsaWNlKGFyZ3VtZW50cykucmV2ZXJzZSgpKTtcbn07XG5cbnZhciBfY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGNvbmNhdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5jb25jYXR9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGNvbmNhdExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5jb25jYXRde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5jb25jYXR9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCxcbiAqIHdoaWNoIHNob3VsZCB1c2UgYW4gYXJyYXkgYXMgaXRzIHJlc3VsdC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5XG4gKiBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgcmVzdWx0cyBvZiB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbi4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHRzKS5cbiAqL1xudmFyIGNvbmNhdExpbWl0ID0gZnVuY3Rpb24oY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcbiAgICBtYXBMaW1pdChjb2xsLCBsaW1pdCwgZnVuY3Rpb24odmFsLCBjYWxsYmFjaykge1xuICAgICAgICBfaXRlcmF0ZWUodmFsLCBmdW5jdGlvbihlcnIgLyosIC4uLmFyZ3MqLykge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uKGVyciwgbWFwUmVzdWx0cykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwUmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG1hcFJlc3VsdHNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfY29uY2F0LmFwcGx5KHJlc3VsdCwgbWFwUmVzdWx0c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIGBpdGVyYXRlZWAgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCwgY29uY2F0ZW5hdGluZyB0aGUgcmVzdWx0cy4gUmV0dXJuc1xuICogdGhlIGNvbmNhdGVuYXRlZCBsaXN0LiBUaGUgYGl0ZXJhdGVlYHMgYXJlIGNhbGxlZCBpbiBwYXJhbGxlbCwgYW5kIHRoZVxuICogcmVzdWx0cyBhcmUgY29uY2F0ZW5hdGVkIGFzIHRoZXkgcmV0dXJuLiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGVcbiAqIHJlc3VsdHMgYXJyYXkgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgb3JpZ2luYWwgb3JkZXIgb2YgYGNvbGxgIHBhc3NlZCB0byB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb24uXG4gKlxuICogQG5hbWUgY29uY2F0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCxcbiAqIHdoaWNoIHNob3VsZCB1c2UgYW4gYXJyYXkgYXMgaXRzIHJlc3VsdC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2soZXJyKV0gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gYXJyYXlcbiAqIGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRlZCByZXN1bHRzIG9mIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9uLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdHMpLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy5jb25jYXQoWydkaXIxJywnZGlyMicsJ2RpcjMnXSwgZnMucmVhZGRpciwgZnVuY3Rpb24oZXJyLCBmaWxlcykge1xuICogICAgIC8vIGZpbGVzIGlzIG5vdyBhIGxpc3Qgb2YgZmlsZW5hbWVzIHRoYXQgZXhpc3QgaW4gdGhlIDMgZGlyZWN0b3JpZXNcbiAqIH0pO1xuICovXG52YXIgY29uY2F0ID0gZG9MaW1pdChjb25jYXRMaW1pdCwgSW5maW5pdHkpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgY29uY2F0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmNvbmNhdH0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGNvbmNhdFNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuY29uY2F0XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuY29uY2F0fVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYW4gYXJyYXkgYW4gYXJyYXkgb2YgcmVzdWx0cy5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrKGVycildIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5XG4gKiBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgcmVzdWx0cyBvZiB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbi4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHRzKS5cbiAqL1xudmFyIGNvbmNhdFNlcmllcyA9IGRvTGltaXQoY29uY2F0TGltaXQsIDEpO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdoZW4gY2FsbGVkLCBjYWxscy1iYWNrIHdpdGggdGhlIHZhbHVlcyBwcm92aWRlZC5cbiAqIFVzZWZ1bCBhcyB0aGUgZmlyc3QgZnVuY3Rpb24gaW4gYSBbYHdhdGVyZmFsbGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53YXRlcmZhbGx9LCBvciBmb3IgcGx1Z2dpbmcgdmFsdWVzIGluIHRvXG4gKiBbYGF1dG9gXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXV0b30uXG4gKlxuICogQG5hbWUgY29uc3RhbnRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGF1dG9tYXRpY2FsbHkgaW52b2tlXG4gKiBjYWxsYmFjayB3aXRoLlxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdoZW4gaW52b2tlZCwgYXV0b21hdGljYWxseVxuICogaW52b2tlcyB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgcHJldmlvdXMgZ2l2ZW4gYXJndW1lbnRzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy53YXRlcmZhbGwoW1xuICogICAgIGFzeW5jLmNvbnN0YW50KDQyKSxcbiAqICAgICBmdW5jdGlvbiAodmFsdWUsIG5leHQpIHtcbiAqICAgICAgICAgLy8gdmFsdWUgPT09IDQyXG4gKiAgICAgfSxcbiAqICAgICAvLy4uLlxuICogXSwgY2FsbGJhY2spO1xuICpcbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgYXN5bmMuY29uc3RhbnQoZmlsZW5hbWUsIFwidXRmOFwiKSxcbiAqICAgICBmcy5yZWFkRmlsZSxcbiAqICAgICBmdW5jdGlvbiAoZmlsZURhdGEsIG5leHQpIHtcbiAqICAgICAgICAgLy8uLi5cbiAqICAgICB9XG4gKiAgICAgLy8uLi5cbiAqIF0sIGNhbGxiYWNrKTtcbiAqXG4gKiBhc3luYy5hdXRvKHtcbiAqICAgICBob3N0bmFtZTogYXN5bmMuY29uc3RhbnQoXCJodHRwczovL3NlcnZlci5uZXQvXCIpLFxuICogICAgIHBvcnQ6IGZpbmRGcmVlUG9ydCxcbiAqICAgICBsYXVuY2hTZXJ2ZXI6IFtcImhvc3RuYW1lXCIsIFwicG9ydFwiLCBmdW5jdGlvbiAob3B0aW9ucywgY2IpIHtcbiAqICAgICAgICAgc3RhcnRTZXJ2ZXIob3B0aW9ucywgY2IpO1xuICogICAgIH1dLFxuICogICAgIC8vLi4uXG4gKiB9LCBjYWxsYmFjayk7XG4gKi9cbnZhciBjb25zdGFudCA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICB2YXIgdmFsdWVzID0gc2xpY2UoYXJndW1lbnRzKTtcbiAgICB2YXIgYXJncyA9IFtudWxsXS5jb25jYXQodmFsdWVzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC8qLi4uaWdub3JlZEFyZ3MsIGNhbGxiYWNrKi8pIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlVGVzdGVyKGNoZWNrLCBnZXRSZXN1bHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWFjaGZuLCBhcnIsIGl0ZXJhdGVlLCBjYikge1xuICAgICAgICBjYiA9IGNiIHx8IG5vb3A7XG4gICAgICAgIHZhciB0ZXN0UGFzc2VkID0gZmFsc2U7XG4gICAgICAgIHZhciB0ZXN0UmVzdWx0O1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbih2YWx1ZSwgXywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlKHZhbHVlLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoZWNrKHJlc3VsdCkgJiYgIXRlc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVzdFBhc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RSZXN1bHQgPSBnZXRSZXN1bHQodHJ1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBicmVha0xvb3ApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNiKG51bGwsIHRlc3RQYXNzZWQgPyB0ZXN0UmVzdWx0IDogZ2V0UmVzdWx0KGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIF9maW5kR2V0UmVzdWx0KHYsIHgpIHtcbiAgICByZXR1cm4geDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBpbiBgY29sbGAgdGhhdCBwYXNzZXMgYW4gYXN5bmMgdHJ1dGggdGVzdC4gVGhlXG4gKiBgaXRlcmF0ZWVgIGlzIGFwcGxpZWQgaW4gcGFyYWxsZWwsIG1lYW5pbmcgdGhlIGZpcnN0IGl0ZXJhdGVlIHRvIHJldHVyblxuICogYHRydWVgIHdpbGwgZmlyZSB0aGUgZGV0ZWN0IGBjYWxsYmFja2Agd2l0aCB0aGF0IHJlc3VsdC4gVGhhdCBtZWFucyB0aGVcbiAqIHJlc3VsdCBtaWdodCBub3QgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIG9yaWdpbmFsIGBjb2xsYCAoaW4gdGVybXMgb2Ygb3JkZXIpXG4gKiB0aGF0IHBhc3NlcyB0aGUgdGVzdC5cblxuICogSWYgb3JkZXIgd2l0aGluIHRoZSBvcmlnaW5hbCBgY29sbGAgaXMgaW1wb3J0YW50LCB0aGVuIGxvb2sgYXRcbiAqIFtgZGV0ZWN0U2VyaWVzYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdFNlcmllc30uXG4gKlxuICogQG5hbWUgZGV0ZWN0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgZmluZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgcmVzdWx0LlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnlcbiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuXG4gKiBSZXN1bHQgd2lsbCBiZSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgYXJyYXkgdGhhdCBwYXNzZXMgdGhlIHRydXRoIHRlc3RcbiAqIChpdGVyYXRlZSkgb3IgdGhlIHZhbHVlIGB1bmRlZmluZWRgIGlmIG5vbmUgcGFzc2VkLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdCkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLmRldGVjdChbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmdW5jdGlvbihmaWxlUGF0aCwgY2FsbGJhY2spIHtcbiAqICAgICBmcy5hY2Nlc3MoZmlsZVBhdGgsIGZ1bmN0aW9uKGVycikge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKVxuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyB0aGUgZmlyc3QgZmlsZSBpbiB0aGUgbGlzdCB0aGF0IGV4aXN0c1xuICogfSk7XG4gKi9cbnZhciBkZXRlY3QgPSBkb1BhcmFsbGVsKF9jcmVhdGVUZXN0ZXIoaWRlbnRpdHksIF9maW5kR2V0UmVzdWx0KSk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BkZXRlY3RgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZGV0ZWN0fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgZGV0ZWN0TGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmRldGVjdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdH1cbiAqIEBhbGlhcyBmaW5kTGltaXRcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYXMgaXRzIHJlc3VsdC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLlxuICogUmVzdWx0IHdpbGwgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGFycmF5IHRoYXQgcGFzc2VzIHRoZSB0cnV0aCB0ZXN0XG4gKiAoaXRlcmF0ZWUpIG9yIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYCBpZiBub25lIHBhc3NlZC4gSW52b2tlZCB3aXRoXG4gKiAoZXJyLCByZXN1bHQpLlxuICovXG52YXIgZGV0ZWN0TGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2NyZWF0ZVRlc3RlcihpZGVudGl0eSwgX2ZpbmRHZXRSZXN1bHQpKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGRldGVjdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5kZXRlY3R9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBkZXRlY3RTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmRldGVjdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdH1cbiAqIEBhbGlhcyBmaW5kU2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyByZXN1bHQuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueVxuICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC5cbiAqIFJlc3VsdCB3aWxsIGJlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBhcnJheSB0aGF0IHBhc3NlcyB0aGUgdHJ1dGggdGVzdFxuICogKGl0ZXJhdGVlKSBvciB0aGUgdmFsdWUgYHVuZGVmaW5lZGAgaWYgbm9uZSBwYXNzZWQuIEludm9rZWQgd2l0aFxuICogKGVyciwgcmVzdWx0KS5cbiAqL1xudmFyIGRldGVjdFNlcmllcyA9IGRvTGltaXQoZGV0ZWN0TGltaXQsIDEpO1xuXG5mdW5jdGlvbiBjb25zb2xlRnVuYyhuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmbi8qLCAuLi5hcmdzKi8pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyci8qLCAuLi5hcmdzKi8pIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlFYWNoKGFyZ3MsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlW25hbWVdKHgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB3cmFwQXN5bmMoZm4pLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH07XG59XG5cbi8qKlxuICogTG9ncyB0aGUgcmVzdWx0IG9mIGFuIFtgYXN5bmNgIGZ1bmN0aW9uXXtAbGluayBBc3luY0Z1bmN0aW9ufSB0byB0aGVcbiAqIGBjb25zb2xlYCB1c2luZyBgY29uc29sZS5kaXJgIHRvIGRpc3BsYXkgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHJlc3VsdGluZyBvYmplY3QuXG4gKiBPbmx5IHdvcmtzIGluIE5vZGUuanMgb3IgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGBjb25zb2xlLmRpcmAgYW5kXG4gKiBgY29uc29sZS5lcnJvcmAgKHN1Y2ggYXMgRkYgYW5kIENocm9tZSkuXG4gKiBJZiBtdWx0aXBsZSBhcmd1bWVudHMgYXJlIHJldHVybmVkIGZyb20gdGhlIGFzeW5jIGZ1bmN0aW9uLFxuICogYGNvbnNvbGUuZGlyYCBpcyBjYWxsZWQgb24gZWFjaCBhcmd1bWVudCBpbiBvcmRlci5cbiAqXG4gKiBAbmFtZSBkaXJcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZ1bmN0aW9uIC0gVGhlIGZ1bmN0aW9uIHlvdSB3YW50IHRvIGV2ZW50dWFsbHkgYXBwbHlcbiAqIGFsbCBhcmd1bWVudHMgdG8uXG4gKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gaW4gYSBtb2R1bGVcbiAqIHZhciBoZWxsbyA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwge2hlbGxvOiBuYW1lfSk7XG4gKiAgICAgfSwgMTAwMCk7XG4gKiB9O1xuICpcbiAqIC8vIGluIHRoZSBub2RlIHJlcGxcbiAqIG5vZGU+IGFzeW5jLmRpcihoZWxsbywgJ3dvcmxkJyk7XG4gKiB7aGVsbG86ICd3b3JsZCd9XG4gKi9cbnZhciBkaXIgPSBjb25zb2xlRnVuYygnZGlyJyk7XG5cbi8qKlxuICogVGhlIHBvc3QtY2hlY2sgdmVyc2lvbiBvZiBbYGR1cmluZ2Bde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5kdXJpbmd9LiBUbyByZWZsZWN0IHRoZSBkaWZmZXJlbmNlIGluXG4gKiB0aGUgb3JkZXIgb2Ygb3BlcmF0aW9ucywgdGhlIGFyZ3VtZW50cyBgdGVzdGAgYW5kIGBmbmAgYXJlIHN3aXRjaGVkLlxuICpcbiAqIEFsc28gYSB2ZXJzaW9uIG9mIFtgZG9XaGlsc3RgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuZG9XaGlsc3R9IHdpdGggYXN5bmNocm9ub3VzIGB0ZXN0YCBmdW5jdGlvbi5cbiAqIEBuYW1lIGRvRHVyaW5nXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5kdXJpbmdde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5kdXJpbmd9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZVxuICogYHRlc3RgIHBhc3Nlcy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHRlc3QgLSBhc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGJlZm9yZSBlYWNoXG4gKiBleGVjdXRpb24gb2YgYGZuYC4gSW52b2tlZCB3aXRoICguLi5hcmdzLCBjYWxsYmFjayksIHdoZXJlIGAuLi5hcmdzYCBhcmUgdGhlXG4gKiBub24tZXJyb3IgYXJncyBmcm9tIHRoZSBwcmV2aW91cyBjYWxsYmFjayBvZiBgZm5gLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0XG4gKiBmdW5jdGlvbiBoYXMgZmFpbGVkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGZuYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYFxuICogd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgaWYgb25lIG9jY3VycmVkLCBvdGhlcndpc2UgYG51bGxgLlxuICovXG5mdW5jdGlvbiBkb0R1cmluZyhmbiwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9ubHlPbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoZm4pO1xuICAgIHZhciBfdGVzdCA9IHdyYXBBc3luYyh0ZXN0KTtcblxuICAgIGZ1bmN0aW9uIG5leHQoZXJyLyosIC4uLmFyZ3MqLykge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICBhcmdzLnB1c2goY2hlY2spO1xuICAgICAgICBfdGVzdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVjayhlcnIsIHRydXRoKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICBpZiAoIXRydXRoKSByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIF9mbihuZXh0KTtcbiAgICB9XG5cbiAgICBjaGVjayhudWxsLCB0cnVlKTtcblxufVxuXG4vKipcbiAqIFRoZSBwb3N0LWNoZWNrIHZlcnNpb24gb2YgW2B3aGlsc3RgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cud2hpbHN0fS4gVG8gcmVmbGVjdCB0aGUgZGlmZmVyZW5jZSBpblxuICogdGhlIG9yZGVyIG9mIG9wZXJhdGlvbnMsIHRoZSBhcmd1bWVudHMgYHRlc3RgIGFuZCBgaXRlcmF0ZWVgIGFyZSBzd2l0Y2hlZC5cbiAqXG4gKiBgZG9XaGlsc3RgIGlzIHRvIGB3aGlsc3RgIGFzIGBkbyB3aGlsZWAgaXMgdG8gYHdoaWxlYCBpbiBwbGFpbiBKYXZhU2NyaXB0LlxuICpcbiAqIEBuYW1lIGRvV2hpbHN0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy53aGlsc3Rde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53aGlsc3R9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZWFjaCB0aW1lIGB0ZXN0YFxuICogcGFzc2VzLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRlc3QgLSBzeW5jaHJvbm91cyB0cnV0aCB0ZXN0IHRvIHBlcmZvcm0gYWZ0ZXIgZWFjaFxuICogZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAuIEludm9rZWQgd2l0aCBhbnkgbm9uLWVycm9yIGNhbGxiYWNrIHJlc3VsdHMgb2ZcbiAqIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRlc3RcbiAqIGZ1bmN0aW9uIGhhcyBmYWlsZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgIGhhcyBzdG9wcGVkLlxuICogYGNhbGxiYWNrYCB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciBhbmQgYW55IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZpbmFsXG4gKiBgaXRlcmF0ZWVgJ3MgY2FsbGJhY2suIEludm9rZWQgd2l0aCAoZXJyLCBbcmVzdWx0c10pO1xuICovXG5mdW5jdGlvbiBkb1doaWxzdChpdGVyYXRlZSwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9ubHlPbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgIHZhciBuZXh0ID0gZnVuY3Rpb24oZXJyLyosIC4uLmFyZ3MqLykge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICBpZiAodGVzdC5hcHBseSh0aGlzLCBhcmdzKSkgcmV0dXJuIF9pdGVyYXRlZShuZXh0KTtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgW251bGxdLmNvbmNhdChhcmdzKSk7XG4gICAgfTtcbiAgICBfaXRlcmF0ZWUobmV4dCk7XG59XG5cbi8qKlxuICogTGlrZSBbJ2RvV2hpbHN0J117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmRvV2hpbHN0fSwgZXhjZXB0IHRoZSBgdGVzdGAgaXMgaW52ZXJ0ZWQuIE5vdGUgdGhlXG4gKiBhcmd1bWVudCBvcmRlcmluZyBkaWZmZXJzIGZyb20gYHVudGlsYC5cbiAqXG4gKiBAbmFtZSBkb1VudGlsXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5kb1doaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmRvV2hpbHN0fVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBlYWNoIHRpbWVcbiAqIGB0ZXN0YCBmYWlscy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0ZXN0IC0gc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGFmdGVyIGVhY2hcbiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggYW55IG5vbi1lcnJvciBjYWxsYmFjayByZXN1bHRzIG9mXG4gKiBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0XG4gKiBmdW5jdGlvbiBoYXMgcGFzc2VkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYFxuICogd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgYW5kIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3NcbiAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKTtcbiAqL1xuZnVuY3Rpb24gZG9VbnRpbChpdGVyYXRlZSwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICBkb1doaWxzdChpdGVyYXRlZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBMaWtlIFtgd2hpbHN0YF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH0sIGV4Y2VwdCB0aGUgYHRlc3RgIGlzIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0XG4gKiBpcyBwYXNzZWQgYSBjYWxsYmFjayBpbiB0aGUgZm9ybSBvZiBgZnVuY3Rpb24gKGVyciwgdHJ1dGgpYC4gSWYgZXJyb3IgaXNcbiAqIHBhc3NlZCB0byBgdGVzdGAgb3IgYGZuYCwgdGhlIG1haW4gY2FsbGJhY2sgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlXG4gKiB2YWx1ZSBvZiB0aGUgZXJyb3IuXG4gKlxuICogQG5hbWUgZHVyaW5nXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy53aGlsc3Rde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53aGlsc3R9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHRlc3QgLSBhc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGJlZm9yZSBlYWNoXG4gKiBleGVjdXRpb24gb2YgYGZuYC4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZVxuICogYHRlc3RgIHBhc3Nlcy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRlc3RcbiAqIGZ1bmN0aW9uIGhhcyBmYWlsZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgZm5gIGhhcyBzdG9wcGVkLiBgY2FsbGJhY2tgXG4gKiB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciwgaWYgb25lIG9jY3VycmVkLCBvdGhlcndpc2UgYG51bGxgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgY291bnQgPSAwO1xuICpcbiAqIGFzeW5jLmR1cmluZyhcbiAqICAgICBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAqICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGNvdW50IDwgNSk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAqICAgICAgICAgY291bnQrKztcbiAqICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCk7XG4gKiAgICAgfSxcbiAqICAgICBmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICAgIC8vIDUgc2Vjb25kcyBoYXZlIHBhc3NlZFxuICogICAgIH1cbiAqICk7XG4gKi9cbmZ1bmN0aW9uIGR1cmluZyh0ZXN0LCBmbiwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9ubHlPbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoZm4pO1xuICAgIHZhciBfdGVzdCA9IHdyYXBBc3luYyh0ZXN0KTtcblxuICAgIGZ1bmN0aW9uIG5leHQoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICBfdGVzdChjaGVjayk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2soZXJyLCB0cnV0aCkge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgaWYgKCF0cnV0aCkgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICBfZm4obmV4dCk7XG4gICAgfVxuXG4gICAgX3Rlc3QoY2hlY2spO1xufVxuXG5mdW5jdGlvbiBfd2l0aG91dEluZGV4KGl0ZXJhdGVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSwgY2FsbGJhY2spO1xuICAgIH07XG59XG5cbi8qKlxuICogQXBwbGllcyB0aGUgZnVuY3Rpb24gYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLCBpbiBwYXJhbGxlbC5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIGNhbGxlZCB3aXRoIGFuIGl0ZW0gZnJvbSB0aGUgbGlzdCwgYW5kIGEgY2FsbGJhY2sgZm9yIHdoZW5cbiAqIGl0IGhhcyBmaW5pc2hlZC4gSWYgdGhlIGBpdGVyYXRlZWAgcGFzc2VzIGFuIGVycm9yIHRvIGl0cyBgY2FsbGJhY2tgLCB0aGVcbiAqIG1haW4gYGNhbGxiYWNrYCAoZm9yIHRoZSBgZWFjaGAgZnVuY3Rpb24pIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZVxuICogZXJyb3IuXG4gKlxuICogTm90ZSwgdGhhdCBzaW5jZSB0aGlzIGZ1bmN0aW9uIGFwcGxpZXMgYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4gcGFyYWxsZWwsXG4gKiB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgaXRlcmF0ZWUgZnVuY3Rpb25zIHdpbGwgY29tcGxldGUgaW4gb3JkZXIuXG4gKlxuICogQG5hbWUgZWFjaFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGFsaWFzIGZvckVhY2hcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG9cbiAqIGVhY2ggaXRlbSBpbiBgY29sbGAuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogVGhlIGFycmF5IGluZGV4IGlzIG5vdCBwYXNzZWQgdG8gdGhlIGl0ZXJhdGVlLlxuICogSWYgeW91IG5lZWQgdGhlIGluZGV4LCB1c2UgYGVhY2hPZmAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBhc3N1bWluZyBvcGVuRmlsZXMgaXMgYW4gYXJyYXkgb2YgZmlsZSBuYW1lcyBhbmQgc2F2ZUZpbGUgaXMgYSBmdW5jdGlvblxuICogLy8gdG8gc2F2ZSB0aGUgbW9kaWZpZWQgY29udGVudHMgb2YgdGhhdCBmaWxlOlxuICpcbiAqIGFzeW5jLmVhY2gob3BlbkZpbGVzLCBzYXZlRmlsZSwgZnVuY3Rpb24oZXJyKXtcbiAqICAgLy8gaWYgYW55IG9mIHRoZSBzYXZlcyBwcm9kdWNlZCBhbiBlcnJvciwgZXJyIHdvdWxkIGVxdWFsIHRoYXQgZXJyb3JcbiAqIH0pO1xuICpcbiAqIC8vIGFzc3VtaW5nIG9wZW5GaWxlcyBpcyBhbiBhcnJheSBvZiBmaWxlIG5hbWVzXG4gKiBhc3luYy5lYWNoKG9wZW5GaWxlcywgZnVuY3Rpb24oZmlsZSwgY2FsbGJhY2spIHtcbiAqXG4gKiAgICAgLy8gUGVyZm9ybSBvcGVyYXRpb24gb24gZmlsZSBoZXJlLlxuICogICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzaW5nIGZpbGUgJyArIGZpbGUpO1xuICpcbiAqICAgICBpZiggZmlsZS5sZW5ndGggPiAzMiApIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCdUaGlzIGZpbGUgbmFtZSBpcyB0b28gbG9uZycpO1xuICogICAgICAgY2FsbGJhY2soJ0ZpbGUgbmFtZSB0b28gbG9uZycpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAvLyBEbyB3b3JrIHRvIHByb2Nlc3MgZmlsZSBoZXJlXG4gKiAgICAgICBjb25zb2xlLmxvZygnRmlsZSBwcm9jZXNzZWQnKTtcbiAqICAgICAgIGNhbGxiYWNrKCk7XG4gKiAgICAgfVxuICogfSwgZnVuY3Rpb24oZXJyKSB7XG4gKiAgICAgLy8gaWYgYW55IG9mIHRoZSBmaWxlIHByb2Nlc3NpbmcgcHJvZHVjZWQgYW4gZXJyb3IsIGVyciB3b3VsZCBlcXVhbCB0aGF0IGVycm9yXG4gKiAgICAgaWYoIGVyciApIHtcbiAqICAgICAgIC8vIE9uZSBvZiB0aGUgaXRlcmF0aW9ucyBwcm9kdWNlZCBhbiBlcnJvci5cbiAqICAgICAgIC8vIEFsbCBwcm9jZXNzaW5nIHdpbGwgbm93IHN0b3AuXG4gKiAgICAgICBjb25zb2xlLmxvZygnQSBmaWxlIGZhaWxlZCB0byBwcm9jZXNzJyk7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCdBbGwgZmlsZXMgaGF2ZSBiZWVuIHByb2Nlc3NlZCBzdWNjZXNzZnVsbHknKTtcbiAqICAgICB9XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gZWFjaExpbWl0KGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGVhY2hPZihjb2xsLCBfd2l0aG91dEluZGV4KHdyYXBBc3luYyhpdGVyYXRlZSkpLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BlYWNoYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGVhY2hMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZWFjaF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9XG4gKiBAYWxpYXMgZm9yRWFjaExpbWl0XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIGFycmF5IGluZGV4IGlzIG5vdCBwYXNzZWQgdG8gdGhlIGl0ZXJhdGVlLlxuICogSWYgeW91IG5lZWQgdGhlIGluZGV4LCB1c2UgYGVhY2hPZkxpbWl0YC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqL1xuZnVuY3Rpb24gZWFjaExpbWl0JDEoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIF9lYWNoT2ZMaW1pdChsaW1pdCkoY29sbCwgX3dpdGhvdXRJbmRleCh3cmFwQXN5bmMoaXRlcmF0ZWUpKSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZWFjaGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZWFjaFNlcmllc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZWFjaF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9XG4gKiBAYWxpYXMgZm9yRWFjaFNlcmllc1xuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoXG4gKiBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBhcnJheSBpbmRleCBpcyBub3QgcGFzc2VkIHRvIHRoZSBpdGVyYXRlZS5cbiAqIElmIHlvdSBuZWVkIHRoZSBpbmRleCwgdXNlIGBlYWNoT2ZTZXJpZXNgLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICovXG52YXIgZWFjaFNlcmllcyA9IGRvTGltaXQoZWFjaExpbWl0JDEsIDEpO1xuXG4vKipcbiAqIFdyYXAgYW4gYXN5bmMgZnVuY3Rpb24gYW5kIGVuc3VyZSBpdCBjYWxscyBpdHMgY2FsbGJhY2sgb24gYSBsYXRlciB0aWNrIG9mXG4gKiB0aGUgZXZlbnQgbG9vcC4gIElmIHRoZSBmdW5jdGlvbiBhbHJlYWR5IGNhbGxzIGl0cyBjYWxsYmFjayBvbiBhIG5leHQgdGljayxcbiAqIG5vIGV4dHJhIGRlZmVycmFsIGlzIGFkZGVkLiBUaGlzIGlzIHVzZWZ1bCBmb3IgcHJldmVudGluZyBzdGFjayBvdmVyZmxvd3NcbiAqIChgUmFuZ2VFcnJvcjogTWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRgKSBhbmQgZ2VuZXJhbGx5IGtlZXBpbmdcbiAqIFtaYWxnb10oaHR0cDovL2Jsb2cuaXpzLm1lL3Bvc3QvNTkxNDI3NDIxNDMvZGVzaWduaW5nLWFwaXMtZm9yLWFzeW5jaHJvbnkpXG4gKiBjb250YWluZWQuIEVTMjAxNyBgYXN5bmNgIGZ1bmN0aW9ucyBhcmUgcmV0dXJuZWQgYXMtaXMgLS0gdGhleSBhcmUgaW1tdW5lXG4gKiB0byBaYWxnbydzIGNvcnJ1cHRpbmcgaW5mbHVlbmNlcywgYXMgdGhleSBhbHdheXMgcmVzb2x2ZSBvbiBhIGxhdGVyIHRpY2suXG4gKlxuICogQG5hbWUgZW5zdXJlQXN5bmNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gYW4gYXN5bmMgZnVuY3Rpb24sIG9uZSB0aGF0IGV4cGVjdHMgYSBub2RlLXN0eWxlXG4gKiBjYWxsYmFjayBhcyBpdHMgbGFzdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBSZXR1cm5zIGEgd3JhcHBlZCBmdW5jdGlvbiB3aXRoIHRoZSBleGFjdCBzYW1lIGNhbGxcbiAqIHNpZ25hdHVyZSBhcyB0aGUgZnVuY3Rpb24gcGFzc2VkIGluLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBzb21ldGltZXNBc3luYyhhcmcsIGNhbGxiYWNrKSB7XG4gKiAgICAgaWYgKGNhY2hlW2FyZ10pIHtcbiAqICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGNhY2hlW2FyZ10pOyAvLyB0aGlzIHdvdWxkIGJlIHN5bmNocm9ub3VzISFcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgICBkb1NvbWVJTyhhcmcsIGNhbGxiYWNrKTsgLy8gdGhpcyBJTyB3b3VsZCBiZSBhc3luY2hyb25vdXNcbiAqICAgICB9XG4gKiB9XG4gKlxuICogLy8gdGhpcyBoYXMgYSByaXNrIG9mIHN0YWNrIG92ZXJmbG93cyBpZiBtYW55IHJlc3VsdHMgYXJlIGNhY2hlZCBpbiBhIHJvd1xuICogYXN5bmMubWFwU2VyaWVzKGFyZ3MsIHNvbWV0aW1lc0FzeW5jLCBkb25lKTtcbiAqXG4gKiAvLyB0aGlzIHdpbGwgZGVmZXIgc29tZXRpbWVzQXN5bmMncyBjYWxsYmFjayBpZiBuZWNlc3NhcnksXG4gKiAvLyBwcmV2ZW50aW5nIHN0YWNrIG92ZXJmbG93c1xuICogYXN5bmMubWFwU2VyaWVzKGFyZ3MsIGFzeW5jLmVuc3VyZUFzeW5jKHNvbWV0aW1lc0FzeW5jKSwgZG9uZSk7XG4gKi9cbmZ1bmN0aW9uIGVuc3VyZUFzeW5jKGZuKSB7XG4gICAgaWYgKGlzQXN5bmMoZm4pKSByZXR1cm4gZm47XG4gICAgcmV0dXJuIGluaXRpYWxQYXJhbXMoZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzeW5jID0gdHJ1ZTtcbiAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbm5lckFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgaW5uZXJBcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgaW5uZXJBcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBzeW5jID0gZmFsc2U7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG5vdElkKHYpIHtcbiAgICByZXR1cm4gIXY7XG59XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgZXZlcnkgZWxlbWVudCBpbiBgY29sbGAgc2F0aXNmaWVzIGFuIGFzeW5jIHRlc3QuIElmIGFueVxuICogaXRlcmF0ZWUgY2FsbCByZXR1cm5zIGBmYWxzZWAsIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkLlxuICpcbiAqIEBuYW1lIGV2ZXJ5XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgYWxsXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtXG4gKiBpbiB0aGUgY29sbGVjdGlvbiBpbiBwYXJhbGxlbC5cbiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHJlc3VsdCB2YWx1ZS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYFxuICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuZXZlcnkoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZVBhdGgsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycilcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gaWYgcmVzdWx0IGlzIHRydWUgdGhlbiBldmVyeSBmaWxlIGV4aXN0c1xuICogfSk7XG4gKi9cbnZhciBldmVyeSA9IGRvUGFyYWxsZWwoX2NyZWF0ZVRlc3Rlcihub3RJZCwgbm90SWQpKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGV2ZXJ5YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmV2ZXJ5fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBldmVyeUxpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5ldmVyeV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmV2ZXJ5fVxuICogQGFsaWFzIGFsbExpbWl0XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtXG4gKiBpbiB0aGUgY29sbGVjdGlvbiBpbiBwYXJhbGxlbC5cbiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHJlc3VsdCB2YWx1ZS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYFxuICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqL1xudmFyIGV2ZXJ5TGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2NyZWF0ZVRlc3Rlcihub3RJZCwgbm90SWQpKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGV2ZXJ5YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmV2ZXJ5fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZXZlcnlTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmV2ZXJ5XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZXZlcnl9XG4gKiBAYWxpYXMgYWxsU2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtXG4gKiBpbiB0aGUgY29sbGVjdGlvbiBpbiBzZXJpZXMuXG4gKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiByZXN1bHQgdmFsdWUuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWBcbiAqIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIHRoZSBhc3luYyB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKi9cbnZhciBldmVyeVNlcmllcyA9IGRvTGltaXQoZXZlcnlMaW1pdCwgMSk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbHRlckFycmF5KGVhY2hmbiwgYXJyLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgdHJ1dGhWYWx1ZXMgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGluZGV4LCBjYWxsYmFjaykge1xuICAgICAgICBpdGVyYXRlZSh4LCBmdW5jdGlvbiAoZXJyLCB2KSB7XG4gICAgICAgICAgICB0cnV0aFZhbHVlc1tpbmRleF0gPSAhIXY7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRydXRoVmFsdWVzW2ldKSByZXN1bHRzLnB1c2goYXJyW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZmlsdGVyR2VuZXJpYyhlYWNoZm4sIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgZWFjaGZuKGNvbGwsIGZ1bmN0aW9uICh4LCBpbmRleCwgY2FsbGJhY2spIHtcbiAgICAgICAgaXRlcmF0ZWUoeCwgZnVuY3Rpb24gKGVyciwgdikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7aW5kZXg6IGluZGV4LCB2YWx1ZTogeH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBhcnJheU1hcChyZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgICAgICAgICB9KSwgYmFzZVByb3BlcnR5KCd2YWx1ZScpKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gX2ZpbHRlcihlYWNoZm4sIGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWx0ZXIgPSBpc0FycmF5TGlrZShjb2xsKSA/IGZpbHRlckFycmF5IDogZmlsdGVyR2VuZXJpYztcbiAgICBmaWx0ZXIoZWFjaGZuLCBjb2xsLCB3cmFwQXN5bmMoaXRlcmF0ZWUpLCBjYWxsYmFjayB8fCBub29wKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGFsbCB0aGUgdmFsdWVzIGluIGBjb2xsYCB3aGljaCBwYXNzIGFuIGFzeW5jIHRydXRoXG4gKiB0ZXN0LiBUaGlzIG9wZXJhdGlvbiBpcyBwZXJmb3JtZWQgaW4gcGFyYWxsZWwsIGJ1dCB0aGUgcmVzdWx0cyBhcnJheSB3aWxsIGJlXG4gKiBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgb3JpZ2luYWwuXG4gKlxuICogQG5hbWUgZmlsdGVyXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgc2VsZWN0XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy5maWx0ZXIoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZVBhdGgsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycilcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHJlc3VsdHMgbm93IGVxdWFscyBhbiBhcnJheSBvZiB0aGUgZXhpc3RpbmcgZmlsZXNcbiAqIH0pO1xuICovXG52YXIgZmlsdGVyID0gZG9QYXJhbGxlbChfZmlsdGVyKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGZpbHRlcmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYVxuICogdGltZS5cbiAqXG4gKiBAbmFtZSBmaWx0ZXJMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZmlsdGVyXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfVxuICogQGFsaWFzIHNlbGVjdExpbWl0XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICovXG52YXIgZmlsdGVyTGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2ZpbHRlcik7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BmaWx0ZXJgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZmlsdGVyU2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5maWx0ZXJde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9XG4gKiBAYWxpYXMgc2VsZWN0U2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC5cbiAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWRcbiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpXG4gKi9cbnZhciBmaWx0ZXJTZXJpZXMgPSBkb0xpbWl0KGZpbHRlckxpbWl0LCAxKTtcblxuLyoqXG4gKiBDYWxscyB0aGUgYXN5bmNocm9ub3VzIGZ1bmN0aW9uIGBmbmAgd2l0aCBhIGNhbGxiYWNrIHBhcmFtZXRlciB0aGF0IGFsbG93cyBpdFxuICogdG8gY2FsbCBpdHNlbGYgYWdhaW4sIGluIHNlcmllcywgaW5kZWZpbml0ZWx5LlxuXG4gKiBJZiBhbiBlcnJvciBpcyBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIHRoZW4gYGVycmJhY2tgIGlzIGNhbGxlZCB3aXRoIHRoZVxuICogZXJyb3IsIGFuZCBleGVjdXRpb24gc3RvcHMsIG90aGVyd2lzZSBpdCB3aWxsIG5ldmVyIGJlIGNhbGxlZC5cbiAqXG4gKiBAbmFtZSBmb3JldmVyXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gYW4gYXN5bmMgZnVuY3Rpb24gdG8gY2FsbCByZXBlYXRlZGx5LlxuICogSW52b2tlZCB3aXRoIChuZXh0KS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJiYWNrXSAtIHdoZW4gYGZuYCBwYXNzZXMgYW4gZXJyb3IgdG8gaXQncyBjYWxsYmFjayxcbiAqIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQsIGFuZCBleGVjdXRpb24gc3RvcHMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuZm9yZXZlcihcbiAqICAgICBmdW5jdGlvbihuZXh0KSB7XG4gKiAgICAgICAgIC8vIG5leHQgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgdG8gdGhpbmdzIHRoYXQgbmVlZCBhIGNhbGxiYWNrKGVyciBbLCB3aGF0ZXZlcl0pO1xuICogICAgICAgICAvLyBpdCB3aWxsIHJlc3VsdCBpbiB0aGlzIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCBhZ2Fpbi5cbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGVycikge1xuICogICAgICAgICAvLyBpZiBuZXh0IGlzIGNhbGxlZCB3aXRoIGEgdmFsdWUgaW4gaXRzIGZpcnN0IHBhcmFtZXRlciwgaXQgd2lsbCBhcHBlYXJcbiAqICAgICAgICAgLy8gaW4gaGVyZSBhcyAnZXJyJywgYW5kIGV4ZWN1dGlvbiB3aWxsIHN0b3AuXG4gKiAgICAgfVxuICogKTtcbiAqL1xuZnVuY3Rpb24gZm9yZXZlcihmbiwgZXJyYmFjaykge1xuICAgIHZhciBkb25lID0gb25seU9uY2UoZXJyYmFjayB8fCBub29wKTtcbiAgICB2YXIgdGFzayA9IHdyYXBBc3luYyhlbnN1cmVBc3luYyhmbikpO1xuXG4gICAgZnVuY3Rpb24gbmV4dChlcnIpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgdGFzayhuZXh0KTtcbiAgICB9XG4gICAgbmV4dCgpO1xufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgZ3JvdXBCeWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBncm91cEJ5TGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmdyb3VwQnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGBrZXlgIHRvIGdyb3VwIHRoZSB2YWx1ZSB1bmRlci5cbiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHQgaXMgYW4gYE9iamVjdGAgd2hvc2VzXG4gKiBwcm9wZXJ0aWVzIGFyZSBhcnJheXMgb2YgdmFsdWVzIHdoaWNoIHJldHVybmVkIHRoZSBjb3JyZXNwb25kaW5nIGtleS5cbiAqL1xudmFyIGdyb3VwQnlMaW1pdCA9IGZ1bmN0aW9uKGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7XG4gICAgbWFwTGltaXQoY29sbCwgbGltaXQsIGZ1bmN0aW9uKHZhbCwgY2FsbGJhY2spIHtcbiAgICAgICAgX2l0ZXJhdGVlKHZhbCwgZnVuY3Rpb24oZXJyLCBrZXkpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtrZXk6IGtleSwgdmFsOiB2YWx9KTtcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24oZXJyLCBtYXBSZXN1bHRzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgLy8gZnJvbSBNRE4sIGhhbmRsZSBvYmplY3QgaGF2aW5nIGFuIGBoYXNPd25Qcm9wZXJ0eWAgcHJvcFxuICAgICAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwUmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG1hcFJlc3VsdHNbaV0pIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gbWFwUmVzdWx0c1tpXS5rZXk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IG1hcFJlc3VsdHNbaV0udmFsO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IFt2YWxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgb2JqZWN0LCB3aGVyZSBlYWNoIHZhbHVlIGNvcnJlc3BvbmRzIHRvIGFuIGFycmF5IG9mIGl0ZW1zLCBmcm9tXG4gKiBgY29sbGAsIHRoYXQgcmV0dXJuZWQgdGhlIGNvcnJlc3BvbmRpbmcga2V5LiBUaGF0IGlzLCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0XG4gKiBjb3JyZXNwb25kIHRvIHRoZSB2YWx1ZXMgcGFzc2VkIHRvIHRoZSBgaXRlcmF0ZWVgIGNhbGxiYWNrLlxuICpcbiAqIE5vdGU6IFNpbmNlIHRoaXMgZnVuY3Rpb24gYXBwbGllcyB0aGUgYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4gcGFyYWxsZWwsXG4gKiB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgd2lsbCBjb21wbGV0ZSBpbiBvcmRlci5cbiAqIEhvd2V2ZXIsIHRoZSB2YWx1ZXMgZm9yIGVhY2gga2V5IGluIHRoZSBgcmVzdWx0YCB3aWxsIGJlIGluIHRoZSBzYW1lIG9yZGVyIGFzXG4gKiB0aGUgb3JpZ2luYWwgYGNvbGxgLiBGb3IgT2JqZWN0cywgdGhlIHZhbHVlcyB3aWxsIHJvdWdobHkgYmUgaW4gdGhlIG9yZGVyIG9mXG4gKiB0aGUgb3JpZ2luYWwgT2JqZWN0cycga2V5cyAoYnV0IHRoaXMgY2FuIHZhcnkgYWNyb3NzIEphdmFTY3JpcHQgZW5naW5lcykuXG4gKlxuICogQG5hbWUgZ3JvdXBCeVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGBrZXlgIHRvIGdyb3VwIHRoZSB2YWx1ZSB1bmRlci5cbiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHQgaXMgYW4gYE9iamVjdGAgd2hvc2VzXG4gKiBwcm9wZXJ0aWVzIGFyZSBhcnJheXMgb2YgdmFsdWVzIHdoaWNoIHJldHVybmVkIHRoZSBjb3JyZXNwb25kaW5nIGtleS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuZ3JvdXBCeShbJ3VzZXJJZDEnLCAndXNlcklkMicsICd1c2VySWQzJ10sIGZ1bmN0aW9uKHVzZXJJZCwgY2FsbGJhY2spIHtcbiAqICAgICBkYi5maW5kQnlJZCh1c2VySWQsIGZ1bmN0aW9uKGVyciwgdXNlcikge1xuICogICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAqICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHVzZXIuYWdlKTtcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gcmVzdWx0IGlzIG9iamVjdCBjb250YWluaW5nIHRoZSB1c2VySWRzIGdyb3VwZWQgYnkgYWdlXG4gKiAgICAgLy8gZS5nLiB7IDMwOiBbJ3VzZXJJZDEnLCAndXNlcklkMyddLCA0MjogWyd1c2VySWQyJ119O1xuICogfSk7XG4gKi9cbnZhciBncm91cEJ5ID0gZG9MaW1pdChncm91cEJ5TGltaXQsIEluZmluaXR5KTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGdyb3VwQnlgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZ3JvdXBCeX0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIEBuYW1lIGdyb3VwQnlTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmdyb3VwQnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGBrZXlgIHRvIGdyb3VwIHRoZSB2YWx1ZSB1bmRlci5cbiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHQgaXMgYW4gYE9iamVjdGAgd2hvc2VzXG4gKiBwcm9wZXJ0aWVzIGFyZSBhcnJheXMgb2YgdmFsdWVzIHdoaWNoIHJldHVybmVkIHRoZSBjb3JyZXNwb25kaW5nIGtleS5cbiAqL1xudmFyIGdyb3VwQnlTZXJpZXMgPSBkb0xpbWl0KGdyb3VwQnlMaW1pdCwgMSk7XG5cbi8qKlxuICogTG9ncyB0aGUgcmVzdWx0IG9mIGFuIGBhc3luY2AgZnVuY3Rpb24gdG8gdGhlIGBjb25zb2xlYC4gT25seSB3b3JrcyBpblxuICogTm9kZS5qcyBvciBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgYGNvbnNvbGUubG9nYCBhbmQgYGNvbnNvbGUuZXJyb3JgIChzdWNoXG4gKiBhcyBGRiBhbmQgQ2hyb21lKS4gSWYgbXVsdGlwbGUgYXJndW1lbnRzIGFyZSByZXR1cm5lZCBmcm9tIHRoZSBhc3luY1xuICogZnVuY3Rpb24sIGBjb25zb2xlLmxvZ2AgaXMgY2FsbGVkIG9uIGVhY2ggYXJndW1lbnQgaW4gb3JkZXIuXG4gKlxuICogQG5hbWUgbG9nXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmdW5jdGlvbiAtIFRoZSBmdW5jdGlvbiB5b3Ugd2FudCB0byBldmVudHVhbGx5IGFwcGx5XG4gKiBhbGwgYXJndW1lbnRzIHRvLlxuICogQHBhcmFtIHsuLi4qfSBhcmd1bWVudHMuLi4gLSBBbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGluIGEgbW9kdWxlXG4gKiB2YXIgaGVsbG8gPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdoZWxsbyAnICsgbmFtZSk7XG4gKiAgICAgfSwgMTAwMCk7XG4gKiB9O1xuICpcbiAqIC8vIGluIHRoZSBub2RlIHJlcGxcbiAqIG5vZGU+IGFzeW5jLmxvZyhoZWxsbywgJ3dvcmxkJyk7XG4gKiAnaGVsbG8gd29ybGQnXG4gKi9cbnZhciBsb2cgPSBjb25zb2xlRnVuYygnbG9nJyk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BtYXBWYWx1ZXNgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwVmFsdWVzfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgbWFwVmFsdWVzTGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLm1hcFZhbHVlc117QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcFZhbHVlc31cbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggdmFsdWUgYW5kIGtleVxuICogaW4gYGNvbGxgLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZSBhcyBpdHMgcmVzdWx0LlxuICogSW52b2tlZCB3aXRoICh2YWx1ZSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gYHJlc3VsdGAgaXMgYSBuZXcgb2JqZWN0IGNvbnNpc3RpbmdcbiAqIG9mIGVhY2gga2V5IGZyb20gYG9iamAsIHdpdGggZWFjaCB0cmFuc2Zvcm1lZCB2YWx1ZSBvbiB0aGUgcmlnaHQtaGFuZCBzaWRlLlxuICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuXG4gKi9cbmZ1bmN0aW9uIG1hcFZhbHVlc0xpbWl0KG9iaiwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICB2YXIgbmV3T2JqID0ge307XG4gICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7XG4gICAgZWFjaE9mTGltaXQob2JqLCBsaW1pdCwgZnVuY3Rpb24odmFsLCBrZXksIG5leHQpIHtcbiAgICAgICAgX2l0ZXJhdGVlKHZhbCwga2V5LCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBuZXh0KGVycik7XG4gICAgICAgICAgICBuZXdPYmpba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIsIG5ld09iaik7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQSByZWxhdGl2ZSBvZiBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LCBkZXNpZ25lZCBmb3IgdXNlIHdpdGggb2JqZWN0cy5cbiAqXG4gKiBQcm9kdWNlcyBhIG5ldyBPYmplY3QgYnkgbWFwcGluZyBlYWNoIHZhbHVlIG9mIGBvYmpgIHRocm91Z2ggdGhlIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9uLiBUaGUgYGl0ZXJhdGVlYCBpcyBjYWxsZWQgZWFjaCBgdmFsdWVgIGFuZCBga2V5YCBmcm9tIGBvYmpgIGFuZCBhXG4gKiBjYWxsYmFjayBmb3Igd2hlbiBpdCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZy4gRWFjaCBvZiB0aGVzZSBjYWxsYmFja3MgdGFrZXNcbiAqIHR3byBhcmd1bWVudHM6IGFuIGBlcnJvcmAsIGFuZCB0aGUgdHJhbnNmb3JtZWQgaXRlbSBmcm9tIGBvYmpgLiBJZiBgaXRlcmF0ZWVgXG4gKiBwYXNzZXMgYW4gZXJyb3IgdG8gaXRzIGNhbGxiYWNrLCB0aGUgbWFpbiBgY2FsbGJhY2tgIChmb3IgdGhlIGBtYXBWYWx1ZXNgXG4gKiBmdW5jdGlvbikgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLlxuICpcbiAqIE5vdGUsIHRoZSBvcmRlciBvZiB0aGUga2V5cyBpbiB0aGUgcmVzdWx0IGlzIG5vdCBndWFyYW50ZWVkLiAgVGhlIGtleXMgd2lsbFxuICogYmUgcm91Z2hseSBpbiB0aGUgb3JkZXIgdGhleSBjb21wbGV0ZSwgKGJ1dCB0aGlzIGlzIHZlcnkgZW5naW5lLXNwZWNpZmljKVxuICpcbiAqIEBuYW1lIG1hcFZhbHVlc1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB2YWx1ZSBhbmQga2V5XG4gKiBpbiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIHZhbHVlIGFzIGl0cyByZXN1bHQuXG4gKiBJbnZva2VkIHdpdGggKHZhbHVlLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBgcmVzdWx0YCBpcyBhIG5ldyBvYmplY3QgY29uc2lzdGluZ1xuICogb2YgZWFjaCBrZXkgZnJvbSBgb2JqYCwgd2l0aCBlYWNoIHRyYW5zZm9ybWVkIHZhbHVlIG9uIHRoZSByaWdodC1oYW5kIHNpZGUuXG4gKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMubWFwVmFsdWVzKHtcbiAqICAgICBmMTogJ2ZpbGUxJyxcbiAqICAgICBmMjogJ2ZpbGUyJyxcbiAqICAgICBmMzogJ2ZpbGUzJ1xuICogfSwgZnVuY3Rpb24gKGZpbGUsIGtleSwgY2FsbGJhY2spIHtcbiAqICAgZnMuc3RhdChmaWxlLCBjYWxsYmFjayk7XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIHJlc3VsdCBpcyBub3cgYSBtYXAgb2Ygc3RhdHMgZm9yIGVhY2ggZmlsZSwgZS5nLlxuICogICAgIC8vIHtcbiAqICAgICAvLyAgICAgZjE6IFtzdGF0cyBmb3IgZmlsZTFdLFxuICogICAgIC8vICAgICBmMjogW3N0YXRzIGZvciBmaWxlMl0sXG4gKiAgICAgLy8gICAgIGYzOiBbc3RhdHMgZm9yIGZpbGUzXVxuICogICAgIC8vIH1cbiAqIH0pO1xuICovXG5cbnZhciBtYXBWYWx1ZXMgPSBkb0xpbWl0KG1hcFZhbHVlc0xpbWl0LCBJbmZpbml0eSk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BtYXBWYWx1ZXNgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwVmFsdWVzfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgbWFwVmFsdWVzU2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5tYXBWYWx1ZXNde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXBWYWx1ZXN9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIHZhbHVlIGFuZCBrZXlcbiAqIGluIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgdmFsdWUgYXMgaXRzIHJlc3VsdC5cbiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGtleSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWBcbiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIGByZXN1bHRgIGlzIGEgbmV3IG9iamVjdCBjb25zaXN0aW5nXG4gKiBvZiBlYWNoIGtleSBmcm9tIGBvYmpgLCB3aXRoIGVhY2ggdHJhbnNmb3JtZWQgdmFsdWUgb24gdGhlIHJpZ2h0LWhhbmQgc2lkZS5cbiAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICovXG52YXIgbWFwVmFsdWVzU2VyaWVzID0gZG9MaW1pdChtYXBWYWx1ZXNMaW1pdCwgMSk7XG5cbmZ1bmN0aW9uIGhhcyhvYmosIGtleSkge1xuICAgIHJldHVybiBrZXkgaW4gb2JqO1xufVxuXG4vKipcbiAqIENhY2hlcyB0aGUgcmVzdWx0cyBvZiBhbiBhc3luYyBmdW5jdGlvbi4gV2hlbiBjcmVhdGluZyBhIGhhc2ggdG8gc3RvcmVcbiAqIGZ1bmN0aW9uIHJlc3VsdHMgYWdhaW5zdCwgdGhlIGNhbGxiYWNrIGlzIG9taXR0ZWQgZnJvbSB0aGUgaGFzaCBhbmQgYW5cbiAqIG9wdGlvbmFsIGhhc2ggZnVuY3Rpb24gY2FuIGJlIHVzZWQuXG4gKlxuICogSWYgbm8gaGFzaCBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIHRoZSBmaXJzdCBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGFzaCBrZXksXG4gKiB3aGljaCBtYXkgd29yayByZWFzb25hYmx5IGlmIGl0IGlzIGEgc3RyaW5nIG9yIGEgZGF0YSB0eXBlIHRoYXQgY29udmVydHMgdG8gYVxuICogZGlzdGluY3Qgc3RyaW5nLiBOb3RlIHRoYXQgb2JqZWN0cyBhbmQgYXJyYXlzIHdpbGwgbm90IGJlaGF2ZSByZWFzb25hYmx5LlxuICogTmVpdGhlciB3aWxsIGNhc2VzIHdoZXJlIHRoZSBvdGhlciBhcmd1bWVudHMgYXJlIHNpZ25pZmljYW50LiBJbiBzdWNoIGNhc2VzLFxuICogc3BlY2lmeSB5b3VyIG93biBoYXNoIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSBjYWNoZSBvZiByZXN1bHRzIGlzIGV4cG9zZWQgYXMgdGhlIGBtZW1vYCBwcm9wZXJ0eSBvZiB0aGUgZnVuY3Rpb25cbiAqIHJldHVybmVkIGJ5IGBtZW1vaXplYC5cbiAqXG4gKiBAbmFtZSBtZW1vaXplXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmbiAtIFRoZSBhc3luYyBmdW5jdGlvbiB0byBwcm94eSBhbmQgY2FjaGUgcmVzdWx0cyBmcm9tLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzaGVyIC0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gZm9yIGdlbmVyYXRpbmcgYSBjdXN0b20gaGFzaFxuICogZm9yIHN0b3JpbmcgcmVzdWx0cy4gSXQgaGFzIGFsbCB0aGUgYXJndW1lbnRzIGFwcGxpZWQgdG8gaXQgYXBhcnQgZnJvbSB0aGVcbiAqIGNhbGxiYWNrLCBhbmQgbXVzdCBiZSBzeW5jaHJvbm91cy5cbiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBhIG1lbW9pemVkIHZlcnNpb24gb2YgYGZuYFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgc2xvd19mbiA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nXG4gKiAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAqIH07XG4gKiB2YXIgZm4gPSBhc3luYy5tZW1vaXplKHNsb3dfZm4pO1xuICpcbiAqIC8vIGZuIGNhbiBub3cgYmUgdXNlZCBhcyBpZiBpdCB3ZXJlIHNsb3dfZm5cbiAqIGZuKCdzb21lIG5hbWUnLCBmdW5jdGlvbigpIHtcbiAqICAgICAvLyBjYWxsYmFja1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZm4sIGhhc2hlcikge1xuICAgIHZhciBtZW1vID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcXVldWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBoYXNoZXIgPSBoYXNoZXIgfHwgaWRlbnRpdHk7XG4gICAgdmFyIF9mbiA9IHdyYXBBc3luYyhmbik7XG4gICAgdmFyIG1lbW9pemVkID0gaW5pdGlhbFBhcmFtcyhmdW5jdGlvbiBtZW1vaXplZChhcmdzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICBpZiAoaGFzKG1lbW8sIGtleSkpIHtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIG1lbW9ba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXMocXVldWVzLCBrZXkpKSB7XG4gICAgICAgICAgICBxdWV1ZXNba2V5XS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlc1trZXldID0gW2NhbGxiYWNrXTtcbiAgICAgICAgICAgIF9mbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChmdW5jdGlvbigvKmFyZ3MqLykge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBtZW1vW2tleV0gPSBhcmdzO1xuICAgICAgICAgICAgICAgIHZhciBxID0gcXVldWVzW2tleV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcVtpXS5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBtZW1vaXplZC5tZW1vID0gbWVtbztcbiAgICBtZW1vaXplZC51bm1lbW9pemVkID0gZm47XG4gICAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vKipcbiAqIENhbGxzIGBjYWxsYmFja2Agb24gYSBsYXRlciBsb29wIGFyb3VuZCB0aGUgZXZlbnQgbG9vcC4gSW4gTm9kZS5qcyB0aGlzIGp1c3RcbiAqIGNhbGxzIGBwcm9jZXNzLm5leHRUaWNrYC4gIEluIHRoZSBicm93c2VyIGl0IHdpbGwgdXNlIGBzZXRJbW1lZGlhdGVgIGlmXG4gKiBhdmFpbGFibGUsIG90aGVyd2lzZSBgc2V0VGltZW91dChjYWxsYmFjaywgMClgLCB3aGljaCBtZWFucyBvdGhlciBoaWdoZXJcbiAqIHByaW9yaXR5IGV2ZW50cyBtYXkgcHJlY2VkZSB0aGUgZXhlY3V0aW9uIG9mIGBjYWxsYmFja2AuXG4gKlxuICogVGhpcyBpcyB1c2VkIGludGVybmFsbHkgZm9yIGJyb3dzZXItY29tcGF0aWJpbGl0eSBwdXJwb3Nlcy5cbiAqXG4gKiBAbmFtZSBuZXh0VGlja1xuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuc2V0SW1tZWRpYXRlXXtAbGluayBtb2R1bGU6VXRpbHMuc2V0SW1tZWRpYXRlfVxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gYSBsYXRlciBsb29wIGFyb3VuZFxuICogdGhlIGV2ZW50IGxvb3AuIEludm9rZWQgd2l0aCAoYXJncy4uLikuXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MuLi4gLSBhbnkgbnVtYmVyIG9mIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlXG4gKiBjYWxsYmFjayBvbiB0aGUgbmV4dCB0aWNrLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgY2FsbF9vcmRlciA9IFtdO1xuICogYXN5bmMubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gKiAgICAgY2FsbF9vcmRlci5wdXNoKCd0d28nKTtcbiAqICAgICAvLyBjYWxsX29yZGVyIG5vdyBlcXVhbHMgWydvbmUnLCd0d28nXVxuICogfSk7XG4gKiBjYWxsX29yZGVyLnB1c2goJ29uZScpO1xuICpcbiAqIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbiAoYSwgYiwgYykge1xuICogICAgIC8vIGEsIGIsIGFuZCBjIGVxdWFsIDEsIDIsIGFuZCAzXG4gKiB9LCAxLCAyLCAzKTtcbiAqL1xudmFyIF9kZWZlciQxO1xuXG5pZiAoaGFzTmV4dFRpY2spIHtcbiAgICBfZGVmZXIkMSA9IHByb2Nlc3MubmV4dFRpY2s7XG59IGVsc2UgaWYgKGhhc1NldEltbWVkaWF0ZSkge1xuICAgIF9kZWZlciQxID0gc2V0SW1tZWRpYXRlO1xufSBlbHNlIHtcbiAgICBfZGVmZXIkMSA9IGZhbGxiYWNrO1xufVxuXG52YXIgbmV4dFRpY2sgPSB3cmFwKF9kZWZlciQxKTtcblxuZnVuY3Rpb24gX3BhcmFsbGVsKGVhY2hmbiwgdGFza3MsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICAgIHZhciByZXN1bHRzID0gaXNBcnJheUxpa2UodGFza3MpID8gW10gOiB7fTtcblxuICAgIGVhY2hmbih0YXNrcywgZnVuY3Rpb24gKHRhc2ssIGtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgd3JhcEFzeW5jKHRhc2spKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBSdW4gdGhlIGB0YXNrc2AgY29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgaW4gcGFyYWxsZWwsIHdpdGhvdXQgd2FpdGluZyB1bnRpbFxuICogdGhlIHByZXZpb3VzIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQuIElmIGFueSBvZiB0aGUgZnVuY3Rpb25zIHBhc3MgYW4gZXJyb3IgdG9cbiAqIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlXG4gKiBlcnJvci4gT25jZSB0aGUgYHRhc2tzYCBoYXZlIGNvbXBsZXRlZCwgdGhlIHJlc3VsdHMgYXJlIHBhc3NlZCB0byB0aGUgZmluYWxcbiAqIGBjYWxsYmFja2AgYXMgYW4gYXJyYXkuXG4gKlxuICogKipOb3RlOioqIGBwYXJhbGxlbGAgaXMgYWJvdXQga2lja2luZy1vZmYgSS9PIHRhc2tzIGluIHBhcmFsbGVsLCBub3QgYWJvdXRcbiAqIHBhcmFsbGVsIGV4ZWN1dGlvbiBvZiBjb2RlLiAgSWYgeW91ciB0YXNrcyBkbyBub3QgdXNlIGFueSB0aW1lcnMgb3IgcGVyZm9ybVxuICogYW55IEkvTywgdGhleSB3aWxsIGFjdHVhbGx5IGJlIGV4ZWN1dGVkIGluIHNlcmllcy4gIEFueSBzeW5jaHJvbm91cyBzZXR1cFxuICogc2VjdGlvbnMgZm9yIGVhY2ggdGFzayB3aWxsIGhhcHBlbiBvbmUgYWZ0ZXIgdGhlIG90aGVyLiAgSmF2YVNjcmlwdCByZW1haW5zXG4gKiBzaW5nbGUtdGhyZWFkZWQuXG4gKlxuICogKipIaW50OioqIFVzZSBbYHJlZmxlY3RgXXtAbGluayBtb2R1bGU6VXRpbHMucmVmbGVjdH0gdG8gY29udGludWUgdGhlXG4gKiBleGVjdXRpb24gb2Ygb3RoZXIgdGFza3Mgd2hlbiBhIHRhc2sgZmFpbHMuXG4gKlxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byB1c2UgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIEVhY2ggcHJvcGVydHkgd2lsbFxuICogYmUgcnVuIGFzIGEgZnVuY3Rpb24gYW5kIHRoZSByZXN1bHRzIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBmaW5hbCBgY2FsbGJhY2tgXG4gKiBhcyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheS4gVGhpcyBjYW4gYmUgYSBtb3JlIHJlYWRhYmxlIHdheSBvZiBoYW5kbGluZ1xuICogcmVzdWx0cyBmcm9tIHtAbGluayBhc3luYy5wYXJhbGxlbH0uXG4gKlxuICogQG5hbWUgcGFyYWxsZWxcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSB0YXNrcyAtIEEgY29sbGVjdGlvbiBvZlxuICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuLlxuICogRWFjaCBhc3luYyBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBydW4gb25jZSBhbGwgdGhlXG4gKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5XG4gKiAob3Igb2JqZWN0KSBjb250YWluaW5nIGFsbCB0aGUgcmVzdWx0IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHRhc2sgY2FsbGJhY2tzLlxuICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBhc3luYy5wYXJhbGxlbChbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogXSxcbiAqIC8vIG9wdGlvbmFsIGNhbGxiYWNrXG4gKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAvLyB0aGUgcmVzdWx0cyBhcnJheSB3aWxsIGVxdWFsIFsnb25lJywndHdvJ10gZXZlbiB0aG91Z2hcbiAqICAgICAvLyB0aGUgc2Vjb25kIGZ1bmN0aW9uIGhhZCBhIHNob3J0ZXIgdGltZW91dC5cbiAqIH0pO1xuICpcbiAqIC8vIGFuIGV4YW1wbGUgdXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXlcbiAqIGFzeW5jLnBhcmFsbGVsKHtcbiAqICAgICBvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAxKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIHR3bzogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDIpO1xuICogICAgICAgICB9LCAxMDApO1xuICogICAgIH1cbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGVxdWFscyB0bzoge29uZTogMSwgdHdvOiAyfVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHBhcmFsbGVsTGltaXQodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgX3BhcmFsbGVsKGVhY2hPZiwgdGFza3MsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYHBhcmFsbGVsYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnBhcmFsbGVsfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgcGFyYWxsZWxMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMucGFyYWxsZWxde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5wYXJhbGxlbH1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSB0YXNrcyAtIEEgY29sbGVjdGlvbiBvZlxuICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuLlxuICogRWFjaCBhc3luYyBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBydW4gb25jZSBhbGwgdGhlXG4gKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5XG4gKiAob3Igb2JqZWN0KSBjb250YWluaW5nIGFsbCB0aGUgcmVzdWx0IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHRhc2sgY2FsbGJhY2tzLlxuICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICovXG5mdW5jdGlvbiBwYXJhbGxlbExpbWl0JDEodGFza3MsIGxpbWl0LCBjYWxsYmFjaykge1xuICAgIF9wYXJhbGxlbChfZWFjaE9mTGltaXQobGltaXQpLCB0YXNrcywgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIEEgcXVldWUgb2YgdGFza3MgZm9yIHRoZSB3b3JrZXIgZnVuY3Rpb24gdG8gY29tcGxldGUuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBRdWV1ZU9iamVjdFxuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbGVuZ3RoIC0gYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG51bWJlciBvZiBpdGVtc1xuICogd2FpdGluZyB0byBiZSBwcm9jZXNzZWQuIEludm9rZSB3aXRoIGBxdWV1ZS5sZW5ndGgoKWAuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHN0YXJ0ZWQgLSBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCBhbnlcbiAqIGl0ZW1zIGhhdmUgYmVlbiBwdXNoZWQgYW5kIHByb2Nlc3NlZCBieSB0aGUgcXVldWUuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBydW5uaW5nIC0gYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG51bWJlciBvZiBpdGVtc1xuICogY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC4gSW52b2tlIHdpdGggYHF1ZXVlLnJ1bm5pbmcoKWAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB3b3JrZXJzTGlzdCAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBhcnJheSBvZiBpdGVtc1xuICogY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC4gSW52b2tlIHdpdGggYHF1ZXVlLndvcmtlcnNMaXN0KClgLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaWRsZSAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGZhbHNlIGlmIHRoZXJlIGFyZSBpdGVtc1xuICogd2FpdGluZyBvciBiZWluZyBwcm9jZXNzZWQsIG9yIHRydWUgaWYgbm90LiBJbnZva2Ugd2l0aCBgcXVldWUuaWRsZSgpYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb25jdXJyZW5jeSAtIGFuIGludGVnZXIgZm9yIGRldGVybWluaW5nIGhvdyBtYW55IGB3b3JrZXJgXG4gKiBmdW5jdGlvbnMgc2hvdWxkIGJlIHJ1biBpbiBwYXJhbGxlbC4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgY2hhbmdlZCBhZnRlciBhXG4gKiBgcXVldWVgIGlzIGNyZWF0ZWQgdG8gYWx0ZXIgdGhlIGNvbmN1cnJlbmN5IG9uLXRoZS1mbHkuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBwdXNoIC0gYWRkIGEgbmV3IHRhc2sgdG8gdGhlIGBxdWV1ZWAuIENhbGxzIGBjYWxsYmFja2BcbiAqIG9uY2UgdGhlIGB3b3JrZXJgIGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nIHRoZSB0YXNrLiBJbnN0ZWFkIG9mIGEgc2luZ2xlIHRhc2ssXG4gKiBhIGB0YXNrc2AgYXJyYXkgY2FuIGJlIHN1Ym1pdHRlZC4gVGhlIHJlc3BlY3RpdmUgY2FsbGJhY2sgaXMgdXNlZCBmb3IgZXZlcnlcbiAqIHRhc2sgaW4gdGhlIGxpc3QuIEludm9rZSB3aXRoIGBxdWV1ZS5wdXNoKHRhc2ssIFtjYWxsYmFja10pYCxcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVuc2hpZnQgLSBhZGQgYSBuZXcgdGFzayB0byB0aGUgZnJvbnQgb2YgdGhlIGBxdWV1ZWAuXG4gKiBJbnZva2Ugd2l0aCBgcXVldWUudW5zaGlmdCh0YXNrLCBbY2FsbGJhY2tdKWAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSByZW1vdmUgLSByZW1vdmUgaXRlbXMgZnJvbSB0aGUgcXVldWUgdGhhdCBtYXRjaCBhIHRlc3RcbiAqIGZ1bmN0aW9uLiAgVGhlIHRlc3QgZnVuY3Rpb24gd2lsbCBiZSBwYXNzZWQgYW4gb2JqZWN0IHdpdGggYSBgZGF0YWAgcHJvcGVydHksXG4gKiBhbmQgYSBgcHJpb3JpdHlgIHByb3BlcnR5LCBpZiB0aGlzIGlzIGFcbiAqIFtwcmlvcml0eVF1ZXVlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucHJpb3JpdHlRdWV1ZX0gb2JqZWN0LlxuICogSW52b2tlZCB3aXRoIGBxdWV1ZS5yZW1vdmUodGVzdEZuKWAsIHdoZXJlIGB0ZXN0Rm5gIGlzIG9mIHRoZSBmb3JtXG4gKiBgZnVuY3Rpb24gKHtkYXRhLCBwcmlvcml0eX0pIHt9YCBhbmQgcmV0dXJucyBhIEJvb2xlYW4uXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBzYXR1cmF0ZWQgLSBhIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIG51bWJlciBvZlxuICogcnVubmluZyB3b3JrZXJzIGhpdHMgdGhlIGBjb25jdXJyZW5jeWAgbGltaXQsIGFuZCBmdXJ0aGVyIHRhc2tzIHdpbGwgYmVcbiAqIHF1ZXVlZC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVuc2F0dXJhdGVkIC0gYSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBudW1iZXJcbiAqIG9mIHJ1bm5pbmcgd29ya2VycyBpcyBsZXNzIHRoYW4gdGhlIGBjb25jdXJyZW5jeWAgJiBgYnVmZmVyYCBsaW1pdHMsIGFuZFxuICogZnVydGhlciB0YXNrcyB3aWxsIG5vdCBiZSBxdWV1ZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gYnVmZmVyIC0gQSBtaW5pbXVtIHRocmVzaG9sZCBidWZmZXIgaW4gb3JkZXIgdG8gc2F5IHRoYXRcbiAqIHRoZSBgcXVldWVgIGlzIGB1bnNhdHVyYXRlZGAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlbXB0eSAtIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbGFzdCBpdGVtXG4gKiBmcm9tIHRoZSBgcXVldWVgIGlzIGdpdmVuIHRvIGEgYHdvcmtlcmAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkcmFpbiAtIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbGFzdCBpdGVtXG4gKiBmcm9tIHRoZSBgcXVldWVgIGhhcyByZXR1cm5lZCBmcm9tIHRoZSBgd29ya2VyYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVycm9yIC0gYSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIGEgdGFzayBlcnJvcnMuXG4gKiBIYXMgdGhlIHNpZ25hdHVyZSBgZnVuY3Rpb24oZXJyb3IsIHRhc2spYC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcGF1c2VkIC0gYSBib29sZWFuIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBxdWV1ZSBpc1xuICogaW4gYSBwYXVzZWQgc3RhdGUuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBwYXVzZSAtIGEgZnVuY3Rpb24gdGhhdCBwYXVzZXMgdGhlIHByb2Nlc3Npbmcgb2YgdGFza3NcbiAqIHVudGlsIGByZXN1bWUoKWAgaXMgY2FsbGVkLiBJbnZva2Ugd2l0aCBgcXVldWUucGF1c2UoKWAuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSByZXN1bWUgLSBhIGZ1bmN0aW9uIHRoYXQgcmVzdW1lcyB0aGUgcHJvY2Vzc2luZyBvZlxuICogcXVldWVkIHRhc2tzIHdoZW4gdGhlIHF1ZXVlIGlzIHBhdXNlZC4gSW52b2tlIHdpdGggYHF1ZXVlLnJlc3VtZSgpYC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGtpbGwgLSBhIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgYGRyYWluYCBjYWxsYmFjayBhbmRcbiAqIGVtcHRpZXMgcmVtYWluaW5nIHRhc2tzIGZyb20gdGhlIHF1ZXVlIGZvcmNpbmcgaXQgdG8gZ28gaWRsZS4gTm8gbW9yZSB0YXNrc1xuICogc2hvdWxkIGJlIHB1c2hlZCB0byB0aGUgcXVldWUgYWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLiBJbnZva2Ugd2l0aCBgcXVldWUua2lsbCgpYC5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgcXVldWVgIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgYGNvbmN1cnJlbmN5YC4gVGFza3MgYWRkZWQgdG8gdGhlXG4gKiBgcXVldWVgIGFyZSBwcm9jZXNzZWQgaW4gcGFyYWxsZWwgKHVwIHRvIHRoZSBgY29uY3VycmVuY3lgIGxpbWl0KS4gSWYgYWxsXG4gKiBgd29ya2VyYHMgYXJlIGluIHByb2dyZXNzLCB0aGUgdGFzayBpcyBxdWV1ZWQgdW50aWwgb25lIGJlY29tZXMgYXZhaWxhYmxlLlxuICogT25jZSBhIGB3b3JrZXJgIGNvbXBsZXRlcyBhIGB0YXNrYCwgdGhhdCBgdGFza2AncyBjYWxsYmFjayBpcyBjYWxsZWQuXG4gKlxuICogQG5hbWUgcXVldWVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gd29ya2VyIC0gQW4gYXN5bmMgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZWQgdGFzay5cbiAqIElmIHlvdSB3YW50IHRvIGhhbmRsZSBlcnJvcnMgZnJvbSBhbiBpbmRpdmlkdWFsIHRhc2ssIHBhc3MgYSBjYWxsYmFjayB0b1xuICogYHEucHVzaCgpYC4gSW52b2tlZCB3aXRoICh0YXNrLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbmN5PTFdIC0gQW4gYGludGVnZXJgIGZvciBkZXRlcm1pbmluZyBob3cgbWFueVxuICogYHdvcmtlcmAgZnVuY3Rpb25zIHNob3VsZCBiZSBydW4gaW4gcGFyYWxsZWwuICBJZiBvbWl0dGVkLCB0aGUgY29uY3VycmVuY3lcbiAqIGRlZmF1bHRzIHRvIGAxYC4gIElmIHRoZSBjb25jdXJyZW5jeSBpcyBgMGAsIGFuIGVycm9yIGlzIHRocm93bi5cbiAqIEByZXR1cm5zIHttb2R1bGU6Q29udHJvbEZsb3cuUXVldWVPYmplY3R9IEEgcXVldWUgb2JqZWN0IHRvIG1hbmFnZSB0aGUgdGFza3MuIENhbGxiYWNrcyBjYW5cbiAqIGF0dGFjaGVkIGFzIGNlcnRhaW4gcHJvcGVydGllcyB0byBsaXN0ZW4gZm9yIHNwZWNpZmljIGV2ZW50cyBkdXJpbmcgdGhlXG4gKiBsaWZlY3ljbGUgb2YgdGhlIHF1ZXVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBjcmVhdGUgYSBxdWV1ZSBvYmplY3Qgd2l0aCBjb25jdXJyZW5jeSAyXG4gKiB2YXIgcSA9IGFzeW5jLnF1ZXVlKGZ1bmN0aW9uKHRhc2ssIGNhbGxiYWNrKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2hlbGxvICcgKyB0YXNrLm5hbWUpO1xuICogICAgIGNhbGxiYWNrKCk7XG4gKiB9LCAyKTtcbiAqXG4gKiAvLyBhc3NpZ24gYSBjYWxsYmFja1xuICogcS5kcmFpbiA9IGZ1bmN0aW9uKCkge1xuICogICAgIGNvbnNvbGUubG9nKCdhbGwgaXRlbXMgaGF2ZSBiZWVuIHByb2Nlc3NlZCcpO1xuICogfTtcbiAqXG4gKiAvLyBhZGQgc29tZSBpdGVtcyB0byB0aGUgcXVldWVcbiAqIHEucHVzaCh7bmFtZTogJ2Zvbyd9LCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBmb28nKTtcbiAqIH0pO1xuICogcS5wdXNoKHtuYW1lOiAnYmFyJ30sIGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBiYXInKTtcbiAqIH0pO1xuICpcbiAqIC8vIGFkZCBzb21lIGl0ZW1zIHRvIHRoZSBxdWV1ZSAoYmF0Y2gtd2lzZSlcbiAqIHEucHVzaChbe25hbWU6ICdiYXonfSx7bmFtZTogJ2JheSd9LHtuYW1lOiAnYmF4J31dLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBpdGVtJyk7XG4gKiB9KTtcbiAqXG4gKiAvLyBhZGQgc29tZSBpdGVtcyB0byB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlXG4gKiBxLnVuc2hpZnQoe25hbWU6ICdiYXInfSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpO1xuICogfSk7XG4gKi9cbnZhciBxdWV1ZSQxID0gZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHtcbiAgICB2YXIgX3dvcmtlciA9IHdyYXBBc3luYyh3b3JrZXIpO1xuICAgIHJldHVybiBxdWV1ZShmdW5jdGlvbiAoaXRlbXMsIGNiKSB7XG4gICAgICAgIF93b3JrZXIoaXRlbXNbMF0sIGNiKTtcbiAgICB9LCBjb25jdXJyZW5jeSwgMSk7XG59O1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFthc3luYy5xdWV1ZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnF1ZXVlfSBvbmx5IHRhc2tzIGFyZSBhc3NpZ25lZCBhIHByaW9yaXR5IGFuZFxuICogY29tcGxldGVkIGluIGFzY2VuZGluZyBwcmlvcml0eSBvcmRlci5cbiAqXG4gKiBAbmFtZSBwcmlvcml0eVF1ZXVlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5xdWV1ZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnF1ZXVlfVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB3b3JrZXIgLSBBbiBhc3luYyBmdW5jdGlvbiBmb3IgcHJvY2Vzc2luZyBhIHF1ZXVlZCB0YXNrLlxuICogSWYgeW91IHdhbnQgdG8gaGFuZGxlIGVycm9ycyBmcm9tIGFuIGluZGl2aWR1YWwgdGFzaywgcGFzcyBhIGNhbGxiYWNrIHRvXG4gKiBgcS5wdXNoKClgLlxuICogSW52b2tlZCB3aXRoICh0YXNrLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge251bWJlcn0gY29uY3VycmVuY3kgLSBBbiBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nIGhvdyBtYW55IGB3b3JrZXJgXG4gKiBmdW5jdGlvbnMgc2hvdWxkIGJlIHJ1biBpbiBwYXJhbGxlbC4gIElmIG9taXR0ZWQsIHRoZSBjb25jdXJyZW5jeSBkZWZhdWx0cyB0b1xuICogYDFgLiAgSWYgdGhlIGNvbmN1cnJlbmN5IGlzIGAwYCwgYW4gZXJyb3IgaXMgdGhyb3duLlxuICogQHJldHVybnMge21vZHVsZTpDb250cm9sRmxvdy5RdWV1ZU9iamVjdH0gQSBwcmlvcml0eVF1ZXVlIG9iamVjdCB0byBtYW5hZ2UgdGhlIHRhc2tzLiBUaGVyZSBhcmUgdHdvXG4gKiBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBxdWV1ZWAgYW5kIGBwcmlvcml0eVF1ZXVlYCBvYmplY3RzOlxuICogKiBgcHVzaCh0YXNrLCBwcmlvcml0eSwgW2NhbGxiYWNrXSlgIC0gYHByaW9yaXR5YCBzaG91bGQgYmUgYSBudW1iZXIuIElmIGFuXG4gKiAgIGFycmF5IG9mIGB0YXNrc2AgaXMgZ2l2ZW4sIGFsbCB0YXNrcyB3aWxsIGJlIGFzc2lnbmVkIHRoZSBzYW1lIHByaW9yaXR5LlxuICogKiBUaGUgYHVuc2hpZnRgIG1ldGhvZCB3YXMgcmVtb3ZlZC5cbiAqL1xudmFyIHByaW9yaXR5UXVldWUgPSBmdW5jdGlvbih3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG4gICAgLy8gU3RhcnQgd2l0aCBhIG5vcm1hbCBxdWV1ZVxuICAgIHZhciBxID0gcXVldWUkMSh3b3JrZXIsIGNvbmN1cnJlbmN5KTtcblxuICAgIC8vIE92ZXJyaWRlIHB1c2ggdG8gYWNjZXB0IHNlY29uZCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIHByaW9yaXR5XG4gICAgcS5wdXNoID0gZnVuY3Rpb24oZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsKSBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGFzayBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIWlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xuICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJpb3JpdHkgPSBwcmlvcml0eSB8fCAwO1xuICAgICAgICB2YXIgbmV4dE5vZGUgPSBxLl90YXNrcy5oZWFkO1xuICAgICAgICB3aGlsZSAobmV4dE5vZGUgJiYgcHJpb3JpdHkgPj0gbmV4dE5vZGUucHJpb3JpdHkpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gbmV4dE5vZGUubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFbaV0sXG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKG5leHROb2RlKSB7XG4gICAgICAgICAgICAgICAgcS5fdGFza3MuaW5zZXJ0QmVmb3JlKG5leHROb2RlLCBpdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcS5fdGFza3MucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRJbW1lZGlhdGUkMShxLnByb2Nlc3MpO1xuICAgIH07XG5cbiAgICAvLyBSZW1vdmUgdW5zaGlmdCBmdW5jdGlvblxuICAgIGRlbGV0ZSBxLnVuc2hpZnQ7XG5cbiAgICByZXR1cm4gcTtcbn07XG5cbi8qKlxuICogUnVucyB0aGUgYHRhc2tzYCBhcnJheSBvZiBmdW5jdGlvbnMgaW4gcGFyYWxsZWwsIHdpdGhvdXQgd2FpdGluZyB1bnRpbCB0aGVcbiAqIHByZXZpb3VzIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQuIE9uY2UgYW55IG9mIHRoZSBgdGFza3NgIGNvbXBsZXRlIG9yIHBhc3MgYW5cbiAqIGVycm9yIHRvIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQuIEl0J3NcbiAqIGVxdWl2YWxlbnQgdG8gYFByb21pc2UucmFjZSgpYC5cbiAqXG4gKiBAbmFtZSByYWNlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FycmF5fSB0YXNrcyAtIEFuIGFycmF5IGNvbnRhaW5pbmcgW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn1cbiAqIHRvIHJ1bi4gRWFjaCBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbiBvcHRpb25hbCBgcmVzdWx0YCB2YWx1ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQSBjYWxsYmFjayB0byBydW4gb25jZSBhbnkgb2YgdGhlIGZ1bmN0aW9ucyBoYXZlXG4gKiBjb21wbGV0ZWQuIFRoaXMgZnVuY3Rpb24gZ2V0cyBhbiBlcnJvciBvciByZXN1bHQgZnJvbSB0aGUgZmlyc3QgZnVuY3Rpb24gdGhhdFxuICogY29tcGxldGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEByZXR1cm5zIHVuZGVmaW5lZFxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy5yYWNlKFtcbiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICogICAgICAgICB9LCAyMDApO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAqICAgICAgICAgfSwgMTAwKTtcbiAqICAgICB9XG4gKiBdLFxuICogLy8gbWFpbiBjYWxsYmFja1xuICogZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyB0aGUgcmVzdWx0IHdpbGwgYmUgZXF1YWwgdG8gJ3R3bycgYXMgaXQgZmluaXNoZXMgZWFybGllclxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHJhY2UodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgIGlmICghaXNBcnJheSh0YXNrcykpIHJldHVybiBjYWxsYmFjayhuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCB0byByYWNlIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJykpO1xuICAgIGlmICghdGFza3MubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2soKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRhc2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB3cmFwQXN5bmModGFza3NbaV0pKGNhbGxiYWNrKTtcbiAgICB9XG59XG5cbi8qKlxuICogU2FtZSBhcyBbYHJlZHVjZWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWR1Y2V9LCBvbmx5IG9wZXJhdGVzIG9uIGBhcnJheWAgaW4gcmV2ZXJzZSBvcmRlci5cbiAqXG4gKiBAbmFtZSByZWR1Y2VSaWdodFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMucmVkdWNlXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVkdWNlfVxuICogQGFsaWFzIGZvbGRyXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHsqfSBtZW1vIC0gVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIHJlZHVjdGlvbi5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIGFwcGxpZWQgdG8gZWFjaCBpdGVtIGluIHRoZVxuICogYXJyYXkgdG8gcHJvZHVjZSB0aGUgbmV4dCBzdGVwIGluIHRoZSByZWR1Y3Rpb24uXG4gKiBUaGUgYGl0ZXJhdGVlYCBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgbmV4dCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLlxuICogSWYgdGhlIGl0ZXJhdGVlIGNvbXBsZXRlIHdpdGggYW4gZXJyb3IsIHRoZSByZWR1Y3Rpb24gaXMgc3RvcHBlZCBhbmQgdGhlXG4gKiBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLlxuICogSW52b2tlZCB3aXRoIChtZW1vLCBpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IGlzIHRoZSByZWR1Y2VkIHZhbHVlLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdCkuXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZVJpZ2h0IChhcnJheSwgbWVtbywgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJldmVyc2VkID0gc2xpY2UoYXJyYXkpLnJldmVyc2UoKTtcbiAgICByZWR1Y2UocmV2ZXJzZWQsIG1lbW8sIGl0ZXJhdGVlLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogV3JhcHMgdGhlIGFzeW5jIGZ1bmN0aW9uIGluIGFub3RoZXIgZnVuY3Rpb24gdGhhdCBhbHdheXMgY29tcGxldGVzIHdpdGggYVxuICogcmVzdWx0IG9iamVjdCwgZXZlbiB3aGVuIGl0IGVycm9ycy5cbiAqXG4gKiBUaGUgcmVzdWx0IG9iamVjdCBoYXMgZWl0aGVyIHRoZSBwcm9wZXJ0eSBgZXJyb3JgIG9yIGB2YWx1ZWAuXG4gKlxuICogQG5hbWUgcmVmbGVjdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpVdGlsc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSBUaGUgYXN5bmMgZnVuY3Rpb24geW91IHdhbnQgdG8gd3JhcFxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIEEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcGFzc2VzIG51bGwgdG8gaXQncyBjYWxsYmFjayBhc1xuICogdGhlIGVycm9yLiBUaGUgc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBjYWxsYmFjayB3aWxsIGJlIGFuIGBvYmplY3RgIHdpdGhcbiAqIGVpdGhlciBhbiBgZXJyb3JgIG9yIGEgYHZhbHVlYCBwcm9wZXJ0eS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMucGFyYWxsZWwoW1xuICogICAgIGFzeW5jLnJlZmxlY3QoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gZG8gc29tZSBzdHVmZiAuLi5cbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICogICAgIH0pLFxuICogICAgIGFzeW5jLnJlZmxlY3QoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gZG8gc29tZSBtb3JlIHN0dWZmIGJ1dCBlcnJvciAuLi5cbiAqICAgICAgICAgY2FsbGJhY2soJ2JhZCBzdHVmZiBoYXBwZW5lZCcpO1xuICogICAgIH0pLFxuICogICAgIGFzeW5jLnJlZmxlY3QoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gZG8gc29tZSBtb3JlIHN0dWZmIC4uLlxuICogICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gKiAgICAgfSlcbiAqIF0sXG4gKiAvLyBvcHRpb25hbCBjYWxsYmFja1xuICogZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgLy8gdmFsdWVzXG4gKiAgICAgLy8gcmVzdWx0c1swXS52YWx1ZSA9ICdvbmUnXG4gKiAgICAgLy8gcmVzdWx0c1sxXS5lcnJvciA9ICdiYWQgc3R1ZmYgaGFwcGVuZWQnXG4gKiAgICAgLy8gcmVzdWx0c1syXS52YWx1ZSA9ICd0d28nXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gcmVmbGVjdChmbikge1xuICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoZm4pO1xuICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIHJlZmxlY3RPbihhcmdzLCByZWZsZWN0Q2FsbGJhY2spIHtcbiAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uIGNhbGxiYWNrKGVycm9yLCBjYkFyZykge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVmbGVjdENhbGxiYWNrKG51bGwsIHsgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNiQXJnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVmbGVjdENhbGxiYWNrKG51bGwsIHsgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gX2ZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYW4gYXJyYXkgb3IgYW4gb2JqZWN0IG9mIGZ1bmN0aW9ucyB3aXRoIGByZWZsZWN0YC5cbiAqXG4gKiBAbmFtZSByZWZsZWN0QWxsXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5yZWZsZWN0XXtAbGluayBtb2R1bGU6VXRpbHMucmVmbGVjdH1cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxJdGVyYWJsZX0gdGFza3MgLSBUaGUgY29sbGVjdGlvbiBvZlxuICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gd3JhcCBpbiBgYXN5bmMucmVmbGVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgYXN5bmMgZnVuY3Rpb25zLCBlYWNoIHdyYXBwZWQgaW5cbiAqIGBhc3luYy5yZWZsZWN0YFxuICogQGV4YW1wbGVcbiAqXG4gKiBsZXQgdGFza3MgPSBbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGRvIHNvbWUgbW9yZSBzdHVmZiBidXQgZXJyb3IgLi4uXG4gKiAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignYmFkIHN0dWZmIGhhcHBlbmVkJykpO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTtcbiAqICAgICAgICAgfSwgMTAwKTtcbiAqICAgICB9XG4gKiBdO1xuICpcbiAqIGFzeW5jLnBhcmFsbGVsKGFzeW5jLnJlZmxlY3RBbGwodGFza3MpLFxuICogLy8gb3B0aW9uYWwgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHZhbHVlc1xuICogICAgIC8vIHJlc3VsdHNbMF0udmFsdWUgPSAnb25lJ1xuICogICAgIC8vIHJlc3VsdHNbMV0uZXJyb3IgPSBFcnJvcignYmFkIHN0dWZmIGhhcHBlbmVkJylcbiAqICAgICAvLyByZXN1bHRzWzJdLnZhbHVlID0gJ3R3bydcbiAqIH0pO1xuICpcbiAqIC8vIGFuIGV4YW1wbGUgdXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXlcbiAqIGxldCB0YXNrcyA9IHtcbiAqICAgICBvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7XG4gKiAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgfSxcbiAqICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKCd0d28nKTtcbiAqICAgICB9LFxuICogICAgIHRocmVlOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3RocmVlJyk7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogfTtcbiAqXG4gKiBhc3luYy5wYXJhbGxlbChhc3luYy5yZWZsZWN0QWxsKHRhc2tzKSxcbiAqIC8vIG9wdGlvbmFsIGNhbGxiYWNrXG4gKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAvLyB2YWx1ZXNcbiAqICAgICAvLyByZXN1bHRzLm9uZS52YWx1ZSA9ICdvbmUnXG4gKiAgICAgLy8gcmVzdWx0cy50d28uZXJyb3IgPSAndHdvJ1xuICogICAgIC8vIHJlc3VsdHMudGhyZWUudmFsdWUgPSAndGhyZWUnXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gcmVmbGVjdEFsbCh0YXNrcykge1xuICAgIHZhciByZXN1bHRzO1xuICAgIGlmIChpc0FycmF5KHRhc2tzKSkge1xuICAgICAgICByZXN1bHRzID0gYXJyYXlNYXAodGFza3MsIHJlZmxlY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgYmFzZUZvck93bih0YXNrcywgZnVuY3Rpb24odGFzaywga2V5KSB7XG4gICAgICAgICAgICByZXN1bHRzW2tleV0gPSByZWZsZWN0LmNhbGwodGhpcywgdGFzayk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gcmVqZWN0JDEoZWFjaGZuLCBhcnIsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIF9maWx0ZXIoZWFjaGZuLCBhcnIsIGZ1bmN0aW9uKHZhbHVlLCBjYikge1xuICAgICAgICBpdGVyYXRlZSh2YWx1ZSwgZnVuY3Rpb24oZXJyLCB2KSB7XG4gICAgICAgICAgICBjYihlcnIsICF2KTtcbiAgICAgICAgfSk7XG4gICAgfSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFRoZSBvcHBvc2l0ZSBvZiBbYGZpbHRlcmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9LiBSZW1vdmVzIHZhbHVlcyB0aGF0IHBhc3MgYW4gYGFzeW5jYCB0cnV0aCB0ZXN0LlxuICpcbiAqIEBuYW1lIHJlamVjdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZmlsdGVyXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYXMgaXRzIGByZXN1bHRgLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy5yZWplY3QoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZVBhdGgsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycilcbiAqICAgICB9KTtcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHJlc3VsdHMgbm93IGVxdWFscyBhbiBhcnJheSBvZiBtaXNzaW5nIGZpbGVzXG4gKiAgICAgY3JlYXRlRmlsZXMocmVzdWx0cyk7XG4gKiB9KTtcbiAqL1xudmFyIHJlamVjdCA9IGRvUGFyYWxsZWwocmVqZWN0JDEpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFtgcmVqZWN0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlamVjdH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhXG4gKiB0aW1lLlxuICpcbiAqIEBuYW1lIHJlamVjdExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5yZWplY3Rde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWplY3R9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgYHJlc3VsdGAuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKi9cbnZhciByZWplY3RMaW1pdCA9IGRvUGFyYWxsZWxMaW1pdChyZWplY3QkMSk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2ByZWplY3RgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVqZWN0fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgcmVqZWN0U2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5yZWplY3Rde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWplY3R9XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpblxuICogYGNvbGxgLlxuICogVGhlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgYHJlc3VsdGAuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKi9cbnZhciByZWplY3RTZXJpZXMgPSBkb0xpbWl0KHJlamVjdExpbWl0LCAxKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50JDEodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBnZXQgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIGZyb20gYHRhc2tgIG5vIG1vcmUgdGhhbiBgdGltZXNgIHRpbWVzXG4gKiBiZWZvcmUgcmV0dXJuaW5nIGFuIGVycm9yLiBJZiB0aGUgdGFzayBpcyBzdWNjZXNzZnVsLCB0aGUgYGNhbGxiYWNrYCB3aWxsIGJlXG4gKiBwYXNzZWQgdGhlIHJlc3VsdCBvZiB0aGUgc3VjY2Vzc2Z1bCB0YXNrLiBJZiBhbGwgYXR0ZW1wdHMgZmFpbCwgdGhlIGNhbGxiYWNrXG4gKiB3aWxsIGJlIHBhc3NlZCB0aGUgZXJyb3IgYW5kIHJlc3VsdCAoaWYgYW55KSBvZiB0aGUgZmluYWwgYXR0ZW1wdC5cbiAqXG4gKiBAbmFtZSByZXRyeVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHNlZSBbYXN5bmMucmV0cnlhYmxlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucmV0cnlhYmxlfVxuICogQHBhcmFtIHtPYmplY3R8bnVtYmVyfSBbb3B0cyA9IHt0aW1lczogNSwgaW50ZXJ2YWw6IDB9fCA1XSAtIENhbiBiZSBlaXRoZXIgYW5cbiAqIG9iamVjdCB3aXRoIGB0aW1lc2AgYW5kIGBpbnRlcnZhbGAgb3IgYSBudW1iZXIuXG4gKiAqIGB0aW1lc2AgLSBUaGUgbnVtYmVyIG9mIGF0dGVtcHRzIHRvIG1ha2UgYmVmb3JlIGdpdmluZyB1cC4gIFRoZSBkZWZhdWx0XG4gKiAgIGlzIGA1YC5cbiAqICogYGludGVydmFsYCAtIFRoZSB0aW1lIHRvIHdhaXQgYmV0d2VlbiByZXRyaWVzLCBpbiBtaWxsaXNlY29uZHMuICBUaGVcbiAqICAgZGVmYXVsdCBpcyBgMGAuIFRoZSBpbnRlcnZhbCBtYXkgYWxzbyBiZSBzcGVjaWZpZWQgYXMgYSBmdW5jdGlvbiBvZiB0aGVcbiAqICAgcmV0cnkgY291bnQgKHNlZSBleGFtcGxlKS5cbiAqICogYGVycm9yRmlsdGVyYCAtIEFuIG9wdGlvbmFsIHN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCBvblxuICogICBlcnJvbmVvdXMgcmVzdWx0LiBJZiBpdCByZXR1cm5zIGB0cnVlYCB0aGUgcmV0cnkgYXR0ZW1wdHMgd2lsbCBjb250aW51ZTtcbiAqICAgaWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCB0aGUgcmV0cnkgZmxvdyBpcyBhYm9ydGVkIHdpdGggdGhlIGN1cnJlbnRcbiAqICAgYXR0ZW1wdCdzIGVycm9yIGFuZCByZXN1bHQgYmVpbmcgcmV0dXJuZWQgdG8gdGhlIGZpbmFsIGNhbGxiYWNrLlxuICogICBJbnZva2VkIHdpdGggKGVycikuXG4gKiAqIElmIGBvcHRzYCBpcyBhIG51bWJlciwgdGhlIG51bWJlciBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiB0aW1lcyB0byByZXRyeSxcbiAqICAgd2l0aCB0aGUgZGVmYXVsdCBpbnRlcnZhbCBvZiBgMGAuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHRhc2sgLSBBbiBhc3luYyBmdW5jdGlvbiB0byByZXRyeS5cbiAqIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHRoZVxuICogdGFzayBoYXMgc3VjY2VlZGVkLCBvciBhZnRlciB0aGUgZmluYWwgZmFpbGVkIGF0dGVtcHQuIEl0IHJlY2VpdmVzIHRoZSBgZXJyYFxuICogYW5kIGByZXN1bHRgIGFyZ3VtZW50cyBvZiB0aGUgbGFzdCBhdHRlbXB0IGF0IGNvbXBsZXRpbmcgdGhlIGB0YXNrYC4gSW52b2tlZFxuICogd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFRoZSBgcmV0cnlgIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIGFzIGEgc3RhbmQtYWxvbmUgY29udHJvbCBmbG93IGJ5IHBhc3NpbmdcbiAqIC8vIGEgY2FsbGJhY2ssIGFzIHNob3duIGJlbG93OlxuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCAzIHRpbWVzXG4gKiBhc3luYy5yZXRyeSgzLCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIDMgdGltZXMsIHdhaXRpbmcgMjAwIG1zIGJldHdlZW4gZWFjaCByZXRyeVxuICogYXN5bmMucmV0cnkoe3RpbWVzOiAzLCBpbnRlcnZhbDogMjAwfSwgYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRcbiAqIH0pO1xuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCAxMCB0aW1lcyB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAqIC8vIChpLmUuIGludGVydmFscyBvZiAxMDAsIDIwMCwgNDAwLCA4MDAsIDE2MDAsIC4uLiBtaWxsaXNlY29uZHMpXG4gKiBhc3luYy5yZXRyeSh7XG4gKiAgIHRpbWVzOiAxMCxcbiAqICAgaW50ZXJ2YWw6IGZ1bmN0aW9uKHJldHJ5Q291bnQpIHtcbiAqICAgICByZXR1cm4gNTAgKiBNYXRoLnBvdygyLCByZXRyeUNvdW50KTtcbiAqICAgfVxuICogfSwgYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRcbiAqIH0pO1xuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCB0aGUgZGVmYXVsdCA1IHRpbWVzIG5vIGRlbGF5IGJldHdlZW4gZWFjaCByZXRyeVxuICogYXN5bmMucmV0cnkoYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRcbiAqIH0pO1xuICpcbiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCBvbmx5IHdoZW4gZXJyb3IgY29uZGl0aW9uIHNhdGlzZmllcywgYWxsIG90aGVyXG4gKiAvLyBlcnJvcnMgd2lsbCBhYm9ydCB0aGUgcmV0cnkgY29udHJvbCBmbG93IGFuZCByZXR1cm4gdG8gZmluYWwgY2FsbGJhY2tcbiAqIGFzeW5jLnJldHJ5KHtcbiAqICAgZXJyb3JGaWx0ZXI6IGZ1bmN0aW9uKGVycikge1xuICogICAgIHJldHVybiBlcnIubWVzc2FnZSA9PT0gJ1RlbXBvcmFyeSBlcnJvcic7IC8vIG9ubHkgcmV0cnkgb24gYSBzcGVjaWZpYyBlcnJvclxuICogICB9XG4gKiB9LCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdG8gcmV0cnkgaW5kaXZpZHVhbCBtZXRob2RzIHRoYXQgYXJlIG5vdCBhcyByZWxpYWJsZSB3aXRoaW4gb3RoZXJcbiAqIC8vIGNvbnRyb2wgZmxvdyBmdW5jdGlvbnMsIHVzZSB0aGUgYHJldHJ5YWJsZWAgd3JhcHBlcjpcbiAqIGFzeW5jLmF1dG8oe1xuICogICAgIHVzZXJzOiBhcGkuZ2V0VXNlcnMuYmluZChhcGkpLFxuICogICAgIHBheW1lbnRzOiBhc3luYy5yZXRyeWFibGUoMywgYXBpLmdldFBheW1lbnRzLmJpbmQoYXBpKSlcbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRzXG4gKiB9KTtcbiAqXG4gKi9cbmZ1bmN0aW9uIHJldHJ5KG9wdHMsIHRhc2ssIGNhbGxiYWNrKSB7XG4gICAgdmFyIERFRkFVTFRfVElNRVMgPSA1O1xuICAgIHZhciBERUZBVUxUX0lOVEVSVkFMID0gMDtcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICB0aW1lczogREVGQVVMVF9USU1FUyxcbiAgICAgICAgaW50ZXJ2YWxGdW5jOiBjb25zdGFudCQxKERFRkFVTFRfSU5URVJWQUwpXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlVGltZXMoYWNjLCB0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGFjYy50aW1lcyA9ICt0LnRpbWVzIHx8IERFRkFVTFRfVElNRVM7XG5cbiAgICAgICAgICAgIGFjYy5pbnRlcnZhbEZ1bmMgPSB0eXBlb2YgdC5pbnRlcnZhbCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgdC5pbnRlcnZhbCA6XG4gICAgICAgICAgICAgICAgY29uc3RhbnQkMSgrdC5pbnRlcnZhbCB8fCBERUZBVUxUX0lOVEVSVkFMKTtcblxuICAgICAgICAgICAgYWNjLmVycm9yRmlsdGVyID0gdC5lcnJvckZpbHRlcjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBhY2MudGltZXMgPSArdCB8fCBERUZBVUxUX1RJTUVTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgZm9yIGFzeW5jLnJldHJ5XCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzICYmIHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdGFzayB8fCBub29wO1xuICAgICAgICB0YXNrID0gb3B0cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZVRpbWVzKG9wdGlvbnMsIG9wdHMpO1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0YXNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRzIGZvciBhc3luYy5yZXRyeVwiKTtcbiAgICB9XG5cbiAgICB2YXIgX3Rhc2sgPSB3cmFwQXN5bmModGFzayk7XG5cbiAgICB2YXIgYXR0ZW1wdCA9IDE7XG4gICAgZnVuY3Rpb24gcmV0cnlBdHRlbXB0KCkge1xuICAgICAgICBfdGFzayhmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgJiYgYXR0ZW1wdCsrIDwgb3B0aW9ucy50aW1lcyAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2Ygb3B0aW9ucy5lcnJvckZpbHRlciAhPSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3JGaWx0ZXIoZXJyKSkpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJldHJ5QXR0ZW1wdCwgb3B0aW9ucy5pbnRlcnZhbEZ1bmMoYXR0ZW1wdCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXRyeUF0dGVtcHQoKTtcbn1cblxuLyoqXG4gKiBBIGNsb3NlIHJlbGF0aXZlIG9mIFtgcmV0cnlgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucmV0cnl9LiAgVGhpcyBtZXRob2RcbiAqIHdyYXBzIGEgdGFzayBhbmQgbWFrZXMgaXQgcmV0cnlhYmxlLCByYXRoZXIgdGhhbiBpbW1lZGlhdGVseSBjYWxsaW5nIGl0XG4gKiB3aXRoIHJldHJpZXMuXG4gKlxuICogQG5hbWUgcmV0cnlhYmxlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5yZXRyeV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnJldHJ5fVxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtPYmplY3R8bnVtYmVyfSBbb3B0cyA9IHt0aW1lczogNSwgaW50ZXJ2YWw6IDB9fCA1XSAtIG9wdGlvbmFsXG4gKiBvcHRpb25zLCBleGFjdGx5IHRoZSBzYW1lIGFzIGZyb20gYHJldHJ5YFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB0YXNrIC0gdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0byB3cmFwLlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgcmV0dXJuZWQgd3JhcHBlci5cbiAqIEludm9rZWQgd2l0aCAoLi4uYXJncywgY2FsbGJhY2spLlxuICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFRoZSB3cmFwcGVkIGZ1bmN0aW9uLCB3aGljaCB3aGVuIGludm9rZWQsIHdpbGxcbiAqIHJldHJ5IG9uIGFuIGVycm9yLCBiYXNlZCBvbiB0aGUgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gYG9wdHNgLlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGFjY2VwdCB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIGB0YXNrYC5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuYXV0byh7XG4gKiAgICAgZGVwMTogYXN5bmMucmV0cnlhYmxlKDMsIGdldEZyb21GbGFreVNlcnZpY2UpLFxuICogICAgIHByb2Nlc3M6IFtcImRlcDFcIiwgYXN5bmMucmV0cnlhYmxlKDMsIGZ1bmN0aW9uIChyZXN1bHRzLCBjYikge1xuICogICAgICAgICBtYXliZVByb2Nlc3NEYXRhKHJlc3VsdHMuZGVwMSwgY2IpO1xuICogICAgIH0pXVxuICogfSwgY2FsbGJhY2spO1xuICovXG52YXIgcmV0cnlhYmxlID0gZnVuY3Rpb24gKG9wdHMsIHRhc2spIHtcbiAgICBpZiAoIXRhc2spIHtcbiAgICAgICAgdGFzayA9IG9wdHM7XG4gICAgICAgIG9wdHMgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgX3Rhc2sgPSB3cmFwQXN5bmModGFzayk7XG4gICAgcmV0dXJuIGluaXRpYWxQYXJhbXMoZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGZ1bmN0aW9uIHRhc2tGbihjYikge1xuICAgICAgICAgICAgX3Rhc2suYXBwbHkobnVsbCwgYXJncy5jb25jYXQoY2IpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzKSByZXRyeShvcHRzLCB0YXNrRm4sIGNhbGxiYWNrKTtcbiAgICAgICAgZWxzZSByZXRyeSh0YXNrRm4sIGNhbGxiYWNrKTtcblxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSdW4gdGhlIGZ1bmN0aW9ucyBpbiB0aGUgYHRhc2tzYCBjb2xsZWN0aW9uIGluIHNlcmllcywgZWFjaCBvbmUgcnVubmluZyBvbmNlXG4gKiB0aGUgcHJldmlvdXMgZnVuY3Rpb24gaGFzIGNvbXBsZXRlZC4gSWYgYW55IGZ1bmN0aW9ucyBpbiB0aGUgc2VyaWVzIHBhc3MgYW5cbiAqIGVycm9yIHRvIGl0cyBjYWxsYmFjaywgbm8gbW9yZSBmdW5jdGlvbnMgYXJlIHJ1biwgYW5kIGBjYWxsYmFja2AgaXNcbiAqIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSB2YWx1ZSBvZiB0aGUgZXJyb3IuIE90aGVyd2lzZSwgYGNhbGxiYWNrYFxuICogcmVjZWl2ZXMgYW4gYXJyYXkgb2YgcmVzdWx0cyB3aGVuIGB0YXNrc2AgaGF2ZSBjb21wbGV0ZWQuXG4gKlxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byB1c2UgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIEVhY2ggcHJvcGVydHkgd2lsbFxuICogYmUgcnVuIGFzIGEgZnVuY3Rpb24sIGFuZCB0aGUgcmVzdWx0cyB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZmluYWwgYGNhbGxiYWNrYFxuICogYXMgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIFRoaXMgY2FuIGJlIGEgbW9yZSByZWFkYWJsZSB3YXkgb2YgaGFuZGxpbmdcbiAqICByZXN1bHRzIGZyb20ge0BsaW5rIGFzeW5jLnNlcmllc30uXG4gKlxuICogKipOb3RlKiogdGhhdCB3aGlsZSBtYW55IGltcGxlbWVudGF0aW9ucyBwcmVzZXJ2ZSB0aGUgb3JkZXIgb2Ygb2JqZWN0XG4gKiBwcm9wZXJ0aWVzLCB0aGUgW0VDTUFTY3JpcHQgTGFuZ3VhZ2UgU3BlY2lmaWNhdGlvbl0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTguNilcbiAqIGV4cGxpY2l0bHkgc3RhdGVzIHRoYXRcbiAqXG4gKiA+IFRoZSBtZWNoYW5pY3MgYW5kIG9yZGVyIG9mIGVudW1lcmF0aW5nIHRoZSBwcm9wZXJ0aWVzIGlzIG5vdCBzcGVjaWZpZWQuXG4gKlxuICogU28gaWYgeW91IHJlbHkgb24gdGhlIG9yZGVyIGluIHdoaWNoIHlvdXIgc2VyaWVzIG9mIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWQsXG4gKiBhbmQgd2FudCB0aGlzIHRvIHdvcmsgb24gYWxsIHBsYXRmb3JtcywgY29uc2lkZXIgdXNpbmcgYW4gYXJyYXkuXG4gKlxuICogQG5hbWUgc2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gdGFza3MgLSBBIGNvbGxlY3Rpb24gY29udGFpbmluZ1xuICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuIGluIHNlcmllcy5cbiAqIEVhY2ggZnVuY3Rpb24gY2FuIGNvbXBsZXRlIHdpdGggYW55IG51bWJlciBvZiBvcHRpb25hbCBgcmVzdWx0YCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZVxuICogZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkLiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5IChvciBvYmplY3QpXG4gKiBjb250YWluaW5nIGFsbCB0aGUgcmVzdWx0IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGB0YXNrYCBjYWxsYmFja3MuIEludm9rZWRcbiAqIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEBleGFtcGxlXG4gKiBhc3luYy5zZXJpZXMoW1xuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGRvIHNvbWUgc3R1ZmYgLi4uXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGRvIHNvbWUgbW9yZSBzdHVmZiAuLi5cbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpO1xuICogICAgIH1cbiAqIF0sXG4gKiAvLyBvcHRpb25hbCBjYWxsYmFja1xuICogZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBub3cgZXF1YWwgdG8gWydvbmUnLCAndHdvJ11cbiAqIH0pO1xuICpcbiAqIGFzeW5jLnNlcmllcyh7XG4gKiAgICAgb25lOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMSk7XG4gKiAgICAgICAgIH0sIDIwMCk7XG4gKiAgICAgfSxcbiAqICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKXtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDIpO1xuICogICAgICAgICB9LCAxMDApO1xuICogICAgIH1cbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGVxdWFsIHRvOiB7b25lOiAxLCB0d286IDJ9XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gc2VyaWVzKHRhc2tzLCBjYWxsYmFjaykge1xuICAgIF9wYXJhbGxlbChlYWNoT2ZTZXJpZXMsIHRhc2tzLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIGBjb2xsYCBzYXRpc2ZpZXMgYW4gYXN5bmMgdGVzdC5cbiAqIElmIGFueSBpdGVyYXRlZSBjYWxsIHJldHVybnMgYHRydWVgLCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5XG4gKiBjYWxsZWQuXG4gKlxuICogQG5hbWUgc29tZVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGFsaWFzIGFueVxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbVxuICogaW4gdGhlIGNvbGxlY3Rpb25zIGluIHBhcmFsbGVsLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiBgcmVzdWx0YCB2YWx1ZS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC5cbiAqIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmNcbiAqIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuc29tZShbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmdW5jdGlvbihmaWxlUGF0aCwgY2FsbGJhY2spIHtcbiAqICAgICBmcy5hY2Nlc3MoZmlsZVBhdGgsIGZ1bmN0aW9uKGVycikge1xuICogICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKVxuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyBpZiByZXN1bHQgaXMgdHJ1ZSB0aGVuIGF0IGxlYXN0IG9uZSBvZiB0aGUgZmlsZXMgZXhpc3RzXG4gKiB9KTtcbiAqL1xudmFyIHNvbWUgPSBkb1BhcmFsbGVsKF9jcmVhdGVUZXN0ZXIoQm9vbGVhbiwgaWRlbnRpdHkpKTtcblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYHNvbWVgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgc29tZUxpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5zb21lXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX1cbiAqIEBhbGlhcyBhbnlMaW1pdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbVxuICogaW4gdGhlIGNvbGxlY3Rpb25zIGluIHBhcmFsbGVsLlxuICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiBgcmVzdWx0YCB2YWx1ZS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55XG4gKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC5cbiAqIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmNcbiAqIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS5cbiAqL1xudmFyIHNvbWVMaW1pdCA9IGRvUGFyYWxsZWxMaW1pdChfY3JlYXRlVGVzdGVyKEJvb2xlYW4sIGlkZW50aXR5KSk7XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2Bzb21lYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnNvbWV9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBzb21lU2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5zb21lXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX1cbiAqIEBhbGlhcyBhbnlTZXJpZXNcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW1cbiAqIGluIHRoZSBjb2xsZWN0aW9ucyBpbiBzZXJpZXMuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIGByZXN1bHRgIHZhbHVlLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnlcbiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLlxuICogUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIHRoZSBhc3luY1xuICogdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICovXG52YXIgc29tZVNlcmllcyA9IGRvTGltaXQoc29tZUxpbWl0LCAxKTtcblxuLyoqXG4gKiBTb3J0cyBhIGxpc3QgYnkgdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGBjb2xsYCB2YWx1ZSB0aHJvdWdoIGFuIGFzeW5jXG4gKiBgaXRlcmF0ZWVgLlxuICpcbiAqIEBuYW1lIHNvcnRCeVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIHZhbHVlIHRvIHVzZSBhcyB0aGUgc29ydCBjcml0ZXJpYSBhc1xuICogaXRzIGByZXN1bHRgLlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGVcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyB0aGUgaXRlbXNcbiAqIGZyb20gdGhlIG9yaWdpbmFsIGBjb2xsYCBzb3J0ZWQgYnkgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgYGl0ZXJhdGVlYFxuICogY2FsbHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMuc29ydEJ5KFsnZmlsZTEnLCdmaWxlMicsJ2ZpbGUzJ10sIGZ1bmN0aW9uKGZpbGUsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMuc3RhdChmaWxlLCBmdW5jdGlvbihlcnIsIHN0YXRzKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKGVyciwgc3RhdHMubXRpbWUpO1xuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBub3cgdGhlIG9yaWdpbmFsIGFycmF5IG9mIGZpbGVzIHNvcnRlZCBieVxuICogICAgIC8vIG1vZGlmaWVkIGRhdGVcbiAqIH0pO1xuICpcbiAqIC8vIEJ5IG1vZGlmeWluZyB0aGUgY2FsbGJhY2sgcGFyYW1ldGVyIHRoZVxuICogLy8gc29ydGluZyBvcmRlciBjYW4gYmUgaW5mbHVlbmNlZDpcbiAqXG4gKiAvLyBhc2NlbmRpbmcgb3JkZXJcbiAqIGFzeW5jLnNvcnRCeShbMSw5LDMsNV0sIGZ1bmN0aW9uKHgsIGNhbGxiYWNrKSB7XG4gKiAgICAgY2FsbGJhY2sobnVsbCwgeCk7XG4gKiB9LCBmdW5jdGlvbihlcnIscmVzdWx0KSB7XG4gKiAgICAgLy8gcmVzdWx0IGNhbGxiYWNrXG4gKiB9KTtcbiAqXG4gKiAvLyBkZXNjZW5kaW5nIG9yZGVyXG4gKiBhc3luYy5zb3J0QnkoWzEsOSwzLDVdLCBmdW5jdGlvbih4LCBjYWxsYmFjaykge1xuICogICAgIGNhbGxiYWNrKG51bGwsIHgqLTEpOyAgICAvLzwtIHgqLTEgaW5zdGVhZCBvZiB4LCB0dXJucyB0aGUgb3JkZXIgYXJvdW5kXG4gKiB9LCBmdW5jdGlvbihlcnIscmVzdWx0KSB7XG4gKiAgICAgLy8gcmVzdWx0IGNhbGxiYWNrXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gc29ydEJ5IChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTtcbiAgICBtYXAoY29sbCwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9pdGVyYXRlZSh4LCBmdW5jdGlvbiAoZXJyLCBjcml0ZXJpYSkge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7dmFsdWU6IHgsIGNyaXRlcmlhOiBjcml0ZXJpYX0pO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCBhcnJheU1hcChyZXN1bHRzLnNvcnQoY29tcGFyYXRvciksIGJhc2VQcm9wZXJ0eSgndmFsdWUnKSkpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY29tcGFyYXRvcihsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWEsIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTZXRzIGEgdGltZSBsaW1pdCBvbiBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBkb2VzIG5vdCBjYWxsXG4gKiBpdHMgY2FsbGJhY2sgd2l0aGluIHRoZSBzcGVjaWZpZWQgbWlsbGlzZWNvbmRzLCBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFcbiAqIHRpbWVvdXQgZXJyb3IuIFRoZSBjb2RlIHByb3BlcnR5IGZvciB0aGUgZXJyb3Igb2JqZWN0IHdpbGwgYmUgYCdFVElNRURPVVQnYC5cbiAqXG4gKiBAbmFtZSB0aW1lb3V0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBhc3luY0ZuIC0gVGhlIGFzeW5jIGZ1bmN0aW9uIHRvIGxpbWl0IGluIHRpbWUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWlsbGlzZWNvbmRzIC0gVGhlIHNwZWNpZmllZCB0aW1lIGxpbWl0LlxuICogQHBhcmFtIHsqfSBbaW5mb10gLSBBbnkgdmFyaWFibGUgeW91IHdhbnQgYXR0YWNoZWQgKGBzdHJpbmdgLCBgb2JqZWN0YCwgZXRjKVxuICogdG8gdGltZW91dCBFcnJvciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4uXG4gKiBAcmV0dXJucyB7QXN5bmNGdW5jdGlvbn0gUmV0dXJucyBhIHdyYXBwZWQgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB3aXRoIGFueVxuICogb2YgdGhlIGNvbnRyb2wgZmxvdyBmdW5jdGlvbnMuXG4gKiBJbnZva2UgdGhpcyBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMgYXMgeW91IHdvdWxkIGBhc3luY0Z1bmNgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBteUZ1bmN0aW9uKGZvbywgY2FsbGJhY2spIHtcbiAqICAgICBkb0FzeW5jVGFzayhmb28sIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICogICAgICAgICAvLyBoYW5kbGUgZXJyb3JzXG4gKiAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICpcbiAqICAgICAgICAgLy8gZG8gc29tZSBzdHVmZiAuLi5cbiAqXG4gKiAgICAgICAgIC8vIHJldHVybiBwcm9jZXNzZWQgZGF0YVxuICogICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKlxuICogdmFyIHdyYXBwZWQgPSBhc3luYy50aW1lb3V0KG15RnVuY3Rpb24sIDEwMDApO1xuICpcbiAqIC8vIGNhbGwgYHdyYXBwZWRgIGFzIHlvdSB3b3VsZCBgbXlGdW5jdGlvbmBcbiAqIHdyYXBwZWQoeyBiYXI6ICdiYXInIH0sIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICogICAgIC8vIGlmIGBteUZ1bmN0aW9uYCB0YWtlcyA8IDEwMDAgbXMgdG8gZXhlY3V0ZSwgYGVycmBcbiAqICAgICAvLyBhbmQgYGRhdGFgIHdpbGwgaGF2ZSB0aGVpciBleHBlY3RlZCB2YWx1ZXNcbiAqXG4gKiAgICAgLy8gZWxzZSBgZXJyYCB3aWxsIGJlIGFuIEVycm9yIHdpdGggdGhlIGNvZGUgJ0VUSU1FRE9VVCdcbiAqIH0pO1xuICovXG5mdW5jdGlvbiB0aW1lb3V0KGFzeW5jRm4sIG1pbGxpc2Vjb25kcywgaW5mbykge1xuICAgIHZhciBmbiA9IHdyYXBBc3luYyhhc3luY0ZuKTtcblxuICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgdGltZWRPdXQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRpbWVyO1xuXG4gICAgICAgIGZ1bmN0aW9uIHRpbWVvdXRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gYXN5bmNGbi5uYW1lIHx8ICdhbm9ueW1vdXMnO1xuICAgICAgICAgICAgdmFyIGVycm9yICA9IG5ldyBFcnJvcignQ2FsbGJhY2sgZnVuY3Rpb24gXCInICsgbmFtZSArICdcIiB0aW1lZCBvdXQuJyk7XG4gICAgICAgICAgICBlcnJvci5jb2RlID0gJ0VUSU1FRE9VVCc7XG4gICAgICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgICAgIGVycm9yLmluZm8gPSBpbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZWRPdXQgPSB0cnVlO1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGltZWRPdXQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNldHVwIHRpbWVyIGFuZCBjYWxsIG9yaWdpbmFsIGZ1bmN0aW9uXG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCh0aW1lb3V0Q2FsbGJhY2ssIG1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xufVxuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbDtcbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5nZWAgYW5kIGBfLnJhbmdlUmlnaHRgIHdoaWNoIGRvZXNuJ3RcbiAqIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBuYXRpdmVNYXgobmF0aXZlQ2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XG4gICAgc3RhcnQgKz0gc3RlcDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFt0aW1lc117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnRpbWVzfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgdGltZXNMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMudGltZXNde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy50aW1lc31cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gY2FsbCBgbmAgdGltZXMuXG4gKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBzZWUgW2FzeW5jLm1hcF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0uXG4gKi9cbmZ1bmN0aW9uIHRpbWVMaW1pdChjb3VudCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpO1xuICAgIG1hcExpbWl0KGJhc2VSYW5nZSgwLCBjb3VudCwgMSksIGxpbWl0LCBfaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBDYWxscyB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbiBgbmAgdGltZXMsIGFuZCBhY2N1bXVsYXRlcyByZXN1bHRzIGluIHRoZSBzYW1lXG4gKiBtYW5uZXIgeW91IHdvdWxkIHVzZSB3aXRoIFttYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LlxuICpcbiAqIEBuYW1lIHRpbWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5tYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gY2FsbCBgbmAgdGltZXMuXG4gKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBzZWUge0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBQcmV0ZW5kIHRoaXMgaXMgc29tZSBjb21wbGljYXRlZCBhc3luYyBmYWN0b3J5XG4gKiB2YXIgY3JlYXRlVXNlciA9IGZ1bmN0aW9uKGlkLCBjYWxsYmFjaykge1xuICogICAgIGNhbGxiYWNrKG51bGwsIHtcbiAqICAgICAgICAgaWQ6ICd1c2VyJyArIGlkXG4gKiAgICAgfSk7XG4gKiB9O1xuICpcbiAqIC8vIGdlbmVyYXRlIDUgdXNlcnNcbiAqIGFzeW5jLnRpbWVzKDUsIGZ1bmN0aW9uKG4sIG5leHQpIHtcbiAqICAgICBjcmVhdGVVc2VyKG4sIGZ1bmN0aW9uKGVyciwgdXNlcikge1xuICogICAgICAgICBuZXh0KGVyciwgdXNlcik7XG4gKiAgICAgfSk7XG4gKiB9LCBmdW5jdGlvbihlcnIsIHVzZXJzKSB7XG4gKiAgICAgLy8gd2Ugc2hvdWxkIG5vdyBoYXZlIDUgdXNlcnNcbiAqIH0pO1xuICovXG52YXIgdGltZXMgPSBkb0xpbWl0KHRpbWVMaW1pdCwgSW5maW5pdHkpO1xuXG4vKipcbiAqIFRoZSBzYW1lIGFzIFt0aW1lc117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnRpbWVzfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgdGltZXNTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLnRpbWVzXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cudGltZXN9XG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gY2FsbCBgbmAgdGltZXMuXG4gKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBzZWUge0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LlxuICovXG52YXIgdGltZXNTZXJpZXMgPSBkb0xpbWl0KHRpbWVMaW1pdCwgMSk7XG5cbi8qKlxuICogQSByZWxhdGl2ZSBvZiBgcmVkdWNlYC4gIFRha2VzIGFuIE9iamVjdCBvciBBcnJheSwgYW5kIGl0ZXJhdGVzIG92ZXIgZWFjaFxuICogZWxlbWVudCBpbiBzZXJpZXMsIGVhY2ggc3RlcCBwb3RlbnRpYWxseSBtdXRhdGluZyBhbiBgYWNjdW11bGF0b3JgIHZhbHVlLlxuICogVGhlIHR5cGUgb2YgdGhlIGFjY3VtdWxhdG9yIGRlZmF1bHRzIHRvIHRoZSB0eXBlIG9mIGNvbGxlY3Rpb24gcGFzc2VkIGluLlxuICpcbiAqIEBuYW1lIHRyYW5zZm9ybVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSAtIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSB0cmFuc2Zvcm0uICBJZiBvbWl0dGVkLFxuICogaXQgd2lsbCBkZWZhdWx0IHRvIGFuIGVtcHR5IE9iamVjdCBvciBBcnJheSwgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIGBjb2xsYFxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gYXBwbGllZCB0byBlYWNoIGl0ZW0gaW4gdGhlXG4gKiBjb2xsZWN0aW9uIHRoYXQgcG90ZW50aWFsbHkgbW9kaWZpZXMgdGhlIGFjY3VtdWxhdG9yLlxuICogSW52b2tlZCB3aXRoIChhY2N1bXVsYXRvciwgaXRlbSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZVxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IGlzIHRoZSB0cmFuc2Zvcm1lZCBhY2N1bXVsYXRvci5cbiAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLlxuICogQGV4YW1wbGVcbiAqXG4gKiBhc3luYy50cmFuc2Zvcm0oWzEsMiwzXSwgZnVuY3Rpb24oYWNjLCBpdGVtLCBpbmRleCwgY2FsbGJhY2spIHtcbiAqICAgICAvLyBwb2ludGxlc3MgYXN5bmM6XG4gKiAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAqICAgICAgICAgYWNjLnB1c2goaXRlbSAqIDIpXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwpXG4gKiAgICAgfSk7XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICogICAgIC8vIHJlc3VsdCBpcyBub3cgZXF1YWwgdG8gWzIsIDQsIDZdXG4gKiB9KTtcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLnRyYW5zZm9ybSh7YTogMSwgYjogMiwgYzogM30sIGZ1bmN0aW9uIChvYmosIHZhbCwga2V5LCBjYWxsYmFjaykge1xuICogICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIG9ialtrZXldID0gdmFsICogMjtcbiAqICAgICAgICAgY2FsbGJhY2soKTtcbiAqICAgICB9KVxuICogfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gcmVzdWx0IGlzIGVxdWFsIHRvIHthOiAyLCBiOiA0LCBjOiA2fVxuICogfSlcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtIChjb2xsLCBhY2N1bXVsYXRvciwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMykge1xuICAgICAgICBjYWxsYmFjayA9IGl0ZXJhdGVlO1xuICAgICAgICBpdGVyYXRlZSA9IGFjY3VtdWxhdG9yO1xuICAgICAgICBhY2N1bXVsYXRvciA9IGlzQXJyYXkoY29sbCkgPyBbXSA6IHt9O1xuICAgIH1cbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7XG5cbiAgICBlYWNoT2YoY29sbCwgZnVuY3Rpb24odiwgaywgY2IpIHtcbiAgICAgICAgX2l0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2LCBrLCBjYik7XG4gICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgYWNjdW11bGF0b3IpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEl0IHJ1bnMgZWFjaCB0YXNrIGluIHNlcmllcyBidXQgc3RvcHMgd2hlbmV2ZXIgYW55IG9mIHRoZSBmdW5jdGlvbnMgd2VyZVxuICogc3VjY2Vzc2Z1bC4gSWYgb25lIG9mIHRoZSB0YXNrcyB3ZXJlIHN1Y2Nlc3NmdWwsIHRoZSBgY2FsbGJhY2tgIHdpbGwgYmVcbiAqIHBhc3NlZCB0aGUgcmVzdWx0IG9mIHRoZSBzdWNjZXNzZnVsIHRhc2suIElmIGFsbCB0YXNrcyBmYWlsLCB0aGUgY2FsbGJhY2tcbiAqIHdpbGwgYmUgcGFzc2VkIHRoZSBlcnJvciBhbmQgcmVzdWx0IChpZiBhbnkpIG9mIHRoZSBmaW5hbCBhdHRlbXB0LlxuICpcbiAqIEBuYW1lIHRyeUVhY2hcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSB0YXNrcyAtIEEgY29sbGVjdGlvbiBjb250YWluaW5nIGZ1bmN0aW9ucyB0b1xuICogcnVuLCBlYWNoIGZ1bmN0aW9uIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHJlc3VsdClgIGl0IG11c3QgY2FsbCBvblxuICogY29tcGxldGlvbiB3aXRoIGFuIGVycm9yIGBlcnJgICh3aGljaCBjYW4gYmUgYG51bGxgKSBhbmQgYW4gb3B0aW9uYWwgYHJlc3VsdGBcbiAqIHZhbHVlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIG9uZVxuICogb2YgdGhlIHRhc2tzIGhhcyBzdWNjZWVkZWQsIG9yIGFsbCBoYXZlIGZhaWxlZC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgIGFuZFxuICogYHJlc3VsdGAgYXJndW1lbnRzIG9mIHRoZSBsYXN0IGF0dGVtcHQgYXQgY29tcGxldGluZyB0aGUgYHRhc2tgLiBJbnZva2VkIHdpdGhcbiAqIChlcnIsIHJlc3VsdHMpLlxuICogQGV4YW1wbGVcbiAqIGFzeW5jLnRyeUVhY2goW1xuICogICAgIGZ1bmN0aW9uIGdldERhdGFGcm9tRmlyc3RXZWJzaXRlKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIFRyeSBnZXR0aW5nIHRoZSBkYXRhIGZyb20gdGhlIGZpcnN0IHdlYnNpdGVcbiAqICAgICAgICAgY2FsbGJhY2soZXJyLCBkYXRhKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uIGdldERhdGFGcm9tU2Vjb25kV2Vic2l0ZShjYWxsYmFjaykge1xuICogICAgICAgICAvLyBGaXJzdCB3ZWJzaXRlIGZhaWxlZCxcbiAqICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIGRhdGEgZnJvbSB0aGUgYmFja3VwIHdlYnNpdGVcbiAqICAgICAgICAgY2FsbGJhY2soZXJyLCBkYXRhKTtcbiAqICAgICB9XG4gKiBdLFxuICogLy8gb3B0aW9uYWwgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIE5vdyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS5cbiAqIH0pO1xuICpcbiAqL1xuZnVuY3Rpb24gdHJ5RWFjaCh0YXNrcywgY2FsbGJhY2spIHtcbiAgICB2YXIgZXJyb3IgPSBudWxsO1xuICAgIHZhciByZXN1bHQ7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICAgIGVhY2hTZXJpZXModGFza3MsIGZ1bmN0aW9uKHRhc2ssIGNhbGxiYWNrKSB7XG4gICAgICAgIHdyYXBBc3luYyh0YXNrKShmdW5jdGlvbiAoZXJyLCByZXMvKiwgLi4uYXJncyovKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgIGNhbGxiYWNrKCFlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFVuZG9lcyBhIFttZW1vaXplXXtAbGluayBtb2R1bGU6VXRpbHMubWVtb2l6ZX1kIGZ1bmN0aW9uLCByZXZlcnRpbmcgaXQgdG8gdGhlIG9yaWdpbmFsLFxuICogdW5tZW1vaXplZCBmb3JtLiBIYW5keSBmb3IgdGVzdGluZy5cbiAqXG4gKiBAbmFtZSB1bm1lbW9pemVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLm1lbW9pemVde0BsaW5rIG1vZHVsZTpVdGlscy5tZW1vaXplfVxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSB0aGUgbWVtb2l6ZWQgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIG9yaWdpbmFsIHVubWVtb2l6ZWQgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gdW5tZW1vaXplKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChmbi51bm1lbW9pemVkIHx8IGZuKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qKlxuICogUmVwZWF0ZWRseSBjYWxsIGBpdGVyYXRlZWAsIHdoaWxlIGB0ZXN0YCByZXR1cm5zIGB0cnVlYC4gQ2FsbHMgYGNhbGxiYWNrYCB3aGVuXG4gKiBzdG9wcGVkLCBvciBhbiBlcnJvciBvY2N1cnMuXG4gKlxuICogQG5hbWUgd2hpbHN0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0ZXN0IC0gc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGJlZm9yZSBlYWNoXG4gKiBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYC4gSW52b2tlZCB3aXRoICgpLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBlYWNoIHRpbWVcbiAqIGB0ZXN0YCBwYXNzZXMuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0XG4gKiBmdW5jdGlvbiBoYXMgZmFpbGVkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYFxuICogd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgYW5kIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3NcbiAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKTtcbiAqIEByZXR1cm5zIHVuZGVmaW5lZFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgY291bnQgPSAwO1xuICogYXN5bmMud2hpbHN0KFxuICogICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gY291bnQgPCA1OyB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIGNvdW50Kys7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBjb3VudCk7XG4gKiAgICAgICAgIH0sIDEwMDApO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24gKGVyciwgbikge1xuICogICAgICAgICAvLyA1IHNlY29uZHMgaGF2ZSBwYXNzZWQsIG4gPSA1XG4gKiAgICAgfVxuICogKTtcbiAqL1xuZnVuY3Rpb24gd2hpbHN0KHRlc3QsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb25seU9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7XG4gICAgaWYgKCF0ZXN0KCkpIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uKGVyci8qLCAuLi5hcmdzKi8pIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIGlmICh0ZXN0KCkpIHJldHVybiBfaXRlcmF0ZWUobmV4dCk7XG4gICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgW251bGxdLmNvbmNhdChhcmdzKSk7XG4gICAgfTtcbiAgICBfaXRlcmF0ZWUobmV4dCk7XG59XG5cbi8qKlxuICogUmVwZWF0ZWRseSBjYWxsIGBpdGVyYXRlZWAgdW50aWwgYHRlc3RgIHJldHVybnMgYHRydWVgLiBDYWxscyBgY2FsbGJhY2tgIHdoZW5cbiAqIHN0b3BwZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gYGNhbGxiYWNrYCB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciBhbmQgYW55XG4gKiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3MgY2FsbGJhY2suXG4gKlxuICogVGhlIGludmVyc2Ugb2YgW3doaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH0uXG4gKlxuICogQG5hbWUgdW50aWxcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLndoaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH1cbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRlc3QgLSBzeW5jaHJvbm91cyB0cnV0aCB0ZXN0IHRvIHBlcmZvcm0gYmVmb3JlIGVhY2hcbiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggKCkuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZVxuICogYHRlc3RgIGZhaWxzLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciB0aGUgdGVzdFxuICogZnVuY3Rpb24gaGFzIHBhc3NlZCBhbmQgcmVwZWF0ZWQgZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAgaGFzIHN0b3BwZWQuIGBjYWxsYmFja2BcbiAqIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yIGFuZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZmluYWwgYGl0ZXJhdGVlYCdzXG4gKiBjYWxsYmFjay4gSW52b2tlZCB3aXRoIChlcnIsIFtyZXN1bHRzXSk7XG4gKi9cbmZ1bmN0aW9uIHVudGlsKHRlc3QsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHdoaWxzdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0ZXN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwgaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSdW5zIHRoZSBgdGFza3NgIGFycmF5IG9mIGZ1bmN0aW9ucyBpbiBzZXJpZXMsIGVhY2ggcGFzc2luZyB0aGVpciByZXN1bHRzIHRvXG4gKiB0aGUgbmV4dCBpbiB0aGUgYXJyYXkuIEhvd2V2ZXIsIGlmIGFueSBvZiB0aGUgYHRhc2tzYCBwYXNzIGFuIGVycm9yIHRvIHRoZWlyXG4gKiBvd24gY2FsbGJhY2ssIHRoZSBuZXh0IGZ1bmN0aW9uIGlzIG5vdCBleGVjdXRlZCwgYW5kIHRoZSBtYWluIGBjYWxsYmFja2AgaXNcbiAqIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSBlcnJvci5cbiAqXG4gKiBAbmFtZSB3YXRlcmZhbGxcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl9IHRhc2tzIC0gQW4gYXJyYXkgb2YgW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn1cbiAqIHRvIHJ1bi5cbiAqIEVhY2ggZnVuY3Rpb24gc2hvdWxkIGNvbXBsZXRlIHdpdGggYW55IG51bWJlciBvZiBgcmVzdWx0YCB2YWx1ZXMuXG4gKiBUaGUgYHJlc3VsdGAgdmFsdWVzIHdpbGwgYmUgcGFzc2VkIGFzIGFyZ3VtZW50cywgaW4gb3JkZXIsIHRvIHRoZSBuZXh0IHRhc2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZVxuICogZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkLiBUaGlzIHdpbGwgYmUgcGFzc2VkIHRoZSByZXN1bHRzIG9mIHRoZSBsYXN0IHRhc2snc1xuICogY2FsbGJhY2suIEludm9rZWQgd2l0aCAoZXJyLCBbcmVzdWx0c10pLlxuICogQHJldHVybnMgdW5kZWZpbmVkXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScsICd0d28nKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGFyZzEsIGFyZzIsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGFyZzEgbm93IGVxdWFscyAnb25lJyBhbmQgYXJnMiBub3cgZXF1YWxzICd0d28nXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0aHJlZScpO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oYXJnMSwgY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gYXJnMSBub3cgZXF1YWxzICd0aHJlZSdcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RvbmUnKTtcbiAqICAgICB9XG4gKiBdLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyAnZG9uZSdcbiAqIH0pO1xuICpcbiAqIC8vIE9yLCB3aXRoIG5hbWVkIGZ1bmN0aW9uczpcbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgbXlGaXJzdEZ1bmN0aW9uLFxuICogICAgIG15U2Vjb25kRnVuY3Rpb24sXG4gKiAgICAgbXlMYXN0RnVuY3Rpb24sXG4gKiBdLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyAnZG9uZSdcbiAqIH0pO1xuICogZnVuY3Rpb24gbXlGaXJzdEZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScsICd0d28nKTtcbiAqIH1cbiAqIGZ1bmN0aW9uIG15U2Vjb25kRnVuY3Rpb24oYXJnMSwgYXJnMiwgY2FsbGJhY2spIHtcbiAqICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ29uZScgYW5kIGFyZzIgbm93IGVxdWFscyAndHdvJ1xuICogICAgIGNhbGxiYWNrKG51bGwsICd0aHJlZScpO1xuICogfVxuICogZnVuY3Rpb24gbXlMYXN0RnVuY3Rpb24oYXJnMSwgY2FsbGJhY2spIHtcbiAqICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ3RocmVlJ1xuICogICAgIGNhbGxiYWNrKG51bGwsICdkb25lJyk7XG4gKiB9XG4gKi9cbnZhciB3YXRlcmZhbGwgPSBmdW5jdGlvbih0YXNrcywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgaWYgKCFpc0FycmF5KHRhc2tzKSkgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gd2F0ZXJmYWxsIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJykpO1xuICAgIGlmICghdGFza3MubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB2YXIgdGFza0luZGV4ID0gMDtcblxuICAgIGZ1bmN0aW9uIG5leHRUYXNrKGFyZ3MpIHtcbiAgICAgICAgdmFyIHRhc2sgPSB3cmFwQXN5bmModGFza3NbdGFza0luZGV4KytdKTtcbiAgICAgICAgYXJncy5wdXNoKG9ubHlPbmNlKG5leHQpKTtcbiAgICAgICAgdGFzay5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXh0KGVyci8qLCAuLi5hcmdzKi8pIHtcbiAgICAgICAgaWYgKGVyciB8fCB0YXNrSW5kZXggPT09IHRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dFRhc2soc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgbmV4dFRhc2soW10pO1xufTtcblxuLyoqXG4gKiBBbiBcImFzeW5jIGZ1bmN0aW9uXCIgaW4gdGhlIGNvbnRleHQgb2YgQXN5bmMgaXMgYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHdpdGhcbiAqIGEgdmFyaWFibGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMsIHdpdGggdGhlIGZpbmFsIHBhcmFtZXRlciBiZWluZyBhIGNhbGxiYWNrLlxuICogKGBmdW5jdGlvbiAoYXJnMSwgYXJnMiwgLi4uLCBjYWxsYmFjaykge31gKVxuICogVGhlIGZpbmFsIGNhbGxiYWNrIGlzIG9mIHRoZSBmb3JtIGBjYWxsYmFjayhlcnIsIHJlc3VsdHMuLi4pYCwgd2hpY2ggbXVzdCBiZVxuICogY2FsbGVkIG9uY2UgdGhlIGZ1bmN0aW9uIGlzIGNvbXBsZXRlZC4gIFRoZSBjYWxsYmFjayBzaG91bGQgYmUgY2FsbGVkIHdpdGggYVxuICogRXJyb3IgYXMgaXRzIGZpcnN0IGFyZ3VtZW50IHRvIHNpZ25hbCB0aGF0IGFuIGVycm9yIG9jY3VycmVkLlxuICogT3RoZXJ3aXNlLCBpZiBubyBlcnJvciBvY2N1cnJlZCwgaXQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIGBudWxsYCBhcyB0aGUgZmlyc3RcbiAqIGFyZ3VtZW50LCBhbmQgYW55IGFkZGl0aW9uYWwgYHJlc3VsdGAgYXJndW1lbnRzIHRoYXQgbWF5IGFwcGx5LCB0byBzaWduYWxcbiAqIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi5cbiAqIFRoZSBjYWxsYmFjayBtdXN0IGJlIGNhbGxlZCBleGFjdGx5IG9uY2UsIGlkZWFsbHkgb24gYSBsYXRlciB0aWNrIG9mIHRoZVxuICogSmF2YVNjcmlwdCBldmVudCBsb29wLlxuICpcbiAqIFRoaXMgdHlwZSBvZiBmdW5jdGlvbiBpcyBhbHNvIHJlZmVycmVkIHRvIGFzIGEgXCJOb2RlLXN0eWxlIGFzeW5jIGZ1bmN0aW9uXCIsXG4gKiBvciBhIFwiY29udGludWF0aW9uIHBhc3Npbmctc3R5bGUgZnVuY3Rpb25cIiAoQ1BTKS4gTW9zdCBvZiB0aGUgbWV0aG9kcyBvZiB0aGlzXG4gKiBsaWJyYXJ5IGFyZSB0aGVtc2VsdmVzIENQUy9Ob2RlLXN0eWxlIGFzeW5jIGZ1bmN0aW9ucywgb3IgZnVuY3Rpb25zIHRoYXRcbiAqIHJldHVybiBDUFMvTm9kZS1zdHlsZSBhc3luYyBmdW5jdGlvbnMuXG4gKlxuICogV2hlcmV2ZXIgd2UgYWNjZXB0IGEgTm9kZS1zdHlsZSBhc3luYyBmdW5jdGlvbiwgd2UgYWxzbyBkaXJlY3RseSBhY2NlcHQgYW5cbiAqIFtFUzIwMTcgYGFzeW5jYCBmdW5jdGlvbl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvU3RhdGVtZW50cy9hc3luY19mdW5jdGlvbn0uXG4gKiBJbiB0aGlzIGNhc2UsIHRoZSBgYXN5bmNgIGZ1bmN0aW9uIHdpbGwgbm90IGJlIHBhc3NlZCBhIGZpbmFsIGNhbGxiYWNrXG4gKiBhcmd1bWVudCwgYW5kIGFueSB0aHJvd24gZXJyb3Igd2lsbCBiZSB1c2VkIGFzIHRoZSBgZXJyYCBhcmd1bWVudCBvZiB0aGVcbiAqIGltcGxpY2l0IGNhbGxiYWNrLCBhbmQgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIGByZXN1bHRgIHZhbHVlLlxuICogKGkuZS4gYSBgcmVqZWN0ZWRgIG9mIHRoZSByZXR1cm5lZCBQcm9taXNlIGJlY29tZXMgdGhlIGBlcnJgIGNhbGxiYWNrXG4gKiBhcmd1bWVudCwgYW5kIGEgYHJlc29sdmVkYCB2YWx1ZSBiZWNvbWVzIHRoZSBgcmVzdWx0YC4pXG4gKlxuICogTm90ZSwgZHVlIHRvIEphdmFTY3JpcHQgbGltaXRhdGlvbnMsIHdlIGNhbiBvbmx5IGRldGVjdCBuYXRpdmUgYGFzeW5jYFxuICogZnVuY3Rpb25zIGFuZCBub3QgdHJhbnNwaWxpZWQgaW1wbGVtZW50YXRpb25zLlxuICogWW91ciBlbnZpcm9ubWVudCBtdXN0IGhhdmUgYGFzeW5jYC9gYXdhaXRgIHN1cHBvcnQgZm9yIHRoaXMgdG8gd29yay5cbiAqIChlLmcuIE5vZGUgPiB2Ny42LCBvciBhIHJlY2VudCB2ZXJzaW9uIG9mIGEgbW9kZXJuIGJyb3dzZXIpLlxuICogSWYgeW91IGFyZSB1c2luZyBgYXN5bmNgIGZ1bmN0aW9ucyB0aHJvdWdoIGEgdHJhbnNwaWxlciAoZS5nLiBCYWJlbCksIHlvdVxuICogbXVzdCBzdGlsbCB3cmFwIHRoZSBmdW5jdGlvbiB3aXRoIFthc3luY2lmeV17QGxpbmsgbW9kdWxlOlV0aWxzLmFzeW5jaWZ5fSxcbiAqIGJlY2F1c2UgdGhlIGBhc3luYyBmdW5jdGlvbmAgd2lsbCBiZSBjb21waWxlZCB0byBhbiBvcmRpbmFyeSBmdW5jdGlvbiB0aGF0XG4gKiByZXR1cm5zIGEgcHJvbWlzZS5cbiAqXG4gKiBAdHlwZWRlZiB7RnVuY3Rpb259IEFzeW5jRnVuY3Rpb25cbiAqIEBzdGF0aWNcbiAqL1xuXG4vKipcbiAqIEFzeW5jIGlzIGEgdXRpbGl0eSBtb2R1bGUgd2hpY2ggcHJvdmlkZXMgc3RyYWlnaHQtZm9yd2FyZCwgcG93ZXJmdWwgZnVuY3Rpb25zXG4gKiBmb3Igd29ya2luZyB3aXRoIGFzeW5jaHJvbm91cyBKYXZhU2NyaXB0LiBBbHRob3VnaCBvcmlnaW5hbGx5IGRlc2lnbmVkIGZvclxuICogdXNlIHdpdGggW05vZGUuanNdKGh0dHA6Ly9ub2RlanMub3JnKSBhbmQgaW5zdGFsbGFibGUgdmlhXG4gKiBgbnBtIGluc3RhbGwgLS1zYXZlIGFzeW5jYCwgaXQgY2FuIGFsc28gYmUgdXNlZCBkaXJlY3RseSBpbiB0aGUgYnJvd3Nlci5cbiAqIEBtb2R1bGUgYXN5bmNcbiAqIEBzZWUgQXN5bmNGdW5jdGlvblxuICovXG5cblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgYGFzeW5jYCBmdW5jdGlvbnMgZm9yIG1hbmlwdWxhdGluZyBjb2xsZWN0aW9ucywgc3VjaCBhc1xuICogYXJyYXlzIGFuZCBvYmplY3RzLlxuICogQG1vZHVsZSBDb2xsZWN0aW9uc1xuICovXG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGBhc3luY2AgZnVuY3Rpb25zIGZvciBjb250cm9sbGluZyB0aGUgZmxvdyB0aHJvdWdoIGEgc2NyaXB0LlxuICogQG1vZHVsZSBDb250cm9sRmxvd1xuICovXG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGBhc3luY2AgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKiBAbW9kdWxlIFV0aWxzXG4gKi9cblxudmFyIGluZGV4ID0ge1xuICAgIGFwcGx5OiBhcHBseSxcbiAgICBhcHBseUVhY2g6IGFwcGx5RWFjaCxcbiAgICBhcHBseUVhY2hTZXJpZXM6IGFwcGx5RWFjaFNlcmllcyxcbiAgICBhc3luY2lmeTogYXN5bmNpZnksXG4gICAgYXV0bzogYXV0byxcbiAgICBhdXRvSW5qZWN0OiBhdXRvSW5qZWN0LFxuICAgIGNhcmdvOiBjYXJnbyxcbiAgICBjb21wb3NlOiBjb21wb3NlLFxuICAgIGNvbmNhdDogY29uY2F0LFxuICAgIGNvbmNhdExpbWl0OiBjb25jYXRMaW1pdCxcbiAgICBjb25jYXRTZXJpZXM6IGNvbmNhdFNlcmllcyxcbiAgICBjb25zdGFudDogY29uc3RhbnQsXG4gICAgZGV0ZWN0OiBkZXRlY3QsXG4gICAgZGV0ZWN0TGltaXQ6IGRldGVjdExpbWl0LFxuICAgIGRldGVjdFNlcmllczogZGV0ZWN0U2VyaWVzLFxuICAgIGRpcjogZGlyLFxuICAgIGRvRHVyaW5nOiBkb0R1cmluZyxcbiAgICBkb1VudGlsOiBkb1VudGlsLFxuICAgIGRvV2hpbHN0OiBkb1doaWxzdCxcbiAgICBkdXJpbmc6IGR1cmluZyxcbiAgICBlYWNoOiBlYWNoTGltaXQsXG4gICAgZWFjaExpbWl0OiBlYWNoTGltaXQkMSxcbiAgICBlYWNoT2Y6IGVhY2hPZixcbiAgICBlYWNoT2ZMaW1pdDogZWFjaE9mTGltaXQsXG4gICAgZWFjaE9mU2VyaWVzOiBlYWNoT2ZTZXJpZXMsXG4gICAgZWFjaFNlcmllczogZWFjaFNlcmllcyxcbiAgICBlbnN1cmVBc3luYzogZW5zdXJlQXN5bmMsXG4gICAgZXZlcnk6IGV2ZXJ5LFxuICAgIGV2ZXJ5TGltaXQ6IGV2ZXJ5TGltaXQsXG4gICAgZXZlcnlTZXJpZXM6IGV2ZXJ5U2VyaWVzLFxuICAgIGZpbHRlcjogZmlsdGVyLFxuICAgIGZpbHRlckxpbWl0OiBmaWx0ZXJMaW1pdCxcbiAgICBmaWx0ZXJTZXJpZXM6IGZpbHRlclNlcmllcyxcbiAgICBmb3JldmVyOiBmb3JldmVyLFxuICAgIGdyb3VwQnk6IGdyb3VwQnksXG4gICAgZ3JvdXBCeUxpbWl0OiBncm91cEJ5TGltaXQsXG4gICAgZ3JvdXBCeVNlcmllczogZ3JvdXBCeVNlcmllcyxcbiAgICBsb2c6IGxvZyxcbiAgICBtYXA6IG1hcCxcbiAgICBtYXBMaW1pdDogbWFwTGltaXQsXG4gICAgbWFwU2VyaWVzOiBtYXBTZXJpZXMsXG4gICAgbWFwVmFsdWVzOiBtYXBWYWx1ZXMsXG4gICAgbWFwVmFsdWVzTGltaXQ6IG1hcFZhbHVlc0xpbWl0LFxuICAgIG1hcFZhbHVlc1NlcmllczogbWFwVmFsdWVzU2VyaWVzLFxuICAgIG1lbW9pemU6IG1lbW9pemUsXG4gICAgbmV4dFRpY2s6IG5leHRUaWNrLFxuICAgIHBhcmFsbGVsOiBwYXJhbGxlbExpbWl0LFxuICAgIHBhcmFsbGVsTGltaXQ6IHBhcmFsbGVsTGltaXQkMSxcbiAgICBwcmlvcml0eVF1ZXVlOiBwcmlvcml0eVF1ZXVlLFxuICAgIHF1ZXVlOiBxdWV1ZSQxLFxuICAgIHJhY2U6IHJhY2UsXG4gICAgcmVkdWNlOiByZWR1Y2UsXG4gICAgcmVkdWNlUmlnaHQ6IHJlZHVjZVJpZ2h0LFxuICAgIHJlZmxlY3Q6IHJlZmxlY3QsXG4gICAgcmVmbGVjdEFsbDogcmVmbGVjdEFsbCxcbiAgICByZWplY3Q6IHJlamVjdCxcbiAgICByZWplY3RMaW1pdDogcmVqZWN0TGltaXQsXG4gICAgcmVqZWN0U2VyaWVzOiByZWplY3RTZXJpZXMsXG4gICAgcmV0cnk6IHJldHJ5LFxuICAgIHJldHJ5YWJsZTogcmV0cnlhYmxlLFxuICAgIHNlcTogc2VxLFxuICAgIHNlcmllczogc2VyaWVzLFxuICAgIHNldEltbWVkaWF0ZTogc2V0SW1tZWRpYXRlJDEsXG4gICAgc29tZTogc29tZSxcbiAgICBzb21lTGltaXQ6IHNvbWVMaW1pdCxcbiAgICBzb21lU2VyaWVzOiBzb21lU2VyaWVzLFxuICAgIHNvcnRCeTogc29ydEJ5LFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgdGltZXM6IHRpbWVzLFxuICAgIHRpbWVzTGltaXQ6IHRpbWVMaW1pdCxcbiAgICB0aW1lc1NlcmllczogdGltZXNTZXJpZXMsXG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgdHJ5RWFjaDogdHJ5RWFjaCxcbiAgICB1bm1lbW9pemU6IHVubWVtb2l6ZSxcbiAgICB1bnRpbDogdW50aWwsXG4gICAgd2F0ZXJmYWxsOiB3YXRlcmZhbGwsXG4gICAgd2hpbHN0OiB3aGlsc3QsXG5cbiAgICAvLyBhbGlhc2VzXG4gICAgYWxsOiBldmVyeSxcbiAgICBhbGxMaW1pdDogZXZlcnlMaW1pdCxcbiAgICBhbGxTZXJpZXM6IGV2ZXJ5U2VyaWVzLFxuICAgIGFueTogc29tZSxcbiAgICBhbnlMaW1pdDogc29tZUxpbWl0LFxuICAgIGFueVNlcmllczogc29tZVNlcmllcyxcbiAgICBmaW5kOiBkZXRlY3QsXG4gICAgZmluZExpbWl0OiBkZXRlY3RMaW1pdCxcbiAgICBmaW5kU2VyaWVzOiBkZXRlY3RTZXJpZXMsXG4gICAgZm9yRWFjaDogZWFjaExpbWl0LFxuICAgIGZvckVhY2hTZXJpZXM6IGVhY2hTZXJpZXMsXG4gICAgZm9yRWFjaExpbWl0OiBlYWNoTGltaXQkMSxcbiAgICBmb3JFYWNoT2Y6IGVhY2hPZixcbiAgICBmb3JFYWNoT2ZTZXJpZXM6IGVhY2hPZlNlcmllcyxcbiAgICBmb3JFYWNoT2ZMaW1pdDogZWFjaE9mTGltaXQsXG4gICAgaW5qZWN0OiByZWR1Y2UsXG4gICAgZm9sZGw6IHJlZHVjZSxcbiAgICBmb2xkcjogcmVkdWNlUmlnaHQsXG4gICAgc2VsZWN0OiBmaWx0ZXIsXG4gICAgc2VsZWN0TGltaXQ6IGZpbHRlckxpbWl0LFxuICAgIHNlbGVjdFNlcmllczogZmlsdGVyU2VyaWVzLFxuICAgIHdyYXBTeW5jOiBhc3luY2lmeVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gaW5kZXg7XG5leHBvcnRzLmFwcGx5ID0gYXBwbHk7XG5leHBvcnRzLmFwcGx5RWFjaCA9IGFwcGx5RWFjaDtcbmV4cG9ydHMuYXBwbHlFYWNoU2VyaWVzID0gYXBwbHlFYWNoU2VyaWVzO1xuZXhwb3J0cy5hc3luY2lmeSA9IGFzeW5jaWZ5O1xuZXhwb3J0cy5hdXRvID0gYXV0bztcbmV4cG9ydHMuYXV0b0luamVjdCA9IGF1dG9JbmplY3Q7XG5leHBvcnRzLmNhcmdvID0gY2FyZ287XG5leHBvcnRzLmNvbXBvc2UgPSBjb21wb3NlO1xuZXhwb3J0cy5jb25jYXQgPSBjb25jYXQ7XG5leHBvcnRzLmNvbmNhdExpbWl0ID0gY29uY2F0TGltaXQ7XG5leHBvcnRzLmNvbmNhdFNlcmllcyA9IGNvbmNhdFNlcmllcztcbmV4cG9ydHMuY29uc3RhbnQgPSBjb25zdGFudDtcbmV4cG9ydHMuZGV0ZWN0ID0gZGV0ZWN0O1xuZXhwb3J0cy5kZXRlY3RMaW1pdCA9IGRldGVjdExpbWl0O1xuZXhwb3J0cy5kZXRlY3RTZXJpZXMgPSBkZXRlY3RTZXJpZXM7XG5leHBvcnRzLmRpciA9IGRpcjtcbmV4cG9ydHMuZG9EdXJpbmcgPSBkb0R1cmluZztcbmV4cG9ydHMuZG9VbnRpbCA9IGRvVW50aWw7XG5leHBvcnRzLmRvV2hpbHN0ID0gZG9XaGlsc3Q7XG5leHBvcnRzLmR1cmluZyA9IGR1cmluZztcbmV4cG9ydHMuZWFjaCA9IGVhY2hMaW1pdDtcbmV4cG9ydHMuZWFjaExpbWl0ID0gZWFjaExpbWl0JDE7XG5leHBvcnRzLmVhY2hPZiA9IGVhY2hPZjtcbmV4cG9ydHMuZWFjaE9mTGltaXQgPSBlYWNoT2ZMaW1pdDtcbmV4cG9ydHMuZWFjaE9mU2VyaWVzID0gZWFjaE9mU2VyaWVzO1xuZXhwb3J0cy5lYWNoU2VyaWVzID0gZWFjaFNlcmllcztcbmV4cG9ydHMuZW5zdXJlQXN5bmMgPSBlbnN1cmVBc3luYztcbmV4cG9ydHMuZXZlcnkgPSBldmVyeTtcbmV4cG9ydHMuZXZlcnlMaW1pdCA9IGV2ZXJ5TGltaXQ7XG5leHBvcnRzLmV2ZXJ5U2VyaWVzID0gZXZlcnlTZXJpZXM7XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbmV4cG9ydHMuZmlsdGVyTGltaXQgPSBmaWx0ZXJMaW1pdDtcbmV4cG9ydHMuZmlsdGVyU2VyaWVzID0gZmlsdGVyU2VyaWVzO1xuZXhwb3J0cy5mb3JldmVyID0gZm9yZXZlcjtcbmV4cG9ydHMuZ3JvdXBCeSA9IGdyb3VwQnk7XG5leHBvcnRzLmdyb3VwQnlMaW1pdCA9IGdyb3VwQnlMaW1pdDtcbmV4cG9ydHMuZ3JvdXBCeVNlcmllcyA9IGdyb3VwQnlTZXJpZXM7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMubWFwID0gbWFwO1xuZXhwb3J0cy5tYXBMaW1pdCA9IG1hcExpbWl0O1xuZXhwb3J0cy5tYXBTZXJpZXMgPSBtYXBTZXJpZXM7XG5leHBvcnRzLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcbmV4cG9ydHMubWFwVmFsdWVzTGltaXQgPSBtYXBWYWx1ZXNMaW1pdDtcbmV4cG9ydHMubWFwVmFsdWVzU2VyaWVzID0gbWFwVmFsdWVzU2VyaWVzO1xuZXhwb3J0cy5tZW1vaXplID0gbWVtb2l6ZTtcbmV4cG9ydHMubmV4dFRpY2sgPSBuZXh0VGljaztcbmV4cG9ydHMucGFyYWxsZWwgPSBwYXJhbGxlbExpbWl0O1xuZXhwb3J0cy5wYXJhbGxlbExpbWl0ID0gcGFyYWxsZWxMaW1pdCQxO1xuZXhwb3J0cy5wcmlvcml0eVF1ZXVlID0gcHJpb3JpdHlRdWV1ZTtcbmV4cG9ydHMucXVldWUgPSBxdWV1ZSQxO1xuZXhwb3J0cy5yYWNlID0gcmFjZTtcbmV4cG9ydHMucmVkdWNlID0gcmVkdWNlO1xuZXhwb3J0cy5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuZXhwb3J0cy5yZWZsZWN0ID0gcmVmbGVjdDtcbmV4cG9ydHMucmVmbGVjdEFsbCA9IHJlZmxlY3RBbGw7XG5leHBvcnRzLnJlamVjdCA9IHJlamVjdDtcbmV4cG9ydHMucmVqZWN0TGltaXQgPSByZWplY3RMaW1pdDtcbmV4cG9ydHMucmVqZWN0U2VyaWVzID0gcmVqZWN0U2VyaWVzO1xuZXhwb3J0cy5yZXRyeSA9IHJldHJ5O1xuZXhwb3J0cy5yZXRyeWFibGUgPSByZXRyeWFibGU7XG5leHBvcnRzLnNlcSA9IHNlcTtcbmV4cG9ydHMuc2VyaWVzID0gc2VyaWVzO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGUkMTtcbmV4cG9ydHMuc29tZSA9IHNvbWU7XG5leHBvcnRzLnNvbWVMaW1pdCA9IHNvbWVMaW1pdDtcbmV4cG9ydHMuc29tZVNlcmllcyA9IHNvbWVTZXJpZXM7XG5leHBvcnRzLnNvcnRCeSA9IHNvcnRCeTtcbmV4cG9ydHMudGltZW91dCA9IHRpbWVvdXQ7XG5leHBvcnRzLnRpbWVzID0gdGltZXM7XG5leHBvcnRzLnRpbWVzTGltaXQgPSB0aW1lTGltaXQ7XG5leHBvcnRzLnRpbWVzU2VyaWVzID0gdGltZXNTZXJpZXM7XG5leHBvcnRzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbmV4cG9ydHMudHJ5RWFjaCA9IHRyeUVhY2g7XG5leHBvcnRzLnVubWVtb2l6ZSA9IHVubWVtb2l6ZTtcbmV4cG9ydHMudW50aWwgPSB1bnRpbDtcbmV4cG9ydHMud2F0ZXJmYWxsID0gd2F0ZXJmYWxsO1xuZXhwb3J0cy53aGlsc3QgPSB3aGlsc3Q7XG5leHBvcnRzLmFsbCA9IGV2ZXJ5O1xuZXhwb3J0cy5hbGxMaW1pdCA9IGV2ZXJ5TGltaXQ7XG5leHBvcnRzLmFsbFNlcmllcyA9IGV2ZXJ5U2VyaWVzO1xuZXhwb3J0cy5hbnkgPSBzb21lO1xuZXhwb3J0cy5hbnlMaW1pdCA9IHNvbWVMaW1pdDtcbmV4cG9ydHMuYW55U2VyaWVzID0gc29tZVNlcmllcztcbmV4cG9ydHMuZmluZCA9IGRldGVjdDtcbmV4cG9ydHMuZmluZExpbWl0ID0gZGV0ZWN0TGltaXQ7XG5leHBvcnRzLmZpbmRTZXJpZXMgPSBkZXRlY3RTZXJpZXM7XG5leHBvcnRzLmZvckVhY2ggPSBlYWNoTGltaXQ7XG5leHBvcnRzLmZvckVhY2hTZXJpZXMgPSBlYWNoU2VyaWVzO1xuZXhwb3J0cy5mb3JFYWNoTGltaXQgPSBlYWNoTGltaXQkMTtcbmV4cG9ydHMuZm9yRWFjaE9mID0gZWFjaE9mO1xuZXhwb3J0cy5mb3JFYWNoT2ZTZXJpZXMgPSBlYWNoT2ZTZXJpZXM7XG5leHBvcnRzLmZvckVhY2hPZkxpbWl0ID0gZWFjaE9mTGltaXQ7XG5leHBvcnRzLmluamVjdCA9IHJlZHVjZTtcbmV4cG9ydHMuZm9sZGwgPSByZWR1Y2U7XG5leHBvcnRzLmZvbGRyID0gcmVkdWNlUmlnaHQ7XG5leHBvcnRzLnNlbGVjdCA9IGZpbHRlcjtcbmV4cG9ydHMuc2VsZWN0TGltaXQgPSBmaWx0ZXJMaW1pdDtcbmV4cG9ydHMuc2VsZWN0U2VyaWVzID0gZmlsdGVyU2VyaWVzO1xuZXhwb3J0cy53cmFwU3luYyA9IGFzeW5jaWZ5O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiZnVuY3Rpb24gQ2FsbGFibGVJbnN0YW5jZShwcm9wZXJ0eSkge1xuICB2YXIgZnVuYyA9IHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlW3Byb3BlcnR5XTtcbiAgdmFyIGFwcGx5ID0gZnVuY3Rpb24oKSB7IHJldHVybiBmdW5jLmFwcGx5KGFwcGx5LCBhcmd1bWVudHMpOyB9XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcHBseSwgdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhmdW5jKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcGx5LCBwLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZ1bmMsIHApKTtcbiAgfSk7XG4gIHJldHVybiBhcHBseTtcbn1cbkNhbGxhYmxlSW5zdGFuY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGdW5jdGlvbi5wcm90b3R5cGUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbGxhYmxlSW5zdGFuY2U7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZXNjYXBlU3RyaW5nUmVnZXhwID0gcmVxdWlyZSgnZXNjYXBlLXN0cmluZy1yZWdleHAnKTtcbnZhciBhbnNpU3R5bGVzID0gcmVxdWlyZSgnYW5zaS1zdHlsZXMnKTtcbnZhciBzdHJpcEFuc2kgPSByZXF1aXJlKCdzdHJpcC1hbnNpJyk7XG52YXIgaGFzQW5zaSA9IHJlcXVpcmUoJ2hhcy1hbnNpJyk7XG52YXIgc3VwcG9ydHNDb2xvciA9IHJlcXVpcmUoJ3N1cHBvcnRzLWNvbG9yJyk7XG52YXIgZGVmaW5lUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBpc1NpbXBsZVdpbmRvd3NUZXJtID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyAmJiAhL154dGVybS9pLnRlc3QocHJvY2Vzcy5lbnYuVEVSTSk7XG5cbmZ1bmN0aW9uIENoYWxrKG9wdGlvbnMpIHtcblx0Ly8gZGV0ZWN0IG1vZGUgaWYgbm90IHNldCBtYW51YWxseVxuXHR0aGlzLmVuYWJsZWQgPSAhb3B0aW9ucyB8fCBvcHRpb25zLmVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHN1cHBvcnRzQ29sb3IgOiBvcHRpb25zLmVuYWJsZWQ7XG59XG5cbi8vIHVzZSBicmlnaHQgYmx1ZSBvbiBXaW5kb3dzIGFzIHRoZSBub3JtYWwgYmx1ZSBjb2xvciBpcyBpbGxlZ2libGVcbmlmIChpc1NpbXBsZVdpbmRvd3NUZXJtKSB7XG5cdGFuc2lTdHlsZXMuYmx1ZS5vcGVuID0gJ1xcdTAwMWJbOTRtJztcbn1cblxudmFyIHN0eWxlcyA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciByZXQgPSB7fTtcblxuXHRPYmplY3Qua2V5cyhhbnNpU3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRhbnNpU3R5bGVzW2tleV0uY2xvc2VSZSA9IG5ldyBSZWdFeHAoZXNjYXBlU3RyaW5nUmVnZXhwKGFuc2lTdHlsZXNba2V5XS5jbG9zZSksICdnJyk7XG5cblx0XHRyZXRba2V5XSA9IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gYnVpbGQuY2FsbCh0aGlzLCB0aGlzLl9zdHlsZXMuY29uY2F0KGtleSkpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xuXG5cdHJldHVybiByZXQ7XG59KSgpO1xuXG52YXIgcHJvdG8gPSBkZWZpbmVQcm9wcyhmdW5jdGlvbiBjaGFsaygpIHt9LCBzdHlsZXMpO1xuXG5mdW5jdGlvbiBidWlsZChfc3R5bGVzKSB7XG5cdHZhciBidWlsZGVyID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBhcHBseVN0eWxlLmFwcGx5KGJ1aWxkZXIsIGFyZ3VtZW50cyk7XG5cdH07XG5cblx0YnVpbGRlci5fc3R5bGVzID0gX3N0eWxlcztcblx0YnVpbGRlci5lbmFibGVkID0gdGhpcy5lbmFibGVkO1xuXHQvLyBfX3Byb3RvX18gaXMgdXNlZCBiZWNhdXNlIHdlIG11c3QgcmV0dXJuIGEgZnVuY3Rpb24sIGJ1dCB0aGVyZSBpc1xuXHQvLyBubyB3YXkgdG8gY3JlYXRlIGEgZnVuY3Rpb24gd2l0aCBhIGRpZmZlcmVudCBwcm90b3R5cGUuXG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cdGJ1aWxkZXIuX19wcm90b19fID0gcHJvdG87XG5cblx0cmV0dXJuIGJ1aWxkZXI7XG59XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoKSB7XG5cdC8vIHN1cHBvcnQgdmFyYWdzLCBidXQgc2ltcGx5IGNhc3QgdG8gc3RyaW5nIGluIGNhc2UgdGhlcmUncyBvbmx5IG9uZSBhcmdcblx0dmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cdHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG5cdHZhciBzdHIgPSBhcmdzTGVuICE9PSAwICYmIFN0cmluZyhhcmd1bWVudHNbMF0pO1xuXG5cdGlmIChhcmdzTGVuID4gMSkge1xuXHRcdC8vIGRvbid0IHNsaWNlIGBhcmd1bWVudHNgLCBpdCBwcmV2ZW50cyB2OCBvcHRpbWl6YXRpb25zXG5cdFx0Zm9yICh2YXIgYSA9IDE7IGEgPCBhcmdzTGVuOyBhKyspIHtcblx0XHRcdHN0ciArPSAnICcgKyBhcmdzW2FdO1xuXHRcdH1cblx0fVxuXG5cdGlmICghdGhpcy5lbmFibGVkIHx8ICFzdHIpIHtcblx0XHRyZXR1cm4gc3RyO1xuXHR9XG5cblx0dmFyIG5lc3RlZFN0eWxlcyA9IHRoaXMuX3N0eWxlcztcblx0dmFyIGkgPSBuZXN0ZWRTdHlsZXMubGVuZ3RoO1xuXG5cdC8vIFR1cm5zIG91dCB0aGF0IG9uIFdpbmRvd3MgZGltbWVkIGdyYXkgdGV4dCBiZWNvbWVzIGludmlzaWJsZSBpbiBjbWQuZXhlLFxuXHQvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYWxrL2NoYWxrL2lzc3Vlcy81OFxuXHQvLyBJZiB3ZSdyZSBvbiBXaW5kb3dzIGFuZCB3ZSdyZSBkZWFsaW5nIHdpdGggYSBncmF5IGNvbG9yLCB0ZW1wb3JhcmlseSBtYWtlICdkaW0nIGEgbm9vcC5cblx0dmFyIG9yaWdpbmFsRGltID0gYW5zaVN0eWxlcy5kaW0ub3Blbjtcblx0aWYgKGlzU2ltcGxlV2luZG93c1Rlcm0gJiYgKG5lc3RlZFN0eWxlcy5pbmRleE9mKCdncmF5JykgIT09IC0xIHx8IG5lc3RlZFN0eWxlcy5pbmRleE9mKCdncmV5JykgIT09IC0xKSkge1xuXHRcdGFuc2lTdHlsZXMuZGltLm9wZW4gPSAnJztcblx0fVxuXG5cdHdoaWxlIChpLS0pIHtcblx0XHR2YXIgY29kZSA9IGFuc2lTdHlsZXNbbmVzdGVkU3R5bGVzW2ldXTtcblxuXHRcdC8vIFJlcGxhY2UgYW55IGluc3RhbmNlcyBhbHJlYWR5IHByZXNlbnQgd2l0aCBhIHJlLW9wZW5pbmcgY29kZVxuXHRcdC8vIG90aGVyd2lzZSBvbmx5IHRoZSBwYXJ0IG9mIHRoZSBzdHJpbmcgdW50aWwgc2FpZCBjbG9zaW5nIGNvZGVcblx0XHQvLyB3aWxsIGJlIGNvbG9yZWQsIGFuZCB0aGUgcmVzdCB3aWxsIHNpbXBseSBiZSAncGxhaW4nLlxuXHRcdHN0ciA9IGNvZGUub3BlbiArIHN0ci5yZXBsYWNlKGNvZGUuY2xvc2VSZSwgY29kZS5vcGVuKSArIGNvZGUuY2xvc2U7XG5cdH1cblxuXHQvLyBSZXNldCB0aGUgb3JpZ2luYWwgJ2RpbScgaWYgd2UgY2hhbmdlZCBpdCB0byB3b3JrIGFyb3VuZCB0aGUgV2luZG93cyBkaW1tZWQgZ3JheSBpc3N1ZS5cblx0YW5zaVN0eWxlcy5kaW0ub3BlbiA9IG9yaWdpbmFsRGltO1xuXG5cdHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIGluaXQoKSB7XG5cdHZhciByZXQgPSB7fTtcblxuXHRPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXRbbmFtZV0gPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGJ1aWxkLmNhbGwodGhpcywgW25hbWVdKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcblxuXHRyZXR1cm4gcmV0O1xufVxuXG5kZWZpbmVQcm9wcyhDaGFsay5wcm90b3R5cGUsIGluaXQoKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IENoYWxrKCk7XG5tb2R1bGUuZXhwb3J0cy5zdHlsZXMgPSBhbnNpU3R5bGVzO1xubW9kdWxlLmV4cG9ydHMuaGFzQ29sb3IgPSBoYXNBbnNpO1xubW9kdWxlLmV4cG9ydHMuc3RyaXBDb2xvciA9IHN0cmlwQW5zaTtcbm1vZHVsZS5leHBvcnRzLnN1cHBvcnRzQ29sb3IgPSBzdXBwb3J0c0NvbG9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFyZ3YgPSBwcm9jZXNzLmFyZ3Y7XG5cbnZhciB0ZXJtaW5hdG9yID0gYXJndi5pbmRleE9mKCctLScpO1xudmFyIGhhc0ZsYWcgPSBmdW5jdGlvbiAoZmxhZykge1xuXHRmbGFnID0gJy0tJyArIGZsYWc7XG5cdHZhciBwb3MgPSBhcmd2LmluZGV4T2YoZmxhZyk7XG5cdHJldHVybiBwb3MgIT09IC0xICYmICh0ZXJtaW5hdG9yICE9PSAtMSA/IHBvcyA8IHRlcm1pbmF0b3IgOiB0cnVlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcblx0aWYgKCdGT1JDRV9DT0xPUicgaW4gcHJvY2Vzcy5lbnYpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmIChoYXNGbGFnKCduby1jb2xvcicpIHx8XG5cdFx0aGFzRmxhZygnbm8tY29sb3JzJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj1mYWxzZScpKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKGhhc0ZsYWcoJ2NvbG9yJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcnMnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPXRydWUnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPWFsd2F5cycpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAocHJvY2Vzcy5zdGRvdXQgJiYgIXByb2Nlc3Muc3Rkb3V0LmlzVFRZKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICgnQ09MT1JURVJNJyBpbiBwcm9jZXNzLmVudikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKHByb2Nlc3MuZW52LlRFUk0gPT09ICdkdW1iJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICgvXnNjcmVlbnxeeHRlcm18XnZ0MTAwfGNvbG9yfGFuc2l8Y3lnd2lufGxpbnV4L2kudGVzdChwcm9jZXNzLmVudi5URVJNKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufSkoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1hdGNoT3BlcmF0b3JzUmUgPSAvW3xcXFxce30oKVtcXF1eJCsqPy5dL2c7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xuXHR9XG5cblx0cmV0dXJuIHN0ci5yZXBsYWNlKG1hdGNoT3BlcmF0b3JzUmUsICdcXFxcJCYnKTtcbn07XG4iLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImVzcHJpbWFcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiZXNwcmltYVwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdC8qXHJcblx0ICBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzLCBodHRwczovL2pzLmZvdW5kYXRpb24vXHJcblxyXG5cdCAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XHJcblx0ICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuXHJcblx0ICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcclxuXHQgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcblx0ICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcclxuXHQgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXHJcblx0ICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuXHJcblx0ICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxyXG5cdCAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxyXG5cdCAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcclxuXHQgIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcclxuXHQgIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXHJcblx0ICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XHJcblx0ICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcclxuXHQgIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXHJcblx0ICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcclxuXHQgIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcblx0Ki9cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIGNvbW1lbnRfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHR2YXIganN4X3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuXHR2YXIgcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG5cdHZhciB0b2tlbml6ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG5cdGZ1bmN0aW9uIHBhcnNlKGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XHJcblx0ICAgIHZhciBjb21tZW50SGFuZGxlciA9IG51bGw7XHJcblx0ICAgIHZhciBwcm94eURlbGVnYXRlID0gZnVuY3Rpb24gKG5vZGUsIG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICBpZiAoZGVsZWdhdGUpIHtcclxuXHQgICAgICAgICAgICBkZWxlZ2F0ZShub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY29tbWVudEhhbmRsZXIpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50SGFuZGxlci52aXNpdChub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIHZhciBwYXJzZXJEZWxlZ2F0ZSA9ICh0eXBlb2YgZGVsZWdhdGUgPT09ICdmdW5jdGlvbicpID8gcHJveHlEZWxlZ2F0ZSA6IG51bGw7XHJcblx0ICAgIHZhciBjb2xsZWN0Q29tbWVudCA9IGZhbHNlO1xyXG5cdCAgICBpZiAob3B0aW9ucykge1xyXG5cdCAgICAgICAgY29sbGVjdENvbW1lbnQgPSAodHlwZW9mIG9wdGlvbnMuY29tbWVudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMuY29tbWVudCk7XHJcblx0ICAgICAgICB2YXIgYXR0YWNoQ29tbWVudCA9ICh0eXBlb2Ygb3B0aW9ucy5hdHRhY2hDb21tZW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5hdHRhY2hDb21tZW50KTtcclxuXHQgICAgICAgIGlmIChjb2xsZWN0Q29tbWVudCB8fCBhdHRhY2hDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudEhhbmRsZXIgPSBuZXcgY29tbWVudF9oYW5kbGVyXzEuQ29tbWVudEhhbmRsZXIoKTtcclxuXHQgICAgICAgICAgICBjb21tZW50SGFuZGxlci5hdHRhY2ggPSBhdHRhY2hDb21tZW50O1xyXG5cdCAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgcGFyc2VyRGVsZWdhdGUgPSBwcm94eURlbGVnYXRlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICAgIHZhciBpc01vZHVsZSA9IGZhbHNlO1xyXG5cdCAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5zb3VyY2VUeXBlID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgaXNNb2R1bGUgPSAob3B0aW9ucy5zb3VyY2VUeXBlID09PSAnbW9kdWxlJyk7XHJcblx0ICAgIH1cclxuXHQgICAgdmFyIHBhcnNlcjtcclxuXHQgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuanN4ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5qc3gpIHtcclxuXHQgICAgICAgIHBhcnNlciA9IG5ldyBqc3hfcGFyc2VyXzEuSlNYUGFyc2VyKGNvZGUsIG9wdGlvbnMsIHBhcnNlckRlbGVnYXRlKTtcclxuXHQgICAgfVxyXG5cdCAgICBlbHNlIHtcclxuXHQgICAgICAgIHBhcnNlciA9IG5ldyBwYXJzZXJfMS5QYXJzZXIoY29kZSwgb3B0aW9ucywgcGFyc2VyRGVsZWdhdGUpO1xyXG5cdCAgICB9XHJcblx0ICAgIHZhciBwcm9ncmFtID0gaXNNb2R1bGUgPyBwYXJzZXIucGFyc2VNb2R1bGUoKSA6IHBhcnNlci5wYXJzZVNjcmlwdCgpO1xyXG5cdCAgICB2YXIgYXN0ID0gcHJvZ3JhbTtcclxuXHQgICAgaWYgKGNvbGxlY3RDb21tZW50ICYmIGNvbW1lbnRIYW5kbGVyKSB7XHJcblx0ICAgICAgICBhc3QuY29tbWVudHMgPSBjb21tZW50SGFuZGxlci5jb21tZW50cztcclxuXHQgICAgfVxyXG5cdCAgICBpZiAocGFyc2VyLmNvbmZpZy50b2tlbnMpIHtcclxuXHQgICAgICAgIGFzdC50b2tlbnMgPSBwYXJzZXIudG9rZW5zO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmIChwYXJzZXIuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICBhc3QuZXJyb3JzID0gcGFyc2VyLmVycm9ySGFuZGxlci5lcnJvcnM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIGFzdDtcclxuXHR9XHJcblx0ZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xyXG5cdGZ1bmN0aW9uIHBhcnNlTW9kdWxlKGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XHJcblx0ICAgIHZhciBwYXJzaW5nT3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0ICAgIHBhcnNpbmdPcHRpb25zLnNvdXJjZVR5cGUgPSAnbW9kdWxlJztcclxuXHQgICAgcmV0dXJuIHBhcnNlKGNvZGUsIHBhcnNpbmdPcHRpb25zLCBkZWxlZ2F0ZSk7XHJcblx0fVxyXG5cdGV4cG9ydHMucGFyc2VNb2R1bGUgPSBwYXJzZU1vZHVsZTtcclxuXHRmdW5jdGlvbiBwYXJzZVNjcmlwdChjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xyXG5cdCAgICB2YXIgcGFyc2luZ09wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdCAgICBwYXJzaW5nT3B0aW9ucy5zb3VyY2VUeXBlID0gJ3NjcmlwdCc7XHJcblx0ICAgIHJldHVybiBwYXJzZShjb2RlLCBwYXJzaW5nT3B0aW9ucywgZGVsZWdhdGUpO1xyXG5cdH1cclxuXHRleHBvcnRzLnBhcnNlU2NyaXB0ID0gcGFyc2VTY3JpcHQ7XHJcblx0ZnVuY3Rpb24gdG9rZW5pemUoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcclxuXHQgICAgdmFyIHRva2VuaXplciA9IG5ldyB0b2tlbml6ZXJfMS5Ub2tlbml6ZXIoY29kZSwgb3B0aW9ucyk7XHJcblx0ICAgIHZhciB0b2tlbnM7XHJcblx0ICAgIHRva2VucyA9IFtdO1xyXG5cdCAgICB0cnkge1xyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbml6ZXIuZ2V0TmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0b2tlbikge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGRlbGVnYXRlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gZGVsZWdhdGUodG9rZW4pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgY2F0Y2ggKGUpIHtcclxuXHQgICAgICAgIHRva2VuaXplci5lcnJvckhhbmRsZXIudG9sZXJhdGUoZSk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHRva2VuaXplci5lcnJvckhhbmRsZXIudG9sZXJhbnQpIHtcclxuXHQgICAgICAgIHRva2Vucy5lcnJvcnMgPSB0b2tlbml6ZXIuZXJyb3JzKCk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIHRva2VucztcclxuXHR9XHJcblx0ZXhwb3J0cy50b2tlbml6ZSA9IHRva2VuaXplO1xyXG5cdHZhciBzeW50YXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblx0ZXhwb3J0cy5TeW50YXggPSBzeW50YXhfMS5TeW50YXg7XHJcblx0Ly8gU3luYyB3aXRoICouanNvbiBtYW5pZmVzdHMuXHJcblx0ZXhwb3J0cy52ZXJzaW9uID0gJzQuMC4wJztcclxuXG5cbi8qKiovIH0sXG4vKiAxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIHN5bnRheF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHR2YXIgQ29tbWVudEhhbmRsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDb21tZW50SGFuZGxlcigpIHtcclxuXHQgICAgICAgIHRoaXMuYXR0YWNoID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICB0aGlzLnN0YWNrID0gW107XHJcblx0ICAgICAgICB0aGlzLmxlYWRpbmcgPSBbXTtcclxuXHQgICAgICAgIHRoaXMudHJhaWxpbmcgPSBbXTtcclxuXHQgICAgfVxyXG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUuaW5zZXJ0SW5uZXJDb21tZW50cyA9IGZ1bmN0aW9uIChub2RlLCBtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgLy8gIGlubm5lckNvbW1lbnRzIGZvciBwcm9wZXJ0aWVzIGVtcHR5IGJsb2NrXHJcblx0ICAgICAgICAvLyAgYGZ1bmN0aW9uIGEoKSB7LyoqIGNvbW1lbnRzICoqXFwvfWBcclxuXHQgICAgICAgIGlmIChub2RlLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5CbG9ja1N0YXRlbWVudCAmJiBub2RlLmJvZHkubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGlubmVyQ29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5sZWFkaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMubGVhZGluZ1tpXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhLmVuZC5vZmZzZXQgPj0gZW50cnkuc3RhcnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlubmVyQ29tbWVudHMudW5zaGlmdChlbnRyeS5jb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubGVhZGluZy5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWlsaW5nLnNwbGljZShpLCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoaW5uZXJDb21tZW50cy5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgbm9kZS5pbm5lckNvbW1lbnRzID0gaW5uZXJDb21tZW50cztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS5maW5kVHJhaWxpbmdDb21tZW50cyA9IGZ1bmN0aW9uIChtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgdmFyIHRyYWlsaW5nQ29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgIGlmICh0aGlzLnRyYWlsaW5nLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cmFpbGluZy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZW50cnlfMSA9IHRoaXMudHJhaWxpbmdbaV07XHJcblx0ICAgICAgICAgICAgICAgIGlmIChlbnRyeV8xLnN0YXJ0ID49IG1ldGFkYXRhLmVuZC5vZmZzZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMudW5zaGlmdChlbnRyeV8xLmNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMudHJhaWxpbmcubGVuZ3RoID0gMDtcclxuXHQgICAgICAgICAgICByZXR1cm4gdHJhaWxpbmdDb21tZW50cztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcclxuXHQgICAgICAgIGlmIChlbnRyeSAmJiBlbnRyeS5ub2RlLnRyYWlsaW5nQ29tbWVudHMpIHtcclxuXHQgICAgICAgICAgICB2YXIgZmlyc3RDb21tZW50ID0gZW50cnkubm9kZS50cmFpbGluZ0NvbW1lbnRzWzBdO1xyXG5cdCAgICAgICAgICAgIGlmIChmaXJzdENvbW1lbnQgJiYgZmlyc3RDb21tZW50LnJhbmdlWzBdID49IG1ldGFkYXRhLmVuZC5vZmZzZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgdHJhaWxpbmdDb21tZW50cyA9IGVudHJ5Lm5vZGUudHJhaWxpbmdDb21tZW50cztcclxuXHQgICAgICAgICAgICAgICAgZGVsZXRlIGVudHJ5Lm5vZGUudHJhaWxpbmdDb21tZW50cztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdHJhaWxpbmdDb21tZW50cztcclxuXHQgICAgfTtcclxuXHQgICAgQ29tbWVudEhhbmRsZXIucHJvdG90eXBlLmZpbmRMZWFkaW5nQ29tbWVudHMgPSBmdW5jdGlvbiAobWV0YWRhdGEpIHtcclxuXHQgICAgICAgIHZhciBsZWFkaW5nQ29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgIHZhciB0YXJnZXQ7XHJcblx0ICAgICAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xyXG5cdCAgICAgICAgICAgIGlmIChlbnRyeSAmJiBlbnRyeS5zdGFydCA+PSBtZXRhZGF0YS5zdGFydC5vZmZzZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgdGFyZ2V0ID0gZW50cnkubm9kZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0YXJnZXQpIHtcclxuXHQgICAgICAgICAgICB2YXIgY291bnQgPSB0YXJnZXQubGVhZGluZ0NvbW1lbnRzID8gdGFyZ2V0LmxlYWRpbmdDb21tZW50cy5sZW5ndGggOiAwO1xyXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSBjb3VudCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gdGFyZ2V0LmxlYWRpbmdDb21tZW50c1tpXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQucmFuZ2VbMV0gPD0gbWV0YWRhdGEuc3RhcnQub2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWFkaW5nQ29tbWVudHMudW5zaGlmdChjb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRhcmdldC5sZWFkaW5nQ29tbWVudHMuc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICh0YXJnZXQubGVhZGluZ0NvbW1lbnRzICYmIHRhcmdldC5sZWFkaW5nQ29tbWVudHMubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXQubGVhZGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICByZXR1cm4gbGVhZGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVhZGluZy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG5cdCAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMubGVhZGluZ1tpXTtcclxuXHQgICAgICAgICAgICBpZiAoZW50cnkuc3RhcnQgPD0gbWV0YWRhdGEuc3RhcnQub2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgIGxlYWRpbmdDb21tZW50cy51bnNoaWZ0KGVudHJ5LmNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmxlYWRpbmcuc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBsZWFkaW5nQ29tbWVudHM7XHJcblx0ICAgIH07XHJcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS52aXNpdE5vZGUgPSBmdW5jdGlvbiAobm9kZSwgbWV0YWRhdGEpIHtcclxuXHQgICAgICAgIGlmIChub2RlLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5Qcm9ncmFtICYmIG5vZGUuYm9keS5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5pbnNlcnRJbm5lckNvbW1lbnRzKG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIHZhciB0cmFpbGluZ0NvbW1lbnRzID0gdGhpcy5maW5kVHJhaWxpbmdDb21tZW50cyhtZXRhZGF0YSk7XHJcblx0ICAgICAgICB2YXIgbGVhZGluZ0NvbW1lbnRzID0gdGhpcy5maW5kTGVhZGluZ0NvbW1lbnRzKG1ldGFkYXRhKTtcclxuXHQgICAgICAgIGlmIChsZWFkaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzID0gbGVhZGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRyYWlsaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgIG5vZGUudHJhaWxpbmdDb21tZW50cyA9IHRyYWlsaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLnN0YWNrLnB1c2goe1xyXG5cdCAgICAgICAgICAgIG5vZGU6IG5vZGUsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IG1ldGFkYXRhLnN0YXJ0Lm9mZnNldFxyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgIH07XHJcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgbWV0YWRhdGEpIHtcclxuXHQgICAgICAgIHZhciB0eXBlID0gKG5vZGUudHlwZVswXSA9PT0gJ0wnKSA/ICdMaW5lJyA6ICdCbG9jayc7XHJcblx0ICAgICAgICB2YXIgY29tbWVudCA9IHtcclxuXHQgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBub2RlLnZhbHVlXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgaWYgKG5vZGUucmFuZ2UpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50LnJhbmdlID0gbm9kZS5yYW5nZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChub2RlLmxvYykge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnQubG9jID0gbm9kZS5sb2M7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbW1lbnRzLnB1c2goY29tbWVudCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5hdHRhY2gpIHtcclxuXHQgICAgICAgICAgICB2YXIgZW50cnkgPSB7XHJcblx0ICAgICAgICAgICAgICAgIGNvbW1lbnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbm9kZS52YWx1ZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBbbWV0YWRhdGEuc3RhcnQub2Zmc2V0LCBtZXRhZGF0YS5lbmQub2Zmc2V0XVxyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogbWV0YWRhdGEuc3RhcnQub2Zmc2V0XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICBpZiAobm9kZS5sb2MpIHtcclxuXHQgICAgICAgICAgICAgICAgZW50cnkuY29tbWVudC5sb2MgPSBub2RlLmxvYztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgbm9kZS50eXBlID0gdHlwZTtcclxuXHQgICAgICAgICAgICB0aGlzLmxlYWRpbmcucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICAgICAgdGhpcy50cmFpbGluZy5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgQ29tbWVudEhhbmRsZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKG5vZGUsIG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICBpZiAobm9kZS50eXBlID09PSAnTGluZUNvbW1lbnQnKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy52aXNpdENvbW1lbnQobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnQmxvY2tDb21tZW50Jykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmlzaXRDb21tZW50KG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMuYXR0YWNoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy52aXNpdE5vZGUobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gQ29tbWVudEhhbmRsZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNvbW1lbnRIYW5kbGVyID0gQ29tbWVudEhhbmRsZXI7XHJcblxuXG4vKioqLyB9LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdGV4cG9ydHMuU3ludGF4ID0ge1xyXG5cdCAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJyxcclxuXHQgICAgQXNzaWdubWVudFBhdHRlcm46ICdBc3NpZ25tZW50UGF0dGVybicsXHJcblx0ICAgIEFycmF5RXhwcmVzc2lvbjogJ0FycmF5RXhwcmVzc2lvbicsXHJcblx0ICAgIEFycmF5UGF0dGVybjogJ0FycmF5UGF0dGVybicsXHJcblx0ICAgIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiAnQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nLFxyXG5cdCAgICBBd2FpdEV4cHJlc3Npb246ICdBd2FpdEV4cHJlc3Npb24nLFxyXG5cdCAgICBCbG9ja1N0YXRlbWVudDogJ0Jsb2NrU3RhdGVtZW50JyxcclxuXHQgICAgQmluYXJ5RXhwcmVzc2lvbjogJ0JpbmFyeUV4cHJlc3Npb24nLFxyXG5cdCAgICBCcmVha1N0YXRlbWVudDogJ0JyZWFrU3RhdGVtZW50JyxcclxuXHQgICAgQ2FsbEV4cHJlc3Npb246ICdDYWxsRXhwcmVzc2lvbicsXHJcblx0ICAgIENhdGNoQ2xhdXNlOiAnQ2F0Y2hDbGF1c2UnLFxyXG5cdCAgICBDbGFzc0JvZHk6ICdDbGFzc0JvZHknLFxyXG5cdCAgICBDbGFzc0RlY2xhcmF0aW9uOiAnQ2xhc3NEZWNsYXJhdGlvbicsXHJcblx0ICAgIENsYXNzRXhwcmVzc2lvbjogJ0NsYXNzRXhwcmVzc2lvbicsXHJcblx0ICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicsXHJcblx0ICAgIENvbnRpbnVlU3RhdGVtZW50OiAnQ29udGludWVTdGF0ZW1lbnQnLFxyXG5cdCAgICBEb1doaWxlU3RhdGVtZW50OiAnRG9XaGlsZVN0YXRlbWVudCcsXHJcblx0ICAgIERlYnVnZ2VyU3RhdGVtZW50OiAnRGVidWdnZXJTdGF0ZW1lbnQnLFxyXG5cdCAgICBFbXB0eVN0YXRlbWVudDogJ0VtcHR5U3RhdGVtZW50JyxcclxuXHQgICAgRXhwb3J0QWxsRGVjbGFyYXRpb246ICdFeHBvcnRBbGxEZWNsYXJhdGlvbicsXHJcblx0ICAgIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjogJ0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbicsXHJcblx0ICAgIEV4cG9ydE5hbWVkRGVjbGFyYXRpb246ICdFeHBvcnROYW1lZERlY2xhcmF0aW9uJyxcclxuXHQgICAgRXhwb3J0U3BlY2lmaWVyOiAnRXhwb3J0U3BlY2lmaWVyJyxcclxuXHQgICAgRXhwcmVzc2lvblN0YXRlbWVudDogJ0V4cHJlc3Npb25TdGF0ZW1lbnQnLFxyXG5cdCAgICBGb3JTdGF0ZW1lbnQ6ICdGb3JTdGF0ZW1lbnQnLFxyXG5cdCAgICBGb3JPZlN0YXRlbWVudDogJ0Zvck9mU3RhdGVtZW50JyxcclxuXHQgICAgRm9ySW5TdGF0ZW1lbnQ6ICdGb3JJblN0YXRlbWVudCcsXHJcblx0ICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246ICdGdW5jdGlvbkRlY2xhcmF0aW9uJyxcclxuXHQgICAgRnVuY3Rpb25FeHByZXNzaW9uOiAnRnVuY3Rpb25FeHByZXNzaW9uJyxcclxuXHQgICAgSWRlbnRpZmllcjogJ0lkZW50aWZpZXInLFxyXG5cdCAgICBJZlN0YXRlbWVudDogJ0lmU3RhdGVtZW50JyxcclxuXHQgICAgSW1wb3J0RGVjbGFyYXRpb246ICdJbXBvcnREZWNsYXJhdGlvbicsXHJcblx0ICAgIEltcG9ydERlZmF1bHRTcGVjaWZpZXI6ICdJbXBvcnREZWZhdWx0U3BlY2lmaWVyJyxcclxuXHQgICAgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyOiAnSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyJyxcclxuXHQgICAgSW1wb3J0U3BlY2lmaWVyOiAnSW1wb3J0U3BlY2lmaWVyJyxcclxuXHQgICAgTGl0ZXJhbDogJ0xpdGVyYWwnLFxyXG5cdCAgICBMYWJlbGVkU3RhdGVtZW50OiAnTGFiZWxlZFN0YXRlbWVudCcsXHJcblx0ICAgIExvZ2ljYWxFeHByZXNzaW9uOiAnTG9naWNhbEV4cHJlc3Npb24nLFxyXG5cdCAgICBNZW1iZXJFeHByZXNzaW9uOiAnTWVtYmVyRXhwcmVzc2lvbicsXHJcblx0ICAgIE1ldGFQcm9wZXJ0eTogJ01ldGFQcm9wZXJ0eScsXHJcblx0ICAgIE1ldGhvZERlZmluaXRpb246ICdNZXRob2REZWZpbml0aW9uJyxcclxuXHQgICAgTmV3RXhwcmVzc2lvbjogJ05ld0V4cHJlc3Npb24nLFxyXG5cdCAgICBPYmplY3RFeHByZXNzaW9uOiAnT2JqZWN0RXhwcmVzc2lvbicsXHJcblx0ICAgIE9iamVjdFBhdHRlcm46ICdPYmplY3RQYXR0ZXJuJyxcclxuXHQgICAgUHJvZ3JhbTogJ1Byb2dyYW0nLFxyXG5cdCAgICBQcm9wZXJ0eTogJ1Byb3BlcnR5JyxcclxuXHQgICAgUmVzdEVsZW1lbnQ6ICdSZXN0RWxlbWVudCcsXHJcblx0ICAgIFJldHVyblN0YXRlbWVudDogJ1JldHVyblN0YXRlbWVudCcsXHJcblx0ICAgIFNlcXVlbmNlRXhwcmVzc2lvbjogJ1NlcXVlbmNlRXhwcmVzc2lvbicsXHJcblx0ICAgIFNwcmVhZEVsZW1lbnQ6ICdTcHJlYWRFbGVtZW50JyxcclxuXHQgICAgU3VwZXI6ICdTdXBlcicsXHJcblx0ICAgIFN3aXRjaENhc2U6ICdTd2l0Y2hDYXNlJyxcclxuXHQgICAgU3dpdGNoU3RhdGVtZW50OiAnU3dpdGNoU3RhdGVtZW50JyxcclxuXHQgICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOiAnVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uJyxcclxuXHQgICAgVGVtcGxhdGVFbGVtZW50OiAnVGVtcGxhdGVFbGVtZW50JyxcclxuXHQgICAgVGVtcGxhdGVMaXRlcmFsOiAnVGVtcGxhdGVMaXRlcmFsJyxcclxuXHQgICAgVGhpc0V4cHJlc3Npb246ICdUaGlzRXhwcmVzc2lvbicsXHJcblx0ICAgIFRocm93U3RhdGVtZW50OiAnVGhyb3dTdGF0ZW1lbnQnLFxyXG5cdCAgICBUcnlTdGF0ZW1lbnQ6ICdUcnlTdGF0ZW1lbnQnLFxyXG5cdCAgICBVbmFyeUV4cHJlc3Npb246ICdVbmFyeUV4cHJlc3Npb24nLFxyXG5cdCAgICBVcGRhdGVFeHByZXNzaW9uOiAnVXBkYXRlRXhwcmVzc2lvbicsXHJcblx0ICAgIFZhcmlhYmxlRGVjbGFyYXRpb246ICdWYXJpYWJsZURlY2xhcmF0aW9uJyxcclxuXHQgICAgVmFyaWFibGVEZWNsYXJhdG9yOiAnVmFyaWFibGVEZWNsYXJhdG9yJyxcclxuXHQgICAgV2hpbGVTdGF0ZW1lbnQ6ICdXaGlsZVN0YXRlbWVudCcsXHJcblx0ICAgIFdpdGhTdGF0ZW1lbnQ6ICdXaXRoU3RhdGVtZW50JyxcclxuXHQgICAgWWllbGRFeHByZXNzaW9uOiAnWWllbGRFeHByZXNzaW9uJ1xyXG5cdH07XHJcblxuXG4vKioqLyB9LFxuLyogMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdHZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuXHQgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuXHQgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuXHQgICAgfTtcclxuXHR9KSgpO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgY2hhcmFjdGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cdHZhciBKU1hOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHR2YXIganN4X3N5bnRheF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHR2YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcblx0dmFyIHBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuXHR2YXIgdG9rZW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG5cdHZhciB4aHRtbF9lbnRpdGllc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XHJcblx0dG9rZW5fMS5Ub2tlbk5hbWVbMTAwIC8qIElkZW50aWZpZXIgKi9dID0gJ0pTWElkZW50aWZpZXInO1xyXG5cdHRva2VuXzEuVG9rZW5OYW1lWzEwMSAvKiBUZXh0ICovXSA9ICdKU1hUZXh0JztcclxuXHQvLyBGdWxseSBxdWFsaWZpZWQgZWxlbWVudCBuYW1lLCBlLmcuIDxzdmc6cGF0aD4gcmV0dXJucyBcInN2ZzpwYXRoXCJcclxuXHRmdW5jdGlvbiBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShlbGVtZW50TmFtZSkge1xyXG5cdCAgICB2YXIgcXVhbGlmaWVkTmFtZTtcclxuXHQgICAgc3dpdGNoIChlbGVtZW50TmFtZS50eXBlKSB7XHJcblx0ICAgICAgICBjYXNlIGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYSWRlbnRpZmllcjpcclxuXHQgICAgICAgICAgICB2YXIgaWQgPSBlbGVtZW50TmFtZTtcclxuXHQgICAgICAgICAgICBxdWFsaWZpZWROYW1lID0gaWQubmFtZTtcclxuXHQgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIGNhc2UganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hOYW1lc3BhY2VkTmFtZTpcclxuXHQgICAgICAgICAgICB2YXIgbnMgPSBlbGVtZW50TmFtZTtcclxuXHQgICAgICAgICAgICBxdWFsaWZpZWROYW1lID0gZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUobnMubmFtZXNwYWNlKSArICc6JyArXHJcblx0ICAgICAgICAgICAgICAgIGdldFF1YWxpZmllZEVsZW1lbnROYW1lKG5zLm5hbWUpO1xyXG5cdCAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgY2FzZSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWE1lbWJlckV4cHJlc3Npb246XHJcblx0ICAgICAgICAgICAgdmFyIGV4cHIgPSBlbGVtZW50TmFtZTtcclxuXHQgICAgICAgICAgICBxdWFsaWZpZWROYW1lID0gZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUoZXhwci5vYmplY3QpICsgJy4nICtcclxuXHQgICAgICAgICAgICAgICAgZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUoZXhwci5wcm9wZXJ0eSk7XHJcblx0ICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICBicmVhaztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gcXVhbGlmaWVkTmFtZTtcclxuXHR9XHJcblx0dmFyIEpTWFBhcnNlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcblx0ICAgIF9fZXh0ZW5kcyhKU1hQYXJzZXIsIF9zdXBlcik7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWFBhcnNlcihjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB8fCB0aGlzO1xyXG5cdCAgICB9XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VQcmltYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLm1hdGNoKCc8JykgPyB0aGlzLnBhcnNlSlNYUm9vdCgpIDogX3N1cGVyLnByb3RvdHlwZS5wYXJzZVByaW1hcnlFeHByZXNzaW9uLmNhbGwodGhpcyk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuc3RhcnRKU1ggPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAvLyBVbndpbmQgdGhlIHNjYW5uZXIgYmVmb3JlIHRoZSBsb29rYWhlYWQgdG9rZW4uXHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIuaW5kZXggPSB0aGlzLnN0YXJ0TWFya2VyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIgPSB0aGlzLnN0YXJ0TWFya2VyLmxpbmU7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIubGluZVN0YXJ0ID0gdGhpcy5zdGFydE1hcmtlci5pbmRleCAtIHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmZpbmlzaEpTWCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIC8vIFByaW1lIHRoZSBuZXh0IGxvb2thaGVhZC5cclxuXHQgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucmVlbnRlckpTWCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRKU1goKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCd9Jyk7XHJcblx0ICAgICAgICAvLyBQb3AgdGhlIGNsb3NpbmcgJ30nIGFkZGVkIGZyb20gdGhlIGxvb2thaGVhZC5cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy50b2tlbnMpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wb3AoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVKU1hOb2RlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5jb2xsZWN0Q29tbWVudHMoKTtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IHRoaXMuc2Nhbm5lci5pbmRleCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBjb2x1bW46IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnRcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuY3JlYXRlSlNYQ2hpbGROb2RlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBpbmRleDogdGhpcy5zY2FubmVyLmluZGV4LFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5zY2FuWEhUTUxFbnRpdHkgPSBmdW5jdGlvbiAocXVvdGUpIHtcclxuXHQgICAgICAgIHZhciByZXN1bHQgPSAnJic7XHJcblx0ICAgICAgICB2YXIgdmFsaWQgPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIHRlcm1pbmF0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBudW1lcmljID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgaGV4ID0gZmFsc2U7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSAmJiB2YWxpZCAmJiAhdGVybWluYXRlZCkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4XTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09IHF1b3RlKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0ZXJtaW5hdGVkID0gKGNoID09PSAnOycpO1xyXG5cdCAgICAgICAgICAgIHJlc3VsdCArPSBjaDtcclxuXHQgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChyZXN1bHQubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiAnJiMxMjM7J1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyaWMgPSAoY2ggPT09ICcjJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bWVyaWMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiAnJiN4NDE7J1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZXggPSAoY2ggPT09ICd4Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkID0gaGV4IHx8IGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtZXJpYyA9IG51bWVyaWMgJiYgIWhleDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkID0gdmFsaWQgJiYgIShudW1lcmljICYmICFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkID0gdmFsaWQgJiYgIShoZXggJiYgIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0hleERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh2YWxpZCAmJiB0ZXJtaW5hdGVkICYmIHJlc3VsdC5sZW5ndGggPiAyKSB7XHJcblx0ICAgICAgICAgICAgLy8gZS5nLiAnJiN4NDE7JyBiZWNvbWVzIGp1c3QgJyN4NDEnXHJcblx0ICAgICAgICAgICAgdmFyIHN0ciA9IHJlc3VsdC5zdWJzdHIoMSwgcmVzdWx0Lmxlbmd0aCAtIDIpO1xyXG5cdCAgICAgICAgICAgIGlmIChudW1lcmljICYmIHN0ci5sZW5ndGggPiAxKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTApKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoaGV4ICYmIHN0ci5sZW5ndGggPiAyKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoJzAnICsgc3RyLnN1YnN0cigxKSwgMTYpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoIW51bWVyaWMgJiYgIWhleCAmJiB4aHRtbF9lbnRpdGllc18xLlhIVE1MRW50aXRpZXNbc3RyXSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSB4aHRtbF9lbnRpdGllc18xLlhIVE1MRW50aXRpZXNbc3RyXTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBTY2FuIHRoZSBuZXh0IEpTWCB0b2tlbi4gVGhpcyByZXBsYWNlcyBTY2FubmVyI2xleCB3aGVuIGluIEpTWCBtb2RlLlxyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmxleEpTWCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjcCA9IHRoaXMuc2Nhbm5lci5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLnNjYW5uZXIuaW5kZXgpO1xyXG5cdCAgICAgICAgLy8gPCA+IC8gOiA9IHsgfVxyXG5cdCAgICAgICAgaWYgKGNwID09PSA2MCB8fCBjcCA9PT0gNjIgfHwgY3AgPT09IDQ3IHx8IGNwID09PSA1OCB8fCBjcCA9PT0gNjEgfHwgY3AgPT09IDEyMyB8fCBjcCA9PT0gMTI1KSB7XHJcblx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogNyAvKiBQdW5jdHVhdG9yICovLFxyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnNjYW5uZXIuaW5kZXggLSAxLFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuc2Nhbm5lci5pbmRleFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBcIiAnXHJcblx0ICAgICAgICBpZiAoY3AgPT09IDM0IHx8IGNwID09PSAzOSkge1xyXG5cdCAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICB2YXIgcXVvdGUgPSB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICB2YXIgc3RyID0gJyc7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKCF0aGlzLnNjYW5uZXIuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnJicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0ciArPSB0aGlzLnNjYW5YSFRNTEVudGl0eShxdW90ZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogOCAvKiBTdHJpbmdMaXRlcmFsICovLFxyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogc3RyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLnNjYW5uZXIubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIC4uLiBvciAuXHJcblx0ICAgICAgICBpZiAoY3AgPT09IDQ2KSB7XHJcblx0ICAgICAgICAgICAgdmFyIG4xID0gdGhpcy5zY2FubmVyLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuc2Nhbm5lci5pbmRleCArIDEpO1xyXG5cdCAgICAgICAgICAgIHZhciBuMiA9IHRoaXMuc2Nhbm5lci5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLnNjYW5uZXIuaW5kZXggKyAyKTtcclxuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSAobjEgPT09IDQ2ICYmIG4yID09PSA0NikgPyAnLi4uJyA6ICcuJztcclxuXHQgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdGhpcy5zY2FubmVyLmluZGV4ICs9IHZhbHVlLmxlbmd0aDtcclxuXHQgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiA3IC8qIFB1bmN0dWF0b3IgKi8sXHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5zY2FubmVyLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuc2Nhbm5lci5pbmRleFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBgXHJcblx0ICAgICAgICBpZiAoY3AgPT09IDk2KSB7XHJcblx0ICAgICAgICAgICAgLy8gT25seSBwbGFjZWhvbGRlciwgc2luY2UgaXQgd2lsbCBiZSByZXNjYW5uZWQgYXMgYSByZWFsIGFzc2lnbm1lbnQgZXhwcmVzc2lvbi5cclxuXHQgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiAxMCAvKiBUZW1wbGF0ZSAqLyxcclxuXHQgICAgICAgICAgICAgICAgdmFsdWU6ICcnLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLnNjYW5uZXIubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5zY2FubmVyLmluZGV4LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuc2Nhbm5lci5pbmRleFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBJZGVudGlmZXIgY2FuIG5vdCBjb250YWluIGJhY2tzbGFzaCAoY2hhciBjb2RlIDkyKS5cclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQoY3ApICYmIChjcCAhPT0gOTIpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc2Nhbm5lci5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLnNjYW5uZXIuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclBhcnQoY2gpICYmIChjaCAhPT0gOTIpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gNDUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEh5cGhlbiAoY2hhciBjb2RlIDQ1KSBjYW4gYmUgcGFydCBvZiBhbiBpZGVudGlmaWVyLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLnNjYW5uZXIuc291cmNlLnNsaWNlKHN0YXJ0LCB0aGlzLnNjYW5uZXIuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IDEwMCAvKiBJZGVudGlmaWVyICovLFxyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogaWQsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB0aGlzLnNjYW5uZXIuaW5kZXhcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbm5lci5sZXgoKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5uZXh0SlNYVG9rZW4gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmNvbGxlY3RDb21tZW50cygpO1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sZXhKU1goKTtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy50b2tlbnMpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHRoaXMuY29udmVydFRva2VuKHRva2VuKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdG9rZW47XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUubmV4dEpTWFRleHQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgdGV4dCA9ICcnO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLnNjYW5uZXIuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleF07XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAneycgfHwgY2ggPT09ICc8Jykge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdGV4dCArPSBjaDtcclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleF0gPT09ICdcXG4nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIubGluZVN0YXJ0ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHtcclxuXHQgICAgICAgICAgICB0eXBlOiAxMDEgLyogVGV4dCAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogdGV4dCxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgaWYgKCh0ZXh0Lmxlbmd0aCA+IDApICYmIHRoaXMuY29uZmlnLnRva2Vucykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2godGhpcy5jb252ZXJ0VG9rZW4odG9rZW4pKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0b2tlbjtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wZWVrSlNYVG9rZW4gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnNjYW5uZXIuc2F2ZVN0YXRlKCk7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIuc2NhbkNvbW1lbnRzKCk7XHJcblx0ICAgICAgICB2YXIgbmV4dCA9IHRoaXMubGV4SlNYKCk7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIucmVzdG9yZVN0YXRlKHN0YXRlKTtcclxuXHQgICAgICAgIHJldHVybiBuZXh0O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBFeHBlY3QgdGhlIG5leHQgSlNYIHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cclxuXHQgICAgLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuZXhwZWN0SlNYID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRKU1hUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IDcgLyogUHVuY3R1YXRvciAqLyB8fCB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgSlNYIHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLm1hdGNoSlNYID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0ICAgICAgICB2YXIgbmV4dCA9IHRoaXMucGVla0pTWFRva2VuKCk7XHJcblx0ICAgICAgICByZXR1cm4gbmV4dC50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgbmV4dC52YWx1ZSA9PT0gdmFsdWU7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dEpTWFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gMTAwIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWElkZW50aWZpZXIodG9rZW4udmFsdWUpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEVsZW1lbnROYW1lID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHZhciBlbGVtZW50TmFtZSA9IHRoaXMucGFyc2VKU1hJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEpTWCgnOicpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGVsZW1lbnROYW1lO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc6Jyk7XHJcblx0ICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHRoaXMucGFyc2VKU1hJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgZWxlbWVudE5hbWUgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWE5hbWVzcGFjZWROYW1lKG5hbWVzcGFjZSwgbmFtZV8xKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoSlNYKCcuJykpIHtcclxuXHQgICAgICAgICAgICB3aGlsZSAodGhpcy5tYXRjaEpTWCgnLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSBlbGVtZW50TmFtZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJy4nKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZUpTWElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICAgICAgZWxlbWVudE5hbWUgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWE1lbWJlckV4cHJlc3Npb24ob2JqZWN0LCBwcm9wZXJ0eSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBlbGVtZW50TmFtZTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEF0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWU7XHJcblx0ICAgICAgICB2YXIgaWRlbnRpZmllciA9IHRoaXMucGFyc2VKU1hJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEpTWCgnOicpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGlkZW50aWZpZXI7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJzonKTtcclxuXHQgICAgICAgICAgICB2YXIgbmFtZV8yID0gdGhpcy5wYXJzZUpTWElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hOYW1lc3BhY2VkTmFtZShuYW1lc3BhY2UsIG5hbWVfMikpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9IGlkZW50aWZpZXI7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gYXR0cmlidXRlTmFtZTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWFN0cmluZ0xpdGVyYWxBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0SlNYVG9rZW4oKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSA4IC8qIFN0cmluZ0xpdGVyYWwgKi8pIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkxpdGVyYWwodG9rZW4udmFsdWUsIHJhdykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYRXhwcmVzc2lvbkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgneycpO1xyXG5cdCAgICAgICAgdGhpcy5maW5pc2hKU1goKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IoJ0pTWCBhdHRyaWJ1dGVzIG11c3Qgb25seSBiZSBhc3NpZ25lZCBhIG5vbi1lbXB0eSBleHByZXNzaW9uJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdGhpcy5yZWVudGVySlNYKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hFeHByZXNzaW9uQ29udGFpbmVyKGV4cHJlc3Npb24pKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEF0dHJpYnV0ZVZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hKU1goJ3snKSA/IHRoaXMucGFyc2VKU1hFeHByZXNzaW9uQXR0cmlidXRlKCkgOlxyXG5cdCAgICAgICAgICAgIHRoaXMubWF0Y2hKU1goJzwnKSA/IHRoaXMucGFyc2VKU1hFbGVtZW50KCkgOiB0aGlzLnBhcnNlSlNYU3RyaW5nTGl0ZXJhbEF0dHJpYnV0ZSgpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYTmFtZVZhbHVlQXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZUpTWEF0dHJpYnV0ZU5hbWUoKTtcclxuXHQgICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEpTWCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJz0nKTtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VKU1hBdHRyaWJ1dGVWYWx1ZSgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYQXR0cmlidXRlKG5hbWUsIHZhbHVlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hTcHJlYWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJ3snKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCcuLi4nKTtcclxuXHQgICAgICAgIHRoaXMuZmluaXNoSlNYKCk7XHJcblx0ICAgICAgICB2YXIgYXJndW1lbnQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHRoaXMucmVlbnRlckpTWCgpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYU3ByZWFkQXR0cmlidXRlKGFyZ3VtZW50KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaEpTWCgnLycpICYmICF0aGlzLm1hdGNoSlNYKCc+JykpIHtcclxuXHQgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5tYXRjaEpTWCgneycpID8gdGhpcy5wYXJzZUpTWFNwcmVhZEF0dHJpYnV0ZSgpIDpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUpTWE5hbWVWYWx1ZUF0dHJpYnV0ZSgpO1xyXG5cdCAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaChhdHRyaWJ1dGUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hPcGVuaW5nRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPCcpO1xyXG5cdCAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlSlNYRWxlbWVudE5hbWUoKTtcclxuXHQgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5wYXJzZUpTWEF0dHJpYnV0ZXMoKTtcclxuXHQgICAgICAgIHZhciBzZWxmQ2xvc2luZyA9IHRoaXMubWF0Y2hKU1goJy8nKTtcclxuXHQgICAgICAgIGlmIChzZWxmQ2xvc2luZykge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCcvJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPicpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYT3BlbmluZ0VsZW1lbnQobmFtZSwgc2VsZkNsb3NpbmcsIGF0dHJpYnV0ZXMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEJvdW5kYXJ5RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPCcpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hKU1goJy8nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCcvJyk7XHJcblx0ICAgICAgICAgICAgdmFyIG5hbWVfMyA9IHRoaXMucGFyc2VKU1hFbGVtZW50TmFtZSgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc+Jyk7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYQ2xvc2luZ0VsZW1lbnQobmFtZV8zKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VKU1hFbGVtZW50TmFtZSgpO1xyXG5cdCAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLnBhcnNlSlNYQXR0cmlidXRlcygpO1xyXG5cdCAgICAgICAgdmFyIHNlbGZDbG9zaW5nID0gdGhpcy5tYXRjaEpTWCgnLycpO1xyXG5cdCAgICAgICAgaWYgKHNlbGZDbG9zaW5nKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJy8nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc+Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hPcGVuaW5nRWxlbWVudChuYW1lLCBzZWxmQ2xvc2luZywgYXR0cmlidXRlcykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYRW1wdHlFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWENoaWxkTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5jb2xsZWN0Q29tbWVudHMoKTtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWEVtcHR5RXhwcmVzc2lvbigpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEV4cHJlc3Npb25Db250YWluZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJ3snKTtcclxuXHQgICAgICAgIHZhciBleHByZXNzaW9uO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hKU1goJ30nKSkge1xyXG5cdCAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlSlNYRW1wdHlFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJ30nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZmluaXNoSlNYKCk7XHJcblx0ICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIHRoaXMucmVlbnRlckpTWCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYRXhwcmVzc2lvbkNvbnRhaW5lcihleHByZXNzaW9uKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLnNjYW5uZXIuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYQ2hpbGROb2RlKCk7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0SlNYVGV4dCgpO1xyXG5cdCAgICAgICAgICAgIGlmICh0b2tlbi5zdGFydCA8IHRva2VuLmVuZCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYVGV4dCh0b2tlbi52YWx1ZSwgcmF3KSk7XHJcblx0ICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXhdID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMucGFyc2VKU1hFeHByZXNzaW9uQ29udGFpbmVyKCk7XHJcblx0ICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY29udGFpbmVyKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBjaGlsZHJlbjtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvbXBsZXhKU1hFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XHJcblx0ICAgICAgICB2YXIgc3RhY2sgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgZWwuY2hpbGRyZW4gPSBlbC5jaGlsZHJlbi5jb25jYXQodGhpcy5wYXJzZUpTWENoaWxkcmVuKCkpO1xyXG5cdCAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hDaGlsZE5vZGUoKTtcclxuXHQgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VKU1hCb3VuZGFyeUVsZW1lbnQoKTtcclxuXHQgICAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWE9wZW5pbmdFbGVtZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBvcGVuaW5nID0gZWxlbWVudDtcclxuXHQgICAgICAgICAgICAgICAgaWYgKG9wZW5pbmcuc2VsZkNsb3NpbmcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYRWxlbWVudChvcGVuaW5nLCBbXSwgbnVsbCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZWwuY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGVsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVsID0geyBub2RlOiBub2RlLCBvcGVuaW5nOiBvcGVuaW5nLCBjbG9zaW5nOiBudWxsLCBjaGlsZHJlbjogW10gfTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWENsb3NpbmdFbGVtZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgIGVsLmNsb3NpbmcgPSBlbGVtZW50O1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgb3Blbl8xID0gZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUoZWwub3BlbmluZy5uYW1lKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNsb3NlXzEgPSBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShlbC5jbG9zaW5nLm5hbWUpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAob3Blbl8xICE9PSBjbG9zZV8xKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IoJ0V4cGVjdGVkIGNvcnJlc3BvbmRpbmcgSlNYIGNsb3NpbmcgdGFnIGZvciAlMCcsIG9wZW5fMSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuZmluYWxpemUoZWwubm9kZSwgbmV3IEpTWE5vZGUuSlNYRWxlbWVudChlbC5vcGVuaW5nLCBlbC5jaGlsZHJlbiwgZWwuY2xvc2luZykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZWwgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVsLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBlbDtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIG9wZW5pbmcgPSB0aGlzLnBhcnNlSlNYT3BlbmluZ0VsZW1lbnQoKTtcclxuXHQgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xyXG5cdCAgICAgICAgdmFyIGNsb3NpbmcgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKCFvcGVuaW5nLnNlbGZDbG9zaW5nKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5wYXJzZUNvbXBsZXhKU1hFbGVtZW50KHsgbm9kZTogbm9kZSwgb3BlbmluZzogb3BlbmluZywgY2xvc2luZzogY2xvc2luZywgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xyXG5cdCAgICAgICAgICAgIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XHJcblx0ICAgICAgICAgICAgY2xvc2luZyA9IGVsLmNsb3Npbmc7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hFbGVtZW50KG9wZW5pbmcsIGNoaWxkcmVuLCBjbG9zaW5nKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hSb290ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgLy8gUG9wIHRoZSBvcGVuaW5nICc8JyBhZGRlZCBmcm9tIHRoZSBsb29rYWhlYWQuXHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9rZW5zKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucG9wKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0SlNYKCk7XHJcblx0ICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VKU1hFbGVtZW50KCk7XHJcblx0ICAgICAgICB0aGlzLmZpbmlzaEpTWCgpO1xyXG5cdCAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuaXNTdGFydE9mRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmlzU3RhcnRPZkV4cHJlc3Npb24uY2FsbCh0aGlzKSB8fCB0aGlzLm1hdGNoKCc8Jyk7XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBKU1hQYXJzZXI7XHJcblx0fShwYXJzZXJfMS5QYXJzZXIpKTtcclxuXHRleHBvcnRzLkpTWFBhcnNlciA9IEpTWFBhcnNlcjtcclxuXG5cbi8qKiovIH0sXG4vKiA0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0Ly8gU2VlIGFsc28gdG9vbHMvZ2VuZXJhdGUtdW5pY29kZS1yZWdleC5qcy5cclxuXHR2YXIgUmVnZXggPSB7XHJcblx0ICAgIC8vIFVuaWNvZGUgdjguMC4wIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OlxyXG5cdCAgICBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDogL1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCNFxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlCLVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFRlxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRFxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0QVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRlxcdURGRDEtXFx1REZENV18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwXFx1REUxMC1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OFxcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMl18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVERDAzLVxcdUREMjZcXHVERDUwLVxcdURENzJcXHVERDc2XFx1REQ4My1cXHVEREIyXFx1RERDMS1cXHVEREM0XFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMkJcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERURFXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0RcXHVERjUwXFx1REY1RC1cXHVERjYxXXxcXHVEODA1W1xcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERBRVxcdURERDgtXFx1REREQlxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTgwLVxcdURFQUFcXHVERjAwLVxcdURGMTldfFxcdUQ4MDZbXFx1RENBMC1cXHVEQ0RGXFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY0MC1cXHVERjQzXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTBcXHVERjkzLVxcdURGOUZdfFxcdUQ4MkNbXFx1REMwMFxcdURDMDFdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF0vLFxyXG5cdCAgICAvLyBVbmljb2RlIHY4LjAuMCBOb25Bc2NpaUlkZW50aWZpZXJQYXJ0OlxyXG5cdCAgICBOb25Bc2NpaUlkZW50aWZpZXJQYXJ0OiAvW1xceEFBXFx4QjVcXHhCN1xceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODYtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjY5XFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDc0QVxcdTA3NEQtXFx1MDdCMVxcdTA3QzAtXFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MkRcXHUwODQwLVxcdTA4NUJcXHUwOEEwLVxcdTA4QjRcXHUwOEUzLVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTBBMDEtXFx1MEEwM1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkMtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRDBcXHUwQUUwLVxcdTBBRTNcXHUwQUU2LVxcdTBBRUZcXHUwQUY5XFx1MEIwMS1cXHUwQjAzXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0MtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNjYtXFx1MEI2RlxcdTBCNzFcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQwXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDAtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM1OC1cXHUwQzVBXFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MS1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDAxLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNELVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU3XFx1MEQ1Ri1cXHUwRDYzXFx1MEQ2Ni1cXHUwRDZGXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4MlxcdTBEODNcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREU2LVxcdTBERUZcXHUwREYyXFx1MERGM1xcdTBFMDEtXFx1MEUzQVxcdTBFNDAtXFx1MEU0RVxcdTBFNTAtXFx1MEU1OVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUI5XFx1MEVCQi1cXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFQzgtXFx1MEVDRFxcdTBFRDAtXFx1MEVEOVxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjE4XFx1MEYxOVxcdTBGMjAtXFx1MEYyOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0UtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGNzEtXFx1MEY4NFxcdTBGODYtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDAwLVxcdTEwNDlcXHUxMDUwLVxcdTEwOURcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM1RC1cXHUxMzVGXFx1MTM2OS1cXHUxMzcxXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzE0XFx1MTcyMC1cXHUxNzM0XFx1MTc0MC1cXHUxNzUzXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3RDNcXHUxN0Q3XFx1MTdEQ1xcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxODBCLVxcdTE4MERcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5M0JcXHUxOTQ2LVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxOUQwLVxcdTE5REFcXHUxQTAwLVxcdTFBMUJcXHUxQTIwLVxcdTFBNUVcXHUxQTYwLVxcdTFBN0NcXHUxQTdGLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQUE3XFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjRCXFx1MUI1MC1cXHUxQjU5XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQkYzXFx1MUMwMC1cXHUxQzM3XFx1MUM0MC1cXHUxQzQ5XFx1MUM0RC1cXHUxQzdEXFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0Y2XFx1MUNGOFxcdTFDRjlcXHUxRDAwLVxcdTFERjVcXHUxREZDLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAwQ1xcdTIwMERcXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ3Ri1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkRFMC1cXHUyREZGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDJGXFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5OS1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY3Ri1cXHVBNkYxXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FEXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEM0XFx1QThEMC1cXHVBOEQ5XFx1QThFMC1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTAwLVxcdUE5MkRcXHVBOTMwLVxcdUE5NTNcXHVBOTYwLVxcdUE5N0NcXHVBOTgwLVxcdUE5QzBcXHVBOUNGLVxcdUE5RDlcXHVBOUUwLVxcdUE5RkVcXHVBQTAwLVxcdUFBMzZcXHVBQTQwLVxcdUFBNERcXHVBQTUwLVxcdUFBNTlcXHVBQTYwLVxcdUFBNzZcXHVBQTdBLVxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUZcXHVBQUYyLVxcdUFBRjZcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMUQtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGXFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjEwLVxcdUZGMTlcXHVGRjIxLVxcdUZGM0FcXHVGRjNGXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQ0MC1cXHVERDc0XFx1RERGRFxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURFRTBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNEFcXHVERjUwLVxcdURGN0FcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1RENBMC1cXHVEQ0E5XFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMC1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTM4LVxcdURFM0FcXHVERTNGXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU2XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OFxcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMl18XFx1RDgwNFtcXHVEQzAwLVxcdURDNDZcXHVEQzY2LVxcdURDNkZcXHVEQzdGLVxcdURDQkFcXHVEQ0QwLVxcdURDRThcXHVEQ0YwLVxcdURDRjlcXHVERDAwLVxcdUREMzRcXHVERDM2LVxcdUREM0ZcXHVERDUwLVxcdURENzNcXHVERDc2XFx1REQ4MC1cXHVEREM0XFx1RERDQS1cXHVERENDXFx1REREMC1cXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUzN1xcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFRUFcXHVERUYwLVxcdURFRjlcXHVERjAwLVxcdURGMDNcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzQy1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjUwXFx1REY1N1xcdURGNUQtXFx1REY2M1xcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgwNVtcXHVEQzgwLVxcdURDQzVcXHVEQ0M3XFx1RENEMC1cXHVEQ0Q5XFx1REQ4MC1cXHVEREI1XFx1RERCOC1cXHVEREMwXFx1REREOC1cXHVEREREXFx1REUwMC1cXHVERTQwXFx1REU0NFxcdURFNTAtXFx1REU1OVxcdURFODAtXFx1REVCN1xcdURFQzAtXFx1REVDOVxcdURGMDAtXFx1REYxOVxcdURGMUQtXFx1REYyQlxcdURGMzAtXFx1REYzOV18XFx1RDgwNltcXHVEQ0EwLVxcdURDRTlcXHVEQ0ZGXFx1REVDMC1cXHVERUY4XXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERTYwLVxcdURFNjlcXHVERUQwLVxcdURFRURcXHVERUYwLVxcdURFRjRcXHVERjAwLVxcdURGMzZcXHVERjQwLVxcdURGNDNcXHVERjUwLVxcdURGNTlcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MC1cXHVERjdFXFx1REY4Ri1cXHVERjlGXXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OVxcdURDOURcXHVEQzlFXXxcXHVEODM0W1xcdURENjUtXFx1REQ2OVxcdURENkQtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXFx1REZDRS1cXHVERkZGXXxcXHVEODM2W1xcdURFMDAtXFx1REUzNlxcdURFM0ItXFx1REU2Q1xcdURFNzVcXHVERTg0XFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNFxcdURDRDAtXFx1RENENl18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdfFxcdURCNDBbXFx1REQwMC1cXHVEREVGXS9cclxuXHR9O1xyXG5cdGV4cG9ydHMuQ2hhcmFjdGVyID0ge1xyXG5cdCAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1iaXR3aXNlICovXHJcblx0ICAgIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA8IDB4MTAwMDApID8gU3RyaW5nLmZyb21DaGFyQ29kZShjcCkgOlxyXG5cdCAgICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODAwICsgKChjcCAtIDB4MTAwMDApID4+IDEwKSkgK1xyXG5cdCAgICAgICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4REMwMCArICgoY3AgLSAweDEwMDAwKSAmIDEwMjMpKTtcclxuXHQgICAgfSxcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtd2hpdGUtc3BhY2VcclxuXHQgICAgaXNXaGl0ZVNwYWNlOiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPT09IDB4MjApIHx8IChjcCA9PT0gMHgwOSkgfHwgKGNwID09PSAweDBCKSB8fCAoY3AgPT09IDB4MEMpIHx8IChjcCA9PT0gMHhBMCkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHgxNjgwICYmIFsweDE2ODAsIDB4MjAwMCwgMHgyMDAxLCAweDIwMDIsIDB4MjAwMywgMHgyMDA0LCAweDIwMDUsIDB4MjAwNiwgMHgyMDA3LCAweDIwMDgsIDB4MjAwOSwgMHgyMDBBLCAweDIwMkYsIDB4MjA1RiwgMHgzMDAwLCAweEZFRkZdLmluZGV4T2YoY3ApID49IDApO1xyXG5cdCAgICB9LFxyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1saW5lLXRlcm1pbmF0b3JzXHJcblx0ICAgIGlzTGluZVRlcm1pbmF0b3I6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA9PT0gMHgwQSkgfHwgKGNwID09PSAweDBEKSB8fCAoY3AgPT09IDB4MjAyOCkgfHwgKGNwID09PSAweDIwMjkpO1xyXG5cdCAgICB9LFxyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1uYW1lcy1hbmQta2V5d29yZHNcclxuXHQgICAgaXNJZGVudGlmaWVyU3RhcnQ6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA9PT0gMHgyNCkgfHwgKGNwID09PSAweDVGKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDQxICYmIGNwIDw9IDB4NUEpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4NjEgJiYgY3AgPD0gMHg3QSkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPT09IDB4NUMpIHx8XHJcblx0ICAgICAgICAgICAgKChjcCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KGV4cG9ydHMuQ2hhcmFjdGVyLmZyb21Db2RlUG9pbnQoY3ApKSk7XHJcblx0ICAgIH0sXHJcblx0ICAgIGlzSWRlbnRpZmllclBhcnQ6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA9PT0gMHgyNCkgfHwgKGNwID09PSAweDVGKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDQxICYmIGNwIDw9IDB4NUEpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4NjEgJiYgY3AgPD0gMHg3QSkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHgzMCAmJiBjcCA8PSAweDM5KSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA9PT0gMHg1QykgfHxcclxuXHQgICAgICAgICAgICAoKGNwID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclBhcnQudGVzdChleHBvcnRzLkNoYXJhY3Rlci5mcm9tQ29kZVBvaW50KGNwKSkpO1xyXG5cdCAgICB9LFxyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1saXRlcmFscy1udW1lcmljLWxpdGVyYWxzXHJcblx0ICAgIGlzRGVjaW1hbERpZ2l0OiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPj0gMHgzMCAmJiBjcCA8PSAweDM5KTsgLy8gMC4uOVxyXG5cdCAgICB9LFxyXG5cdCAgICBpc0hleERpZ2l0OiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPj0gMHgzMCAmJiBjcCA8PSAweDM5KSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDQxICYmIGNwIDw9IDB4NDYpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4NjEgJiYgY3AgPD0gMHg2Nik7IC8vIGEuLmZcclxuXHQgICAgfSxcclxuXHQgICAgaXNPY3RhbERpZ2l0OiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPj0gMHgzMCAmJiBjcCA8PSAweDM3KTsgLy8gMC4uN1xyXG5cdCAgICB9XHJcblx0fTtcclxuXG5cbi8qKiovIH0sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIGpzeF9zeW50YXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblx0LyogdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cclxuXHR2YXIgSlNYQ2xvc2luZ0VsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hDbG9zaW5nRWxlbWVudChuYW1lKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWENsb3NpbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYQ2xvc2luZ0VsZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWENsb3NpbmdFbGVtZW50ID0gSlNYQ2xvc2luZ0VsZW1lbnQ7XHJcblx0dmFyIEpTWEVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hFbGVtZW50KG9wZW5pbmdFbGVtZW50LCBjaGlsZHJlbiwgY2xvc2luZ0VsZW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMub3BlbmluZ0VsZW1lbnQgPSBvcGVuaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuXHQgICAgICAgIHRoaXMuY2xvc2luZ0VsZW1lbnQgPSBjbG9zaW5nRWxlbWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYRWxlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYRWxlbWVudCA9IEpTWEVsZW1lbnQ7XHJcblx0dmFyIEpTWEVtcHR5RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWEVtcHR5RXhwcmVzc2lvbigpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYRW1wdHlFeHByZXNzaW9uO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hFbXB0eUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWEVtcHR5RXhwcmVzc2lvbiA9IEpTWEVtcHR5RXhwcmVzc2lvbjtcclxuXHR2YXIgSlNYRXhwcmVzc2lvbkNvbnRhaW5lciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWEV4cHJlc3Npb25Db250YWluZXIoZXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hFeHByZXNzaW9uQ29udGFpbmVyO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYRXhwcmVzc2lvbkNvbnRhaW5lcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYRXhwcmVzc2lvbkNvbnRhaW5lciA9IEpTWEV4cHJlc3Npb25Db250YWluZXI7XHJcblx0dmFyIEpTWElkZW50aWZpZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hJZGVudGlmaWVyKG5hbWUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYSWRlbnRpZmllcjtcclxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWElkZW50aWZpZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWElkZW50aWZpZXIgPSBKU1hJZGVudGlmaWVyO1xyXG5cdHZhciBKU1hNZW1iZXJFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYTWVtYmVyRXhwcmVzc2lvbihvYmplY3QsIHByb3BlcnR5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWE1lbWJlckV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHQgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYTWVtYmVyRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYTWVtYmVyRXhwcmVzc2lvbiA9IEpTWE1lbWJlckV4cHJlc3Npb247XHJcblx0dmFyIEpTWEF0dHJpYnV0ZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hBdHRyaWJ1dGU7XHJcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hBdHRyaWJ1dGU7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWEF0dHJpYnV0ZSA9IEpTWEF0dHJpYnV0ZTtcclxuXHR2YXIgSlNYTmFtZXNwYWNlZE5hbWUgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hOYW1lc3BhY2VkTmFtZShuYW1lc3BhY2UsIG5hbWUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYTmFtZXNwYWNlZE5hbWU7XHJcblx0ICAgICAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcclxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWE5hbWVzcGFjZWROYW1lO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hOYW1lc3BhY2VkTmFtZSA9IEpTWE5hbWVzcGFjZWROYW1lO1xyXG5cdHZhciBKU1hPcGVuaW5nRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWE9wZW5pbmdFbGVtZW50KG5hbWUsIHNlbGZDbG9zaW5nLCBhdHRyaWJ1dGVzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWE9wZW5pbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHQgICAgICAgIHRoaXMuc2VsZkNsb3NpbmcgPSBzZWxmQ2xvc2luZztcclxuXHQgICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWE9wZW5pbmdFbGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hPcGVuaW5nRWxlbWVudCA9IEpTWE9wZW5pbmdFbGVtZW50O1xyXG5cdHZhciBKU1hTcHJlYWRBdHRyaWJ1dGUgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hTcHJlYWRBdHRyaWJ1dGUoYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYU3ByZWFkQXR0cmlidXRlO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hTcHJlYWRBdHRyaWJ1dGU7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWFNwcmVhZEF0dHJpYnV0ZSA9IEpTWFNwcmVhZEF0dHJpYnV0ZTtcclxuXHR2YXIgSlNYVGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWFRleHQodmFsdWUsIHJhdykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hUZXh0O1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgdGhpcy5yYXcgPSByYXc7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWFRleHQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWFRleHQgPSBKU1hUZXh0O1xyXG5cblxuLyoqKi8gfSxcbi8qIDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHRleHBvcnRzLkpTWFN5bnRheCA9IHtcclxuXHQgICAgSlNYQXR0cmlidXRlOiAnSlNYQXR0cmlidXRlJyxcclxuXHQgICAgSlNYQ2xvc2luZ0VsZW1lbnQ6ICdKU1hDbG9zaW5nRWxlbWVudCcsXHJcblx0ICAgIEpTWEVsZW1lbnQ6ICdKU1hFbGVtZW50JyxcclxuXHQgICAgSlNYRW1wdHlFeHByZXNzaW9uOiAnSlNYRW1wdHlFeHByZXNzaW9uJyxcclxuXHQgICAgSlNYRXhwcmVzc2lvbkNvbnRhaW5lcjogJ0pTWEV4cHJlc3Npb25Db250YWluZXInLFxyXG5cdCAgICBKU1hJZGVudGlmaWVyOiAnSlNYSWRlbnRpZmllcicsXHJcblx0ICAgIEpTWE1lbWJlckV4cHJlc3Npb246ICdKU1hNZW1iZXJFeHByZXNzaW9uJyxcclxuXHQgICAgSlNYTmFtZXNwYWNlZE5hbWU6ICdKU1hOYW1lc3BhY2VkTmFtZScsXHJcblx0ICAgIEpTWE9wZW5pbmdFbGVtZW50OiAnSlNYT3BlbmluZ0VsZW1lbnQnLFxyXG5cdCAgICBKU1hTcHJlYWRBdHRyaWJ1dGU6ICdKU1hTcHJlYWRBdHRyaWJ1dGUnLFxyXG5cdCAgICBKU1hUZXh0OiAnSlNYVGV4dCdcclxuXHR9O1xyXG5cblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgc3ludGF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cdC8qIHRzbGludDpkaXNhYmxlOm1heC1jbGFzc2VzLXBlci1maWxlICovXHJcblx0dmFyIEFycmF5RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFycmF5RXhwcmVzc2lvbihlbGVtZW50cykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFycmF5RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXJyYXlFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5BcnJheUV4cHJlc3Npb24gPSBBcnJheUV4cHJlc3Npb247XHJcblx0dmFyIEFycmF5UGF0dGVybiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFycmF5UGF0dGVybihlbGVtZW50cykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFycmF5UGF0dGVybjtcclxuXHQgICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXJyYXlQYXR0ZXJuO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5BcnJheVBhdHRlcm4gPSBBcnJheVBhdHRlcm47XHJcblx0dmFyIEFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24ocGFyYW1zLCBib2R5LCBleHByZXNzaW9uKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gbnVsbDtcclxuXHQgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5hc3luYyA9IGZhbHNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR2YXIgQXNzaWdubWVudEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBc3NpZ25tZW50RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcclxuXHQgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFzc2lnbm1lbnRFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Bc3NpZ25tZW50RXhwcmVzc2lvbiA9IEFzc2lnbm1lbnRFeHByZXNzaW9uO1xyXG5cdHZhciBBc3NpZ25tZW50UGF0dGVybiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFzc2lnbm1lbnRQYXR0ZXJuKGxlZnQsIHJpZ2h0KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudFBhdHRlcm47XHJcblx0ICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBc3NpZ25tZW50UGF0dGVybjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXNzaWdubWVudFBhdHRlcm4gPSBBc3NpZ25tZW50UGF0dGVybjtcclxuXHR2YXIgQXN5bmNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24ocGFyYW1zLCBib2R5LCBleHByZXNzaW9uKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gbnVsbDtcclxuXHQgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5hc3luYyA9IHRydWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSBBc3luY0Fycm93RnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdHZhciBBc3luY0Z1bmN0aW9uRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBc3luY0Z1bmN0aW9uRGVjbGFyYXRpb24oaWQsIHBhcmFtcywgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmFzeW5jID0gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Bc3luY0Z1bmN0aW9uRGVjbGFyYXRpb24gPSBBc3luY0Z1bmN0aW9uRGVjbGFyYXRpb247XHJcblx0dmFyIEFzeW5jRnVuY3Rpb25FeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24oaWQsIHBhcmFtcywgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuYXN5bmMgPSB0cnVlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBc3luY0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24gPSBBc3luY0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR2YXIgQXdhaXRFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXdhaXRFeHByZXNzaW9uKGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXdhaXRFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBd2FpdEV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkF3YWl0RXhwcmVzc2lvbiA9IEF3YWl0RXhwcmVzc2lvbjtcclxuXHR2YXIgQmluYXJ5RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XHJcblx0ICAgICAgICB2YXIgbG9naWNhbCA9IChvcGVyYXRvciA9PT0gJ3x8JyB8fCBvcGVyYXRvciA9PT0gJyYmJyk7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBsb2dpY2FsID8gc3ludGF4XzEuU3ludGF4LkxvZ2ljYWxFeHByZXNzaW9uIDogc3ludGF4XzEuU3ludGF4LkJpbmFyeUV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBCaW5hcnlFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5CaW5hcnlFeHByZXNzaW9uID0gQmluYXJ5RXhwcmVzc2lvbjtcclxuXHR2YXIgQmxvY2tTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBCbG9ja1N0YXRlbWVudChib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQmxvY2tTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBCbG9ja1N0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQmxvY2tTdGF0ZW1lbnQgPSBCbG9ja1N0YXRlbWVudDtcclxuXHR2YXIgQnJlYWtTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBCcmVha1N0YXRlbWVudChsYWJlbCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkJyZWFrU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBCcmVha1N0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQnJlYWtTdGF0ZW1lbnQgPSBCcmVha1N0YXRlbWVudDtcclxuXHR2YXIgQ2FsbEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDYWxsRXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5DYWxsRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuY2FsbGVlID0gY2FsbGVlO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudHMgPSBhcmdzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDYWxsRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ2FsbEV4cHJlc3Npb24gPSBDYWxsRXhwcmVzc2lvbjtcclxuXHR2YXIgQ2F0Y2hDbGF1c2UgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDYXRjaENsYXVzZShwYXJhbSwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNhdGNoQ2xhdXNlO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbSA9IHBhcmFtO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ2F0Y2hDbGF1c2U7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNhdGNoQ2xhdXNlID0gQ2F0Y2hDbGF1c2U7XHJcblx0dmFyIENsYXNzQm9keSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENsYXNzQm9keShib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ2xhc3NCb2R5O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ2xhc3NCb2R5O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5DbGFzc0JvZHkgPSBDbGFzc0JvZHk7XHJcblx0dmFyIENsYXNzRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDbGFzc0RlY2xhcmF0aW9uKGlkLCBzdXBlckNsYXNzLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ2xhc3NEZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMuc3VwZXJDbGFzcyA9IHN1cGVyQ2xhc3M7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDbGFzc0RlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5DbGFzc0RlY2xhcmF0aW9uID0gQ2xhc3NEZWNsYXJhdGlvbjtcclxuXHR2YXIgQ2xhc3NFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ2xhc3NFeHByZXNzaW9uKGlkLCBzdXBlckNsYXNzLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ2xhc3NFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5zdXBlckNsYXNzID0gc3VwZXJDbGFzcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENsYXNzRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ2xhc3NFeHByZXNzaW9uID0gQ2xhc3NFeHByZXNzaW9uO1xyXG5cdHZhciBDb21wdXRlZE1lbWJlckV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDb21wdXRlZE1lbWJlckV4cHJlc3Npb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk1lbWJlckV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmNvbXB1dGVkID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDb21wdXRlZE1lbWJlckV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbiA9IENvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbjtcclxuXHR2YXIgQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ29uZGl0aW9uYWxFeHByZXNzaW9uKHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNvbmRpdGlvbmFsRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xyXG5cdCAgICAgICAgdGhpcy5hbHRlcm5hdGUgPSBhbHRlcm5hdGU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENvbmRpdGlvbmFsRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xyXG5cdHZhciBDb250aW51ZVN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENvbnRpbnVlU3RhdGVtZW50KGxhYmVsKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ29udGludWVTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENvbnRpbnVlU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Db250aW51ZVN0YXRlbWVudCA9IENvbnRpbnVlU3RhdGVtZW50O1xyXG5cdHZhciBEZWJ1Z2dlclN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIERlYnVnZ2VyU3RhdGVtZW50KCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkRlYnVnZ2VyU3RhdGVtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBEZWJ1Z2dlclN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRGVidWdnZXJTdGF0ZW1lbnQgPSBEZWJ1Z2dlclN0YXRlbWVudDtcclxuXHR2YXIgRGlyZWN0aXZlID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRGlyZWN0aXZlKGV4cHJlc3Npb24sIGRpcmVjdGl2ZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5kaXJlY3RpdmUgPSBkaXJlY3RpdmU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIERpcmVjdGl2ZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRGlyZWN0aXZlID0gRGlyZWN0aXZlO1xyXG5cdHZhciBEb1doaWxlU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRG9XaGlsZVN0YXRlbWVudChib2R5LCB0ZXN0KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRG9XaGlsZVN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBEb1doaWxlU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Eb1doaWxlU3RhdGVtZW50ID0gRG9XaGlsZVN0YXRlbWVudDtcclxuXHR2YXIgRW1wdHlTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFbXB0eVN0YXRlbWVudCgpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FbXB0eVN0YXRlbWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRW1wdHlTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkVtcHR5U3RhdGVtZW50ID0gRW1wdHlTdGF0ZW1lbnQ7XHJcblx0dmFyIEV4cG9ydEFsbERlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRXhwb3J0QWxsRGVjbGFyYXRpb24oc291cmNlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRXhwb3J0QWxsRGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRXhwb3J0QWxsRGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkV4cG9ydEFsbERlY2xhcmF0aW9uID0gRXhwb3J0QWxsRGVjbGFyYXRpb247XHJcblx0dmFyIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihkZWNsYXJhdGlvbikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24gPSBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb247XHJcblx0dmFyIEV4cG9ydE5hbWVkRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFeHBvcnROYW1lZERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLCBzcGVjaWZpZXJzLCBzb3VyY2UpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FeHBvcnROYW1lZERlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5kZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5zcGVjaWZpZXJzID0gc3BlY2lmaWVycztcclxuXHQgICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBFeHBvcnROYW1lZERlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FeHBvcnROYW1lZERlY2xhcmF0aW9uID0gRXhwb3J0TmFtZWREZWNsYXJhdGlvbjtcclxuXHR2YXIgRXhwb3J0U3BlY2lmaWVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRXhwb3J0U3BlY2lmaWVyKGxvY2FsLCBleHBvcnRlZCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cG9ydFNwZWNpZmllcjtcclxuXHQgICAgICAgIHRoaXMuZXhwb3J0ZWQgPSBleHBvcnRlZDtcclxuXHQgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRXhwb3J0U3BlY2lmaWVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FeHBvcnRTcGVjaWZpZXIgPSBFeHBvcnRTcGVjaWZpZXI7XHJcblx0dmFyIEV4cHJlc3Npb25TdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFeHByZXNzaW9uU3RhdGVtZW50KGV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRXhwcmVzc2lvblN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRXhwcmVzc2lvblN0YXRlbWVudCA9IEV4cHJlc3Npb25TdGF0ZW1lbnQ7XHJcblx0dmFyIEZvckluU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRm9ySW5TdGF0ZW1lbnQobGVmdCwgcmlnaHQsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Gb3JJblN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5lYWNoID0gZmFsc2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEZvckluU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Gb3JJblN0YXRlbWVudCA9IEZvckluU3RhdGVtZW50O1xyXG5cdHZhciBGb3JPZlN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEZvck9mU3RhdGVtZW50KGxlZnQsIHJpZ2h0LCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRm9yT2ZTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRm9yT2ZTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkZvck9mU3RhdGVtZW50ID0gRm9yT2ZTdGF0ZW1lbnQ7XHJcblx0dmFyIEZvclN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEZvclN0YXRlbWVudChpbml0LCB0ZXN0LCB1cGRhdGUsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Gb3JTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmluaXQgPSBpbml0O1xyXG5cdCAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcclxuXHQgICAgICAgIHRoaXMudXBkYXRlID0gdXBkYXRlO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRm9yU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Gb3JTdGF0ZW1lbnQgPSBGb3JTdGF0ZW1lbnQ7XHJcblx0dmFyIEZ1bmN0aW9uRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBGdW5jdGlvbkRlY2xhcmF0aW9uKGlkLCBwYXJhbXMsIGJvZHksIGdlbmVyYXRvcikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGdlbmVyYXRvcjtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5hc3luYyA9IGZhbHNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBGdW5jdGlvbkRlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5GdW5jdGlvbkRlY2xhcmF0aW9uID0gRnVuY3Rpb25EZWNsYXJhdGlvbjtcclxuXHR2YXIgRnVuY3Rpb25FeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRnVuY3Rpb25FeHByZXNzaW9uKGlkLCBwYXJhbXMsIGJvZHksIGdlbmVyYXRvcikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmFzeW5jID0gZmFsc2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEZ1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRnVuY3Rpb25FeHByZXNzaW9uID0gRnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdHZhciBJZGVudGlmaWVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSWRlbnRpZmllcihuYW1lKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcjtcclxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIElkZW50aWZpZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLklkZW50aWZpZXIgPSBJZGVudGlmaWVyO1xyXG5cdHZhciBJZlN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIElmU3RhdGVtZW50KHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LklmU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcclxuXHQgICAgICAgIHRoaXMuY29uc2VxdWVudCA9IGNvbnNlcXVlbnQ7XHJcblx0ICAgICAgICB0aGlzLmFsdGVybmF0ZSA9IGFsdGVybmF0ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSWZTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLklmU3RhdGVtZW50ID0gSWZTdGF0ZW1lbnQ7XHJcblx0dmFyIEltcG9ydERlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSW1wb3J0RGVjbGFyYXRpb24oc3BlY2lmaWVycywgc291cmNlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSW1wb3J0RGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLnNwZWNpZmllcnMgPSBzcGVjaWZpZXJzO1xyXG5cdCAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEltcG9ydERlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5JbXBvcnREZWNsYXJhdGlvbiA9IEltcG9ydERlY2xhcmF0aW9uO1xyXG5cdHZhciBJbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSW1wb3J0RGVmYXVsdFNwZWNpZmllcihsb2NhbCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkltcG9ydERlZmF1bHRTcGVjaWZpZXI7XHJcblx0ICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEltcG9ydERlZmF1bHRTcGVjaWZpZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBJbXBvcnREZWZhdWx0U3BlY2lmaWVyO1xyXG5cdHZhciBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIobG9jYWwpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI7XHJcblx0ICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xyXG5cdHZhciBJbXBvcnRTcGVjaWZpZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBJbXBvcnRTcGVjaWZpZXIobG9jYWwsIGltcG9ydGVkKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSW1wb3J0U3BlY2lmaWVyO1xyXG5cdCAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xyXG5cdCAgICAgICAgdGhpcy5pbXBvcnRlZCA9IGltcG9ydGVkO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBJbXBvcnRTcGVjaWZpZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkltcG9ydFNwZWNpZmllciA9IEltcG9ydFNwZWNpZmllcjtcclxuXHR2YXIgTGFiZWxlZFN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIExhYmVsZWRTdGF0ZW1lbnQobGFiZWwsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5MYWJlbGVkU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gTGFiZWxlZFN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuTGFiZWxlZFN0YXRlbWVudCA9IExhYmVsZWRTdGF0ZW1lbnQ7XHJcblx0dmFyIExpdGVyYWwgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBMaXRlcmFsKHZhbHVlLCByYXcpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5MaXRlcmFsO1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgdGhpcy5yYXcgPSByYXc7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIExpdGVyYWw7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkxpdGVyYWwgPSBMaXRlcmFsO1xyXG5cdHZhciBNZXRhUHJvcGVydHkgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBNZXRhUHJvcGVydHkobWV0YSwgcHJvcGVydHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5NZXRhUHJvcGVydHk7XHJcblx0ICAgICAgICB0aGlzLm1ldGEgPSBtZXRhO1xyXG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBNZXRhUHJvcGVydHk7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLk1ldGFQcm9wZXJ0eSA9IE1ldGFQcm9wZXJ0eTtcclxuXHR2YXIgTWV0aG9kRGVmaW5pdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIE1ldGhvZERlZmluaXRpb24oa2V5LCBjb21wdXRlZCwgdmFsdWUsIGtpbmQsIGlzU3RhdGljKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTWV0aG9kRGVmaW5pdGlvbjtcclxuXHQgICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG5cdCAgICAgICAgdGhpcy5jb21wdXRlZCA9IGNvbXB1dGVkO1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgdGhpcy5raW5kID0ga2luZDtcclxuXHQgICAgICAgIHRoaXMuc3RhdGljID0gaXNTdGF0aWM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIE1ldGhvZERlZmluaXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLk1ldGhvZERlZmluaXRpb24gPSBNZXRob2REZWZpbml0aW9uO1xyXG5cdHZhciBNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBNb2R1bGUoYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlByb2dyYW07XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5zb3VyY2VUeXBlID0gJ21vZHVsZSc7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIE1vZHVsZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuTW9kdWxlID0gTW9kdWxlO1xyXG5cdHZhciBOZXdFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gTmV3RXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5OZXdFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5jYWxsZWUgPSBjYWxsZWU7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3M7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIE5ld0V4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLk5ld0V4cHJlc3Npb24gPSBOZXdFeHByZXNzaW9uO1xyXG5cdHZhciBPYmplY3RFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gT2JqZWN0RXhwcmVzc2lvbihwcm9wZXJ0aWVzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguT2JqZWN0RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIE9iamVjdEV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLk9iamVjdEV4cHJlc3Npb24gPSBPYmplY3RFeHByZXNzaW9uO1xyXG5cdHZhciBPYmplY3RQYXR0ZXJuID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gT2JqZWN0UGF0dGVybihwcm9wZXJ0aWVzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguT2JqZWN0UGF0dGVybjtcclxuXHQgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIE9iamVjdFBhdHRlcm47XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLk9iamVjdFBhdHRlcm4gPSBPYmplY3RQYXR0ZXJuO1xyXG5cdHZhciBQcm9wZXJ0eSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFByb3BlcnR5KGtpbmQsIGtleSwgY29tcHV0ZWQsIHZhbHVlLCBtZXRob2QsIHNob3J0aGFuZCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlByb3BlcnR5O1xyXG5cdCAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcblx0ICAgICAgICB0aGlzLmNvbXB1dGVkID0gY29tcHV0ZWQ7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xyXG5cdCAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XHJcblx0ICAgICAgICB0aGlzLnNob3J0aGFuZCA9IHNob3J0aGFuZDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gUHJvcGVydHk7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlByb3BlcnR5ID0gUHJvcGVydHk7XHJcblx0dmFyIFJlZ2V4TGl0ZXJhbCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFJlZ2V4TGl0ZXJhbCh2YWx1ZSwgcmF3LCBwYXR0ZXJuLCBmbGFncykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkxpdGVyYWw7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgICAgICB0aGlzLnJhdyA9IHJhdztcclxuXHQgICAgICAgIHRoaXMucmVnZXggPSB7IHBhdHRlcm46IHBhdHRlcm4sIGZsYWdzOiBmbGFncyB9O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBSZWdleExpdGVyYWw7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlJlZ2V4TGl0ZXJhbCA9IFJlZ2V4TGl0ZXJhbDtcclxuXHR2YXIgUmVzdEVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBSZXN0RWxlbWVudChhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlJlc3RFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBSZXN0RWxlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuUmVzdEVsZW1lbnQgPSBSZXN0RWxlbWVudDtcclxuXHR2YXIgUmV0dXJuU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gUmV0dXJuU3RhdGVtZW50KGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguUmV0dXJuU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBSZXR1cm5TdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlJldHVyblN0YXRlbWVudCA9IFJldHVyblN0YXRlbWVudDtcclxuXHR2YXIgU2NyaXB0ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU2NyaXB0KGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Qcm9ncmFtO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuc291cmNlVHlwZSA9ICdzY3JpcHQnO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTY3JpcHQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlNjcmlwdCA9IFNjcmlwdDtcclxuXHR2YXIgU2VxdWVuY2VFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU2VxdWVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb25zKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguU2VxdWVuY2VFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTZXF1ZW5jZUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlNlcXVlbmNlRXhwcmVzc2lvbiA9IFNlcXVlbmNlRXhwcmVzc2lvbjtcclxuXHR2YXIgU3ByZWFkRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFNwcmVhZEVsZW1lbnQoYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5TcHJlYWRFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTcHJlYWRFbGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5TcHJlYWRFbGVtZW50ID0gU3ByZWFkRWxlbWVudDtcclxuXHR2YXIgU3RhdGljTWVtYmVyRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFN0YXRpY01lbWJlckV4cHJlc3Npb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk1lbWJlckV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmNvbXB1dGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHQgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU3RhdGljTWVtYmVyRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU3RhdGljTWVtYmVyRXhwcmVzc2lvbiA9IFN0YXRpY01lbWJlckV4cHJlc3Npb247XHJcblx0dmFyIFN1cGVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU3VwZXIoKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguU3VwZXI7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFN1cGVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5TdXBlciA9IFN1cGVyO1xyXG5cdHZhciBTd2l0Y2hDYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU3dpdGNoQ2FzZSh0ZXN0LCBjb25zZXF1ZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguU3dpdGNoQ2FzZTtcclxuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTd2l0Y2hDYXNlO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Td2l0Y2hDYXNlID0gU3dpdGNoQ2FzZTtcclxuXHR2YXIgU3dpdGNoU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU3dpdGNoU3RhdGVtZW50KGRpc2NyaW1pbmFudCwgY2FzZXMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Td2l0Y2hTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmRpc2NyaW1pbmFudCA9IGRpc2NyaW1pbmFudDtcclxuXHQgICAgICAgIHRoaXMuY2FzZXMgPSBjYXNlcztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU3dpdGNoU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Td2l0Y2hTdGF0ZW1lbnQgPSBTd2l0Y2hTdGF0ZW1lbnQ7XHJcblx0dmFyIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbih0YWcsIHF1YXNpKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy50YWcgPSB0YWc7XHJcblx0ICAgICAgICB0aGlzLnF1YXNpID0gcXVhc2k7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uID0gVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xyXG5cdHZhciBUZW1wbGF0ZUVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUZW1wbGF0ZUVsZW1lbnQodmFsdWUsIHRhaWwpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5UZW1wbGF0ZUVsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgICAgICB0aGlzLnRhaWwgPSB0YWlsO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBUZW1wbGF0ZUVsZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRlbXBsYXRlRWxlbWVudCA9IFRlbXBsYXRlRWxlbWVudDtcclxuXHR2YXIgVGVtcGxhdGVMaXRlcmFsID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVGVtcGxhdGVMaXRlcmFsKHF1YXNpcywgZXhwcmVzc2lvbnMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5UZW1wbGF0ZUxpdGVyYWw7XHJcblx0ICAgICAgICB0aGlzLnF1YXNpcyA9IHF1YXNpcztcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVGVtcGxhdGVMaXRlcmFsO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWwgPSBUZW1wbGF0ZUxpdGVyYWw7XHJcblx0dmFyIFRoaXNFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVGhpc0V4cHJlc3Npb24oKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVGhpc0V4cHJlc3Npb247XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFRoaXNFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5UaGlzRXhwcmVzc2lvbiA9IFRoaXNFeHByZXNzaW9uO1xyXG5cdHZhciBUaHJvd1N0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRocm93U3RhdGVtZW50KGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVGhyb3dTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFRocm93U3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5UaHJvd1N0YXRlbWVudCA9IFRocm93U3RhdGVtZW50O1xyXG5cdHZhciBUcnlTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUcnlTdGF0ZW1lbnQoYmxvY2ssIGhhbmRsZXIsIGZpbmFsaXplcikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlRyeVN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcclxuXHQgICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XHJcblx0ICAgICAgICB0aGlzLmZpbmFsaXplciA9IGZpbmFsaXplcjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVHJ5U3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5UcnlTdGF0ZW1lbnQgPSBUcnlTdGF0ZW1lbnQ7XHJcblx0dmFyIFVuYXJ5RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFVuYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5VbmFyeUV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLnByZWZpeCA9IHRydWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFVuYXJ5RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVW5hcnlFeHByZXNzaW9uID0gVW5hcnlFeHByZXNzaW9uO1xyXG5cdHZhciBVcGRhdGVFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVXBkYXRlRXhwcmVzc2lvbihvcGVyYXRvciwgYXJndW1lbnQsIHByZWZpeCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlVwZGF0ZUV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVXBkYXRlRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVXBkYXRlRXhwcmVzc2lvbiA9IFVwZGF0ZUV4cHJlc3Npb247XHJcblx0dmFyIFZhcmlhYmxlRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBWYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmRlY2xhcmF0aW9ucyA9IGRlY2xhcmF0aW9ucztcclxuXHQgICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFZhcmlhYmxlRGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlZhcmlhYmxlRGVjbGFyYXRpb24gPSBWYXJpYWJsZURlY2xhcmF0aW9uO1xyXG5cdHZhciBWYXJpYWJsZURlY2xhcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBWYXJpYWJsZURlY2xhcmF0b3IoaWQsIGluaXQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLmluaXQgPSBpbml0O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBWYXJpYWJsZURlY2xhcmF0b3I7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlZhcmlhYmxlRGVjbGFyYXRvciA9IFZhcmlhYmxlRGVjbGFyYXRvcjtcclxuXHR2YXIgV2hpbGVTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBXaGlsZVN0YXRlbWVudCh0ZXN0LCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguV2hpbGVTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gV2hpbGVTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLldoaWxlU3RhdGVtZW50ID0gV2hpbGVTdGF0ZW1lbnQ7XHJcblx0dmFyIFdpdGhTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBXaXRoU3RhdGVtZW50KG9iamVjdCwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LldpdGhTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFdpdGhTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLldpdGhTdGF0ZW1lbnQgPSBXaXRoU3RhdGVtZW50O1xyXG5cdHZhciBZaWVsZEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBZaWVsZEV4cHJlc3Npb24oYXJndW1lbnQsIGRlbGVnYXRlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguWWllbGRFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBZaWVsZEV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLllpZWxkRXhwcmVzc2lvbiA9IFlpZWxkRXhwcmVzc2lvbjtcclxuXG5cbi8qKiovIH0sXG4vKiA4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIGFzc2VydF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxuXHR2YXIgZXJyb3JfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcblx0dmFyIG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxuXHR2YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcblx0dmFyIHNjYW5uZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG5cdHZhciBzeW50YXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblx0dmFyIHRva2VuXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxuXHR2YXIgQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlciA9ICdBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyJztcclxuXHR2YXIgUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gUGFyc2VyKGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XHJcblx0ICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG5cdCAgICAgICAgdGhpcy5jb25maWcgPSB7XHJcblx0ICAgICAgICAgICAgcmFuZ2U6ICh0eXBlb2Ygb3B0aW9ucy5yYW5nZSA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnJhbmdlLFxyXG5cdCAgICAgICAgICAgIGxvYzogKHR5cGVvZiBvcHRpb25zLmxvYyA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLmxvYyxcclxuXHQgICAgICAgICAgICBzb3VyY2U6IG51bGwsXHJcblx0ICAgICAgICAgICAgdG9rZW5zOiAodHlwZW9mIG9wdGlvbnMudG9rZW5zID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMudG9rZW5zLFxyXG5cdCAgICAgICAgICAgIGNvbW1lbnQ6ICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMuY29tbWVudCxcclxuXHQgICAgICAgICAgICB0b2xlcmFudDogKHR5cGVvZiBvcHRpb25zLnRvbGVyYW50ID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMudG9sZXJhbnRcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcubG9jICYmIG9wdGlvbnMuc291cmNlICYmIG9wdGlvbnMuc291cmNlICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb25maWcuc291cmNlID0gU3RyaW5nKG9wdGlvbnMuc291cmNlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gbmV3IGVycm9yX2hhbmRsZXJfMS5FcnJvckhhbmRsZXIoKTtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLnRvbGVyYW50ID0gdGhpcy5jb25maWcudG9sZXJhbnQ7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIgPSBuZXcgc2Nhbm5lcl8xLlNjYW5uZXIoY29kZSwgdGhpcy5lcnJvckhhbmRsZXIpO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLnRyYWNrQ29tbWVudCA9IHRoaXMuY29uZmlnLmNvbW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLm9wZXJhdG9yUHJlY2VkZW5jZSA9IHtcclxuXHQgICAgICAgICAgICAnKSc6IDAsXHJcblx0ICAgICAgICAgICAgJzsnOiAwLFxyXG5cdCAgICAgICAgICAgICcsJzogMCxcclxuXHQgICAgICAgICAgICAnPSc6IDAsXHJcblx0ICAgICAgICAgICAgJ10nOiAwLFxyXG5cdCAgICAgICAgICAgICd8fCc6IDEsXHJcblx0ICAgICAgICAgICAgJyYmJzogMixcclxuXHQgICAgICAgICAgICAnfCc6IDMsXHJcblx0ICAgICAgICAgICAgJ14nOiA0LFxyXG5cdCAgICAgICAgICAgICcmJzogNSxcclxuXHQgICAgICAgICAgICAnPT0nOiA2LFxyXG5cdCAgICAgICAgICAgICchPSc6IDYsXHJcblx0ICAgICAgICAgICAgJz09PSc6IDYsXHJcblx0ICAgICAgICAgICAgJyE9PSc6IDYsXHJcblx0ICAgICAgICAgICAgJzwnOiA3LFxyXG5cdCAgICAgICAgICAgICc+JzogNyxcclxuXHQgICAgICAgICAgICAnPD0nOiA3LFxyXG5cdCAgICAgICAgICAgICc+PSc6IDcsXHJcblx0ICAgICAgICAgICAgJzw8JzogOCxcclxuXHQgICAgICAgICAgICAnPj4nOiA4LFxyXG5cdCAgICAgICAgICAgICc+Pj4nOiA4LFxyXG5cdCAgICAgICAgICAgICcrJzogOSxcclxuXHQgICAgICAgICAgICAnLSc6IDksXHJcblx0ICAgICAgICAgICAgJyonOiAxMSxcclxuXHQgICAgICAgICAgICAnLyc6IDExLFxyXG5cdCAgICAgICAgICAgICclJzogMTFcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICB0aGlzLmxvb2thaGVhZCA9IHtcclxuXHQgICAgICAgICAgICB0eXBlOiAyIC8qIEVPRiAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogJycsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiAwLFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiAwLFxyXG5cdCAgICAgICAgICAgIGVuZDogMFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIHRoaXMuaGFzTGluZVRlcm1pbmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dCA9IHtcclxuXHQgICAgICAgICAgICBpc01vZHVsZTogZmFsc2UsXHJcblx0ICAgICAgICAgICAgYXdhaXQ6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGFsbG93SW46IHRydWUsXHJcblx0ICAgICAgICAgICAgYWxsb3dTdHJpY3REaXJlY3RpdmU6IHRydWUsXHJcblx0ICAgICAgICAgICAgYWxsb3dZaWVsZDogdHJ1ZSxcclxuXHQgICAgICAgICAgICBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I6IG51bGwsXHJcblx0ICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0OiBmYWxzZSxcclxuXHQgICAgICAgICAgICBpc0JpbmRpbmdFbGVtZW50OiBmYWxzZSxcclxuXHQgICAgICAgICAgICBpbkZ1bmN0aW9uQm9keTogZmFsc2UsXHJcblx0ICAgICAgICAgICAgaW5JdGVyYXRpb246IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGluU3dpdGNoOiBmYWxzZSxcclxuXHQgICAgICAgICAgICBsYWJlbFNldDoge30sXHJcblx0ICAgICAgICAgICAgc3RyaWN0OiBmYWxzZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIHRoaXMudG9rZW5zID0gW107XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyID0ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiAwLFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogMFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlciA9IHtcclxuXHQgICAgICAgICAgICBpbmRleDogMCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBjb2x1bW46IDBcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyID0ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiB0aGlzLnNjYW5uZXIuaW5kZXgsXHJcblx0ICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUudGhyb3dFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlRm9ybWF0KSB7XHJcblx0ICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG5cdCAgICAgICAgICAgIHZhbHVlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHQgICAgICAgIHZhciBtc2cgPSBtZXNzYWdlRm9ybWF0LnJlcGxhY2UoLyUoXFxkKS9nLCBmdW5jdGlvbiAod2hvbGUsIGlkeCkge1xyXG5cdCAgICAgICAgICAgIGFzc2VydF8xLmFzc2VydChpZHggPCBhcmdzLmxlbmd0aCwgJ01lc3NhZ2UgcmVmZXJlbmNlIG11c3QgYmUgaW4gcmFuZ2UnKTtcclxuXHQgICAgICAgICAgICByZXR1cm4gYXJnc1tpZHhdO1xyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxhc3RNYXJrZXIuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgbGluZSA9IHRoaXMubGFzdE1hcmtlci5saW5lO1xyXG5cdCAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubGFzdE1hcmtlci5jb2x1bW4gKyAxO1xyXG5cdCAgICAgICAgdGhyb3cgdGhpcy5lcnJvckhhbmRsZXIuY3JlYXRlRXJyb3IoaW5kZXgsIGxpbmUsIGNvbHVtbiwgbXNnKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS50b2xlcmF0ZUVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2VGb3JtYXQpIHtcclxuXHQgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuXHQgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcblx0ICAgICAgICAgICAgdmFsdWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cdCAgICAgICAgdmFyIG1zZyA9IG1lc3NhZ2VGb3JtYXQucmVwbGFjZSgvJShcXGQpL2csIGZ1bmN0aW9uICh3aG9sZSwgaWR4KSB7XHJcblx0ICAgICAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KGlkeCA8IGFyZ3MubGVuZ3RoLCAnTWVzc2FnZSByZWZlcmVuY2UgbXVzdCBiZSBpbiByYW5nZScpO1xyXG5cdCAgICAgICAgICAgIHJldHVybiBhcmdzW2lkeF07XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgICAgIHZhciBpbmRleCA9IHRoaXMubGFzdE1hcmtlci5pbmRleDtcclxuXHQgICAgICAgIHZhciBsaW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5sYXN0TWFya2VyLmNvbHVtbiArIDE7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlci50b2xlcmF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2x1bW4sIG1zZyk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIG9mIHRoZSB0b2tlbi5cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS51bmV4cGVjdGVkVG9rZW5FcnJvciA9IGZ1bmN0aW9uICh0b2tlbiwgbWVzc2FnZSkge1xyXG5cdCAgICAgICAgdmFyIG1zZyA9IG1lc3NhZ2UgfHwgbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW47XHJcblx0ICAgICAgICB2YXIgdmFsdWU7XHJcblx0ICAgICAgICBpZiAodG9rZW4pIHtcclxuXHQgICAgICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcclxuXHQgICAgICAgICAgICAgICAgbXNnID0gKHRva2VuLnR5cGUgPT09IDIgLyogRU9GICovKSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZEVPUyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZElkZW50aWZpZXIgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSA2IC8qIE51bWVyaWNMaXRlcmFsICovKSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZE51bWJlciA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSA4IC8qIFN0cmluZ0xpdGVyYWwgKi8pID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkU3RyaW5nIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSAxMCAvKiBUZW1wbGF0ZSAqLykgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUZW1wbGF0ZSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW47XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNGdXR1cmVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbXNnID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkUmVzZXJ2ZWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbXNnID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0b2tlbi52YWx1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gJ0lMTEVHQUwnO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgbXNnID0gbXNnLnJlcGxhY2UoJyUwJywgdmFsdWUpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuICYmIHR5cGVvZiB0b2tlbi5saW5lTnVtYmVyID09PSAnbnVtYmVyJykge1xyXG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IHRva2VuLnN0YXJ0O1xyXG5cdCAgICAgICAgICAgIHZhciBsaW5lID0gdG9rZW4ubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICB2YXIgbGFzdE1hcmtlckxpbmVTdGFydCA9IHRoaXMubGFzdE1hcmtlci5pbmRleCAtIHRoaXMubGFzdE1hcmtlci5jb2x1bW47XHJcblx0ICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHRva2VuLnN0YXJ0IC0gbGFzdE1hcmtlckxpbmVTdGFydCArIDE7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JIYW5kbGVyLmNyZWF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2x1bW4sIG1zZyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxhc3RNYXJrZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxhc3RNYXJrZXIubGluZTtcclxuXHQgICAgICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5sYXN0TWFya2VyLmNvbHVtbiArIDE7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JIYW5kbGVyLmNyZWF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2x1bW4sIG1zZyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUudGhyb3dVbmV4cGVjdGVkVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4sIG1lc3NhZ2UpIHtcclxuXHQgICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZFRva2VuRXJyb3IodG9rZW4sIG1lc3NhZ2UpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuID0gZnVuY3Rpb24gKHRva2VuLCBtZXNzYWdlKSB7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlci50b2xlcmF0ZSh0aGlzLnVuZXhwZWN0ZWRUb2tlbkVycm9yKHRva2VuLCBtZXNzYWdlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuY29sbGVjdENvbW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5jb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5zY2FubmVyLnNjYW5Db21tZW50cygpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNvbW1lbnRzID0gdGhpcy5zY2FubmVyLnNjYW5Db21tZW50cygpO1xyXG5cdCAgICAgICAgICAgIGlmIChjb21tZW50cy5sZW5ndGggPiAwICYmIHRoaXMuZGVsZWdhdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tZW50cy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBjb21tZW50c1tpXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gdm9pZCAwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBlLm11bHRpTGluZSA/ICdCbG9ja0NvbW1lbnQnIDogJ0xpbmVDb21tZW50JyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zY2FubmVyLnNvdXJjZS5zbGljZShlLnNsaWNlWzBdLCBlLnNsaWNlWzFdKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5yYW5nZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmFuZ2UgPSBlLnJhbmdlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubG9jID0gZS5sb2M7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogZS5sb2Muc3RhcnQubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBlLmxvYy5zdGFydC5jb2x1bW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogZS5yYW5nZVswXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGUubG9jLmVuZC5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGUubG9jLmVuZC5jb2x1bW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogZS5yYW5nZVsxXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlKG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLy8gRnJvbSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiB0byBhbiBleHRlcm5hbCBzdHJ1Y3R1cmVcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5nZXRUb2tlblJhdyA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbm5lci5zb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQsIHRva2VuLmVuZCk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuY29udmVydFRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICB2YXIgdCA9IHtcclxuXHQgICAgICAgICAgICB0eXBlOiB0b2tlbl8xLlRva2VuTmFtZVt0b2tlbi50eXBlXSxcclxuXHQgICAgICAgICAgICB2YWx1ZTogdGhpcy5nZXRUb2tlblJhdyh0b2tlbilcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcucmFuZ2UpIHtcclxuXHQgICAgICAgICAgICB0LnJhbmdlID0gW3Rva2VuLnN0YXJ0LCB0b2tlbi5lbmRdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvYykge1xyXG5cdCAgICAgICAgICAgIHQubG9jID0ge1xyXG5cdCAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5zdGFydE1hcmtlci5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDkgLyogUmVndWxhckV4cHJlc3Npb24gKi8pIHtcclxuXHQgICAgICAgICAgICB2YXIgcGF0dGVybiA9IHRva2VuLnBhdHRlcm47XHJcblx0ICAgICAgICAgICAgdmFyIGZsYWdzID0gdG9rZW4uZmxhZ3M7XHJcblx0ICAgICAgICAgICAgdC5yZWdleCA9IHsgcGF0dGVybjogcGF0dGVybiwgZmxhZ3M6IGZsYWdzIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5uZXh0VG9rZW4gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIHRoaXMuY29sbGVjdENvbW1lbnRzKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5zY2FubmVyLmluZGV4ICE9PSB0aGlzLnN0YXJ0TWFya2VyLmluZGV4KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5zdGFydE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbmV4dCA9IHRoaXMuc2Nhbm5lci5sZXgoKTtcclxuXHQgICAgICAgIHRoaXMuaGFzTGluZVRlcm1pbmF0b3IgPSAodG9rZW4ubGluZU51bWJlciAhPT0gbmV4dC5saW5lTnVtYmVyKTtcclxuXHQgICAgICAgIGlmIChuZXh0ICYmIHRoaXMuY29udGV4dC5zdHJpY3QgJiYgbmV4dC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChuZXh0LnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICBuZXh0LnR5cGUgPSA0IC8qIEtleXdvcmQgKi87XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5sb29rYWhlYWQgPSBuZXh0O1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRva2VucyAmJiBuZXh0LnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0aGlzLmNvbnZlcnRUb2tlbihuZXh0KSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdG9rZW47XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubmV4dFJlZ2V4VG9rZW4gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmNvbGxlY3RDb21tZW50cygpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5zY2FubmVyLnNjYW5SZWdFeHAoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy50b2tlbnMpIHtcclxuXHQgICAgICAgICAgICAvLyBQb3AgdGhlIHByZXZpb3VzIHRva2VuLCAnLycgb3IgJy89J1xyXG5cdCAgICAgICAgICAgIC8vIFRoaXMgaXMgYWRkZWQgZnJvbSB0aGUgbG9va2FoZWFkIHRva2VuLlxyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnBvcCgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2godGhpcy5jb252ZXJ0VG9rZW4odG9rZW4pKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFByaW1lIHRoZSBuZXh0IGxvb2thaGVhZC5cclxuXHQgICAgICAgIHRoaXMubG9va2FoZWFkID0gdG9rZW47XHJcblx0ICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRva2VuO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmNyZWF0ZU5vZGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiB0aGlzLnN0YXJ0TWFya2VyLmluZGV4LFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc3RhcnRNYXJrZXIubGluZSxcclxuXHQgICAgICAgICAgICBjb2x1bW46IHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnN0YXJ0Tm9kZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBpbmRleDogdG9rZW4uc3RhcnQsXHJcblx0ICAgICAgICAgICAgbGluZTogdG9rZW4ubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBjb2x1bW46IHRva2VuLnN0YXJ0IC0gdG9rZW4ubGluZVN0YXJ0XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKG1hcmtlciwgbm9kZSkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnJhbmdlKSB7XHJcblx0ICAgICAgICAgICAgbm9kZS5yYW5nZSA9IFttYXJrZXIuaW5kZXgsIHRoaXMubGFzdE1hcmtlci5pbmRleF07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcubG9jKSB7XHJcblx0ICAgICAgICAgICAgbm9kZS5sb2MgPSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiBtYXJrZXIubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogbWFya2VyLmNvbHVtbixcclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxhc3RNYXJrZXIubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5sYXN0TWFya2VyLmNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb25maWcuc291cmNlKSB7XHJcblx0ICAgICAgICAgICAgICAgIG5vZGUubG9jLnNvdXJjZSA9IHRoaXMuY29uZmlnLnNvdXJjZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHtcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IG1hcmtlci5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBtYXJrZXIuY29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBtYXJrZXIuaW5kZXhcclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxhc3RNYXJrZXIubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5sYXN0TWFya2VyLmNvbHVtbixcclxuXHQgICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5sYXN0TWFya2VyLmluZGV4XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIG5vZGU7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIEV4cGVjdCB0aGUgbmV4dCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXHJcblx0ICAgIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmV4cGVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSA3IC8qIFB1bmN0dWF0b3IgKi8gfHwgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFF1aWV0bHkgZXhwZWN0IGEgY29tbWEgd2hlbiBpbiB0b2xlcmFudCBtb2RlLCBvdGhlcndpc2UgZGVsZWdhdGVzIHRvIGV4cGVjdCgpLlxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmV4cGVjdENvbW1hU2VwYXJhdG9yID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJywnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJzsnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIEV4cGVjdCB0aGUgbmV4dCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIGtleXdvcmQuXHJcblx0ICAgIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmV4cGVjdEtleXdvcmQgPSBmdW5jdGlvbiAoa2V5d29yZCkge1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSA0IC8qIEtleXdvcmQgKi8gfHwgdG9rZW4udmFsdWUgIT09IGtleXdvcmQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmxvb2thaGVhZC50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgdGhpcy5sb29rYWhlYWQudmFsdWUgPT09IHZhbHVlO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQga2V5d29yZFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm1hdGNoS2V5d29yZCA9IGZ1bmN0aW9uIChrZXl3b3JkKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5sb29rYWhlYWQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSBrZXl3b3JkO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgY29udGV4dHVhbCBrZXl3b3JkXHJcblx0ICAgIC8vICh3aGVyZSBhbiBpZGVudGlmaWVyIGlzIHNvbWV0aW1lcyBhIGtleXdvcmQgZGVwZW5kaW5nIG9uIHRoZSBjb250ZXh0KVxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm1hdGNoQ29udGV4dHVhbEtleXdvcmQgPSBmdW5jdGlvbiAoa2V5d29yZCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiB0aGlzLmxvb2thaGVhZC52YWx1ZSA9PT0ga2V5d29yZDtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gaXMgYW4gYXNzaWdubWVudCBvcGVyYXRvclxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm1hdGNoQXNzaWduID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDcgLyogUHVuY3R1YXRvciAqLykge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBvcCA9IHRoaXMubG9va2FoZWFkLnZhbHVlO1xyXG5cdCAgICAgICAgcmV0dXJuIG9wID09PSAnPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJyo9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnKio9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnLz0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICclPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJys9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnLT0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICc8PD0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICc+Pj0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICc+Pj49JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnJj0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICdePScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJ3w9JztcclxuXHQgICAgfTtcclxuXHQgICAgLy8gQ292ZXIgZ3JhbW1hciBzdXBwb3J0LlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyBXaGVuIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiBwb3NpdGlvbiBzdGFydHMgd2l0aCBhbiBsZWZ0IHBhcmVudGhlc2lzLCB0aGUgZGV0ZXJtaW5hdGlvbiBvZiB0aGUgdHlwZVxyXG5cdCAgICAvLyBvZiB0aGUgc3ludGF4IGlzIHRvIGJlIGRlZmVycmVkIGFyYml0cmFyaWx5IGxvbmcgdW50aWwgdGhlIGVuZCBvZiB0aGUgcGFyZW50aGVzZXMgcGFpciAocGx1cyBhIGxvb2thaGVhZClcclxuXHQgICAgLy8gb3IgdGhlIGZpcnN0IGNvbW1hLiBUaGlzIHNpdHVhdGlvbiBhbHNvIGRlZmVycyB0aGUgZGV0ZXJtaW5hdGlvbiBvZiBhbGwgdGhlIGV4cHJlc3Npb25zIG5lc3RlZCBpbiB0aGUgcGFpci5cclxuXHQgICAgLy9cclxuXHQgICAgLy8gVGhlcmUgYXJlIHRocmVlIHByb2R1Y3Rpb25zIHRoYXQgY2FuIGJlIHBhcnNlZCBpbiBhIHBhcmVudGhlc2VzIHBhaXIgdGhhdCBuZWVkcyB0byBiZSBkZXRlcm1pbmVkXHJcblx0ICAgIC8vIGFmdGVyIHRoZSBvdXRlcm1vc3QgcGFpciBpcyBjbG9zZWQuIFRoZXkgYXJlOlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyAgIDEuIEFzc2lnbm1lbnRFeHByZXNzaW9uXHJcblx0ICAgIC8vICAgMi4gQmluZGluZ0VsZW1lbnRzXHJcblx0ICAgIC8vICAgMy4gQXNzaWdubWVudFRhcmdldHNcclxuXHQgICAgLy9cclxuXHQgICAgLy8gSW4gb3JkZXIgdG8gYXZvaWQgZXhwb25lbnRpYWwgYmFja3RyYWNraW5nLCB3ZSB1c2UgdHdvIGZsYWdzIHRvIGRlbm90ZSBpZiB0aGUgcHJvZHVjdGlvbiBjYW4gYmVcclxuXHQgICAgLy8gYmluZGluZyBlbGVtZW50IG9yIGFzc2lnbm1lbnQgdGFyZ2V0LlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyBUaGUgdGhyZWUgcHJvZHVjdGlvbnMgaGF2ZSB0aGUgcmVsYXRpb25zaGlwOlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyAgIEJpbmRpbmdFbGVtZW50cyDiioYgQXNzaWdubWVudFRhcmdldHMg4oqGIEFzc2lnbm1lbnRFeHByZXNzaW9uXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIHdpdGggYSBzaW5nbGUgZXhjZXB0aW9uIHRoYXQgQ292ZXJJbml0aWFsaXplZE5hbWUgd2hlbiB1c2VkIGRpcmVjdGx5IGluIGFuIEV4cHJlc3Npb24sIGdlbmVyYXRlc1xyXG5cdCAgICAvLyBhbiBlYXJseSBlcnJvci4gVGhlcmVmb3JlLCB3ZSBuZWVkIHRoZSB0aGlyZCBzdGF0ZSwgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yLCB0byB0cmFjayB0aGVcclxuXHQgICAgLy8gZmlyc3QgdXNhZ2Ugb2YgQ292ZXJJbml0aWFsaXplZE5hbWUgYW5kIHJlcG9ydCBpdCB3aGVuIHdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgcGFyZW50aGVzZXMgcGFpci5cclxuXHQgICAgLy9cclxuXHQgICAgLy8gaXNvbGF0ZUNvdmVyR3JhbW1hciBmdW5jdGlvbiBydW5zIHRoZSBnaXZlbiBwYXJzZXIgZnVuY3Rpb24gd2l0aCBhIG5ldyBjb3ZlciBncmFtbWFyIGNvbnRleHQsIGFuZCBpdCBkb2VzIG5vdFxyXG5cdCAgICAvLyBlZmZlY3QgdGhlIGN1cnJlbnQgZmxhZ3MuIFRoaXMgbWVhbnMgdGhlIHByb2R1Y3Rpb24gdGhlIHBhcnNlciBwYXJzZXMgaXMgb25seSB1c2VkIGFzIGFuIGV4cHJlc3Npb24uIFRoZXJlZm9yZVxyXG5cdCAgICAvLyB0aGUgQ292ZXJJbml0aWFsaXplZE5hbWUgY2hlY2sgaXMgY29uZHVjdGVkLlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyBpbmhlcml0Q292ZXJHcmFtbWFyIGZ1bmN0aW9uIHJ1bnMgdGhlIGdpdmVuIHBhcnNlIGZ1bmN0aW9uIHdpdGggYSBuZXcgY292ZXIgZ3JhbW1hciBjb250ZXh0LCBhbmQgaXQgcHJvcGFnYXRlc1xyXG5cdCAgICAvLyB0aGUgZmxhZ3Mgb3V0c2lkZSBvZiB0aGUgcGFyc2VyLiBUaGlzIG1lYW5zIHRoZSBwcm9kdWN0aW9uIHRoZSBwYXJzZXIgcGFyc2VzIGlzIHVzZWQgYXMgYSBwYXJ0IG9mIGEgcG90ZW50aWFsXHJcblx0ICAgIC8vIHBhdHRlcm4uIFRoZSBDb3ZlckluaXRpYWxpemVkTmFtZSBjaGVjayBpcyBkZWZlcnJlZC5cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5pc29sYXRlQ292ZXJHcmFtbWFyID0gZnVuY3Rpb24gKHBhcnNlRnVuY3Rpb24pIHtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0lzQmluZGluZ0VsZW1lbnQgPSB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0lzQXNzaWdubWVudFRhcmdldCA9IHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcclxuXHQgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUZ1bmN0aW9uLmNhbGwodGhpcyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IHByZXZpb3VzSXNCaW5kaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBwcmV2aW91c0lzQXNzaWdubWVudFRhcmdldDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBwcmV2aW91c0ZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcjtcclxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuaW5oZXJpdENvdmVyR3JhbW1hciA9IGZ1bmN0aW9uIChwYXJzZUZ1bmN0aW9uKSB7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJc0JpbmRpbmdFbGVtZW50ID0gdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJc0Fzc2lnbm1lbnRUYXJnZXQgPSB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcjtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VGdW5jdGlvbi5jYWxsKHRoaXMpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCAmJiBwcmV2aW91c0lzQmluZGluZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCAmJiBwcmV2aW91c0lzQXNzaWdubWVudFRhcmdldDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBwcmV2aW91c0ZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciB8fCB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xyXG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5jb25zdW1lU2VtaWNvbG9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJzsnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICghdGhpcy5oYXNMaW5lVGVybWluYXRvcikge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLyAmJiAhdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmxhc3RNYXJrZXIuaW5kZXggPSB0aGlzLnN0YXJ0TWFya2VyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHRoaXMubGFzdE1hcmtlci5saW5lID0gdGhpcy5zdGFydE1hcmtlci5saW5lO1xyXG5cdCAgICAgICAgICAgIHRoaXMubGFzdE1hcmtlci5jb2x1bW4gPSB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtbjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHJpbWFyeS1leHByZXNzaW9uXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQcmltYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIHZhciB0b2tlbiwgcmF3O1xyXG5cdCAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAzIC8qIElkZW50aWZpZXIgKi86XHJcblx0ICAgICAgICAgICAgICAgIGlmICgodGhpcy5jb250ZXh0LmlzTW9kdWxlIHx8IHRoaXMuY29udGV4dC5hd2FpdCkgJiYgdGhpcy5sb29rYWhlYWQudmFsdWUgPT09ICdhd2FpdCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLm1hdGNoQXN5bmNGdW5jdGlvbigpID8gdGhpcy5wYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbigpIDogdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKHRoaXMubmV4dFRva2VuKCkudmFsdWUpKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA2IC8qIE51bWVyaWNMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgOCAvKiBTdHJpbmdMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLmxvb2thaGVhZC5vY3RhbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTGl0ZXJhbCh0b2tlbi52YWx1ZSwgcmF3KSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgMSAvKiBCb29sZWFuTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5MaXRlcmFsKHRva2VuLnZhbHVlID09PSAndHJ1ZScsIHJhdykpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDUgLyogTnVsbExpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTGl0ZXJhbChudWxsLCByYXcpKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAxMCAvKiBUZW1wbGF0ZSAqLzpcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VUZW1wbGF0ZUxpdGVyYWwoKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA3IC8qIFB1bmN0dWF0b3IgKi86XHJcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJygnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlR3JvdXBFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1snOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFycmF5SW5pdGlhbGl6ZXIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAneyc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlT2JqZWN0SW5pdGlhbGl6ZXIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnLyc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICcvPSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLmluZGV4ID0gdGhpcy5zdGFydE1hcmtlci5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFJlZ2V4VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5SZWdleExpdGVyYWwodG9rZW4ucmVnZXgsIHJhdywgdG9rZW4ucGF0dGVybiwgdG9rZW4uZmxhZ3MpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA0IC8qIEtleXdvcmQgKi86XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCAmJiB0aGlzLm1hdGNoS2V5d29yZCgneWllbGQnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMubWF0Y2hLZXl3b3JkKCdsZXQnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0aGlzLm5leHRUb2tlbigpLnZhbHVlKSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdmdW5jdGlvbicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCd0aGlzJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRoaXNFeHByZXNzaW9uKCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2NsYXNzJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZUNsYXNzRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXktaW5pdGlhbGl6ZXJcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNwcmVhZEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJy4uLicpO1xyXG5cdCAgICAgICAgdmFyIGFyZyA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuU3ByZWFkRWxlbWVudChhcmcpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFycmF5SW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnWycpO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCddJykpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobnVsbCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJy4uLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wYXJzZVNwcmVhZEVsZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCddJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCddJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnXScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXJyYXlFeHByZXNzaW9uKGVsZW1lbnRzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC1pbml0aWFsaXplclxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJvcGVydHlNZXRob2QgPSBmdW5jdGlvbiAocGFyYW1zKSB7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0ID0gdGhpcy5jb250ZXh0LnN0cmljdDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlID0gdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gcGFyYW1zLnNpbXBsZTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHBhcmFtcy5maXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHBhcmFtcy5maXJzdFJlc3RyaWN0ZWQsIHBhcmFtcy5tZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHBhcmFtcy5zdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4ocGFyYW1zLnN0cmljdGVkLCBwYXJhbXMubWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgcmV0dXJuIGJvZHk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQcm9wZXJ0eU1ldGhvZEZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycygpO1xyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZChwYXJhbXMpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5GdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgcGFyYW1zLnBhcmFtcywgbWV0aG9kLCBpc0dlbmVyYXRvcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJvcGVydHlNZXRob2RBc3luY0Z1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0F3YWl0ID0gdGhpcy5jb250ZXh0LmF3YWl0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoKTtcclxuXHQgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2QocGFyYW1zKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gcHJldmlvdXNBd2FpdDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFzeW5jRnVuY3Rpb25FeHByZXNzaW9uKG51bGwsIHBhcmFtcy5wYXJhbXMsIG1ldGhvZCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHZhciBrZXk7XHJcblx0ICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIDggLyogU3RyaW5nTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDYgLyogTnVtZXJpY0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRva2VuLm9jdGFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdmFyIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkxpdGVyYWwodG9rZW4udmFsdWUsIHJhdykpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDMgLyogSWRlbnRpZmllciAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDEgLyogQm9vbGVhbkxpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA1IC8qIE51bGxMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNCAvKiBLZXl3b3JkICovOlxyXG5cdCAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIodG9rZW4udmFsdWUpKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA3IC8qIFB1bmN0dWF0b3IgKi86XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ1snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCddJyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBrZXk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuaXNQcm9wZXJ0eUtleSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGtleS50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllciAmJiBrZXkubmFtZSA9PT0gdmFsdWUpIHx8XHJcblx0ICAgICAgICAgICAgKGtleS50eXBlID09PSBzeW50YXhfMS5TeW50YXguTGl0ZXJhbCAmJiBrZXkudmFsdWUgPT09IHZhbHVlKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9iamVjdFByb3BlcnR5ID0gZnVuY3Rpb24gKGhhc1Byb3RvKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIga2luZDtcclxuXHQgICAgICAgIHZhciBrZXkgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBjb21wdXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHNob3J0aGFuZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGlzQXN5bmMgPSBmYWxzZTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICB2YXIgaWQgPSB0b2tlbi52YWx1ZTtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGlzQXN5bmMgPSAhdGhpcy5oYXNMaW5lVGVybWluYXRvciAmJiAoaWQgPT09ICdhc3luYycpICYmXHJcblx0ICAgICAgICAgICAgICAgICF0aGlzLm1hdGNoKCc6JykgJiYgIXRoaXMubWF0Y2goJygnKSAmJiAhdGhpcy5tYXRjaCgnKicpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IGlzQXN5bmMgPyB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKSA6IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcihpZCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnKicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGxvb2thaGVhZFByb3BlcnR5S2V5ID0gdGhpcy5xdWFsaWZpZWRQcm9wZXJ0eU5hbWUodGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiAhaXNBc3luYyAmJiB0b2tlbi52YWx1ZSA9PT0gJ2dldCcgJiYgbG9va2FoZWFkUHJvcGVydHlLZXkpIHtcclxuXHQgICAgICAgICAgICBraW5kID0gJ2dldCc7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VHZXR0ZXJNZXRob2QoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiAhaXNBc3luYyAmJiB0b2tlbi52YWx1ZSA9PT0gJ3NldCcgJiYgbG9va2FoZWFkUHJvcGVydHlLZXkpIHtcclxuXHQgICAgICAgICAgICBraW5kID0gJ3NldCc7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlU2V0dGVyTWV0aG9kKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgdG9rZW4udmFsdWUgPT09ICcqJyAmJiBsb29rYWhlYWRQcm9wZXJ0eUtleSkge1xyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnaW5pdCc7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlR2VuZXJhdG9yTWV0aG9kKCk7XHJcblx0ICAgICAgICAgICAgbWV0aG9kID0gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGlmICgha2V5KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBraW5kID0gJ2luaXQnO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc6JykgJiYgIWlzQXN5bmMpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCFjb21wdXRlZCAmJiB0aGlzLmlzUHJvcGVydHlLZXkoa2V5LCAnX19wcm90b19fJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChoYXNQcm90by52YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkR1cGxpY2F0ZVByb3RvUHJvcGVydHkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaGFzUHJvdG8udmFsdWUgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJygnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IGlzQXN5bmMgPyB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2RBc3luY0Z1bmN0aW9uKCkgOiB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2RGdW5jdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICBtZXRob2QgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKHRva2VuLnZhbHVlKSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzaG9ydGhhbmQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGluaXQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Bc3NpZ25tZW50UGF0dGVybihpZCwgaW5pdCkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2hvcnRoYW5kID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaWQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuUHJvcGVydHkoa2luZCwga2V5LCBjb21wdXRlZCwgdmFsdWUsIG1ldGhvZCwgc2hvcnRoYW5kKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VPYmplY3RJbml0aWFsaXplciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBoYXNQcm90byA9IHsgdmFsdWU6IGZhbHNlIH07XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaCh0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHkoaGFzUHJvdG8pKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENvbW1hU2VwYXJhdG9yKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLk9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10ZW1wbGF0ZS1saXRlcmFsc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGVtcGxhdGVIZWFkID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KHRoaXMubG9va2FoZWFkLmhlYWQsICdUZW1wbGF0ZSBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIHRlbXBsYXRlIGhlYWQnKTtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdmFyIHJhdyA9IHRva2VuLnZhbHVlO1xyXG5cdCAgICAgICAgdmFyIGNvb2tlZCA9IHRva2VuLmNvb2tlZDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRlbXBsYXRlRWxlbWVudCh7IHJhdzogcmF3LCBjb29rZWQ6IGNvb2tlZCB9LCB0b2tlbi50YWlsKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VUZW1wbGF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMTAgLyogVGVtcGxhdGUgKi8pIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHZhciByYXcgPSB0b2tlbi52YWx1ZTtcclxuXHQgICAgICAgIHZhciBjb29rZWQgPSB0b2tlbi5jb29rZWQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UZW1wbGF0ZUVsZW1lbnQoeyByYXc6IHJhdywgY29va2VkOiBjb29rZWQgfSwgdG9rZW4udGFpbCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGVtcGxhdGVMaXRlcmFsID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHF1YXNpcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlSGVhZCgpO1xyXG5cdCAgICAgICAgcXVhc2lzLnB1c2gocXVhc2kpO1xyXG5cdCAgICAgICAgd2hpbGUgKCFxdWFzaS50YWlsKSB7XHJcblx0ICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlRXhwcmVzc2lvbigpKTtcclxuXHQgICAgICAgICAgICBxdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoKTtcclxuXHQgICAgICAgICAgICBxdWFzaXMucHVzaChxdWFzaSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UZW1wbGF0ZUxpdGVyYWwocXVhc2lzLCBleHByZXNzaW9ucykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1ncm91cGluZy1vcGVyYXRvclxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybiA9IGZ1bmN0aW9uIChleHByKSB7XHJcblx0ICAgICAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXI6XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguTWVtYmVyRXhwcmVzc2lvbjpcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5SZXN0RWxlbWVudDpcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjpcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguU3ByZWFkRWxlbWVudDpcclxuXHQgICAgICAgICAgICAgICAgZXhwci50eXBlID0gc3ludGF4XzEuU3ludGF4LlJlc3RFbGVtZW50O1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmFyZ3VtZW50KTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguQXJyYXlFeHByZXNzaW9uOlxyXG5cdCAgICAgICAgICAgICAgICBleHByLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXJyYXlQYXR0ZXJuO1xyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHIuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChleHByLmVsZW1lbnRzW2ldICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5lbGVtZW50c1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguT2JqZWN0RXhwcmVzc2lvbjpcclxuXHQgICAgICAgICAgICAgICAgZXhwci50eXBlID0gc3ludGF4XzEuU3ludGF4Lk9iamVjdFBhdHRlcm47XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwci5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLnByb3BlcnRpZXNbaV0udmFsdWUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uOlxyXG5cdCAgICAgICAgICAgICAgICBleHByLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudFBhdHRlcm47XHJcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSBleHByLm9wZXJhdG9yO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmxlZnQpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAvLyBBbGxvdyBvdGhlciBub2RlIHR5cGUgZm9yIHRvbGVyYW50IHBhcnNpbmcuXHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlR3JvdXBFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCc9PicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc9PicpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICBwYXJhbXM6IFtdLFxyXG5cdCAgICAgICAgICAgICAgICBhc3luYzogZmFsc2VcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICB2YXIgcGFyYW1zID0gW107XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJy4uLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlUmVzdEVsZW1lbnQocGFyYW1zKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCc9PicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnPT4nKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgIHBhcmFtczogW2V4cHJdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgYXJyb3cgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChleHByKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwcmVzc2lvbnNbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycm93ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IGV4cHJlc3Npb25zLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJy4uLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZVJlc3RFbGVtZW50KHBhcmFtcykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJz0+JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc9PicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHJlc3Npb25zW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdyA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBleHByZXNzaW9ucyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWFycm93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLlNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICghYXJyb3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnPT4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyICYmIGV4cHIubmFtZSA9PT0gJ3lpZWxkJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdyA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbZXhwcl0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnJvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguU2VxdWVuY2VFeHByZXNzaW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHIuZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmV4cHJlc3Npb25zW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJzID0gKGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LlNlcXVlbmNlRXhwcmVzc2lvbiA/IGV4cHIuZXhwcmVzc2lvbnMgOiBbZXhwcl0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1ldGVycyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGVmdC1oYW5kLXNpZGUtZXhwcmVzc2lvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFyZ3VtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZXhwciA9IHRoaXMubWF0Y2goJy4uLicpID8gdGhpcy5wYXJzZVNwcmVhZEVsZW1lbnQoKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHIpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENvbW1hU2VwYXJhdG9yKCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgIHJldHVybiBhcmdzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmlzSWRlbnRpZmllck5hbWUgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIHJldHVybiB0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gfHxcclxuXHQgICAgICAgICAgICB0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8gfHxcclxuXHQgICAgICAgICAgICB0b2tlbi50eXBlID09PSAxIC8qIEJvb2xlYW5MaXRlcmFsICovIHx8XHJcblx0ICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gNSAvKiBOdWxsTGl0ZXJhbCAqLztcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUlkZW50aWZpZXJOYW1lID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMuaXNJZGVudGlmaWVyTmFtZSh0b2tlbikpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIodG9rZW4udmFsdWUpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU5ld0V4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQoaWQubmFtZSA9PT0gJ25ldycsICdOZXcgZXhwcmVzc2lvbiBtdXN0IHN0YXJ0IHdpdGggYG5ld2AnKTtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJy4nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkgJiYgdGhpcy5sb29rYWhlYWQudmFsdWUgPT09ICd0YXJnZXQnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gbmV3IE5vZGUuTWV0YVByb3BlcnR5KGlkLCBwcm9wZXJ0eSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YXIgY2FsbGVlID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICB2YXIgYXJncyA9IHRoaXMubWF0Y2goJygnKSA/IHRoaXMucGFyc2VBcmd1bWVudHMoKSA6IFtdO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSBuZXcgTm9kZS5OZXdFeHByZXNzaW9uKGNhbGxlZSwgYXJncyk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBleHByKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFzeW5jQXJndW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgYXJnID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcclxuXHQgICAgICAgIHJldHVybiBhcmc7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBc3luY0FyZ3VtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZXhwciA9IHRoaXMubWF0Y2goJy4uLicpID8gdGhpcy5wYXJzZVNwcmVhZEVsZW1lbnQoKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzeW5jQXJndW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICBhcmdzLnB1c2goZXhwcik7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q29tbWFTZXBhcmF0b3IoKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgcmV0dXJuIGFyZ3M7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBtYXliZUFzeW5jID0gdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhc3luYycpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dJbiA9IHRoaXMuY29udGV4dC5hbGxvd0luO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ3N1cGVyJykgJiYgdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5KSB7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUoZXhwciwgbmV3IE5vZGUuU3VwZXIoKSk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcoJykgJiYgIXRoaXMubWF0Y2goJy4nKSAmJiAhdGhpcy5tYXRjaCgnWycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5tYXRjaEtleXdvcmQoJ25ldycpID8gdGhpcy5wYXJzZU5ld0V4cHJlc3Npb24gOiB0aGlzLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLicpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLlN0YXRpY01lbWJlckV4cHJlc3Npb24oZXhwciwgcHJvcGVydHkpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnKCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBhc3luY0Fycm93ID0gbWF5YmVBc3luYyAmJiAoc3RhcnRUb2tlbi5saW5lTnVtYmVyID09PSB0aGlzLmxvb2thaGVhZC5saW5lTnVtYmVyKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFzeW5jQXJyb3cgPyB0aGlzLnBhcnNlQXN5bmNBcmd1bWVudHMoKSA6IHRoaXMucGFyc2VBcmd1bWVudHMoKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLkNhbGxFeHByZXNzaW9uKGV4cHIsIGFyZ3MpKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGFzeW5jQXJyb3cgJiYgdGhpcy5tYXRjaCgnPT4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oYXJnc1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBhcmdzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJ1snKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJ1snKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJ10nKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLkNvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbihleHByLCBwcm9wZXJ0eSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAxMCAvKiBUZW1wbGF0ZSAqLyAmJiB0aGlzLmxvb2thaGVhZC5oZWFkKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBxdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZUxpdGVyYWwoKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihleHByLCBxdWFzaSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN1cGVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnc3VwZXInKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnWycpICYmICF0aGlzLm1hdGNoKCcuJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlN1cGVyKCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydCh0aGlzLmNvbnRleHQuYWxsb3dJbiwgJ2NhbGxlZSBvZiBuZXcgZXhwcmVzc2lvbiBhbHdheXMgYWxsb3cgaW4ga2V5d29yZC4nKTtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUodGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSAodGhpcy5tYXRjaEtleXdvcmQoJ3N1cGVyJykgJiYgdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5KSA/IHRoaXMucGFyc2VTdXBlcigpIDpcclxuXHQgICAgICAgICAgICB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5tYXRjaEtleXdvcmQoJ25ldycpID8gdGhpcy5wYXJzZU5ld0V4cHJlc3Npb24gOiB0aGlzLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnWycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnWycpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnXScpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Db21wdXRlZE1lbWJlckV4cHJlc3Npb24oZXhwciwgcHJvcGVydHkpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLicpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuU3RhdGljTWVtYmVyRXhwcmVzc2lvbihleHByLCBwcm9wZXJ0eSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAxMCAvKiBUZW1wbGF0ZSAqLyAmJiB0aGlzLmxvb2thaGVhZC5oZWFkKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBxdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZUxpdGVyYWwoKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKGV4cHIsIHF1YXNpKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdXBkYXRlLWV4cHJlc3Npb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VVcGRhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJysrJykgfHwgdGhpcy5tYXRjaCgnLS0nKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbik7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VVbmFyeUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIgJiYgdGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQoZXhwci5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RMSFNQcmVmaXgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZExIU0luQXNzaWdubWVudCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHZhciBwcmVmaXggPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlVwZGF0ZUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIsIHByZWZpeCkpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yICYmIHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKysnKSB8fCB0aGlzLm1hdGNoKCctLScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyICYmIHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKGV4cHIubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RMSFNQb3N0Zml4KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHRoaXMubmV4dFRva2VuKCkudmFsdWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuVXBkYXRlRXhwcmVzc2lvbihvcGVyYXRvciwgZXhwciwgcHJlZml4KSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdW5hcnktb3BlcmF0b3JzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBd2FpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHZhciBhcmd1bWVudCA9IHRoaXMucGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkF3YWl0RXhwcmVzc2lvbihhcmd1bWVudCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVW5hcnlFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnKycpIHx8IHRoaXMubWF0Y2goJy0nKSB8fCB0aGlzLm1hdGNoKCd+JykgfHwgdGhpcy5tYXRjaCgnIScpIHx8XHJcblx0ICAgICAgICAgICAgdGhpcy5tYXRjaEtleXdvcmQoJ2RlbGV0ZScpIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCd2b2lkJykgfHwgdGhpcy5tYXRjaEtleXdvcmQoJ3R5cGVvZicpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VVbmFyeUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlVuYXJ5RXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwcikpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGV4cHIub3BlcmF0b3IgPT09ICdkZWxldGUnICYmIGV4cHIuYXJndW1lbnQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RGVsZXRlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRleHQuYXdhaXQgJiYgdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhd2FpdCcpKSB7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VBd2FpdEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlVXBkYXRlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VFeHBvbmVudGlhdGlvbkV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZVVuYXJ5RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICBpZiAoZXhwci50eXBlICE9PSBzeW50YXhfMS5TeW50YXguVW5hcnlFeHByZXNzaW9uICYmIHRoaXMubWF0Y2goJyoqJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHZhciBsZWZ0ID0gZXhwcjtcclxuXHQgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUV4cG9uZW50aWF0aW9uRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLkJpbmFyeUV4cHJlc3Npb24oJyoqJywgbGVmdCwgcmlnaHQpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1leHAtb3BlcmF0b3JcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbXVsdGlwbGljYXRpdmUtb3BlcmF0b3JzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFkZGl0aXZlLW9wZXJhdG9yc1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1iaXR3aXNlLXNoaWZ0LW9wZXJhdG9yc1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWxhdGlvbmFsLW9wZXJhdG9yc1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lcXVhbGl0eS1vcGVyYXRvcnNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYmluYXJ5LWJpdHdpc2Utb3BlcmF0b3JzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWJpbmFyeS1sb2dpY2FsLW9wZXJhdG9yc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmJpbmFyeVByZWNlZGVuY2UgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIHZhciBvcCA9IHRva2VuLnZhbHVlO1xyXG5cdCAgICAgICAgdmFyIHByZWNlZGVuY2U7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovKSB7XHJcblx0ICAgICAgICAgICAgcHJlY2VkZW5jZSA9IHRoaXMub3BlcmF0b3JQcmVjZWRlbmNlW29wXSB8fCAwO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gNCAvKiBLZXl3b3JkICovKSB7XHJcblx0ICAgICAgICAgICAgcHJlY2VkZW5jZSA9IChvcCA9PT0gJ2luc3RhbmNlb2YnIHx8ICh0aGlzLmNvbnRleHQuYWxsb3dJbiAmJiBvcCA9PT0gJ2luJykpID8gNyA6IDA7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBwcmVjZWRlbmNlID0gMDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBwcmVjZWRlbmNlO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQmluYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlRXhwb25lbnRpYXRpb25FeHByZXNzaW9uKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIHByZWMgPSB0aGlzLmJpbmFyeVByZWNlZGVuY2UodG9rZW4pO1xyXG5cdCAgICAgICAgaWYgKHByZWMgPiAwKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB2YXIgbWFya2VycyA9IFtzdGFydFRva2VuLCB0aGlzLmxvb2thaGVhZF07XHJcblx0ICAgICAgICAgICAgdmFyIGxlZnQgPSBleHByO1xyXG5cdCAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlRXhwb25lbnRpYXRpb25FeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICB2YXIgc3RhY2sgPSBbbGVmdCwgdG9rZW4udmFsdWUsIHJpZ2h0XTtcclxuXHQgICAgICAgICAgICB2YXIgcHJlY2VkZW5jZXMgPSBbcHJlY107XHJcblx0ICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICAgICAgcHJlYyA9IHRoaXMuYmluYXJ5UHJlY2VkZW5jZSh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChwcmVjIDw9IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIC8vIFJlZHVjZTogbWFrZSBhIGJpbmFyeSBleHByZXNzaW9uIGZyb20gdGhlIHRocmVlIHRvcG1vc3QgZW50cmllcy5cclxuXHQgICAgICAgICAgICAgICAgd2hpbGUgKChzdGFjay5sZW5ndGggPiAyKSAmJiAocHJlYyA8PSBwcmVjZWRlbmNlc1twcmVjZWRlbmNlcy5sZW5ndGggLSAxXSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gc3RhY2sucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBzdGFjay5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2VzLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbWFya2Vycy5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUobWFya2Vyc1ttYXJrZXJzLmxlbmd0aCAtIDFdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5CaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkpKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAvLyBTaGlmdC5cclxuXHQgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzLm5leHRUb2tlbigpLnZhbHVlKTtcclxuXHQgICAgICAgICAgICAgICAgcHJlY2VkZW5jZXMucHVzaChwcmVjKTtcclxuXHQgICAgICAgICAgICAgICAgbWFya2Vycy5wdXNoKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUV4cG9uZW50aWF0aW9uRXhwcmVzc2lvbikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAvLyBGaW5hbCByZWR1Y2UgdG8gY2xlYW4tdXAgdGhlIHN0YWNrLlxyXG5cdCAgICAgICAgICAgIHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTtcclxuXHQgICAgICAgICAgICBleHByID0gc3RhY2tbaV07XHJcblx0ICAgICAgICAgICAgbWFya2Vycy5wb3AoKTtcclxuXHQgICAgICAgICAgICB3aGlsZSAoaSA+IDEpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZShtYXJrZXJzLnBvcCgpKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gc3RhY2tbaSAtIDFdO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5CaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBzdGFja1tpIC0gMl0sIGV4cHIpKTtcclxuXHQgICAgICAgICAgICAgICAgaSAtPSAyO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jb25kaXRpb25hbC1vcGVyYXRvclxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VCaW5hcnlFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCc/JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93SW4gPSB0aGlzLmNvbnRleHQuYWxsb3dJbjtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHRydWU7XHJcblx0ICAgICAgICAgICAgdmFyIGNvbnNlcXVlbnQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOicpO1xyXG5cdCAgICAgICAgICAgIHZhciBhbHRlcm5hdGUgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQ29uZGl0aW9uYWxFeHByZXNzaW9uKGV4cHIsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFzc2lnbm1lbnQtb3BlcmF0b3JzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuY2hlY2tQYXR0ZXJuUGFyYW0gPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyYW0pIHtcclxuXHQgICAgICAgIHN3aXRjaCAocGFyYW0udHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXI6XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVQYXJhbShvcHRpb25zLCBwYXJhbSwgcGFyYW0ubmFtZSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LlJlc3RFbGVtZW50OlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLmFyZ3VtZW50KTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudFBhdHRlcm46XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0ubGVmdCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LkFycmF5UGF0dGVybjpcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbS5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtLmVsZW1lbnRzW2ldICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbS5lbGVtZW50c1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguT2JqZWN0UGF0dGVybjpcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLnByb3BlcnRpZXNbaV0udmFsdWUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgb3B0aW9ucy5zaW1wbGUgPSBvcHRpb25zLnNpbXBsZSAmJiAocGFyYW0gaW5zdGFuY2VvZiBOb2RlLklkZW50aWZpZXIpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnJlaW50ZXJwcmV0QXNDb3ZlckZvcm1hbHNMaXN0ID0gZnVuY3Rpb24gKGV4cHIpIHtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBbZXhwcl07XHJcblx0ICAgICAgICB2YXIgb3B0aW9ucztcclxuXHQgICAgICAgIHZhciBhc3luY0Fycm93ID0gZmFsc2U7XHJcblx0ICAgICAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXI6XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcjpcclxuXHQgICAgICAgICAgICAgICAgcGFyYW1zID0gZXhwci5wYXJhbXM7XHJcblx0ICAgICAgICAgICAgICAgIGFzeW5jQXJyb3cgPSBleHByLmFzeW5jO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIG9wdGlvbnMgPSB7XHJcblx0ICAgICAgICAgICAgc2ltcGxlOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIHBhcmFtU2V0OiB7fVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zW2ldO1xyXG5cdCAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudFBhdHRlcm4pIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnJpZ2h0LnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5ZaWVsZEV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbS5yaWdodC5hcmd1bWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyYW0ucmlnaHQudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyYW0ucmlnaHQubmFtZSA9ICd5aWVsZCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW0ucmlnaHQuYXJndW1lbnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW0ucmlnaHQuZGVsZWdhdGU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoYXN5bmNBcnJvdyAmJiBwYXJhbS50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllciAmJiBwYXJhbS5uYW1lID09PSAnYXdhaXQnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtKTtcclxuXHQgICAgICAgICAgICBwYXJhbXNbaV0gPSBwYXJhbTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0IHx8ICF0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCkge1xyXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1tpXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5ZaWVsZEV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKG9wdGlvbnMubWVzc2FnZSA9PT0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGUpIHtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmNvbnRleHQuc3RyaWN0ID8gb3B0aW9ucy5zdHJpY3RlZCA6IG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkO1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG9wdGlvbnMubWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHNpbXBsZTogb3B0aW9ucy5zaW1wbGUsXHJcblx0ICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXHJcblx0ICAgICAgICAgICAgc3RyaWN0ZWQ6IG9wdGlvbnMuc3RyaWN0ZWQsXHJcblx0ICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCxcclxuXHQgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2VcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCAmJiB0aGlzLm1hdGNoS2V5d29yZCgneWllbGQnKSkge1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlWWllbGRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHN0YXJ0VG9rZW47XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmICh0b2tlbi5saW5lTnVtYmVyID09PSB0aGlzLmxvb2thaGVhZC5saW5lTnVtYmVyKSAmJiB0b2tlbi52YWx1ZSA9PT0gJ2FzeW5jJykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCd5aWVsZCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gdGhpcy5wYXJzZVByaW1hcnlFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihhcmcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogW2FyZ10sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlciB8fCB0aGlzLm1hdGNoKCc9PicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycm93LWZ1bmN0aW9uLWRlZmluaXRpb25zXHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGlzQXN5bmMgPSBleHByLmFzeW5jO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IHRoaXMucmVpbnRlcnByZXRBc0NvdmVyRm9ybWFsc0xpc3QoZXhwcik7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChsaXN0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNMaW5lVGVybWluYXRvcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QgPSB0aGlzLmNvbnRleHQuc3RyaWN0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmUgPSB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBsaXN0LnNpbXBsZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0F3YWl0ID0gdGhpcy5jb250ZXh0LmF3YWl0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gaXNBc3luYztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnPT4nKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gdm9pZCAwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ3snKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93SW4gPSB0aGlzLmNvbnRleHQuYWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGJvZHkudHlwZSAhPT0gc3ludGF4XzEuU3ludGF4LkJsb2NrU3RhdGVtZW50O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgbGlzdC5maXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKGxpc3QuZmlyc3RSZXN0cmljdGVkLCBsaXN0Lm1lc3NhZ2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgbGlzdC5zdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4obGlzdC5zdHJpY3RlZCwgbGlzdC5tZXNzYWdlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSBpc0FzeW5jID8gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Bc3luY0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKGxpc3QucGFyYW1zLCBib2R5LCBleHByZXNzaW9uKSkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24obGlzdC5wYXJhbXMsIGJvZHksIGV4cHJlc3Npb24pKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IHByZXZpb3VzQXdhaXQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoQXNzaWduKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGV4cHI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKGlkLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0TEhTQXNzaWdubWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKGlkLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB0b2tlbi52YWx1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLkFzc2lnbm1lbnRFeHByZXNzaW9uKG9wZXJhdG9yLCBleHByLCByaWdodCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY29tbWEtb3BlcmF0b3JcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcclxuXHQgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGV4cHIpO1xyXG5cdCAgICAgICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5TZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1ibG9ja1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovKSB7XHJcblx0ICAgICAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC52YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdleHBvcnQnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNNb2R1bGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkLCBtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxFeHBvcnREZWNsYXJhdGlvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdpbXBvcnQnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNNb2R1bGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkLCBtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxJbXBvcnREZWNsYXJhdGlvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlSW1wb3J0RGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdjb25zdCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlTGV4aWNhbERlY2xhcmF0aW9uKHsgaW5Gb3I6IGZhbHNlIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnY2xhc3MnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUNsYXNzRGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdsZXQnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5pc0xleGljYWxEZWNsYXJhdGlvbigpID8gdGhpcy5wYXJzZUxleGljYWxEZWNsYXJhdGlvbih7IGluRm9yOiBmYWxzZSB9KSA6IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHN0YXRlbWVudDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJsb2NrID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB2YXIgYmxvY2sgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgYmxvY2sucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQmxvY2tTdGF0ZW1lbnQoYmxvY2spKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGV0LWFuZC1jb25zdC1kZWNsYXJhdGlvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxleGljYWxCaW5kaW5nID0gZnVuY3Rpb24gKGtpbmQsIG9wdGlvbnMpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gW107XHJcblx0ICAgICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgaWQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQoaWQubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0VmFyTmFtZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKGtpbmQgPT09ICdjb25zdCcpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hLZXl3b3JkKCdpbicpICYmICF0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ29mJykpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkRlY2xhcmF0aW9uTWlzc2luZ0luaXRpYWxpemVyLCAnY29uc3QnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKCghb3B0aW9ucy5pbkZvciAmJiBpZC50eXBlICE9PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikgfHwgdGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0nKTtcclxuXHQgICAgICAgICAgICBpbml0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0b3IoaWQsIGluaXQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJpbmRpbmdMaXN0ID0gZnVuY3Rpb24gKGtpbmQsIG9wdGlvbnMpIHtcclxuXHQgICAgICAgIHZhciBsaXN0ID0gW3RoaXMucGFyc2VMZXhpY2FsQmluZGluZyhraW5kLCBvcHRpb25zKV07XHJcblx0ICAgICAgICB3aGlsZSAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBsaXN0LnB1c2godGhpcy5wYXJzZUxleGljYWxCaW5kaW5nKGtpbmQsIG9wdGlvbnMpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBsaXN0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmlzTGV4aWNhbERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zY2FubmVyLnNhdmVTdGF0ZSgpO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLnNjYW5Db21tZW50cygpO1xyXG5cdCAgICAgICAgdmFyIG5leHQgPSB0aGlzLnNjYW5uZXIubGV4KCk7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIucmVzdG9yZVN0YXRlKHN0YXRlKTtcclxuXHQgICAgICAgIHJldHVybiAobmV4dC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHx8XHJcblx0ICAgICAgICAgICAgKG5leHQudHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIG5leHQudmFsdWUgPT09ICdbJykgfHxcclxuXHQgICAgICAgICAgICAobmV4dC50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgbmV4dC52YWx1ZSA9PT0gJ3snKSB8fFxyXG5cdCAgICAgICAgICAgIChuZXh0LnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyAmJiBuZXh0LnZhbHVlID09PSAnbGV0JykgfHxcclxuXHQgICAgICAgICAgICAobmV4dC50eXBlID09PSA0IC8qIEtleXdvcmQgKi8gJiYgbmV4dC52YWx1ZSA9PT0gJ3lpZWxkJyk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VMZXhpY2FsRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBraW5kID0gdGhpcy5uZXh0VG9rZW4oKS52YWx1ZTtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydChraW5kID09PSAnbGV0JyB8fCBraW5kID09PSAnY29uc3QnLCAnTGV4aWNhbCBkZWNsYXJhdGlvbiBtdXN0IGJlIGVpdGhlciBsZXQgb3IgY29uc3QnKTtcclxuXHQgICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3Qoa2luZCwgb3B0aW9ucyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWRlc3RydWN0dXJpbmctYmluZGluZy1wYXR0ZXJuc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQmluZGluZ1Jlc3RFbGVtZW50ID0gZnVuY3Rpb24gKHBhcmFtcywga2luZCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcuLi4nKTtcclxuXHQgICAgICAgIHZhciBhcmcgPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuUmVzdEVsZW1lbnQoYXJnKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBcnJheVBhdHRlcm4gPSBmdW5jdGlvbiAocGFyYW1zLCBraW5kKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ1snKTtcclxuXHQgICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCddJykpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobnVsbCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLi4uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2godGhpcy5wYXJzZUJpbmRpbmdSZXN0RWxlbWVudChwYXJhbXMsIGtpbmQpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzLnBhcnNlUGF0dGVybldpdGhEZWZhdWx0KHBhcmFtcywga2luZCkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnXScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ10nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFycmF5UGF0dGVybihlbGVtZW50cykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJvcGVydHlQYXR0ZXJuID0gZnVuY3Rpb24gKHBhcmFtcywga2luZCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBjb21wdXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHNob3J0aGFuZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGtleTtcclxuXHQgICAgICAgIHZhciB2YWx1ZTtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICB2YXIga2V5VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgdmFyIGluaXQgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIoa2V5VG9rZW4udmFsdWUpKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGtleVRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgc2hvcnRoYW5kID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKGtleVRva2VuKSwgbmV3IE5vZGUuQXNzaWdubWVudFBhdHRlcm4oaW5pdCwgZXhwcikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5tYXRjaCgnOicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGtleVRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgc2hvcnRoYW5kID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBpbml0O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJzonKTtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlUGF0dGVybldpdGhEZWZhdWx0KHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJzonKTtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlByb3BlcnR5KCdpbml0Jywga2V5LCBjb21wdXRlZCwgdmFsdWUsIG1ldGhvZCwgc2hvcnRoYW5kKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VPYmplY3RQYXR0ZXJuID0gZnVuY3Rpb24gKHBhcmFtcywga2luZCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gW107XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2godGhpcy5wYXJzZVByb3BlcnR5UGF0dGVybihwYXJhbXMsIGtpbmQpKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5PYmplY3RQYXR0ZXJuKHByb3BlcnRpZXMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVBhdHRlcm4gPSBmdW5jdGlvbiAocGFyYW1zLCBraW5kKSB7XHJcblx0ICAgICAgICB2YXIgcGF0dGVybjtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCdbJykpIHtcclxuXHQgICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5wYXJzZUFycmF5UGF0dGVybihwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgneycpKSB7XHJcblx0ICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMucGFyc2VPYmplY3RQYXR0ZXJuKHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2xldCcpICYmIChraW5kID09PSAnY29uc3QnIHx8IGtpbmQgPT09ICdsZXQnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkLCBtZXNzYWdlc18xLk1lc3NhZ2VzLkxldEluTGV4aWNhbEJpbmRpbmcpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBwYXJhbXMucHVzaCh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoa2luZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gcGF0dGVybjtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVBhdHRlcm5XaXRoRGVmYXVsdCA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgcGF0dGVybiA9IHRoaXMucGFyc2VQYXR0ZXJuKHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5Bc3NpZ25tZW50UGF0dGVybihwYXR0ZXJuLCByaWdodCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHBhdHRlcm47XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXZhcmlhYmxlLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyID0gZnVuY3Rpb24gKGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJ3lpZWxkJykge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29udGV4dC5hbGxvd1lpZWxkKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgIT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRva2VuLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyAmJiB0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCB8fCB0b2tlbi52YWx1ZSAhPT0gJ2xldCcgfHwga2luZCAhPT0gJ3ZhcicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoKHRoaXMuY29udGV4dC5pc01vZHVsZSB8fCB0aGlzLmNvbnRleHQuYXdhaXQpICYmIHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJ2F3YWl0Jykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0b2tlbi52YWx1ZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZVBhdHRlcm4ocGFyYW1zLCAndmFyJyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBpZC50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RWYXJOYW1lKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBpbml0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmIChpZC50eXBlICE9PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllciAmJiAhb3B0aW9ucy5pbkZvcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc9Jyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0b3IoaWQsIGluaXQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHQgICAgICAgIHZhciBvcHQgPSB7IGluRm9yOiBvcHRpb25zLmluRm9yIH07XHJcblx0ICAgICAgICB2YXIgbGlzdCA9IFtdO1xyXG5cdCAgICAgICAgbGlzdC5wdXNoKHRoaXMucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uKG9wdCkpO1xyXG5cdCAgICAgICAgd2hpbGUgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgbGlzdC5wdXNoKHRoaXMucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uKG9wdCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGxpc3Q7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VWYXJpYWJsZVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3ZhcicpO1xyXG5cdCAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCh7IGluRm9yOiBmYWxzZSB9KTtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsICd2YXInKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVtcHR5LXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRW1wdHlTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJzsnKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkVtcHR5U3RhdGVtZW50KCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1leHByZXNzaW9uLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pZi1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUlmQ2xhdXNlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSWZTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGNvbnNlcXVlbnQ7XHJcblx0ICAgICAgICB2YXIgYWx0ZXJuYXRlID0gbnVsbDtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnaWYnKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgdGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSAmJiB0aGlzLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgY29uc2VxdWVudCA9IHRoaXMuZmluYWxpemUodGhpcy5jcmVhdGVOb2RlKCksIG5ldyBOb2RlLkVtcHR5U3RhdGVtZW50KCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICBjb25zZXF1ZW50ID0gdGhpcy5wYXJzZUlmQ2xhdXNlKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdlbHNlJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgYWx0ZXJuYXRlID0gdGhpcy5wYXJzZUlmQ2xhdXNlKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWZTdGF0ZW1lbnQodGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWRvLXdoaWxlLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRG9XaGlsZVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2RvJyk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJbkl0ZXJhdGlvbiA9IHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHByZXZpb3VzSW5JdGVyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3doaWxlJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIHRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykgJiYgdGhpcy5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnOycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRG9XaGlsZVN0YXRlbWVudChib2R5LCB0ZXN0KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXdoaWxlLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlV2hpbGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3doaWxlJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIHRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykgJiYgdGhpcy5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIGJvZHkgPSB0aGlzLmZpbmFsaXplKHRoaXMuY3JlYXRlTm9kZSgpLCBuZXcgTm9kZS5FbXB0eVN0YXRlbWVudCgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzSW5JdGVyYXRpb24gPSB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb247XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHByZXZpb3VzSW5JdGVyYXRpb247XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5XaGlsZVN0YXRlbWVudCh0ZXN0LCBib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWZvci1zdGF0ZW1lbnRcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZm9yLWluLWFuZC1mb3Itb2Ytc3RhdGVtZW50c1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRm9yU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIHRlc3QgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIHVwZGF0ZSA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgZm9ySW4gPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIGxlZnQsIHJpZ2h0O1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZm9yJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJzsnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ3ZhcicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dJbiA9IHRoaXMuY29udGV4dC5hbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdGhpcy5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KHsgaW5Gb3I6IHRydWUgfSk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiB0aGlzLm1hdGNoS2V5d29yZCgnaW4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2wgPSBkZWNsYXJhdGlvbnNbMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGVjbC5pbml0ICYmIChkZWNsLmlkLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5BcnJheVBhdHRlcm4gfHwgZGVjbC5pZC50eXBlID09PSBzeW50YXhfMS5TeW50YXguT2JqZWN0UGF0dGVybiB8fCB0aGlzLmNvbnRleHQuc3RyaWN0KSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkZvckluT2ZMb29wSW5pdGlhbGl6ZXIsICdmb3ItaW4nKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCAndmFyJykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiBkZWNsYXJhdGlvbnNbMF0uaW5pdCA9PT0gbnVsbCAmJiB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ29mJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCAndmFyJykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9ySW4gPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCAndmFyJykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJzsnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnY29uc3QnKSB8fCB0aGlzLm1hdGNoS2V5d29yZCgnbGV0JykpIHtcclxuXHQgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIga2luZCA9IHRoaXMubmV4dFRva2VuKCkudmFsdWU7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLmxvb2thaGVhZC52YWx1ZSA9PT0gJ2luJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuSWRlbnRpZmllcihraW5kKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93SW4gPSB0aGlzLmNvbnRleHQuYWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KGtpbmQsIHsgaW5Gb3I6IHRydWUgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIGRlY2xhcmF0aW9uc1swXS5pbml0ID09PSBudWxsICYmIHRoaXMubWF0Y2hLZXl3b3JkKCdpbicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgZGVjbGFyYXRpb25zWzBdLmluaXQgPT09IG51bGwgJiYgdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdvZicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9ySW4gPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBpbml0U3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnaW4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0IHx8IGluaXQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZExIU0luRm9ySW4pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGluaXQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ29mJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCB8fCBpbml0LnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRMSFNJbkZvckxvb3ApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGluaXQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3JJbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbml0U2VxID0gW2luaXRdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdFNlcS5wdXNoKHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoaW5pdFN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5TZXF1ZW5jZUV4cHJlc3Npb24oaW5pdFNlcSkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJzsnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJzsnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJzsnKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICB1cGRhdGUgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBib2R5O1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykgJiYgdGhpcy5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIGJvZHkgPSB0aGlzLmZpbmFsaXplKHRoaXMuY3JlYXRlTm9kZSgpLCBuZXcgTm9kZS5FbXB0eVN0YXRlbWVudCgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzSW5JdGVyYXRpb24gPSB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb247XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VTdGF0ZW1lbnQpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHByZXZpb3VzSW5JdGVyYXRpb247XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gKHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJykgP1xyXG5cdCAgICAgICAgICAgIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRm9yU3RhdGVtZW50KGluaXQsIHRlc3QsIHVwZGF0ZSwgYm9keSkpIDpcclxuXHQgICAgICAgICAgICBmb3JJbiA/IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRm9ySW5TdGF0ZW1lbnQobGVmdCwgcmlnaHQsIGJvZHkpKSA6XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRm9yT2ZTdGF0ZW1lbnQobGVmdCwgcmlnaHQsIGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY29udGludWUtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDb250aW51ZVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2NvbnRpbnVlJyk7XHJcblx0ICAgICAgICB2YXIgbGFiZWwgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiAhdGhpcy5oYXNMaW5lVGVybWluYXRvcikge1xyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICBsYWJlbCA9IGlkO1xyXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSAnJCcgKyBpZC5uYW1lO1xyXG5cdCAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29udGV4dC5sYWJlbFNldCwga2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5Vbmtub3duTGFiZWwsIGlkLm5hbWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgaWYgKGxhYmVsID09PSBudWxsICYmICF0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24pIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsQ29udGludWUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQ29udGludWVTdGF0ZW1lbnQobGFiZWwpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYnJlYWstc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VCcmVha1N0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2JyZWFrJyk7XHJcblx0ICAgICAgICB2YXIgbGFiZWwgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiAhdGhpcy5oYXNMaW5lVGVybWluYXRvcikge1xyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB2YXIga2V5ID0gJyQnICsgaWQubmFtZTtcclxuXHQgICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNvbnRleHQubGFiZWxTZXQsIGtleSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5rbm93bkxhYmVsLCBpZC5uYW1lKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgbGFiZWwgPSBpZDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgaWYgKGxhYmVsID09PSBudWxsICYmICF0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gJiYgIXRoaXMuY29udGV4dC5pblN3aXRjaCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxCcmVhayk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5CcmVha1N0YXRlbWVudChsYWJlbCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZXR1cm4tc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VSZXR1cm5TdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxSZXR1cm4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgncmV0dXJuJyk7XHJcblx0ICAgICAgICB2YXIgaGFzQXJndW1lbnQgPSAhdGhpcy5tYXRjaCgnOycpICYmICF0aGlzLm1hdGNoKCd9JykgJiZcclxuXHQgICAgICAgICAgICAhdGhpcy5oYXNMaW5lVGVybWluYXRvciAmJiB0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLztcclxuXHQgICAgICAgIHZhciBhcmd1bWVudCA9IGhhc0FyZ3VtZW50ID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IG51bGw7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlJldHVyblN0YXRlbWVudChhcmd1bWVudCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy13aXRoLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlV2l0aFN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0TW9kZVdpdGgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd3aXRoJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIG9iamVjdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSAmJiB0aGlzLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgYm9keSA9IHRoaXMuZmluYWxpemUodGhpcy5jcmVhdGVOb2RlKCksIG5ldyBOb2RlLkVtcHR5U3RhdGVtZW50KCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuV2l0aFN0YXRlbWVudChvYmplY3QsIGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3dpdGNoLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3dpdGNoQ2FzZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdGVzdDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZGVmYXVsdCcpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB0ZXN0ID0gbnVsbDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnY2FzZScpO1xyXG5cdCAgICAgICAgICAgIHRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJzonKTtcclxuXHQgICAgICAgIHZhciBjb25zZXF1ZW50ID0gW107XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCd9JykgfHwgdGhpcy5tYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSB8fCB0aGlzLm1hdGNoS2V5d29yZCgnY2FzZScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBjb25zZXF1ZW50LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuU3dpdGNoQ2FzZSh0ZXN0LCBjb25zZXF1ZW50KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTd2l0Y2hTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdzd2l0Y2gnKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgZGlzY3JpbWluYW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJblN3aXRjaCA9IHRoaXMuY29udGV4dC5pblN3aXRjaDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pblN3aXRjaCA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgY2FzZXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBkZWZhdWx0Rm91bmQgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHZhciBjbGF1c2UgPSB0aGlzLnBhcnNlU3dpdGNoQ2FzZSgpO1xyXG5cdCAgICAgICAgICAgIGlmIChjbGF1c2UudGVzdCA9PT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdEZvdW5kKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5NdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2gpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHRGb3VuZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGNhc2VzLnB1c2goY2xhdXNlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5Td2l0Y2ggPSBwcmV2aW91c0luU3dpdGNoO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuU3dpdGNoU3RhdGVtZW50KGRpc2NyaW1pbmFudCwgY2FzZXMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGFiZWxsZWQtc3RhdGVtZW50c1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTGFiZWxsZWRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdmFyIHN0YXRlbWVudDtcclxuXHQgICAgICAgIGlmICgoZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikgJiYgdGhpcy5tYXRjaCgnOicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB2YXIgaWQgPSBleHByO1xyXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSAnJCcgKyBpZC5uYW1lO1xyXG5cdCAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb250ZXh0LmxhYmVsU2V0LCBrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlJlZGVjbGFyYXRpb24sICdMYWJlbCcsIGlkLm5hbWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQubGFiZWxTZXRba2V5XSA9IHRydWU7XHJcblx0ICAgICAgICAgICAgdmFyIGJvZHkgPSB2b2lkIDA7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdjbGFzcycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZUNsYXNzRGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWNsYXJhdGlvbi5nZW5lcmF0b3IpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuR2VuZXJhdG9ySW5MZWdhY3lDb250ZXh0KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBib2R5ID0gZGVjbGFyYXRpb247XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBkZWxldGUgdGhpcy5jb250ZXh0LmxhYmVsU2V0W2tleV07XHJcblx0ICAgICAgICAgICAgc3RhdGVtZW50ID0gbmV3IE5vZGUuTGFiZWxlZFN0YXRlbWVudChpZCwgYm9keSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgICAgICBzdGF0ZW1lbnQgPSBuZXcgTm9kZS5FeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgc3RhdGVtZW50KTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdGhyb3ctc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VUaHJvd1N0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3Rocm93Jyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5oYXNMaW5lVGVybWluYXRvcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLk5ld2xpbmVBZnRlclRocm93KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBhcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRocm93U3RhdGVtZW50KGFyZ3VtZW50KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRyeS1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNhdGNoQ2xhdXNlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnY2F0Y2gnKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gW107XHJcblx0ICAgICAgICB2YXIgcGFyYW0gPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMpO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtTWFwID0ge307XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSAnJCcgKyBwYXJhbXNbaV0udmFsdWU7XHJcblx0ICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbU1hcCwga2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5EdXBsaWNhdGVCaW5kaW5nLCBwYXJhbXNbaV0udmFsdWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBwYXJhbU1hcFtrZXldID0gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHBhcmFtLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKHBhcmFtLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdENhdGNoVmFyaWFibGUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VCbG9jaygpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQ2F0Y2hDbGF1c2UocGFyYW0sIGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZpbmFsbHlDbGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2ZpbmFsbHknKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmxvY2soKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRyeVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3RyeScpO1xyXG5cdCAgICAgICAgdmFyIGJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XHJcblx0ICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMubWF0Y2hLZXl3b3JkKCdjYXRjaCcpID8gdGhpcy5wYXJzZUNhdGNoQ2xhdXNlKCkgOiBudWxsO1xyXG5cdCAgICAgICAgdmFyIGZpbmFsaXplciA9IHRoaXMubWF0Y2hLZXl3b3JkKCdmaW5hbGx5JykgPyB0aGlzLnBhcnNlRmluYWxseUNsYXVzZSgpIDogbnVsbDtcclxuXHQgICAgICAgIGlmICghaGFuZGxlciAmJiAhZmluYWxpemVyKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuTm9DYXRjaE9yRmluYWxseSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UcnlTdGF0ZW1lbnQoYmxvY2ssIGhhbmRsZXIsIGZpbmFsaXplcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1kZWJ1Z2dlci1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZURlYnVnZ2VyU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZGVidWdnZXInKTtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRGVidWdnZXJTdGF0ZW1lbnQoKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2Utc3RhdGVtZW50cy1hbmQtZGVjbGFyYXRpb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhdGVtZW50O1xyXG5cdCAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAxIC8qIEJvb2xlYW5MaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNSAvKiBOdWxsTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDYgLyogTnVtZXJpY0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA4IC8qIFN0cmluZ0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSAxMCAvKiBUZW1wbGF0ZSAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDkgLyogUmVndWxhckV4cHJlc3Npb24gKi86XHJcblx0ICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNyAvKiBQdW5jdHVhdG9yICovOlxyXG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmxvb2thaGVhZC52YWx1ZTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VCbG9jaygpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSAnKCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09ICc7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUVtcHR5U3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgMyAvKiBJZGVudGlmaWVyICovOlxyXG5cdCAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLm1hdGNoQXN5bmNGdW5jdGlvbigpID8gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKSA6IHRoaXMucGFyc2VMYWJlbGxlZFN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDQgLyogS2V5d29yZCAqLzpcclxuXHQgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC52YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnYnJlYWsnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VCcmVha1N0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29udGludWUnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VDb250aW51ZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVidWdnZXInOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VEZWJ1Z2dlclN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnZG8nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VEb1doaWxlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdmb3InOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VGb3JTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnaWYnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VJZlN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAncmV0dXJuJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlUmV0dXJuU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdzd2l0Y2gnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VTd2l0Y2hTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Rocm93JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlVGhyb3dTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RyeSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVRyeVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAndmFyJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlVmFyaWFibGVTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3doaWxlJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlV2hpbGVTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dpdGgnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VXaXRoU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gc3RhdGVtZW50O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mdW5jdGlvbi1kZWZpbml0aW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRGlyZWN0aXZlUHJvbG9ndWVzKCk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNMYWJlbFNldCA9IHRoaXMuY29udGV4dC5sYWJlbFNldDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0luSXRlcmF0aW9uID0gdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSW5Td2l0Y2ggPSB0aGlzLmNvbnRleHQuaW5Td2l0Y2g7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJbkZ1bmN0aW9uQm9keSA9IHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5sYWJlbFNldCA9IHt9O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5Td2l0Y2ggPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSA9IHRydWU7XHJcblx0ICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBib2R5LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5sYWJlbFNldCA9IHByZXZpb3VzTGFiZWxTZXQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSBwcmV2aW91c0luSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluU3dpdGNoID0gcHJldmlvdXNJblN3aXRjaDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSA9IHByZXZpb3VzSW5GdW5jdGlvbkJvZHk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5CbG9ja1N0YXRlbWVudChib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUudmFsaWRhdGVQYXJhbSA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJhbSwgbmFtZSkge1xyXG5cdCAgICAgICAgdmFyIGtleSA9ICckJyArIG5hbWU7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChuYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLnN0cmljdGVkID0gcGFyYW07XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UGFyYW1OYW1lO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMucGFyYW1TZXQsIGtleSkpIHtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3RlZCA9IHBhcmFtO1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICghb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQobmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQgPSBwYXJhbTtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQobmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQgPSBwYXJhbTtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLnBhcmFtU2V0LCBrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RyaWN0ZWQgPSBwYXJhbTtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdGlvbnMucGFyYW1TZXQsIGtleSwgeyB2YWx1ZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIG9wdGlvbnMucGFyYW1TZXRba2V5XSA9IHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VSZXN0RWxlbWVudCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnLi4uJyk7XHJcblx0ICAgICAgICB2YXIgYXJnID0gdGhpcy5wYXJzZVBhdHRlcm4ocGFyYW1zKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5EZWZhdWx0UmVzdFBhcmFtZXRlcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlBhcmFtZXRlckFmdGVyUmVzdFBhcmFtZXRlcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5SZXN0RWxlbWVudChhcmcpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZvcm1hbFBhcmFtZXRlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gW107XHJcblx0ICAgICAgICB2YXIgcGFyYW0gPSB0aGlzLm1hdGNoKCcuLi4nKSA/IHRoaXMucGFyc2VSZXN0RWxlbWVudChwYXJhbXMpIDogdGhpcy5wYXJzZVBhdHRlcm5XaXRoRGVmYXVsdChwYXJhbXMpO1xyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGFyYW0ob3B0aW9ucywgcGFyYW1zW2ldLCBwYXJhbXNbaV0udmFsdWUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgb3B0aW9ucy5zaW1wbGUgPSBvcHRpb25zLnNpbXBsZSAmJiAocGFyYW0gaW5zdGFuY2VvZiBOb2RlLklkZW50aWZpZXIpO1xyXG5cdCAgICAgICAgb3B0aW9ucy5wYXJhbXMucHVzaChwYXJhbSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGb3JtYWxQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKGZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgdmFyIG9wdGlvbnM7XHJcblx0ICAgICAgICBvcHRpb25zID0ge1xyXG5cdCAgICAgICAgICAgIHNpbXBsZTogdHJ1ZSxcclxuXHQgICAgICAgICAgICBwYXJhbXM6IFtdLFxyXG5cdCAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZDogZmlyc3RSZXN0cmljdGVkXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgb3B0aW9ucy5wYXJhbVNldCA9IHt9O1xyXG5cdCAgICAgICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVyKG9wdGlvbnMpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHNpbXBsZTogb3B0aW9ucy5zaW1wbGUsXHJcblx0ICAgICAgICAgICAgcGFyYW1zOiBvcHRpb25zLnBhcmFtcyxcclxuXHQgICAgICAgICAgICBzdHJpY3RlZDogb3B0aW9ucy5zdHJpY3RlZCxcclxuXHQgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQ6IG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkLFxyXG5cdCAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5tYXRjaEFzeW5jRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbWF0Y2ggPSB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzeW5jJyk7XHJcblx0ICAgICAgICBpZiAobWF0Y2gpIHtcclxuXHQgICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnNjYW5uZXIuc2F2ZVN0YXRlKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5zY2FubmVyLnNjYW5Db21tZW50cygpO1xyXG5cdCAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5zY2FubmVyLmxleCgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5yZXN0b3JlU3RhdGUoc3RhdGUpO1xyXG5cdCAgICAgICAgICAgIG1hdGNoID0gKHN0YXRlLmxpbmVOdW1iZXIgPT09IG5leHQubGluZU51bWJlcikgJiYgKG5leHQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovKSAmJiAobmV4dC52YWx1ZSA9PT0gJ2Z1bmN0aW9uJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gbWF0Y2g7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uID0gZnVuY3Rpb24gKGlkZW50aWZpZXJJc09wdGlvbmFsKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGlzQXN5bmMgPSB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzeW5jJyk7XHJcblx0ICAgICAgICBpZiAoaXNBc3luYykge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2Z1bmN0aW9uJyk7XHJcblx0ICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSBpc0FzeW5jID8gZmFsc2UgOiB0aGlzLm1hdGNoKCcqJyk7XHJcblx0ICAgICAgICBpZiAoaXNHZW5lcmF0b3IpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG1lc3NhZ2U7XHJcblx0ICAgICAgICB2YXIgaWQgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGZpcnN0UmVzdHJpY3RlZCA9IG51bGw7XHJcblx0ICAgICAgICBpZiAoIWlkZW50aWZpZXJJc09wdGlvbmFsIHx8ICF0aGlzLm1hdGNoKCcoJykpIHtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICBpZCA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93QXdhaXQgPSB0aGlzLmNvbnRleHQuYXdhaXQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBpc0FzeW5jO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSAhaXNHZW5lcmF0b3I7XHJcblx0ICAgICAgICB2YXIgZm9ybWFsUGFyYW1ldGVycyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKGZpcnN0UmVzdHJpY3RlZCk7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gZm9ybWFsUGFyYW1ldGVycy5wYXJhbXM7XHJcblx0ICAgICAgICB2YXIgc3RyaWN0ZWQgPSBmb3JtYWxQYXJhbWV0ZXJzLnN0cmljdGVkO1xyXG5cdCAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gZm9ybWFsUGFyYW1ldGVycy5maXJzdFJlc3RyaWN0ZWQ7XHJcblx0ICAgICAgICBpZiAoZm9ybWFsUGFyYW1ldGVycy5tZXNzYWdlKSB7XHJcblx0ICAgICAgICAgICAgbWVzc2FnZSA9IGZvcm1hbFBhcmFtZXRlcnMubWVzc2FnZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZSA9IHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IGZvcm1hbFBhcmFtZXRlcnMuc2ltcGxlO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHN0cmljdGVkLCBtZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBwcmV2aW91c0FsbG93QXdhaXQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHJldHVybiBpc0FzeW5jID8gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Bc3luY0Z1bmN0aW9uRGVjbGFyYXRpb24oaWQsIHBhcmFtcywgYm9keSkpIDpcclxuXHQgICAgICAgICAgICB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRGVjbGFyYXRpb24oaWQsIHBhcmFtcywgYm9keSwgaXNHZW5lcmF0b3IpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaXNBc3luYyA9IHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXN5bmMnKTtcclxuXHQgICAgICAgIGlmIChpc0FzeW5jKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZnVuY3Rpb24nKTtcclxuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IGlzQXN5bmMgPyBmYWxzZSA6IHRoaXMubWF0Y2goJyonKTtcclxuXHQgICAgICAgIGlmIChpc0dlbmVyYXRvcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbWVzc2FnZTtcclxuXHQgICAgICAgIHZhciBpZCA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgZmlyc3RSZXN0cmljdGVkO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dBd2FpdCA9IHRoaXMuY29udGV4dC5hd2FpdDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IGlzQXN5bmM7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9ICFpc0dlbmVyYXRvcjtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKCcpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgaWQgPSAoIXRoaXMuY29udGV4dC5zdHJpY3QgJiYgIWlzR2VuZXJhdG9yICYmIHRoaXMubWF0Y2hLZXl3b3JkKCd5aWVsZCcpKSA/IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpIDogdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0KSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XHJcblx0ICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGZvcm1hbFBhcmFtZXRlcnMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycyhmaXJzdFJlc3RyaWN0ZWQpO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zO1xyXG5cdCAgICAgICAgdmFyIHN0cmljdGVkID0gZm9ybWFsUGFyYW1ldGVycy5zdHJpY3RlZDtcclxuXHQgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IGZvcm1hbFBhcmFtZXRlcnMuZmlyc3RSZXN0cmljdGVkO1xyXG5cdCAgICAgICAgaWYgKGZvcm1hbFBhcmFtZXRlcnMubWVzc2FnZSkge1xyXG5cdCAgICAgICAgICAgIG1lc3NhZ2UgPSBmb3JtYWxQYXJhbWV0ZXJzLm1lc3NhZ2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QgPSB0aGlzLmNvbnRleHQuc3RyaWN0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmUgPSB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBmb3JtYWxQYXJhbWV0ZXJzLnNpbXBsZTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihzdHJpY3RlZCwgbWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gcHJldmlvdXNBbGxvd0F3YWl0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICByZXR1cm4gaXNBc3luYyA/IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24oaWQsIHBhcmFtcywgYm9keSkpIDpcclxuXHQgICAgICAgICAgICB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRXhwcmVzc2lvbihpZCwgcGFyYW1zLCBib2R5LCBpc0dlbmVyYXRvcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1kaXJlY3RpdmUtcHJvbG9ndWVzLWFuZC10aGUtdXNlLXN0cmljdC1kaXJlY3RpdmVcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZURpcmVjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHZhciBkaXJlY3RpdmUgPSAoZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguTGl0ZXJhbCkgPyB0aGlzLmdldFRva2VuUmF3KHRva2VuKS5zbGljZSgxLCAtMSkgOiBudWxsO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBkaXJlY3RpdmUgPyBuZXcgTm9kZS5EaXJlY3RpdmUoZXhwciwgZGlyZWN0aXZlKSA6IG5ldyBOb2RlLkV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRGlyZWN0aXZlUHJvbG9ndWVzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGZpcnN0UmVzdHJpY3RlZCA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gOCAvKiBTdHJpbmdMaXRlcmFsICovKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB2YXIgc3RhdGVtZW50ID0gdGhpcy5wYXJzZURpcmVjdGl2ZSgpO1xyXG5cdCAgICAgICAgICAgIGJvZHkucHVzaChzdGF0ZW1lbnQpO1xyXG5cdCAgICAgICAgICAgIHZhciBkaXJlY3RpdmUgPSBzdGF0ZW1lbnQuZGlyZWN0aXZlO1xyXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgZGlyZWN0aXZlICE9PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZSA9PT0gJ3VzZSBzdHJpY3QnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxMYW5ndWFnZU1vZGVEaXJlY3RpdmUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIWZpcnN0UmVzdHJpY3RlZCAmJiB0b2tlbi5vY3RhbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gYm9keTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbWV0aG9kLWRlZmluaXRpb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucXVhbGlmaWVkUHJvcGVydHlOYW1lID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIDMgLyogSWRlbnRpZmllciAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDggLyogU3RyaW5nTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDEgLyogQm9vbGVhbkxpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA1IC8qIE51bGxMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNiAvKiBOdW1lcmljTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDQgLyogS2V5d29yZCAqLzpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgY2FzZSA3IC8qIFB1bmN0dWF0b3IgKi86XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbi52YWx1ZSA9PT0gJ1snO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlR2V0dGVyTWV0aG9kID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBmb3JtYWxQYXJhbWV0ZXJzID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoKTtcclxuXHQgICAgICAgIGlmIChmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtcy5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuQmFkR2V0dGVyQXJpdHkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZChmb3JtYWxQYXJhbWV0ZXJzKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRnVuY3Rpb25FeHByZXNzaW9uKG51bGwsIGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zLCBtZXRob2QsIGlzR2VuZXJhdG9yKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTZXR0ZXJNZXRob2QgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGZvcm1hbFBhcmFtZXRlcnMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycygpO1xyXG5cdCAgICAgICAgaWYgKGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zLmxlbmd0aCAhPT0gMSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkJhZFNldHRlckFyaXR5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zWzBdIGluc3RhbmNlb2YgTm9kZS5SZXN0RWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkJhZFNldHRlclJlc3RQYXJhbWV0ZXIpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZChmb3JtYWxQYXJhbWV0ZXJzKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRnVuY3Rpb25FeHByZXNzaW9uKG51bGwsIGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zLCBtZXRob2QsIGlzR2VuZXJhdG9yKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VHZW5lcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycygpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2QocGFyYW1zKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRnVuY3Rpb25FeHByZXNzaW9uKG51bGwsIHBhcmFtcy5wYXJhbXMsIG1ldGhvZCwgaXNHZW5lcmF0b3IpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2VuZXJhdG9yLWZ1bmN0aW9uLWRlZmluaXRpb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuaXNTdGFydE9mRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmxvb2thaGVhZC52YWx1ZTtcclxuXHQgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgNyAvKiBQdW5jdHVhdG9yICovOlxyXG5cdCAgICAgICAgICAgICAgICBzdGFydCA9ICh2YWx1ZSA9PT0gJ1snKSB8fCAodmFsdWUgPT09ICcoJykgfHwgKHZhbHVlID09PSAneycpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICcrJykgfHwgKHZhbHVlID09PSAnLScpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICchJykgfHwgKHZhbHVlID09PSAnficpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICcrKycpIHx8ICh2YWx1ZSA9PT0gJy0tJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJy8nKSB8fCAodmFsdWUgPT09ICcvPScpOyAvLyByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbFxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDQgLyogS2V5d29yZCAqLzpcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQgPSAodmFsdWUgPT09ICdjbGFzcycpIHx8ICh2YWx1ZSA9PT0gJ2RlbGV0ZScpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICdmdW5jdGlvbicpIHx8ICh2YWx1ZSA9PT0gJ2xldCcpIHx8ICh2YWx1ZSA9PT0gJ25ldycpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICdzdXBlcicpIHx8ICh2YWx1ZSA9PT0gJ3RoaXMnKSB8fCAodmFsdWUgPT09ICd0eXBlb2YnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAndm9pZCcpIHx8ICh2YWx1ZSA9PT0gJ3lpZWxkJyk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHN0YXJ0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlWWllbGRFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgneWllbGQnKTtcclxuXHQgICAgICAgIHZhciBhcmd1bWVudCA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgZGVsZWdhdGUgPSBmYWxzZTtcclxuXHQgICAgICAgIGlmICghdGhpcy5oYXNMaW5lVGVybWluYXRvcikge1xyXG5cdCAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIGRlbGVnYXRlID0gdGhpcy5tYXRjaCgnKicpO1xyXG5cdCAgICAgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBhcmd1bWVudCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzU3RhcnRPZkV4cHJlc3Npb24oKSkge1xyXG5cdCAgICAgICAgICAgICAgICBhcmd1bWVudCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLllpZWxkRXhwcmVzc2lvbihhcmd1bWVudCwgZGVsZWdhdGUpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY2xhc3MtZGVmaW5pdGlvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRWxlbWVudCA9IGZ1bmN0aW9uIChoYXNDb25zdHJ1Y3Rvcikge1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGtpbmQgPSAnJztcclxuXHQgICAgICAgIHZhciBrZXkgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBjb21wdXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGlzU3RhdGljID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgaXNBc3luYyA9IGZhbHNlO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJyonKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICB2YXIgaWQgPSBrZXk7XHJcblx0ICAgICAgICAgICAgaWYgKGlkLm5hbWUgPT09ICdzdGF0aWMnICYmICh0aGlzLnF1YWxpZmllZFByb3BlcnR5TmFtZSh0aGlzLmxvb2thaGVhZCkgfHwgdGhpcy5tYXRjaCgnKicpKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgICAgICBpc1N0YXRpYyA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKCh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pICYmICF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yICYmICh0b2tlbi52YWx1ZSA9PT0gJ2FzeW5jJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHB1bmN0dWF0b3IgPSB0aGlzLmxvb2thaGVhZC52YWx1ZTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHB1bmN0dWF0b3IgIT09ICc6JyAmJiBwdW5jdHVhdG9yICE9PSAnKCcgJiYgcHVuY3R1YXRvciAhPT0gJyonKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdnZXQnIHx8IHRva2VuLnZhbHVlID09PSAnc2V0Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICdjb25zdHJ1Y3RvcicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5Db25zdHJ1Y3RvcklzQXN5bmMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBsb29rYWhlYWRQcm9wZXJ0eUtleSA9IHRoaXMucXVhbGlmaWVkUHJvcGVydHlOYW1lKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdnZXQnICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XHJcblx0ICAgICAgICAgICAgICAgIGtpbmQgPSAnZ2V0JztcclxuXHQgICAgICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VHZXR0ZXJNZXRob2QoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICdzZXQnICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XHJcblx0ICAgICAgICAgICAgICAgIGtpbmQgPSAnc2V0JztcclxuXHQgICAgICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VTZXR0ZXJNZXRob2QoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgdG9rZW4udmFsdWUgPT09ICcqJyAmJiBsb29rYWhlYWRQcm9wZXJ0eUtleSkge1xyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnaW5pdCc7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlR2VuZXJhdG9yTWV0aG9kKCk7XHJcblx0ICAgICAgICAgICAgbWV0aG9kID0gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICgha2luZCAmJiBrZXkgJiYgdGhpcy5tYXRjaCgnKCcpKSB7XHJcblx0ICAgICAgICAgICAga2luZCA9ICdpbml0JztcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IGlzQXN5bmMgPyB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2RBc3luY0Z1bmN0aW9uKCkgOiB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2RGdW5jdGlvbigpO1xyXG5cdCAgICAgICAgICAgIG1ldGhvZCA9IHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIWtpbmQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChraW5kID09PSAnaW5pdCcpIHtcclxuXHQgICAgICAgICAgICBraW5kID0gJ21ldGhvZCc7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIWNvbXB1dGVkKSB7XHJcblx0ICAgICAgICAgICAgaWYgKGlzU3RhdGljICYmIHRoaXMuaXNQcm9wZXJ0eUtleShrZXksICdwcm90b3R5cGUnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0YXRpY1Byb3RvdHlwZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICghaXNTdGF0aWMgJiYgdGhpcy5pc1Byb3BlcnR5S2V5KGtleSwgJ2NvbnN0cnVjdG9yJykpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGtpbmQgIT09ICdtZXRob2QnIHx8ICFtZXRob2QgfHwgKHZhbHVlICYmIHZhbHVlLmdlbmVyYXRvcikpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuQ29uc3RydWN0b3JTcGVjaWFsTWV0aG9kKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoaGFzQ29uc3RydWN0b3IudmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuRHVwbGljYXRlQ29uc3RydWN0b3IpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaGFzQ29uc3RydWN0b3IudmFsdWUgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGtpbmQgPSAnY29uc3RydWN0b3InO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLk1ldGhvZERlZmluaXRpb24oa2V5LCBjb21wdXRlZCwgdmFsdWUsIGtpbmQsIGlzU3RhdGljKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0VsZW1lbnRMaXN0ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSBbXTtcclxuXHQgICAgICAgIHZhciBoYXNDb25zdHJ1Y3RvciA9IHsgdmFsdWU6IGZhbHNlIH07XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnOycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBib2R5LnB1c2godGhpcy5wYXJzZUNsYXNzRWxlbWVudChoYXNDb25zdHJ1Y3RvcikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICByZXR1cm4gYm9keTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzQm9keSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZWxlbWVudExpc3QgPSB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TGlzdCgpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQ2xhc3NCb2R5KGVsZW1lbnRMaXN0KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0RlY2xhcmF0aW9uID0gZnVuY3Rpb24gKGlkZW50aWZpZXJJc09wdGlvbmFsKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0ID0gdGhpcy5jb250ZXh0LnN0cmljdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdjbGFzcycpO1xyXG5cdCAgICAgICAgdmFyIGlkID0gKGlkZW50aWZpZXJJc09wdGlvbmFsICYmICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAzIC8qIElkZW50aWZpZXIgKi8pKSA/IG51bGwgOiB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICB2YXIgc3VwZXJDbGFzcyA9IG51bGw7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2V4dGVuZHMnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgc3VwZXJDbGFzcyA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgY2xhc3NCb2R5ID0gdGhpcy5wYXJzZUNsYXNzQm9keSgpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQ2xhc3NEZWNsYXJhdGlvbihpZCwgc3VwZXJDbGFzcywgY2xhc3NCb2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0V4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0ID0gdGhpcy5jb250ZXh0LnN0cmljdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdjbGFzcycpO1xyXG5cdCAgICAgICAgdmFyIGlkID0gKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykgPyB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCkgOiBudWxsO1xyXG5cdCAgICAgICAgdmFyIHN1cGVyQ2xhc3MgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdleHRlbmRzJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHN1cGVyQ2xhc3MgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGNsYXNzQm9keSA9IHRoaXMucGFyc2VDbGFzc0JvZHkoKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNsYXNzRXhwcmVzc2lvbihpZCwgc3VwZXJDbGFzcywgY2xhc3NCb2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXNjcmlwdHNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbW9kdWxlc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTW9kdWxlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNNb2R1bGUgPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZURpcmVjdGl2ZVByb2xvZ3VlcygpO1xyXG5cdCAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgYm9keS5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLk1vZHVsZShib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTY3JpcHQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRGlyZWN0aXZlUHJvbG9ndWVzKCk7XHJcblx0ICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICBib2R5LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuU2NyaXB0KGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaW1wb3J0c1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTW9kdWxlU3BlY2lmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSA4IC8qIFN0cmluZ0xpdGVyYWwgKi8pIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkTW9kdWxlU3BlY2lmaWVyKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB2YXIgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5MaXRlcmFsKHRva2VuLnZhbHVlLCByYXcpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaW1wb3J0IHs8Zm9vIGFzIGJhcj59IC4uLjtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUltcG9ydFNwZWNpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaW1wb3J0ZWQ7XHJcblx0ICAgICAgICB2YXIgbG9jYWw7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgaW1wb3J0ZWQgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgbG9jYWwgPSBpbXBvcnRlZDtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGxvY2FsID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGltcG9ydGVkID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICAgICAgbG9jYWwgPSBpbXBvcnRlZDtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGxvY2FsID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JbXBvcnRTcGVjaWZpZXIobG9jYWwsIGltcG9ydGVkKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIHtmb28sIGJhciBhcyBiYXN9XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VOYW1lZEltcG9ydHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgdmFyIHNwZWNpZmllcnMgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXIoKSk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHNwZWNpZmllcnM7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGltcG9ydCA8Zm9vPiAuLi47XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBsb2NhbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSW1wb3J0RGVmYXVsdFNwZWNpZmllcihsb2NhbCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBpbXBvcnQgPCogYXMgZm9vPiAuLi47XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJyonKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuTm9Bc0FmdGVySW1wb3J0TmFtZXNwYWNlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB2YXIgbG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkltcG9ydE5hbWVzcGFjZVNwZWNpZmllcihsb2NhbCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSW1wb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbEltcG9ydERlY2xhcmF0aW9uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2ltcG9ydCcpO1xyXG5cdCAgICAgICAgdmFyIHNyYztcclxuXHQgICAgICAgIHZhciBzcGVjaWZpZXJzID0gW107XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gOCAvKiBTdHJpbmdMaXRlcmFsICovKSB7XHJcblx0ICAgICAgICAgICAgLy8gaW1wb3J0ICdmb28nO1xyXG5cdCAgICAgICAgICAgIHNyYyA9IHRoaXMucGFyc2VNb2R1bGVTcGVjaWZpZXIoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCd7JykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gaW1wb3J0IHtiYXJ9XHJcblx0ICAgICAgICAgICAgICAgIHNwZWNpZmllcnMgPSBzcGVjaWZpZXJzLmNvbmNhdCh0aGlzLnBhcnNlTmFtZWRJbXBvcnRzKCkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcqJykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gaW1wb3J0ICogYXMgZm9vXHJcblx0ICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh0aGlzLnBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKCkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzSWRlbnRpZmllck5hbWUodGhpcy5sb29rYWhlYWQpICYmICF0aGlzLm1hdGNoS2V5d29yZCgnZGVmYXVsdCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGltcG9ydCBmb29cclxuXHQgICAgICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHRoaXMucGFyc2VJbXBvcnREZWZhdWx0U3BlY2lmaWVyKCkpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyonKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltcG9ydCBmb28sICogYXMgZm9vXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHRoaXMucGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCd7JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbXBvcnQgZm9vLCB7YmFyfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZmllcnMgPSBzcGVjaWZpZXJzLmNvbmNhdCh0aGlzLnBhcnNlTmFtZWRJbXBvcnRzKCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLmxvb2thaGVhZC52YWx1ZSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuIDogbWVzc2FnZXNfMS5NZXNzYWdlcy5NaXNzaW5nRnJvbUNsYXVzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIHRoaXMubG9va2FoZWFkLnZhbHVlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBzcmMgPSB0aGlzLnBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkltcG9ydERlY2xhcmF0aW9uKHNwZWNpZmllcnMsIHNyYykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1leHBvcnRzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VFeHBvcnRTcGVjaWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICB2YXIgZXhwb3J0ZWQgPSBsb2NhbDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGV4cG9ydGVkID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnRTcGVjaWZpZXIobG9jYWwsIGV4cG9ydGVkKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VFeHBvcnREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsRXhwb3J0RGVjbGFyYXRpb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZXhwb3J0Jyk7XHJcblx0ICAgICAgICB2YXIgZXhwb3J0RGVjbGFyYXRpb247XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xyXG5cdCAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IC4uLlxyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdmdW5jdGlvbicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvbyAoKSB7fVxyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7fVxyXG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbih0cnVlKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihkZWNsYXJhdGlvbikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnY2xhc3MnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBjbGFzcyBmb28ge31cclxuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUNsYXNzRGVjbGFyYXRpb24odHJ1ZSk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhc3luYycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGYgKCkge31cclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gKCkge31cclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgYXN5bmMgeCA9PiB4XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMubWF0Y2hBc3luY0Z1bmN0aW9uKCkgPyB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbih0cnVlKSA6IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgdGhpcy5sb29rYWhlYWQudmFsdWUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IHt9O1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBbXTtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgKDEgKyAyKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5tYXRjaCgneycpID8gdGhpcy5wYXJzZU9iamVjdEluaXRpYWxpemVyKCkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaCgnWycpID8gdGhpcy5wYXJzZUFycmF5SW5pdGlhbGl6ZXIoKSA6IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihkZWNsYXJhdGlvbikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJyonKSkge1xyXG5cdCAgICAgICAgICAgIC8vIGV4cG9ydCAqIGZyb20gJ2Zvbyc7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnZnJvbScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5sb29rYWhlYWQudmFsdWUgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiA6IG1lc3NhZ2VzXzEuTWVzc2FnZXMuTWlzc2luZ0Zyb21DbGF1c2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCB0aGlzLmxvb2thaGVhZC52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdmFyIHNyYyA9IHRoaXMucGFyc2VNb2R1bGVTcGVjaWZpZXIoKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0QWxsRGVjbGFyYXRpb24oc3JjKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pIHtcclxuXHQgICAgICAgICAgICAvLyBleHBvcnQgdmFyIGYgPSAxO1xyXG5cdCAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHZvaWQgMDtcclxuXHQgICAgICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2xldCc6XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2NvbnN0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUxleGljYWxEZWNsYXJhdGlvbih7IGluRm9yOiBmYWxzZSB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICd2YXInOlxyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdjbGFzcyc6XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0TmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwgW10sIG51bGwpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hBc3luY0Z1bmN0aW9uKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnROYW1lZERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLCBbXSwgbnVsbCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFyIHNwZWNpZmllcnMgPSBbXTtcclxuXHQgICAgICAgICAgICB2YXIgc291cmNlID0gbnVsbDtcclxuXHQgICAgICAgICAgICB2YXIgaXNFeHBvcnRGcm9tSWRlbnRpZmllciA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgaXNFeHBvcnRGcm9tSWRlbnRpZmllciA9IGlzRXhwb3J0RnJvbUlkZW50aWZpZXIgfHwgdGhpcy5tYXRjaEtleXdvcmQoJ2RlZmF1bHQnKTtcclxuXHQgICAgICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXIoKSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnZnJvbScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCB7ZGVmYXVsdH0gZnJvbSAnZm9vJztcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IHtmb299IGZyb20gJ2Zvbyc7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMucGFyc2VNb2R1bGVTcGVjaWZpZXIoKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGlzRXhwb3J0RnJvbUlkZW50aWZpZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IHtkZWZhdWx0fTsgLy8gbWlzc2luZyBmcm9tQ2xhdXNlXHJcblx0ICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5sb29rYWhlYWQudmFsdWUgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiA6IG1lc3NhZ2VzXzEuTWVzc2FnZXMuTWlzc2luZ0Zyb21DbGF1c2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCB0aGlzLmxvb2thaGVhZC52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQge2Zvb307XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0TmFtZWREZWNsYXJhdGlvbihudWxsLCBzcGVjaWZpZXJzLCBzb3VyY2UpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHBvcnREZWNsYXJhdGlvbjtcclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIFBhcnNlcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xyXG5cblxuLyoqKi8gfSxcbi8qIDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdC8vIEVuc3VyZSB0aGUgY29uZGl0aW9uIGlzIHRydWUsIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvci5cclxuXHQvLyBUaGlzIGlzIG9ubHkgdG8gaGF2ZSBhIGJldHRlciBjb250cmFjdCBzZW1hbnRpYywgaS5lLiBhbm90aGVyIHNhZmV0eSBuZXRcclxuXHQvLyB0byBjYXRjaCBhIGxvZ2ljIGVycm9yLiBUaGUgY29uZGl0aW9uIHNoYWxsIGJlIGZ1bGZpbGxlZCBpbiBub3JtYWwgY2FzZS5cclxuXHQvLyBEbyBOT1QgdXNlIHRoaXMgdG8gZW5mb3JjZSBhIGNlcnRhaW4gY29uZGl0aW9uIG9uIGFueSB1c2VyIGlucHV0LlxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHRmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XHJcblx0ICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG5cdCAgICBpZiAoIWNvbmRpdGlvbikge1xyXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBU1NFUlQ6ICcgKyBtZXNzYWdlKTtcclxuXHQgICAgfVxyXG5cdH1cclxuXHRleHBvcnRzLmFzc2VydCA9IGFzc2VydDtcclxuXG5cbi8qKiovIH0sXG4vKiAxMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0LyogdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIEVycm9ySGFuZGxlciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEVycm9ySGFuZGxlcigpIHtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JzID0gW107XHJcblx0ICAgICAgICB0aGlzLnRvbGVyYW50ID0gZmFsc2U7XHJcblx0ICAgIH1cclxuXHQgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5yZWNvcmRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG5cdCAgICAgICAgdGhpcy5lcnJvcnMucHVzaChlcnJvcik7XHJcblx0ICAgIH07XHJcblx0ICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUudG9sZXJhdGUgPSBmdW5jdGlvbiAoZXJyb3IpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5yZWNvcmRFcnJvcihlcnJvcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RFcnJvciA9IGZ1bmN0aW9uIChtc2csIGNvbHVtbikge1xyXG5cdCAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1zZyk7XHJcblx0ICAgICAgICB0cnkge1xyXG5cdCAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgY2F0Y2ggKGJhc2UpIHtcclxuXHQgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG5cdCAgICAgICAgICAgIGlmIChPYmplY3QuY3JlYXRlICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xyXG5cdCAgICAgICAgICAgICAgICBlcnJvciA9IE9iamVjdC5jcmVhdGUoYmFzZSk7XHJcblx0ICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvciwgJ2NvbHVtbicsIHsgdmFsdWU6IGNvbHVtbiB9KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgICAgICAgcmV0dXJuIGVycm9yO1xyXG5cdCAgICB9O1xyXG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUVycm9yID0gZnVuY3Rpb24gKGluZGV4LCBsaW5lLCBjb2wsIGRlc2NyaXB0aW9uKSB7XHJcblx0ICAgICAgICB2YXIgbXNnID0gJ0xpbmUgJyArIGxpbmUgKyAnOiAnICsgZGVzY3JpcHRpb247XHJcblx0ICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLmNvbnN0cnVjdEVycm9yKG1zZywgY29sKTtcclxuXHQgICAgICAgIGVycm9yLmluZGV4ID0gaW5kZXg7XHJcblx0ICAgICAgICBlcnJvci5saW5lTnVtYmVyID0gbGluZTtcclxuXHQgICAgICAgIGVycm9yLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XHJcblx0ICAgICAgICByZXR1cm4gZXJyb3I7XHJcblx0ICAgIH07XHJcblx0ICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUudGhyb3dFcnJvciA9IGZ1bmN0aW9uIChpbmRleCwgbGluZSwgY29sLCBkZXNjcmlwdGlvbikge1xyXG5cdCAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFcnJvcihpbmRleCwgbGluZSwgY29sLCBkZXNjcmlwdGlvbik7XHJcblx0ICAgIH07XHJcblx0ICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUudG9sZXJhdGVFcnJvciA9IGZ1bmN0aW9uIChpbmRleCwgbGluZSwgY29sLCBkZXNjcmlwdGlvbikge1xyXG5cdCAgICAgICAgdmFyIGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihpbmRleCwgbGluZSwgY29sLCBkZXNjcmlwdGlvbik7XHJcblx0ICAgICAgICBpZiAodGhpcy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMucmVjb3JkRXJyb3IoZXJyb3IpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBFcnJvckhhbmRsZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkVycm9ySGFuZGxlciA9IEVycm9ySGFuZGxlcjtcclxuXG5cbi8qKiovIH0sXG4vKiAxMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdC8vIEVycm9yIG1lc3NhZ2VzIHNob3VsZCBiZSBpZGVudGljYWwgdG8gVjguXHJcblx0ZXhwb3J0cy5NZXNzYWdlcyA9IHtcclxuXHQgICAgQmFkR2V0dGVyQXJpdHk6ICdHZXR0ZXIgbXVzdCBub3QgaGF2ZSBhbnkgZm9ybWFsIHBhcmFtZXRlcnMnLFxyXG5cdCAgICBCYWRTZXR0ZXJBcml0eTogJ1NldHRlciBtdXN0IGhhdmUgZXhhY3RseSBvbmUgZm9ybWFsIHBhcmFtZXRlcicsXHJcblx0ICAgIEJhZFNldHRlclJlc3RQYXJhbWV0ZXI6ICdTZXR0ZXIgZnVuY3Rpb24gYXJndW1lbnQgbXVzdCBub3QgYmUgYSByZXN0IHBhcmFtZXRlcicsXHJcblx0ICAgIENvbnN0cnVjdG9ySXNBc3luYzogJ0NsYXNzIGNvbnN0cnVjdG9yIG1heSBub3QgYmUgYW4gYXN5bmMgbWV0aG9kJyxcclxuXHQgICAgQ29uc3RydWN0b3JTcGVjaWFsTWV0aG9kOiAnQ2xhc3MgY29uc3RydWN0b3IgbWF5IG5vdCBiZSBhbiBhY2Nlc3NvcicsXHJcblx0ICAgIERlY2xhcmF0aW9uTWlzc2luZ0luaXRpYWxpemVyOiAnTWlzc2luZyBpbml0aWFsaXplciBpbiAlMCBkZWNsYXJhdGlvbicsXHJcblx0ICAgIERlZmF1bHRSZXN0UGFyYW1ldGVyOiAnVW5leHBlY3RlZCB0b2tlbiA9JyxcclxuXHQgICAgRHVwbGljYXRlQmluZGluZzogJ0R1cGxpY2F0ZSBiaW5kaW5nICUwJyxcclxuXHQgICAgRHVwbGljYXRlQ29uc3RydWN0b3I6ICdBIGNsYXNzIG1heSBvbmx5IGhhdmUgb25lIGNvbnN0cnVjdG9yJyxcclxuXHQgICAgRHVwbGljYXRlUHJvdG9Qcm9wZXJ0eTogJ0R1cGxpY2F0ZSBfX3Byb3RvX18gZmllbGRzIGFyZSBub3QgYWxsb3dlZCBpbiBvYmplY3QgbGl0ZXJhbHMnLFxyXG5cdCAgICBGb3JJbk9mTG9vcEluaXRpYWxpemVyOiAnJTAgbG9vcCB2YXJpYWJsZSBkZWNsYXJhdGlvbiBtYXkgbm90IGhhdmUgYW4gaW5pdGlhbGl6ZXInLFxyXG5cdCAgICBHZW5lcmF0b3JJbkxlZ2FjeUNvbnRleHQ6ICdHZW5lcmF0b3IgZGVjbGFyYXRpb25zIGFyZSBub3QgYWxsb3dlZCBpbiBsZWdhY3kgY29udGV4dHMnLFxyXG5cdCAgICBJbGxlZ2FsQnJlYWs6ICdJbGxlZ2FsIGJyZWFrIHN0YXRlbWVudCcsXHJcblx0ICAgIElsbGVnYWxDb250aW51ZTogJ0lsbGVnYWwgY29udGludWUgc3RhdGVtZW50JyxcclxuXHQgICAgSWxsZWdhbEV4cG9ydERlY2xhcmF0aW9uOiAnVW5leHBlY3RlZCB0b2tlbicsXHJcblx0ICAgIElsbGVnYWxJbXBvcnREZWNsYXJhdGlvbjogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxyXG5cdCAgICBJbGxlZ2FsTGFuZ3VhZ2VNb2RlRGlyZWN0aXZlOiAnSWxsZWdhbCBcXCd1c2Ugc3RyaWN0XFwnIGRpcmVjdGl2ZSBpbiBmdW5jdGlvbiB3aXRoIG5vbi1zaW1wbGUgcGFyYW1ldGVyIGxpc3QnLFxyXG5cdCAgICBJbGxlZ2FsUmV0dXJuOiAnSWxsZWdhbCByZXR1cm4gc3RhdGVtZW50JyxcclxuXHQgICAgSW52YWxpZEVzY2FwZWRSZXNlcnZlZFdvcmQ6ICdLZXl3b3JkIG11c3Qgbm90IGNvbnRhaW4gZXNjYXBlZCBjaGFyYWN0ZXJzJyxcclxuXHQgICAgSW52YWxpZEhleEVzY2FwZVNlcXVlbmNlOiAnSW52YWxpZCBoZXhhZGVjaW1hbCBlc2NhcGUgc2VxdWVuY2UnLFxyXG5cdCAgICBJbnZhbGlkTEhTSW5Bc3NpZ25tZW50OiAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBhc3NpZ25tZW50JyxcclxuXHQgICAgSW52YWxpZExIU0luRm9ySW46ICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci1pbicsXHJcblx0ICAgIEludmFsaWRMSFNJbkZvckxvb3A6ICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci1sb29wJyxcclxuXHQgICAgSW52YWxpZE1vZHVsZVNwZWNpZmllcjogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxyXG5cdCAgICBJbnZhbGlkUmVnRXhwOiAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24nLFxyXG5cdCAgICBMZXRJbkxleGljYWxCaW5kaW5nOiAnbGV0IGlzIGRpc2FsbG93ZWQgYXMgYSBsZXhpY2FsbHkgYm91bmQgbmFtZScsXHJcblx0ICAgIE1pc3NpbmdGcm9tQ2xhdXNlOiAnVW5leHBlY3RlZCB0b2tlbicsXHJcblx0ICAgIE11bHRpcGxlRGVmYXVsdHNJblN3aXRjaDogJ01vcmUgdGhhbiBvbmUgZGVmYXVsdCBjbGF1c2UgaW4gc3dpdGNoIHN0YXRlbWVudCcsXHJcblx0ICAgIE5ld2xpbmVBZnRlclRocm93OiAnSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93JyxcclxuXHQgICAgTm9Bc0FmdGVySW1wb3J0TmFtZXNwYWNlOiAnVW5leHBlY3RlZCB0b2tlbicsXHJcblx0ICAgIE5vQ2F0Y2hPckZpbmFsbHk6ICdNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgYWZ0ZXIgdHJ5JyxcclxuXHQgICAgUGFyYW1ldGVyQWZ0ZXJSZXN0UGFyYW1ldGVyOiAnUmVzdCBwYXJhbWV0ZXIgbXVzdCBiZSBsYXN0IGZvcm1hbCBwYXJhbWV0ZXInLFxyXG5cdCAgICBSZWRlY2xhcmF0aW9uOiAnJTAgXFwnJTFcXCcgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZCcsXHJcblx0ICAgIFN0YXRpY1Byb3RvdHlwZTogJ0NsYXNzZXMgbWF5IG5vdCBoYXZlIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGUnLFxyXG5cdCAgICBTdHJpY3RDYXRjaFZhcmlhYmxlOiAnQ2F0Y2ggdmFyaWFibGUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdERlbGV0ZTogJ0RlbGV0ZSBvZiBhbiB1bnF1YWxpZmllZCBpZGVudGlmaWVyIGluIHN0cmljdCBtb2RlLicsXHJcblx0ICAgIFN0cmljdEZ1bmN0aW9uOiAnSW4gc3RyaWN0IG1vZGUgY29kZSwgZnVuY3Rpb25zIGNhbiBvbmx5IGJlIGRlY2xhcmVkIGF0IHRvcCBsZXZlbCBvciBpbnNpZGUgYSBibG9jaycsXHJcblx0ICAgIFN0cmljdEZ1bmN0aW9uTmFtZTogJ0Z1bmN0aW9uIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdExIU0Fzc2lnbm1lbnQ6ICdBc3NpZ25tZW50IHRvIGV2YWwgb3IgYXJndW1lbnRzIGlzIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0TEhTUG9zdGZpeDogJ1Bvc3RmaXggaW5jcmVtZW50L2RlY3JlbWVudCBtYXkgbm90IGhhdmUgZXZhbCBvciBhcmd1bWVudHMgb3BlcmFuZCBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdExIU1ByZWZpeDogJ1ByZWZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0TW9kZVdpdGg6ICdTdHJpY3QgbW9kZSBjb2RlIG1heSBub3QgaW5jbHVkZSBhIHdpdGggc3RhdGVtZW50JyxcclxuXHQgICAgU3RyaWN0T2N0YWxMaXRlcmFsOiAnT2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlLicsXHJcblx0ICAgIFN0cmljdFBhcmFtRHVwZTogJ1N0cmljdCBtb2RlIGZ1bmN0aW9uIG1heSBub3QgaGF2ZSBkdXBsaWNhdGUgcGFyYW1ldGVyIG5hbWVzJyxcclxuXHQgICAgU3RyaWN0UGFyYW1OYW1lOiAnUGFyYW1ldGVyIG5hbWUgZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3RSZXNlcnZlZFdvcmQ6ICdVc2Ugb2YgZnV0dXJlIHJlc2VydmVkIHdvcmQgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3RWYXJOYW1lOiAnVmFyaWFibGUgbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgVGVtcGxhdGVPY3RhbExpdGVyYWw6ICdPY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gdGVtcGxhdGUgc3RyaW5ncy4nLFxyXG5cdCAgICBVbmV4cGVjdGVkRU9TOiAnVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnLFxyXG5cdCAgICBVbmV4cGVjdGVkSWRlbnRpZmllcjogJ1VuZXhwZWN0ZWQgaWRlbnRpZmllcicsXHJcblx0ICAgIFVuZXhwZWN0ZWROdW1iZXI6ICdVbmV4cGVjdGVkIG51bWJlcicsXHJcblx0ICAgIFVuZXhwZWN0ZWRSZXNlcnZlZDogJ1VuZXhwZWN0ZWQgcmVzZXJ2ZWQgd29yZCcsXHJcblx0ICAgIFVuZXhwZWN0ZWRTdHJpbmc6ICdVbmV4cGVjdGVkIHN0cmluZycsXHJcblx0ICAgIFVuZXhwZWN0ZWRUZW1wbGF0ZTogJ1VuZXhwZWN0ZWQgcXVhc2kgJTAnLFxyXG5cdCAgICBVbmV4cGVjdGVkVG9rZW46ICdVbmV4cGVjdGVkIHRva2VuICUwJyxcclxuXHQgICAgVW5leHBlY3RlZFRva2VuSWxsZWdhbDogJ1VuZXhwZWN0ZWQgdG9rZW4gSUxMRUdBTCcsXHJcblx0ICAgIFVua25vd25MYWJlbDogJ1VuZGVmaW5lZCBsYWJlbCBcXCclMFxcJycsXHJcblx0ICAgIFVudGVybWluYXRlZFJlZ0V4cDogJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiBtaXNzaW5nIC8nXHJcblx0fTtcclxuXG5cbi8qKiovIH0sXG4vKiAxMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBhc3NlcnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcblx0dmFyIGNoYXJhY3Rlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHR2YXIgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG5cdGZ1bmN0aW9uIGhleFZhbHVlKGNoKSB7XHJcblx0ICAgIHJldHVybiAnMDEyMzQ1Njc4OWFiY2RlZicuaW5kZXhPZihjaC50b0xvd2VyQ2FzZSgpKTtcclxuXHR9XHJcblx0ZnVuY3Rpb24gb2N0YWxWYWx1ZShjaCkge1xyXG5cdCAgICByZXR1cm4gJzAxMjM0NTY3Jy5pbmRleE9mKGNoKTtcclxuXHR9XHJcblx0dmFyIFNjYW5uZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTY2FubmVyKGNvZGUsIGhhbmRsZXIpIHtcclxuXHQgICAgICAgIHRoaXMuc291cmNlID0gY29kZTtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gaGFuZGxlcjtcclxuXHQgICAgICAgIHRoaXMudHJhY2tDb21tZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmxlbmd0aCA9IGNvZGUubGVuZ3RoO1xyXG5cdCAgICAgICAgdGhpcy5pbmRleCA9IDA7XHJcblx0ICAgICAgICB0aGlzLmxpbmVOdW1iZXIgPSAoY29kZS5sZW5ndGggPiAwKSA/IDEgOiAwO1xyXG5cdCAgICAgICAgdGhpcy5saW5lU3RhcnQgPSAwO1xyXG5cdCAgICAgICAgdGhpcy5jdXJseVN0YWNrID0gW107XHJcblx0ICAgIH1cclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2F2ZVN0YXRlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUucmVzdG9yZVN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcblx0ICAgICAgICB0aGlzLmluZGV4ID0gc3RhdGUuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLmxpbmVOdW1iZXIgPSBzdGF0ZS5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5saW5lU3RhcnQgPSBzdGF0ZS5saW5lU3RhcnQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmVvZiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmluZGV4ID49IHRoaXMubGVuZ3RoO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS50aHJvd1VuZXhwZWN0ZWRUb2tlbiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcblx0ICAgICAgICBpZiAobWVzc2FnZSA9PT0gdm9pZCAwKSB7IG1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbklsbGVnYWw7IH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmVycm9ySGFuZGxlci50aHJvd0Vycm9yKHRoaXMuaW5kZXgsIHRoaXMubGluZU51bWJlciwgdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0ICsgMSwgbWVzc2FnZSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuXHQgICAgICAgIGlmIChtZXNzYWdlID09PSB2b2lkIDApIHsgbWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuSWxsZWdhbDsgfVxyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIudG9sZXJhdGVFcnJvcih0aGlzLmluZGV4LCB0aGlzLmxpbmVOdW1iZXIsIHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydCArIDEsIG1lc3NhZ2UpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jb21tZW50c1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5za2lwU2luZ2xlTGluZUNvbW1lbnQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0ICAgICAgICB2YXIgY29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgIHZhciBzdGFydCwgbG9jO1xyXG5cdCAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgICAgICBzdGFydCA9IHRoaXMuaW5kZXggLSBvZmZzZXQ7XHJcblx0ICAgICAgICAgICAgbG9jID0ge1xyXG5cdCAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnQgLSBvZmZzZXRcclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB7fVxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbG9jLmVuZCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnQgLSAxXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpTGluZTogZmFsc2UsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2U6IFtzdGFydCArIG9mZnNldCwgdGhpcy5pbmRleCAtIDFdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIHRoaXMuaW5kZXggLSAxXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IGxvY1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMTMgJiYgdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSA9PT0gMTApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY29tbWVudHM7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgbG9jLmVuZCA9IHtcclxuXHQgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG5cdCAgICAgICAgICAgICAgICBtdWx0aUxpbmU6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgICAgICBzbGljZTogW3N0YXJ0ICsgb2Zmc2V0LCB0aGlzLmluZGV4XSxcclxuXHQgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgdGhpcy5pbmRleF0sXHJcblx0ICAgICAgICAgICAgICAgIGxvYzogbG9jXHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICBjb21tZW50cy5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBjb21tZW50cztcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2tpcE11bHRpTGluZUNvbW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgIHZhciBzdGFydCwgbG9jO1xyXG5cdCAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgICAgICBzdGFydCA9IHRoaXMuaW5kZXggLSAyO1xyXG5cdCAgICAgICAgICAgIGxvYyA9IHtcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0IC0gMlxyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHt9XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MEQgJiYgdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSkgPT09IDB4MEEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAweDJBKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIEJsb2NrIGNvbW1lbnQgZW5kcyB3aXRoICcqLycuXHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAxKSA9PT0gMHgyRikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9jLmVuZCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aUxpbmU6IHRydWUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlOiBbc3RhcnQgKyAyLCB0aGlzLmluZGV4IC0gMl0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIHRoaXMuaW5kZXhdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IGxvY1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tbWVudHM7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFJhbiBvZmYgdGhlIGVuZCBvZiB0aGUgZmlsZSAtIHRoZSB3aG9sZSB0aGluZyBpcyBhIGNvbW1lbnRcclxuXHQgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIGxvYy5lbmQgPSB7XHJcblx0ICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnRcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcclxuXHQgICAgICAgICAgICAgICAgbXVsdGlMaW5lOiB0cnVlLFxyXG5cdCAgICAgICAgICAgICAgICBzbGljZTogW3N0YXJ0ICsgMiwgdGhpcy5pbmRleF0sXHJcblx0ICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIHRoaXMuaW5kZXhdLFxyXG5cdCAgICAgICAgICAgICAgICBsb2M6IGxvY1xyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgY29tbWVudHMucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICByZXR1cm4gY29tbWVudHM7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5Db21tZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjb21tZW50cztcclxuXHQgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSAodGhpcy5pbmRleCA9PT0gMCk7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNXaGl0ZVNwYWNlKGNoKSkge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgwRCAmJiB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpID09PSAweDBBKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gMHgyRikge1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MkYpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gdGhpcy5za2lwU2luZ2xlTGluZUNvbW1lbnQoMik7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cyA9IGNvbW1lbnRzLmNvbmNhdChjb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gMHgyQSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLnNraXBNdWx0aUxpbmVDb21tZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cyA9IGNvbW1lbnRzLmNvbmNhdChjb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0ICYmIGNoID09PSAweDJEKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIFUrMDAzRSBpcyAnPidcclxuXHQgICAgICAgICAgICAgICAgaWYgKCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAxKSA9PT0gMHgyRCkgJiYgKHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDIpID09PSAweDNFKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gJy0tPicgaXMgYSBzaW5nbGUtbGluZSBjb21tZW50XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMuc2tpcFNpbmdsZUxpbmVDb21tZW50KDMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5jb25jYXQoY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gMHgzQykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2Uuc2xpY2UodGhpcy5pbmRleCArIDEsIHRoaXMuaW5kZXggKyA0KSA9PT0gJyEtLScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gNDsgLy8gYDwhLS1gXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMuc2tpcFNpbmdsZUxpbmVDb21tZW50KDQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5jb25jYXQoY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGNvbW1lbnRzO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mdXR1cmUtcmVzZXJ2ZWQtd29yZHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuaXNGdXR1cmVSZXNlcnZlZFdvcmQgPSBmdW5jdGlvbiAoaWQpIHtcclxuXHQgICAgICAgIHN3aXRjaCAoaWQpIHtcclxuXHQgICAgICAgICAgICBjYXNlICdlbnVtJzpcclxuXHQgICAgICAgICAgICBjYXNlICdleHBvcnQnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ2ltcG9ydCc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnc3VwZXInOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCA9IGZ1bmN0aW9uIChpZCkge1xyXG5cdCAgICAgICAgc3dpdGNoIChpZCkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ2ludGVyZmFjZSc6XHJcblx0ICAgICAgICAgICAgY2FzZSAncGFja2FnZSc6XHJcblx0ICAgICAgICAgICAgY2FzZSAncHJpdmF0ZSc6XHJcblx0ICAgICAgICAgICAgY2FzZSAncHJvdGVjdGVkJzpcclxuXHQgICAgICAgICAgICBjYXNlICdwdWJsaWMnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3N0YXRpYyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAneWllbGQnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ2xldCc6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuaXNSZXN0cmljdGVkV29yZCA9IGZ1bmN0aW9uIChpZCkge1xyXG5cdCAgICAgICAgcmV0dXJuIGlkID09PSAnZXZhbCcgfHwgaWQgPT09ICdhcmd1bWVudHMnO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1rZXl3b3Jkc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5pc0tleXdvcmQgPSBmdW5jdGlvbiAoaWQpIHtcclxuXHQgICAgICAgIHN3aXRjaCAoaWQubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAyOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAnaWYnKSB8fCAoaWQgPT09ICdpbicpIHx8IChpZCA9PT0gJ2RvJyk7XHJcblx0ICAgICAgICAgICAgY2FzZSAzOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAndmFyJykgfHwgKGlkID09PSAnZm9yJykgfHwgKGlkID09PSAnbmV3JykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgIChpZCA9PT0gJ3RyeScpIHx8IChpZCA9PT0gJ2xldCcpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNDpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3RoaXMnKSB8fCAoaWQgPT09ICdlbHNlJykgfHwgKGlkID09PSAnY2FzZScpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAoaWQgPT09ICd2b2lkJykgfHwgKGlkID09PSAnd2l0aCcpIHx8IChpZCA9PT0gJ2VudW0nKTtcclxuXHQgICAgICAgICAgICBjYXNlIDU6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd3aGlsZScpIHx8IChpZCA9PT0gJ2JyZWFrJykgfHwgKGlkID09PSAnY2F0Y2gnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKGlkID09PSAndGhyb3cnKSB8fCAoaWQgPT09ICdjb25zdCcpIHx8IChpZCA9PT0gJ3lpZWxkJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgIChpZCA9PT0gJ2NsYXNzJykgfHwgKGlkID09PSAnc3VwZXInKTtcclxuXHQgICAgICAgICAgICBjYXNlIDY6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdyZXR1cm4nKSB8fCAoaWQgPT09ICd0eXBlb2YnKSB8fCAoaWQgPT09ICdkZWxldGUnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKGlkID09PSAnc3dpdGNoJykgfHwgKGlkID09PSAnZXhwb3J0JykgfHwgKGlkID09PSAnaW1wb3J0Jyk7XHJcblx0ICAgICAgICAgICAgY2FzZSA3OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAnZGVmYXVsdCcpIHx8IChpZCA9PT0gJ2ZpbmFsbHknKSB8fCAoaWQgPT09ICdleHRlbmRzJyk7XHJcblx0ICAgICAgICAgICAgY2FzZSA4OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAnZnVuY3Rpb24nKSB8fCAoaWQgPT09ICdjb250aW51ZScpIHx8IChpZCA9PT0gJ2RlYnVnZ2VyJyk7XHJcblx0ICAgICAgICAgICAgY2FzZSAxMDpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2luc3RhbmNlb2YnKTtcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmNvZGVQb2ludEF0ID0gZnVuY3Rpb24gKGkpIHtcclxuXHQgICAgICAgIHZhciBjcCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQoaSk7XHJcblx0ICAgICAgICBpZiAoY3AgPj0gMHhEODAwICYmIGNwIDw9IDB4REJGRikge1xyXG5cdCAgICAgICAgICAgIHZhciBzZWNvbmQgPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KGkgKyAxKTtcclxuXHQgICAgICAgICAgICBpZiAoc2Vjb25kID49IDB4REMwMCAmJiBzZWNvbmQgPD0gMHhERkZGKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IGNwO1xyXG5cdCAgICAgICAgICAgICAgICBjcCA9IChmaXJzdCAtIDB4RDgwMCkgKiAweDQwMCArIHNlY29uZCAtIDB4REMwMCArIDB4MTAwMDA7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGNwO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuSGV4RXNjYXBlID0gZnVuY3Rpb24gKHByZWZpeCkge1xyXG5cdCAgICAgICAgdmFyIGxlbiA9IChwcmVmaXggPT09ICd1JykgPyA0IDogMjtcclxuXHQgICAgICAgIHZhciBjb2RlID0gMDtcclxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZW9mKCkgJiYgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSGV4RGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiAxNiArIGhleFZhbHVlKHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK10pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICB2YXIgY29kZSA9IDA7XHJcblx0ICAgICAgICAvLyBBdCBsZWFzdCwgb25lIGhleCBkaWdpdCBpcyByZXF1aXJlZC5cclxuXHQgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSGV4RGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGNvZGUgPSBjb2RlICogMTYgKyBoZXhWYWx1ZShjaCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY29kZSA+IDB4MTBGRkZGIHx8IGNoICE9PSAnfScpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmZyb21Db2RlUG9pbnQoY29kZSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmdldElkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4Kys7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gMHg1Qykge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBCbGFja3NsYXNoIChVKzAwNUMpIG1hcmtzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gc3RhcnQ7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbXBsZXhJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID49IDB4RDgwMCAmJiBjaCA8IDB4REZGRikge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGhhbmRsZSBzdXJyb2dhdGUgcGFpcnMuXHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBzdGFydDtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcGxleElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc2xpY2Uoc3RhcnQsIHRoaXMuaW5kZXgpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5nZXRDb21wbGV4SWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjcCA9IHRoaXMuY29kZVBvaW50QXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICB2YXIgaWQgPSBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuZnJvbUNvZGVQb2ludChjcCk7XHJcblx0ICAgICAgICB0aGlzLmluZGV4ICs9IGlkLmxlbmd0aDtcclxuXHQgICAgICAgIC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cclxuXHQgICAgICAgIHZhciBjaDtcclxuXHQgICAgICAgIGlmIChjcCA9PT0gMHg1Qykge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpICE9PSAweDc1KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc2NhbkhleEVzY2FwZSgndScpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IG51bGwgfHwgY2ggPT09ICdcXFxcJyB8fCAhY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWQgPSBjaDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGNwID0gdGhpcy5jb2RlUG9pbnRBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJQYXJ0KGNwKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgY2ggPSBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuZnJvbUNvZGVQb2ludChjcCk7XHJcblx0ICAgICAgICAgICAgaWQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgdGhpcy5pbmRleCArPSBjaC5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxyXG5cdCAgICAgICAgICAgIGlmIChjcCA9PT0gMHg1Qykge1xyXG5cdCAgICAgICAgICAgICAgICBpZCA9IGlkLnN1YnN0cigwLCBpZC5sZW5ndGggLSAxKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkgIT09IDB4NzUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zY2FuSGV4RXNjYXBlKCd1Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IG51bGwgfHwgY2ggPT09ICdcXFxcJyB8fCAhY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGlkO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5vY3RhbFRvRGVjaW1hbCA9IGZ1bmN0aW9uIChjaCkge1xyXG5cdCAgICAgICAgLy8gXFwwIGlzIG5vdCBvY3RhbCBlc2NhcGUgc2VxdWVuY2VcclxuXHQgICAgICAgIHZhciBvY3RhbCA9IChjaCAhPT0gJzAnKTtcclxuXHQgICAgICAgIHZhciBjb2RlID0gb2N0YWxWYWx1ZShjaCk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMuZW9mKCkgJiYgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyBvY3RhbFZhbHVlKHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK10pO1xyXG5cdCAgICAgICAgICAgIC8vIDMgZGlnaXRzIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiBzdHJpbmcgc3RhcnRzXHJcblx0ICAgICAgICAgICAgLy8gd2l0aCAwLCAxLCAyLCAzXHJcblx0ICAgICAgICAgICAgaWYgKCcwMTIzJy5pbmRleE9mKGNoKSA+PSAwICYmICF0aGlzLmVvZigpICYmIGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgb2N0YWxWYWx1ZSh0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGNvZGU6IGNvZGUsXHJcblx0ICAgICAgICAgICAgb2N0YWw6IG9jdGFsXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1uYW1lcy1hbmQta2V5d29yZHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbklkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgdHlwZTtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAvLyBCYWNrc2xhc2ggKFUrMDA1Qykgc3RhcnRzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxyXG5cdCAgICAgICAgdmFyIGlkID0gKHRoaXMuc291cmNlLmNoYXJDb2RlQXQoc3RhcnQpID09PSAweDVDKSA/IHRoaXMuZ2V0Q29tcGxleElkZW50aWZpZXIoKSA6IHRoaXMuZ2V0SWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgLy8gVGhlcmUgaXMgbm8ga2V5d29yZCBvciBsaXRlcmFsIHdpdGggb25seSBvbmUgY2hhcmFjdGVyLlxyXG5cdCAgICAgICAgLy8gVGh1cywgaXQgbXVzdCBiZSBhbiBpZGVudGlmaWVyLlxyXG5cdCAgICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gMSkge1xyXG5cdCAgICAgICAgICAgIHR5cGUgPSAzIC8qIElkZW50aWZpZXIgKi87XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLmlzS2V5d29yZChpZCkpIHtcclxuXHQgICAgICAgICAgICB0eXBlID0gNCAvKiBLZXl3b3JkICovO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoaWQgPT09ICdudWxsJykge1xyXG5cdCAgICAgICAgICAgIHR5cGUgPSA1IC8qIE51bGxMaXRlcmFsICovO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoaWQgPT09ICd0cnVlJyB8fCBpZCA9PT0gJ2ZhbHNlJykge1xyXG5cdCAgICAgICAgICAgIHR5cGUgPSAxIC8qIEJvb2xlYW5MaXRlcmFsICovO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdHlwZSA9IDMgLyogSWRlbnRpZmllciAqLztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0eXBlICE9PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgKHN0YXJ0ICsgaWQubGVuZ3RoICE9PSB0aGlzLmluZGV4KSkge1xyXG5cdCAgICAgICAgICAgIHZhciByZXN0b3JlID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICB0aGlzLmluZGV4ID0gc3RhcnQ7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRFc2NhcGVkUmVzZXJ2ZWRXb3JkKTtcclxuXHQgICAgICAgICAgICB0aGlzLmluZGV4ID0gcmVzdG9yZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuXHQgICAgICAgICAgICB2YWx1ZTogaWQsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHVuY3R1YXRvcnNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblB1bmN0dWF0b3IgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgLy8gQ2hlY2sgZm9yIG1vc3QgY29tbW9uIHNpbmdsZS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXHJcblx0ICAgICAgICB2YXIgc3RyID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICBzd2l0Y2ggKHN0cikge1xyXG5cdCAgICAgICAgICAgIGNhc2UgJygnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3snOlxyXG5cdCAgICAgICAgICAgICAgICBpZiAoc3RyID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VybHlTdGFjay5wdXNoKCd7Jyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlICcuJzpcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICcuJyAmJiB0aGlzLnNvdXJjZVt0aGlzLmluZGV4ICsgMV0gPT09ICcuJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU3ByZWFkIG9wZXJhdG9yOiAuLi5cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0ciA9ICcuLi4nO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgJ30nOlxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY3VybHlTdGFjay5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAnKSc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnOyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnLCc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnWyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnXSc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnOic6XHJcblx0ICAgICAgICAgICAgY2FzZSAnPyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnfic6XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgLy8gNC1jaGFyYWN0ZXIgcHVuY3R1YXRvci5cclxuXHQgICAgICAgICAgICAgICAgc3RyID0gdGhpcy5zb3VyY2Uuc3Vic3RyKHRoaXMuaW5kZXgsIDQpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoc3RyID09PSAnPj4+PScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gNDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIDMtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigwLCAzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdHIgPT09ICc9PT0nIHx8IHN0ciA9PT0gJyE9PScgfHwgc3RyID09PSAnPj4+JyB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJzw8PScgfHwgc3RyID09PSAnPj49JyB8fCBzdHIgPT09ICcqKj0nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gMi1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigwLCAyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyID09PSAnJiYnIHx8IHN0ciA9PT0gJ3x8JyB8fCBzdHIgPT09ICc9PScgfHwgc3RyID09PSAnIT0nIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJys9JyB8fCBzdHIgPT09ICctPScgfHwgc3RyID09PSAnKj0nIHx8IHN0ciA9PT0gJy89JyB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICcrKycgfHwgc3RyID09PSAnLS0nIHx8IHN0ciA9PT0gJzw8JyB8fCBzdHIgPT09ICc+PicgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnJj0nIHx8IHN0ciA9PT0gJ3w9JyB8fCBzdHIgPT09ICdePScgfHwgc3RyID09PSAnJT0nIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJzw9JyB8fCBzdHIgPT09ICc+PScgfHwgc3RyID09PSAnPT4nIHx8IHN0ciA9PT0gJyoqJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnPD49ISstKiUmfF4vJy5pbmRleE9mKHN0cikgPj0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gc3RhcnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDcgLyogUHVuY3R1YXRvciAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogc3RyLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxpdGVyYWxzLW51bWVyaWMtbGl0ZXJhbHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbkhleExpdGVyYWwgPSBmdW5jdGlvbiAoc3RhcnQpIHtcclxuXHQgICAgICAgIHZhciBudW0gPSAnJztcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSGV4RGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKG51bS5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA2IC8qIE51bWVyaWNMaXRlcmFsICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludCgnMHgnICsgbnVtLCAxNiksXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbkJpbmFyeUxpdGVyYWwgPSBmdW5jdGlvbiAoc3RhcnQpIHtcclxuXHQgICAgICAgIHZhciBudW0gPSAnJztcclxuXHQgICAgICAgIHZhciBjaDtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICAgICAgaWYgKGNoICE9PSAnMCcgJiYgY2ggIT09ICcxJykge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAobnVtLmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgIC8vIG9ubHkgMGIgb3IgMEJcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KGNoKSB8fCBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQoY2gpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDYgLyogTnVtZXJpY0xpdGVyYWwgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHBhcnNlSW50KG51bSwgMiksXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbk9jdGFsTGl0ZXJhbCA9IGZ1bmN0aW9uIChwcmVmaXgsIHN0YXJ0KSB7XHJcblx0ICAgICAgICB2YXIgbnVtID0gJyc7XHJcblx0ICAgICAgICB2YXIgb2N0YWwgPSBmYWxzZTtcclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KHByZWZpeC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICBudW0gPSAnMCcgKyB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghb2N0YWwgJiYgbnVtLmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgIC8vIG9ubHkgMG8gb3IgME9cclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpIHx8IGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogNiAvKiBOdW1lcmljTGl0ZXJhbCAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQobnVtLCA4KSxcclxuXHQgICAgICAgICAgICBvY3RhbDogb2N0YWwsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuaXNJbXBsaWNpdE9jdGFsTGl0ZXJhbCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIC8vIEltcGxpY2l0IG9jdGFsLCB1bmxlc3MgdGhlcmUgaXMgYSBub24tb2N0YWwgZGlnaXQuXHJcblx0ICAgICAgICAvLyAoQW5uZXggQi4xLjEgb24gTnVtZXJpYyBMaXRlcmFscylcclxuXHQgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmluZGV4ICsgMTsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVtpXTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09ICc4JyB8fCBjaCA9PT0gJzknKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuTnVtZXJpY0xpdGVyYWwgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2Vbc3RhcnRdO1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSB8fCAoY2ggPT09ICcuJyksICdOdW1lcmljIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgZGVjaW1hbCBkaWdpdCBvciBhIGRlY2ltYWwgcG9pbnQnKTtcclxuXHQgICAgICAgIHZhciBudW0gPSAnJztcclxuXHQgICAgICAgIGlmIChjaCAhPT0gJy4nKSB7XHJcblx0ICAgICAgICAgICAgbnVtID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgIC8vIEhleCBudW1iZXIgc3RhcnRzIHdpdGggJzB4Jy5cclxuXHQgICAgICAgICAgICAvLyBPY3RhbCBudW1iZXIgc3RhcnRzIHdpdGggJzAnLlxyXG5cdCAgICAgICAgICAgIC8vIE9jdGFsIG51bWJlciBpbiBFUzYgc3RhcnRzIHdpdGggJzBvJy5cclxuXHQgICAgICAgICAgICAvLyBCaW5hcnkgbnVtYmVyIGluIEVTNiBzdGFydHMgd2l0aCAnMGInLlxyXG5cdCAgICAgICAgICAgIGlmIChudW0gPT09ICcwJykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd4JyB8fCBjaCA9PT0gJ1gnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuSGV4TGl0ZXJhbChzdGFydCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnYicgfHwgY2ggPT09ICdCJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkJpbmFyeUxpdGVyYWwoc3RhcnQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ28nIHx8IGNoID09PSAnTycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5PY3RhbExpdGVyYWwoY2gsIHN0YXJ0KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggJiYgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbXBsaWNpdE9jdGFsTGl0ZXJhbCgpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk9jdGFsTGl0ZXJhbChjaCwgc3RhcnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHdoaWxlIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY2ggPT09ICcuJykge1xyXG5cdCAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIHdoaWxlIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XHJcblx0ICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09ICcrJyB8fCBjaCA9PT0gJy0nKSB7XHJcblx0ICAgICAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogNiAvKiBOdW1lcmljTGl0ZXJhbCAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW0pLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxpdGVyYWxzLXN0cmluZy1saXRlcmFsc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuU3RyaW5nTGl0ZXJhbCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgcXVvdGUgPSB0aGlzLnNvdXJjZVtzdGFydF07XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQoKHF1b3RlID09PSAnXFwnJyB8fCBxdW90ZSA9PT0gJ1wiJyksICdTdHJpbmcgbGl0ZXJhbCBtdXN0IHN0YXJ0cyB3aXRoIGEgcXVvdGUnKTtcclxuXHQgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgIHZhciBvY3RhbCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHN0ciA9ICcnO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09IHF1b3RlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHF1b3RlID0gJyc7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCFjaCB8fCAhY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSB0aGlzLnNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5lc2NhcGVkXzEgPSB0aGlzLnNjYW5IZXhFc2NhcGUoY2gpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZF8xID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHVuZXNjYXBlZF8xO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5lc2NhcGVkID0gdGhpcy5zY2FuSGV4RXNjYXBlKGNoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZCA9PT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRIZXhFc2NhcGVTZXF1ZW5jZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHVuZXNjYXBlZDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxuJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxyJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFx0JztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxiJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxmJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFx4MEInO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc4JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc5JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCAmJiBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2N0VG9EZWMgPSB0aGlzLm9jdGFsVG9EZWNpbWFsKGNoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gb2N0VG9EZWMub2N0YWwgfHwgb2N0YWw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShvY3RUb0RlYy5jb2RlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ1xcbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHF1b3RlICE9PSAnJykge1xyXG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXggPSBzdGFydDtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDggLyogU3RyaW5nTGl0ZXJhbCAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogc3RyLFxyXG5cdCAgICAgICAgICAgIG9jdGFsOiBvY3RhbCxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50c1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuVGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY29va2VkID0gJyc7XHJcblx0ICAgICAgICB2YXIgdGVybWluYXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgIHZhciBoZWFkID0gKHRoaXMuc291cmNlW3N0YXJ0XSA9PT0gJ2AnKTtcclxuXHQgICAgICAgIHZhciB0YWlsID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgcmF3T2Zmc2V0ID0gMjtcclxuXHQgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAnYCcpIHtcclxuXHQgICAgICAgICAgICAgICAgcmF3T2Zmc2V0ID0gMTtcclxuXHQgICAgICAgICAgICAgICAgdGFpbCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICckJykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJseVN0YWNrLnB1c2goJyR7Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGNvb2tlZCArPSBjaDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXG4nO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXHInO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXHQnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSB0aGlzLnNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdG9yZSA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5lc2NhcGVkXzIgPSB0aGlzLnNjYW5IZXhFc2NhcGUoY2gpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZF8yICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IHVuZXNjYXBlZF8yO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHJlc3RvcmU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5lc2NhcGVkID0gdGhpcy5zY2FuSGV4RXNjYXBlKGNoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZCA9PT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRIZXhFc2NhcGVTZXF1ZW5jZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IHVuZXNjYXBlZDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxiJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxmJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFx2JztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnMCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsOiBcXDAxIFxcMDIgYW5kIHNvIG9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLlRlbXBsYXRlT2N0YWxMaXRlcmFsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFwwJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsOiBcXDEgXFwyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVGVtcGxhdGVPY3RhbExpdGVyYWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAnXFxuJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ1xcbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxuJztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGNvb2tlZCArPSBjaDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIWhlYWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmN1cmx5U3RhY2sucG9wKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDEwIC8qIFRlbXBsYXRlICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNvdXJjZS5zbGljZShzdGFydCArIDEsIHRoaXMuaW5kZXggLSByYXdPZmZzZXQpLFxyXG5cdCAgICAgICAgICAgIGNvb2tlZDogY29va2VkLFxyXG5cdCAgICAgICAgICAgIGhlYWQ6IGhlYWQsXHJcblx0ICAgICAgICAgICAgdGFpbDogdGFpbCxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1saXRlcmFscy1yZWd1bGFyLWV4cHJlc3Npb24tbGl0ZXJhbHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUudGVzdFJlZ0V4cCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBmbGFncykge1xyXG5cdCAgICAgICAgLy8gVGhlIEJNUCBjaGFyYWN0ZXIgdG8gdXNlIGFzIGEgcmVwbGFjZW1lbnQgZm9yIGFzdHJhbCBzeW1ib2xzIHdoZW5cclxuXHQgICAgICAgIC8vIHRyYW5zbGF0aW5nIGFuIEVTNiBcInVcIi1mbGFnZ2VkIHBhdHRlcm4gdG8gYW4gRVM1LWNvbXBhdGlibGVcclxuXHQgICAgICAgIC8vIGFwcHJveGltYXRpb24uXHJcblx0ICAgICAgICAvLyBOb3RlOiByZXBsYWNpbmcgd2l0aCAnXFx1RkZGRicgZW5hYmxlcyBmYWxzZSBwb3NpdGl2ZXMgaW4gdW5saWtlbHlcclxuXHQgICAgICAgIC8vIHNjZW5hcmlvcy4gRm9yIGV4YW1wbGUsIGBbXFx1ezEwNDRmfS1cXHV7MTA0NDB9XWAgaXMgYW4gaW52YWxpZFxyXG5cdCAgICAgICAgLy8gcGF0dGVybiB0aGF0IHdvdWxkIG5vdCBiZSBkZXRlY3RlZCBieSB0aGlzIHN1YnN0aXR1dGlvbi5cclxuXHQgICAgICAgIHZhciBhc3RyYWxTdWJzdGl0dXRlID0gJ1xcdUZGRkYnO1xyXG5cdCAgICAgICAgdmFyIHRtcCA9IHBhdHRlcm47XHJcblx0ICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblx0ICAgICAgICBpZiAoZmxhZ3MuaW5kZXhPZigndScpID49IDApIHtcclxuXHQgICAgICAgICAgICB0bXAgPSB0bXBcclxuXHQgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFx1XFx7KFswLTlhLWZBLUZdKylcXH18XFxcXHUoW2EtZkEtRjAtOV17NH0pL2csIGZ1bmN0aW9uICgkMCwgJDEsICQyKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBwYXJzZUludCgkMSB8fCAkMiwgMTYpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY29kZVBvaW50ID4gMHgxMEZGRkYpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHNlbGYudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkUmVnRXhwKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4RkZGRikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYXN0cmFsU3Vic3RpdHV0ZTtcclxuXHQgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nLCBhc3RyYWxTdWJzdGl0dXRlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIEZpcnN0LCBkZXRlY3QgaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb25zLlxyXG5cdCAgICAgICAgdHJ5IHtcclxuXHQgICAgICAgICAgICBSZWdFeHAodG1wKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGNhdGNoIChlKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRSZWdFeHApO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gUmV0dXJuIGEgcmVndWxhciBleHByZXNzaW9uIG9iamVjdCBmb3IgdGhpcyBwYXR0ZXJuLWZsYWcgcGFpciwgb3JcclxuXHQgICAgICAgIC8vIGBudWxsYCBpbiBjYXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZmxhZ3MgaXRcclxuXHQgICAgICAgIC8vIHVzZXMuXHJcblx0ICAgICAgICB0cnkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGNhdGNoIChleGNlcHRpb24pIHtcclxuXHQgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuUmVnRXhwQm9keSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KGNoID09PSAnLycsICdSZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBzbGFzaCcpO1xyXG5cdCAgICAgICAgdmFyIHN0ciA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICB2YXIgY2xhc3NNYXJrZXIgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciB0ZXJtaW5hdGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGl0ZXJhbHMtcmVndWxhci1leHByZXNzaW9uLWxpdGVyYWxzXHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2xhc3NNYXJrZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNsYXNzTWFya2VyID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJy8nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnWycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNsYXNzTWFya2VyID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghdGVybWluYXRlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gRXhjbHVkZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cclxuXHQgICAgICAgIHJldHVybiBzdHIuc3Vic3RyKDEsIHN0ci5sZW5ndGggLSAyKTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblJlZ0V4cEZsYWdzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0ciA9ICcnO1xyXG5cdCAgICAgICAgdmFyIGZsYWdzID0gJyc7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcgJiYgIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXN0b3JlID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGFyID0gdGhpcy5zY2FuSGV4RXNjYXBlKCd1Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2hhciAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICs9IGNoYXI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChzdHIgKz0gJ1xcXFx1JzsgcmVzdG9yZSA8IHRoaXMuaW5kZXg7ICsrcmVzdG9yZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdGhpcy5zb3VyY2VbcmVzdG9yZV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHJlc3RvcmU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gJ3UnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXHUnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcJztcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgZmxhZ3MgKz0gY2g7XHJcblx0ICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZmxhZ3M7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5SZWdFeHAgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIHBhdHRlcm4gPSB0aGlzLnNjYW5SZWdFeHBCb2R5KCk7XHJcblx0ICAgICAgICB2YXIgZmxhZ3MgPSB0aGlzLnNjYW5SZWdFeHBGbGFncygpO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlID0gdGhpcy50ZXN0UmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogOSAvKiBSZWd1bGFyRXhwcmVzc2lvbiAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogJycsXHJcblx0ICAgICAgICAgICAgcGF0dGVybjogcGF0dGVybixcclxuXHQgICAgICAgICAgICBmbGFnczogZmxhZ3MsXHJcblx0ICAgICAgICAgICAgcmVnZXg6IHZhbHVlLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmxleCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogMiAvKiBFT0YgKi8sXHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiAnJyxcclxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5pbmRleCxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBjcCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KGNwKSkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5JZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBWZXJ5IGNvbW1vbjogKCBhbmQgKSBhbmQgO1xyXG5cdCAgICAgICAgaWYgKGNwID09PSAweDI4IHx8IGNwID09PSAweDI5IHx8IGNwID09PSAweDNCKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblB1bmN0dWF0b3IoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFN0cmluZyBsaXRlcmFsIHN0YXJ0cyB3aXRoIHNpbmdsZSBxdW90ZSAoVSswMDI3KSBvciBkb3VibGUgcXVvdGUgKFUrMDAyMikuXHJcblx0ICAgICAgICBpZiAoY3AgPT09IDB4MjcgfHwgY3AgPT09IDB4MjIpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuU3RyaW5nTGl0ZXJhbCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gRG90ICguKSBVKzAwMkUgY2FuIGFsc28gc3RhcnQgYSBmbG9hdGluZy1wb2ludCBudW1iZXIsIGhlbmNlIHRoZSBuZWVkXHJcblx0ICAgICAgICAvLyB0byBjaGVjayB0aGUgbmV4dCBjaGFyYWN0ZXIuXHJcblx0ICAgICAgICBpZiAoY3AgPT09IDB4MkUpIHtcclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuTnVtZXJpY0xpdGVyYWwoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblB1bmN0dWF0b3IoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQoY3ApKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk51bWVyaWNMaXRlcmFsKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBUZW1wbGF0ZSBsaXRlcmFscyBzdGFydCB3aXRoIGAgKFUrMDA2MCkgZm9yIHRlbXBsYXRlIGhlYWRcclxuXHQgICAgICAgIC8vIG9yIH0gKFUrMDA3RCkgZm9yIHRlbXBsYXRlIG1pZGRsZSBvciB0ZW1wbGF0ZSB0YWlsLlxyXG5cdCAgICAgICAgaWYgKGNwID09PSAweDYwIHx8IChjcCA9PT0gMHg3RCAmJiB0aGlzLmN1cmx5U3RhY2tbdGhpcy5jdXJseVN0YWNrLmxlbmd0aCAtIDFdID09PSAnJHsnKSkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5UZW1wbGF0ZSgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gUG9zc2libGUgaWRlbnRpZmllciBzdGFydCBpbiBhIHN1cnJvZ2F0ZSBwYWlyLlxyXG5cdCAgICAgICAgaWYgKGNwID49IDB4RDgwMCAmJiBjcCA8IDB4REZGRikge1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQodGhpcy5jb2RlUG9pbnRBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbklkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5zY2FuUHVuY3R1YXRvcigpO1xyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gU2Nhbm5lcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU2Nhbm5lciA9IFNjYW5uZXI7XHJcblxuXG4vKioqLyB9LFxuLyogMTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHRleHBvcnRzLlRva2VuTmFtZSA9IHt9O1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzEgLyogQm9vbGVhbkxpdGVyYWwgKi9dID0gJ0Jvb2xlYW4nO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzIgLyogRU9GICovXSA9ICc8ZW5kPic7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbMyAvKiBJZGVudGlmaWVyICovXSA9ICdJZGVudGlmaWVyJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVs0IC8qIEtleXdvcmQgKi9dID0gJ0tleXdvcmQnO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzUgLyogTnVsbExpdGVyYWwgKi9dID0gJ051bGwnO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzYgLyogTnVtZXJpY0xpdGVyYWwgKi9dID0gJ051bWVyaWMnO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzcgLyogUHVuY3R1YXRvciAqL10gPSAnUHVuY3R1YXRvcic7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbOCAvKiBTdHJpbmdMaXRlcmFsICovXSA9ICdTdHJpbmcnO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzkgLyogUmVndWxhckV4cHJlc3Npb24gKi9dID0gJ1JlZ3VsYXJFeHByZXNzaW9uJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVsxMCAvKiBUZW1wbGF0ZSAqL10gPSAnVGVtcGxhdGUnO1xyXG5cblxuLyoqKi8gfSxcbi8qIDE0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHQvLyBHZW5lcmF0ZWQgYnkgZ2VuZXJhdGUteGh0bWwtZW50aXRpZXMuanMuIERPIE5PVCBNT0RJRlkhXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdGV4cG9ydHMuWEhUTUxFbnRpdGllcyA9IHtcclxuXHQgICAgcXVvdDogJ1xcdTAwMjInLFxyXG5cdCAgICBhbXA6ICdcXHUwMDI2JyxcclxuXHQgICAgYXBvczogJ1xcdTAwMjcnLFxyXG5cdCAgICBndDogJ1xcdTAwM0UnLFxyXG5cdCAgICBuYnNwOiAnXFx1MDBBMCcsXHJcblx0ICAgIGlleGNsOiAnXFx1MDBBMScsXHJcblx0ICAgIGNlbnQ6ICdcXHUwMEEyJyxcclxuXHQgICAgcG91bmQ6ICdcXHUwMEEzJyxcclxuXHQgICAgY3VycmVuOiAnXFx1MDBBNCcsXHJcblx0ICAgIHllbjogJ1xcdTAwQTUnLFxyXG5cdCAgICBicnZiYXI6ICdcXHUwMEE2JyxcclxuXHQgICAgc2VjdDogJ1xcdTAwQTcnLFxyXG5cdCAgICB1bWw6ICdcXHUwMEE4JyxcclxuXHQgICAgY29weTogJ1xcdTAwQTknLFxyXG5cdCAgICBvcmRmOiAnXFx1MDBBQScsXHJcblx0ICAgIGxhcXVvOiAnXFx1MDBBQicsXHJcblx0ICAgIG5vdDogJ1xcdTAwQUMnLFxyXG5cdCAgICBzaHk6ICdcXHUwMEFEJyxcclxuXHQgICAgcmVnOiAnXFx1MDBBRScsXHJcblx0ICAgIG1hY3I6ICdcXHUwMEFGJyxcclxuXHQgICAgZGVnOiAnXFx1MDBCMCcsXHJcblx0ICAgIHBsdXNtbjogJ1xcdTAwQjEnLFxyXG5cdCAgICBzdXAyOiAnXFx1MDBCMicsXHJcblx0ICAgIHN1cDM6ICdcXHUwMEIzJyxcclxuXHQgICAgYWN1dGU6ICdcXHUwMEI0JyxcclxuXHQgICAgbWljcm86ICdcXHUwMEI1JyxcclxuXHQgICAgcGFyYTogJ1xcdTAwQjYnLFxyXG5cdCAgICBtaWRkb3Q6ICdcXHUwMEI3JyxcclxuXHQgICAgY2VkaWw6ICdcXHUwMEI4JyxcclxuXHQgICAgc3VwMTogJ1xcdTAwQjknLFxyXG5cdCAgICBvcmRtOiAnXFx1MDBCQScsXHJcblx0ICAgIHJhcXVvOiAnXFx1MDBCQicsXHJcblx0ICAgIGZyYWMxNDogJ1xcdTAwQkMnLFxyXG5cdCAgICBmcmFjMTI6ICdcXHUwMEJEJyxcclxuXHQgICAgZnJhYzM0OiAnXFx1MDBCRScsXHJcblx0ICAgIGlxdWVzdDogJ1xcdTAwQkYnLFxyXG5cdCAgICBBZ3JhdmU6ICdcXHUwMEMwJyxcclxuXHQgICAgQWFjdXRlOiAnXFx1MDBDMScsXHJcblx0ICAgIEFjaXJjOiAnXFx1MDBDMicsXHJcblx0ICAgIEF0aWxkZTogJ1xcdTAwQzMnLFxyXG5cdCAgICBBdW1sOiAnXFx1MDBDNCcsXHJcblx0ICAgIEFyaW5nOiAnXFx1MDBDNScsXHJcblx0ICAgIEFFbGlnOiAnXFx1MDBDNicsXHJcblx0ICAgIENjZWRpbDogJ1xcdTAwQzcnLFxyXG5cdCAgICBFZ3JhdmU6ICdcXHUwMEM4JyxcclxuXHQgICAgRWFjdXRlOiAnXFx1MDBDOScsXHJcblx0ICAgIEVjaXJjOiAnXFx1MDBDQScsXHJcblx0ICAgIEV1bWw6ICdcXHUwMENCJyxcclxuXHQgICAgSWdyYXZlOiAnXFx1MDBDQycsXHJcblx0ICAgIElhY3V0ZTogJ1xcdTAwQ0QnLFxyXG5cdCAgICBJY2lyYzogJ1xcdTAwQ0UnLFxyXG5cdCAgICBJdW1sOiAnXFx1MDBDRicsXHJcblx0ICAgIEVUSDogJ1xcdTAwRDAnLFxyXG5cdCAgICBOdGlsZGU6ICdcXHUwMEQxJyxcclxuXHQgICAgT2dyYXZlOiAnXFx1MDBEMicsXHJcblx0ICAgIE9hY3V0ZTogJ1xcdTAwRDMnLFxyXG5cdCAgICBPY2lyYzogJ1xcdTAwRDQnLFxyXG5cdCAgICBPdGlsZGU6ICdcXHUwMEQ1JyxcclxuXHQgICAgT3VtbDogJ1xcdTAwRDYnLFxyXG5cdCAgICB0aW1lczogJ1xcdTAwRDcnLFxyXG5cdCAgICBPc2xhc2g6ICdcXHUwMEQ4JyxcclxuXHQgICAgVWdyYXZlOiAnXFx1MDBEOScsXHJcblx0ICAgIFVhY3V0ZTogJ1xcdTAwREEnLFxyXG5cdCAgICBVY2lyYzogJ1xcdTAwREInLFxyXG5cdCAgICBVdW1sOiAnXFx1MDBEQycsXHJcblx0ICAgIFlhY3V0ZTogJ1xcdTAwREQnLFxyXG5cdCAgICBUSE9STjogJ1xcdTAwREUnLFxyXG5cdCAgICBzemxpZzogJ1xcdTAwREYnLFxyXG5cdCAgICBhZ3JhdmU6ICdcXHUwMEUwJyxcclxuXHQgICAgYWFjdXRlOiAnXFx1MDBFMScsXHJcblx0ICAgIGFjaXJjOiAnXFx1MDBFMicsXHJcblx0ICAgIGF0aWxkZTogJ1xcdTAwRTMnLFxyXG5cdCAgICBhdW1sOiAnXFx1MDBFNCcsXHJcblx0ICAgIGFyaW5nOiAnXFx1MDBFNScsXHJcblx0ICAgIGFlbGlnOiAnXFx1MDBFNicsXHJcblx0ICAgIGNjZWRpbDogJ1xcdTAwRTcnLFxyXG5cdCAgICBlZ3JhdmU6ICdcXHUwMEU4JyxcclxuXHQgICAgZWFjdXRlOiAnXFx1MDBFOScsXHJcblx0ICAgIGVjaXJjOiAnXFx1MDBFQScsXHJcblx0ICAgIGV1bWw6ICdcXHUwMEVCJyxcclxuXHQgICAgaWdyYXZlOiAnXFx1MDBFQycsXHJcblx0ICAgIGlhY3V0ZTogJ1xcdTAwRUQnLFxyXG5cdCAgICBpY2lyYzogJ1xcdTAwRUUnLFxyXG5cdCAgICBpdW1sOiAnXFx1MDBFRicsXHJcblx0ICAgIGV0aDogJ1xcdTAwRjAnLFxyXG5cdCAgICBudGlsZGU6ICdcXHUwMEYxJyxcclxuXHQgICAgb2dyYXZlOiAnXFx1MDBGMicsXHJcblx0ICAgIG9hY3V0ZTogJ1xcdTAwRjMnLFxyXG5cdCAgICBvY2lyYzogJ1xcdTAwRjQnLFxyXG5cdCAgICBvdGlsZGU6ICdcXHUwMEY1JyxcclxuXHQgICAgb3VtbDogJ1xcdTAwRjYnLFxyXG5cdCAgICBkaXZpZGU6ICdcXHUwMEY3JyxcclxuXHQgICAgb3NsYXNoOiAnXFx1MDBGOCcsXHJcblx0ICAgIHVncmF2ZTogJ1xcdTAwRjknLFxyXG5cdCAgICB1YWN1dGU6ICdcXHUwMEZBJyxcclxuXHQgICAgdWNpcmM6ICdcXHUwMEZCJyxcclxuXHQgICAgdXVtbDogJ1xcdTAwRkMnLFxyXG5cdCAgICB5YWN1dGU6ICdcXHUwMEZEJyxcclxuXHQgICAgdGhvcm46ICdcXHUwMEZFJyxcclxuXHQgICAgeXVtbDogJ1xcdTAwRkYnLFxyXG5cdCAgICBPRWxpZzogJ1xcdTAxNTInLFxyXG5cdCAgICBvZWxpZzogJ1xcdTAxNTMnLFxyXG5cdCAgICBTY2Fyb246ICdcXHUwMTYwJyxcclxuXHQgICAgc2Nhcm9uOiAnXFx1MDE2MScsXHJcblx0ICAgIFl1bWw6ICdcXHUwMTc4JyxcclxuXHQgICAgZm5vZjogJ1xcdTAxOTInLFxyXG5cdCAgICBjaXJjOiAnXFx1MDJDNicsXHJcblx0ICAgIHRpbGRlOiAnXFx1MDJEQycsXHJcblx0ICAgIEFscGhhOiAnXFx1MDM5MScsXHJcblx0ICAgIEJldGE6ICdcXHUwMzkyJyxcclxuXHQgICAgR2FtbWE6ICdcXHUwMzkzJyxcclxuXHQgICAgRGVsdGE6ICdcXHUwMzk0JyxcclxuXHQgICAgRXBzaWxvbjogJ1xcdTAzOTUnLFxyXG5cdCAgICBaZXRhOiAnXFx1MDM5NicsXHJcblx0ICAgIEV0YTogJ1xcdTAzOTcnLFxyXG5cdCAgICBUaGV0YTogJ1xcdTAzOTgnLFxyXG5cdCAgICBJb3RhOiAnXFx1MDM5OScsXHJcblx0ICAgIEthcHBhOiAnXFx1MDM5QScsXHJcblx0ICAgIExhbWJkYTogJ1xcdTAzOUInLFxyXG5cdCAgICBNdTogJ1xcdTAzOUMnLFxyXG5cdCAgICBOdTogJ1xcdTAzOUQnLFxyXG5cdCAgICBYaTogJ1xcdTAzOUUnLFxyXG5cdCAgICBPbWljcm9uOiAnXFx1MDM5RicsXHJcblx0ICAgIFBpOiAnXFx1MDNBMCcsXHJcblx0ICAgIFJobzogJ1xcdTAzQTEnLFxyXG5cdCAgICBTaWdtYTogJ1xcdTAzQTMnLFxyXG5cdCAgICBUYXU6ICdcXHUwM0E0JyxcclxuXHQgICAgVXBzaWxvbjogJ1xcdTAzQTUnLFxyXG5cdCAgICBQaGk6ICdcXHUwM0E2JyxcclxuXHQgICAgQ2hpOiAnXFx1MDNBNycsXHJcblx0ICAgIFBzaTogJ1xcdTAzQTgnLFxyXG5cdCAgICBPbWVnYTogJ1xcdTAzQTknLFxyXG5cdCAgICBhbHBoYTogJ1xcdTAzQjEnLFxyXG5cdCAgICBiZXRhOiAnXFx1MDNCMicsXHJcblx0ICAgIGdhbW1hOiAnXFx1MDNCMycsXHJcblx0ICAgIGRlbHRhOiAnXFx1MDNCNCcsXHJcblx0ICAgIGVwc2lsb246ICdcXHUwM0I1JyxcclxuXHQgICAgemV0YTogJ1xcdTAzQjYnLFxyXG5cdCAgICBldGE6ICdcXHUwM0I3JyxcclxuXHQgICAgdGhldGE6ICdcXHUwM0I4JyxcclxuXHQgICAgaW90YTogJ1xcdTAzQjknLFxyXG5cdCAgICBrYXBwYTogJ1xcdTAzQkEnLFxyXG5cdCAgICBsYW1iZGE6ICdcXHUwM0JCJyxcclxuXHQgICAgbXU6ICdcXHUwM0JDJyxcclxuXHQgICAgbnU6ICdcXHUwM0JEJyxcclxuXHQgICAgeGk6ICdcXHUwM0JFJyxcclxuXHQgICAgb21pY3JvbjogJ1xcdTAzQkYnLFxyXG5cdCAgICBwaTogJ1xcdTAzQzAnLFxyXG5cdCAgICByaG86ICdcXHUwM0MxJyxcclxuXHQgICAgc2lnbWFmOiAnXFx1MDNDMicsXHJcblx0ICAgIHNpZ21hOiAnXFx1MDNDMycsXHJcblx0ICAgIHRhdTogJ1xcdTAzQzQnLFxyXG5cdCAgICB1cHNpbG9uOiAnXFx1MDNDNScsXHJcblx0ICAgIHBoaTogJ1xcdTAzQzYnLFxyXG5cdCAgICBjaGk6ICdcXHUwM0M3JyxcclxuXHQgICAgcHNpOiAnXFx1MDNDOCcsXHJcblx0ICAgIG9tZWdhOiAnXFx1MDNDOScsXHJcblx0ICAgIHRoZXRhc3ltOiAnXFx1MDNEMScsXHJcblx0ICAgIHVwc2loOiAnXFx1MDNEMicsXHJcblx0ICAgIHBpdjogJ1xcdTAzRDYnLFxyXG5cdCAgICBlbnNwOiAnXFx1MjAwMicsXHJcblx0ICAgIGVtc3A6ICdcXHUyMDAzJyxcclxuXHQgICAgdGhpbnNwOiAnXFx1MjAwOScsXHJcblx0ICAgIHp3bmo6ICdcXHUyMDBDJyxcclxuXHQgICAgendqOiAnXFx1MjAwRCcsXHJcblx0ICAgIGxybTogJ1xcdTIwMEUnLFxyXG5cdCAgICBybG06ICdcXHUyMDBGJyxcclxuXHQgICAgbmRhc2g6ICdcXHUyMDEzJyxcclxuXHQgICAgbWRhc2g6ICdcXHUyMDE0JyxcclxuXHQgICAgbHNxdW86ICdcXHUyMDE4JyxcclxuXHQgICAgcnNxdW86ICdcXHUyMDE5JyxcclxuXHQgICAgc2JxdW86ICdcXHUyMDFBJyxcclxuXHQgICAgbGRxdW86ICdcXHUyMDFDJyxcclxuXHQgICAgcmRxdW86ICdcXHUyMDFEJyxcclxuXHQgICAgYmRxdW86ICdcXHUyMDFFJyxcclxuXHQgICAgZGFnZ2VyOiAnXFx1MjAyMCcsXHJcblx0ICAgIERhZ2dlcjogJ1xcdTIwMjEnLFxyXG5cdCAgICBidWxsOiAnXFx1MjAyMicsXHJcblx0ICAgIGhlbGxpcDogJ1xcdTIwMjYnLFxyXG5cdCAgICBwZXJtaWw6ICdcXHUyMDMwJyxcclxuXHQgICAgcHJpbWU6ICdcXHUyMDMyJyxcclxuXHQgICAgUHJpbWU6ICdcXHUyMDMzJyxcclxuXHQgICAgbHNhcXVvOiAnXFx1MjAzOScsXHJcblx0ICAgIHJzYXF1bzogJ1xcdTIwM0EnLFxyXG5cdCAgICBvbGluZTogJ1xcdTIwM0UnLFxyXG5cdCAgICBmcmFzbDogJ1xcdTIwNDQnLFxyXG5cdCAgICBldXJvOiAnXFx1MjBBQycsXHJcblx0ICAgIGltYWdlOiAnXFx1MjExMScsXHJcblx0ICAgIHdlaWVycDogJ1xcdTIxMTgnLFxyXG5cdCAgICByZWFsOiAnXFx1MjExQycsXHJcblx0ICAgIHRyYWRlOiAnXFx1MjEyMicsXHJcblx0ICAgIGFsZWZzeW06ICdcXHUyMTM1JyxcclxuXHQgICAgbGFycjogJ1xcdTIxOTAnLFxyXG5cdCAgICB1YXJyOiAnXFx1MjE5MScsXHJcblx0ICAgIHJhcnI6ICdcXHUyMTkyJyxcclxuXHQgICAgZGFycjogJ1xcdTIxOTMnLFxyXG5cdCAgICBoYXJyOiAnXFx1MjE5NCcsXHJcblx0ICAgIGNyYXJyOiAnXFx1MjFCNScsXHJcblx0ICAgIGxBcnI6ICdcXHUyMUQwJyxcclxuXHQgICAgdUFycjogJ1xcdTIxRDEnLFxyXG5cdCAgICByQXJyOiAnXFx1MjFEMicsXHJcblx0ICAgIGRBcnI6ICdcXHUyMUQzJyxcclxuXHQgICAgaEFycjogJ1xcdTIxRDQnLFxyXG5cdCAgICBmb3JhbGw6ICdcXHUyMjAwJyxcclxuXHQgICAgcGFydDogJ1xcdTIyMDInLFxyXG5cdCAgICBleGlzdDogJ1xcdTIyMDMnLFxyXG5cdCAgICBlbXB0eTogJ1xcdTIyMDUnLFxyXG5cdCAgICBuYWJsYTogJ1xcdTIyMDcnLFxyXG5cdCAgICBpc2luOiAnXFx1MjIwOCcsXHJcblx0ICAgIG5vdGluOiAnXFx1MjIwOScsXHJcblx0ICAgIG5pOiAnXFx1MjIwQicsXHJcblx0ICAgIHByb2Q6ICdcXHUyMjBGJyxcclxuXHQgICAgc3VtOiAnXFx1MjIxMScsXHJcblx0ICAgIG1pbnVzOiAnXFx1MjIxMicsXHJcblx0ICAgIGxvd2FzdDogJ1xcdTIyMTcnLFxyXG5cdCAgICByYWRpYzogJ1xcdTIyMUEnLFxyXG5cdCAgICBwcm9wOiAnXFx1MjIxRCcsXHJcblx0ICAgIGluZmluOiAnXFx1MjIxRScsXHJcblx0ICAgIGFuZzogJ1xcdTIyMjAnLFxyXG5cdCAgICBhbmQ6ICdcXHUyMjI3JyxcclxuXHQgICAgb3I6ICdcXHUyMjI4JyxcclxuXHQgICAgY2FwOiAnXFx1MjIyOScsXHJcblx0ICAgIGN1cDogJ1xcdTIyMkEnLFxyXG5cdCAgICBpbnQ6ICdcXHUyMjJCJyxcclxuXHQgICAgdGhlcmU0OiAnXFx1MjIzNCcsXHJcblx0ICAgIHNpbTogJ1xcdTIyM0MnLFxyXG5cdCAgICBjb25nOiAnXFx1MjI0NScsXHJcblx0ICAgIGFzeW1wOiAnXFx1MjI0OCcsXHJcblx0ICAgIG5lOiAnXFx1MjI2MCcsXHJcblx0ICAgIGVxdWl2OiAnXFx1MjI2MScsXHJcblx0ICAgIGxlOiAnXFx1MjI2NCcsXHJcblx0ICAgIGdlOiAnXFx1MjI2NScsXHJcblx0ICAgIHN1YjogJ1xcdTIyODInLFxyXG5cdCAgICBzdXA6ICdcXHUyMjgzJyxcclxuXHQgICAgbnN1YjogJ1xcdTIyODQnLFxyXG5cdCAgICBzdWJlOiAnXFx1MjI4NicsXHJcblx0ICAgIHN1cGU6ICdcXHUyMjg3JyxcclxuXHQgICAgb3BsdXM6ICdcXHUyMjk1JyxcclxuXHQgICAgb3RpbWVzOiAnXFx1MjI5NycsXHJcblx0ICAgIHBlcnA6ICdcXHUyMkE1JyxcclxuXHQgICAgc2RvdDogJ1xcdTIyQzUnLFxyXG5cdCAgICBsY2VpbDogJ1xcdTIzMDgnLFxyXG5cdCAgICByY2VpbDogJ1xcdTIzMDknLFxyXG5cdCAgICBsZmxvb3I6ICdcXHUyMzBBJyxcclxuXHQgICAgcmZsb29yOiAnXFx1MjMwQicsXHJcblx0ICAgIGxvejogJ1xcdTI1Q0EnLFxyXG5cdCAgICBzcGFkZXM6ICdcXHUyNjYwJyxcclxuXHQgICAgY2x1YnM6ICdcXHUyNjYzJyxcclxuXHQgICAgaGVhcnRzOiAnXFx1MjY2NScsXHJcblx0ICAgIGRpYW1zOiAnXFx1MjY2NicsXHJcblx0ICAgIGxhbmc6ICdcXHUyN0U4JyxcclxuXHQgICAgcmFuZzogJ1xcdTI3RTknXHJcblx0fTtcclxuXG5cbi8qKiovIH0sXG4vKiAxNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBlcnJvcl9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxuXHR2YXIgc2Nhbm5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcblx0dmFyIHRva2VuXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxuXHR2YXIgUmVhZGVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gUmVhZGVyKCkge1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZXMgPSBbXTtcclxuXHQgICAgICAgIHRoaXMuY3VybHkgPSB0aGlzLnBhcmVuID0gLTE7XHJcblx0ICAgIH1cclxuXHQgICAgLy8gQSBmdW5jdGlvbiBmb2xsb3dpbmcgb25lIG9mIHRob3NlIHRva2VucyBpcyBhbiBleHByZXNzaW9uLlxyXG5cdCAgICBSZWFkZXIucHJvdG90eXBlLmJlZm9yZUZ1bmN0aW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh0KSB7XHJcblx0ICAgICAgICByZXR1cm4gWycoJywgJ3snLCAnWycsICdpbicsICd0eXBlb2YnLCAnaW5zdGFuY2VvZicsICduZXcnLFxyXG5cdCAgICAgICAgICAgICdyZXR1cm4nLCAnY2FzZScsICdkZWxldGUnLCAndGhyb3cnLCAndm9pZCcsXHJcblx0ICAgICAgICAgICAgLy8gYXNzaWdubWVudCBvcGVyYXRvcnNcclxuXHQgICAgICAgICAgICAnPScsICcrPScsICctPScsICcqPScsICcqKj0nLCAnLz0nLCAnJT0nLCAnPDw9JywgJz4+PScsICc+Pj49JyxcclxuXHQgICAgICAgICAgICAnJj0nLCAnfD0nLCAnXj0nLCAnLCcsXHJcblx0ICAgICAgICAgICAgLy8gYmluYXJ5L3VuYXJ5IG9wZXJhdG9yc1xyXG5cdCAgICAgICAgICAgICcrJywgJy0nLCAnKicsICcqKicsICcvJywgJyUnLCAnKysnLCAnLS0nLCAnPDwnLCAnPj4nLCAnPj4+JywgJyYnLFxyXG5cdCAgICAgICAgICAgICd8JywgJ14nLCAnIScsICd+JywgJyYmJywgJ3x8JywgJz8nLCAnOicsICc9PT0nLCAnPT0nLCAnPj0nLFxyXG5cdCAgICAgICAgICAgICc8PScsICc8JywgJz4nLCAnIT0nLCAnIT09J10uaW5kZXhPZih0KSA+PSAwO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBEZXRlcm1pbmUgaWYgZm9yd2FyZCBzbGFzaCAoLykgaXMgYW4gb3BlcmF0b3Igb3IgcGFydCBvZiBhIHJlZ3VsYXIgZXhwcmVzc2lvblxyXG5cdCAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zd2VldC5qcy93aWtpL2Rlc2lnblxyXG5cdCAgICBSZWFkZXIucHJvdG90eXBlLmlzUmVnZXhTdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMudmFsdWVzW3RoaXMudmFsdWVzLmxlbmd0aCAtIDFdO1xyXG5cdCAgICAgICAgdmFyIHJlZ2V4ID0gKHByZXZpb3VzICE9PSBudWxsKTtcclxuXHQgICAgICAgIHN3aXRjaCAocHJldmlvdXMpIHtcclxuXHQgICAgICAgICAgICBjYXNlICd0aGlzJzpcclxuXHQgICAgICAgICAgICBjYXNlICddJzpcclxuXHQgICAgICAgICAgICAgICAgcmVnZXggPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAnKSc6XHJcblx0ICAgICAgICAgICAgICAgIHZhciBrZXl3b3JkID0gdGhpcy52YWx1ZXNbdGhpcy5wYXJlbiAtIDFdO1xyXG5cdCAgICAgICAgICAgICAgICByZWdleCA9IChrZXl3b3JkID09PSAnaWYnIHx8IGtleXdvcmQgPT09ICd3aGlsZScgfHwga2V5d29yZCA9PT0gJ2ZvcicgfHwga2V5d29yZCA9PT0gJ3dpdGgnKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAnfSc6XHJcblx0ICAgICAgICAgICAgICAgIC8vIERpdmlkaW5nIGEgZnVuY3Rpb24gYnkgYW55dGhpbmcgbWFrZXMgbGl0dGxlIHNlbnNlLFxyXG5cdCAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSB0byBjaGVjayBmb3IgdGhhdC5cclxuXHQgICAgICAgICAgICAgICAgcmVnZXggPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVzW3RoaXMuY3VybHkgLSAzXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQW5vbnltb3VzIGZ1bmN0aW9uLCBlLmcuIGZ1bmN0aW9uKCl7fSAvNDJcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGVjayA9IHRoaXMudmFsdWVzW3RoaXMuY3VybHkgLSA0XTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJlZ2V4ID0gY2hlY2sgPyAhdGhpcy5iZWZvcmVGdW5jdGlvbkV4cHJlc3Npb24oY2hlY2spIDogZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy52YWx1ZXNbdGhpcy5jdXJseSAtIDRdID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBOYW1lZCBmdW5jdGlvbiwgZS5nLiBmdW5jdGlvbiBmKCl7fSAvNDIvXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2sgPSB0aGlzLnZhbHVlc1t0aGlzLmN1cmx5IC0gNV07XHJcblx0ICAgICAgICAgICAgICAgICAgICByZWdleCA9IGNoZWNrID8gIXRoaXMuYmVmb3JlRnVuY3Rpb25FeHByZXNzaW9uKGNoZWNrKSA6IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gcmVnZXg7XHJcblx0ICAgIH07XHJcblx0ICAgIFJlYWRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyB8fCB0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pIHtcclxuXHQgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmN1cmx5ID0gdGhpcy52YWx1ZXMubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0b2tlbi52YWx1ZSA9PT0gJygnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMucGFyZW4gPSB0aGlzLnZhbHVlcy5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMudmFsdWVzLnB1c2godG9rZW4udmFsdWUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy52YWx1ZXMucHVzaChudWxsKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIFJlYWRlcjtcclxuXHR9KCkpO1xyXG5cdHZhciBUb2tlbml6ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUb2tlbml6ZXIoY29kZSwgY29uZmlnKSB7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlciA9IG5ldyBlcnJvcl9oYW5kbGVyXzEuRXJyb3JIYW5kbGVyKCk7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlci50b2xlcmFudCA9IGNvbmZpZyA/ICh0eXBlb2YgY29uZmlnLnRvbGVyYW50ID09PSAnYm9vbGVhbicgJiYgY29uZmlnLnRvbGVyYW50KSA6IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyID0gbmV3IHNjYW5uZXJfMS5TY2FubmVyKGNvZGUsIHRoaXMuZXJyb3JIYW5kbGVyKTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci50cmFja0NvbW1lbnQgPSBjb25maWcgPyAodHlwZW9mIGNvbmZpZy5jb21tZW50ID09PSAnYm9vbGVhbicgJiYgY29uZmlnLmNvbW1lbnQpIDogZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLnRyYWNrUmFuZ2UgPSBjb25maWcgPyAodHlwZW9mIGNvbmZpZy5yYW5nZSA9PT0gJ2Jvb2xlYW4nICYmIGNvbmZpZy5yYW5nZSkgOiBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMudHJhY2tMb2MgPSBjb25maWcgPyAodHlwZW9mIGNvbmZpZy5sb2MgPT09ICdib29sZWFuJyAmJiBjb25maWcubG9jKSA6IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcclxuXHQgICAgICAgIHRoaXMucmVhZGVyID0gbmV3IFJlYWRlcigpO1xyXG5cdCAgICB9XHJcblx0ICAgIFRva2VuaXplci5wcm90b3R5cGUuZXJyb3JzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JIYW5kbGVyLmVycm9ycztcclxuXHQgICAgfTtcclxuXHQgICAgVG9rZW5pemVyLnByb3RvdHlwZS5nZXROZXh0VG9rZW4gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNvbW1lbnRzID0gdGhpcy5zY2FubmVyLnNjYW5Db21tZW50cygpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWVudHMubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlID0gY29tbWVudHNbaV07XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnNjYW5uZXIuc291cmNlLnNsaWNlKGUuc2xpY2VbMF0sIGUuc2xpY2VbMV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZS5tdWx0aUxpbmUgPyAnQmxvY2tDb21tZW50JyA6ICdMaW5lQ29tbWVudCcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tSYW5nZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQucmFuZ2UgPSBlLnJhbmdlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tMb2MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50LmxvYyA9IGUubG9jO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChjb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuc2Nhbm5lci5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbG9jID0gdm9pZCAwO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0xvYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbG9jID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVuZDoge31cclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdmFyIHN0YXJ0UmVnZXggPSAodGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXhdID09PSAnLycpICYmIHRoaXMucmVhZGVyLmlzUmVnZXhTdGFydCgpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBzdGFydFJlZ2V4ID8gdGhpcy5zY2FubmVyLnNjYW5SZWdFeHAoKSA6IHRoaXMuc2Nhbm5lci5sZXgoKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5yZWFkZXIucHVzaCh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHR5cGU6IHRva2VuXzEuVG9rZW5OYW1lW3Rva2VuLnR5cGVdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc2Nhbm5lci5zb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQsIHRva2VuLmVuZClcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tSYW5nZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZW50cnkucmFuZ2UgPSBbdG9rZW4uc3RhcnQsIHRva2VuLmVuZF07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tMb2MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZW50cnkubG9jID0gbG9jO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA5IC8qIFJlZ3VsYXJFeHByZXNzaW9uICovKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IHRva2VuLnBhdHRlcm47XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZmxhZ3MgPSB0b2tlbi5mbGFncztcclxuXHQgICAgICAgICAgICAgICAgICAgIGVudHJ5LnJlZ2V4ID0geyBwYXR0ZXJuOiBwYXR0ZXJuLCBmbGFnczogZmxhZ3MgfTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc2hpZnQoKTtcclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIFRva2VuaXplcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVG9rZW5pemVyID0gVG9rZW5pemVyO1xyXG5cblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuOyIsIid1c2Ugc3RyaWN0J1xudmFyIHJlYWRvbmx5UHJveGllcyA9IG5ldyBXZWFrTWFwXG52YXIgY3VycmVudFNhbmRib3ggPSB1bmRlZmluZWRcbnZhciBHTE9CQUwgPSBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKVxudmFyIHVuc2NvcGFibGVzU3ltYm9sID0gU3ltYm9sLnVuc2NvcGFibGVzXG52YXIgRnVuY3Rpb25Db25zdHJ1Y3RvciA9IDAuLmNvbnN0cnVjdG9yLmNvbnN0cnVjdG9yXG5cbmZ1bmN0aW9uIGNvbXBpbGVFeHByZXNzaW9uKHNyYykge1xuXHRpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhIHN0cmluZy4nKVxuXHR9XG5cdFxuXHRuZXcgRnVuY3Rpb25Db25zdHJ1Y3RvcignXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAnICsgc3JjKSAvLyBUZXN0cyBmb3Igc3ludGF4IGVycm9ycyB3aXRob3V0IHJ1bm5pbmcgdGhlIGNvZGVcblx0dmFyIGNvZGUgPSBuZXcgRnVuY3Rpb25Db25zdHJ1Y3Rvcignc2FuZGJveCcsICd3aXRoIChzYW5kYm94KSB7cmV0dXJuIChmdW5jdGlvbiAoKSB7XCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAnICsgc3JjICsgJ30pLmNhbGwodGhpcyl9Jylcblx0XG5cdHJldHVybiBmdW5jdGlvbiAoc2FuZGJveCkge1xuXHRcdGlmICghaXNPYmplY3Qoc2FuZGJveCkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCBvciBmdW5jdGlvbi4nKVxuXHRcdH1cblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCBydW4gc2FuZGJveGVkIGNvZGUgaW5zaWRlIGFuIGFscmVhZHktcnVubmluZyBzYW5kYm94LicpXG5cdFx0fVxuXHRcdHZhciBzYW5kYm94UHJveHkgPSBnZXRQcm94eShzYW5kYm94KVxuXHRcdHZhciByZXN1bHQsIGVycm9yXG5cdFx0XG5cdFx0Y3VycmVudFNhbmRib3ggPSBzYW5kYm94XG5cdFx0dHJ5IHtcblx0XHRcdHJlc3VsdCA9IGNvZGUuY2FsbChzYW5kYm94UHJveHksIHNhbmRib3hQcm94eSlcblx0XHRcdGN1cnJlbnRTYW5kYm94ID0gdW5kZWZpbmVkXG5cdFx0fSBjYXRjaCAoZXgpIHtcblx0XHRcdGN1cnJlbnRTYW5kYm94ID0gdW5kZWZpbmVkXG5cdFx0XHRpZiAoZXggaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0XHRlcnJvciA9IG5ldyBleC5jb25zdHJ1Y3RvcignJyArIGV4Lm1lc3NhZ2UpXG5cdFx0XHRcdGVycm9yLnN0YWNrID0gJycgKyBleC5zdGFja1xuXHRcdFx0XHR0aHJvdyBlcnJvclxuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFN0cmluZyhleCkpXG5cdFx0fVxuXHRcdGlmIChpc09iamVjdChyZXN1bHQpKSB7XG5cdFx0XHR0aHJvdyBUeXBlRXJyb3IoJ1NhbmRib3hlcyBhcmUgb25seSBhbGxvd2VkIHRvIHJldHVybiBwcmltaXRpdmUgdmFsdWVzLicpXG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHRcblx0fVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlRXhwcmVzc2lvblxuXG52YXIgdHJhcHMgPSB7XG5cdGdldDogZnVuY3Rpb24gKHRhcmdldCwga2V5LCByZWNlaXZlcikge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0aWYgKGtleSA9PT0gdW5zY29wYWJsZXNTeW1ib2wgJiYgdGFyZ2V0ID09PSBjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0XHRpZiAoIW5vdFByaXZhdGUoa2V5KSkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZ2V0UHJveHlPclByaW1pdGl2ZShSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpKVxuXHRcdH1cblx0XHRyZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKVxuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgY2Fubm90IHNldCBwcm9wZXJ0aWVzIG9uIGEgc2FuZGJveGVkIG9iamVjdC4nKVxuXHRcdH1cblx0XHRyZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcilcblx0fSxcblx0aGFzOiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdGlmICh0YXJnZXQgPT09IGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0XHRpZiAoIW5vdFByaXZhdGUoa2V5KSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHRcdH1cblx0XHRcdHJldHVybiBnZXRQcm94eU9yUHJpbWl0aXZlKFJlZmxlY3QuaGFzKHRhcmdldCwga2V5KSlcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwga2V5KVxuXHR9LFxuXHRnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0cmV0dXJuIGdldFByb3h5T3JQcmltaXRpdmUoUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpKVxuXHRcdH1cblx0XHRyZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpXG5cdH0sXG5cdHNldFByb3RvdHlwZU9mOiBmdW5jdGlvbiAodGFyZ2V0LCBwcm90bykge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbm5vdCBzZXQgdGhlIHByb3RvdHlwZSBvZiBhIHNhbmRib3hlZCBvYmplY3QuJylcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcblx0fSxcblx0aXNFeHRlbnNpYmxlOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHRyZXR1cm4gZ2V0UHJveHlPclByaW1pdGl2ZShSZWZsZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpKVxuXHRcdH1cblx0XHRyZXR1cm4gUmVmbGVjdC5pc0V4dGVuc2libGUodGFyZ2V0KVxuXHR9LFxuXHRwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gKHRhcmdldCkge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbm5vdCBjaGFuZ2UgdGhlIGV4dGVuc2liaWxpdHkgb2YgYSBzYW5kYm94ZWQgb2JqZWN0LicpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zKHRhcmdldClcblx0fSxcblx0Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdGlmIChrZXkgPT09IFN5bWJvbC51bnNjb3BhYmxlcyAmJiB0YXJnZXQgPT09IGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWRcblx0XHRcdH1cblx0XHRcdGlmICghbm90UHJpdmF0ZShrZXkpKSB7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWRcblx0XHRcdH1cblx0XHRcdHJldHVybiBnZXRQcm94eU9yUHJpbWl0aXZlKFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSlcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KVxuXHR9LFxuXHRkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgY2Fubm90IGRlZmluZSBwcm9wZXJ0aWVzIG9uIGEgc2FuZGJveGVkIG9iamVjdC4nKVxuXHRcdH1cblx0XHRyZXR1cm4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcilcblx0fSxcblx0ZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuXHRcdGlmIChjdXJyZW50U2FuZGJveCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbm5vdCBkZWxldGUgcHJvcGVydGllcyBvbiBhIHNhbmRib3hlZCBvYmplY3QuJylcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpXG5cdH0sXG5cdG93bktleXM6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdHJldHVybiBnZXRQcm94eU9yUHJpbWl0aXZlKFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpLmZpbHRlcihub3RQcml2YXRlKSlcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG5cdH0sXG5cdGFwcGx5OiBmdW5jdGlvbiAodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSB7XG5cdFx0aWYgKGN1cnJlbnRTYW5kYm94KSB7XG5cdFx0XHRpZiAodGFyZ2V0ID09PSBGdW5jdGlvbkNvbnN0cnVjdG9yIHx8IHRhcmdldCA9PT0gRnVuY3Rpb25Db25zdHJ1Y3RvclByb3h5KSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBjYW5ub3QgdXNlIHRoZSBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpbiBhIHNhbmRib3hlZCBjb250ZXh0LicpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZ2V0UHJveHlPclByaW1pdGl2ZShSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkpXG5cdFx0fVxuXHRcdHJldHVybiBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdClcblx0fSxcblx0Y29uc3RydWN0OiBmdW5jdGlvbiAodGFyZ2V0LCBhcmd1bWVudHNMaXN0LCBuZXdUYXJnZXQpIHtcblx0XHRpZiAoY3VycmVudFNhbmRib3gpIHtcblx0XHRcdGlmICh0YXJnZXQgPT09IEZ1bmN0aW9uQ29uc3RydWN0b3IgfHwgdGFyZ2V0ID09PSBGdW5jdGlvbkNvbnN0cnVjdG9yUHJveHkpIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignWW91IGNhbm5vdCB1c2UgdGhlIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGluIGEgc2FuZGJveGVkIGNvbnRleHQuJylcblx0XHRcdH1cblx0XHRcdHJldHVybiBnZXRQcm94eU9yUHJpbWl0aXZlKFJlZmxlY3QuY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCwgbmV3VGFyZ2V0KSlcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmxlY3QuY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCwgbmV3VGFyZ2V0KVxuXHR9XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpXG59XG5cbmZ1bmN0aW9uIGdldFByb3h5T3JQcmltaXRpdmUodmFsdWUpIHtcblx0aWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuXHRcdHJldHVybiBzYWZlT2JqZWN0cy5pbmRleE9mKHZhbHVlKSA+PSAwID8gdmFsdWUgOiBnZXRQcm94eSh2YWx1ZSlcblx0fVxuXHRyZXR1cm4gdmFsdWVcbn1cblxuZnVuY3Rpb24gZ2V0UHJveHkob2JqZWN0LCBoaWRlT3JpZ2luYWwpIHtcblx0aWYgKG9iamVjdCA9PT0gR0xPQkFMKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGdsb2JhbCBvYmplY3QgaXMgZm9yYmlkZGVuIGZyb20gZW50ZXJpbmcgYSBzYW5kYm94ZWQgY29udGV4dC4nKVxuXHR9XG5cdGlmIChvYmplY3QgPT09IGV2YWxGdW5jdGlvbikge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBldmFsIGZ1bmN0aW9uIGlzIGZvcmJpZGRlbiBmcm9tIGVudGVyaW5nIGEgc2FuZGJveGVkIGNvbnRleHQuJylcblx0fVxuXHR2YXIgcHJveHkgPSByZWFkb25seVByb3hpZXMuZ2V0KG9iamVjdClcblx0aWYgKHR5cGVvZiBwcm94eSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRwcm94eSA9IG5ldyBQcm94eShvYmplY3QsIHRyYXBzKVxuXHRcdHJlYWRvbmx5UHJveGllcy5zZXQoaGlkZU9yaWdpbmFsID8gcHJveHkgOiBvYmplY3QsIHByb3h5KVxuXHR9XG5cdHJldHVybiBwcm94eVxufVxuXG5mdW5jdGlvbiBub3RQcml2YXRlKGtleSkge1xuXHRyZXR1cm4gdHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwga2V5WzBdICE9PSAnXydcbn1cblxuLy8gRnJlZXplIGFuZCBwcm94eSBhbnl0aGluZyB0aGF0IGlzIGFjY2Vzc2libGUgdGhyb3VnaCBKYXZhU2NyaXB0IHN5bnRheCBhbG9uZVxuLy8gVGhpcyBzaG91bGQgaW5jbHVkZSBhbnkgdmFsdWUgdGhhdCB5b3UgY2FuIGdldCBmcm9tIEphdmFTY3JpcHQgc3ludGF4IGl0c2VsZi5cbi8vIEZvciBleGFtcGxlOlxuLy8gICAgIFwibXkgc3RyaW5nXCIuZm9vYmFyXG4vLyAgICAgdHJ5IHt0aHJvdyAxfSBjYXRjaCAoZXJyKSB7ZXJyLmZvb2Jhcn1cbi8vIFN5bWJvbHMgYXJlIGluY2x1ZGVkIGhlcmUgYmVjYXVzZSB0aGV5IGFyZSBub3QgcHJvdGVjdGVkIGJ5IG91ciBwcm94eWluZ1xuLy8gYmVjYXVzZSB0aGV5IGFyZSBwcmltaXRpdmVzLlxudmFyIHNhZmVPYmplY3RzID0gcmVxdWlyZSgnLi9saWIvbWFrZS1zYWZlJykoW1xuXHRCb29sZWFuLnByb3RvdHlwZSxcblx0TnVtYmVyLnByb3RvdHlwZSxcblx0U3RyaW5nLnByb3RvdHlwZSxcblx0U3ltYm9sLnByb3RvdHlwZSxcblx0RnVuY3Rpb24ucHJvdG90eXBlLFxuXHRPYmplY3QucHJvdG90eXBlLFxuXHRBcnJheS5wcm90b3R5cGUsXG5cdFJlZ0V4cC5wcm90b3R5cGUsXG5cdEVycm9yLnByb3RvdHlwZSxcblx0RXZhbEVycm9yLnByb3RvdHlwZSxcblx0UmFuZ2VFcnJvci5wcm90b3R5cGUsXG5cdFJlZmVyZW5jZUVycm9yLnByb3RvdHlwZSxcblx0U3ludGF4RXJyb3IucHJvdG90eXBlLFxuXHRUeXBlRXJyb3IucHJvdG90eXBlLFxuXHRVUklFcnJvci5wcm90b3R5cGUsXG5cdFByb21pc2UucHJvdG90eXBlLFxuXHRPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnVuY3Rpb24qKCl7fSksXG5cdE9iamVjdC5nZXRQcm90b3R5cGVPZihmdW5jdGlvbiooKXt9KCkpXG5dLCBpc09iamVjdCwgZ2V0UHJveHksIEdMT0JBTClcblxudmFyIGV2YWxGdW5jdGlvbiA9IEdMT0JBTC5ldmFsXG52YXIgRnVuY3Rpb25Db25zdHJ1Y3RvclByb3h5ID0gMC4uY29uc3RydWN0b3IuY29uc3RydWN0b3JcblxubW9kdWxlLmV4cG9ydHMuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcblx0cmV0dXJuIGEgPT09IGIgfHwgKHJlYWRvbmx5UHJveGllcy5nZXQoYSkgfHwgYSkgPT09IChyZWFkb25seVByb3hpZXMuZ2V0KGIpIHx8IGIpXG59XG5cblxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVuc2FmZU9iamVjdHMsIGlzT2JqZWN0LCBnZXRQcm94eSwgR0xPQkFMKSB7XG5cdHZhciBwcm94aWVzID0gW11cblx0dmFyIHNhZmVPYmplY3RzID0gW11cblx0dmFyIHJldHVybnNTYWZlVmFsdWVzID0gW1xuXHRcdEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdXG5cdF1cblx0dmFyIGdsb2JhbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhHTE9CQUwpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gJ3Jvb3QnICYmIGtleSAhPT0gJ0dMT0JBTCcgJiYga2V5ICE9PSAnZ2xvYmFsJyAmJiBrZXkgIT09ICd3aW5kb3cnICYmIGtleSAhPT0gJ3NlbGYnfSlcblx0dmFyIGdsb2JhbFZhbHVlcyA9IGdsb2JhbEtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4gdGhpc1trZXldfSwgR0xPQkFMKVxuXHRcblx0d2hpbGUgKHVuc2FmZU9iamVjdHMubGVuZ3RoKSB7XG5cdFx0bWFrZVNhZmUodW5zYWZlT2JqZWN0cy5zaGlmdCgpKVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBtYWtlU2FmZShvYmplY3QpIHtcblx0XHRpZiAoaXNTYWZlKG9iamVjdCkpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHR2YXIgcmVhY2hhYmxlID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KVxuXHRcdFx0LmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCkpXG5cdFx0XG5cdFx0aWYgKG9iamVjdCA9PT0gRnVuY3Rpb24ucHJvdG90eXBlKSB7XG5cdFx0XHRyZWFjaGFibGUgPSByZWFjaGFibGUuZmlsdGVyKGlnbm9yZWRLZXlzKVxuXHRcdH1cblx0XHRcblx0XHRyZWFjaGFibGUuZm9yRWFjaChyZXBsYWNlV2l0aFByb3h5LCBvYmplY3QpXG5cdFx0T2JqZWN0LmZyZWV6ZShvYmplY3QpXG5cdFx0c2FmZU9iamVjdHMucHVzaChvYmplY3QpXG5cdFx0XG5cdFx0dW5zYWZlT2JqZWN0cy5wdXNoKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpKVxuXHR9XG5cdFxuXHRmdW5jdGlvbiBpZ25vcmVkS2V5cyhrZXkpIHtcblx0XHRyZXR1cm4ga2V5ICE9PSAnY2FsbGVyJyAmJiBrZXkgIT09ICdhcmd1bWVudHMnXG5cdH1cblx0XG5cdGZ1bmN0aW9uIGlzU2FmZSh2YWx1ZSkge1xuXHRcdHJldHVybiAhaXNPYmplY3QodmFsdWUpIHx8IHByb3hpZXMuaW5kZXhPZih2YWx1ZSkgPj0gMCB8fCBzYWZlT2JqZWN0cy5pbmRleE9mKHZhbHVlKSA+PSAwXG5cdH1cblx0XG5cdGZ1bmN0aW9uIHJlcGxhY2VXaXRoUHJveHkoa2V5KSB7XG5cdFx0dmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsIGtleSlcblx0XHRpZiAoISgndmFsdWUnIGluIGQpKSB7XG5cdFx0XHRpZiAoa2V5ID09PSAnX19wcm90b19fJyAmJiBpc1NhZmUodGhpc1trZXldKSkge1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGlmICghZC5jb25maWd1cmFibGUpIHtcblx0XHRcdFx0ZC5nZXQgJiYgdW5zYWZlT2JqZWN0cy5wdXNoKGQuZ2V0KVxuXHRcdFx0XHRkLnNldCAmJiB1bnNhZmVPYmplY3RzLnB1c2goZC5zZXQpXG5cdFx0XHRcdC8vIFRoaXMgZ2V0dGVyL3NldHRlciBjb3VsZCBwb3RlbnRpYWxseSByZXR1cm4gYSBub24tcHJveGllZCBvYmplY3Rcblx0XHRcdFx0Y29uc29sZS53YXJuKCdQb3RlbnRpYWxseSB2dWxuZXJhYmxlIGdldHRlci9zZXR0ZXIgYXQgJXMgaW4gJXMnLCBrZXksIHRoaXMpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0dmFyIGdldHRlciA9IGQuZ2V0ICYmIGdldFByb3h5KGQuZ2V0LCB0cnVlKVxuXHRcdFx0dmFyIHNldHRlciA9IGQuc2V0ICYmIGdldFByb3h5KGQuc2V0LCB0cnVlKVxuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuXHRcdFx0XHRnZXQ6IGdldHRlcixcblx0XHRcdFx0c2V0OiBzZXR0ZXIsXG5cdFx0XHRcdGVudW1lcmFibGU6IGQuZW51bWVyYWJsZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZVxuXHRcdFx0fSlcblx0XHRcdGdldHRlciAmJiBwcm94aWVzLnB1c2goZ2V0dGVyKVxuXHRcdFx0c2V0dGVyICYmIHByb3hpZXMucHVzaChzZXR0ZXIpXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0XG5cdFx0dmFyIHZhbHVlID0gdGhpc1trZXldXG5cdFx0aWYgKGlzU2FmZSh2YWx1ZSkpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHRpZiAoZC53cml0YWJsZSkge1xuXHRcdFx0dmFyIHByb3h5ID0gZ2V0UHJveHkodmFsdWUsIHRydWUpXG5cdFx0XHRwcm94aWVzLnB1c2godGhpc1trZXldID0gcHJveHkpXG5cdFx0XHRyZXBsYWNlSW5HbG9iYWwodmFsdWUsIHByb3h5KVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdFxuXHRcdGlmIChkLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0dmFyIHByb3h5ID0gZ2V0UHJveHkodmFsdWUsIHRydWUpXG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG5cdFx0XHRcdHZhbHVlOiBwcm94eSxcblx0XHRcdFx0d3JpdGFibGU6IGZhbHNlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiBkLmVudW1lcmFibGUsXG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2Vcblx0XHRcdH0pXG5cdFx0XHRyZXBsYWNlSW5HbG9iYWwodmFsdWUsIHByb3h5KVxuXHRcdFx0cHJveGllcy5wdXNoKHByb3h5KVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdFxuXHRcdHVuc2FmZU9iamVjdHMucHVzaCh2YWx1ZSlcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIHJldHVybnNTYWZlVmFsdWVzLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuXHRcdFx0Ly8gVGhpcyBmdW5jdGlvbiBjb3VsZCBwb3RlbnRpYWxseSByZXR1cm4gYSBub24tcHJveGllZCBvYmplY3Rcblx0XHRcdGNvbnNvbGUud2FybignUG90ZW50aWFsbHkgdnVsbmVyYWJsZSBmdW5jdGlvbiBhdCAlcyBpbiAlcycsIGtleSwgdGhpcylcblx0XHR9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHJlcGxhY2VJbkdsb2JhbCh2YWx1ZSwgcHJveHkpIHtcblx0XHR2YXIgaW5kZXggPSBnbG9iYWxWYWx1ZXMuaW5kZXhPZih2YWx1ZSlcblx0XHRpZiAoaW5kZXggPj0gMCkge1xuXHRcdFx0dmFyIGtleSA9IGdsb2JhbEtleXNbaW5kZXhdXG5cdFx0XHR2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoR0xPQkFMLCBrZXkpXG5cdFx0XHRpZiAoZC53cml0YWJsZSkge1xuXHRcdFx0XHRHTE9CQUxba2V5XSA9IHByb3h5XG5cdFx0XHR9IGVsc2UgaWYgKGQuY29uZmlndXJhYmxlKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHTE9CQUwsIGtleSwge1xuXHRcdFx0XHRcdHZhbHVlOiBwcm94eSxcblx0XHRcdFx0XHR3cml0YWJsZTogZmFsc2UsXG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogZC5lbnVtZXJhYmxlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2Vcblx0XHRcdFx0fSlcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignV2FzIG5vdCBhYmxlIHRvIHJlcGxhY2UgJXMgaW4gZ2xvYmFsIG9iamVjdCcsIGtleSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdHJldHVybiBzYWZlT2JqZWN0c1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuc2lSZWdleCA9IHJlcXVpcmUoJ2Fuc2ktcmVnZXgnKTtcbnZhciByZSA9IG5ldyBSZWdFeHAoYW5zaVJlZ2V4KCkuc291cmNlKTsgLy8gcmVtb3ZlIHRoZSBgZ2AgZmxhZ1xubW9kdWxlLmV4cG9ydHMgPSByZS50ZXN0LmJpbmQocmUpO1xuIiwiXG52YXIgcnhfZXNjYXBhYmxlID0gL1tcXFxcXFxcIlxcdTAwMDAtXFx1MDAxZlxcdTAwN2YtXFx1MDA5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nO1xuXG52YXIgZ2FwLFxuICAgIGluZGVudCxcbiAgICBtZXRhID0geyAvLyB0YWJsZSBvZiBjaGFyYWN0ZXIgc3Vic3RpdHV0aW9uc1xuICAgICAgJ1xcYic6ICdcXFxcYicsXG4gICAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgJ1xcZic6ICdcXFxcZicsXG4gICAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAgICdcIic6ICdcXFxcXCInLFxuICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXG4gICAgfSxcbiAgICByZXA7XG5cbmZ1bmN0aW9uIHF1b3RlKHN0cmluZykge1xuXG4vLyBJZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG5vIGNvbnRyb2wgY2hhcmFjdGVycywgbm8gcXVvdGUgY2hhcmFjdGVycywgYW5kIG5vXG4vLyBiYWNrc2xhc2ggY2hhcmFjdGVycywgdGhlbiB3ZSBjYW4gc2FmZWx5IHNsYXAgc29tZSBxdW90ZXMgYXJvdW5kIGl0LlxuLy8gT3RoZXJ3aXNlIHdlIG11c3QgYWxzbyByZXBsYWNlIHRoZSBvZmZlbmRpbmcgY2hhcmFjdGVycyB3aXRoIHNhZmUgZXNjYXBlXG4vLyBzZXF1ZW5jZXMuXG5cbiAgICByeF9lc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gcnhfZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKVxuICAgICAgICA/ICdcIicgKyBzdHJpbmcucmVwbGFjZShyeF9lc2NhcGFibGUsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBjXG4gICAgICAgICAgICAgICAgOiAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgfSkgKyAnXCInXG4gICAgICAgIDogJ1wiJyArIHN0cmluZyArICdcIic7XG59XG5cblxuZnVuY3Rpb24gc3RyKGtleSwgaG9sZGVyLCBsaW1pdCkge1xuXG4vLyBQcm9kdWNlIGEgc3RyaW5nIGZyb20gaG9sZGVyW2tleV0uXG5cbiAgICB2YXIgaSwgICAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlci5cbiAgICAgICAgaywgICAgICAgICAgLy8gVGhlIG1lbWJlciBrZXkuXG4gICAgICAgIHYsICAgICAgICAgIC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgbWluZCA9IGdhcCxcbiAgICAgICAgcGFydGlhbCxcbiAgICAgICAgdmFsdWUgPSBob2xkZXJba2V5XTtcblxuLy8gSWYgdGhlIHZhbHVlIGhhcyBhIHRvSlNPTiBtZXRob2QsIGNhbGwgaXQgdG8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG5cbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuICAgIH1cblxuLy8gSWYgd2Ugd2VyZSBjYWxsZWQgd2l0aCBhIHJlcGxhY2VyIGZ1bmN0aW9uLCB0aGVuIGNhbGwgdGhlIHJlcGxhY2VyIHRvXG4vLyBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cblxuICAgIGlmICh0eXBlb2YgcmVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gcmVwLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICB9XG5cbi8vIFdoYXQgaGFwcGVucyBuZXh0IGRlcGVuZHMgb24gdGhlIHZhbHVlJ3MgdHlwZS5cblxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIHF1b3RlKHZhbHVlKTtcblxuICAgIGNhc2UgJ251bWJlcic6XG5cbi8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gRW5jb2RlIG5vbi1maW5pdGUgbnVtYmVycyBhcyBudWxsLlxuXG4gICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSlcbiAgICAgICAgICAgID8gU3RyaW5nKHZhbHVlKVxuICAgICAgICAgICAgOiAnbnVsbCc7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICBjYXNlICdudWxsJzpcblxuLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSAnbnVsbCcuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cbi8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXG5cbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cbi8vIElmIHRoZSB0eXBlIGlzICdvYmplY3QnLCB3ZSBtaWdodCBiZSBkZWFsaW5nIHdpdGggYW4gb2JqZWN0IG9yIGFuIGFycmF5IG9yXG4vLyBudWxsLlxuXG4gICAgY2FzZSAnb2JqZWN0JzpcblxuLy8gRHVlIHRvIGEgc3BlY2lmaWNhdGlvbiBibHVuZGVyIGluIEVDTUFTY3JpcHQsIHR5cGVvZiBudWxsIGlzICdvYmplY3QnLFxuLy8gc28gd2F0Y2ggb3V0IGZvciB0aGF0IGNhc2UuXG5cbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgfVxuXG4vLyBNYWtlIGFuIGFycmF5IHRvIGhvbGQgdGhlIHBhcnRpYWwgcmVzdWx0cyBvZiBzdHJpbmdpZnlpbmcgdGhpcyBvYmplY3QgdmFsdWUuXG5cbiAgICAgICAgZ2FwICs9IGluZGVudDtcbiAgICAgICAgcGFydGlhbCA9IFtdO1xuXG4vLyBJcyB0aGUgdmFsdWUgYW4gYXJyYXk/XG5cbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG5cbi8vIFRoZSB2YWx1ZSBpcyBhbiBhcnJheS4gU3RyaW5naWZ5IGV2ZXJ5IGVsZW1lbnQuIFVzZSBudWxsIGFzIGEgcGxhY2Vob2xkZXJcbi8vIGZvciBub24tSlNPTiB2YWx1ZXMuXG5cbiAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHBhcnRpYWxbaV0gPSBzdHIoaSwgdmFsdWUsIGxpbWl0KSB8fCAnbnVsbCc7XG4gICAgICAgICAgICB9XG5cbi8vIEpvaW4gYWxsIG9mIHRoZSBlbGVtZW50cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLCBhbmQgd3JhcCB0aGVtIGluXG4vLyBicmFja2V0cy5cblxuICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgPyAnW10nXG4gICAgICAgICAgICAgICAgOiBnYXBcbiAgICAgICAgICAgICAgICAgICAgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgZ2FwLmxlbmd0aCArIHBhcnRpYWwuam9pbignLCAnKS5sZW5ndGggKyA0ID4gbGltaXQgP1xuICAgICAgICAgICAgICAgICAgICAgICdbXFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ10nIDpcbiAgICAgICAgICAgICAgICAgICAgICAnWyAnICsgcGFydGlhbC5qb2luKCcsICcpICsgJyBdJ1xuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogJ1snICsgcGFydGlhbC5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cblxuLy8gSWYgdGhlIHJlcGxhY2VyIGlzIGFuIGFycmF5LCB1c2UgaXQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlIHN0cmluZ2lmaWVkLlxuXG4gICAgICAgIGlmIChyZXAgJiYgdHlwZW9mIHJlcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IHJlcC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcFtpXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IHJlcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSwgbGltaXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICc6ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnOidcbiAgICAgICAgICAgICAgICAgICAgICAgICkgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcblxuLy8gT3RoZXJ3aXNlLCBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG5cbiAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUsIGxpbWl0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnOiAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJzonXG4gICAgICAgICAgICAgICAgICAgICAgICApICsgdik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuLy8gSm9pbiBhbGwgb2YgdGhlIG1lbWJlciB0ZXh0cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLFxuLy8gYW5kIHdyYXAgdGhlbSBpbiBicmFjZXMuXG5cbiAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwXG4gICAgICAgICAgICA/ICd7fSdcbiAgICAgICAgICAgIDogZ2FwXG4gICAgICAgICAgICAgICAgPyAoXG4gICAgICAgICAgICAgICAgICBnYXAubGVuZ3RoICsgcGFydGlhbC5qb2luKCcsICcpLmxlbmd0aCArIDQgPiBsaW1pdCA/XG4gICAgICAgICAgICAgICAgICAne1xcbicgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICsgbWluZCArICd9JyA6XG4gICAgICAgICAgICAgICAgICAneyAnICsgcGFydGlhbC5qb2luKCcsICcpICsgJyB9J1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6ICd7JyArIHBhcnRpYWwuam9pbignLCcpICsgJ30nO1xuICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gYmVhdXRpZnkgKHZhbHVlLCByZXBsYWNlciwgc3BhY2UsIGxpbWl0KSB7XG5cbi8vIFRoZSBzdHJpbmdpZnkgbWV0aG9kIHRha2VzIGEgdmFsdWUgYW5kIGFuIG9wdGlvbmFsIHJlcGxhY2VyLCBhbmQgYW4gb3B0aW9uYWxcbi8vIHNwYWNlIHBhcmFtZXRlciwgYW5kIHJldHVybnMgYSBKU09OIHRleHQuIFRoZSByZXBsYWNlciBjYW4gYmUgYSBmdW5jdGlvblxuLy8gdGhhdCBjYW4gcmVwbGFjZSB2YWx1ZXMsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCB3aWxsIHNlbGVjdCB0aGUga2V5cy5cbi8vIEEgZGVmYXVsdCByZXBsYWNlciBtZXRob2QgY2FuIGJlIHByb3ZpZGVkLiBVc2Ugb2YgdGhlIHNwYWNlIHBhcmFtZXRlciBjYW5cbi8vIHByb2R1Y2UgdGV4dCB0aGF0IGlzIG1vcmUgZWFzaWx5IHJlYWRhYmxlLlxuXG4gIHZhciBpO1xuICBnYXAgPSAnJztcbiAgaW5kZW50ID0gJyc7XG5cbiAgaWYgKCFsaW1pdCkgbGltaXQgPSAwO1xuXG4gIGlmICh0eXBlb2YgbGltaXQgIT09IFwibnVtYmVyXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmVhdWZpZmllcjogbGltaXQgbXVzdCBiZSBhIG51bWJlclwiKTtcblxuLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG51bWJlciwgbWFrZSBhbiBpbmRlbnQgc3RyaW5nIGNvbnRhaW5pbmcgdGhhdFxuLy8gbWFueSBzcGFjZXMuXG5cbiAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGFjZTsgaSArPSAxKSB7XG4gICAgICAgICAgaW5kZW50ICs9ICcgJztcbiAgICAgIH1cblxuLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbmRlbnQgc3RyaW5nLlxuXG4gIH0gZWxzZSBpZiAodHlwZW9mIHNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgaW5kZW50ID0gc3BhY2U7XG4gIH1cblxuLy8gSWYgdGhlcmUgaXMgYSByZXBsYWNlciwgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5LlxuLy8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvci5cblxuICByZXAgPSByZXBsYWNlcjtcbiAgaWYgKHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICh0eXBlb2YgcmVwbGFjZXIgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgdHlwZW9mIHJlcGxhY2VyLmxlbmd0aCAhPT0gJ251bWJlcicpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JlYXV0aWZpZXI6IHdyb25nIHJlcGxhY2VyIHBhcmFtZXRlcicpO1xuICB9XG5cbi8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgJycuXG4vLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBzdHJpbmdpZnlpbmcgdGhlIHZhbHVlLlxuXG4gIHJldHVybiBzdHIoJycsIHsnJzogdmFsdWV9LCBsaW1pdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmVhdXRpZnk7XG4iLCIvKipcbiAqIMKpIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAxNyBBbGwgUmlnaHRzIFJlc2VydmVkXG4gKiAgIFByb2plY3QgbmFtZTogSlNPTmF0YVxuICogICBUaGlzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLCBzZWUgTElDRU5TRVxuICovXG5cbi8qKlxuICogQG1vZHVsZSBKU09OYXRhXG4gKiBAZGVzY3JpcHRpb24gSlNPTiBxdWVyeSBhbmQgdHJhbnNmb3JtYXRpb24gbGFuZ3VhZ2VcbiAqL1xuXG4vKipcbiAqIGpzb25hdGFcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAqIEByZXR1cm5zIHt7ZXZhbHVhdGU6IGV2YWx1YXRlLCBhc3NpZ246IGFzc2lnbn19IEV2YWx1YXRlZCBleHByZXNzaW9uXG4gKi9cbnZhciBqc29uYXRhID0gKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBvcGVyYXRvcnMgPSB7XG4gICAgICAgICcuJzogNzUsXG4gICAgICAgICdbJzogODAsXG4gICAgICAgICddJzogMCxcbiAgICAgICAgJ3snOiA3MCxcbiAgICAgICAgJ30nOiAwLFxuICAgICAgICAnKCc6IDgwLFxuICAgICAgICAnKSc6IDAsXG4gICAgICAgICcsJzogMCxcbiAgICAgICAgJ0AnOiA3NSxcbiAgICAgICAgJyMnOiA3MCxcbiAgICAgICAgJzsnOiA4MCxcbiAgICAgICAgJzonOiA4MCxcbiAgICAgICAgJz8nOiAyMCxcbiAgICAgICAgJysnOiA1MCxcbiAgICAgICAgJy0nOiA1MCxcbiAgICAgICAgJyonOiA2MCxcbiAgICAgICAgJy8nOiA2MCxcbiAgICAgICAgJyUnOiA2MCxcbiAgICAgICAgJ3wnOiAyMCxcbiAgICAgICAgJz0nOiA0MCxcbiAgICAgICAgJzwnOiA0MCxcbiAgICAgICAgJz4nOiA0MCxcbiAgICAgICAgJ14nOiA0MCxcbiAgICAgICAgJyoqJzogNjAsXG4gICAgICAgICcuLic6IDIwLFxuICAgICAgICAnOj0nOiAxMCxcbiAgICAgICAgJyE9JzogNDAsXG4gICAgICAgICc8PSc6IDQwLFxuICAgICAgICAnPj0nOiA0MCxcbiAgICAgICAgJ34+JzogNDAsXG4gICAgICAgICdhbmQnOiAzMCxcbiAgICAgICAgJ29yJzogMjUsXG4gICAgICAgICdpbic6IDQwLFxuICAgICAgICAnJic6IDUwLFxuICAgICAgICAnISc6IDAsICAgLy8gbm90IGFuIG9wZXJhdG9yLCBidXQgbmVlZGVkIGFzIGEgc3RvcCBjaGFyYWN0ZXIgZm9yIG5hbWUgdG9rZW5zXG4gICAgICAgICd+JzogMCAgIC8vIG5vdCBhbiBvcGVyYXRvciwgYnV0IG5lZWRlZCBhcyBhIHN0b3AgY2hhcmFjdGVyIGZvciBuYW1lIHRva2Vuc1xuICAgIH07XG5cbiAgICB2YXIgZXNjYXBlcyA9IHsgIC8vIEpTT04gc3RyaW5nIGVzY2FwZSBzZXF1ZW5jZXMgLSBzZWUganNvbi5vcmdcbiAgICAgICAgJ1wiJzogJ1wiJyxcbiAgICAgICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgICAgICcvJzogJy8nLFxuICAgICAgICAnYic6ICdcXGInLFxuICAgICAgICAnZic6ICdcXGYnLFxuICAgICAgICAnbic6ICdcXG4nLFxuICAgICAgICAncic6ICdcXHInLFxuICAgICAgICAndCc6ICdcXHQnXG4gICAgfTtcblxuICAgIC8vIFRva2VuaXplciAobGV4ZXIpIC0gaW52b2tlZCBieSB0aGUgcGFyc2VyIHRvIHJldHVybiBvbmUgdG9rZW4gYXQgYSB0aW1lXG4gICAgdmFyIHRva2VuaXplciA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgICB2YXIgY3JlYXRlID0gZnVuY3Rpb24gKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0ge3R5cGU6IHR5cGUsIHZhbHVlOiB2YWx1ZSwgcG9zaXRpb246IHBvc2l0aW9ufTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHNjYW5SZWdleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gdGhlIHByZWZpeCAnLycgd2lsbCBoYXZlIGJlZW4gcHJldmlvdXNseSBzY2FubmVkLiBGaW5kIHRoZSBlbmQgb2YgdGhlIHJlZ2V4LlxuICAgICAgICAgICAgLy8gc2VhcmNoIGZvciBjbG9zaW5nICcvJyBpZ25vcmluZyBhbnkgdGhhdCBhcmUgZXNjYXBlZCwgb3Igd2l0aGluIGJyYWNrZXRzXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBwb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IDA7XG4gICAgICAgICAgICB2YXIgcGF0dGVybjtcbiAgICAgICAgICAgIHZhciBmbGFncztcbiAgICAgICAgICAgIHdoaWxlKHBvc2l0aW9uIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGFyID0gcGF0aC5jaGFyQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRDaGFyID09PSAnLycgJiYgcGF0aC5jaGFyQXQocG9zaXRpb24gLSAxKSAhPT0gJ1xcXFwnICYmIGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuZCBvZiByZWdleCBmb3VuZFxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gcGF0aC5zdWJzdHJpbmcoc3RhcnQsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYocGF0dGVybiA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMzAxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFyID0gcGF0aC5jaGFyQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAvLyBmbGFnc1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZShjdXJyZW50Q2hhciA9PT0gJ2knIHx8IGN1cnJlbnRDaGFyID09PSAnbScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhciA9IHBhdGguY2hhckF0KHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmbGFncyA9IHBhdGguc3Vic3RyaW5nKHN0YXJ0LCBwb3NpdGlvbikgKyAnZyc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoKGN1cnJlbnRDaGFyID09PSAnKCcgfHwgY3VycmVudENoYXIgPT09ICdbJyB8fCBjdXJyZW50Q2hhciA9PT0gJ3snKSAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiAtIDEpICE9PSAnXFxcXCcgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKChjdXJyZW50Q2hhciA9PT0gJyknIHx8IGN1cnJlbnRDaGFyID09PSAnXScgfHwgY3VycmVudENoYXIgPT09ICd9JykgJiYgcGF0aC5jaGFyQXQocG9zaXRpb24gLSAxKSAhPT0gJ1xcXFwnICkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgY29kZTogXCJTMDMwMlwiLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBsZW5ndGgpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGFyID0gcGF0aC5jaGFyQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgLy8gc2tpcCB3aGl0ZXNwYWNlXG4gICAgICAgICAgICB3aGlsZSAocG9zaXRpb24gPCBsZW5ndGggJiYgJyBcXHRcXG5cXHJcXHYnLmluZGV4T2YoY3VycmVudENoYXIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFyID0gcGF0aC5jaGFyQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCBmb3IgcmVnZXhcbiAgICAgICAgICAgIGlmIChwcmVmaXggIT09IHRydWUgJiYgY3VycmVudENoYXIgPT09ICcvJykge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgncmVnZXgnLCBzY2FuUmVnZXgoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYW5kbGUgZG91YmxlLWNoYXIgb3BlcmF0b3JzXG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICcuJyAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiArIDEpID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUtZG90IC4uIHJhbmdlIG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdvcGVyYXRvcicsICcuLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnOicgJiYgcGF0aC5jaGFyQXQocG9zaXRpb24gKyAxKSA9PT0gJz0nKSB7XG4gICAgICAgICAgICAgICAgLy8gOj0gYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgnb3BlcmF0b3InLCAnOj0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJyEnICYmIHBhdGguY2hhckF0KHBvc2l0aW9uICsgMSkgPT09ICc9Jykge1xuICAgICAgICAgICAgICAgIC8vICE9XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdvcGVyYXRvcicsICchPScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnPicgJiYgcGF0aC5jaGFyQXQocG9zaXRpb24gKyAxKSA9PT0gJz0nKSB7XG4gICAgICAgICAgICAgICAgLy8gPj1cbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ29wZXJhdG9yJywgJz49Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICc8JyAmJiBwYXRoLmNoYXJBdChwb3NpdGlvbiArIDEpID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICAvLyA8PVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgnb3BlcmF0b3InLCAnPD0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJyonICYmIHBhdGguY2hhckF0KHBvc2l0aW9uICsgMSkgPT09ICcqJykge1xuICAgICAgICAgICAgICAgIC8vICoqICBkZXNjZW5kYW50IHdpbGRjYXJkXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdvcGVyYXRvcicsICcqKicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnficgJiYgcGF0aC5jaGFyQXQocG9zaXRpb24gKyAxKSA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgLy8gfj4gIGNoYWluIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdvcGVyYXRvcicsICd+PicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCBmb3Igc2luZ2xlIGNoYXIgb3BlcmF0b3JzXG4gICAgICAgICAgICBpZiAob3BlcmF0b3JzLmhhc093blByb3BlcnR5KGN1cnJlbnRDaGFyKSkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgnb3BlcmF0b3InLCBjdXJyZW50Q2hhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IGZvciBzdHJpbmcgbGl0ZXJhbHNcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJ1wiJyB8fCBjdXJyZW50Q2hhciA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcXVvdGVUeXBlID0gY3VycmVudENoYXI7XG4gICAgICAgICAgICAgICAgLy8gZG91YmxlIHF1b3RlZCBzdHJpbmcgbGl0ZXJhbCAtIGZpbmQgZW5kIG9mIHN0cmluZ1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgdmFyIHFzdHIgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhciA9IHBhdGguY2hhckF0KHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnXFxcXCcpIHsgLy8gZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYXIgPSBwYXRoLmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXNjYXBlcy5oYXNPd25Qcm9wZXJ0eShjdXJyZW50Q2hhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxc3RyICs9IGVzY2FwZXNbY3VycmVudENoYXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Q2hhciA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXFx1IHNob3VsZCBiZSBmb2xsb3dlZCBieSA0IGhleCBkaWdpdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2N0ZXRzID0gcGF0aC5zdWJzdHIocG9zaXRpb24gKyAxLCA0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoL15bMC05YS1mQS1GXSskLy50ZXN0KG9jdGV0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGVwb2ludCA9IHBhcnNlSW50KG9jdGV0cywgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZXBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMTA0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWxsZWdhbCBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAxMDNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IGN1cnJlbnRDaGFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDaGFyID09PSBxdW90ZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCdzdHJpbmcnLCBxc3RyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFzdHIgKz0gY3VycmVudENoYXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMTAxXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCBmb3IgbnVtYmVyc1xuICAgICAgICAgICAgdmFyIG51bXJlZ2V4ID0gL14tPygwfChbMS05XVswLTldKikpKFxcLlswLTldKyk/KFtFZV1bLStdP1swLTldKyk/LztcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IG51bXJlZ2V4LmV4ZWMocGF0aC5zdWJzdHJpbmcocG9zaXRpb24pKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBudW0gPSBwYXJzZUZsb2F0KG1hdGNoWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKG51bSkgJiYgaXNGaW5pdGUobnVtKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ251bWJlcicsIG51bSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDEwMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogbWF0Y2hbMF1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IGZvciBxdW90ZWQgbmFtZXMgKGJhY2t0aWNrcylcbiAgICAgICAgICAgIHZhciBuYW1lO1xuICAgICAgICAgICAgaWYoY3VycmVudENoYXIgPT09ICdgJykge1xuICAgICAgICAgICAgICAgIC8vIHNjYW4gZm9yIGNsb3NpbmcgcXVvdGVcbiAgICAgICAgICAgICAgICBwb3NpdGlvbisrO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBwYXRoLmluZGV4T2YoJ2AnLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYoZW5kICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gcGF0aC5zdWJzdHJpbmcocG9zaXRpb24sIGVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gZW5kICsgMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgnbmFtZScsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAxMDVcIixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IGZvciBuYW1lc1xuICAgICAgICAgICAgdmFyIGkgPSBwb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciBjaDtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBjaCA9IHBhdGguY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBsZW5ndGggfHwgJyBcXHRcXG5cXHJcXHYnLmluZGV4T2YoY2gpID4gLTEgfHwgb3BlcmF0b3JzLmhhc093blByb3BlcnR5KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aC5jaGFyQXQocG9zaXRpb24pID09PSAnJCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhcmlhYmxlIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHBhdGguc3Vic3RyaW5nKHBvc2l0aW9uICsgMSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCd2YXJpYWJsZScsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHBhdGguc3Vic3RyaW5nKHBvc2l0aW9uLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ29yJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpbic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYW5kJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgnb3BlcmF0b3InLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0cnVlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgndmFsdWUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmYWxzZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGUoJ3ZhbHVlJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlKCd2YWx1ZScsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gbGVuZ3RoICYmIG5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGl0ZXNwYWNlIGF0IGVuZCBvZiBpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZSgnbmFtZScsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgZnVuY3Rpb24gc2lnbmF0dXJlIGRlZmluaXRpb24gYW5kIHJldHVybnMgYSB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZSAtIHRoZSBzaWduYXR1cmUgYmV0d2VlbiB0aGUgPGFuZ2xlIGJyYWNrZXRzPlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gdmFsaWRhdGlvbiBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgICAgICAvLyBjcmVhdGUgYSBSZWdleCB0aGF0IHJlcHJlc2VudHMgdGhpcyBzaWduYXR1cmUgYW5kIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgd2hlbiBpbnZva2VkLFxuICAgICAgICAvLyByZXR1cm5zIHRoZSB2YWxpZGF0ZWQgKHBvc3NpYmx5IGZpeGVkLXVwKSBhcmd1bWVudHMsIG9yIHRocm93cyBhIHZhbGlkYXRpb24gZXJyb3JcbiAgICAgICAgLy8gc3RlcCB0aHJvdWdoIHRoZSBzaWduYXR1cmUsIG9uZSBzeW1ib2wgYXQgYSB0aW1lXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IDE7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgdmFyIHBhcmFtID0ge307XG4gICAgICAgIHZhciBwcmV2UGFyYW0gPSBwYXJhbTtcbiAgICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgc2lnbmF0dXJlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHN5bWJvbCA9IHNpZ25hdHVyZS5jaGFyQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgaWYoc3ltYm9sID09PSAnOicpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGZpZ3VyZSBvdXQgd2hhdCB0byBkbyB3aXRoIHRoZSByZXR1cm4gdHlwZVxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBpdCBmb3Igbm93XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIHByZXZQYXJhbSA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIHBhcmFtID0ge307XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZmluZENsb3NpbmdCcmFja2V0ID0gZnVuY3Rpb24oc3RyLCBzdGFydCwgb3BlblN5bWJvbCwgY2xvc2VTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgY2xvc2luZyBzeW1ib2wgKGUuZy4gYnJhY2tldCkgaW4gYSBzdHJpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGJhbGFuY2VzIHRoZSBvcGVuaW5nIHN5bWJvbCBhdCBwb3NpdGlvbiBzdGFydFxuICAgICAgICAgICAgICAgIHZhciBkZXB0aCA9IDE7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUocG9zaXRpb24gPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN0ci5jaGFyQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wgPT09IGNsb3NlU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSBkb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIG91dCBvZiB3aGlsZSBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihzeW1ib2wgPT09IG9wZW5TeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc3dpdGNoIChzeW1ib2wpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzJzogLy8gc3RyaW5nXG4gICAgICAgICAgICAgICAgY2FzZSAnbic6IC8vIG51bWJlclxuICAgICAgICAgICAgICAgIGNhc2UgJ2InOiAvLyBib29sZWFuXG4gICAgICAgICAgICAgICAgY2FzZSAnbCc6IC8vIG5vdCBzbyBzdXJlIGFib3V0IGV4cGVjdGluZyBudWxsP1xuICAgICAgICAgICAgICAgIGNhc2UgJ28nOiAvLyBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0ucmVnZXggPSAnWycgKyBzeW1ib2wgKyAnbV0nO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbS50eXBlID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2EnOiAvLyBhcnJheVxuICAgICAgICAgICAgICAgICAgICAvLyAgbm9ybWFsbHkgdHJlYXQgYW55IHZhbHVlIGFzIHNpbmdsZXRvbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICBwYXJhbS5yZWdleCA9ICdbYXNuYmxmb21dJztcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0udHlwZSA9IHN5bWJvbDtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0uYXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOiAvLyBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICBwYXJhbS5yZWdleCA9ICdmJztcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0udHlwZSA9IHN5bWJvbDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdqJzogLy8gYW55IEpTT04gdHlwZVxuICAgICAgICAgICAgICAgICAgICBwYXJhbS5yZWdleCA9ICdbYXNuYmxvbV0nO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbS50eXBlID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3gnOiAvLyBhbnkgdHlwZVxuICAgICAgICAgICAgICAgICAgICBwYXJhbS5yZWdleCA9ICdbYXNuYmxmb21dJztcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0udHlwZSA9IHN5bWJvbDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICctJzogLy8gdXNlIGNvbnRleHQgaWYgcGFyYW0gbm90IHN1cHBsaWVkXG4gICAgICAgICAgICAgICAgICAgIHByZXZQYXJhbS5jb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcHJldlBhcmFtLmNvbnRleHRSZWdleCA9IG5ldyBSZWdFeHAocHJldlBhcmFtLnJlZ2V4KTsgLy8gcHJlLWNvbXBpbGVkIHRvIHRlc3QgdGhlIGNvbnRleHQgdHlwZSBhdCBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgIHByZXZQYXJhbS5yZWdleCArPSAnPyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJz8nOiAvLyBvcHRpb25hbCBwYXJhbVxuICAgICAgICAgICAgICAgIGNhc2UgJysnOiAvLyBvbmUgb3IgbW9yZVxuICAgICAgICAgICAgICAgICAgICBwcmV2UGFyYW0ucmVnZXggKz0gc3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICcoJzogLy8gY2hvaWNlIG9mIHR5cGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBmb3J3YXJkIGZvciBtYXRjaGluZyAnKSdcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZFBhcmVuID0gZmluZENsb3NpbmdCcmFja2V0KHNpZ25hdHVyZSwgcG9zaXRpb24sICcoJywgJyknKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNob2ljZSA9IHNpZ25hdHVyZS5zdWJzdHJpbmcocG9zaXRpb24gKyAxLCBlbmRQYXJlbik7XG4gICAgICAgICAgICAgICAgICAgIGlmKGNob2ljZS5pbmRleE9mKCc8JykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBwYXJhbWV0ZXJpemVkIHR5cGVzLCBzaW1wbGUgcmVnZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtLnJlZ2V4ID0gJ1snICsgY2hvaWNlICsgJ21dJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gaGFyZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDQwMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaG9pY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJhbS50eXBlID0gJygnICsgY2hvaWNlICsgJyknO1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGVuZFBhcmVuO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJzwnOiAvLyB0eXBlIHBhcmFtZXRlciAtIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gJ2EnIGFuZCAnZidcbiAgICAgICAgICAgICAgICAgICAgaWYocHJldlBhcmFtLnR5cGUgPT09ICdhJyB8fCBwcmV2UGFyYW0udHlwZSA9PT0gJ2YnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWFyY2ggZm9yd2FyZCBmb3IgbWF0Y2hpbmcgJz4nXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kUG9zID0gZmluZENsb3NpbmdCcmFja2V0KHNpZ25hdHVyZSwgcG9zaXRpb24sICc8JywgJz4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZQYXJhbS5zdWJ0eXBlID0gc2lnbmF0dXJlLnN1YnN0cmluZyhwb3NpdGlvbiArIDEsIGVuZFBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGVuZFBvcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwNDAxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHByZXZQYXJhbS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NpdGlvbisrO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWdleFN0ciA9ICdeJyArXG4gICAgICAgICAgcGFyYW1zLm1hcChmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICAgICAgICByZXR1cm4gJygnICsgcGFyYW0ucmVnZXggKyAnKSc7XG4gICAgICAgICAgfSkuam9pbignJykgK1xuICAgICAgICAgICckJztcbiAgICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleFN0cik7XG4gICAgICAgIHZhciBnZXRTeW1ib2wgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHN5bWJvbDtcbiAgICAgICAgICAgIGlmKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gJ2YnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9ICdzJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gJ24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gJ2InO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSAnbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gJ2EnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSAnbyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFueSB2YWx1ZSBjYW4gYmUgdW5kZWZpbmVkLCBidXQgc2hvdWxkIGJlIGFsbG93ZWQgdG8gbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9ICdtJzsgLy8gbSBmb3IgbWlzc2luZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHRocm93VmFsaWRhdGlvbkVycm9yID0gZnVuY3Rpb24oYmFkQXJncywgYmFkU2lnKSB7XG4gICAgICAgICAgICAvLyB0byBmaWd1cmUgb3V0IHdoZXJlIHRoaXMgd2VudCB3cm9uZyB3ZSBuZWVkIGFwcGx5IGVhY2ggY29tcG9uZW50IG9mIHRoZVxuICAgICAgICAgICAgLy8gcmVnZXggdG8gZWFjaCBhcmd1bWVudCB1bnRpbCB3ZSBnZXQgdG8gdGhlIG9uZSB0aGF0IGZhaWxzIHRvIG1hdGNoXG4gICAgICAgICAgICB2YXIgcGFydGlhbFBhdHRlcm4gPSAnXic7XG4gICAgICAgICAgICB2YXIgZ29vZFRvID0gMDtcbiAgICAgICAgICAgIGZvcih2YXIgaW5kZXggPSAwOyBpbmRleCA8IHBhcmFtcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsUGF0dGVybiArPSBwYXJhbXNbaW5kZXhdLnJlZ2V4O1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGJhZFNpZy5tYXRjaChwYXJ0aWFsUGF0dGVybik7XG4gICAgICAgICAgICAgICAgaWYobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFpbGVkIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJUMDQxMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYmFkQXJnc1tnb29kVG9dLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGdvb2RUbyArIDFcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ29vZFRvID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgaXQgZ290IHRoaXMgZmFyLCBpdCdzIHByb2JhYmx5IGJlY2F1c2Ugb2YgZXh0cmFuZW91cyBhcmd1bWVudHMgKHdlXG4gICAgICAgICAgICAvLyBoYXZlbid0IGFkZGVkIHRoZSB0cmFpbGluZyAnJCcgaW4gdGhlIHJlZ2V4IHlldC5cbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlQwNDEwXCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IGJhZEFyZ3NbZ29vZFRvXSxcbiAgICAgICAgICAgICAgICBpbmRleDogZ29vZFRvICsgMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVmaW5pdGlvbjogc2lnbmF0dXJlLFxuICAgICAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VwcGxpZWRTaWcgPSAnJztcbiAgICAgICAgICAgICAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBsaWVkU2lnICs9IGdldFN5bWJvbChhcmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBpc1ZhbGlkID0gcmVnZXguZXhlYyhzdXBwbGllZFNpZyk7XG4gICAgICAgICAgICAgICAgaWYoaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdGVkQXJncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZm9yRWFjaChmdW5jdGlvbihwYXJhbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBhcmdzW2FyZ0luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGlzVmFsaWRbaW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG1hdGNoID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbS5jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1YnN0aXR1dGUgY29udGV4dCB2YWx1ZSBmb3IgbWlzc2luZyBhcmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgY2hlY2sgdGhhdCB0aGUgY29udGV4dCB2YWx1ZSBpcyB0aGUgcmlnaHQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dFR5cGUgPSBnZXRTeW1ib2woY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRlc3QgY29udGV4dFR5cGUgYWdhaW5zdCB0aGUgcmVnZXggZm9yIHRoaXMgYXJnICh3aXRob3V0IHRoZSB0cmFpbGluZyA/KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihwYXJhbS5jb250ZXh0UmVnZXgudGVzdChjb250ZXh0VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlZEFyZ3MucHVzaChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRleHQgdmFsdWUgbm90IGNvbXBhdGlibGUgd2l0aCB0aGlzIGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJUMDQxMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBhcmdJbmRleCArIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZWRBcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heSBoYXZlIG1hdGNoZWQgbXVsdGlwbGUgYXJncyAoaWYgdGhlIHJlZ2V4IGVuZHMgd2l0aCBhICcrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwbGl0IGludG8gc2luZ2xlIHRva2Vuc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uKHNpbmdsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2luZ2xlID09PSAnbScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtaXNzaW5nICh1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmdzW2FyZ0luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXlPSyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgdGhlcmUgdHlwZSBpbmZvcm1hdGlvbiBvbiB0aGUgY29udGVudHMgb2YgdGhlIGFycmF5P1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW0uc3VidHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpbmdsZSAhPT0gJ2EnICYmIG1hdGNoICE9PSBwYXJhbS5zdWJ0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheU9LID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2luZ2xlID09PSAnYScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtVHlwZSA9IGdldFN5bWJvbChhcmdbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtVHlwZSAhPT0gcGFyYW0uc3VidHlwZS5jaGFyQXQoMCkpIHsgLy8gVE9ETyByZWN1cnNlIGZ1cnRoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlPSyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBldmVyeSBpdGVtIGluIHRoZSBhcnJheSBpcyB0aGlzIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpZmZlcmVudEl0ZW1zID0gYXJnLmZpbHRlcihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGdldFN5bWJvbCh2YWwpICE9PSBpdGVtVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheU9LID0gKGRpZmZlcmVudEl0ZW1zLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJyYXlPSykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQwNDEyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhcmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogYXJnSW5kZXggKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogcGFyYW0uc3VidHlwZSAvLyBUT0RPIHRyYW5zbGF0ZSBzeW1ib2wgdG8gdHlwZSBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmdW5jdGlvbiBleHBlY3RzIGFuIGFycmF5LiBJZiBpdCdzIG5vdCBvbmUsIG1ha2UgaXQgc29cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2luZ2xlICE9PSAnYScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gW2FyZ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVkQXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVkQXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVkQXJncztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3dWYWxpZGF0aW9uRXJyb3IoYXJncywgc3VwcGxpZWRTaWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIFRoaXMgcGFyc2VyIGltcGxlbWVudHMgdGhlICdUb3AgZG93biBvcGVyYXRvciBwcmVjZWRlbmNlJyBhbGdvcml0aG0gZGV2ZWxvcGVkIGJ5IFZhdWdoYW4gUiBQcmF0dDsgaHR0cDovL2RsLmFjbS5vcmcvY2l0YXRpb24uY2ZtP2lkPTUxMjkzMS5cbiAgICAvLyBhbmQgYnVpbGRzIG9uIHRoZSBKYXZhc2NyaXB0IGZyYW1ld29yayBkZXNjcmliZWQgYnkgRG91Z2xhcyBDcm9ja2ZvcmQgYXQgaHR0cDovL2phdmFzY3JpcHQuY3JvY2tmb3JkLmNvbS90ZG9wL3Rkb3AuaHRtbFxuICAgIC8vIGFuZCBpbiAnQmVhdXRpZnVsIENvZGUnLCBlZGl0ZWQgYnkgQW5keSBPcmFtIGFuZCBHcmVnIFdpbHNvbiwgQ29weXJpZ2h0IDIwMDcgTydSZWlsbHkgTWVkaWEsIEluYy4gNzk4LTAtNTk2LTUxMDA0LTZcblxuICAgIHZhciBwYXJzZXIgPSBmdW5jdGlvbiAoc291cmNlLCByZWNvdmVyKSB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICB2YXIgbGV4ZXI7XG5cbiAgICAgICAgdmFyIHN5bWJvbF90YWJsZSA9IHt9O1xuICAgICAgICB2YXIgZXJyb3JzID0gW107XG5cbiAgICAgICAgdmFyIHJlbWFpbmluZ1Rva2VucyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IFtdO1xuICAgICAgICAgICAgaWYobm9kZS5pZCAhPT0gJyhlbmQpJykge1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZy5wdXNoKHt0eXBlOiBub2RlLnR5cGUsIHZhbHVlOiBub2RlLnZhbHVlLCBwb3NpdGlvbjogbm9kZS5wb3NpdGlvbn0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG54dCA9IGxleGVyKCk7XG4gICAgICAgICAgICB3aGlsZShueHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZW1haW5pbmcucHVzaChueHQpO1xuICAgICAgICAgICAgICAgIG54dCA9IGxleGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVtYWluaW5nO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBiYXNlX3N5bWJvbCA9IHtcbiAgICAgICAgICAgIG51ZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIGVycm9yIC0gc3ltYm9sIGhhcyBiZWVuIGludm9rZWQgYXMgYSB1bmFyeSBvcGVyYXRvclxuICAgICAgICAgICAgICAgIHZhciBlcnIgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6ICdTMDIxMScsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5wb3NpdGlvblxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZihyZWNvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyci5yZW1haW5pbmcgPSByZW1haW5pbmdUb2tlbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyLnR5cGUgPSAnZXJyb3InO1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVyci5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHN5bWJvbCA9IGZ1bmN0aW9uIChpZCwgYnApIHtcbiAgICAgICAgICAgIHZhciBzID0gc3ltYm9sX3RhYmxlW2lkXTtcbiAgICAgICAgICAgIGJwID0gYnAgfHwgMDtcbiAgICAgICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJwID49IHMubGJwKSB7XG4gICAgICAgICAgICAgICAgICAgIHMubGJwID0gYnA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzID0gT2JqZWN0LmNyZWF0ZShiYXNlX3N5bWJvbCk7XG4gICAgICAgICAgICAgICAgcy5pZCA9IHMudmFsdWUgPSBpZDtcbiAgICAgICAgICAgICAgICBzLmxicCA9IGJwO1xuICAgICAgICAgICAgICAgIHN5bWJvbF90YWJsZVtpZF0gPSBzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGhhbmRsZUVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpZihyZWNvdmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gdG9rZW5pemUgdGhlIHJlc3Qgb2YgdGhlIGJ1ZmZlciBhbmQgYWRkIGl0IHRvIGFuIGVycm9yIHRva2VuXG4gICAgICAgICAgICAgICAgZXJyLnJlbWFpbmluZyA9IHJlbWFpbmluZ1Rva2VucygpO1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgdmFyIHN5bWJvbCA9IHN5bWJvbF90YWJsZVtcIihlcnJvcilcIl07XG4gICAgICAgICAgICAgICAgbm9kZSA9IE9iamVjdC5jcmVhdGUoc3ltYm9sKTtcbiAgICAgICAgICAgICAgICBub2RlLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IFwiKGVycm9yKVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnIuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYWR2YW5jZSA9IGZ1bmN0aW9uIChpZCwgaW5maXgpIHtcbiAgICAgICAgICAgIGlmIChpZCAmJiBub2RlLmlkICE9PSBpZCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlO1xuICAgICAgICAgICAgICAgIGlmKG5vZGUuaWQgPT09ICcoZW5kKScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5leHBlY3RlZCBlbmQgb2YgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBcIlMwMjAzXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IFwiUzAyMDJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IG5vZGUucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiBub2RlLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5leHRfdG9rZW4gPSBsZXhlcihpbmZpeCk7XG4gICAgICAgICAgICBpZiAobmV4dF90b2tlbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBzeW1ib2xfdGFibGVbXCIoZW5kKVwiXTtcbiAgICAgICAgICAgICAgICBub2RlLnBvc2l0aW9uID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5leHRfdG9rZW4udmFsdWU7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IG5leHRfdG9rZW4udHlwZTtcbiAgICAgICAgICAgIHZhciBzeW1ib2w7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICAgICAgICBjYXNlICd2YXJpYWJsZSc6XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbF90YWJsZVtcIihuYW1lKVwiXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnb3BlcmF0b3InOlxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2xfdGFibGVbdmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDIwNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBuZXh0X3Rva2VuLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwibGl0ZXJhbFwiO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2xfdGFibGVbXCIobGl0ZXJhbClcIl07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JlZ2V4JzpcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwicmVnZXhcIjtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gc3ltYm9sX3RhYmxlW1wiKHJlZ2V4KVwiXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMjA1XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBuZXh0X3Rva2VuLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gT2JqZWN0LmNyZWF0ZShzeW1ib2wpO1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgbm9kZS50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIG5vZGUucG9zaXRpb24gPSBuZXh0X3Rva2VuLnBvc2l0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHJhdHQncyBhbGdvcml0aG1cbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBmdW5jdGlvbiAocmJwKSB7XG4gICAgICAgICAgICB2YXIgbGVmdDtcbiAgICAgICAgICAgIHZhciB0ID0gbm9kZTtcbiAgICAgICAgICAgIGFkdmFuY2UobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICBsZWZ0ID0gdC5udWQoKTtcbiAgICAgICAgICAgIHdoaWxlIChyYnAgPCBub2RlLmxicCkge1xuICAgICAgICAgICAgICAgIHQgPSBub2RlO1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gdC5sZWQobGVmdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdGVybWluYWwgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgdmFyIHMgPSBzeW1ib2woaWQsIDApO1xuICAgICAgICAgICAgcy5udWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbWF0Y2ggaW5maXggb3BlcmF0b3JzXG4gICAgICAgIC8vIDxleHByZXNzaW9uPiA8b3BlcmF0b3I+IDxleHByZXNzaW9uPlxuICAgICAgICAvLyBsZWZ0IGFzc29jaWF0aXZlXG4gICAgICAgIHZhciBpbmZpeCA9IGZ1bmN0aW9uIChpZCwgYnAsIGxlZCkge1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdQb3dlciA9IGJwIHx8IG9wZXJhdG9yc1tpZF07XG4gICAgICAgICAgICB2YXIgcyA9IHN5bWJvbChpZCwgYmluZGluZ1Bvd2VyKTtcbiAgICAgICAgICAgIHMubGVkID0gbGVkIHx8IGZ1bmN0aW9uIChsZWZ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saHMgPSBsZWZ0O1xuICAgICAgICAgICAgICAgIHRoaXMucmhzID0gZXhwcmVzc2lvbihiaW5kaW5nUG93ZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiYmluYXJ5XCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbWF0Y2ggaW5maXggb3BlcmF0b3JzXG4gICAgICAgIC8vIDxleHByZXNzaW9uPiA8b3BlcmF0b3I+IDxleHByZXNzaW9uPlxuICAgICAgICAvLyByaWdodCBhc3NvY2lhdGl2ZVxuICAgICAgICB2YXIgaW5maXhyID0gZnVuY3Rpb24gKGlkLCBicCwgbGVkKSB7XG4gICAgICAgICAgICB2YXIgYmluZGluZ1Bvd2VyID0gYnAgfHwgb3BlcmF0b3JzW2lkXTtcbiAgICAgICAgICAgIHZhciBzID0gc3ltYm9sKGlkLCBiaW5kaW5nUG93ZXIpO1xuICAgICAgICAgICAgcy5sZWQgPSBsZWQgfHwgZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxocyA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yaHMgPSBleHByZXNzaW9uKGJpbmRpbmdQb3dlciAtIDEpOyAvLyBzdWJ0cmFjdCAxIGZyb20gYmluZGluZ1Bvd2VyIGZvciByaWdodCBhc3NvY2lhdGl2ZSBvcGVyYXRvcnNcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcImJpbmFyeVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG1hdGNoIHByZWZpeCBvcGVyYXRvcnNcbiAgICAgICAgLy8gPG9wZXJhdG9yPiA8ZXhwcmVzc2lvbj5cbiAgICAgICAgdmFyIHByZWZpeCA9IGZ1bmN0aW9uIChpZCwgbnVkKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHN5bWJvbChpZCk7XG4gICAgICAgICAgICBzLm51ZCA9IG51ZCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbig3MCk7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJ1bmFyeVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRlcm1pbmFsKFwiKGVuZClcIik7XG4gICAgICAgIHRlcm1pbmFsKFwiKG5hbWUpXCIpO1xuICAgICAgICB0ZXJtaW5hbChcIihsaXRlcmFsKVwiKTtcbiAgICAgICAgdGVybWluYWwoXCIocmVnZXgpXCIpO1xuICAgICAgICBzeW1ib2woXCI6XCIpO1xuICAgICAgICBzeW1ib2woXCI7XCIpO1xuICAgICAgICBzeW1ib2woXCIsXCIpO1xuICAgICAgICBzeW1ib2woXCIpXCIpO1xuICAgICAgICBzeW1ib2woXCJdXCIpO1xuICAgICAgICBzeW1ib2woXCJ9XCIpO1xuICAgICAgICBzeW1ib2woXCIuLlwiKTsgLy8gcmFuZ2Ugb3BlcmF0b3JcbiAgICAgICAgaW5maXgoXCIuXCIpOyAvLyBmaWVsZCByZWZlcmVuY2VcbiAgICAgICAgaW5maXgoXCIrXCIpOyAvLyBudW1lcmljIGFkZGl0aW9uXG4gICAgICAgIGluZml4KFwiLVwiKTsgLy8gbnVtZXJpYyBzdWJ0cmFjdGlvblxuICAgICAgICBpbmZpeChcIipcIik7IC8vIG51bWVyaWMgbXVsdGlwbGljYXRpb25cbiAgICAgICAgaW5maXgoXCIvXCIpOyAvLyBudW1lcmljIGRpdmlzaW9uXG4gICAgICAgIGluZml4KFwiJVwiKTsgLy8gbnVtZXJpYyBtb2R1bHVzXG4gICAgICAgIGluZml4KFwiPVwiKTsgLy8gZXF1YWxpdHlcbiAgICAgICAgaW5maXgoXCI8XCIpOyAvLyBsZXNzIHRoYW5cbiAgICAgICAgaW5maXgoXCI+XCIpOyAvLyBncmVhdGVyIHRoYW5cbiAgICAgICAgaW5maXgoXCIhPVwiKTsgLy8gbm90IGVxdWFsIHRvXG4gICAgICAgIGluZml4KFwiPD1cIik7IC8vIGxlc3MgdGhhbiBvciBlcXVhbFxuICAgICAgICBpbmZpeChcIj49XCIpOyAvLyBncmVhdGVyIHRoYW4gb3IgZXF1YWxcbiAgICAgICAgaW5maXgoXCImXCIpOyAvLyBzdHJpbmcgY29uY2F0ZW5hdGlvblxuICAgICAgICBpbmZpeChcImFuZFwiKTsgLy8gQm9vbGVhbiBBTkRcbiAgICAgICAgaW5maXgoXCJvclwiKTsgLy8gQm9vbGVhbiBPUlxuICAgICAgICBpbmZpeChcImluXCIpOyAvLyBpcyBtZW1iZXIgb2YgYXJyYXlcbiAgICAgICAgdGVybWluYWwoXCJhbmRcIik7IC8vIHRoZSAna2V5d29yZHMnIGNhbiBhbHNvIGJlIHVzZWQgYXMgdGVybWluYWxzIChmaWVsZCBuYW1lcylcbiAgICAgICAgdGVybWluYWwoXCJvclwiKTsgLy9cbiAgICAgICAgdGVybWluYWwoXCJpblwiKTsgLy9cbiAgICAgICAgaW5maXhyKFwiOj1cIik7IC8vIGJpbmQgdmFyaWFibGVcbiAgICAgICAgcHJlZml4KFwiLVwiKTsgLy8gdW5hcnkgbnVtZXJpYyBuZWdhdGlvblxuICAgICAgICBpbmZpeChcIn4+XCIpOyAvLyBmdW5jdGlvbiBhcHBsaWNhdGlvblxuXG4gICAgICAgIGluZml4cihcIihlcnJvcilcIiwgMTAsIGZ1bmN0aW9uKGxlZnQpIHtcbiAgICAgICAgICAgIHRoaXMubGhzID0gbGVmdDtcblxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IG5vZGUuZXJyb3I7XG4gICAgICAgICAgICB0aGlzLnJlbWFpbmluZyA9IHJlbWFpbmluZ1Rva2VucygpO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ2Vycm9yJztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBmaWVsZCB3aWxkY2FyZCAoc2luZ2xlIGxldmVsKVxuICAgICAgICBwcmVmaXgoJyonLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBcIndpbGRjYXJkXCI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZGVzY2VuZGFudCB3aWxkY2FyZCAobXVsdGktbGV2ZWwpXG4gICAgICAgIHByZWZpeCgnKionLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBcImRlc2NlbmRhbnRcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBmdW5jdGlvbiBpbnZvY2F0aW9uXG4gICAgICAgIGluZml4KFwiKFwiLCBvcGVyYXRvcnNbJygnXSwgZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgICAgIC8vIGxlZnQgaXMgaXMgd2hhdCB3ZSBhcmUgdHJ5aW5nIHRvIGludm9rZVxuICAgICAgICAgICAgdGhpcy5wcm9jZWR1cmUgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnRzID0gW107XG4gICAgICAgICAgICBpZiAobm9kZS5pZCAhPT0gJyknKSB7XG4gICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnb3BlcmF0b3InICYmIG5vZGUuaWQgPT09ICc/Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFydGlhbCBmdW5jdGlvbiBhcHBsaWNhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gJ3BhcnRpYWwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmd1bWVudHMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoJz8nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJndW1lbnRzLnB1c2goZXhwcmVzc2lvbigwKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgIT09ICcsJykgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoJywnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZHZhbmNlKFwiKVwiLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiBpcyAnZnVuY3Rpb24nIG9yIM67LCB0aGVuIHRoaXMgaXMgZnVuY3Rpb24gZGVmaW5pdGlvbiAobGFtYmRhIGZ1bmN0aW9uKVxuICAgICAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ25hbWUnICYmIChsZWZ0LnZhbHVlID09PSAnZnVuY3Rpb24nIHx8IGxlZnQudmFsdWUgPT09ICdcXHUwM0JCJykpIHtcbiAgICAgICAgICAgICAgICAvLyBhbGwgb2YgdGhlIGFyZ3MgbXVzdCBiZSBWQVJJQUJMRSB0b2tlbnNcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmcudHlwZSAhPT0gJ3ZhcmlhYmxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDIwOFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBhcmcucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IGFyZy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5kZXggKyAxXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdsYW1iZGEnO1xuICAgICAgICAgICAgICAgIC8vIGlzIHRoZSBuZXh0IHRva2VuIGEgJzwnIC0gaWYgc28sIHBhcnNlIHRoZSBmdW5jdGlvbiBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICBpZihub2RlLmlkID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ1BvcyA9IG5vZGUucG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXB0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWcgPSAnPCc7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGRlcHRoID4gMCAmJiBub2RlLmlkICE9PSAneycgJiYgbm9kZS5pZCAhPT0gJyhlbmQpJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvayA9IGFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRvay5pZCA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZih0b2suaWQgPT09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWcgKz0gdG9rLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoJz4nKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2lnbmF0dXJlID0gcGFyc2VTaWduYXR1cmUoc2lnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2VydCB0aGUgcG9zaXRpb24gaW50byB0aGlzIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIucG9zaXRpb24gPSBzaWdQb3MgKyBlcnIub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKCBlcnIgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBwYXJzZSB0aGUgZnVuY3Rpb24gYm9keVxuICAgICAgICAgICAgICAgIGFkdmFuY2UoJ3snKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkgPSBleHByZXNzaW9uKDApO1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoJ30nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBwYXJlbnRoZXNpcyAtIGJsb2NrIGV4cHJlc3Npb25cbiAgICAgICAgcHJlZml4KFwiKFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChub2RlLmlkICE9PSBcIilcIikge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbigwKSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgIT09IFwiO1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZHZhbmNlKFwiO1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoXCIpXCIsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhcnJheSBjb25zdHJ1Y3RvclxuICAgICAgICBwcmVmaXgoXCJbXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICBpZiAobm9kZS5pZCAhPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT09IFwiLi5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmFuZ2Ugb3BlcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHt0eXBlOiBcImJpbmFyeVwiLCB2YWx1ZTogXCIuLlwiLCBwb3NpdGlvbjogbm9kZS5wb3NpdGlvbiwgbGhzOiBpdGVtfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoXCIuLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnJocyA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gcmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCAhPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoXCIsXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoXCJdXCIsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGE7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBcInVuYXJ5XCI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZmlsdGVyIC0gcHJlZGljYXRlIG9yIGFycmF5IGluZGV4XG4gICAgICAgIGluZml4KFwiW1wiLCBvcGVyYXRvcnNbJ1snXSwgZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgICAgIGlmKG5vZGUuaWQgPT09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgcHJlZGljYXRlIG1lYW5zIG1haW50YWluIHNpbmdsZXRvbiBhcnJheXMgaW4gdGhlIG91dHB1dFxuICAgICAgICAgICAgICAgIHZhciBzdGVwID0gbGVmdDtcbiAgICAgICAgICAgICAgICB3aGlsZShzdGVwICYmIHN0ZXAudHlwZSA9PT0gJ2JpbmFyeScgJiYgc3RlcC52YWx1ZSA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXAgPSBzdGVwLmxocztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RlcC5rZWVwQXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoXCJdXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxocyA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yaHMgPSBleHByZXNzaW9uKG9wZXJhdG9yc1snXSddKTtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAnYmluYXJ5JztcbiAgICAgICAgICAgICAgICBhZHZhbmNlKFwiXVwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gb3JkZXItYnlcbiAgICAgICAgaW5maXgoXCJeXCIsIG9wZXJhdG9yc1snXiddLCBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICAgICAgYWR2YW5jZShcIihcIik7XG4gICAgICAgICAgICB2YXIgdGVybXMgPSBbXTtcbiAgICAgICAgICAgIGZvcig7Oykge1xuICAgICAgICAgICAgICAgIHZhciB0ZXJtID0ge1xuICAgICAgICAgICAgICAgICAgICBkZXNjZW5kaW5nOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT09IFwiPFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFzY2VuZGluZyBzb3J0XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoXCI8XCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5pZCA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVzY2VuZGluZyBzb3J0XG4gICAgICAgICAgICAgICAgICAgIHRlcm0uZGVzY2VuZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoXCI+XCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdW5zcGVjaWZpZWQgLSBkZWZhdWx0IHRvIGFzY2VuZGluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZXJtLmV4cHJlc3Npb24gPSBleHByZXNzaW9uKDApO1xuICAgICAgICAgICAgICAgIHRlcm1zLnB1c2godGVybSk7XG4gICAgICAgICAgICAgICAgaWYobm9kZS5pZCAhPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkdmFuY2UoXCIsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShcIilcIik7XG4gICAgICAgICAgICB0aGlzLmxocyA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJocyA9IHRlcm1zO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ2JpbmFyeSc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG9iamVjdFBhcnNlciA9IGZ1bmN0aW9uIChsZWZ0KSB7XG4gICAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgaWYgKG5vZGUuaWQgIT09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoXCI6XCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChbbiwgdl0pOyAvLyBob2xkcyBhbiBhcnJheSBvZiBuYW1lL3ZhbHVlIGV4cHJlc3Npb24gcGFpcnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaWQgIT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKFwiLFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZHZhbmNlKFwifVwiLCB0cnVlKTtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIC8vIE5VRCAtIHVuYXJ5IHByZWZpeCBmb3JtXG4gICAgICAgICAgICAgICAgdGhpcy5saHMgPSBhO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwidW5hcnlcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTEVEIC0gYmluYXJ5IGluZml4IGZvcm1cbiAgICAgICAgICAgICAgICB0aGlzLmxocyA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yaHMgPSBhO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdiaW5hcnknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdG9yXG4gICAgICAgIHByZWZpeChcIntcIiwgb2JqZWN0UGFyc2VyKTtcblxuICAgICAgICAvLyBvYmplY3QgZ3JvdXBpbmdcbiAgICAgICAgaW5maXgoXCJ7XCIsIG9wZXJhdG9yc1sneyddLCBvYmplY3RQYXJzZXIpO1xuXG4gICAgICAgIC8vIGlmL3RoZW4vZWxzZSB0ZXJuYXJ5IG9wZXJhdG9yID86XG4gICAgICAgIGluZml4KFwiP1wiLCBvcGVyYXRvcnNbJz8nXSwgZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9ICdjb25kaXRpb24nO1xuICAgICAgICAgICAgdGhpcy5jb25kaXRpb24gPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy50aGVuID0gZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgIGlmIChub2RlLmlkID09PSAnOicpIHtcbiAgICAgICAgICAgICAgICAvLyBlbHNlIGNvbmRpdGlvblxuICAgICAgICAgICAgICAgIGFkdmFuY2UoXCI6XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZWxzZSA9IGV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gb2JqZWN0IHRyYW5zZm9ybWVyXG4gICAgICAgIHByZWZpeChcInxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ3RyYW5zZm9ybSc7XG4gICAgICAgICAgICB0aGlzLnBhdHRlcm4gPSBleHByZXNzaW9uKDApO1xuICAgICAgICAgICAgYWR2YW5jZSgnfCcpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUgPSBleHByZXNzaW9uKDApO1xuICAgICAgICAgICAgaWYobm9kZS5pZCA9PT0gJywnKSB7XG4gICAgICAgICAgICAgICAgYWR2YW5jZSgnLCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlID0gZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoJ3wnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB0YWlsIGNhbGwgb3B0aW1pemF0aW9uXG4gICAgICAgIC8vIHRoaXMgaXMgaW52b2tlZCBieSB0aGUgcG9zdCBwYXJzZXIgdG8gYW5hbHlzZSBsYW1iZGEgZnVuY3Rpb25zIHRvIHNlZVxuICAgICAgICAvLyBpZiB0aGV5IG1ha2UgYSB0YWlsIGNhbGwuICBJZiBzbywgaXQgaXMgcmVwbGFjZWQgYnkgYSB0aHVuayB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIGludm9rZWQgYnkgdGhlIHRyYW1wb2xpbmUgbG9vcCBkdXJpbmcgZnVuY3Rpb24gYXBwbGljYXRpb24uXG4gICAgICAgIC8vIFRoaXMgZW5hYmxlcyB0YWlsLXJlY3Vyc2l2ZSBmdW5jdGlvbnMgdG8gYmUgd3JpdHRlbiB3aXRob3V0IGdyb3dpbmcgdGhlIHN0YWNrXG4gICAgICAgIHZhciB0YWlsX2NhbGxfb3B0aW1pemUgPSBmdW5jdGlvbihleHByKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgaWYoZXhwci50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRodW5rID0ge3R5cGU6ICdsYW1iZGEnLCB0aHVuazogdHJ1ZSwgYXJndW1lbnRzOiBbXSwgcG9zaXRpb246IGV4cHIucG9zaXRpb259O1xuICAgICAgICAgICAgICAgIHRodW5rLmJvZHkgPSBleHByO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRodW5rO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGV4cHIudHlwZSA9PT0gJ2NvbmRpdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBhbmFseXNlIGJvdGggYnJhbmNoZXNcbiAgICAgICAgICAgICAgICBleHByLnRoZW4gPSB0YWlsX2NhbGxfb3B0aW1pemUoZXhwci50aGVuKTtcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgZXhwci5lbHNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBleHByLmVsc2UgPSB0YWlsX2NhbGxfb3B0aW1pemUoZXhwci5lbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXhwcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZihleHByLnR5cGUgPT09ICdibG9jaycpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHRoZSBsYXN0IGV4cHJlc3Npb24gaW4gdGhlIGJsb2NrXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGV4cHIuZXhwcmVzc2lvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwci5leHByZXNzaW9uc1tsZW5ndGggLSAxXSA9IHRhaWxfY2FsbF9vcHRpbWl6ZShleHByLmV4cHJlc3Npb25zW2xlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXhwcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXhwcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcG9zdC1wYXJzZSBzdGFnZVxuICAgICAgICAvLyB0aGUgcHVycG9zZSBvZiB0aGlzIGlzIGZsYXR0ZW4gdGhlIHBhcnRzIG9mIHRoZSBBU1QgcmVwcmVzZW50aW5nIGxvY2F0aW9uIHBhdGhzLFxuICAgICAgICAvLyBjb252ZXJ0aW5nIHRoZW0gdG8gYXJyYXlzIG9mIHN0ZXBzIHdoaWNoIGluIHR1cm4gbWF5IGNvbnRhaW4gYXJyYXlzIG9mIHByZWRpY2F0ZXMuXG4gICAgICAgIC8vIGZvbGxvd2luZyB0aGlzLCBub2RlcyBjb250YWluaW5nICcuJyBhbmQgJ1snIHNob3VsZCBiZSBlbGltaW5hdGVkIGZyb20gdGhlIEFTVC5cbiAgICAgICAgdmFyIGFzdF9vcHRpbWl6ZSA9IGZ1bmN0aW9uIChleHByKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cHIudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsc3RlcCA9IGFzdF9vcHRpbWl6ZShleHByLmxocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6ICdwYXRoJywgc3RlcHM6IFtdfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobHN0ZXAudHlwZSA9PT0gJ3BhdGgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlc3VsdC5zdGVwcywgbHN0ZXAuc3RlcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGVwcyA9IFtsc3RlcF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN0ID0gYXN0X29wdGltaXplKGV4cHIucmhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN0LnR5cGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3QucHJvY2VkdXJlLnR5cGUgPT09ICdwYXRoJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdC5wcm9jZWR1cmUuc3RlcHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0LnByb2NlZHVyZS5zdGVwc1swXS50eXBlID09PSAnbmFtZScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGVwc1tyZXN1bHQuc3RlcHMubGVuZ3RoLTFdLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBmdW5jdGlvbiBpbiBjaGFpbiBvZiBmdW5jdGlvbnMgLSB3aWxsIG92ZXJyaWRlIGEgdGhlbmFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0ZXBzW3Jlc3VsdC5zdGVwcy5sZW5ndGgtMV0ubmV4dEZ1bmN0aW9uID0gcmVzdC5wcm9jZWR1cmUuc3RlcHNbMF0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3QudHlwZSAhPT0gJ3BhdGgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3QgPSB7dHlwZTogJ3BhdGgnLCBzdGVwczogW3Jlc3RdfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocmVzdWx0LnN0ZXBzLCByZXN0LnN0ZXBzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbnkgc3RlcHMgd2l0aGluIGEgcGF0aCB0aGF0IGFyZSBsaXRlcmFscywgc2hvdWxkIGJlIGNoYW5nZWQgdG8gJ25hbWUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0ZXBzLmZpbHRlcihmdW5jdGlvbihzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGVwLnR5cGUgPT09ICdsaXRlcmFsJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGxpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXQudHlwZSA9ICduYW1lJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbnkgc3RlcCB0aGF0IHNpZ25hbHMga2VlcGluZyBhIHNpbmdsZXRvbiBhcnJheSwgc2hvdWxkIGJlIGZsYWdnZWQgb24gdGhlIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQuc3RlcHMuZmlsdGVyKGZ1bmN0aW9uKHN0ZXApIHsgcmV0dXJuIHN0ZXAua2VlcEFycmF5ID09PSB0cnVlO30pLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmtlZXBTaW5nbGV0b25BcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGZpcnN0IHN0ZXAgaXMgYSBwYXRoIGNvbnN0cnVjdG9yLCBmbGFnIGl0IGZvciBzcGVjaWFsIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0LnN0ZXBzWzBdLnR5cGUgPT09ICd1bmFyeScgJiYgcmVzdWx0LnN0ZXBzWzBdLnZhbHVlID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0ZXBzWzBdLmNvbnNhcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJlZGljYXRlZCBzdGVwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTEhTIGlzIGEgc3RlcCBvciBhIHByZWRpY2F0ZWQgc3RlcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJIUyBpcyB0aGUgcHJlZGljYXRlIGV4cHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhc3Rfb3B0aW1pemUoZXhwci5saHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGVwID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdC50eXBlID09PSAncGF0aCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcCA9IHJlc3VsdC5zdGVwc1tyZXN1bHQuc3RlcHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RlcC5ncm91cCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJTMDIwOVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0ZXAucHJlZGljYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwLnByZWRpY2F0ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwLnByZWRpY2F0ZS5wdXNoKGFzdF9vcHRpbWl6ZShleHByLnJocykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ3JvdXAtYnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMSFMgaXMgYSBzdGVwIG9yIGEgcHJlZGljYXRlZCBzdGVwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUkhTIGlzIHRoZSBvYmplY3QgY29uc3RydWN0b3IgZXhwclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFzdF9vcHRpbWl6ZShleHByLmxocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQuZ3JvdXAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAyMTBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdG9yIC0gcHJvY2VzcyBlYWNoIHBhaXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZ3JvdXAgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxoczogZXhwci5yaHMubWFwKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2FzdF9vcHRpbWl6ZShwYWlyWzBdKSwgYXN0X29wdGltaXplKHBhaXJbMV0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yZGVyLWJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTEhTIGlzIHRoZSBhcnJheSB0byBiZSBvcmRlcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUkhTIGRlZmluZXMgdGhlIHRlcm1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6ICdzb3J0JywgdmFsdWU6IGV4cHIudmFsdWUsIHBvc2l0aW9uOiBleHByLnBvc2l0aW9ufTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubGhzID0gYXN0X29wdGltaXplKGV4cHIubGhzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmhzID0gZXhwci5yaHMubWFwKGZ1bmN0aW9uICh0ZXJtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY2VuZGluZzogdGVybXMuZGVzY2VuZGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGFzdF9vcHRpbWl6ZSh0ZXJtcy5leHByZXNzaW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnOj0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt0eXBlOiAnYmluZCcsIHZhbHVlOiBleHByLnZhbHVlLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmxocyA9IGFzdF9vcHRpbWl6ZShleHByLmxocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJocyA9IGFzdF9vcHRpbWl6ZShleHByLnJocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd+Pic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6ICdhcHBseScsIHZhbHVlOiBleHByLnZhbHVlLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmxocyA9IGFzdF9vcHRpbWl6ZShleHByLmxocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJocyA9IGFzdF9vcHRpbWl6ZShleHByLnJocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt0eXBlOiBleHByLnR5cGUsIHZhbHVlOiBleHByLnZhbHVlLCBwb3NpdGlvbjogZXhwci5wb3NpdGlvbn07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmxocyA9IGFzdF9vcHRpbWl6ZShleHByLmxocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJocyA9IGFzdF9vcHRpbWl6ZShleHByLnJocyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndW5hcnknOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7dHlwZTogZXhwci50eXBlLCB2YWx1ZTogZXhwci52YWx1ZSwgcG9zaXRpb246IGV4cHIucG9zaXRpb259O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwci52YWx1ZSA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSBjb25zdHJ1Y3RvciAtIHByb2Nlc3MgZWFjaCBpdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXhwcmVzc2lvbnMgPSBleHByLmV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhc3Rfb3B0aW1pemUoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHByLnZhbHVlID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3RvciAtIHByb2Nlc3MgZWFjaCBwYWlyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubGhzID0gZXhwci5saHMubWFwKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthc3Rfb3B0aW1pemUocGFpclswXSksIGFzdF9vcHRpbWl6ZShwYWlyWzFdKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBvdGhlciB1bmFyeSBleHByZXNzaW9ucyAtIGp1c3QgcHJvY2VzcyB0aGUgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmV4cHJlc3Npb24gPSBhc3Rfb3B0aW1pemUoZXhwci5leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHVuYXJ5IG1pbnVzIG9uIGEgbnVtYmVyLCB0aGVuIHByZS1wcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwci52YWx1ZSA9PT0gJy0nICYmIHJlc3VsdC5leHByZXNzaW9uLnR5cGUgPT09ICdsaXRlcmFsJyAmJiBpc051bWVyaWMocmVzdWx0LmV4cHJlc3Npb24udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gLXJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgY2FzZSAncGFydGlhbCc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt0eXBlOiBleHByLnR5cGUsIG5hbWU6IGV4cHIubmFtZSwgdmFsdWU6IGV4cHIudmFsdWUsIHBvc2l0aW9uOiBleHByLnBvc2l0aW9ufTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFyZ3VtZW50cyA9IGV4cHIuYXJndW1lbnRzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXN0X29wdGltaXplKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHJvY2VkdXJlID0gYXN0X29wdGltaXplKGV4cHIucHJvY2VkdXJlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGFtYmRhJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6IGV4cHIudHlwZSwgYXJndW1lbnRzOiBleHByLmFyZ3VtZW50cywgc2lnbmF0dXJlOiBleHByLnNpZ25hdHVyZSwgcG9zaXRpb246IGV4cHIucG9zaXRpb259O1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keSA9IGFzdF9vcHRpbWl6ZShleHByLmJvZHkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYm9keSA9IHRhaWxfY2FsbF9vcHRpbWl6ZShib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29uZGl0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6IGV4cHIudHlwZSwgcG9zaXRpb246IGV4cHIucG9zaXRpb259O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY29uZGl0aW9uID0gYXN0X29wdGltaXplKGV4cHIuY29uZGl0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnRoZW4gPSBhc3Rfb3B0aW1pemUoZXhwci50aGVuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByLmVsc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZWxzZSA9IGFzdF9vcHRpbWl6ZShleHByLmVsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RyYW5zZm9ybSc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt0eXBlOiBleHByLnR5cGUsIHBvc2l0aW9uOiBleHByLnBvc2l0aW9ufTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBhdHRlcm4gPSBhc3Rfb3B0aW1pemUoZXhwci5wYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnVwZGF0ZSA9IGFzdF9vcHRpbWl6ZShleHByLnVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBleHByLmRlbGV0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kZWxldGUgPSBhc3Rfb3B0aW1pemUoZXhwci5kZWxldGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2NrJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6IGV4cHIudHlwZSwgcG9zaXRpb246IGV4cHIucG9zaXRpb259O1xuICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSBvZiBleHByZXNzaW9ucyAtIHByb2Nlc3MgZWFjaCBvbmVcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmV4cHJlc3Npb25zID0gZXhwci5leHByZXNzaW9ucy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhc3Rfb3B0aW1pemUoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHNjYW4gdGhlIGFycmF5IG9mIGV4cHJlc3Npb25zIHRvIHNlZSBpZiBhbnkgb2YgdGhlbSBhc3NpZ24gdmFyaWFibGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHNvLCBuZWVkIHRvIG1hcmsgdGhlIGJsb2NrIGFzIG9uZSB0aGF0IG5lZWRzIHRvIGNyZWF0ZSBhIG5ldyBmcmFtZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge3R5cGU6ICdwYXRoJywgc3RlcHM6IFtleHByXX07XG4gICAgICAgICAgICAgICAgICAgIGlmKGV4cHIua2VlcEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQua2VlcFNpbmdsZXRvbkFycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdsaXRlcmFsJzpcbiAgICAgICAgICAgICAgICBjYXNlICd3aWxkY2FyZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGVzY2VuZGFudCc6XG4gICAgICAgICAgICAgICAgY2FzZSAndmFyaWFibGUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlZ2V4JzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZXhwcjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnb3BlcmF0b3InOlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdG9rZW5zICdhbmQnIGFuZCAnb3InIG1pZ2h0IGhhdmUgYmVlbiB1c2VkIGFzIGEgbmFtZSByYXRoZXIgdGhhbiBhbiBvcGVyYXRvclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwci52YWx1ZSA9PT0gJ2FuZCcgfHwgZXhwci52YWx1ZSA9PT0gJ29yJyB8fCBleHByLnZhbHVlID09PSAnaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByLnR5cGUgPSAnbmFtZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhc3Rfb3B0aW1pemUoZXhwcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqLyBpZiAoZXhwci52YWx1ZSA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJ0aWFsIGFwcGxpY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBleHByO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiUzAyMDFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogZXhwci52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV4cHI7XG4gICAgICAgICAgICAgICAgICAgIGlmKGV4cHIubGhzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhc3Rfb3B0aW1pemUoZXhwci5saHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2RlID0gXCJTMDIwNlwiO1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwci5pZCA9PT0gJyhlbmQpJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IFwiUzAyMDdcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IGV4cHIudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYocmVjb3Zlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogJ2Vycm9yJywgZXJyb3I6IGVycn07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG5vdyBpbnZva2UgdGhlIHRva2VuaXplciBhbmQgdGhlIHBhcnNlciBhbmQgcmV0dXJuIHRoZSBzeW50YXggdHJlZVxuICAgICAgICBsZXhlciA9IHRva2VuaXplcihzb3VyY2UpO1xuICAgICAgICBhZHZhbmNlKCk7XG4gICAgICAgIC8vIHBhcnNlIHRoZSB0b2tlbnNcbiAgICAgICAgdmFyIGV4cHIgPSBleHByZXNzaW9uKDApO1xuICAgICAgICBpZiAobm9kZS5pZCAhPT0gJyhlbmQpJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlMwMjAxXCIsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IG5vZGUucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgdG9rZW46IG5vZGUudmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGV4cHIgPSBhc3Rfb3B0aW1pemUoZXhwcik7XG5cbiAgICAgICAgaWYoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGV4cHIuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfTtcblxuICAgIC8vIFN0YXJ0IG9mIEV2YWx1YXRvciBjb2RlXG5cbiAgICB2YXIgc3RhdGljRnJhbWUgPSBjcmVhdGVGcmFtZShudWxsKTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHZhbHVlIGlzIGEgZmluaXRlIG51bWJlclxuICAgICAqIEBwYXJhbSB7ZmxvYXR9IG4gLSBudW1iZXIgdG8gZXZhbHVhdGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBuIGlzIGEgZmluaXRlIG51bWJlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtZXJpYyhuKSB7XG4gICAgICAgIHZhciBpc051bSA9IGZhbHNlO1xuICAgICAgICBpZih0eXBlb2YgbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhciBudW0gPSBwYXJzZUZsb2F0KG4pO1xuICAgICAgICAgICAgaXNOdW0gPSAhaXNOYU4obnVtKTtcbiAgICAgICAgICAgIGlmIChpc051bSAmJiAhaXNGaW5pdGUobnVtKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJEMTAwMVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2tcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc051bTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFyZyBpcyBhbiBhcnJheSBvZiBzdHJpbmdzXG4gICAgICogQHBhcmFtIHsqfSBhcmcgLSB0aGUgaXRlbSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYXJnIGlzIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5T2ZTdHJpbmdzKGFyZykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gKGFyZy5maWx0ZXIoZnVuY3Rpb24oaXRlbSl7cmV0dXJuIHR5cGVvZiBpdGVtICE9PSAnc3RyaW5nJzt9KS5sZW5ndGggPT09IDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBhcmcgaXMgYW4gYXJyYXkgb2YgbnVtYmVyc1xuICAgICAqIEBwYXJhbSB7Kn0gYXJnIC0gdGhlIGl0ZW0gdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGFyZyBpcyBhbiBhcnJheSBvZiBudW1iZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheU9mTnVtYmVycyhhcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBpZihBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChhcmcuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pe3JldHVybiAhaXNOdW1lcmljKGl0ZW0pO30pLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBQb2x5ZmlsbFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgTnVtYmVyLmlzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICAgIGlzRmluaXRlKHZhbHVlKSAmJlxuICAgICAgICAgIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgZXhwcmVzc2lvbiBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIHZhciBlbnRyeUNhbGxiYWNrID0gZW52aXJvbm1lbnQubG9va3VwKCdfX2V2YWx1YXRlX2VudHJ5Jyk7XG4gICAgICAgIGlmKGVudHJ5Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIGVudHJ5Q2FsbGJhY2soZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdwYXRoJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlUGF0aChleHByLnN0ZXBzLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVNlcXVlbmNlKHJlc3VsdCwgZXhwci5rZWVwU2luZ2xldG9uQXJyYXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlQmluYXJ5KGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd1bmFyeSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZVVuYXJ5KGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZU5hbWUoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xpdGVyYWwnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlTGl0ZXJhbChleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2lsZGNhcmQnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlV2lsZGNhcmQoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Rlc2NlbmRhbnQnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlRGVzY2VuZGFudHMoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbmRpdGlvbic6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZUNvbmRpdGlvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2snOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVCbG9jayhleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmluZCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZUJpbmRFeHByZXNzaW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZWdleCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVSZWdleChleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVGdW5jdGlvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndmFyaWFibGUnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlVmFyaWFibGUoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xhbWJkYSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVMYW1iZGEoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3BhcnRpYWwnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVQYXJ0aWFsQXBwbGljYXRpb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FwcGx5JzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlQXBwbHlFeHByZXNzaW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzb3J0JzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlU29ydEV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RyYW5zZm9ybSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVUcmFuc2Zvcm1FeHByZXNzaW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZihlbnZpcm9ubWVudC5sb29rdXAoJ19fanNvbmF0YV9hc3luYycpICYmXG4gICAgICAgICAgKHR5cGVvZiByZXN1bHQgPT09ICd1bmRlZmluZWQnIHx8IHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0LnRoZW4gIT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZihlbnZpcm9ubWVudC5sb29rdXAoJ19fanNvbmF0YV9hc3luYycpICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJiBleHByLm5leHRGdW5jdGlvbiAmJiB0eXBlb2YgcmVzdWx0W2V4cHIubmV4dEZ1bmN0aW9uXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gYWx0aG91Z2ggdGhpcyBpcyBhICd0aGVuYWJsZScsIGl0IGlzIGNoYWluaW5nIGEgZGlmZmVyZW50IGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyBzbyBkb24ndCB5aWVsZCBzaW5jZSB5aWVsZGluZyB3aWxsIHRyaWdnZXIgdGhlIC50aGVuKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHJlc3VsdDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKGV4cHIuaGFzT3duUHJvcGVydHkoJ3ByZWRpY2F0ZScpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGFwcGx5UHJlZGljYXRlcyhleHByLnByZWRpY2F0ZSwgcmVzdWx0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICByZXN1bHQgPSBub3JtYWxpemVTZXF1ZW5jZShyZXN1bHQpO1xuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cHIuaGFzT3duUHJvcGVydHkoJ2dyb3VwJykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVHcm91cEV4cHJlc3Npb24oZXhwci5ncm91cCwgcmVzdWx0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhpdENhbGxiYWNrID0gZW52aXJvbm1lbnQubG9va3VwKCdfX2V2YWx1YXRlX2V4aXQnKTtcbiAgICAgICAgaWYoZXhpdENhbGxiYWNrKSB7XG4gICAgICAgICAgICBleGl0Q2FsbGJhY2soZXhwciwgaW5wdXQsIGVudmlyb25tZW50LCByZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBwYXRoIGV4cHJlc3Npb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBldmFsdWF0ZVBhdGgoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciBpbnB1dFNlcXVlbmNlO1xuICAgICAgICAvLyBleHByIGlzIGFuIGFycmF5IG9mIHN0ZXBzXG4gICAgICAgIC8vIGlmIHRoZSBmaXJzdCBzdGVwIGlzIGEgdmFyaWFibGUgcmVmZXJlbmNlICgkLi4uKSwgaW5jbHVkaW5nIHJvb3QgcmVmZXJlbmNlICgkJCksXG4gICAgICAgIC8vICAgdGhlbiB0aGUgcGF0aCBpcyBhYnNvbHV0ZSByYXRoZXIgdGhhbiByZWxhdGl2ZVxuICAgICAgICBpZiAoZXhwclswXS50eXBlID09PSAndmFyaWFibGUnKSB7XG4gICAgICAgICAgICBpbnB1dFNlcXVlbmNlID0gW2lucHV0XTsgLy8gZHVtbXkgc2luZ2xldG9uIHNlcXVlbmNlIGZvciBmaXJzdCAoYWJzb2x1dGUpIHN0ZXBcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgaW5wdXRTZXF1ZW5jZSA9IGlucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgaW5wdXQgaXMgbm90IGFuIGFycmF5LCBtYWtlIGl0IHNvXG4gICAgICAgICAgICBpbnB1dFNlcXVlbmNlID0gW2lucHV0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHRTZXF1ZW5jZTtcblxuICAgICAgICAvLyBldmFsdWF0ZSBlYWNoIHN0ZXAgaW4gdHVyblxuICAgICAgICBmb3IodmFyIGlpID0gMDsgaWkgPCBleHByLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSBleHByW2lpXTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIGZpcnN0IHN0ZXAgaXMgYW4gZXhwbGljaXQgYXJyYXkgY29uc3RydWN0b3IsIHRoZW4ganVzdCBldmFsdWF0ZSB0aGF0IChpLmUuIGRvbid0IGl0ZXJhdGUgb3ZlciBhIGNvbnRleHQgYXJyYXkpXG4gICAgICAgICAgICBpZihpaSA9PT0gMCAmJiBzdGVwLmNvbnNhcnJheSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFNlcXVlbmNlID0geWllbGQgKiBldmFsdWF0ZShzdGVwLCBpbnB1dFNlcXVlbmNlLCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFNlcXVlbmNlID0geWllbGQgKiBldmFsdWF0ZVN0ZXAoc3RlcCwgaW5wdXRTZXF1ZW5jZSwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0eXBlb2YgcmVzdWx0U2VxdWVuY2UgPT09ICd1bmRlZmluZWQnIHx8IHJlc3VsdFNlcXVlbmNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRTZXF1ZW5jZSA9IHJlc3VsdFNlcXVlbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFNlcXVlbmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBhIEpTT05hdGEgc2VxdWVuY2UgLSBzaW5nbGV0b24gYXJyYXlzIGJlY29tZSBhdG9taWMgdmFsdWVzXG4gICAgICogQHBhcmFtIHtBcnJheX0gc2VxdWVuY2UgLSBpbnB1dCBzZXF1ZW5jZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0ga2VlcFNpbmdsZXRvbiAtIGtlZXAgc2luZ2xldG9uIHNlcXVlbmNlcyBhcyBhcnJheXNcbiAgICAgKiBAcmV0dXJucyB7Kn0gbm9ybWFsaXplZCBzZXF1ZW5jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVNlcXVlbmNlKHNlcXVlbmNlLCBrZWVwU2luZ2xldG9uKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmKHR5cGVvZiBzZXF1ZW5jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmKCFBcnJheS5pc0FycmF5KHNlcXVlbmNlKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc2VxdWVuY2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VxdWVuY2UubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZihrZWVwU2luZ2xldG9uKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VxdWVuY2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNlcXVlbmNlWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNlcXVlbmNlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNlcXVlbmNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgYSBzdGVwIHdpdGhpbiBhIHBhdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlU3RlcChleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG5cbiAgICAgICAgZm9yKHZhciBpaSA9IDA7IGlpIDwgaW5wdXQubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0geWllbGQgKiBldmFsdWF0ZShleHByLCBpbnB1dFtpaV0sIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgIGlmICghKEFycmF5LmlzQXJyYXkocmVzKSAmJiAoZXhwci52YWx1ZSAhPT0gJ1snICkpICYmICFleHByLmNvbnNhcnJheSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IFtyZXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaXMgcmVzIGFuIGFycmF5IC0gaWYgc28sIGZsYXR0ZW4gaXQgaW50byB0aGUgcGFyZW50IGFycmF5XG4gICAgICAgICAgICByZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5uZXJSZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlubmVyUmVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbm5lclJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBwcmVkaWNhdGVzIHRvIGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJlZGljYXRlcyAtIFByZWRpY2F0ZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGFwcGx5IHByZWRpY2F0ZXMgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IFJlc3VsdCBhZnRlciBhcHBseWluZyBwcmVkaWNhdGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGFwcGx5UHJlZGljYXRlcyhwcmVkaWNhdGVzLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIGlucHV0U2VxdWVuY2UgPSBpbnB1dDtcbiAgICAgICAgLy8gbGhzIHBvdGVudGlhbGx5IGhvbGRzIGFuIGFycmF5XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gaXRlcmF0ZSBvdmVyIHRoZSBhcnJheSwgYW5kIG9ubHkga2VlcCB0aGUgaXRlbXMgdGhhdCBhcmVcbiAgICAgICAgLy8gdHJ1dGh5IHdoZW4gYXBwbGllZCB0byB0aGUgcHJlZGljYXRlLlxuICAgICAgICAvLyBpZiB0aGUgcHJlZGljYXRlIGV2YWx1YXRlcyB0byBhbiBpbnRlZ2VyLCB0aGVuIHNlbGVjdCB0aGF0IGluZGV4XG5cbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yKHZhciBpaSA9IDA7IGlpIDwgcHJlZGljYXRlcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgIHZhciBwcmVkaWNhdGUgPSBwcmVkaWNhdGVzW2lpXTtcbiAgICAgICAgICAgIC8vIGlmIGl0J3Mgbm90IGFuIGFycmF5LCB0dXJuIGl0IGludG8gb25lXG4gICAgICAgICAgICAvLyBzaW5jZSBpbiBYUGF0aCA+PSAyLjAgYW4gaXRlbSBpcyBlcXVpdmFsZW50IHRvIGEgc2luZ2xldG9uIHNlcXVlbmNlIG9mIHRoYXQgaXRlbVxuICAgICAgICAgICAgLy8gaWYgaW5wdXQgaXMgbm90IGFuIGFycmF5LCBtYWtlIGl0IHNvXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXRTZXF1ZW5jZSkpIHtcbiAgICAgICAgICAgICAgICBpbnB1dFNlcXVlbmNlID0gW2lucHV0U2VxdWVuY2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZS50eXBlID09PSAnbGl0ZXJhbCcgJiYgaXNOdW1lcmljKHByZWRpY2F0ZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwcmVkaWNhdGUudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByb3VuZCBpdCBkb3duXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcihpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY291bnQgaW4gZnJvbSBlbmQgb2YgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpbnB1dFNlcXVlbmNlLmxlbmd0aCArIGluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzID0gaW5wdXRTZXF1ZW5jZVtpbmRleF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSB5aWVsZCAqIGV2YWx1YXRlRmlsdGVyKHByZWRpY2F0ZSwgaW5wdXRTZXF1ZW5jZSwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRTZXF1ZW5jZSA9IHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgZmlsdGVyIHByZWRpY2F0ZSB0byBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByZWRpY2F0ZSAtIGZpbHRlciBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBhcHBseSBwcmVkaWNhdGVzIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBSZXN1bHQgYWZ0ZXIgYXBwbHlpbmcgcHJlZGljYXRlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBldmFsdWF0ZUZpbHRlcihwcmVkaWNhdGUsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IodmFyIGluZGV4ID0gMDsgaW5kZXggPCBpbnB1dC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gaW5wdXRbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIHJlcyA9IHlpZWxkICogZXZhbHVhdGUocHJlZGljYXRlLCBpdGVtLCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICBpZiAoaXNOdW1lcmljKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBbcmVzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGlzQXJyYXlPZk51bWJlcnMocmVzKSkge1xuICAgICAgICAgICAgICAgIHJlcy5mb3JFYWNoKGZ1bmN0aW9uKGlyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGlyZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByb3VuZCBpdCBkb3duXG4gICAgICAgICAgICAgICAgICAgICAgICBpcmVzID0gTWF0aC5mbG9vcihpcmVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXJlcyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvdW50IGluIGZyb20gZW5kIG9mIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICBpcmVzID0gaW5wdXQubGVuZ3RoICsgaXJlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXJlcyA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmdW5jdGlvbkJvb2xlYW4ocmVzKSkgeyAvLyB0cnV0aHlcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgYmluYXJ5IGV4cHJlc3Npb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICogZXZhbHVhdGVCaW5hcnkoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBsaHMgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIubGhzLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICB2YXIgcmhzID0geWllbGQgKiBldmFsdWF0ZShleHByLnJocywgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgdmFyIG9wID0gZXhwci52YWx1ZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZU51bWVyaWNFeHByZXNzaW9uKGxocywgcmhzLCBvcCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZUNvbXBhcmlzb25FeHByZXNzaW9uKGxocywgcmhzLCBvcCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZVN0cmluZ0NvbmNhdChsaHMsIHJocyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FuZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnb3InOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBldmFsdWF0ZUJvb2xlYW5FeHByZXNzaW9uKGxocywgcmhzLCBvcCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJy4uJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZhbHVhdGVSYW5nZUV4cHJlc3Npb24obGhzLCByaHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdpbic6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2YWx1YXRlSW5jbHVkZXNFeHByZXNzaW9uKGxocywgcmhzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICBlcnIucG9zaXRpb24gPSBleHByLnBvc2l0aW9uO1xuICAgICAgICAgICAgZXJyLnRva2VuID0gb3A7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSB1bmFyeSBleHByZXNzaW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVVbmFyeShleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBzd2l0Y2ggKGV4cHIudmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5leHByZXNzaW9uLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChpc051bWVyaWMocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAtcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiRDEwMDJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogZXhwci52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICAvLyBhcnJheSBjb25zdHJ1Y3RvciAtIGV2YWx1YXRlIGVhY2ggaXRlbVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaWkgPSAwOyBpaSA8IGV4cHIuZXhwcmVzc2lvbnMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZXhwci5leHByZXNzaW9uc1tpaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHlpZWxkICogZXZhbHVhdGUoaXRlbSwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0udmFsdWUgPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuY3Rpb25BcHBlbmQocmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0b3IgLSBhcHBseSBncm91cGluZ1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGVHcm91cEV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgbmFtZSBvYmplY3QgYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBkYXRhIHRvIGV2YWx1YXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52aXJvbm1lbnQgLSBFbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlTmFtZShleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgLy8gbG9va3VwIHRoZSAnbmFtZScgaXRlbSBpbiB0aGUgaW5wdXRcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvcih2YXIgaWkgPSAwOyBpaSA8IGlucHV0Lmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSAgZXZhbHVhdGVOYW1lKGV4cHIsIGlucHV0W2lpXSwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChyZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCAhPT0gbnVsbCAmJiB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpbnB1dFtleHByLnZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBub3JtYWxpemVTZXF1ZW5jZShyZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGxpdGVyYWwgYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmFsdWF0ZUxpdGVyYWwoZXhwcikge1xuICAgICAgICByZXR1cm4gZXhwci52YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSB3aWxkY2FyZCBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlV2lsZGNhcmQoZXhwciwgaW5wdXQpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgaWYgKGlucHV0ICE9PSBudWxsICYmIHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGlucHV0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZmxhdHRlbih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBmdW5jdGlvbkFwcGVuZChyZXN1bHRzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVNlcXVlbmNlKHJlc3VsdHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmbGF0dGVuZWQgYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmcgLSB0aGUgYXJyYXkgdG8gYmUgZmxhdHRlblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZsYXR0ZW5lZCAtIGNhcnJpZXMgdGhlIGZsYXR0ZW5lZCBhcnJheSAtIGlmIG5vdCBkZWZpbmVkLCB3aWxsIGluaXRpYWxpemUgdG8gW11cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IC0gdGhlIGZsYXR0ZW5lZCBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJnLCBmbGF0dGVuZWQpIHtcbiAgICAgICAgaWYodHlwZW9mIGZsYXR0ZW5lZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGZsYXR0ZW5lZCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgYXJnLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBmbGF0dGVuKGl0ZW0sIGZsYXR0ZW5lZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZsYXR0ZW5lZC5wdXNoKGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBkZXNjZW5kYW50cyBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlRGVzY2VuZGFudHMoZXhwciwgaW5wdXQpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHJlc3VsdFNlcXVlbmNlID0gW107XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyB0cmF2ZXJzZSBhbGwgZGVzY2VuZGFudHMgb2YgdGhpcyBvYmplY3QvYXJyYXlcbiAgICAgICAgICAgIHJlY3Vyc2VEZXNjZW5kYW50cyhpbnB1dCwgcmVzdWx0U2VxdWVuY2UpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdFNlcXVlbmNlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFNlcXVlbmNlWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRTZXF1ZW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2UgdGhyb3VnaCBkZXNjZW5kYW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0cyAtIFJlc3VsdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWN1cnNlRGVzY2VuZGFudHMoaW5wdXQsIHJlc3VsdHMpIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiAvLyogaW4gWFBhdGhcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGlucHV0LmZvckVhY2goZnVuY3Rpb24gKG1lbWJlcikge1xuICAgICAgICAgICAgICAgIHJlY3Vyc2VEZXNjZW5kYW50cyhtZW1iZXIsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQgIT09IG51bGwgJiYgdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoaW5wdXQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJlY3Vyc2VEZXNjZW5kYW50cyhpbnB1dFtrZXldLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgbnVtZXJpYyBleHByZXNzaW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsaHMgLSBMSFMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmhzIC0gUkhTIHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wIC0gb3Bjb2RlXG4gICAgICogQHJldHVybnMgeyp9IFJlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlTnVtZXJpY0V4cHJlc3Npb24obGhzLCByaHMsIG9wKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiByaHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBpZiBlaXRoZXIgc2lkZSBpcyB1bmRlZmluZWQsIHRoZSByZXN1bHQgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bWVyaWMobGhzKSkge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMDFcIixcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGhzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNOdW1lcmljKHJocykpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlQyMDAyXCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJoc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyArIHJocztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyAtIHJocztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyAqIHJocztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyAvIHJocztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxocyAlIHJocztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGNvbXBhcmlzb24gZXhwcmVzc2lvbiBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGhzIC0gTEhTIHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJocyAtIFJIUyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcCAtIG9wY29kZVxuICAgICAqIEByZXR1cm5zIHsqfSBSZXN1bHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmFsdWF0ZUNvbXBhcmlzb25FeHByZXNzaW9uKGxocywgcmhzLCBvcCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIHR5cGUgY2hlY2tzXG4gICAgICAgIHZhciBsdHlwZSA9IHR5cGVvZiBsaHM7XG4gICAgICAgIHZhciBydHlwZSA9IHR5cGVvZiByaHM7XG5cbiAgICAgICAgaWYgKGx0eXBlID09PSAndW5kZWZpbmVkJyB8fCBydHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIGlmIGVpdGhlciBzaWRlIGlzIHVuZGVmaW5lZCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBpZiBhYSBvciBiYiBhcmUgbm90IHN0cmluZyBvciBudW1lcmljIHZhbHVlcywgdGhlbiB0aHJvdyBhbiBlcnJvclxuICAgICAgICAgICAgaWYgKCEobHR5cGUgPT09ICdzdHJpbmcnIHx8IGx0eXBlID09PSAnbnVtYmVyJykgfHwgIShydHlwZSA9PT0gJ3N0cmluZycgfHwgcnR5cGUgPT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJUMjAxMFwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEobHR5cGUgPT09ICdzdHJpbmcnIHx8IGx0eXBlID09PSAnbnVtYmVyJykgPyBsaHMgOiByaHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2lmIGFhIGFuZCBiYiBhcmUgbm90IG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgICAgICAgIGlmIChsdHlwZSAhPT0gcnR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMDlcIixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBsaHMsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlMjogcmhzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgICAgICBjYXNlICc9JzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsaHMgPT09IHJocztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAobGhzICE9PSByaHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsaHMgPCByaHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsaHMgPD0gcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsaHMgPiByaHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsaHMgPj0gcmhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5jbHVzaW9uIG9wZXJhdG9yIC0gaW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsaHMgLSBMSFMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmhzIC0gUkhTIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSBpZiBsaHMgaXMgYSBtZW1iZXIgb2YgcmhzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVJbmNsdWRlc0V4cHJlc3Npb24obGhzLCByaHMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgcmhzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gaWYgZWl0aGVyIHNpZGUgaXMgdW5kZWZpbmVkLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZighQXJyYXkuaXNBcnJheShyaHMpKSB7XG4gICAgICAgICAgICByaHMgPSBbcmhzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCByaHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmKHJoc1tpXSA9PT0gbGhzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgYm9vbGVhbiBleHByZXNzaW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsaHMgLSBMSFMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmhzIC0gUkhTIHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wIC0gb3Bjb2RlXG4gICAgICogQHJldHVybnMgeyp9IFJlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlQm9vbGVhbkV4cHJlc3Npb24obGhzLCByaHMsIG9wKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICAgICAgY2FzZSAnYW5kJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jdGlvbkJvb2xlYW4obGhzKSAmJiBmdW5jdGlvbkJvb2xlYW4ocmhzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ29yJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jdGlvbkJvb2xlYW4obGhzKSB8fCBmdW5jdGlvbkJvb2xlYW4ocmhzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHN0cmluZyBjb25jYXRlbmF0aW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsaHMgLSBMSFMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmhzIC0gUkhTIHZhbHVlXG4gICAgICogQHJldHVybnMge3N0cmluZ3wqfSBDb25jYXRlbmF0ZWQgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVTdHJpbmdDb25jYXQobGhzLCByaHMpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICB2YXIgbHN0ciA9ICcnO1xuICAgICAgICB2YXIgcnN0ciA9ICcnO1xuICAgICAgICBpZiAodHlwZW9mIGxocyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxzdHIgPSBmdW5jdGlvblN0cmluZyhsaHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmhzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcnN0ciA9IGZ1bmN0aW9uU3RyaW5nKHJocyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBsc3RyLmNvbmNhdChyc3RyKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBncm91cCBleHByZXNzaW9uIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7e319IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlR3JvdXBFeHByZXNzaW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHZhciBncm91cHMgPSB7fTtcbiAgICAgICAgLy8gZ3JvdXAgdGhlIGlucHV0IHNlcXVlbmNlIGJ5ICdrZXknIGV4cHJlc3Npb25cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgaW5wdXQgPSBbaW5wdXRdO1xuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgaXRlbUluZGV4ID0gMDsgaXRlbUluZGV4IDwgaW5wdXQubGVuZ3RoOyBpdGVtSW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpbnB1dFtpdGVtSW5kZXhdO1xuICAgICAgICAgICAgZm9yKHZhciBwYWlySW5kZXggPSAwOyBwYWlySW5kZXggPCBleHByLmxocy5sZW5ndGg7IHBhaXJJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhaXIgPSBleHByLmxoc1twYWlySW5kZXhdO1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSB5aWVsZCAqIGV2YWx1YXRlKHBhaXJbMF0sIGl0ZW0sIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICAvLyBrZXkgaGFzIHRvIGJlIGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQxMDAzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGtleVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB7ZGF0YTogaXRlbSwgZXhwcjogcGFpclsxXX07XG4gICAgICAgICAgICAgICAgaWYgKGdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgdmFsdWUgYWxyZWFkeSBleGlzdHMgaW4gdGhpcyBzbG90XG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBpdCBhcyBhbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICBncm91cHNba2V5XS5kYXRhID0gZnVuY3Rpb25BcHBlbmQoZ3JvdXBzW2tleV0uZGF0YSwgaXRlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzW2tleV0gPSBlbnRyeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpdGVyYXRlIG92ZXIgdGhlIGdyb3VwcyB0byBldmFsdWF0ZSB0aGUgJ3ZhbHVlJyBleHByZXNzaW9uXG4gICAgICAgIGZvciAoa2V5IGluIGdyb3Vwcykge1xuICAgICAgICAgICAgZW50cnkgPSBncm91cHNba2V5XTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHlpZWxkICogZXZhbHVhdGUoZW50cnkuZXhwciwgZW50cnkuZGF0YSwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgaWYodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHJhbmdlIGV4cHJlc3Npb24gYWdhaW5zdCBpbnB1dCBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxocyAtIExIUyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByaHMgLSBSSFMgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJlc3VsdGFudCBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlUmFuZ2VFeHByZXNzaW9uKGxocywgcmhzKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiByaHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBpZiBlaXRoZXIgc2lkZSBpcyB1bmRlZmluZWQsIHRoZSByZXN1bHQgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxocyA+IHJocykge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGxocyBpcyBncmVhdGVyIHRoYW4gdGhlIHJocywgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihsaHMpKSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgY29kZTogXCJUMjAwM1wiLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBsaHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHJocykpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlQyMDA0XCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJoc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShyaHMgLSBsaHMgKyAxKTtcbiAgICAgICAgZm9yICh2YXIgaXRlbSA9IGxocywgaW5kZXggPSAwOyBpdGVtIDw9IHJoczsgaXRlbSsrLCBpbmRleCsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGJpbmQgZXhwcmVzc2lvbiBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlQmluZEV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIC8vIFRoZSBSSFMgaXMgdGhlIGV4cHJlc3Npb24gdG8gZXZhbHVhdGVcbiAgICAgICAgLy8gVGhlIExIUyBpcyB0aGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgdG8gYmluZCB0byAtIHNob3VsZCBiZSBhIFZBUklBQkxFIHRva2VuXG4gICAgICAgIHZhciB2YWx1ZSA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5yaHMsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgIGlmIChleHByLmxocy50eXBlICE9PSAndmFyaWFibGUnKSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgY29kZTogXCJEMjAwNVwiLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHRva2VuOiBleHByLnZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBleHByLmxocy50eXBlID09PSAncGF0aCcgPyBleHByLmxocy5zdGVwc1swXS52YWx1ZSA6IGV4cHIubGhzLnZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVudmlyb25tZW50LmJpbmQoZXhwci5saHMudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGNvbmRpdGlvbiBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlQ29uZGl0aW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgY29uZGl0aW9uID0geWllbGQgKiBldmFsdWF0ZShleHByLmNvbmRpdGlvbiwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgaWYgKGZ1bmN0aW9uQm9vbGVhbihjb25kaXRpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIudGhlbiwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwci5lbHNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBldmFsdWF0ZShleHByLmVsc2UsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBibG9jayBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlQmxvY2soZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBmcmFtZSB0byBsaW1pdCB0aGUgc2NvcGUgb2YgdmFyaWFibGUgYXNzaWdubWVudHNcbiAgICAgICAgLy8gVE9ETywgb25seSBkbyB0aGlzIGlmIHRoZSBwb3N0LXBhcnNlIHN0YWdlIGhhcyBmbGFnZ2VkIHRoaXMgYXMgcmVxdWlyZWRcbiAgICAgICAgdmFyIGZyYW1lID0gY3JlYXRlRnJhbWUoZW52aXJvbm1lbnQpO1xuICAgICAgICAvLyBpbnZva2UgZWFjaCBleHByZXNzaW9uIGluIHR1cm5cbiAgICAgICAgLy8gb25seSByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBvbmVcbiAgICAgICAgZm9yKHZhciBpaSA9IDA7IGlpIDwgZXhwci5leHByZXNzaW9ucy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogZXZhbHVhdGUoZXhwci5leHByZXNzaW9uc1tpaV0sIGlucHV0LCBmcmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgYSByZWdleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gZXhwcmVzc2lvbiBjb250YWluaW5nIHJlZ2V4XG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBIaWdoZXIgb3JkZXIgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHByZXBhcmVkIHJlZ2V4XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVSZWdleChleHByKSB7XG4gICAgICAgIGV4cHIudmFsdWUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIGNsb3N1cmUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHZhciByZSA9IGV4cHIudmFsdWU7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gcmUuZXhlYyhzdHIpO1xuICAgICAgICAgICAgaWYobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoOiBtYXRjaFswXSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG1hdGNoLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBncm91cHM6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZihtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBtYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmdyb3Vwcy5wdXNoKG1hdGNoW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZihyZS5sYXN0SW5kZXggPj0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gY2xvc3VyZShzdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobmV4dCAmJiBuZXh0Lm1hdGNoID09PSAnJyAmJiByZS5sYXN0SW5kZXggPT09IGV4cHIudmFsdWUubGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hlcyB6ZXJvIGxlbmd0aCBzdHJpbmc7IHRoaXMgd2lsbCBuZXZlciBwcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJEMTAwNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBleHByLnZhbHVlLnNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbG9zdXJlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHZhcmlhYmxlIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmFsdWF0ZVZhcmlhYmxlKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICAvLyBsb29rdXAgdGhlIHZhcmlhYmxlIHZhbHVlIGluIHRoZSBlbnZpcm9ubWVudFxuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAvLyBpZiB0aGUgdmFyaWFibGUgbmFtZSBpcyBlbXB0eSBzdHJpbmcsIHRoZW4gaXQgcmVmZXJzIHRvIGNvbnRleHQgdmFsdWVcbiAgICAgICAgaWYgKGV4cHIudmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGVudmlyb25tZW50Lmxvb2t1cChleHByLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNvcnQgLyBvcmRlci1ieSBvcGVyYXRvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gQVNUIGZvciBvcGVyYXRvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IE9yZGVyZWQgc2VxdWVuY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVTb3J0RXhwcmVzc2lvbihleHByLCBpbnB1dCwgZW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyBldmFsdWF0ZSB0aGUgbGhzLCB0aGVuIHNvcnQgdGhlIHJlc3VsdHMgaW4gb3JkZXIgYWNjb3JkaW5nIHRvIHJocyBleHByZXNzaW9uXG4gICAgICAgIHZhciBsaHMgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIubGhzLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuXG4gICAgICAgIC8vIHNvcnQgdGhlIGxocyBhcnJheVxuICAgICAgICAvLyB1c2UgY29tcGFyYXRvciBmdW5jdGlvblxuICAgICAgICB2YXIgY29tcGFyYXRvciA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIC8vIGV4cHIucmhzIGlzIGFuIGFycmF5IG9mIG9yZGVyLWJ5IGluIHByaW9yaXR5IG9yZGVyXG4gICAgICAgICAgICB2YXIgY29tcCA9IDA7XG4gICAgICAgICAgICBmb3IodmFyIGluZGV4ID0gMDsgY29tcCA9PT0gMCAmJiBpbmRleCA8IGV4cHIucmhzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHZhciB0ZXJtID0gZXhwci5yaHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIC8vZXZhbHVhdGUgdGhlIHJocyBleHByZXNzaW9uIGluIHRoZSBjb250ZXh0IG9mIGFcbiAgICAgICAgICAgICAgICB2YXIgYWEgPSBkcml2ZUdlbmVyYXRvcih0ZXJtLmV4cHJlc3Npb24sIGEsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICAvL2V2YWx1YXRlIHRoZSByaHMgZXhwcmVzc2lvbiBpbiB0aGUgY29udGV4dCBvZiBiXG4gICAgICAgICAgICAgICAgdmFyIGJiID0gZHJpdmVHZW5lcmF0b3IodGVybS5leHByZXNzaW9uLCBiLCBlbnZpcm9ubWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyB0eXBlIGNoZWNrc1xuICAgICAgICAgICAgICAgIHZhciBhdHlwZSA9IHR5cGVvZiBhYTtcbiAgICAgICAgICAgICAgICB2YXIgYnR5cGUgPSB0eXBlb2YgYmI7XG4gICAgICAgICAgICAgICAgLy8gdW5kZWZpbmVkIHNob3VsZCBiZSBsYXN0IGluIHNvcnQgb3JkZXJcbiAgICAgICAgICAgICAgICBpZihhdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3dhcCB0aGVtLCB1bmxlc3MgYnR5cGUgaXMgYWxzbyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgY29tcCA9IChidHlwZSA9PT0gJ3VuZGVmaW5lZCcpID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihidHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBhYSBvciBiYiBhcmUgbm90IHN0cmluZyBvciBudW1lcmljIHZhbHVlcywgdGhlbiB0aHJvdyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIGlmKCEoYXR5cGUgPT09ICdzdHJpbmcnIHx8IGF0eXBlID09PSAnbnVtYmVyJykgfHwgIShidHlwZSA9PT0gJ3N0cmluZycgfHwgYnR5cGUgPT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQyMDA4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICEoYXR5cGUgPT09ICdzdHJpbmcnIHx8IGF0eXBlID09PSAnbnVtYmVyJykgPyBhYSA6IGJiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9pZiBhYSBhbmQgYmIgYXJlIG5vdCBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAgICAgICAgICAgaWYoYXR5cGUgIT09IGJ0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMDdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYWEsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTI6IGJiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGFhID09PSBiYikge1xuICAgICAgICAgICAgICAgICAgICAvLyBib3RoIHRoZSBzYW1lIC0gbW92ZSBvbiB0byBuZXh0IHRlcm1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhYSA8IGJiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXAgPSAtMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21wID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYodGVybS5kZXNjZW5kaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXAgPSAtY29tcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvbmx5IHN3YXAgYSAmIGIgaWYgY29tcCBlcXVhbHMgMVxuICAgICAgICAgICAgcmV0dXJuIGNvbXAgPT09IDE7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVzdWx0ID0gZnVuY3Rpb25Tb3J0KGxocywgY29tcGFyYXRvcik7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgYSB0cmFuc2Zvcm1lciBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gQVNUIGZvciBvcGVyYXRvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IHRyYW5mb3JtZXIgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmFsdWF0ZVRyYW5zZm9ybUV4cHJlc3Npb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIGZ1bmN0aW9uIHRvIGltcGxlbWVudCB0aGUgdHJhbnNmb3JtIGRlZmluaXRpb25cbiAgICAgICAgdmFyIHRyYW5zZm9ybWVyID0gZnVuY3Rpb24qKG9iaikgeyAvLyBzaWduYXR1cmUgPChvYSk6bz5cbiAgICAgICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgY29weSBvZiBvYmogd2l0aCBjaGFuZ2VzIHNwZWNpZmllZCBieSB0aGUgcGF0dGVybi9vcGVyYXRpb25cbiAgICAgICAgICAgIHZhciBjbG9uZUZ1bmN0aW9uID0gZW52aXJvbm1lbnQubG9va3VwKCdjbG9uZScpO1xuICAgICAgICAgICAgaWYoIWlzRnVuY3Rpb24oY2xvbmVGdW5jdGlvbikpIHtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyB0eXBlIGVycm9yXG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQyMDEzXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXhwci5wb3NpdGlvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0geWllbGQgKiBhcHBseShjbG9uZUZ1bmN0aW9uLCBbb2JqXSwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIucGF0dGVybiwgcmVzdWx0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICBpZih0eXBlb2YgbWF0Y2hlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBpZighQXJyYXkuaXNBcnJheShtYXRjaGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gW21hdGNoZXNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IodmFyIGlpID0gMDsgaWkgPCBtYXRjaGVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBtYXRjaGVzW2lpXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZhbHVhdGUgdGhlIHVwZGF0ZSB2YWx1ZSBmb3IgZWFjaCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlID0geWllbGQgKiBldmFsdWF0ZShleHByLnVwZGF0ZSwgbWF0Y2gsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIG11c3QgYmUgYW4gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVUeXBlID0gdHlwZW9mIHVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYodXBkYXRlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHVwZGF0ZVR5cGUgIT09ICdvYmplY3QnIHx8IHVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRocm93IHR5cGUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiVDIwMTFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnVwZGF0ZS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVwZGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSB0aGUgdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHByb3AgaW4gdXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbcHJvcF0gPSB1cGRhdGVbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUsIGlmIHNwZWNpZmllZCwgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzIChvciBzaW5nbGUgc3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgZXhwci5kZWxldGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsZXRpb25zID0geWllbGQgKiBldmFsdWF0ZShleHByLmRlbGV0ZSwgbWF0Y2gsIGVudmlyb25tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBkZWxldGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGRlbGV0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGVsZXRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGlvbnMgPSBbZGVsZXRpb25zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5T2ZTdHJpbmdzKGRlbGV0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgdHlwZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlQyMDEyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLmRlbGV0ZS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgamogPSAwOyBqaiA8IGRlbGV0aW9ucy5sZW5ndGg7IGpqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1hdGNoW2RlbGV0aW9uc1tqal1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZGVmaW5lRnVuY3Rpb24odHJhbnNmb3JtZXIsICc8KG9hKTpvPicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGFuIGV4cHJlc3Npb24gYnkgZHJpdmluZyB0aGUgZ2VuZXJhdG9yIHRvIGNvbXBsZXRpb25cbiAgICAgKiBVc2VkIHdoZW4gaXQncyBub3QgcG9zc2libGUgdG8geWllbGRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEFTVFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IHJlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyaXZlR2VuZXJhdG9yKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgZ2VuID0gZXZhbHVhdGUoZXhwciwgaW5wdXQsIGVudmlyb25tZW50KTtcbiAgICAgICAgLy8gcmV0dXJucyBhIGdlbmVyYXRvciAtIHNvIGl0ZXJhdGUgb3ZlciBpdFxuICAgICAgICB2YXIgY29tcCA9IGdlbi5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghY29tcC5kb25lKSB7XG4gICAgICAgICAgICBjb21wID0gZ2VuLm5leHQoY29tcC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXAudmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGNoYWluID0gZHJpdmVHZW5lcmF0b3IocGFyc2VyKCdmdW5jdGlvbigkZiwgJGcpIHsgZnVuY3Rpb24oJHgpeyAkZygkZigkeCkpIH0gfScpLCBudWxsLCBzdGF0aWNGcmFtZSk7XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgZnVuY3Rpb24gb24gdGhlIFJIUyB1c2luZyB0aGUgc2VxdWVuY2Ugb24gdGhlIExIUyBhcyB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHJldHVybnMgeyp9IEV2YWx1YXRlZCBpbnB1dCBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24qIGV2YWx1YXRlQXBwbHlFeHByZXNzaW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG5cbiAgICAgICAgaWYoZXhwci5yaHMudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIGZ1bmN0aW9uIF9pbnZvY2F0aW9uXzsgaW52b2tlIGl0IHdpdGggbGhzIGV4cHJlc3Npb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICAgICAgICBleHByLnJocy5hcmd1bWVudHMudW5zaGlmdChleHByLmxocyk7XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlRnVuY3Rpb24oZXhwci5yaHMsIGlucHV0LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICBleHByLnJocy5hcmd1bWVudHMuc2hpZnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsaHMgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIubGhzLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIucmhzLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuXG4gICAgICAgICAgICBpZighaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJUMjAwNlwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoaXNGdW5jdGlvbihsaHMpKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBmdW5jdGlvbiBjaGFpbmluZyAoZnVuYzEgfj4gZnVuYzIpXG4gICAgICAgICAgICAgICAgLy8gzrsoJGYsICRnKSB7IM67KCR4KXsgJGcoJGYoJHgpKSB9IH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGFwcGx5KGNoYWluLCBbbGhzLCBmdW5jXSwgZW52aXJvbm1lbnQsIG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGFwcGx5KGZ1bmMsIFtsaHNdLCBlbnZpcm9ubWVudCwgbnVsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnIC0gZXhwcmVzc2lvbiB0byB0ZXN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSBpZiBpdCBpcyBhIGZ1bmN0aW9uIChsYW1iZGEgb3IgYnVpbHQtaW4pXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuICgoYXJnICYmIChhcmcuX2pzb25hdGFfZnVuY3Rpb24gPT09IHRydWUgfHwgYXJnLl9qc29uYXRhX2xhbWJkYSA9PT0gdHJ1ZSkpIHx8IHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RzIHdoZXRoZXIgYXJnIGlzIGEgbGFtYmRhIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSBhcmcgLSB0aGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUgaWYgaXQgaXMgYSBsYW1iZGEgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xhbWJkYShhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZyAmJiBhcmcuX2pzb25hdGFfbGFtYmRhID09PSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmcgLSBleHByZXNzaW9uIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIGl0IGlzIGEgZ2VuZXJhdG9yIGkuZS4gdGhlIHJlc3VsdCBmcm9tIGNhbGxpbmcgYVxuICAgICAqIGdlbmVyYXRvciBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzR2VuZXJhdG9yKGFyZykge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIGFyZyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgU3ltYm9sLml0ZXJhdG9yIGluIGFyZyAmJlxuICAgICAgICAgICAgdHlwZW9mIGFyZ1tTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAnbmV4dCcgaW4gYXJnICYmXG4gICAgICAgICAgICB0eXBlb2YgYXJnLm5leHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBmdW5jdGlvbiBhZ2FpbnN0IGlucHV0IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXhwciAtIEpTT05hdGEgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGRhdGEgdG8gZXZhbHVhdGUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnZpcm9ubWVudCAtIEVudmlyb25tZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFthcHBseXRvXSAtIExIUyBvZiB+PiBvcGVyYXRvclxuICAgICAqIEByZXR1cm5zIHsqfSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBldmFsdWF0ZUZ1bmN0aW9uKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgcHJvY2VkdXJlXG4gICAgICAgIC8vIGNhbid0IGFzc3VtZSB0aGF0IGV4cHIucHJvY2VkdXJlIGlzIGEgbGFtYmRhIHR5cGUgZGlyZWN0bHlcbiAgICAgICAgLy8gY291bGQgYmUgYW4gZXhwcmVzc2lvbiB0aGF0IGV2YWx1YXRlcyB0byBhIGZ1bmN0aW9uIChlLmcuIHZhcmlhYmxlIHJlZmVyZW5jZSwgcGFyZW5zIGV4cHIgZXRjLlxuICAgICAgICAvLyBldmFsdWF0ZSBpdCBnZW5lcmljYWxseSBmaXJzdCwgdGhlbiBjaGVjayB0aGF0IGl0IGlzIGEgZnVuY3Rpb24uICBUaHJvdyBlcnJvciBpZiBub3QuXG4gICAgICAgIHZhciBwcm9jID0geWllbGQgKiBldmFsdWF0ZShleHByLnByb2NlZHVyZSwgaW5wdXQsIGVudmlyb25tZW50KTtcblxuICAgICAgICBpZiAodHlwZW9mIHByb2MgPT09ICd1bmRlZmluZWQnICYmIGV4cHIucHJvY2VkdXJlLnR5cGUgPT09ICdwYXRoJyAmJiBlbnZpcm9ubWVudC5sb29rdXAoZXhwci5wcm9jZWR1cmUuc3RlcHNbMF0udmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBoZWxwIHRoZSB1c2VyIG91dCBoZXJlIGlmIHRoZXkgc2ltcGx5IGZvcmdvdCB0aGUgbGVhZGluZyAkXG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgY29kZTogXCJUMTAwNVwiLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHRva2VuOiBleHByLnByb2NlZHVyZS5zdGVwc1swXS52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBldmFsdWF0ZWRBcmdzID0gW107XG4gICAgICAgIC8vIGVhZ2VyIGV2YWx1YXRpb24gLSBldmFsdWF0ZSB0aGUgYXJndW1lbnRzXG4gICAgICAgIGZvciAodmFyIGpqID0gMDsgamogPCBleHByLmFyZ3VtZW50cy5sZW5ndGg7IGpqKyspIHtcbiAgICAgICAgICAgIC8vIG9ubHkgZXZhbHVhdGUgJ2VhZ2VyJyBhcmd1bWVudHMgYXQgdGhpcyBzdGFnZTsgd3JhcCB0aGUgJ2xhenknIG9uZXMgaW4gYSBjbG9zdXJlXG4gICAgICAgICAgICBldmFsdWF0ZWRBcmdzLnB1c2goeWllbGQqIGV2YWx1YXRlKGV4cHIuYXJndW1lbnRzW2pqXSwgaW5wdXQsIGVudmlyb25tZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXBwbHkgdGhlIHByb2NlZHVyZVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gaWYoaW5wdXQgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgIC8vICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5wdXQsICdfX2Vudl9fJywge1xuICAgICAgICAgICAgLy8gICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIC8vICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgLy8gICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHJldHVybiBlbnZpcm9ubWVudDtcbiAgICAgICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAgICAgLy8gICAgIH0pO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBhcHBseShwcm9jLCBldmFsdWF0ZWRBcmdzLCBpbnB1dCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gYWRkIHRoZSBwb3NpdGlvbiBmaWVsZCB0byB0aGUgZXJyb3JcbiAgICAgICAgICAgIGVyci5wb3NpdGlvbiA9IGV4cHIucG9zaXRpb247XG4gICAgICAgICAgICAvLyBhbmQgdGhlIGZ1bmN0aW9uIGlkZW50aWZpZXJcbiAgICAgICAgICAgIGVyci50b2tlbiA9IGV4cHIucHJvY2VkdXJlLnR5cGUgPT09ICdwYXRoJyA/IGV4cHIucHJvY2VkdXJlLnN0ZXBzWzBdLnZhbHVlIDogZXhwci5wcm9jZWR1cmUudmFsdWU7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBwcm9jZWR1cmUgb3IgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvYyAtIFByb2NlZHVyZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBBcmd1bWVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VsZiAtIFNlbGZcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0IG9mIHByb2NlZHVyZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBhcHBseShwcm9jLCBhcmdzLCBzZWxmKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9IHlpZWxkICogYXBwbHlJbm5lcihwcm9jLCBhcmdzLCBzZWxmKTtcbiAgICAgICAgd2hpbGUoaXNMYW1iZGEocmVzdWx0KSAmJiByZXN1bHQudGh1bmsgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIHRyYW1wb2xpbmUgbG9vcCAtIHRoaXMgZ2V0cyBpbnZva2VkIGFzIGEgcmVzdWx0IG9mIHRhaWwtY2FsbCBvcHRpbWl6YXRpb25cbiAgICAgICAgICAgIC8vIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBhIHRhaWwtY2FsbCB0aHVua1xuICAgICAgICAgICAgLy8gdW5wYWNrIGl0LCBldmFsdWF0ZSBpdHMgYXJndW1lbnRzLCBhbmQgYXBwbHkgdGhlIHRhaWwgY2FsbFxuICAgICAgICAgICAgdmFyIG5leHQgPSB5aWVsZCAqIGV2YWx1YXRlKHJlc3VsdC5ib2R5LnByb2NlZHVyZSwgcmVzdWx0LmlucHV0LCByZXN1bHQuZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgdmFyIGV2YWx1YXRlZEFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvcih2YXIgaWkgPSAwOyBpaSA8IHJlc3VsdC5ib2R5LmFyZ3VtZW50cy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICAgICAgICBldmFsdWF0ZWRBcmdzLnB1c2goeWllbGQgKiBldmFsdWF0ZShyZXN1bHQuYm9keS5hcmd1bWVudHNbaWldLCByZXN1bHQuaW5wdXQsIHJlc3VsdC5lbnZpcm9ubWVudCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGFwcGx5SW5uZXIobmV4dCwgZXZhbHVhdGVkQXJncywgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBwcm9jZWR1cmUgb3IgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvYyAtIFByb2NlZHVyZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBBcmd1bWVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VsZiAtIFNlbGZcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0IG9mIHByb2NlZHVyZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBhcHBseUlubmVyKHByb2MsIGFyZ3MsIHNlbGYpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHZhbGlkYXRlZEFyZ3MgPSBhcmdzO1xuICAgICAgICBpZihwcm9jKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZWRBcmdzID0gdmFsaWRhdGVBcmd1bWVudHMocHJvYy5zaWduYXR1cmUsIGFyZ3MsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xhbWJkYShwcm9jKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgKiBhcHBseVByb2NlZHVyZShwcm9jLCB2YWxpZGF0ZWRBcmdzKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jICYmIHByb2MuX2pzb25hdGFfZnVuY3Rpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHByb2MuaW1wbGVtZW50YXRpb24uYXBwbHkoc2VsZiwgdmFsaWRhdGVkQXJncyk7XG4gICAgICAgICAgICAvLyBgcHJvYy5pbXBsZW1lbnRhdGlvbmAgbWlnaHQgYmUgYSBnZW5lcmF0b3IgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIGFuZCBgcmVzdWx0YCBtaWdodCBiZSBhIGdlbmVyYXRvciAtIGlmIHNvLCB5aWVsZFxuICAgICAgICAgICAgaWYoaXNHZW5lcmF0b3IocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICpyZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHByb2MuYXBwbHkoc2VsZiwgdmFsaWRhdGVkQXJncyk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYoaXNHZW5lcmF0b3IocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICpyZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgY29kZTogXCJUMTAwNlwiLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgbGFtYmRhIGFnYWluc3QgaW5wdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7e2xhbWJkYTogYm9vbGVhbiwgaW5wdXQ6ICosIGVudmlyb25tZW50OiAqLCBhcmd1bWVudHM6ICosIGJvZHk6ICp9fSBFdmFsdWF0ZWQgaW5wdXQgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2YWx1YXRlTGFtYmRhKGV4cHIsIGlucHV0LCBlbnZpcm9ubWVudCkge1xuICAgICAgICAvLyBtYWtlIGEgZnVuY3Rpb24gKGNsb3N1cmUpXG4gICAgICAgIHZhciBwcm9jZWR1cmUgPSB7XG4gICAgICAgICAgICBfanNvbmF0YV9sYW1iZGE6IHRydWUsXG4gICAgICAgICAgICBpbnB1dDogaW5wdXQsXG4gICAgICAgICAgICBlbnZpcm9ubWVudDogZW52aXJvbm1lbnQsXG4gICAgICAgICAgICBhcmd1bWVudHM6IGV4cHIuYXJndW1lbnRzLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBleHByLnNpZ25hdHVyZSxcbiAgICAgICAgICAgIGJvZHk6IGV4cHIuYm9keVxuICAgICAgICB9O1xuICAgICAgICBpZihleHByLnRodW5rID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwcm9jZWR1cmUudGh1bmsgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9jZWR1cmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgcGFydGlhbCBhcHBsaWNhdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHByIC0gSlNPTmF0YSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgZGF0YSB0byBldmFsdWF0ZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVudmlyb25tZW50IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gRXZhbHVhdGVkIGlucHV0IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZXZhbHVhdGVQYXJ0aWFsQXBwbGljYXRpb24oZXhwciwgaW5wdXQsIGVudmlyb25tZW50KSB7XG4gICAgICAgIC8vIHBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uXG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIC8vIGV2YWx1YXRlIHRoZSBhcmd1bWVudHNcbiAgICAgICAgdmFyIGV2YWx1YXRlZEFyZ3MgPSBbXTtcbiAgICAgICAgZm9yKHZhciBpaSA9IDA7IGlpIDwgZXhwci5hcmd1bWVudHMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICB2YXIgYXJnID0gZXhwci5hcmd1bWVudHNbaWldO1xuICAgICAgICAgICAgaWYgKGFyZy50eXBlID09PSAnb3BlcmF0b3InICYmIGFyZy52YWx1ZSA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgICAgZXZhbHVhdGVkQXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2YWx1YXRlZEFyZ3MucHVzaCh5aWVsZCAqIGV2YWx1YXRlKGFyZywgaW5wdXQsIGVudmlyb25tZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9va3VwIHRoZSBwcm9jZWR1cmVcbiAgICAgICAgdmFyIHByb2MgPSB5aWVsZCAqIGV2YWx1YXRlKGV4cHIucHJvY2VkdXJlLCBpbnB1dCwgZW52aXJvbm1lbnQpO1xuICAgICAgICBpZiAodHlwZW9mIHByb2MgPT09ICd1bmRlZmluZWQnICYmIGV4cHIucHJvY2VkdXJlLnR5cGUgPT09ICdwYXRoJyAmJiBlbnZpcm9ubWVudC5sb29rdXAoZXhwci5wcm9jZWR1cmUuc3RlcHNbMF0udmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBoZWxwIHRoZSB1c2VyIG91dCBoZXJlIGlmIHRoZXkgc2ltcGx5IGZvcmdvdCB0aGUgbGVhZGluZyAkXG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgY29kZTogXCJUMTAwN1wiLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHByLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHRva2VuOiBleHByLnByb2NlZHVyZS5zdGVwc1swXS52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMYW1iZGEocHJvYykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcnRpYWxBcHBseVByb2NlZHVyZShwcm9jLCBldmFsdWF0ZWRBcmdzKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jICYmIHByb2MuX2pzb25hdGFfZnVuY3Rpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcnRpYWxBcHBseU5hdGl2ZUZ1bmN0aW9uKHByb2MuaW1wbGVtZW50YXRpb24sIGV2YWx1YXRlZEFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJ0aWFsQXBwbHlOYXRpdmVGdW5jdGlvbihwcm9jLCBldmFsdWF0ZWRBcmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlQxMDA4XCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cHIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgdG9rZW46IGV4cHIucHJvY2VkdXJlLnR5cGUgPT09ICdwYXRoJyA/IGV4cHIucHJvY2VkdXJlLnN0ZXBzWzBdLnZhbHVlIDogZXhwci5wcm9jZWR1cmUudmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgYXJndW1lbnRzIGFnYWluc3QgdGhlIHNpZ25hdHVyZSB2YWxpZGF0b3IgKGlmIGl0IGV4aXN0cylcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzaWduYXR1cmUgLSB2YWxpZGF0b3IgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIC0gZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICogQHBhcmFtIHsqfSBjb250ZXh0IC0gY29udGV4dCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gLSB2YWxpZGF0ZWQgYXJndW1lbnRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVBcmd1bWVudHMoc2lnbmF0dXJlLCBhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgIGlmKHR5cGVvZiBzaWduYXR1cmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHRvIHZhbGlkYXRlXG4gICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsaWRhdGVkQXJncyA9IHNpZ25hdHVyZS52YWxpZGF0ZShhcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEFyZ3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgcHJvY2VkdXJlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb2MgLSBQcm9jZWR1cmVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIC0gQXJndW1lbnRzXG4gICAgICogQHJldHVybnMgeyp9IFJlc3VsdCBvZiBwcm9jZWR1cmVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogYXBwbHlQcm9jZWR1cmUocHJvYywgYXJncykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgZW52ID0gY3JlYXRlRnJhbWUocHJvYy5lbnZpcm9ubWVudCk7XG4gICAgICAgIHByb2MuYXJndW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtLCBpbmRleCkge1xuICAgICAgICAgICAgZW52LmJpbmQocGFyYW0udmFsdWUsIGFyZ3NbaW5kZXhdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvYy5ib2R5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgbGFtYmRhIHRoYXQgd3JhcHMgYSBuYXRpdmUgZnVuY3Rpb24gLSBnZW5lcmF0ZWQgYnkgcGFydGlhbGx5IGV2YWx1YXRpbmcgYSBuYXRpdmVcbiAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkICogYXBwbHlOYXRpdmVGdW5jdGlvbihwcm9jLmJvZHksIGVudik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGV2YWx1YXRlKHByb2MuYm9keSwgcHJvYy5pbnB1dCwgZW52KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnRpYWxseSBhcHBseSBwcm9jZWR1cmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvYyAtIFByb2NlZHVyZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBBcmd1bWVudHNcbiAgICAgKiBAcmV0dXJucyB7e2xhbWJkYTogYm9vbGVhbiwgaW5wdXQ6ICosIGVudmlyb25tZW50OiB7YmluZCwgbG9va3VwfSwgYXJndW1lbnRzOiBBcnJheSwgYm9keTogKn19IFJlc3VsdCBvZiBwYXJ0aWFsbHkgYXBwbGllZCBwcm9jZWR1cmVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJ0aWFsQXBwbHlQcm9jZWR1cmUocHJvYywgYXJncykge1xuICAgICAgICAvLyBjcmVhdGUgYSBjbG9zdXJlLCBiaW5kIHRoZSBzdXBwbGllZCBwYXJhbWV0ZXJzIGFuZCByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSByZW1haW5pbmcgKD8pIHBhcmFtZXRlcnNcbiAgICAgICAgdmFyIGVudiA9IGNyZWF0ZUZyYW1lKHByb2MuZW52aXJvbm1lbnQpO1xuICAgICAgICB2YXIgdW5ib3VuZEFyZ3MgPSBbXTtcbiAgICAgICAgcHJvYy5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgYXJnID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoYXJnICYmIGFyZy50eXBlID09PSAnb3BlcmF0b3InICYmIGFyZy52YWx1ZSA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgICAgdW5ib3VuZEFyZ3MucHVzaChwYXJhbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVudi5iaW5kKHBhcmFtLnZhbHVlLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHByb2NlZHVyZSA9IHtcbiAgICAgICAgICAgIF9qc29uYXRhX2xhbWJkYTogdHJ1ZSxcbiAgICAgICAgICAgIGlucHV0OiBwcm9jLmlucHV0LFxuICAgICAgICAgICAgZW52aXJvbm1lbnQ6IGVudixcbiAgICAgICAgICAgIGFyZ3VtZW50czogdW5ib3VuZEFyZ3MsXG4gICAgICAgICAgICBib2R5OiBwcm9jLmJvZHlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHByb2NlZHVyZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJ0aWFsbHkgYXBwbHkgbmF0aXZlIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmF0aXZlIC0gTmF0aXZlIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHt7bGFtYmRhOiBib29sZWFuLCBpbnB1dDogKiwgZW52aXJvbm1lbnQ6IHtiaW5kLCBsb29rdXB9LCBhcmd1bWVudHM6IEFycmF5LCBib2R5OiAqfX0gUmVzdWx0IG9mIHBhcnRpYWxseSBhcHBseWluZyBuYXRpdmUgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJ0aWFsQXBwbHlOYXRpdmVGdW5jdGlvbihuYXRpdmUsIGFyZ3MpIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgbGFtYmRhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYW5kIGludm9rZXMgdGhlIG5hdGl2ZSBmdW5jdGlvblxuICAgICAgICAvLyBnZXQgdGhlIGxpc3Qgb2YgZGVjbGFyZWQgYXJndW1lbnRzIGZyb20gdGhlIG5hdGl2ZSBmdW5jdGlvblxuICAgICAgICAvLyB0aGlzIGhhcyB0byBiZSBwaWNrZWQgb3V0IGZyb20gdGhlIHRvU3RyaW5nKCkgdmFsdWVcbiAgICAgICAgdmFyIHNpZ0FyZ3MgPSBnZXROYXRpdmVGdW5jdGlvbkFyZ3VtZW50cyhuYXRpdmUpO1xuICAgICAgICBzaWdBcmdzID0gc2lnQXJncy5tYXAoZnVuY3Rpb24gKHNpZ0FyZykge1xuICAgICAgICAgICAgcmV0dXJuICckJyArIHNpZ0FyZy50cmltKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYm9keSA9ICdmdW5jdGlvbignICsgc2lnQXJncy5qb2luKCcsICcpICsgJyl7IF8gfSc7XG5cbiAgICAgICAgdmFyIGJvZHlBU1QgPSBwYXJzZXIoYm9keSk7XG4gICAgICAgIGJvZHlBU1QuYm9keSA9IG5hdGl2ZTtcblxuICAgICAgICB2YXIgcGFydGlhbCA9IHBhcnRpYWxBcHBseVByb2NlZHVyZShib2R5QVNULCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHBhcnRpYWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgbmF0aXZlIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb2MgLSBQcm9jZWR1cmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZW52IC0gRW52aXJvbm1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmVzdWx0IG9mIGFwcGx5aW5nIG5hdGl2ZSBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBhcHBseU5hdGl2ZUZ1bmN0aW9uKHByb2MsIGVudikge1xuICAgICAgICB2YXIgc2lnQXJncyA9IGdldE5hdGl2ZUZ1bmN0aW9uQXJndW1lbnRzKHByb2MpO1xuICAgICAgICAvLyBnZW5lcmF0ZSB0aGUgYXJyYXkgb2YgYXJndW1lbnRzIGZvciBpbnZva2luZyB0aGUgZnVuY3Rpb24gLSBsb29rIHRoZW0gdXAgaW4gdGhlIGVudmlyb25tZW50XG4gICAgICAgIHZhciBhcmdzID0gc2lnQXJncy5tYXAoZnVuY3Rpb24gKHNpZ0FyZykge1xuICAgICAgICAgICAgcmV0dXJuIGVudi5sb29rdXAoc2lnQXJnLnRyaW0oKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBwcm9jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICBpZihpc0dlbmVyYXRvcihyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBuYXRpdmUgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uXG4gICAgICogQHJldHVybnMgeyp8QXJyYXl9IE5hdGl2ZSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXROYXRpdmVGdW5jdGlvbkFyZ3VtZW50cyhmdW5jKSB7XG4gICAgICAgIHZhciBzaWduYXR1cmUgPSBmdW5jLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBzaWdQYXJlbnMgPSAvXFwoKFteKV0qKVxcKS8uZXhlYyhzaWduYXR1cmUpWzFdOyAvLyB0aGUgY29udGVudHMgb2YgdGhlIHBhcmVuc1xuICAgICAgICB2YXIgc2lnQXJncyA9IHNpZ1BhcmVucy5zcGxpdCgnLCcpO1xuICAgICAgICByZXR1cm4gc2lnQXJncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgLSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbiBpbiBKYXZhc2NyaXB0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZSAtIEpTT05hdGEgZnVuY3Rpb24gc2lnbmF0dXJlIGRlZmluaXRpb25cbiAgICAgKiBAcmV0dXJucyB7e2ltcGxlbWVudGF0aW9uOiAqLCBzaWduYXR1cmU6ICp9fSBmdW5jdGlvbiBkZWZpbml0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmaW5lRnVuY3Rpb24oZnVuYywgc2lnbmF0dXJlKSB7XG4gICAgICAgIHZhciBkZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgX2pzb25hdGFfZnVuY3Rpb246IHRydWUsXG4gICAgICAgICAgICBpbXBsZW1lbnRhdGlvbjogZnVuY1xuICAgICAgICB9O1xuICAgICAgICBpZih0eXBlb2Ygc2lnbmF0dXJlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZGVmaW5pdGlvbi5zaWduYXR1cmUgPSBwYXJzZVNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN1bSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIC0gQXJndW1lbnRzXG4gICAgICogQHJldHVybnMge251bWJlcn0gVG90YWwgdmFsdWUgb2YgYXJndW1lbnRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25TdW0oYXJncykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmdzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbihudW0pe3RvdGFsICs9IG51bTt9KTtcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvdW50IGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgLSBBcmd1bWVudHNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Db3VudChhcmdzKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZ3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcmdzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXggZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE1heCBlbGVtZW50IGluIHRoZSBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uTWF4KGFyZ3MpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJncyA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWluIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgLSBBcmd1bWVudHNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBNaW4gZWxlbWVudCBpbiB0aGUgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbk1pbihhcmdzKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZ3MgPT09ICd1bmRlZmluZWQnIHx8IGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF2ZXJhZ2UgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIEFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEF2ZXJhZ2UgZWxlbWVudCBpbiB0aGUgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkF2ZXJhZ2UoYXJncykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmdzID09PSAndW5kZWZpbmVkJyB8fCBhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbihudW0pe3RvdGFsICs9IG51bTt9KTtcbiAgICAgICAgcmV0dXJuIHRvdGFsL2FyZ3MubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0aW5naWZ5IGFyZ3VtZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmcgLSBBcmd1bWVudHNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBTdHJpbmcgZnJvbSBhcmd1bWVudHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblN0cmluZyhhcmcpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHI7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBhbHJlYWR5IGEgc3RyaW5nXG4gICAgICAgICAgICBzdHIgPSBhcmc7XG4gICAgICAgIH0gZWxzZSBpZihpc0Z1bmN0aW9uKGFyZykpIHtcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9ucyAoYnVpbHQtaW4gYW5kIGxhbWJkYSBjb252ZXJ0IHRvIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgc3RyID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicgJiYgIWlzRmluaXRlKGFyZykpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMDAxXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGFyZyxcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBzdHIgPSBKU09OLnN0cmluZ2lmeShhcmcsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsICE9PSBudWxsICYmIHZhbC50b1ByZWNpc2lvbiAmJiBpc051bWVyaWModmFsKSkgPyBOdW1iZXIodmFsLnRvUHJlY2lzaW9uKDEzKSkgOlxuICAgICAgICAgICAgICAgICAgICAodmFsICYmIGlzRnVuY3Rpb24odmFsKSkgPyAnJyA6IHZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBzdWJzdHJpbmcgYmFzZWQgb24gY2hhcmFjdGVyIG51bWJlciBhbmQgbGVuZ3RoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFN0cmluZyB0byBldmFsdWF0ZVxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gc3RhcnQgLSBDaGFyYWN0ZXIgbnVtYmVyIHRvIHN0YXJ0IHN1YnN0cmluZ1xuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gW2xlbmd0aF0gLSBOdW1iZXIgb2YgY2hhcmFjdGVycyBpbiBzdWJzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCp9IFN1YnN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU3Vic3RyaW5nKHN0ciwgc3RhcnQsIGxlbmd0aCkge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHN1YnN0cmluZyB1cCB1bnRpbCBhIGNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBTdHJpbmcgdG8gZXZhbHVhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2hhcnMgLSBDaGFyYWN0ZXIgdG8gZGVmaW5lIHN1YnN0cmluZyBib3VuZGFyeVxuICAgICAqIEByZXR1cm5zIHsqfSBTdWJzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblN1YnN0cmluZ0JlZm9yZShzdHIsIGNoYXJzKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9zID0gc3RyLmluZGV4T2YoY2hhcnMpO1xuICAgICAgICBpZiAocG9zID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIHBvcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHN1YnN0cmluZyBhZnRlciBhIGNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBTdHJpbmcgdG8gZXZhbHVhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2hhcnMgLSBDaGFyYWN0ZXIgdG8gZGVmaW5lIHN1YnN0cmluZyBib3VuZGFyeVxuICAgICAqIEByZXR1cm5zIHsqfSBTdWJzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblN1YnN0cmluZ0FmdGVyKHN0ciwgY2hhcnMpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3MgPSBzdHIuaW5kZXhPZihjaGFycyk7XG4gICAgICAgIGlmIChwb3MgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIocG9zICsgY2hhcnMubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb3dlcmNhc2UgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gU3RyaW5nIHRvIGV2YWx1YXRlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gTG93ZXJjYXNlIHN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uTG93ZXJjYXNlKHN0cikge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwcGVyY2FzZSBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBTdHJpbmcgdG8gZXZhbHVhdGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBVcHBlcmNhc2Ugc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25VcHBlcmNhc2Uoc3RyKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbGVuZ3RoIG9mIGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25MZW5ndGgoc3RyKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgYW5kIHRyaW0gd2hpdGVzcGFjZSB3aXRoaW4gYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gc3RyaW5nIHRvIGJlIHRyaW1tZWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRyaW1tZWQgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25UcmltKHN0cikge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIHdoaXRlc3BhY2VcbiAgICAgICAgdmFyIHJlc3VsdCA9IHN0ci5yZXBsYWNlKC9bIFxcdFxcblxccl0rL2dtLCAnICcpO1xuICAgICAgICBpZihyZXN1bHQuY2hhckF0KDApID09PSAnICcpIHtcbiAgICAgICAgICAgIC8vIHN0cmlwIGxlYWRpbmcgc3BhY2VcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYocmVzdWx0LmNoYXJBdChyZXN1bHQubGVuZ3RoIC0gMSkgPT09ICcgJykge1xuICAgICAgICAgICAgLy8gc3RyaXAgdHJhaWxpbmcgc3BhY2VcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHJpbmcoMCwgcmVzdWx0Lmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFkIGEgc3RyaW5nIHRvIGEgbWluaW11bSB3aWR0aCBieSBhZGRpbmcgY2hhcmFjdGVycyB0byB0aGUgc3RhcnQgb3IgZW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIHN0cmluZyB0byBiZSBwYWRkZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgbWluaW11bSB3aWR0aDsgK3ZlIHBhZHMgdG8gdGhlIHJpZ2h0LCAtdmUgcGFkcyB0byB0aGUgbGVmdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcl0gLSB0aGUgcGFkIGNoYXJhY3RlcihzKTsgZGVmYXVsdHMgdG8gJyAnXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSBwYWRkZWQgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25QYWQoc3RyLCB3aWR0aCwgY2hhcikge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodHlwZW9mIGNoYXIgPT09ICd1bmRlZmluZWQnIHx8IGNoYXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjaGFyID0gJyAnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHBhZExlbmd0aCA9IE1hdGguYWJzKHdpZHRoKSAtIHN0ci5sZW5ndGg7XG4gICAgICAgIGlmKHBhZExlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gKG5ldyBBcnJheShwYWRMZW5ndGggKyAxKSkuam9pbihjaGFyKTtcbiAgICAgICAgICAgIGlmKGNoYXIubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHBhZGRpbmcgPSBwYWRkaW5nLnN1YnN0cmluZygwLCBwYWRMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYod2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc3RyICsgcGFkZGluZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFkZGluZyArIHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN0cjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoZSBzdHIgY29udGFpbnMgdGhlIHRva2VuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHN0cmluZyB0byB0ZXN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRva2VuIC0gc3Vic3RyaW5nIG9yIHJlZ2V4IHRvIGZpbmRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSB0cnVlIGlmIHN0ciBjb250YWlucyB0b2tlblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uQ29udGFpbnMoc3RyLCB0b2tlbikge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBpZih0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAoc3RyLmluZGV4T2YodG9rZW4pICE9PSAtMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHRva2VuKHN0cik7XG4gICAgICAgICAgICByZXN1bHQgPSAodHlwZW9mIG1hdGNoZXMgIT09ICd1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWF0Y2ggYSBzdHJpbmcgd2l0aCBhIHJlZ2V4IHJldHVybmluZyBhbiBhcnJheSBvZiBvYmplY3QgY29udGFpbmluZyBkZXRhaWxzIG9mIGVhY2ggbWF0Y2hcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2V4IC0gdGhlIHJlZ2V4IGFwcGxpZWQgdG8gdGhlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gW2xpbWl0XSAtIG1heCBudW1iZXIgb2YgbWF0Y2hlcyB0byByZXR1cm5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBvZiBtYXRjaCBvYmplY3RzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25NYXRjaChzdHIsIHJlZ2V4LCBsaW1pdCkge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGltaXQsIGlmIHNwZWNpZmllZCwgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXJcbiAgICAgICAgaWYobGltaXQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxpbWl0LFxuICAgICAgICAgICAgICAgIGNvZGU6ICdEMzA0MCcsXG4gICAgICAgICAgICAgICAgaW5kZXg6IDNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYodHlwZW9mIGxpbWl0ID09PSAndW5kZWZpbmVkJyB8fCBsaW1pdCA+IDApIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHJlZ2V4KHN0cik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1hdGNoZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHR5cGVvZiBtYXRjaGVzICE9PSAndW5kZWZpbmVkJyAmJiAodHlwZW9mIGxpbWl0ID09PSAndW5kZWZpbmVkJyB8fCBjb3VudCA8IGxpbWl0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaDogbWF0Y2hlcy5tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBtYXRjaGVzLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzOiBtYXRjaGVzLmdyb3Vwc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IG1hdGNoZXMubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWF0Y2ggYSBzdHJpbmcgd2l0aCBhIHJlZ2V4IHJldHVybmluZyBhbiBhcnJheSBvZiBvYmplY3QgY29udGFpbmluZyBkZXRhaWxzIG9mIGVhY2ggbWF0Y2hcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4gLSB0aGUgc3Vic3RyaW5nL3JlZ2V4IGFwcGxpZWQgdG8gdGhlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXBsYWNlbWVudCAtIHRleHQgdG8gcmVwbGFjZSB0aGUgbWF0Y2hlZCBzdWJzdHJpbmdzXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBbbGltaXRdIC0gbWF4IG51bWJlciBvZiBtYXRjaGVzIHRvIHJldHVyblxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IG9mIG1hdGNoIG9iamVjdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiogZnVuY3Rpb25SZXBsYWNlKHN0ciwgcGF0dGVybiwgcmVwbGFjZW1lbnQsIGxpbWl0KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYXR0ZXJuIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgaWYocGF0dGVybiA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMDEwXCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgaW5kZXg6IDJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsaW1pdCwgaWYgc3BlY2lmaWVkLCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlclxuICAgICAgICBpZihsaW1pdCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMDExXCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgdmFsdWU6IGxpbWl0LFxuICAgICAgICAgICAgICAgIGluZGV4OiA0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcGxhY2VyO1xuICAgICAgICBpZih0eXBlb2YgcmVwbGFjZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXBsYWNlciA9IGZ1bmN0aW9uIChyZWdleE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnN0aXR1dGUgPSAnJztcbiAgICAgICAgICAgICAgICAvLyBzY2FuIGZvcndhcmQsIGNvcHlpbmcgdGhlIHJlcGxhY2VtZW50IHRleHQgaW50byB0aGUgc3Vic3RpdHV0ZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAvLyBhbmQgcmVwbGFjZSBhbnkgb2NjdXJyZW5jZSBvZiAkbiB3aXRoIHRoZSB2YWx1ZXMgbWF0Y2hlZCBieSB0aGUgcmVnZXhcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHJlcGxhY2VtZW50LmluZGV4T2YoJyQnLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4ICE9PSAtMSAmJiBwb3NpdGlvbiA8IHJlcGxhY2VtZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRlICs9IHJlcGxhY2VtZW50LnN1YnN0cmluZyhwb3NpdGlvbiwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbGxhclZhbCA9IHJlcGxhY2VtZW50LmNoYXJBdChwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2xsYXJWYWwgPT09ICckJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGl0ZXJhbCAkXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRlICs9ICckJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZG9sbGFyVmFsID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGUgKz0gcmVnZXhNYXRjaC5tYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4RGlnaXRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVnZXhNYXRjaC5ncm91cHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gc3ViLW1hdGNoZXM7IGFueSAkIGZvbGxvd2VkIGJ5IGEgZGlnaXQgd2lsbCBiZSByZXBsYWNlZCBieSBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhEaWdpdHMgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXggbnVtYmVyIG9mIGRpZ2l0cyB0byBwYXJzZSBmb2xsb3dpbmcgdGhlICRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhEaWdpdHMgPSBNYXRoLmZsb29yKE1hdGgubG9nKHJlZ2V4TWF0Y2guZ3JvdXBzLmxlbmd0aCkgKiBNYXRoLkxPRzEwRSkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBwYXJzZUludChyZXBsYWNlbWVudC5zdWJzdHJpbmcocG9zaXRpb24sIHBvc2l0aW9uICsgbWF4RGlnaXRzKSwgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobWF4RGlnaXRzID4gMSAmJiBpbmRleCA+IHJlZ2V4TWF0Y2guZ3JvdXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcGFyc2VJbnQocmVwbGFjZW1lbnQuc3Vic3RyaW5nKHBvc2l0aW9uLCBwb3NpdGlvbiArIG1heERpZ2l0cyAtIDEpLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlZ2V4TWF0Y2guZ3JvdXBzLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJtYXRjaCA9IHJlZ2V4TWF0Y2guZ3JvdXBzW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3VibWF0Y2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRlICs9IHN1Ym1hdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IGluZGV4LnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgYSBjYXB0dXJlIGdyb3VwLCB0cmVhdCB0aGUgJCBhcyBsaXRlcmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0ZSArPSAnJCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXBsYWNlbWVudC5pbmRleE9mKCckJywgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRlICs9IHJlcGxhY2VtZW50LnN1YnN0cmluZyhwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVwbGFjZXIgPSByZXBsYWNlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gMDtcblxuICAgICAgICBpZih0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnIHx8IGxpbWl0ID4gMCkge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHN0ci5pbmRleE9mKHBhdHRlcm4sIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICB3aGlsZShpbmRleCAhPT0gLTEgJiYgKHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcgfHwgY291bnQgPCBsaW1pdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5zdWJzdHJpbmcocG9zaXRpb24sIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGluZGV4ICsgcGF0dGVybi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gc3RyLmluZGV4T2YocGF0dGVybiwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyLnN1YnN0cmluZyhwb3NpdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gcGF0dGVybihzdHIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWF0Y2hlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHR5cGVvZiBtYXRjaGVzICE9PSAndW5kZWZpbmVkJyAmJiAodHlwZW9mIGxpbWl0ID09PSAndW5kZWZpbmVkJyB8fCBjb3VudCA8IGxpbWl0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5zdWJzdHJpbmcocG9zaXRpb24sIG1hdGNoZXMuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VkV2l0aCA9IHlpZWxkICogYXBwbHkocmVwbGFjZXIsIFttYXRjaGVzXSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayByZXBsYWNlZFdpdGggaXMgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiByZXBsYWNlZFdpdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHJlcGxhY2VkV2l0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGEgc3RyaW5nIC0gdGhyb3cgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiRDMwMTJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXBsYWNlZFdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBtYXRjaGVzLnN0YXJ0ICsgbWF0Y2hlcy5tYXRjaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IG1hdGNoZXMubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuc3Vic3RyaW5nKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzdHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3RyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCYXNlNjQgZW5jb2RlIGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IEJhc2UgNjQgZW5jb2Rpbmcgb2YgdGhlIGJpbmFyeSBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25CYXNlNjRlbmNvZGUoc3RyKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGJ0b2EgaW4gYSBicm93c2VyLCBvciBCdWZmZXIgaW4gTm9kZS5qc1xuXG4gICAgICAgIHZhciBidG9hID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gd2luZG93LmJ0b2EgOlxuICAgICAgICAgICAgZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGx5IGRvaW5nIGBuZXcgQnVmZmVyYCBhdCB0aGlzIHBvaW50IGNhdXNlcyBCcm93c2VyaWZ5IHRvIHB1bGxcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgZW50aXJlIEJ1ZmZlciBicm93c2VyIGxpYnJhcnksIHdoaWNoIGlzIGxhcmdlIGFuZCB1bm5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAgICAvLyBVc2luZyBgZ2xvYmFsLkJ1ZmZlcmAgZGVmZWF0cyB0aGlzLlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZ2xvYmFsLkJ1ZmZlcihzdHIsICdiaW5hcnknKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYnRvYShzdHIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJhc2U2NCBkZWNvZGUgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gc3RyaW5nXG4gICAgICogQHJldHVybnMge1N0cmluZ30gQmFzZSA2NCBlbmNvZGluZyBvZiB0aGUgYmluYXJ5IGRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkJhc2U2NGRlY29kZShzdHIpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgYnRvYSBpbiBhIGJyb3dzZXIsIG9yIEJ1ZmZlciBpbiBOb2RlLmpzXG4gICAgICAgIHZhciBhdG9iID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gd2luZG93LmF0b2IgOlxuICAgICAgICAgICAgZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGx5IGRvaW5nIGBuZXcgQnVmZmVyYCBhdCB0aGlzIHBvaW50IGNhdXNlcyBCcm93c2VyaWZ5IHRvIHB1bGxcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgZW50aXJlIEJ1ZmZlciBicm93c2VyIGxpYnJhcnksIHdoaWNoIGlzIGxhcmdlIGFuZCB1bm5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAgICAvLyBVc2luZyBgZ2xvYmFsLkJ1ZmZlcmAgZGVmZWF0cyB0aGlzLlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZ2xvYmFsLkJ1ZmZlcihzdHIsICdiYXNlNjQnKS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXRvYihzdHIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwbGl0IGEgc3RyaW5nIGludG8gYW4gYXJyYXkgb2Ygc3Vic3RyaW5nc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VwYXJhdG9yIC0gdGhlIHRva2VuIG9yIHJlZ2V4IHRoYXQgc3BsaXRzIHRoZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IFtsaW1pdF0gLSBtYXggbnVtYmVyIG9mIHN1YnN0cmluZ3NcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBvZiBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblNwbGl0KHN0ciwgc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGltaXQsIGlmIHNwZWNpZmllZCwgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXJcbiAgICAgICAgaWYobGltaXQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgY29kZTogXCJEMzAyMFwiLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBsaW1pdCxcbiAgICAgICAgICAgICAgICBpbmRleDogM1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZih0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnIHx8IGxpbWl0ID4gMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXBhcmF0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc3RyLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gc2VwYXJhdG9yKHN0cik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtYXRjaGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHlwZW9mIG1hdGNoZXMgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnIHx8IGNvdW50IDwgbGltaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdHIuc3Vic3RyaW5nKHN0YXJ0LCBtYXRjaGVzLnN0YXJ0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG1hdGNoZXMuZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IG1hdGNoZXMubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnIHx8IGNvdW50IDwgbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0ci5zdWJzdHJpbmcoc3RhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtzdHJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSm9pbiBhbiBhcnJheSBvZiBzdHJpbmdzXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3RycyAtIGFycmF5IG9mIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VwYXJhdG9yXSAtIHRoZSB0b2tlbiB0aGF0IHNwbGl0cyB0aGUgc3RyaW5nXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGNvbmNhdGVuYXRlZCBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkpvaW4oc3Rycywgc2VwYXJhdG9yKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHN0cnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgc2VwYXJhdG9yIGlzIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHQgdG8gZW1wdHkgc3RyaW5nXG4gICAgICAgIGlmKHR5cGVvZiBzZXBhcmF0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cnMuam9pbihzZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdHMgYSBudW1iZXIgaW50byBhIGRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIHVzaW5nIFhQYXRoIDMuMSBGJk8gZm46Zm9ybWF0LW51bWJlciBzcGVjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gbnVtYmVyIHRvIGZvcm1hdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwaWN0dXJlIC0gcGljdHVyZSBzdHJpbmcgZGVmaW5pdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBvdmVycmlkZSBsb2NhbGUgZGVmYXVsdHNcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgZm9ybWF0dGVkIHN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uRm9ybWF0TnVtYmVyKHZhbHVlLCBwaWN0dXJlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIFwiZGVjaW1hbC1zZXBhcmF0b3JcIjogXCIuXCIsXG4gICAgICAgICAgICBcImdyb3VwaW5nLXNlcGFyYXRvclwiOiBcIixcIixcbiAgICAgICAgICAgIFwiZXhwb25lbnQtc2VwYXJhdG9yXCI6IFwiZVwiLFxuICAgICAgICAgICAgXCJpbmZpbml0eVwiOiBcIkluZmluaXR5XCIsXG4gICAgICAgICAgICBcIm1pbnVzLXNpZ25cIjogXCItXCIsXG4gICAgICAgICAgICBcIk5hTlwiOiBcIk5hTlwiLFxuICAgICAgICAgICAgXCJwZXJjZW50XCI6IFwiJVwiLFxuICAgICAgICAgICAgXCJwZXItbWlsbGVcIjogXCJcXHUyMDMwXCIsXG4gICAgICAgICAgICBcInplcm8tZGlnaXRcIjogXCIwXCIsXG4gICAgICAgICAgICBcImRpZ2l0XCI6IFwiI1wiLFxuICAgICAgICAgICAgXCJwYXR0ZXJuLXNlcGFyYXRvclwiOiBcIjtcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGlmIGBvcHRpb25zYCBpcyBzcGVjaWZpZWQsIHRoZW4gaXRzIGVudHJpZXMgb3ZlcnJpZGUgZGVmYXVsdHNcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBkZWZhdWx0cztcbiAgICAgICAgaWYodHlwZW9mIG9wdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWNpbWFsRGlnaXRGYW1pbHkgPSBbXTtcbiAgICAgICAgdmFyIHplcm9DaGFyQ29kZSA9IHByb3BlcnRpZXNbJ3plcm8tZGlnaXQnXS5jaGFyQ29kZUF0KDApO1xuICAgICAgICBmb3IodmFyIGlpID0gemVyb0NoYXJDb2RlOyBpaSA8IHplcm9DaGFyQ29kZSArIDEwOyBpaSsrKSB7XG4gICAgICAgICAgICBkZWNpbWFsRGlnaXRGYW1pbHkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGlpKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWN0aXZlQ2hhcnMgPSBkZWNpbWFsRGlnaXRGYW1pbHkuY29uY2F0KFtwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddLCBwcm9wZXJ0aWVzWydleHBvbmVudC1zZXBhcmF0b3InXSwgcHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10sIHByb3BlcnRpZXMuZGlnaXQsIHByb3BlcnRpZXNbJ3BhdHRlcm4tc2VwYXJhdG9yJ11dKTtcblxuICAgICAgICB2YXIgc3ViUGljdHVyZXMgPSBwaWN0dXJlLnNwbGl0KHByb3BlcnRpZXNbJ3BhdHRlcm4tc2VwYXJhdG9yJ10pO1xuXG4gICAgICAgIGlmKHN1YlBpY3R1cmVzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiAnRDMwODAnLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNwbGl0UGFydHMgPSBmdW5jdGlvbihzdWJwaWN0dXJlKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjaDtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGlpID0gMDsgaWkgPCBzdWJwaWN0dXJlLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICAgICAgICBjaCA9IHN1YnBpY3R1cmUuY2hhckF0KGlpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoYWN0aXZlQ2hhcnMuaW5kZXhPZihjaCkgIT09IC0xICYmIGNoICE9PSBwcm9wZXJ0aWVzWydleHBvbmVudC1zZXBhcmF0b3InXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnBpY3R1cmUuc3Vic3RyaW5nKDAsIGlpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjaDtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGlpID0gc3VicGljdHVyZS5sZW5ndGggLSAxOyBpaSA+PSAwOyBpaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gc3VicGljdHVyZS5jaGFyQXQoaWkpO1xuICAgICAgICAgICAgICAgICAgICBpZihhY3RpdmVDaGFycy5pbmRleE9mKGNoKSAhPT0gLTEgJiYgY2ggIT09IHByb3BlcnRpZXNbJ2V4cG9uZW50LXNlcGFyYXRvciddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VicGljdHVyZS5zdWJzdHJpbmcoaWkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB2YXIgYWN0aXZlUGFydCA9IHN1YnBpY3R1cmUuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgsIHN1YnBpY3R1cmUubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgbWFudGlzc2FQYXJ0LCBleHBvbmVudFBhcnQsIGludGVnZXJQYXJ0LCBmcmFjdGlvbmFsUGFydDtcbiAgICAgICAgICAgIHZhciBleHBvbmVudFBvc2l0aW9uID0gc3VicGljdHVyZS5pbmRleE9mKHByb3BlcnRpZXNbJ2V4cG9uZW50LXNlcGFyYXRvciddLCBwcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmKGV4cG9uZW50UG9zaXRpb24gPT09IC0xIHx8IGV4cG9uZW50UG9zaXRpb24gPiBzdWJwaWN0dXJlLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBtYW50aXNzYVBhcnQgPSBhY3RpdmVQYXJ0O1xuICAgICAgICAgICAgICAgIGV4cG9uZW50UGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFudGlzc2FQYXJ0ID0gYWN0aXZlUGFydC5zdWJzdHJpbmcoMCwgZXhwb25lbnRQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgZXhwb25lbnRQYXJ0ID0gYWN0aXZlUGFydC5zdWJzdHJpbmcoZXhwb25lbnRQb3NpdGlvbiArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRlY2ltYWxQb3NpdGlvbiA9IG1hbnRpc3NhUGFydC5pbmRleE9mKHByb3BlcnRpZXNbJ2RlY2ltYWwtc2VwYXJhdG9yJ10pO1xuICAgICAgICAgICAgaWYoZGVjaW1hbFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGludGVnZXJQYXJ0ID0gbWFudGlzc2FQYXJ0O1xuICAgICAgICAgICAgICAgIGZyYWN0aW9uYWxQYXJ0ID0gc3VmZml4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnRlZ2VyUGFydCA9IG1hbnRpc3NhUGFydC5zdWJzdHJpbmcoMCwgZGVjaW1hbFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBmcmFjdGlvbmFsUGFydCA9IG1hbnRpc3NhUGFydC5zdWJzdHJpbmcoZGVjaW1hbFBvc2l0aW9uICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgICAgICAgIHN1ZmZpeDogc3VmZml4LFxuICAgICAgICAgICAgICAgIGFjdGl2ZVBhcnQ6IGFjdGl2ZVBhcnQsXG4gICAgICAgICAgICAgICAgbWFudGlzc2FQYXJ0OiBtYW50aXNzYVBhcnQsXG4gICAgICAgICAgICAgICAgZXhwb25lbnRQYXJ0OiBleHBvbmVudFBhcnQsXG4gICAgICAgICAgICAgICAgaW50ZWdlclBhcnQ6IGludGVnZXJQYXJ0LFxuICAgICAgICAgICAgICAgIGZyYWN0aW9uYWxQYXJ0OiBmcmFjdGlvbmFsUGFydCxcbiAgICAgICAgICAgICAgICBzdWJwaWN0dXJlOiBzdWJwaWN0dXJlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHZhbGlkYXRlIHRoZSBwaWN0dXJlIHN0cmluZywgRiZPIDQuNy4zXG4gICAgICAgIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgICAgICB2YXIgaWk7XG4gICAgICAgICAgICB2YXIgc3VicGljdHVyZSA9IHBhcnRzLnN1YnBpY3R1cmU7XG4gICAgICAgICAgICB2YXIgZGVjaW1hbFBvcyA9IHN1YnBpY3R1cmUuaW5kZXhPZihwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddKTtcbiAgICAgICAgICAgIGlmKGRlY2ltYWxQb3MgIT09IHN1YnBpY3R1cmUubGFzdEluZGV4T2YocHJvcGVydGllc1snZGVjaW1hbC1zZXBhcmF0b3InXSkpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA4MSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllcy5wZXJjZW50KSAhPT0gc3VicGljdHVyZS5sYXN0SW5kZXhPZihwcm9wZXJ0aWVzLnBlcmNlbnQpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAnRDMwODInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoc3VicGljdHVyZS5pbmRleE9mKHByb3BlcnRpZXNbJ3Blci1taWxsZSddKSAhPT0gc3VicGljdHVyZS5sYXN0SW5kZXhPZihwcm9wZXJ0aWVzWydwZXItbWlsbGUnXSkpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA4Myc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllcy5wZXJjZW50KSAhPT0gLTEgJiYgc3VicGljdHVyZS5pbmRleE9mKHByb3BlcnRpZXNbJ3Blci1taWxsZSddKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA4NCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvcihpaSA9IDA7IGlpIDwgcGFydHMubWFudGlzc2FQYXJ0Lmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaCA9IHBhcnRzLm1hbnRpc3NhUGFydC5jaGFyQXQoaWkpO1xuICAgICAgICAgICAgICAgIGlmKGRlY2ltYWxEaWdpdEZhbWlseS5pbmRleE9mKGNoKSAhPT0gLTEgfHwgY2ggPT09IHByb3BlcnRpZXMuZGlnaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZighdmFsaWQpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA4NSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hhclR5cGVzID0gcGFydHMuYWN0aXZlUGFydC5zcGxpdCgnJykubWFwKGZ1bmN0aW9uKGNoYXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0aXZlQ2hhcnMuaW5kZXhPZihjaGFyKSA9PT0gLTEgPyAncCcgOiAnYSc7XG4gICAgICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgICAgIGlmKGNoYXJUeXBlcy5pbmRleE9mKCdwJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAnRDMwODYnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGVjaW1hbFBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZihzdWJwaWN0dXJlLmNoYXJBdChkZWNpbWFsUG9zIC0gMSkgPT09IHByb3BlcnRpZXNbJ2dyb3VwaW5nLXNlcGFyYXRvciddIHx8IHN1YnBpY3R1cmUuY2hhckF0KGRlY2ltYWxQb3MgKyAxKSA9PT0gcHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSAnRDMwODcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZihwYXJ0cy5pbnRlZ2VyUGFydC5jaGFyQXQocGFydHMuaW50ZWdlclBhcnQubGVuZ3RoIC0gMSkgPT09IHByb3BlcnRpZXNbJ2dyb3VwaW5nLXNlcGFyYXRvciddKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAnRDMwODgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoc3VicGljdHVyZS5pbmRleE9mKHByb3BlcnRpZXNbJ2dyb3VwaW5nLXNlcGFyYXRvciddICsgcHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gJ0QzMDg5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvcHRpb25hbERpZ2l0UG9zID0gcGFydHMuaW50ZWdlclBhcnQuaW5kZXhPZihwcm9wZXJ0aWVzLmRpZ2l0KTtcbiAgICAgICAgICAgIGlmKG9wdGlvbmFsRGlnaXRQb3MgIT09IC0xICYmIHBhcnRzLmludGVnZXJQYXJ0LnN1YnN0cmluZygwLCBvcHRpb25hbERpZ2l0UG9zKS5zcGxpdCgnJykuZmlsdGVyKGZ1bmN0aW9uKGNoYXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjaW1hbERpZ2l0RmFtaWx5LmluZGV4T2YoY2hhcikgPiAtMTtcbiAgICAgICAgICAgIH0pLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdEMzA5MCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25hbERpZ2l0UG9zID0gcGFydHMuZnJhY3Rpb25hbFBhcnQubGFzdEluZGV4T2YocHJvcGVydGllcy5kaWdpdCk7XG4gICAgICAgICAgICBpZihvcHRpb25hbERpZ2l0UG9zICE9PSAtMSAmJiBwYXJ0cy5mcmFjdGlvbmFsUGFydC5zdWJzdHJpbmcob3B0aW9uYWxEaWdpdFBvcykuc3BsaXQoJycpLmZpbHRlcihmdW5jdGlvbihjaGFyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY2ltYWxEaWdpdEZhbWlseS5pbmRleE9mKGNoYXIpID4gLTE7XG4gICAgICAgICAgICB9KS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAnRDMwOTEnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGV4cG9uZW50RXhpc3RzID0gKHR5cGVvZiBwYXJ0cy5leHBvbmVudFBhcnQgPT09ICdzdHJpbmcnKTtcbiAgICAgICAgICAgIGlmKGV4cG9uZW50RXhpc3RzICYmIHBhcnRzLmV4cG9uZW50UGFydC5sZW5ndGggPiAwICYmIChzdWJwaWN0dXJlLmluZGV4T2YocHJvcGVydGllcy5wZXJjZW50KSAhPT0gLTEgfHwgc3VicGljdHVyZS5pbmRleE9mKHByb3BlcnRpZXNbJ3Blci1taWxsZSddKSAhPT0gLTEpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAnRDMwOTInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZXhwb25lbnRFeGlzdHMgJiYgKHBhcnRzLmV4cG9uZW50UGFydC5sZW5ndGggPT09IDAgfHwgcGFydHMuZXhwb25lbnRQYXJ0LnNwbGl0KCcnKS5maWx0ZXIoZnVuY3Rpb24oY2hhcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNpbWFsRGlnaXRGYW1pbHkuaW5kZXhPZihjaGFyKSA9PT0gLTE7XG4gICAgICAgICAgICB9KS5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gJ0QzMDkzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2tcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFuYWx5c2UgdGhlIHBpY3R1cmUgc3RyaW5nLCBGJk8gNC43LjRcbiAgICAgICAgdmFyIGFuYWx5c2UgPSBmdW5jdGlvbihwYXJ0cykge1xuICAgICAgICAgICAgdmFyIGdldEdyb3VwaW5nUG9zaXRpb25zID0gZnVuY3Rpb24ocGFydCwgdG9MZWZ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBncm91cGluZ1Bvc2l0aW9uID0gcGFydC5pbmRleE9mKHByb3BlcnRpZXNbJ2dyb3VwaW5nLXNlcGFyYXRvciddKTtcbiAgICAgICAgICAgICAgICB3aGlsZShncm91cGluZ1Bvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhcnNUb1RoZVJpZ2h0ID0gKHRvTGVmdCA/IHBhcnQuc3Vic3RyaW5nKDAsIGdyb3VwaW5nUG9zaXRpb24pIDogcGFydC5zdWJzdHJpbmcoZ3JvdXBpbmdQb3NpdGlvbikpLnNwbGl0KCcnKS5maWx0ZXIoZnVuY3Rpb24oY2hhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY2ltYWxEaWdpdEZhbWlseS5pbmRleE9mKGNoYXIpICE9PSAtMSB8fCBjaGFyID09PSBwcm9wZXJ0aWVzLmRpZ2l0O1xuICAgICAgICAgICAgICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKGNoYXJzVG9UaGVSaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwaW5nUG9zaXRpb24gPSBwYXJ0cy5pbnRlZ2VyUGFydC5pbmRleE9mKHByb3BlcnRpZXNbJ2dyb3VwaW5nLXNlcGFyYXRvciddLCBncm91cGluZ1Bvc2l0aW9uICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbnM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGludGVnZXJQYXJ0R3JvdXBpbmdQb3NpdGlvbnMgPSBnZXRHcm91cGluZ1Bvc2l0aW9ucyhwYXJ0cy5pbnRlZ2VyUGFydCk7XG4gICAgICAgICAgICB2YXIgcmVndWxhciA9IGZ1bmN0aW9uKGluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBhcmUgdGhlIGdyb3VwaW5nIHBvc2l0aW9ucyByZWd1bGFyPyBpLmUuIHNhbWUgaW50ZXJ2YWwgYmV0d2VlbiBlYWNoIG9mIHRoZW1cbiAgICAgICAgICAgICAgICBpZihpbmRleGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGdjZCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGIgPT09IDAgPyBhIDogZ2NkKGIsIGEgJSBiKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIGdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yIG9mIGFsbCB0aGUgcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IGluZGV4ZXMucmVkdWNlKGdjZCk7XG4gICAgICAgICAgICAgICAgLy8gaXMgZXZlcnkgcG9zaXRpb24gc2VwYXJhdGVkIGJ5IHRoaXMgZGl2aXNvcj8gSWYgc28sIGl0J3MgcmVndWxhclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaW5kZXggPSAxOyBpbmRleCA8PSBpbmRleGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBpZihpbmRleGVzLmluZGV4T2YoaW5kZXggKiBmYWN0b3IpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhY3RvcjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciByZWd1bGFyR3JvdXBpbmcgPSByZWd1bGFyKGludGVnZXJQYXJ0R3JvdXBpbmdQb3NpdGlvbnMpO1xuICAgICAgICAgICAgdmFyIGZyYWN0aW9uYWxQYXJ0R3JvdXBpbmdQb3NpdGlvbnMgPSBnZXRHcm91cGluZ1Bvc2l0aW9ucyhwYXJ0cy5mcmFjdGlvbmFsUGFydCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciBtaW5pbXVtSW50ZWdlclBhcnRTaXplID0gcGFydHMuaW50ZWdlclBhcnQuc3BsaXQoJycpLmZpbHRlcihmdW5jdGlvbihjaGFyKSB7IHJldHVybiBkZWNpbWFsRGlnaXRGYW1pbHkuaW5kZXhPZihjaGFyKSAhPT0gLTE7IH0pLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBzY2FsaW5nRmFjdG9yID0gbWluaW11bUludGVnZXJQYXJ0U2l6ZTtcblxuICAgICAgICAgICAgdmFyIGZyYWN0aW9uYWxQYXJ0QXJyYXkgPSBwYXJ0cy5mcmFjdGlvbmFsUGFydC5zcGxpdCgnJyk7XG4gICAgICAgICAgICB2YXIgbWluaW11bUZhY3Rpb25hbFBhcnRTaXplID0gZnJhY3Rpb25hbFBhcnRBcnJheS5maWx0ZXIoZnVuY3Rpb24oY2hhcikgeyByZXR1cm4gZGVjaW1hbERpZ2l0RmFtaWx5LmluZGV4T2YoY2hhcikgIT09IC0xOyB9KS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgbWF4aW11bUZhY3Rpb25hbFBhcnRTaXplID0gZnJhY3Rpb25hbFBhcnRBcnJheS5maWx0ZXIoZnVuY3Rpb24oY2hhcikgeyByZXR1cm4gZGVjaW1hbERpZ2l0RmFtaWx5LmluZGV4T2YoY2hhcikgIT09IC0xIHx8IGNoYXIgPT09IHByb3BlcnRpZXMuZGlnaXQ7IH0pLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBleHBvbmVudFByZXNlbnQgPSB0eXBlb2YgcGFydHMuZXhwb25lbnRQYXJ0ID09PSAnc3RyaW5nJztcbiAgICAgICAgICAgIGlmKG1pbmltdW1JbnRlZ2VyUGFydFNpemUgPT09IDAgJiYgbWF4aW11bUZhY3Rpb25hbFBhcnRTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYoZXhwb25lbnRQcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW1GYWN0aW9uYWxQYXJ0U2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIG1heGltdW1GYWN0aW9uYWxQYXJ0U2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bUludGVnZXJQYXJ0U2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZXhwb25lbnRQcmVzZW50ICYmIG1pbmltdW1JbnRlZ2VyUGFydFNpemUgPT09IDAgJiYgcGFydHMuaW50ZWdlclBhcnQuaW5kZXhPZihwcm9wZXJ0aWVzLmRpZ2l0KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBtaW5pbXVtSW50ZWdlclBhcnRTaXplID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKG1pbmltdW1JbnRlZ2VyUGFydFNpemUgPT09IDAgJiYgbWluaW11bUZhY3Rpb25hbFBhcnRTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWluaW11bUZhY3Rpb25hbFBhcnRTaXplID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtaW5pbXVtRXhwb25lbnRTaXplID0gMDtcbiAgICAgICAgICAgIGlmKGV4cG9uZW50UHJlc2VudCkge1xuICAgICAgICAgICAgICAgIG1pbmltdW1FeHBvbmVudFNpemUgPSBwYXJ0cy5leHBvbmVudFBhcnQuc3BsaXQoJycpLmZpbHRlcihmdW5jdGlvbihjaGFyKSB7IHJldHVybiBkZWNpbWFsRGlnaXRGYW1pbHkuaW5kZXhPZihjaGFyKSAhPT0gLTE7IH0pLmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbnRlZ2VyUGFydEdyb3VwaW5nUG9zaXRpb25zOiBpbnRlZ2VyUGFydEdyb3VwaW5nUG9zaXRpb25zLFxuICAgICAgICAgICAgICAgIHJlZ3VsYXJHcm91cGluZzogcmVndWxhckdyb3VwaW5nLFxuICAgICAgICAgICAgICAgIG1pbmltdW1JbnRlZ2VyUGFydFNpemU6IG1pbmltdW1JbnRlZ2VyUGFydFNpemUsXG4gICAgICAgICAgICAgICAgc2NhbGluZ0ZhY3Rvcjogc2NhbGluZ0ZhY3RvcixcbiAgICAgICAgICAgICAgICBwcmVmaXg6IHBhcnRzLnByZWZpeCxcbiAgICAgICAgICAgICAgICBmcmFjdGlvbmFsUGFydEdyb3VwaW5nUG9zaXRpb25zOiBmcmFjdGlvbmFsUGFydEdyb3VwaW5nUG9zaXRpb25zLFxuICAgICAgICAgICAgICAgIG1pbmltdW1GYWN0aW9uYWxQYXJ0U2l6ZTogbWluaW11bUZhY3Rpb25hbFBhcnRTaXplLFxuICAgICAgICAgICAgICAgIG1heGltdW1GYWN0aW9uYWxQYXJ0U2l6ZTogbWF4aW11bUZhY3Rpb25hbFBhcnRTaXplLFxuICAgICAgICAgICAgICAgIG1pbmltdW1FeHBvbmVudFNpemU6IG1pbmltdW1FeHBvbmVudFNpemUsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBwYXJ0cy5zdWZmaXgsXG4gICAgICAgICAgICAgICAgcGljdHVyZTogcGFydHMuc3VicGljdHVyZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcGFydHMgPSBzdWJQaWN0dXJlcy5tYXAoc3BsaXRQYXJ0cyk7XG4gICAgICAgIHBhcnRzLmZvckVhY2godmFsaWRhdGUpO1xuXG4gICAgICAgIHZhciB2YXJpYWJsZXMgPSBwYXJ0cy5tYXAoYW5hbHlzZSk7XG5cbiAgICAgICAgaWYodmFyaWFibGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFyaWFibGVzLnB1c2goSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YXJpYWJsZXNbMF0pKSk7XG4gICAgICAgICAgICB2YXJpYWJsZXNbMV0ucHJlZml4ID0gcHJvcGVydGllc1snbWludXMtc2lnbiddICsgdmFyaWFibGVzWzFdLnByZWZpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE8gY2FjaGUgdGhlIHJlc3VsdCBvZiB0aGUgYW5hbHlzaXNcblxuICAgICAgICAvLyBmb3JtYXQgdGhlIG51bWJlclxuICAgICAgICAvLyBidWxsZXQgMTogVE9ETzogTmFOIC0gbm90IHN1cmUgd2UnZCBldmVyIGdldCB0aGlzIGluIEpTT05cbiAgICAgICAgdmFyIHBpYztcbiAgICAgICAgLy8gYnVsbGV0IDI6XG4gICAgICAgIGlmKHZhbHVlID49IDApIHtcbiAgICAgICAgICAgIHBpYyA9IHZhcmlhYmxlc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBpYyA9IHZhcmlhYmxlc1sxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWRqdXN0ZWROdW1iZXI7XG4gICAgICAgIC8vIGJ1bGxldCAzOlxuICAgICAgICBpZihwaWMucGljdHVyZS5pbmRleE9mKHByb3BlcnRpZXMucGVyY2VudCkgIT09IC0xKSB7XG4gICAgICAgICAgICBhZGp1c3RlZE51bWJlciA9IHZhbHVlICogMTAwO1xuICAgICAgICB9IGVsc2UgaWYocGljLnBpY3R1cmUuaW5kZXhPZihwcm9wZXJ0aWVzWydwZXItbWlsbGUnXSkgIT09IC0xKSB7XG4gICAgICAgICAgICBhZGp1c3RlZE51bWJlciA9IHZhbHVlICogMTAwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkanVzdGVkTnVtYmVyID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnVsbGV0IDQ6XG4gICAgICAgIC8vIFRPRE86IGluZmluaXR5IC0gbm90IHN1cmUgd2UnZCBldmVyIGdldCB0aGlzIGluIEpTT05cbiAgICAgICAgLy8gYnVsbGV0IDU6XG4gICAgICAgIHZhciBtYW50aXNzYSwgZXhwb25lbnQ7XG4gICAgICAgIGlmKHBpYy5taW5pbXVtRXhwb25lbnRTaXplID09PSAwKSB7XG4gICAgICAgICAgICBtYW50aXNzYSA9IGFkanVzdGVkTnVtYmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbWFudGlzc2EgKiAxMF5leHBvbmVudCA9IGFkanVzdGVkTnVtYmVyXG4gICAgICAgICAgICB2YXIgbWF4TWFudGlzc2EgPSBNYXRoLnBvdygxMCwgcGljLnNjYWxpbmdGYWN0b3IpO1xuICAgICAgICAgICAgdmFyIG1pbk1hbnRpc3NhID0gTWF0aC5wb3coMTAsIHBpYy5zY2FsaW5nRmFjdG9yIC0gMSk7XG4gICAgICAgICAgICBtYW50aXNzYSA9IGFkanVzdGVkTnVtYmVyO1xuICAgICAgICAgICAgZXhwb25lbnQgPSAwO1xuICAgICAgICAgICAgd2hpbGUobWFudGlzc2EgPCBtaW5NYW50aXNzYSkge1xuICAgICAgICAgICAgICAgIG1hbnRpc3NhICo9IDEwO1xuICAgICAgICAgICAgICAgIGV4cG9uZW50IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZShtYW50aXNzYSA+IG1heE1hbnRpc3NhKSB7XG4gICAgICAgICAgICAgICAgbWFudGlzc2EgLz0gMTA7XG4gICAgICAgICAgICAgICAgZXhwb25lbnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBidWxsZXQgNjpcbiAgICAgICAgdmFyIHJvdW5kZWROdW1iZXIgPSBmdW5jdGlvblJvdW5kKG1hbnRpc3NhLCBwaWMubWF4aW11bUZhY3Rpb25hbFBhcnRTaXplKTtcbiAgICAgICAgLy8gYnVsbGV0IDc6XG4gICAgICAgIHZhciBtYWtlU3RyaW5nID0gZnVuY3Rpb24odmFsdWUsIGRwKSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gTWF0aC5hYnModmFsdWUpLnRvRml4ZWQoZHApO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNbJ3plcm8tZGlnaXQnXSAhPT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24gKGRpZ2l0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGRpZ2l0ID49ICcwJyAmJiBkaWdpdCA8PSc5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY2ltYWxEaWdpdEZhbWlseVtkaWdpdC5jaGFyQ29kZUF0KDApIC0gNDhdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZ2l0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuam9pbignJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSBtYWtlU3RyaW5nKHJvdW5kZWROdW1iZXIsIHBpYy5tYXhpbXVtRmFjdGlvbmFsUGFydFNpemUpO1xuICAgICAgICB2YXIgZGVjaW1hbFBvcyA9IHN0cmluZ1ZhbHVlLmluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYoZGVjaW1hbFBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gc3RyaW5nVmFsdWUgKyBwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZS5yZXBsYWNlKCcuJywgcHJvcGVydGllc1snZGVjaW1hbC1zZXBhcmF0b3InXSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUoc3RyaW5nVmFsdWUuY2hhckF0KDApID09PSBwcm9wZXJ0aWVzWyd6ZXJvLWRpZ2l0J10pIHtcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gc3RyaW5nVmFsdWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlKHN0cmluZ1ZhbHVlLmNoYXJBdChzdHJpbmdWYWx1ZS5sZW5ndGggLSAxKSA9PT0gcHJvcGVydGllc1snemVyby1kaWdpdCddKSB7XG4gICAgICAgICAgICBzdHJpbmdWYWx1ZSA9IHN0cmluZ1ZhbHVlLnN1YnN0cmluZygwLCBzdHJpbmdWYWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBidWxsZXRzIDggJiA5OlxuICAgICAgICBkZWNpbWFsUG9zID0gc3RyaW5nVmFsdWUuaW5kZXhPZihwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddKTtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBwaWMubWluaW11bUludGVnZXJQYXJ0U2l6ZSAtIGRlY2ltYWxQb3M7XG4gICAgICAgIHZhciBwYWRSaWdodCA9IHBpYy5taW5pbXVtRmFjdGlvbmFsUGFydFNpemUgLSAoc3RyaW5nVmFsdWUubGVuZ3RoIC0gZGVjaW1hbFBvcyAtIDEpO1xuICAgICAgICBzdHJpbmdWYWx1ZSA9IChwYWRMZWZ0ID4gMCA/IG5ldyBBcnJheShwYWRMZWZ0ICsgMSkuam9pbignMCcpIDogJycpICsgc3RyaW5nVmFsdWU7XG4gICAgICAgIHN0cmluZ1ZhbHVlID0gc3RyaW5nVmFsdWUgKyAocGFkUmlnaHQgPiAwID8gbmV3IEFycmF5KHBhZFJpZ2h0ICsgMSkuam9pbignMCcpIDogJycpO1xuICAgICAgICBkZWNpbWFsUG9zID0gc3RyaW5nVmFsdWUuaW5kZXhPZihwcm9wZXJ0aWVzWydkZWNpbWFsLXNlcGFyYXRvciddKTtcbiAgICAgICAgLy8gYnVsbGV0IDEwOlxuICAgICAgICBpZihwaWMucmVndWxhckdyb3VwaW5nID4gMCkge1xuICAgICAgICAgICAgdmFyIGdyb3VwQ291bnQgPSBNYXRoLmZsb29yKChkZWNpbWFsUG9zIC0gMSkgLyBwaWMucmVndWxhckdyb3VwaW5nKTtcbiAgICAgICAgICAgIGZvcih2YXIgZ3JvdXAgPSAxOyBncm91cCA8PSBncm91cENvdW50OyBncm91cCsrKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSBbc3RyaW5nVmFsdWUuc2xpY2UoMCwgZGVjaW1hbFBvcyAtIGdyb3VwICogcGljLnJlZ3VsYXJHcm91cGluZyksIHByb3BlcnRpZXNbJ2dyb3VwaW5nLXNlcGFyYXRvciddLCBzdHJpbmdWYWx1ZS5zbGljZShkZWNpbWFsUG9zIC0gZ3JvdXAgKiBwaWMucmVndWxhckdyb3VwaW5nKV0uam9pbignJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwaWMuaW50ZWdlclBhcnRHcm91cGluZ1Bvc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmdWYWx1ZSA9IFtzdHJpbmdWYWx1ZS5zbGljZSgwLCBkZWNpbWFsUG9zIC0gcG9zKSwgcHJvcGVydGllc1snZ3JvdXBpbmctc2VwYXJhdG9yJ10sIHN0cmluZ1ZhbHVlLnNsaWNlKGRlY2ltYWxQb3MgLSBwb3MpXS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICBkZWNpbWFsUG9zKys7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBidWxsZXQgMTE6XG4gICAgICAgIGRlY2ltYWxQb3MgPSBzdHJpbmdWYWx1ZS5pbmRleE9mKHByb3BlcnRpZXNbJ2RlY2ltYWwtc2VwYXJhdG9yJ10pO1xuICAgICAgICBwaWMuZnJhY3Rpb25hbFBhcnRHcm91cGluZ1Bvc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHBvcykge1xuICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSBbc3RyaW5nVmFsdWUuc2xpY2UoMCwgcG9zICsgZGVjaW1hbFBvcyArIDEpLCBwcm9wZXJ0aWVzWydncm91cGluZy1zZXBhcmF0b3InXSwgc3RyaW5nVmFsdWUuc2xpY2UocG9zICsgZGVjaW1hbFBvcyArIDEpXS5qb2luKCcnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGJ1bGxldCAxMjpcbiAgICAgICAgZGVjaW1hbFBvcyA9IHN0cmluZ1ZhbHVlLmluZGV4T2YocHJvcGVydGllc1snZGVjaW1hbC1zZXBhcmF0b3InXSk7XG4gICAgICAgIGlmKHBpYy5waWN0dXJlLmluZGV4T2YocHJvcGVydGllc1snZGVjaW1hbC1zZXBhcmF0b3InXSkgPT09IC0xIHx8IGRlY2ltYWxQb3MgPT09IHN0cmluZ1ZhbHVlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gc3RyaW5nVmFsdWUuc3Vic3RyaW5nKDAsIHN0cmluZ1ZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ1bGxldCAxMzpcbiAgICAgICAgaWYodHlwZW9mIGV4cG9uZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdmFyIHN0cmluZ0V4cG9uZW50ID0gbWFrZVN0cmluZyhleHBvbmVudCwgMCk7XG4gICAgICAgICAgICBwYWRMZWZ0ID0gcGljLm1pbmltdW1FeHBvbmVudFNpemUgLSBzdHJpbmdFeHBvbmVudC5sZW5ndGg7XG4gICAgICAgICAgICBpZihwYWRMZWZ0ID4gMCkge1xuICAgICAgICAgICAgICAgIHN0cmluZ0V4cG9uZW50ID0gbmV3IEFycmF5KHBhZExlZnQgKyAxKS5qb2luKCcwJykgKyBzdHJpbmdFeHBvbmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlID0gc3RyaW5nVmFsdWUgKyBwcm9wZXJ0aWVzWydleHBvbmVudC1zZXBhcmF0b3InXSArIChleHBvbmVudCA8IDAgPyBwcm9wZXJ0aWVzWydtaW51cy1zaWduJ10gOiAnJykgKyBzdHJpbmdFeHBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBidWxsZXQgMTQ6XG4gICAgICAgIHN0cmluZ1ZhbHVlID0gcGljLnByZWZpeCArIHN0cmluZ1ZhbHVlICsgcGljLnN1ZmZpeDtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgbnVtYmVyIHRvIGEgc3RyaW5nIHVzaW5nIGEgc3BlY2lmaWVkIG51bWJlciBiYXNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gdGhlIG51bWJlciB0byBjb252ZXJ0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpeF0gLSB0aGUgbnVtYmVyIGJhc2U7IG11c3QgYmUgYmV0d2VlbiAyIGFuZCAzNi4gRGVmYXVsdHMgdG8gMTBcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBjb252ZXJ0ZWQgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Gb3JtYXRCYXNlKHZhbHVlLCByYWRpeCkge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IGZ1bmN0aW9uUm91bmQodmFsdWUpO1xuXG4gICAgICAgIGlmKHR5cGVvZiByYWRpeCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJhZGl4ID0gMTA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYWRpeCA9IGZ1bmN0aW9uUm91bmQocmFkaXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocmFkaXggPCAyIHx8IHJhZGl4ID4gMzYpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBjb2RlOiAnRDMxMDAnLFxuICAgICAgICAgICAgICAgIHN0YWNrOiAobmV3IEVycm9yKCkpLnN0YWNrLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByYWRpeFxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKHJhZGl4KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3QgYXJndW1lbnQgdG8gbnVtYmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZyAtIEFyZ3VtZW50XG4gICAgICogQHJldHVybnMge051bWJlcn0gbnVtZXJpYyB2YWx1ZSBvZiBhcmd1bWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uTnVtYmVyKGFyZykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGFscmVhZHkgYSBudW1iZXJcbiAgICAgICAgICAgIHJlc3VsdCA9IGFyZztcbiAgICAgICAgfSBlbHNlIGlmKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnICYmIC9eLT8oMHwoWzEtOV1bMC05XSopKShcXC5bMC05XSspPyhbRWVdWy0rXT9bMC05XSspPyQvLnRlc3QoYXJnKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChhcmcpKSAmJiBpc0Zpbml0ZShhcmcpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJzZUZsb2F0KGFyZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgY29kZTogXCJEMzAzMFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhcmcsXG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgaW5kZXg6IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBYnNvbHV0ZSB2YWx1ZSBvZiBhIG51bWJlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmcgLSBBcmd1bWVudFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IGFic29sdXRlIHZhbHVlIG9mIGFyZ3VtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25BYnMoYXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IE1hdGguYWJzKGFyZyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUm91bmRzIGEgbnVtYmVyIGRvd24gdG8gaW50ZWdlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmcgLSBBcmd1bWVudFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHJvdW5kZWQgaW50ZWdlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uRmxvb3IoYXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IE1hdGguZmxvb3IoYXJnKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3VuZHMgYSBudW1iZXIgdXAgdG8gaW50ZWdlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmcgLSBBcmd1bWVudFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHJvdW5kZWQgaW50ZWdlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uQ2VpbChhcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gTWF0aC5jZWlsKGFyZyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUm91bmQgdG8gaGFsZiBldmVuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZyAtIEFyZ3VtZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByZWNpc2lvbiAtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHJvdW5kZWQgaW50ZWdlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uUm91bmQoYXJnLCBwcmVjaXNpb24pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAvLyBzaGlmdCB0aGUgZGVjaW1hbCBwbGFjZSAtIHRoaXMgbmVlZHMgdG8gYmUgZG9uZSBpbiBhIHN0cmluZyBzaW5jZSBtdWx0aXBseWluZ1xuICAgICAgICAgICAgLy8gYnkgYSBwb3dlciBvZiB0ZW4gY2FuIGludHJvZHVjZSBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24gZXJyb3JzIHdoaWNoIG1lc3MgdXBcbiAgICAgICAgICAgIC8vIHRoaXMgcm91bmRpbmcgYWxnb3JpdGhtIC0gU2VlICdEZWNpbWFsIHJvdW5kaW5nJyBpblxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9yb3VuZFxuICAgICAgICAgICAgLy8gU2hpZnRcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFyZy50b1N0cmluZygpLnNwbGl0KCdlJyk7XG4gICAgICAgICAgICBhcmcgPSArKHZhbHVlWzBdICsgJ2UnICsgKHZhbHVlWzFdID8gKCt2YWx1ZVsxXSArIHByZWNpc2lvbikgOiBwcmVjaXNpb24pKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcm91bmQgdXAgdG8gbmVhcmVzdCBpbnRcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5yb3VuZChhcmcpO1xuICAgICAgICB2YXIgZGlmZiA9IHJlc3VsdCAtIGFyZztcbiAgICAgICAgaWYoTWF0aC5hYnMoZGlmZikgPT09IDAuNSAmJiBNYXRoLmFicyhyZXN1bHQgJSAyKSA9PT0gMSkge1xuICAgICAgICAgICAgLy8gcm91bmRlZCB0aGUgd3Jvbmcgd2F5IC0gYWRqdXN0IHRvIG5lYXJlc3QgZXZlbiBudW1iZXJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYocHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAvLyBTaGlmdCBiYWNrXG4gICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdC50b1N0cmluZygpLnNwbGl0KCdlJyk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgcmVzdWx0ID0gKyh2YWx1ZVswXSArICdlJyArICh2YWx1ZVsxXSA/ICgrdmFsdWVbMV0gLSBwcmVjaXNpb24pIDogLXByZWNpc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIGlmKE9iamVjdC5pcyhyZXN1bHQsIC0wKSkgeyAvLyBFU0xpbnQgcnVsZSAnbm8tY29tcGFyZS1uZWctemVybycgc3VnZ2VzdHMgdGhpcyB3YXlcbiAgICAgICAgICAgIC8vIEpTT04gZG9lc24ndCBkbyAtMFxuICAgICAgICAgICAgcmVzdWx0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNxdWFyZSByb290IG9mIG51bWJlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmcgLSBBcmd1bWVudFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZSByb290XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25TcXJ0KGFyZykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihhcmcgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgY29kZTogXCJEMzA2MFwiLFxuICAgICAgICAgICAgICAgIGluZGV4OiAxLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhcmdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBNYXRoLnNxcnQoYXJnKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJhaXNlcyBudW1iZXIgdG8gdGhlIHBvd2VyIG9mIHRoZSBzZWNvbmQgbnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyZyAtIHRoZSBiYXNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGV4cCAtIHRoZSBleHBvbmVudFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHJvdW5kZWQgaW50ZWdlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uUG93ZXIoYXJnLCBleHApIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gTWF0aC5wb3coYXJnLCBleHApO1xuXG4gICAgICAgIGlmKCFpc0Zpbml0ZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgY29kZTogXCJEMzA2MVwiLFxuICAgICAgICAgICAgICAgIGluZGV4OiAxLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhcmcsXG4gICAgICAgICAgICAgICAgZXhwOiBleHBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByYW5kb20gbnVtYmVyIDAgPD0gbiA8IDFcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSByYW5kb20gbnVtYmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25SYW5kb20oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGFuIGlucHV0IGFuZCByZXR1cm4gYSBib29sZWFuXG4gICAgICogQHBhcmFtIHsqfSBhcmcgLSBBcmd1bWVudHNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gQm9vbGVhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uQm9vbGVhbihhcmcpIHtcbiAgICAgICAgLy8gY2FzdCBhcmcgdG8gaXRzIGVmZmVjdGl2ZSBib29sZWFuIHZhbHVlXG4gICAgICAgIC8vIGJvb2xlYW46IHVuY2hhbmdlZFxuICAgICAgICAvLyBzdHJpbmc6IHplcm8tbGVuZ3RoIC0+IGZhbHNlOyBvdGhlcndpc2UgLT4gdHJ1ZVxuICAgICAgICAvLyBudW1iZXI6IDAgLT4gZmFsc2U7IG90aGVyd2lzZSAtPiB0cnVlXG4gICAgICAgIC8vIG51bGwgLT4gZmFsc2VcbiAgICAgICAgLy8gYXJyYXk6IGVtcHR5IC0+IGZhbHNlOyBsZW5ndGggPiAxIC0+IHRydWVcbiAgICAgICAgLy8gb2JqZWN0OiBlbXB0eSAtPiBmYWxzZTsgbm9uLWVtcHR5IC0+IHRydWVcbiAgICAgICAgLy8gZnVuY3Rpb24gLT4gZmFsc2VcblxuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICBpZiAoYXJnLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uQm9vbGVhbihhcmdbMF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciB0cnVlcyA9IGFyZy5maWx0ZXIoZnVuY3Rpb24odmFsKSB7cmV0dXJuIGZ1bmN0aW9uQm9vbGVhbih2YWwpO30pO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWVzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1lcmljKGFyZykpIHtcbiAgICAgICAgICAgIGlmIChhcmcgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFyZyAhPT0gbnVsbCAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGFyZykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBpdCdzIG5vdCBhIGxhbWJkYSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGlmICghKGlzTGFtYmRhKGFyZykgfHwgYXJnLl9qc29uYXRhX2Z1bmN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgJiYgYXJnID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgQm9vbGVhbiBOT1Qgb2YgdGhlIGFyZ1xuICAgICAqIEBwYXJhbSB7Kn0gYXJnIC0gYXJndW1lbnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBOT1QgYXJnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Ob3QoYXJnKSB7XG4gICAgICAgIHJldHVybiAhZnVuY3Rpb25Cb29sZWFuKGFyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbWFwIGZyb20gYW4gYXJyYXkgb2YgYXJndW1lbnRzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2Fycl0gLSBhcnJheSB0byBtYXAgb3ZlclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgLSBmdW5jdGlvbiB0byBhcHBseVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gTWFwIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24qIGZ1bmN0aW9uTWFwKGFyciwgZnVuYykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcnIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAvLyBkbyB0aGUgbWFwIC0gaXRlcmF0ZSBvdmVyIHRoZSBhcnJheXMsIGFuZCBpbnZva2UgZnVuY1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZ1bmNfYXJncyA9IFthcnJbaV1dOyAvLyB0aGUgZmlyc3QgYXJnICh2YWx1ZSkgaXMgcmVxdWlyZWRcbiAgICAgICAgICAgIC8vIHRoZSBvdGhlciB0d28gYXJlIG9wdGlvbmFsIC0gb25seSBzdXBwbHkgaXQgaWYgdGhlIGZ1bmN0aW9uIGNhbiB0YWtlIGl0XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicgPyBmdW5jLmxlbmd0aCA6XG4gICAgICAgICAgICAgICAgZnVuYy5fanNvbmF0YV9mdW5jdGlvbiA9PT0gdHJ1ZSA/IGZ1bmMuaW1wbGVtZW50YXRpb24ubGVuZ3RoIDogZnVuYy5hcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgaWYobGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICBmdW5jX2FyZ3MucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICAgICAgZnVuY19hcmdzLnB1c2goYXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGludm9rZSBmdW5jXG4gICAgICAgICAgICB2YXIgcmVzID0geWllbGQgKiBhcHBseShmdW5jLCBmdW5jX2FyZ3MsIG51bGwpO1xuICAgICAgICAgICAgaWYodHlwZW9mIHJlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGdlbmVyYXRvciBmdW5jdGlvbiBkb2VzIG5vdCBoYXZlIGEgeWllbGQoKSwgcHJlc3VtYWJseSB0byBtYWtlIGl0XG4gICAgLy8gY29uc2lzdGVudCB3aXRoIG90aGVyIHNpbWlsYXIgZnVuY3Rpb25zLlxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG1hcCBmcm9tIGFuIGFycmF5IG9mIGFyZ3VtZW50c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJdIC0gYXJyYXkgdG8gZmlsdGVyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIHByZWRpY2F0ZSBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gTWFwIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24qIGZ1bmN0aW9uRmlsdGVyKGFyciwgZnVuYykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUteWllbGRcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICB2YXIgcHJlZGljYXRlID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBpdCA9IGFwcGx5KGZ1bmMsIFt2YWx1ZSwgaW5kZXgsIGFycmF5XSwgbnVsbCk7XG4gICAgICAgICAgICAvLyByZXR1cm5zIGEgZ2VuZXJhdG9yIC0gc28gaXRlcmF0ZSBvdmVyIGl0XG4gICAgICAgICAgICB2YXIgcmVzID0gaXQubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKCFyZXMuZG9uZSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IGl0Lm5leHQocmVzLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMudmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gYXJyW2ldO1xuICAgICAgICAgICAgaWYoZnVuY3Rpb25Cb29sZWFuKHByZWRpY2F0ZShlbnRyeSwgaSwgYXJyKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZvbHZlcyAoemlwcykgZWFjaCB2YWx1ZSBmcm9tIGEgc2V0IG9mIGFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXSAtIGFycmF5cyB0byB6aXBcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFppcHBlZCBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uWmlwKCkge1xuICAgICAgICAvLyB0aGlzIGNhbiB0YWtlIGEgdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgLy8gbGVuZ3RoIG9mIHRoZSBzaG9ydGVzdCBhcnJheVxuICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgYXJncy5tYXAoZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9KSk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHR1cGxlID0gYXJncy5tYXAoKGFyZykgPT4ge3JldHVybiBhcmdbaV07fSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0dXBsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb2xkIGxlZnQgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzZXF1ZW5jZSAtIFNlcXVlbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGluaXQgLSBJbml0aWFsIHZhbHVlXG4gICAgICogQHJldHVybnMgeyp9IFJlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uKiBmdW5jdGlvbkZvbGRMZWZ0KHNlcXVlbmNlLCBmdW5jLCBpbml0KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIHNlcXVlbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgaWYgKCEoZnVuYy5sZW5ndGggPT09IDIgfHwgKGZ1bmMuX2pzb25hdGFfZnVuY3Rpb24gPT09IHRydWUgJiYgZnVuYy5pbXBsZW1lbnRhdGlvbi5sZW5ndGggPT09IDIpIHx8IGZ1bmMuYXJndW1lbnRzLmxlbmd0aCA9PT0gMikpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBzdGFjazogKG5ldyBFcnJvcigpKS5zdGFjayxcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkQzMDUwXCIsXG4gICAgICAgICAgICAgICAgaW5kZXg6IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIGlmICh0eXBlb2YgaW5pdCA9PT0gJ3VuZGVmaW5lZCcgJiYgc2VxdWVuY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc2VxdWVuY2VbMF07XG4gICAgICAgICAgICBpbmRleCA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpbml0O1xuICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgc2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB5aWVsZCAqIGFwcGx5KGZ1bmMsIFtyZXN1bHQsIHNlcXVlbmNlW2luZGV4XV0sIG51bGwpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGtleXMgZm9yIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmcgLSBPYmplY3RcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGtleXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbktleXMoYXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZihBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgIC8vIG1lcmdlIHRoZSBrZXlzIG9mIGFsbCBvZiB0aGUgaXRlbXMgaW4gdGhlIGFycmF5XG4gICAgICAgICAgICB2YXIgbWVyZ2UgPSB7fTtcbiAgICAgICAgICAgIGFyZy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IGZ1bmN0aW9uS2V5cyhpdGVtKTtcbiAgICAgICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uS2V5cyhtZXJnZSk7XG4gICAgICAgIH0gZWxzZSBpZihhcmcgIT09IG51bGwgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgIShpc0xhbWJkYShhcmcpKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gT2JqZWN0LmtleXMoYXJnKTtcbiAgICAgICAgICAgIGlmKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdmFsdWUgZnJvbSBhbiBvYmplY3QgZm9yIGEgZ2l2ZW4ga2V5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIE9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBLZXkgaW4gb2JqZWN0XG4gICAgICogQHJldHVybnMgeyp9IFZhbHVlIG9mIGtleSBpbiBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkxvb2t1cChvYmplY3QsIGtleSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZXZhbHVhdGVOYW1lKHt2YWx1ZToga2V5fSwgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgc2Vjb25kIGFyZ3VtZW50IHRvIGZpcnN0XG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGFyZzEgLSBGaXJzdCBhcmd1bWVudFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBhcmcyIC0gU2Vjb25kIGFyZ3VtZW50XG4gICAgICogQHJldHVybnMgeyp9IEFwcGVuZGVkIGFyZ3VtZW50c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uQXBwZW5kKGFyZzEsIGFyZzIpIHtcbiAgICAgICAgLy8gZGlzcmVnYXJkIHVuZGVmaW5lZCBhcmdzXG4gICAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmcyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmcxO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGVpdGhlciBhcmd1bWVudCBpcyBub3QgYW4gYXJyYXksIG1ha2UgaXQgc29cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICBhcmcxID0gW2FyZzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmcyKSkge1xuICAgICAgICAgICAgYXJnMiA9IFthcmcyXTtcbiAgICAgICAgfVxuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhcmcxLCBhcmcyKTtcbiAgICAgICAgcmV0dXJuIGFyZzE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgYXJndW1lbnQgaXMgdW5kZWZpbmVkXG4gICAgICogQHBhcmFtIHsqfSBhcmcgLSBhcmd1bWVudFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBGYWxzZSBpZiBhcmd1bWVudCB1bmRlZmluZWQsIG90aGVyd2lzZSB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25FeGlzdHMoYXJnKXtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhbiBvYmplY3QgaW50byBhbiBhcnJheSBvZiBvYmplY3Qgd2l0aCBvbmUgcHJvcGVydHkgZWFjaFxuICAgICAqIEBwYXJhbSB7Kn0gYXJnIC0gdGhlIG9iamVjdCB0byBzcGxpdFxuICAgICAqIEByZXR1cm5zIHsqfSAtIHRoZSBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU3ByZWFkKGFyZykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICAvLyBzcHJlYWQgYWxsIG9mIHRoZSBpdGVtcyBpbiB0aGUgYXJyYXlcbiAgICAgICAgICAgIGFyZy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jdGlvbkFwcGVuZChyZXN1bHQsIGZ1bmN0aW9uU3ByZWFkKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYoYXJnICE9PSBudWxsICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmICFpc0xhbWJkYShhcmcpKSB7XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBhcmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSBhcmdba2V5XTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXJnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIGFuIGFycmF5IG9mIG9iamVjdHMgaW50byBhIHNpbmdsZSBvYmplY3QuICBEdXBsaWNhdGUgcHJvcGVydGllcyBhcmVcbiAgICAgKiBvdmVycmlkZGVuIGJ5IGVudHJpZXMgbGF0ZXIgaW4gdGhlIGFycmF5XG4gICAgICogQHBhcmFtIHsqfSBhcmcgLSB0aGUgb2JqZWN0cyB0byBtZXJnZVxuICAgICAqIEByZXR1cm5zIHsqfSAtIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbk1lcmdlKGFyZykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIGFyZy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgZm9yKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIG9yZGVyIG9mIGl0ZW1zIGluIGFuIGFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyIC0gdGhlIGFycmF5IHRvIHJldmVyc2VcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IC0gdGhlIHJldmVyc2VkIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25SZXZlcnNlKGFycikge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcnIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYXJyLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbbGVuZ3RoIC0gaSAtIDFdID0gYXJyW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIC0gdGhlIGlucHV0IG9iamVjdCB0byBpdGVyYXRlIG92ZXJcbiAgICAgKiBAcGFyYW0geyp9IGZ1bmMgLSB0aGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBrZXkvdmFsdWUgcGFpclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gLSB0aGUgcmVzdWx0YW50IGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24qIGZ1bmN0aW9uRWFjaChvYmosIGZ1bmMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZvcih2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgdmFyIGZ1bmNfYXJncyA9IFtvYmpba2V5XSwga2V5XTtcbiAgICAgICAgICAgIC8vIGludm9rZSBmdW5jXG4gICAgICAgICAgICByZXN1bHQucHVzaCh5aWVsZCAqIGFwcGx5KGZ1bmMsIGZ1bmNfYXJncywgbnVsbCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIHRoZSBtZXJnZSBzb3J0IChzdGFibGUpIHdpdGggb3B0aW9uYWwgY29tcGFyYXRvciBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyIC0gdGhlIGFycmF5IHRvIHNvcnRcbiAgICAgKiBAcGFyYW0geyp9IGNvbXBhcmF0b3IgLSBjb21wYXJhdG9yIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge0FycmF5fSAtIHNvcnRlZCBhcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU29ydChhcnIsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGFyci5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb21wO1xuICAgICAgICBpZih0eXBlb2YgY29tcGFyYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIGluamVjdCBhIGRlZmF1bHQgY29tcGFyYXRvciAtIG9ubHkgd29ya3MgZm9yIG51bWVyaWMgb3Igc3RyaW5nIGFycmF5c1xuICAgICAgICAgICAgaWYgKCFpc0FycmF5T2ZOdW1iZXJzKGFycikgJiYgIWlzQXJyYXlPZlN0cmluZ3MoYXJyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiRDMwNzBcIixcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IDFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb21wID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSA+IGI7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYodHlwZW9mIGNvbXBhcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGZvciBpbnRlcm5hbCB1c2FnZSBvZiBmdW5jdGlvblNvcnQgKGkuZS4gb3JkZXItYnkgc3ludGF4KVxuICAgICAgICAgICAgY29tcCA9IGNvbXBhcmF0b3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXQgPSBhcHBseShjb21wYXJhdG9yLCBbYSwgYl0sIG51bGwpO1xuICAgICAgICAgICAgICAgIC8vIHJldHVybnMgYSBnZW5lcmF0b3IgLSBzbyBpdGVyYXRlIG92ZXIgaXRcbiAgICAgICAgICAgICAgICB2YXIgY29tcCA9IGl0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWNvbXAuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wID0gaXQubmV4dChjb21wLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAudmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1lcmdlID0gZnVuY3Rpb24obCwgcikge1xuICAgICAgICAgICAgdmFyIG1lcmdlX2l0ZXIgPSBmdW5jdGlvbihyZXN1bHQsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmlnaHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlc3VsdCwgbGVmdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21wKGxlZnRbMF0sIHJpZ2h0WzBdKSkgeyAvLyBpbnZva2UgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQgcmV0dXJucyB0cnVlIC0gc3dhcCBsZWZ0IGFuZCByaWdodFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChyaWdodFswXSk7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlX2l0ZXIocmVzdWx0LCBsZWZ0LCByaWdodC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGtlZXAgdGhlIHNhbWUgb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGVmdFswXSk7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlX2l0ZXIocmVzdWx0LCBsZWZ0LnNsaWNlKDEpLCByaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBtZXJnZWQgPSBbXTtcbiAgICAgICAgICAgIG1lcmdlX2l0ZXIobWVyZ2VkLCBsLCByKTtcbiAgICAgICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHNvcnQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgICAgICAgICAgaWYoYXJyYXkubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKGFycmF5Lmxlbmd0aCAvIDIpO1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gYXJyYXkuc2xpY2UoMCwgbWlkZGxlKTtcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBhcnJheS5zbGljZShtaWRkbGUpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBzb3J0KGxlZnQpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gc29ydChyaWdodCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gc29ydChhcnIpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmFuZG9tbHkgc2h1ZmZsZXMgdGhlIGNvbnRlbnRzIG9mIGFuIGFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyIC0gdGhlIGlucHV0IGFycmF5XG4gICAgICogQHJldHVybnMge0FycmF5fSB0aGUgc2h1ZmZsZWQgYXJyYXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvblNodWZmbGUoYXJyKSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCBpbnB1dHMgYWx3YXlzIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgaWYodHlwZW9mIGFyciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihhcnIubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaHVmZmxlIHVzaW5nIHRoZSAnaW5zaWRlLW91dCcgdmFyaWFudCBvZiB0aGUgRmlzaGVyLVlhdGVzIGFsZ29yaXRobVxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpOyAvLyByYW5kb20gaW50ZWdlciBzdWNoIHRoYXQgMCDiiaQgaiDiiaQgaVxuICAgICAgICAgICAgaWYoaSAhPT0gaikge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHJlc3VsdFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtqXSA9IGFycltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhIHByZWRpY2F0ZSBmdW5jdGlvbiB0byBlYWNoIGtleS92YWx1ZSBwYWlyIGluIGFuIG9iamVjdCwgYW5kIHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmdcbiAgICAgKiBvbmx5IHRoZSBrZXkvdmFsdWUgcGFpcnMgdGhhdCBwYXNzZWQgdGhlIHByZWRpY2F0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFyZyAtIHRoZSBvYmplY3QgdG8gYmUgc2lmdGVkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGZ1bmMgLSB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uIChsYW1iZGEgb3IgbmF0aXZlKVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IC0gc2lmdGVkIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU2lmdChhcmcsIGZ1bmMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIHZhciBwcmVkaWNhdGUgPSBmdW5jdGlvbiAodmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgaXQgPSBhcHBseShmdW5jLCBbdmFsdWUsIGtleSwgb2JqZWN0XSwgbnVsbCk7XG4gICAgICAgICAgICAvLyByZXR1cm5zIGEgZ2VuZXJhdG9yIC0gc28gaXRlcmF0ZSBvdmVyIGl0XG4gICAgICAgICAgICB2YXIgcmVzID0gaXQubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKCFyZXMuZG9uZSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IGl0Lm5leHQocmVzLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMudmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yKHZhciBpdGVtIGluIGFyZykge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gYXJnW2l0ZW1dO1xuICAgICAgICAgICAgaWYoZnVuY3Rpb25Cb29sZWFuKHByZWRpY2F0ZShlbnRyeSwgaXRlbSwgYXJnKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaXRlbV0gPSBlbnRyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVtcHR5IG9iamVjdHMgc2hvdWxkIGJlIGNoYW5nZWQgdG8gdW5kZWZpbmVkXG4gICAgICAgIGlmKE9iamVjdC5rZXlzKHJlc3VsdCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBhbiBJU08gODYwMSBmb3JtYXR0ZWQgdGltZXN0YW1wXG4gICAgdmFyIGlzbzg2MDFyZWdleCA9IG5ldyBSZWdFeHAoJ15cXFxcZHs0fS1bMDFdXFxcXGQtWzAtM11cXFxcZFRbMC0yXVxcXFxkOlswLTVdXFxcXGQ6WzAtNV1cXFxcZFxcXFwuXFxcXGQrKFsrLV1bMC0yXVxcXFxkOlswLTVdXFxcXGR8WikkJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBJU08gODYwMSB0aW1lc3RhbXAgdG8gbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBlcG9jaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRpbWVzdGFtcCAtIHRoZSBJU08gODYwMSB0aW1lc3RhbXAgdG8gYmUgY29udmVydGVkXG4gICAgICogQHJldHVybnMge051bWJlcn0gLSBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGVwb2NoXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Ub01pbGxpcyh0aW1lc3RhbXApIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgdGltZXN0YW1wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFpc284NjAxcmVnZXgudGVzdCh0aW1lc3RhbXApKSB7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgc3RhY2s6IChuZXcgRXJyb3IoKSkuc3RhY2ssXG4gICAgICAgICAgICAgICAgY29kZTogXCJEMzExMFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aW1lc3RhbXBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRGF0ZS5wYXJzZSh0aW1lc3RhbXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2ggdG8gYW4gSVNPIDg2MDEgdGltZXN0YW1wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbGxpcyAtIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2ggdG8gYmUgY29udmVydGVkXG4gICAgICogQHJldHVybnMge1N0cmluZ30gLSBhbiBJU08gODYwMSBmb3JtYXR0ZWQgdGltZXN0YW1wXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25Gcm9tTWlsbGlzKG1pbGxpcykge1xuICAgICAgICAvLyB1bmRlZmluZWQgaW5wdXRzIGFsd2F5cyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIGlmKHR5cGVvZiBtaWxsaXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1pbGxpcykudG9JU09TdHJpbmcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9uZXMgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyZyAtIG9iamVjdCB0byBjbG9uZSAoZGVlcCBjb3B5KVxuICAgICAqIEByZXR1cm5zIHsqfSAtIHRoZSBjbG9uZWQgb2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25DbG9uZShhcmcpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIGlucHV0cyBhbHdheXMgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICBpZih0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGZ1bmN0aW9uU3RyaW5nKGFyZykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBmcmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbmNsb3NpbmdFbnZpcm9ubWVudCAtIEVuY2xvc2luZyBlbnZpcm9ubWVudFxuICAgICAqIEByZXR1cm5zIHt7YmluZDogYmluZCwgbG9va3VwOiBsb29rdXB9fSBDcmVhdGVkIGZyYW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRnJhbWUoZW5jbG9zaW5nRW52aXJvbm1lbnQpIHtcbiAgICAgICAgdmFyIGJpbmRpbmdzID0ge307XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiaW5kOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvb2t1cDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYoYmluZGluZ3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBiaW5kaW5nc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVuY2xvc2luZ0Vudmlyb25tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZW5jbG9zaW5nRW52aXJvbm1lbnQubG9va3VwKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRnVuY3Rpb24gcmVnaXN0cmF0aW9uXG4gICAgc3RhdGljRnJhbWUuYmluZCgnc3VtJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TdW0sICc8YTxuPjpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdjb3VudCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQ291bnQsICc8YTpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdtYXgnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbk1heCwgJzxhPG4+Om4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ21pbicsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uTWluLCAnPGE8bj46bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnYXZlcmFnZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQXZlcmFnZSwgJzxhPG4+Om4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3N0cmluZycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uU3RyaW5nLCAnPHgtOnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3N1YnN0cmluZycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uU3Vic3RyaW5nLCAnPHMtbm4/OnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3N1YnN0cmluZ0JlZm9yZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uU3Vic3RyaW5nQmVmb3JlLCAnPHMtczpzPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdzdWJzdHJpbmdBZnRlcicsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uU3Vic3RyaW5nQWZ0ZXIsICc8cy1zOnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2xvd2VyY2FzZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uTG93ZXJjYXNlLCAnPHMtOnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3VwcGVyY2FzZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uVXBwZXJjYXNlLCAnPHMtOnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2xlbmd0aCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uTGVuZ3RoLCAnPHMtOm4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3RyaW0nLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblRyaW0sICc8cy06cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgncGFkJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25QYWQsICc8cy1ucz86cz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnbWF0Y2gnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbk1hdGNoLCAnPHMtZjxzOm8+bj86YTxvPj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnY29udGFpbnMnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkNvbnRhaW5zLCAnPHMtKHNmKTpiPicpKTsgLy8gVE9ETyA8cy0oc2Y8czpvPik6Yj5cbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdyZXBsYWNlJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25SZXBsYWNlLCAnPHMtKHNmKShzZiluPzpzPicpKTsgLy8gVE9ETyA8cy0oc2Y8czpvPikoc2Y8bzpzPiluPzpzPlxuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3NwbGl0JywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TcGxpdCwgJzxzLShzZiluPzphPHM+PicpKTsgLy8gVE9ETyA8cy0oc2Y8czpvPiluPzphPHM+PlxuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2pvaW4nLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkpvaW4sICc8YTxzPnM/OnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2Zvcm1hdE51bWJlcicsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uRm9ybWF0TnVtYmVyLCAnPG4tc28/OnM+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2Zvcm1hdEJhc2UnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkZvcm1hdEJhc2UsICc8bi1uPzpzPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdudW1iZXInLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbk51bWJlciwgJzwobnMpLTpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdmbG9vcicsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uRmxvb3IsICc8bi06bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnY2VpbCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQ2VpbCwgJzxuLTpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdyb3VuZCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uUm91bmQsICc8bi1uPzpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdhYnMnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkFicywgJzxuLTpuPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdzcXJ0JywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TcXJ0LCAnPG4tOm4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3Bvd2VyJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Qb3dlciwgJzxuLW46bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgncmFuZG9tJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25SYW5kb20sICc8Om4+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2Jvb2xlYW4nLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkJvb2xlYW4sICc8eC06Yj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnbm90JywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Ob3QsICc8eC06Yj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnbWFwJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25NYXAsICc8YWY+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3ppcCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uWmlwLCAnPGErPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdmaWx0ZXInLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkZpbHRlciwgJzxhZj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgncmVkdWNlJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Gb2xkTGVmdCwgJzxhZmo/Omo+JykpOyAvLyBUT0RPIDxmPGpqOmo+YTxqPmo/Omo+XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc2lmdCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uU2lmdCwgJzxvLWY/Om8+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2tleXMnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbktleXMsICc8eC06YTxzPj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnbG9va3VwJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25Mb29rdXAsICc8eC1zOng+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2FwcGVuZCcsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQXBwZW5kLCAnPHh4OmE+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2V4aXN0cycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uRXhpc3RzLCAnPHg6Yj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnc3ByZWFkJywgZGVmaW5lRnVuY3Rpb24oZnVuY3Rpb25TcHJlYWQsICc8eC06YTxvPj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnbWVyZ2UnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbk1lcmdlLCAnPGE8bz46bz4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgncmV2ZXJzZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uUmV2ZXJzZSwgJzxhOmE+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ2VhY2gnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkVhY2gsICc8by1mOmE+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3NvcnQnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblNvcnQsICc8YWY/OmE+JykpO1xuICAgIHN0YXRpY0ZyYW1lLmJpbmQoJ3NodWZmbGUnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvblNodWZmbGUsICc8YTphPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdiYXNlNjRlbmNvZGUnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkJhc2U2NGVuY29kZSwgJzxzLTpzPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdiYXNlNjRkZWNvZGUnLCBkZWZpbmVGdW5jdGlvbihmdW5jdGlvbkJhc2U2NGRlY29kZSwgJzxzLTpzPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCd0b01pbGxpcycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uVG9NaWxsaXMsICc8cy06bj4nKSk7XG4gICAgc3RhdGljRnJhbWUuYmluZCgnZnJvbU1pbGxpcycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uRnJvbU1pbGxpcywgJzxuLTpzPicpKTtcbiAgICBzdGF0aWNGcmFtZS5iaW5kKCdjbG9uZScsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uQ2xvbmUsICc8KG9hKS06bz4nKSk7XG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2Rlc1xuICAgICAqXG4gICAgICovXG4gICAgdmFyIGVycm9yQ29kZXMgPSB7XG4gICAgICAgIFwiUzAxMDFcIjogXCJTdHJpbmcgbGl0ZXJhbCBtdXN0IGJlIHRlcm1pbmF0ZWQgYnkgYSBtYXRjaGluZyBxdW90ZVwiLFxuICAgICAgICBcIlMwMTAyXCI6IFwiTnVtYmVyIG91dCBvZiByYW5nZToge3t0b2tlbn19XCIsXG4gICAgICAgIFwiUzAxMDNcIjogXCJVbnN1cHBvcnRlZCBlc2NhcGUgc2VxdWVuY2U6IFxcXFx7e3Rva2VufX1cIixcbiAgICAgICAgXCJTMDEwNFwiOiBcIlRoZSBlc2NhcGUgc2VxdWVuY2UgXFxcXHUgbXVzdCBiZSBmb2xsb3dlZCBieSA0IGhleCBkaWdpdHNcIixcbiAgICAgICAgXCJTMDEwNVwiOiBcIlF1b3RlZCBwcm9wZXJ0eSBuYW1lIG11c3QgYmUgdGVybWluYXRlZCB3aXRoIGEgYmFja3F1b3RlIChgKVwiLFxuICAgICAgICBcIlMwMjAxXCI6IFwiU3ludGF4IGVycm9yOiB7e3Rva2VufX1cIixcbiAgICAgICAgXCJTMDIwMlwiOiBcIkV4cGVjdGVkIHt7dmFsdWV9fSwgZ290IHt7dG9rZW59fVwiLFxuICAgICAgICBcIlMwMjAzXCI6IFwiRXhwZWN0ZWQge3t2YWx1ZX19IGJlZm9yZSBlbmQgb2YgZXhwcmVzc2lvblwiLFxuICAgICAgICBcIlMwMjA0XCI6IFwiVW5rbm93biBvcGVyYXRvcjoge3t0b2tlbn19XCIsXG4gICAgICAgIFwiUzAyMDVcIjogXCJVbmV4cGVjdGVkIHRva2VuOiB7e3Rva2VufX1cIixcbiAgICAgICAgXCJTMDIwNlwiOiBcIlVua25vd24gZXhwcmVzc2lvbiB0eXBlOiB7e3Rva2VufX1cIixcbiAgICAgICAgXCJTMDIwN1wiOiBcIlVuZXhwZWN0ZWQgZW5kIG9mIGV4cHJlc3Npb25cIixcbiAgICAgICAgXCJTMDIwOFwiOiBcIlBhcmFtZXRlciB7e3ZhbHVlfX0gb2YgZnVuY3Rpb24gZGVmaW5pdGlvbiBtdXN0IGJlIGEgdmFyaWFibGUgbmFtZSAoc3RhcnQgd2l0aCAkKVwiLFxuICAgICAgICBcIlMwMjA5XCI6IFwiQSBwcmVkaWNhdGUgY2Fubm90IGZvbGxvdyBhIGdyb3VwaW5nIGV4cHJlc3Npb24gaW4gYSBzdGVwXCIsXG4gICAgICAgIFwiUzAyMTBcIjogXCJFYWNoIHN0ZXAgY2FuIG9ubHkgaGF2ZSBvbmUgZ3JvdXBpbmcgZXhwcmVzc2lvblwiLFxuICAgICAgICBcIlMwMjExXCI6IFwiVGhlIHN5bWJvbCB7e3Rva2VufX0gY2Fubm90IGJlIHVzZWQgYXMgYSB1bmFyeSBvcGVyYXRvclwiLFxuICAgICAgICBcIlMwMzAxXCI6IFwiRW1wdHkgcmVndWxhciBleHByZXNzaW9ucyBhcmUgbm90IGFsbG93ZWRcIixcbiAgICAgICAgXCJTMDMwMlwiOiBcIk5vIHRlcm1pbmF0aW5nIC8gaW4gcmVndWxhciBleHByZXNzaW9uXCIsXG4gICAgICAgIFwiUzA0MDJcIjogXCJDaG9pY2UgZ3JvdXBzIGNvbnRhaW5pbmcgcGFyYW1ldGVyaXplZCB0eXBlcyBhcmUgbm90IHN1cHBvcnRlZFwiLFxuICAgICAgICBcIlMwNDAxXCI6IFwiVHlwZSBwYXJhbWV0ZXJzIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gZnVuY3Rpb25zIGFuZCBhcnJheXNcIixcbiAgICAgICAgXCJTMDUwMFwiOiBcIkF0dGVtcHRlZCB0byBldmFsdWF0ZSBhbiBleHByZXNzaW9uIGNvbnRhaW5pbmcgc3ludGF4IGVycm9yKHMpXCIsXG4gICAgICAgIFwiVDA0MTBcIjogXCJBcmd1bWVudCB7e2luZGV4fX0gb2YgZnVuY3Rpb24ge3t0b2tlbn19IGRvZXMgbm90IG1hdGNoIGZ1bmN0aW9uIHNpZ25hdHVyZVwiLFxuICAgICAgICBcIlQwNDExXCI6IFwiQ29udGV4dCB2YWx1ZSBpcyBub3QgYSBjb21wYXRpYmxlIHR5cGUgd2l0aCBhcmd1bWVudCB7e2luZGV4fX0gb2YgZnVuY3Rpb24ge3t0b2tlbn19XCIsXG4gICAgICAgIFwiVDA0MTJcIjogXCJBcmd1bWVudCB7e2luZGV4fX0gb2YgZnVuY3Rpb24ge3t0b2tlbn19IG11c3QgYmUgYW4gYXJyYXkgb2Yge3t0eXBlfX1cIixcbiAgICAgICAgXCJEMTAwMVwiOiBcIk51bWJlciBvdXQgb2YgcmFuZ2U6IHt7dmFsdWV9fVwiLFxuICAgICAgICBcIkQxMDAyXCI6IFwiQ2Fubm90IG5lZ2F0ZSBhIG5vbi1udW1lcmljIHZhbHVlOiB7e3ZhbHVlfX1cIixcbiAgICAgICAgXCJUMTAwM1wiOiBcIktleSBpbiBvYmplY3Qgc3RydWN0dXJlIG11c3QgZXZhbHVhdGUgdG8gYSBzdHJpbmc7IGdvdDoge3t2YWx1ZX19XCIsXG4gICAgICAgIFwiRDEwMDRcIjogXCJSZWd1bGFyIGV4cHJlc3Npb24gbWF0Y2hlcyB6ZXJvIGxlbmd0aCBzdHJpbmdcIixcbiAgICAgICAgXCJUMTAwNVwiOiBcIkF0dGVtcHRlZCB0byBpbnZva2UgYSBub24tZnVuY3Rpb24uIERpZCB5b3UgbWVhbiAke3t7dG9rZW59fX0/XCIsXG4gICAgICAgIFwiVDEwMDZcIjogXCJBdHRlbXB0ZWQgdG8gaW52b2tlIGEgbm9uLWZ1bmN0aW9uXCIsXG4gICAgICAgIFwiVDEwMDdcIjogXCJBdHRlbXB0ZWQgdG8gcGFydGlhbGx5IGFwcGx5IGEgbm9uLWZ1bmN0aW9uLiBEaWQgeW91IG1lYW4gJHt7e3Rva2VufX19P1wiLFxuICAgICAgICBcIlQxMDA4XCI6IFwiQXR0ZW1wdGVkIHRvIHBhcnRpYWxseSBhcHBseSBhIG5vbi1mdW5jdGlvblwiLFxuICAgICAgICBcIlQyMDAxXCI6IFwiVGhlIGxlZnQgc2lkZSBvZiB0aGUge3t0b2tlbn19IG9wZXJhdG9yIG11c3QgZXZhbHVhdGUgdG8gYSBudW1iZXJcIixcbiAgICAgICAgXCJUMjAwMlwiOiBcIlRoZSByaWdodCBzaWRlIG9mIHRoZSB7e3Rva2VufX0gb3BlcmF0b3IgbXVzdCBldmFsdWF0ZSB0byBhIG51bWJlclwiLFxuICAgICAgICBcIlQyMDAzXCI6IFwiVGhlIGxlZnQgc2lkZSBvZiB0aGUgcmFuZ2Ugb3BlcmF0b3IgKC4uKSBtdXN0IGV2YWx1YXRlIHRvIGFuIGludGVnZXJcIixcbiAgICAgICAgXCJUMjAwNFwiOiBcIlRoZSByaWdodCBzaWRlIG9mIHRoZSByYW5nZSBvcGVyYXRvciAoLi4pIG11c3QgZXZhbHVhdGUgdG8gYW4gaW50ZWdlclwiLFxuICAgICAgICBcIkQyMDA1XCI6IFwiVGhlIGxlZnQgc2lkZSBvZiA6PSBtdXN0IGJlIGEgdmFyaWFibGUgbmFtZSAoc3RhcnQgd2l0aCAkKVwiLFxuICAgICAgICBcIlQyMDA2XCI6IFwiVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGZ1bmN0aW9uIGFwcGxpY2F0aW9uIG9wZXJhdG9yIH4+IG11c3QgYmUgYSBmdW5jdGlvblwiLFxuICAgICAgICBcIlQyMDA3XCI6IFwiVHlwZSBtaXNtYXRjaCB3aGVuIGNvbXBhcmluZyB2YWx1ZXMge3t2YWx1ZX19IGFuZCB7e3ZhbHVlMn19IGluIG9yZGVyLWJ5IGNsYXVzZVwiLFxuICAgICAgICBcIlQyMDA4XCI6IFwiVGhlIGV4cHJlc3Npb25zIHdpdGhpbiBhbiBvcmRlci1ieSBjbGF1c2UgbXVzdCBldmFsdWF0ZSB0byBudW1lcmljIG9yIHN0cmluZyB2YWx1ZXNcIixcbiAgICAgICAgXCJUMjAwOVwiOiBcIlRoZSB2YWx1ZXMge3t2YWx1ZX19IGFuZCB7e3ZhbHVlMn19IGVpdGhlciBzaWRlIG9mIG9wZXJhdG9yIHt7dG9rZW59fSBtdXN0IGJlIG9mIHRoZSBzYW1lIGRhdGEgdHlwZVwiLFxuICAgICAgICBcIlQyMDEwXCI6IFwiVGhlIGV4cHJlc3Npb25zIGVpdGhlciBzaWRlIG9mIG9wZXJhdG9yIHt7dG9rZW59fSBtdXN0IGV2YWx1YXRlIHRvIG51bWVyaWMgb3Igc3RyaW5nIHZhbHVlc1wiLFxuICAgICAgICBcIlQyMDExXCI6IFwiVGhlIGluc2VydC91cGRhdGUgY2xhdXNlIG9mIHRoZSB0cmFuc2Zvcm0gZXhwcmVzc2lvbiBtdXN0IGV2YWx1YXRlIHRvIGFuIG9iamVjdDoge3t2YWx1ZX19XCIsXG4gICAgICAgIFwiVDIwMTJcIjogXCJUaGUgZGVsZXRlIGNsYXVzZSBvZiB0aGUgdHJhbnNmb3JtIGV4cHJlc3Npb24gbXVzdCBldmFsdWF0ZSB0byBhIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzOiB7e3ZhbHVlfX1cIixcbiAgICAgICAgXCJUMjAxM1wiOiBcIlRoZSB0cmFuc2Zvcm0gZXhwcmVzc2lvbiBjbG9uZXMgdGhlIGlucHV0IG9iamVjdCB1c2luZyB0aGUgJGNsb25lKCkgZnVuY3Rpb24uICBUaGlzIGhhcyBiZWVuIG92ZXJyaWRkZW4gaW4gdGhlIGN1cnJlbnQgc2NvcGUgYnkgYSBub24tZnVuY3Rpb24uXCIsXG4gICAgICAgIFwiRDMwMDFcIjogXCJBdHRlbXB0aW5nIHRvIGludm9rZSBzdHJpbmcgZnVuY3Rpb24gb24gSW5maW5pdHkgb3IgTmFOXCIsXG4gICAgICAgIFwiRDMwMTBcIjogXCJTZWNvbmQgYXJndW1lbnQgb2YgcmVwbGFjZSBmdW5jdGlvbiBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nXCIsXG4gICAgICAgIFwiRDMwMTFcIjogXCJGb3VydGggYXJndW1lbnQgb2YgcmVwbGFjZSBmdW5jdGlvbiBtdXN0IGV2YWx1YXRlIHRvIGEgcG9zaXRpdmUgbnVtYmVyXCIsXG4gICAgICAgIFwiRDMwMTJcIjogXCJBdHRlbXB0ZWQgdG8gcmVwbGFjZSBhIG1hdGNoZWQgc3RyaW5nIHdpdGggYSBub24tc3RyaW5nIHZhbHVlXCIsXG4gICAgICAgIFwiRDMwMjBcIjogXCJUaGlyZCBhcmd1bWVudCBvZiBzcGxpdCBmdW5jdGlvbiBtdXN0IGV2YWx1YXRlIHRvIGEgcG9zaXRpdmUgbnVtYmVyXCIsXG4gICAgICAgIFwiRDMwMzBcIjogXCJVbmFibGUgdG8gY2FzdCB2YWx1ZSB0byBhIG51bWJlcjoge3t2YWx1ZX19XCIsXG4gICAgICAgIFwiRDMwNDBcIjogXCJUaGlyZCBhcmd1bWVudCBvZiBtYXRjaCBmdW5jdGlvbiBtdXN0IGV2YWx1YXRlIHRvIGEgcG9zaXRpdmUgbnVtYmVyXCIsXG4gICAgICAgIFwiRDMwNTBcIjogXCJGaXJzdCBhcmd1bWVudCBvZiByZWR1Y2UgZnVuY3Rpb24gbXVzdCBiZSBhIGZ1bmN0aW9uIHdpdGggdHdvIGFyZ3VtZW50c1wiLFxuICAgICAgICBcIkQzMDYwXCI6IFwiVGhlIHNxcnQgZnVuY3Rpb24gY2Fubm90IGJlIGFwcGxpZWQgdG8gYSBuZWdhdGl2ZSBudW1iZXI6IHt7dmFsdWV9fVwiLFxuICAgICAgICBcIkQzMDYxXCI6IFwiVGhlIHBvd2VyIGZ1bmN0aW9uIGhhcyByZXN1bHRlZCBpbiBhIHZhbHVlIHRoYXQgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzIGEgSlNPTiBudW1iZXI6IGJhc2U9e3t2YWx1ZX19LCBleHBvbmVudD17e2V4cH19XCIsXG4gICAgICAgIFwiRDMwNzBcIjogXCJUaGUgc2luZ2xlIGFyZ3VtZW50IGZvcm0gb2YgdGhlIHNvcnQgZnVuY3Rpb24gY2FuIG9ubHkgYmUgYXBwbGllZCB0byBhbiBhcnJheSBvZiBzdHJpbmdzIG9yIGFuIGFycmF5IG9mIG51bWJlcnMuICBVc2UgdGhlIHNlY29uZCBhcmd1bWVudCB0byBzcGVjaWZ5IGEgY29tcGFyaXNvbiBmdW5jdGlvblwiLFxuICAgICAgICBcIkQzMDgwXCI6IFwiVGhlIHBpY3R1cmUgc3RyaW5nIG11c3Qgb25seSBjb250YWluIGEgbWF4aW11bSBvZiB0d28gc3ViLXBpY3R1cmVzXCIsXG4gICAgICAgIFwiRDMwODFcIjogXCJUaGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBtb3JlIHRoYW4gb25lIGluc3RhbmNlIG9mIHRoZSAnZGVjaW1hbC1zZXBhcmF0b3InIGNoYXJhY3RlclwiLFxuICAgICAgICBcIkQzMDgyXCI6IFwiVGhlIHN1Yi1waWN0dXJlIG11c3Qgbm90IGNvbnRhaW4gbW9yZSB0aGFuIG9uZSBpbnN0YW5jZSBvZiB0aGUgJ3BlcmNlbnQnIGNoYXJhY3RlclwiLFxuICAgICAgICBcIkQzMDgzXCI6IFwiVGhlIHN1Yi1waWN0dXJlIG11c3Qgbm90IGNvbnRhaW4gbW9yZSB0aGFuIG9uZSBpbnN0YW5jZSBvZiB0aGUgJ3Blci1taWxsZScgY2hhcmFjdGVyXCIsXG4gICAgICAgIFwiRDMwODRcIjogXCJUaGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBib3RoIGEgJ3BlcmNlbnQnIGFuZCBhICdwZXItbWlsbGUnIGNoYXJhY3RlclwiLFxuICAgICAgICBcIkQzMDg1XCI6IFwiVGhlIG1hbnRpc3NhIHBhcnQgb2YgYSBzdWItcGljdHVyZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlciB0aGF0IGlzIGVpdGhlciBhbiAnb3B0aW9uYWwgZGlnaXQgY2hhcmFjdGVyJyBvciBhIG1lbWJlciBvZiB0aGUgJ2RlY2ltYWwgZGlnaXQgZmFtaWx5J1wiLFxuICAgICAgICBcIkQzMDg2XCI6IFwiVGhlIHN1Yi1waWN0dXJlIG11c3Qgbm90IGNvbnRhaW4gYSBwYXNzaXZlIGNoYXJhY3RlciB0aGF0IGlzIHByZWNlZGVkIGJ5IGFuIGFjdGl2ZSBjaGFyYWN0ZXIgYW5kIHRoYXQgaXMgZm9sbG93ZWQgYnkgYW5vdGhlciBhY3RpdmUgY2hhcmFjdGVyXCIsXG4gICAgICAgIFwiRDMwODdcIjogXCJUaGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBhICdncm91cGluZy1zZXBhcmF0b3InIGNoYXJhY3RlciB0aGF0IGFwcGVhcnMgYWRqYWNlbnQgdG8gYSAnZGVjaW1hbC1zZXBhcmF0b3InIGNoYXJhY3RlclwiLFxuICAgICAgICBcIkQzMDg4XCI6IFwiVGhlIHN1Yi1waWN0dXJlIG11c3Qgbm90IGNvbnRhaW4gYSAnZ3JvdXBpbmctc2VwYXJhdG9yJyBhdCB0aGUgZW5kIG9mIHRoZSBpbnRlZ2VyIHBhcnRcIixcbiAgICAgICAgXCJEMzA4OVwiOiBcIlRoZSBzdWItcGljdHVyZSBtdXN0IG5vdCBjb250YWluIHR3byBhZGphY2VudCBpbnN0YW5jZXMgb2YgdGhlICdncm91cGluZy1zZXBhcmF0b3InIGNoYXJhY3RlclwiLFxuICAgICAgICBcIkQzMDkwXCI6IFwiVGhlIGludGVnZXIgcGFydCBvZiB0aGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBhIG1lbWJlciBvZiB0aGUgJ2RlY2ltYWwgZGlnaXQgZmFtaWx5JyB0aGF0IGlzIGZvbGxvd2VkIGJ5IGFuIGluc3RhbmNlIG9mIHRoZSAnb3B0aW9uYWwgZGlnaXQgY2hhcmFjdGVyJ1wiLFxuICAgICAgICBcIkQzMDkxXCI6IFwiVGhlIGZyYWN0aW9uYWwgcGFydCBvZiB0aGUgc3ViLXBpY3R1cmUgbXVzdCBub3QgY29udGFpbiBhbiBpbnN0YW5jZSBvZiB0aGUgJ29wdGlvbmFsIGRpZ2l0IGNoYXJhY3RlcicgdGhhdCBpcyBmb2xsb3dlZCBieSBhIG1lbWJlciBvZiB0aGUgJ2RlY2ltYWwgZGlnaXQgZmFtaWx5J1wiLFxuICAgICAgICBcIkQzMDkyXCI6IFwiQSBzdWItcGljdHVyZSB0aGF0IGNvbnRhaW5zIGEgJ3BlcmNlbnQnIG9yICdwZXItbWlsbGUnIGNoYXJhY3RlciBtdXN0IG5vdCBjb250YWluIGEgY2hhcmFjdGVyIHRyZWF0ZWQgYXMgYW4gJ2V4cG9uZW50LXNlcGFyYXRvcidcIixcbiAgICAgICAgXCJEMzA5M1wiOiBcIlRoZSBleHBvbmVudCBwYXJ0IG9mIHRoZSBzdWItcGljdHVyZSBtdXN0IGNvbXByaXNlIG9ubHkgb2Ygb25lIG9yIG1vcmUgY2hhcmFjdGVycyB0aGF0IGFyZSBtZW1iZXJzIG9mIHRoZSAnZGVjaW1hbCBkaWdpdCBmYW1pbHknXCIsXG4gICAgICAgIFwiRDMxMDBcIjogXCJUaGUgcmFkaXggb2YgdGhlIGZvcm1hdEJhc2UgZnVuY3Rpb24gbXVzdCBiZSBiZXR3ZWVuIDIgYW5kIDM2LiAgSXQgd2FzIGdpdmVuIHt7dmFsdWV9fVwiLFxuICAgICAgICBcIkQzMTEwXCI6IFwiVGhlIGFyZ3VtZW50IG9mIHRoZSB0b01pbGxpcyBmdW5jdGlvbiBtdXN0IGJlIGFuIElTTyA4NjAxIGZvcm1hdHRlZCB0aW1lc3RhbXAuIEdpdmVuIHt7dmFsdWV9fVwiXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGxvb2t1cCBhIG1lc3NhZ2UgdGVtcGxhdGUgZnJvbSB0aGUgY2F0YWxvZyBhbmQgc3Vic3RpdHV0ZSB0aGUgaW5zZXJ0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlcnIgLSBlcnJvciBjb2RlIHRvIGxvb2t1cFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb29rdXBNZXNzYWdlKGVycikge1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICdVbmtub3duIGVycm9yJztcbiAgICAgICAgaWYodHlwZW9mIGVyci5tZXNzYWdlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IGVycm9yQ29kZXNbZXJyLmNvZGVdO1xuICAgICAgICBpZih0eXBlb2YgdGVtcGxhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgYW55IGhhbmRsZWJhcnMsIHJlcGxhY2UgdGhlbSB3aXRoIHRoZSBmaWVsZCByZWZlcmVuY2VzXG4gICAgICAgICAgICAvLyB0cmlwbGUgYnJhY2VzIC0gcmVwbGFjZSB3aXRoIHZhbHVlXG4gICAgICAgICAgICAvLyBkb3VibGUgYnJhY2VzIC0gcmVwbGFjZSB3aXRoIGpzb24gc3RyaW5naWZpZWQgdmFsdWVcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9cXHtcXHtcXHsoW159XSspfX19L2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJbYXJndW1lbnRzWzFdXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZSgvXFx7XFx7KFtefV0rKX19L2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShlcnJbYXJndW1lbnRzWzFdXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBKU09OYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4cHIgLSBKU09OYXRhIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMgLSByZWNvdmVyOiBhdHRlbXB0IHRvIHJlY292ZXIgb24gcGFyc2UgZXJyb3JcbiAgICAgKiBAcmV0dXJucyB7e2V2YWx1YXRlOiBldmFsdWF0ZSwgYXNzaWduOiBhc3NpZ259fSBFdmFsdWF0ZWQgZXhwcmVzc2lvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGpzb25hdGEoZXhwciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgYXN0O1xuICAgICAgICB2YXIgZXJyb3JzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXN0ID0gcGFyc2VyKGV4cHIsIG9wdGlvbnMgJiYgb3B0aW9ucy5yZWNvdmVyKTtcbiAgICAgICAgICAgIGVycm9ycyA9IGFzdC5lcnJvcnM7XG4gICAgICAgICAgICBkZWxldGUgYXN0LmVycm9ycztcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIC8vIGluc2VydCBlcnJvciBtZXNzYWdlIGludG8gc3RydWN0dXJlXG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9IGxvb2t1cE1lc3NhZ2UoZXJyKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW52aXJvbm1lbnQgPSBjcmVhdGVGcmFtZShzdGF0aWNGcmFtZSk7XG5cbiAgICAgICAgdmFyIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7IC8vIHdpbGwgYmUgb3ZlcnJpZGRlbiBvbiBlYWNoIGNhbGwgdG8gZXZhbHV0ZSgpXG4gICAgICAgIGVudmlyb25tZW50LmJpbmQoJ25vdycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVzdGFtcC50b0pTT04oKTtcbiAgICAgICAgfSwgJzw6cz4nKSk7XG4gICAgICAgIGVudmlyb25tZW50LmJpbmQoJ21pbGxpcycsIGRlZmluZUZ1bmN0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVzdGFtcC5nZXRUaW1lKCk7XG4gICAgICAgIH0sICc8Om4+JykpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gKGlucHV0LCBiaW5kaW5ncywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBpZiB0aGUgZXhwcmVzc2lvbiBjb21waWxlZCB3aXRoIHN5bnRheCBlcnJvcnNcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgZXJyb3JzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogJ1MwNTAwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAwXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gbG9va3VwTWVzc2FnZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiaW5kaW5ncyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4ZWNfZW52O1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdmFyaWFibGUgYmluZGluZ3MgaGF2ZSBiZWVuIHBhc3NlZCBpbiAtIGNyZWF0ZSBhIGZyYW1lIHRvIGhvbGQgdGhlc2VcbiAgICAgICAgICAgICAgICAgICAgZXhlY19lbnYgPSBjcmVhdGVGcmFtZShlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHYgaW4gYmluZGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNfZW52LmJpbmQodiwgYmluZGluZ3Nbdl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXhlY19lbnYgPSBlbnZpcm9ubWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcHV0IHRoZSBpbnB1dCBkb2N1bWVudCBpbnRvIHRoZSBlbnZpcm9ubWVudCBhcyB0aGUgcm9vdCBvYmplY3RcbiAgICAgICAgICAgICAgICBleGVjX2Vudi5iaW5kKCckJywgaW5wdXQpO1xuXG4gICAgICAgICAgICAgICAgLy8gY2FwdHVyZSB0aGUgdGltZXN0YW1wIGFuZCBwdXQgaXQgaW4gdGhlIGV4ZWN1dGlvbiBlbnZpcm9ubWVudFxuICAgICAgICAgICAgICAgIC8vIHRoZSAkbm93KCkgYW5kICRtaWxsaXMoKSBmdW5jdGlvbnMgd2lsbCByZXR1cm4gdGhpcyB2YWx1ZSAtIHdoZW5ldmVyIGl0IGlzIGNhbGxlZFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0LCBpdDtcbiAgICAgICAgICAgICAgICAvLyBpZiBhIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHN1cHBsaWVkLCB0aGVuIGRyaXZlIHRoZSBnZW5lcmF0b3IgaW4gYSBwcm9taXNlIGNoYWluXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4ZWNfZW52LmJpbmQoJ19fanNvbmF0YV9hc3luYycsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGhlbkhhbmRsZXIgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl0Lm5leHQocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlLnRoZW4odGhlbkhhbmRsZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGxvb2t1cE1lc3NhZ2UoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpdCA9IGV2YWx1YXRlKGFzdCwgaW5wdXQsIGV4ZWNfZW52KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gaXQubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUudGhlbih0aGVuSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gY2FsbGJhY2sgZnVuY3Rpb24gLSBkcml2ZSB0aGUgZ2VuZXJhdG9yIHRvIGNvbXBsZXRpb24gc3luY2hyb25vdXNseVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQgPSBldmFsdWF0ZShhc3QsIGlucHV0LCBleGVjX2Vudik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBpdC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gaXQubmV4dChyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlcnQgZXJyb3IgbWVzc2FnZSBpbnRvIHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBsb29rdXBNZXNzYWdlKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXNzaWduOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBlbnZpcm9ubWVudC5iaW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWdpc3RlckZ1bmN0aW9uOiBmdW5jdGlvbihuYW1lLCBpbXBsZW1lbnRhdGlvbiwgc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmMgPSBkZWZpbmVGdW5jdGlvbihpbXBsZW1lbnRhdGlvbiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICBlbnZpcm9ubWVudC5iaW5kKG5hbWUsIGZ1bmMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAganNvbmF0YS5wYXJzZXIgPSBwYXJzZXI7IC8vIFRPRE8gcmVtb3ZlIHRoaXMgaW4gYSBmdXR1cmUgcmVsZWFzZSAtIHVzZSBhc3QoKSBpbnN0ZWFkXG5cbiAgICByZXR1cm4ganNvbmF0YTtcblxufSkoKTtcblxuLy8gbm9kZS5qcyBvbmx5IC0gZXhwb3J0IHRoZSBqc29uYXRhIGFuZCBwYXJzZXIgZnVuY3Rpb25zXG4vLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZVxuaWYodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGpzb25hdGE7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBsb2dsZXZlbCA9IHJlcXVpcmUoJ2xvZ2xldmVsJyk7XG52YXIgY2hhbGsgPSByZXF1aXJlKCdjaGFsaycpO1xuXG52YXIgbG9nZ2VycyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldExvZ2dlcjtcblxuZnVuY3Rpb24gZ2V0TG9nZ2VyKCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBfcmVmJGxldmVsID0gX3JlZi5sZXZlbCxcbiAgICAgIGxldmVsID0gX3JlZiRsZXZlbCA9PT0gdW5kZWZpbmVkID8gZ2V0RGVmYXVsdExldmVsKCkgOiBfcmVmJGxldmVsLFxuICAgICAgX3JlZiRwcmVmaXggPSBfcmVmLnByZWZpeCxcbiAgICAgIHByZWZpeCA9IF9yZWYkcHJlZml4ID09PSB1bmRlZmluZWQgPyAnJyA6IF9yZWYkcHJlZml4O1xuXG4gIGlmIChsb2dnZXJzW3ByZWZpeF0pIHtcbiAgICByZXR1cm4gbG9nZ2Vyc1twcmVmaXhdO1xuICB9XG4gIHZhciBjb2xvcmVkUHJlZml4ID0gcHJlZml4ID8gYCR7Y2hhbGsuZGltKHByZWZpeCl9IGAgOiAnJztcbiAgdmFyIGxldmVsUHJlZml4ID0ge1xuICAgIFRSQUNFOiBjaGFsay5kaW0oJ1tUUkFDRV0nKSxcbiAgICBERUJVRzogY2hhbGsuY3lhbignW0RFQlVHXScpLFxuICAgIElORk86IGNoYWxrLmJsdWUoJ1tJTkZPXScpLFxuICAgIFdBUk46IGNoYWxrLnllbGxvdygnW1dBUk5dJyksXG4gICAgRVJST1I6IGNoYWxrLnJlZCgnW0VSUk9SXScpXG4gIH07XG5cbiAgdmFyIGxvZ2dlciA9IGxvZ2xldmVsLmdldExvZ2dlcihgJHtwcmVmaXh9LWxvZ2dlcmApO1xuXG4gIC8vIHRoaXMgaXMgdGhlIHBsdWdpbiBcImFwaVwiXG4gIHZhciBvcmlnaW5hbEZhY3RvcnkgPSBsb2dnZXIubWV0aG9kRmFjdG9yeTtcbiAgbG9nZ2VyLm1ldGhvZEZhY3RvcnkgPSBtZXRob2RGYWN0b3J5O1xuXG4gIHZhciBvcmlnaW5hbFNldExldmVsID0gbG9nZ2VyLnNldExldmVsO1xuICBsb2dnZXIuc2V0TGV2ZWwgPSBzZXRMZXZlbDtcbiAgbG9nZ2VyLnNldExldmVsKGxldmVsKTtcbiAgbG9nZ2Vyc1twcmVmaXhdID0gbG9nZ2VyO1xuICByZXR1cm4gbG9nZ2VyO1xuXG4gIGZ1bmN0aW9uIG1ldGhvZEZhY3RvcnkoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZhY3RvcnlBcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBmYWN0b3J5QXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgbG9nTGV2ZWwgPSBmYWN0b3J5QXJnc1swXTtcblxuICAgIHZhciByYXdNZXRob2QgPSBvcmlnaW5hbEZhY3RvcnkuYXBwbHkodW5kZWZpbmVkLCBmYWN0b3J5QXJncyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhd01ldGhvZC5hcHBseSh1bmRlZmluZWQsIFtgJHtjb2xvcmVkUHJlZml4fSR7bGV2ZWxQcmVmaXhbbG9nTGV2ZWwudG9VcHBlckNhc2UoKV19OmBdLmNvbmNhdChhcmdzKSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldExldmVsKGxldmVsVG9TZXRUbykge1xuICAgIHZhciBwZXJzaXN0ID0gZmFsc2U7IC8vIHVzZXMgYnJvd3NlciBsb2NhbFN0b3JhZ2VcbiAgICByZXR1cm4gb3JpZ2luYWxTZXRMZXZlbC5jYWxsKGxvZ2dlciwgbGV2ZWxUb1NldFRvLCBwZXJzaXN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0TGV2ZWwoKSB7XG4gIHZhciBsb2dMZXZlbCA9IHByb2Nlc3MuZW52LkxPR19MRVZFTDtcblxuICBpZiAobG9nTGV2ZWwgPT09ICd1bmRlZmluZWQnIHx8ICFsb2dMZXZlbCkge1xuICAgIHJldHVybiAnd2Fybic7XG4gIH1cbiAgcmV0dXJuIGxvZ0xldmVsO1xufSIsIi8qXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuKi9cbihmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplXG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcblxuICAgIHZhciBsb2dNZXRob2RzID0gW1xuICAgICAgICBcInRyYWNlXCIsXG4gICAgICAgIFwiZGVidWdcIixcbiAgICAgICAgXCJpbmZvXCIsXG4gICAgICAgIFwid2FyblwiLFxuICAgICAgICBcImVycm9yXCJcbiAgICBdO1xuXG4gICAgLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNlxuICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnZcbiAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXNcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/XG4gICAgICAgICAgICAgICAgbm9vcCA6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xuICAgIH1cblxuICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XG4gICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGRlZmF1bHRMZXZlbCwgZmFjdG9yeSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGN1cnJlbnRMZXZlbDtcbiAgICAgIHZhciBzdG9yYWdlS2V5ID0gXCJsb2dsZXZlbFwiO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXG4gICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjb29raWUuaW5kZXhPZihcbiAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIik7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXRMZXZlbChpbml0aWFsTGV2ZWwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqXG4gICAgICogVG9wLWxldmVsIEFQSVxuICAgICAqXG4gICAgICovXG5cbiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXG4gICAgICAgICAgICBuYW1lLCBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCksIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pKTtcbiIsInZhciBwZXJmb3JtYW5jZSA9IGdsb2JhbC5wZXJmb3JtYW5jZSB8fCB7fTtcblxudmFyIHByZXNlbnQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgbmFtZXMgPSBbJ25vdycsICd3ZWJraXROb3cnLCAnbXNOb3cnLCAnbW96Tm93JywgJ29Ob3cnXTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCkge1xuICAgIHZhciBuYW1lID0gbmFtZXMuc2hpZnQoKTtcbiAgICBpZiAobmFtZSBpbiBwZXJmb3JtYW5jZSkge1xuICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlW25hbWVdLmJpbmQocGVyZm9ybWFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkYXRlTm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH07XG4gIHZhciBuYXZpZ2F0aW9uU3RhcnQgPSAocGVyZm9ybWFuY2UudGltaW5nIHx8IHt9KS5uYXZpZ2F0aW9uU3RhcnQgfHwgZGF0ZU5vdygpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkYXRlTm93KCkgLSBuYXZpZ2F0aW9uU3RhcnQ7XG4gIH07XG59KCkpO1xuXG5wcmVzZW50LnBlcmZvcm1hbmNlTm93ID0gcGVyZm9ybWFuY2Uubm93O1xucHJlc2VudC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICBwZXJmb3JtYW5jZS5ub3cgPSBwcmVzZW50LnBlcmZvcm1hbmNlTm93O1xufTtcbnByZXNlbnQuY29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHBlcmZvcm1hbmNlLm5vdyA9IHByZXNlbnQ7XG59O1xucHJlc2VudC5jb25mbGljdCgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByZXNlbnQ7XG4iLCIvLyBFeHBvcnQgLi9saWIvcmFuZGdlblxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9yYW5kZ2VuXCIpO1xuIiwiLypqc2xpbnQgaW5kZW50OiAyLCBwbHVzcGx1czogdHJ1ZSwgc2xvcHB5OiB0cnVlICovXG4vLyBHZW5lcmF0ZSB1bmlmb3JtbHkgZGlzdHJpYnV0ZWQgcmFuZG9tIG51bWJlcnNcbi8vIEdpdmVzIGEgcmFuZG9tIG51bWJlciBvbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4KS5cbi8vIElmIGRpc2NyZXRlIGlzIHRydWUsIHRoZSBudW1iZXIgd2lsbCBiZSBhbiBpbnRlZ2VyLlxuZnVuY3Rpb24gcnVuaWYobWluLCBtYXgsIGRpc2NyZXRlKSB7XG4gIGlmIChtaW4gPT09IHVuZGVmaW5lZCkge1xuICAgIG1pbiA9IDA7XG4gIH1cbiAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWF4ID0gMTtcbiAgfVxuICBpZiAoZGlzY3JldGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGRpc2NyZXRlID0gZmFsc2U7XG4gIH1cbiAgaWYgKGRpc2NyZXRlKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IocnVuaWYobWluLCBtYXgsIGZhbHNlKSk7XG4gIH1cbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcbn1cblxuLy8gR2VuZXJhdGUgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIG51Ym1lcnNcbi8vIEFsZ29yaXRobSBhZGFwdGVkIGZyb206XG4vLyBodHRwOi8vYy1mYXEuY29tL2xpYi9nYXVzc2lhbi5odG1sXG5mdW5jdGlvbiBybm9ybShtZWFuLCBzdGRldikge1xuICB2YXIgdTEsIHUyLCB2MSwgdjIsIHM7XG4gIGlmIChtZWFuID09PSB1bmRlZmluZWQpIHtcbiAgICBtZWFuID0gMC4wO1xuICB9XG4gIGlmIChzdGRldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RkZXYgPSAxLjA7XG4gIH1cbiAgaWYgKHJub3JtLnYyID09PSBudWxsKSB7XG4gICAgZG8ge1xuICAgICAgdTEgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgdTIgPSBNYXRoLnJhbmRvbSgpO1xuXG4gICAgICB2MSA9IDIgKiB1MSAtIDE7XG4gICAgICB2MiA9IDIgKiB1MiAtIDE7XG4gICAgICBzID0gdjEgKiB2MSArIHYyICogdjI7XG4gICAgfSB3aGlsZSAocyA9PT0gMCB8fCBzID49IDEpO1xuXG4gICAgcm5vcm0udjIgPSB2MiAqIE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHMpIC8gcyk7XG4gICAgcmV0dXJuIHN0ZGV2ICogdjEgKiBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhzKSAvIHMpICsgbWVhbjtcbiAgfVxuXG4gIHYyID0gcm5vcm0udjI7XG4gIHJub3JtLnYyID0gbnVsbDtcbiAgcmV0dXJuIHN0ZGV2ICogdjIgKyBtZWFuO1xufVxuXG5ybm9ybS52MiA9IG51bGw7XG5cbi8vIEdlbmVyYXRlIENoaS1zcXVhcmUgZGlzdHJpYnV0ZWQgcmFuZG9tIG51bWJlcnNcbmZ1bmN0aW9uIHJjaGlzcShkZWdyZWVzT2ZGcmVlZG9tKSB7XG4gIGlmIChkZWdyZWVzT2ZGcmVlZG9tID09PSB1bmRlZmluZWQpIHtcbiAgICBkZWdyZWVzT2ZGcmVlZG9tID0gMTtcbiAgfVxuICB2YXIgaSwgeiwgc3VtID0gMC4wO1xuICBmb3IgKGkgPSAwOyBpIDwgZGVncmVlc09mRnJlZWRvbTsgaSsrKSB7XG4gICAgeiA9IHJub3JtKCk7XG4gICAgc3VtICs9IHogKiB6O1xuICB9XG5cbiAgcmV0dXJuIHN1bTtcbn1cblxuLy8gR2VuZXJhdGUgUG9pc3NvbiBkaXN0cmlidXRlZCByYW5kb20gbnVtYmVyc1xuZnVuY3Rpb24gcnBvaXNzb24obGFtYmRhKSB7XG4gIGlmIChsYW1iZGEgPT09IHVuZGVmaW5lZCkge1xuICAgIGxhbWJkYSA9IDE7XG4gIH1cbiAgdmFyIGwgPSBNYXRoLmV4cCgtbGFtYmRhKSxcbiAgICBrID0gMCxcbiAgICBwID0gMS4wO1xuICBkbyB7XG4gICAgaysrO1xuICAgIHAgKj0gTWF0aC5yYW5kb20oKTtcbiAgfSB3aGlsZSAocCA+IGwpO1xuXG4gIHJldHVybiBrIC0gMTtcbn1cblxuLy8gR2VuZXJhdGUgQ2F1Y2h5IGRpc3RyaWJ1dGVkIHJhbmRvbSBudW1iZXJzXG5mdW5jdGlvbiByY2F1Y2h5KGxvYywgc2NhbGUpIHtcbiAgaWYgKGxvYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbG9jID0gMC4wO1xuICB9XG4gIGlmIChzY2FsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc2NhbGUgPSAxLjA7XG4gIH1cbiAgdmFyIG4yLCBuMSA9IHJub3JtKCk7XG4gIGRvIHtcbiAgICBuMiA9IHJub3JtKCk7XG4gIH0gd2hpbGUgKG4yID09PSAwLjApO1xuXG4gIHJldHVybiBsb2MgKyBzY2FsZSAqIG4xIC8gbjI7XG59XG5cbi8vIEJlcm5vdWxsaSBkaXN0cmlidXRpb246IGdpdmVzIDEgd2l0aCBwcm9iYWJpbGl0eSBwXG5mdW5jdGlvbiByYmVybm91bGxpKHApIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkgPCBwID8gMSA6IDA7XG59XG5cbi8vIFZlY3Rvcml6ZSBhIHJhbmRvbSBnZW5lcmF0b3JcbmZ1bmN0aW9uIHZlY3Rvcml6ZShnZW5lcmF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbiwgcmVzdWx0LCBpLCBhcmdzO1xuICAgIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICBuID0gYXJncy5zaGlmdCgpO1xuICAgIHJlc3VsdCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRvci5hcHBseSh0aGlzLCBhcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8vIEdlbmVyYXRlIGEgaGlzdG9ncmFtIGZyb20gYSBsaXN0IG9mIG51bWJlcnNcbmZ1bmN0aW9uIGhpc3RvZ3JhbShkYXRhLCBiaW5Db3VudCkge1xuICBiaW5Db3VudCA9IGJpbkNvdW50IHx8IDEwO1xuXG4gIHZhciBiaW5zLCBpLCBzY2FsZWQsXG4gICAgbWF4ID0gTWF0aC5tYXguYXBwbHkodGhpcywgZGF0YSksXG4gICAgbWluID0gTWF0aC5taW4uYXBwbHkodGhpcywgZGF0YSk7XG5cbiAgLy8gZWRnZSBjYXNlOiBtYXggPT0gbWluXG4gIGlmIChtYXggPT09IG1pbikge1xuICAgIHJldHVybiBbZGF0YS5sZW5ndGhdO1xuICB9XG5cbiAgYmlucyA9IFtdO1xuXG4gIC8vIHplcm8gZWFjaCBiaW5cbiAgZm9yIChpID0gMDsgaSA8IGJpbkNvdW50OyBpKyspIHtcbiAgICBiaW5zLnB1c2goMCk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIC8vIHNjYWxlIGl0IHRvIGJlIGJldHdlZW4gMCBhbmQgMVxuICAgIHNjYWxlZCA9IChkYXRhW2ldIC0gbWluKSAvIChtYXggLSBtaW4pO1xuXG4gICAgLy8gc2NhbGUgaXQgdXAgdG8gdGhlIGhpc3RvZ3JhbSBzaXplXG4gICAgc2NhbGVkICo9IGJpbkNvdW50O1xuXG4gICAgLy8gZHJvcCBpdCBpbiBhIGJpblxuICAgIHNjYWxlZCA9IE1hdGguZmxvb3Ioc2NhbGVkKTtcblxuICAgIC8vIGVkZ2UgY2FzZTogdGhlIG1heFxuICAgIGlmIChzY2FsZWQgPT09IGJpbkNvdW50KSB7IHNjYWxlZC0tOyB9XG5cbiAgICBiaW5zW3NjYWxlZF0rKztcbiAgfVxuXG4gIHJldHVybiBiaW5zO1xufVxuXG4vKipcbiAqIEdldCBhIHJhbmRvbSBlbGVtZW50IGZyb20gYSBsaXN0XG4gKi9cbmZ1bmN0aW9uIHJsaXN0KGxpc3QpIHtcbiAgcmV0dXJuIGxpc3RbcnVuaWYoMCwgbGlzdC5sZW5ndGgsIHRydWUpXTtcbn1cblxuZXhwb3J0cy5ydW5pZiA9IHJ1bmlmO1xuZXhwb3J0cy5ybm9ybSA9IHJub3JtO1xuZXhwb3J0cy5yY2hpc3EgPSByY2hpc3E7XG5leHBvcnRzLnJwb2lzc29uID0gcnBvaXNzb247XG5leHBvcnRzLnJjYXVjaHkgPSByY2F1Y2h5O1xuZXhwb3J0cy5yYmVybm91bGxpID0gcmJlcm5vdWxsaTtcbmV4cG9ydHMucmxpc3QgPSBybGlzdDtcblxuZXhwb3J0cy5ydnVuaWYgPSB2ZWN0b3JpemUocnVuaWYpO1xuZXhwb3J0cy5ydm5vcm0gPSB2ZWN0b3JpemUocm5vcm0pO1xuZXhwb3J0cy5ydmNoaXNxID0gdmVjdG9yaXplKHJjaGlzcSk7XG5leHBvcnRzLnJ2cG9pc3NvbiA9IHZlY3Rvcml6ZShycG9pc3Nvbik7XG5leHBvcnRzLnJ2Y2F1Y2h5ID0gdmVjdG9yaXplKHJjYXVjaHkpO1xuZXhwb3J0cy5ydmJlcm5vdWxsaSA9IHZlY3Rvcml6ZShyYmVybm91bGxpKTtcbmV4cG9ydHMucnZsaXN0ID0gdmVjdG9yaXplKHJsaXN0KTtcblxuZXhwb3J0cy5oaXN0b2dyYW0gPSBoaXN0b2dyYW07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYW5zaVJlZ2V4ID0gcmVxdWlyZSgnYW5zaS1yZWdleCcpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuXHRyZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBzdHIucmVwbGFjZShhbnNpUmVnZXgsICcnKSA6IHN0cjtcbn07XG4iLCIvKiBqc2hpbnQgbm9kZTogdHJ1ZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBtYWtlQXJyYXlGcm9tKG9iaikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KG9iaik7XG59XG52YXJcbiAgUEVORElORyA9IFwicGVuZGluZ1wiLFxuICBSRVNPTFZFRCA9IFwicmVzb2x2ZWRcIixcbiAgUkVKRUNURUQgPSBcInJlamVjdGVkXCI7XG5cbmZ1bmN0aW9uIFN5bmNocm9ub3VzUHJvbWlzZShoYW5kbGVyKSB7XG4gIHRoaXMuc3RhdHVzID0gUEVORElORztcbiAgdGhpcy5fY29udGludWF0aW9ucyA9IFtdO1xuICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgaWYgKGhhbmRsZXIpIHtcbiAgICBoYW5kbGVyLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgdGhpcy5fY29udGludWVXaXRoLmJpbmQodGhpcyksXG4gICAgICB0aGlzLl9mYWlsV2l0aC5iaW5kKHRoaXMpXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsb29rc0xpa2VBUHJvbWlzZShvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgKG9iai50aGVuKSA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG5TeW5jaHJvbm91c1Byb21pc2UucHJvdG90eXBlID0ge1xuICB0aGVuOiBmdW5jdGlvbiAobmV4dEZuLCBjYXRjaEZuKSB7XG4gICAgdmFyIG5leHQgPSBTeW5jaHJvbm91c1Byb21pc2UudW5yZXNvbHZlZCgpLl9zZXRQYXJlbnQodGhpcyk7XG4gICAgaWYgKHRoaXMuX2lzUmVqZWN0ZWQoKSkge1xuICAgICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgICB0aGlzLl9jb250aW51YXRpb25zLnB1c2goe1xuICAgICAgICAgIHByb21pc2U6IG5leHQsXG4gICAgICAgICAgbmV4dEZuOiBuZXh0Rm4sXG4gICAgICAgICAgY2F0Y2hGbjogY2F0Y2hGblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9XG4gICAgICBpZiAoY2F0Y2hGbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBjYXRjaFJlc3VsdCA9IGNhdGNoRm4odGhpcy5fZXJyb3IpO1xuICAgICAgICAgIGlmIChsb29rc0xpa2VBUHJvbWlzZShjYXRjaFJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYWluUHJvbWlzZURhdGEoY2F0Y2hSZXN1bHQsIG5leHQpO1xuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZShjYXRjaFJlc3VsdCkuX3NldFBhcmVudCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlamVjdChlKS5fc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlamVjdCh0aGlzLl9lcnJvcikuX3NldFBhcmVudCh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5fY29udGludWF0aW9ucy5wdXNoKHtcbiAgICAgIHByb21pc2U6IG5leHQsXG4gICAgICBuZXh0Rm46IG5leHRGbixcbiAgICAgIGNhdGNoRm46IGNhdGNoRm5cbiAgICB9KTtcbiAgICB0aGlzLl9ydW5SZXNvbHV0aW9ucygpO1xuICAgIHJldHVybiBuZXh0O1xuICB9LFxuICBjYXRjaDogZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSB7XG4gICAgICByZXR1cm4gU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUodGhpcy5fZGF0YSkuX3NldFBhcmVudCh0aGlzKTtcbiAgICB9XG4gICAgdmFyIG5leHQgPSBTeW5jaHJvbm91c1Byb21pc2UudW5yZXNvbHZlZCgpLl9zZXRQYXJlbnQodGhpcyk7XG4gICAgdGhpcy5fY29udGludWF0aW9ucy5wdXNoKHtcbiAgICAgIHByb21pc2U6IG5leHQsXG4gICAgICBjYXRjaEZuOiBoYW5kbGVyXG4gICAgfSk7XG4gICAgdGhpcy5fcnVuUmVqZWN0aW9ucygpO1xuICAgIHJldHVybiBuZXh0O1xuICB9LFxuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmaXJzdFBhdXNlZCA9IHRoaXMuX2ZpbmRGaXJzdFBhdXNlZCgpO1xuICAgIGlmIChmaXJzdFBhdXNlZCkge1xuICAgICAgZmlyc3RQYXVzZWQuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgZmlyc3RQYXVzZWQuX3J1blJlc29sdXRpb25zKCk7XG4gICAgICBmaXJzdFBhdXNlZC5fcnVuUmVqZWN0aW9ucygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgX2ZpbmRBbmNlc3RyeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250aW51YXRpb25zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjdXIpIHtcbiAgICAgIGlmIChjdXIucHJvbWlzZSkge1xuICAgICAgICB2YXIgbm9kZSA9IHtcbiAgICAgICAgICBwcm9taXNlOiBjdXIucHJvbWlzZSxcbiAgICAgICAgICBjaGlsZHJlbjogY3VyLnByb21pc2UuX2ZpbmRBbmNlc3RyeSgpXG4gICAgICAgIH07XG4gICAgICAgIGFjYy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gIH0sXG4gIF9zZXRQYXJlbnQ6IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXJlbnQgYWxyZWFkeSBzZXRcIik7XG4gICAgfVxuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgX2NvbnRpbnVlV2l0aDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgZmlyc3RQZW5kaW5nID0gdGhpcy5fZmluZEZpcnN0UGVuZGluZygpO1xuICAgIGlmIChmaXJzdFBlbmRpbmcpIHtcbiAgICAgIGZpcnN0UGVuZGluZy5fZGF0YSA9IGRhdGE7XG4gICAgICBmaXJzdFBlbmRpbmcuX3NldFJlc29sdmVkKCk7XG4gICAgfVxuICB9LFxuICBfZmluZEZpcnN0UGVuZGluZzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9maW5kRmlyc3RBbmNlc3RvcihmdW5jdGlvbiAodGVzdCkge1xuICAgICAgcmV0dXJuIHRlc3QuX2lzUGVuZGluZyAmJiB0ZXN0Ll9pc1BlbmRpbmcoKTtcbiAgICB9KTtcbiAgfSxcbiAgX2ZpbmRGaXJzdFBhdXNlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9maW5kRmlyc3RBbmNlc3RvcihmdW5jdGlvbiAodGVzdCkge1xuICAgICAgcmV0dXJuIHRlc3QuX3BhdXNlZDtcbiAgICB9KTtcbiAgfSxcbiAgX2ZpbmRGaXJzdEFuY2VzdG9yOiBmdW5jdGlvbiAobWF0Y2hpbmcpIHtcbiAgICB2YXIgdGVzdCA9IHRoaXM7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB3aGlsZSAodGVzdCkge1xuICAgICAgaWYgKG1hdGNoaW5nKHRlc3QpKSB7XG4gICAgICAgIHJlc3VsdCA9IHRlc3Q7XG4gICAgICB9XG4gICAgICB0ZXN0ID0gdGVzdC5fcGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBfZmFpbFdpdGg6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHZhciBmaXJzdFJlamVjdGVkID0gdGhpcy5fZmluZEZpcnN0UGVuZGluZygpO1xuICAgIGlmIChmaXJzdFJlamVjdGVkKSB7XG4gICAgICBmaXJzdFJlamVjdGVkLl9lcnJvciA9IGVycm9yO1xuICAgICAgZmlyc3RSZWplY3RlZC5fc2V0UmVqZWN0ZWQoKTtcbiAgICB9XG4gIH0sXG4gIF90YWtlQ29udGludWF0aW9uczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250aW51YXRpb25zLnNwbGljZSgwLCB0aGlzLl9jb250aW51YXRpb25zLmxlbmd0aCk7XG4gIH0sXG4gIF9ydW5SZWplY3Rpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3BhdXNlZCB8fCAhdGhpcy5faXNSZWplY3RlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhclxuICAgICAgZXJyb3IgPSB0aGlzLl9lcnJvcixcbiAgICAgIGNvbnRpbnVhdGlvbnMgPSB0aGlzLl90YWtlQ29udGludWF0aW9ucygpLFxuICAgICAgc2VsZiA9IHRoaXM7XG4gICAgY29udGludWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb250KSB7XG4gICAgICBpZiAoY29udC5jYXRjaEZuKSB7XG4gICAgICAgIHZhciBjYXRjaFJlc3VsdCA9IGNvbnQuY2F0Y2hGbihlcnJvcik7XG4gICAgICAgIHNlbGYuX2hhbmRsZVVzZXJGdW5jdGlvblJlc3VsdChjYXRjaFJlc3VsdCwgY29udC5wcm9taXNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnQucHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBfcnVuUmVzb2x1dGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcGF1c2VkIHx8ICF0aGlzLl9pc1Jlc29sdmVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvbnRpbnVhdGlvbnMgPSB0aGlzLl90YWtlQ29udGludWF0aW9ucygpO1xuICAgIGlmIChsb29rc0xpa2VBUHJvbWlzZSh0aGlzLl9kYXRhKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZVdoZW5SZXNvbHZlZERhdGFJc1Byb21pc2UodGhpcy5fZGF0YSk7XG4gICAgfVxuICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgY29udGludWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb250KSB7XG4gICAgICBpZiAoY29udC5uZXh0Rm4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY29udC5uZXh0Rm4oZGF0YSk7XG4gICAgICAgICAgc2VsZi5faGFuZGxlVXNlckZ1bmN0aW9uUmVzdWx0KHJlc3VsdCwgY29udC5wcm9taXNlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHNlbGYuX2hhbmRsZVJlc29sdXRpb25FcnJvcihlLCBjb250KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250LnByb21pc2UpIHtcbiAgICAgICAgY29udC5wcm9taXNlLnJlc29sdmUoZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIF9oYW5kbGVSZXNvbHV0aW9uRXJyb3I6IGZ1bmN0aW9uIChlLCBjb250aW51YXRpb24pIHtcbiAgICB0aGlzLl9zZXRSZWplY3RlZCgpO1xuICAgIGlmIChjb250aW51YXRpb24uY2F0Y2hGbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udGludWF0aW9uLmNhdGNoRm4oZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIGUgPSBlMjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRpbnVhdGlvbi5wcm9taXNlKSB7XG4gICAgICBjb250aW51YXRpb24ucHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxuICB9LFxuICBfaGFuZGxlV2hlblJlc29sdmVkRGF0YUlzUHJvbWlzZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGRhdGEudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICBzZWxmLl9kYXRhID0gcmVzdWx0O1xuICAgICAgc2VsZi5fcnVuUmVzb2x1dGlvbnMoKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHNlbGYuX2Vycm9yID0gZXJyb3I7XG4gICAgICBzZWxmLl9zZXRSZWplY3RlZCgpO1xuICAgICAgc2VsZi5fcnVuUmVqZWN0aW9ucygpO1xuICAgIH0pO1xuICB9LFxuICBfaGFuZGxlVXNlckZ1bmN0aW9uUmVzdWx0OiBmdW5jdGlvbiAoZGF0YSwgbmV4dFN5bmNocm9ub3VzUHJvbWlzZSkge1xuICAgIGlmIChsb29rc0xpa2VBUHJvbWlzZShkYXRhKSkge1xuICAgICAgdGhpcy5fY2hhaW5Qcm9taXNlRGF0YShkYXRhLCBuZXh0U3luY2hyb25vdXNQcm9taXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKGRhdGEpO1xuICAgIH1cbiAgfSxcbiAgX2NoYWluUHJvbWlzZURhdGE6IGZ1bmN0aW9uIChwcm9taXNlRGF0YSwgbmV4dFN5bmNocm9ub3VzUHJvbWlzZSkge1xuICAgIHByb21pc2VEYXRhLnRoZW4oZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIG5leHRTeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZShuZXdEYXRhKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAobmV3RXJyb3IpIHtcbiAgICAgIG5leHRTeW5jaHJvbm91c1Byb21pc2UucmVqZWN0KG5ld0Vycm9yKTtcbiAgICB9KTtcbiAgfSxcbiAgX3NldFJlc29sdmVkOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBSRVNPTFZFRDtcbiAgICBpZiAoIXRoaXMuX3BhdXNlZCkge1xuICAgICAgdGhpcy5fcnVuUmVzb2x1dGlvbnMoKTtcbiAgICB9XG4gIH0sXG4gIF9zZXRSZWplY3RlZDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3RhdHVzID0gUkVKRUNURUQ7XG4gICAgaWYgKCF0aGlzLl9wYXVzZWQpIHtcbiAgICAgIHRoaXMuX3J1blJlamVjdGlvbnMoKTtcbiAgICB9XG4gIH0sXG4gIF9pc1BlbmRpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IFBFTkRJTkc7XG4gIH0sXG4gIF9pc1Jlc29sdmVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSBSRVNPTFZFRDtcbiAgfSxcbiAgX2lzUmVqZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IFJFSkVDVEVEO1xuICB9XG59O1xuXG5TeW5jaHJvbm91c1Byb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgcmV0dXJuIG5ldyBTeW5jaHJvbm91c1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmIChsb29rc0xpa2VBUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICByZXN1bHQudGhlbihmdW5jdGlvbiAobmV3UmVzdWx0KSB7XG4gICAgICAgIHJlc29sdmUobmV3UmVzdWx0KTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9XG4gIH0pO1xufTtcblxuU3luY2hyb25vdXNQcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgcmV0dXJuIG5ldyBTeW5jaHJvbm91c1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlamVjdChyZXN1bHQpO1xuICB9KTtcbn07XG5cblN5bmNocm9ub3VzUHJvbWlzZS51bnJlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFN5bmNocm9ub3VzUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgfSk7XG59O1xuXG5TeW5jaHJvbm91c1Byb21pc2UuYWxsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJncyA9IG1ha2VBcnJheUZyb20oYXJndW1lbnRzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICBhcmdzID0gYXJnc1swXTtcbiAgfVxuICBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFN5bmNocm9ub3VzUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgfVxuICByZXR1cm4gbmV3IFN5bmNocm9ub3VzUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyXG4gICAgICBhbGxEYXRhID0gW10sXG4gICAgICBudW1SZXNvbHZlZCA9IDAsXG4gICAgICBkb1Jlc29sdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChudW1SZXNvbHZlZCA9PT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICByZXNvbHZlKGFsbERhdGEpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVqZWN0ZWQgPSBmYWxzZSxcbiAgICAgIGRvUmVqZWN0ID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH07XG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcsIGlkeCkge1xuICAgICAgU3luY2hyb25vdXNQcm9taXNlLnJlc29sdmUoYXJnKS50aGVuKGZ1bmN0aW9uICh0aGlzUmVzdWx0KSB7XG4gICAgICAgIGFsbERhdGFbaWR4XSA9IHRoaXNSZXN1bHQ7XG4gICAgICAgIG51bVJlc29sdmVkICs9IDE7XG4gICAgICAgIGRvUmVzb2x2ZSgpO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBkb1JlamVjdChlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuaWYgKFByb21pc2UgPT09IFN5bmNocm9ub3VzUHJvbWlzZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgdXNlIFN5bmNocm9ub3VzUHJvbWlzZS5pbnN0YWxsR2xvYmFsbHkoKSB0byBpbnN0YWxsIGdsb2JhbGx5XCIpO1xufVxudmFyIFJlYWxQcm9taXNlID0gUHJvbWlzZTtcblN5bmNocm9ub3VzUHJvbWlzZS5pbnN0YWxsR2xvYmFsbHkgPSBmdW5jdGlvbihfX2F3YWl0ZXIpIHtcbiAgaWYgKFByb21pc2UgPT09IFN5bmNocm9ub3VzUHJvbWlzZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXI7XG4gIH0gXG4gIHZhciByZXN1bHQgPSBwYXRjaEF3YWl0ZXJJZlJlcXVpcmVkKF9fYXdhaXRlcik7XG4gIFByb21pc2UgPSBTeW5jaHJvbm91c1Byb21pc2U7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5TeW5jaHJvbm91c1Byb21pc2UudW5pbnN0YWxsR2xvYmFsbHkgPSBmdW5jdGlvbigpIHtcbiAgaWYgKFByb21pc2UgPT09IFN5bmNocm9ub3VzUHJvbWlzZSkge1xuICAgIFByb21pc2UgPSBSZWFsUHJvbWlzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcGF0Y2hBd2FpdGVySWZSZXF1aXJlZChfX2F3YWl0ZXIpIHtcbiAgaWYgKHR5cGVvZihfX2F3YWl0ZXIpID09PSBcInVuZGVmaW5lZFwiIHx8IF9fYXdhaXRlci5fX3BhdGNoZWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyO1xuICB9XG4gIHZhciBvcmlnaW5hbEF3YWl0ZXIgPSBfX2F3YWl0ZXI7XG4gIF9fYXdhaXRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBQcm9taXNlID0gUmVhbFByb21pc2U7XG4gICAgb3JpZ2luYWxBd2FpdGVyLmFwcGx5KHRoaXMsIG1ha2VBcnJheUZyb20oYXJndW1lbnRzKSk7XG4gIH07XG4gIF9fYXdhaXRlci5fX3BhdGNoZWQgPSB0cnVlO1xuICByZXR1cm4gX19hd2FpdGVyO1xufVxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFN5bmNocm9ub3VzUHJvbWlzZTogU3luY2hyb25vdXNQcm9taXNlXG59OyIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gUGx1Z2luIHRvIGFkZCAncHJvcGVydHknIChhcyBpbiBwZXJzb25hbCBwcm9wZXJ0eSkgcHJvcGVydHkgdG8gUGxheWVycyB3aGVuIHRoZXkgYXJlIGluaXRpYWxpemVkLiBNZWFudCB0byBiZSB1c2VkIGZvclxyXG4vLyBzaW11bGF0aW9ucyBpbnZvbHZpbmcgcGVyc29uYWwgcG9zZXNzaW9ucywgZm9yIGluc3RhbmNlIGVjb25vbWljIHNpbXVsYXRpb25zLlxyXG5cclxuLy8gTmFzaEpTIGVuZ2luZSBjb21wb25lbnRzXHJcbnZhciBFbmdpbmUgPSByZXF1aXJlKFwiLi4vbGliL2VuZ2luZVwiKVxyXG5cclxuLy8gR2FtZSBzdGF0ZVxyXG52YXIgeyByZWdpc3RyeSwgZ2FtZVBvcHVsYXRpb24gfSA9IEVuZ2luZS5CYWNrZW5kLlN0YXRlO1xyXG5cclxuLy8gTGV0J3MgYWRkIHNvbWUgUGxheWVyTGlzdCBmdW5jdGlvbmFsaXR5XHJcbnZhciB7IFBsYXllckxpc3QgfSA9IEVuZ2luZS5CYWNrZW5kLkNsYXNzZXM7XHJcblxyXG5cclxudmFyIEJhbGFuY2VTaGVldCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHQvLyBWYXJpYWJsZXMgdG8gc3RvcmUgc2V0dGluZ3MsIGFuZCBkZWZhdWx0c1xyXG5cdHZhciBzZXR0aW5ncyA9IHtcclxuXHRcdGFkZEJhbGFuY2VTaGVldE9uQ2xhaW06IHRydWUsXHJcblx0XHRjbGVhblplcm9zOiB0cnVlLFxyXG5cdFx0bmVnYXRpdmVBc3NldHM6IGZhbHNlXHJcblx0fVxyXG5cdC8vVE9ETyBtYWtlIG5lZ2F0aXZlQXNzZXRzIChhbmQgbmVnYXRpdmVMaWFiaWxpdGllcykgd29ya1xyXG5cclxuXHJcblx0Ly8gQXNzZXRzIENsYXNzZXNcclxuXHJcblx0Ly8gQ2xhaW0gcGFyZW50IGNsYXNzXHJcblx0dmFyIENsYWltID0gZnVuY3Rpb24oY2xhaW1hbnQsIGFtb3VudCkge1xyXG5cdFx0Ly8gQWRkIGJhbGFuY2Ugc2hlZXQgaWYgbmVjZXNzYXJ5IGFuZCBwZXJtaXR0ZWRcclxuXHRcdGlmICghY2xhaW1hbnQuYmFsYW5jZVNoZWV0KSB7XHJcblx0XHRcdGlmIChzZXR0aW5ncy5hZGRCYWxhbmNlU2hlZXRPbkNsYWltKSBhZGRFbnRyaWVzKHJlZ2lzdHJ5LnBsYXllcnNbY2xhaW1hbnQuaWQoKV0pXHJcblx0XHRcdC8vIEZhaWwgaWYgbm90IHBlcm1pdHRlZCB0byBhZGQgbmVjZXNzYXJ5IGJhbGFuY2Ugc2hlZXQuXHJcblx0XHRcdGVsc2UgcmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYW1vdW50ID0gYW1vdW50O1xyXG5cdFx0dGhpcy5jbGFpbWFudCA9IGNsYWltYW50XHJcblx0XHRjbGFpbWFudC5lbmRvdyh0aGlzKVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHQvLyBFbmQgb3duZXJzaGlwIGNsYWltXHJcblx0Q2xhaW0ucHJvdG90eXBlLmVyYXNlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLmNsYWltYW50LnJldm9rZSh0aGlzKVxyXG5cdFx0dGhpcy5jbGFpbWFudCA9IG51bGw7XHJcblx0XHR0aGlzLmFtb3VudCA9IDBcclxuXHR9XHJcblxyXG5cdC8vIE1lcmdlIGNsYWltcyBpZiB0aGV5J3JlIHRoZSBzYW1lIGZhbWlseSBidXQgZGlmZmVyZW50IGFtb3VudHNcclxuXHRDbGFpbS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihvdGhlckNsYWltKSB7XHJcblx0XHRpZiAodGhpcy5jbGFpbWFudCAhPT0gb3RoZXJDbGFpbS5jbGFpbWFudCkgcmV0dXJuIGZhbHNlXHJcblx0XHQvLyBBZGQgYW1vdW50c1xyXG5cdFx0dGhpcy5hbW91bnQgPSB0aGlzLmFtb3VudCArIG90aGVyQ2xhaW0uYW1vdW50XHJcblxyXG5cdFx0Ly8gUmVtb3ZlIGZyb20gYmFsYW5jZSBzaGVldFxyXG5cdFx0b3RoZXJDbGFpbS5lcmFzZSgpO1xyXG5cdH1cclxuXHJcblx0Ly8gU3BsaXQgdGhpcyBpbnRvIHR3byBzZXBhcmF0ZSBjbGFpbXMsIHdpdGggZGlmZmVyZW50IGFtb3VudHNcclxuXHRDbGFpbS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbihuZXdBbW91bnQpIHtcclxuXHRcdHZhciBjbG9uZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpLCB0aGlzKTtcclxuXHRcdGNsb25lLmFtb3VudCA9IG5ld0Ftb3VudDtcclxuXHRcdHRoaXMuYW1vdW50ID0gdGhpcy5hbW91bnQgLSBuZXdBbW91bnQ7XHJcblx0XHR0aGlzLmNsYWltYW50LmVuZG93KGNsb25lLCBmYWxzZSlcclxuXHRcdHJldHVybiBjbG9uZTtcclxuXHR9XHJcblxyXG5cdC8vIFRyYW5zZmVyIHRvIG5ldyBvd25lclxyXG5cdENsYWltLnByb3RvdHlwZS50cmFuc2ZlciA9IGZ1bmN0aW9uKG5ld0NsYWltYW50LCBhbW91bnQgPSBcImFsbFwiKSB7XHJcblx0XHQvLyBBZGQgYmFsYW5jZSBzaGVldCBpZiBuZWNlc3NhcnkgYW5kIHBlcm1pdHRlZFxyXG5cdFx0aWYgKCFuZXdDbGFpbWFudC5iYWxhbmNlU2hlZXQpIHtcclxuXHRcdFx0aWYgKHNldHRpbmdzLmFkZEJhbGFuY2VTaGVldE9uQ2xhaW0pIGFkZEVudHJpZXMocmVnaXN0cnkucGxheWVyc1tuZXdDbGFpbWFudC5pZCgpXSlcclxuXHRcdFx0Ly8gRmFpbCBpZiBub3QgcGVybWl0dGVkIHRvIGFkZCBuZWNlc3NhcnkgYmFsYW5jZSBzaGVldC5cclxuXHRcdFx0ZWxzZSByZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVHJhbnNmZXIgYWxsIG9mIGl0XHJcblx0XHRpZiAoYW1vdW50ID09IFwiYWxsXCIgfHwgYW1vdW50ID09IHRoaXMuYW1vdW50KSB7XHJcblx0XHRcdHZhciBvbGRDbGFpbWFudCA9IHRoaXMuY2xhaW1hbnQ7XHJcblx0XHRcdHRoaXMuY2xhaW1hbnQucmV2b2tlKHRoaXMpO1xyXG5cdFx0XHR0aGlzLmNsYWltYW50ID0gbmV3Q2xhaW1hbnQ7XHJcblx0XHRcdG5ld0NsYWltYW50LmVuZG93KHRoaXMpO1xyXG5cclxuXHRcdH1cclxuXHRcdC8vIG9yIG9ubHkgYSBwb3J0aW9uXHJcblx0XHRlbHNlIHtcclxuXHRcdFx0dmFyIG5ld0NsYWltID0gdGhpcy5zcGxpdChhbW91bnQpO1xyXG5cdFx0XHRuZXdDbGFpbS50cmFuc2ZlcihuZXdDbGFpbWFudCwgXCJhbGxcIilcclxuXHRcdFx0Y2xlYW5Bc3NldCh0aGlzKVxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cclxuXHJcblx0Ly8gQ2xhaW1zIG9uIHJlYWwgdGhpbmdzIChsaWtlIGNhcnMsIGhvdXNlcywgZ29sZClcclxuXHR2YXIgUmVhbENsYWltID0gZnVuY3Rpb24oY2xhaW1hbnQsIGdvb2QsIGFtb3VudCkge1xyXG5cdFx0aWYgKCFDbGFpbS5jYWxsKHRoaXMsIGNsYWltYW50LCBhbW91bnQpKSByZXR1cm4gZmFsc2U7XHJcblx0XHR0aGlzLmdvb2QgPSBnb29kO1xyXG5cdH1cclxuXHRSZWFsQ2xhaW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFpbS5wcm90b3R5cGUpXHJcblx0UmVhbENsYWltLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlYWxDbGFpbVxyXG5cclxuXHQvLyBMb3NlIHZhbHVlIGJ5IHBlcmNlbnRhZ2VcclxuXHRSZWFsQ2xhaW0ucHJvdG90eXBlLmRlcHJlY2lhdGUgPSBmdW5jdGlvbihyYXRlID0gLjEpIHtcclxuXHRcdHRoaXMuYW1vdW50ID0gdGhpcy5hbW91bnQgKiAoMSAtIHJhdGUpXHJcblx0fVxyXG5cclxuXHQvLyBBZGQgZ29vZCBlbmZvcmNlbWVudCB0byBtZXJnZVxyXG5cdFJlYWxDbGFpbS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihvdGhlckNsYWltKSB7XHJcblx0XHRpZiAodGhpcy5nb29kID09PSBvdGhlckNsYWltLmdvb2QpIHJldHVybiBDbGFpbS5wcm90b3R5cGUubWVyZ2UuY2FsbCh0aGlzLCBvdGhlckNsYWltKTtcclxuXHR9XHJcblxyXG5cdC8vIFJlcGxhY2UgcGxheWVyIG9iamVjdCB3aXRoIGlkIHdoZW4gc3RyaW5naWZ5aW5nXHJcblx0UmVhbENsYWltLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGNsYWltYW50OiB0aGlzLmNsYWltYW50LmlkKCksXHJcblx0XHRcdGdvb2Q6IHRoaXMuZ29vZCxcclxuXHRcdFx0YW1vdW50OiB0aGlzLmFtb3VudFxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQ2xhaW1zIG9uIG90aGVyIGVudGl0aWVzIHdpdGggYmFsYW5jZSBzaGVldHNcclxuXHR2YXIgRmluYW5jaWFsQ2xhaW0gPSBmdW5jdGlvbihjbGFpbWFudCwgY2xhaW1lZCwgYW1vdW50LCBpbnN0cnVtZW50ID0gXCJEZWJ0XCIpIHtcclxuXHRcdC8vIEFkZCBiYWxhbmNlIHNoZWV0IGlmIG5lY2Vzc2FyeSBhbmQgcGVybWl0dGVkXHJcblx0XHRpZiAoIWNsYWltZWQuYmFsYW5jZVNoZWV0KSB7XHJcblx0XHRcdGlmIChzZXR0aW5ncy5hZGRCYWxhbmNlU2hlZXRPbkNsYWltKSBhZGRFbnRyaWVzKHJlZ2lzdHJ5LnBsYXllcnNbY2xhaW1lZC5pZCgpXSlcclxuXHRcdFx0Ly8gRmFpbCBpZiBub3QgcGVybWl0dGVkIHRvIGFkZCBuZWNlc3NhcnkgYmFsYW5jZSBzaGVldC5cclxuXHRcdFx0ZWxzZSByZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHR0aGlzLmNsYWltZWQgPSBjbGFpbWVkO1xyXG5cdFx0dGhpcy5pbnN0cnVtZW50ID0gaW5zdHJ1bWVudDtcclxuXHJcblx0XHRpZiAoIUNsYWltLmNhbGwodGhpcywgY2xhaW1hbnQsIGFtb3VudCkpIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRjbGFpbWVkLmluZGVidCh0aGlzKVxyXG5cdH1cclxuXHRGaW5hbmNpYWxDbGFpbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYWltLnByb3RvdHlwZSlcclxuXHRGaW5hbmNpYWxDbGFpbS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGaW5hbmNpYWxDbGFpbVxyXG5cclxuXHQvLyBBZGQgdG8gZXJhc2UgZnVuY3Rpb24sIHRvIGVyYXNlIGZyb20gY2xhaW1lZCdzIGJhbGFuY2Ugc2hlZXQgdG9vXHJcblx0RmluYW5jaWFsQ2xhaW0ucHJvdG90eXBlLmVyYXNlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgYnMgPSByZWdpc3RyeS5wbGF5ZXJzW3RoaXMuY2xhaW1lZC5pZCgpXS5iYWxhbmNlU2hlZXQubGlhYmlsaXRpZXNcclxuXHRcdGJzLnNwbGljZShicy5pbmRleE9mKHRoaXMpLCAxKVxyXG5cdFx0dGhpcy5jbGFpbWVkID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gQ2xhaW0ucHJvdG90eXBlLmVyYXNlLmNhbGwodGhpcylcclxuXHR9XHJcblxyXG5cdC8vIEFkZCBjbGFpbWVkIGVuZm9yY2VtZW50IHRvIG1lcmdlXHJcblx0RmluYW5jaWFsQ2xhaW0ucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24ob3RoZXJDbGFpbSkge1xyXG5cdFx0aWYgKHRoaXMuY2xhaW1lZCA9PT0gb3RoZXJDbGFpbS5jbGFpbWVkKSByZXR1cm4gQ2xhaW0ucHJvdG90eXBlLm1lcmdlLmNhbGwodGhpcywgb3RoZXJDbGFpbSk7XHJcblx0fVxyXG5cclxuXHJcblx0Ly8gQWRkIHRvIHNwbGl0IGZ1bmN0aW9uLCB0byBzcGxpdCBvbiBjbGFpbWVkJ3MgYmFsYW5jZSBzaGVldCB0b29cclxuXHRGaW5hbmNpYWxDbGFpbS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbihuZXdBbW91bnQpIHtcclxuXHRcdHZhciBjbG9uZSA9IENsYWltLnByb3RvdHlwZS5zcGxpdC5jYWxsKHRoaXMsIG5ld0Ftb3VudCk7XHJcblx0XHRjbG9uZS5jbGFpbWVkLmluZGVidChjbG9uZSwgZmFsc2UpO1xyXG5cdFx0cmV0dXJuIGNsb25lO1xyXG5cdH1cclxuXHJcblx0Ly8gUmVwbGFjZSBwbGF5ZXIgb2JqZWN0IHdpdGggaWQgd2hlbiBzdHJpbmdpZnlpbmdcclxuXHRGaW5hbmNpYWxDbGFpbS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRjbGFpbWFudDogdGhpcy5jbGFpbWFudC5pZCgpLFxyXG5cdFx0XHRjbGFpbWVkOiB0aGlzLmNsYWltZWQuaWQoKSxcclxuXHRcdFx0aW5zdHJ1bWVudDogdGhpcy5pbnN0cnVtZW50LFxyXG5cdFx0XHRhbW91bnQ6IHRoaXMuYW1vdW50XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHJcblx0Ly8gQ2xlYW4gdGhlIHNpbWlsYXIgY2xhaW1zIG9uIHRoZSBjbGFpbWFudCBzdXBwbGllZFxyXG5cdHZhciBjbGVhbkFzc2V0ID0gZnVuY3Rpb24oY2xhaW0pIHtcclxuXHRcdHZhciBicyA9IHJlZ2lzdHJ5LnBsYXllcnNbY2xhaW0uY2xhaW1hbnQuaWQoKV0uYmFsYW5jZVNoZWV0LmFzc2V0cztcclxuXHJcblx0XHR2YXIgZGlydHkgPSBicy5maWx0ZXIoZnVuY3Rpb24oZW50cnkpIHtcclxuXHRcdFx0cmV0dXJuIChlbnRyeSAhPT0gY2xhaW0gJiYgZW50cnkuZ29vZCA9PT0gY2xhaW0uZ29vZCAmJiBlbnRyeS5pbnN0cnVtZW50ID09PSBjbGFpbS5pbnN0cnVtZW50KTtcclxuXHRcdH0pXHJcblxyXG5cdFx0ZGlydHkuZm9yRWFjaChmdW5jdGlvbihkaXJ0KSB7XHJcblx0XHRcdGNsYWltLm1lcmdlKGRpcnQpXHJcblx0XHR9KVxyXG5cclxuXHRcdGlmIChzZXR0aW5ncy5jbGVhblplcm9zICYmIGNsYWltLmFtb3VudCA9PSAwKSBjbGFpbS5lcmFzZSgpXHJcblx0fVxyXG5cclxuXHR2YXIgY2xlYW5MaWFiaWxpdHkgPSBmdW5jdGlvbihjbGFpbSkge1xyXG5cdFx0dmFyIGJzID0gcmVnaXN0cnkucGxheWVyc1tjbGFpbS5jbGFpbWVkLmlkKCldLmJhbGFuY2VTaGVldC5saWFiaWxpdGllcztcclxuXHJcblx0XHR2YXIgZGlydHkgPSBicy5maWx0ZXIoZnVuY3Rpb24oZW50cnkpIHtcclxuXHRcdFx0cmV0dXJuIChlbnRyeSAhPT0gY2xhaW0gJiYgZW50cnkuY2xhaW1hbnQgPT09IGNsYWltLmNsYWltYW50ICYmIGVudHJ5Lmluc3RydW1lbnQgPT09IGNsYWltLmluc3RydW1lbnQpO1xyXG5cdFx0fSlcclxuXHJcblx0XHRkaXJ0eS5mb3JFYWNoKGZ1bmN0aW9uKGRpcnQpIHtcclxuXHRcdFx0Y2xhaW0ubWVyZ2UoZGlydClcclxuXHRcdH0pXHJcblxyXG5cdFx0aWYgKHNldHRpbmdzLmNsZWFuWmVyb3MgJiYgY2xhaW0uYW1vdW50ID09IDApIGNsYWltLmVyYXNlXHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8vIEFkZCBiYWxhbmNlIHNoZWV0IG9iamVjdCBhbmQgbWV0aG9kcyB0byBwbGF5ZXIuXHJcblx0dmFyIGFkZEVudHJpZXMgPSBmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHJcblx0XHQvL19wbGF5ZXIgcHJvcGVydGllcy9tZXRob2RzXHJcblx0XHRwbGF5ZXIuYmFsYW5jZVNoZWV0ID0geyBhc3NldHM6IFtdLCBsaWFiaWxpdGllczogW10gfVxyXG5cclxuXHRcdC8qXHJcblx0XHR2YXIgbG9va3VwID0gZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0XHR0aGlzLnJlZHVjZShmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUpIHtcclxuXHRcdFx0XHRpZiAodHlwZSA9PT0gdmFsdWUuZ29vZCkgYWNjdW11bGF0b3IgKz0gdmFsdWUuYW1vdW50XHJcblx0XHRcdFx0ZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIE9iamVjdCAmJiB0eXBlLmluc3RydW1lbnQgPT0gdmFsdWUuaW5zdHJ1bWVudCAmJiAodHlwZS5jbGFpbWVkID09PSB2YWx1ZS5jbGFpbWVkKSlcclxuXHRcdFx0XHRcdGFjY3VtdWxhdG9yICs9IHZhbHVlLmFtb3VudFxyXG5cdFx0XHRcdHJldHVybiBhY2N1bXVsYXRvcjtcclxuXHRcdFx0fSwgMClcclxuXHRcdH1cclxuXHRcdHBsYXllci5iYWxhbmNlU2hlZXQuYXNzZXRzLmxvb2t1cCA9IGxvb2t1cDtcclxuXHRcdHBsYXllci5iYWxhbmNlU2hlZXQubGlhYmlsaXRpZXMubG9va3VwID0gbG9va3VwO1xyXG5cdFx0Ki9cclxuXHJcblx0XHRwbGF5ZXIubmV0V29ydGggPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdHZhciBhc3NldHMgPSB0aGlzLmJhbGFuY2VTaGVldC5hc3NldHMucmVkdWNlKGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpIHtcclxuXHRcdFx0XHRyZXR1cm4gYWNjdW11bGF0b3IgKyBjdXJyZW50VmFsdWUuYW1vdW50XHJcblx0XHRcdH0sIDApO1xyXG5cclxuXHRcdFx0dmFyIGxpYWJpbGl0aWVzID0gdGhpcy5iYWxhbmNlU2hlZXQubGlhYmlsaXRpZXMucmVkdWNlKGZ1bmN0aW9uKGFjY3VtdWxhdG9yLFxyXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSkge1xyXG5cdFx0XHRcdHJldHVybiBhY2N1bXVsYXRvciArIGN1cnJlbnRWYWx1ZS5hbW91bnRcclxuXHRcdFx0fSwgMCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gYXNzZXRzIC0gbGlhYmlsaXRpZXM7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVXNlciBpbnRlcmZhY2VcclxuXHRcdHBsYXllci5pbnRlcmZhY2UuYmFsYW5jZVNoZWV0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyLmlkXS5iYWxhbmNlU2hlZXQpKTtcclxuXHRcdH1cclxuXHJcblx0XHRwbGF5ZXIuaW50ZXJmYWNlLm5ldFdvcnRoID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiByZWdpc3RyeS5wbGF5ZXJzW3BsYXllci5pZF0ubmV0V29ydGgoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBUT0RPIHZhbGlkYXRlIG9iamVjdC5cclxuXHRcdHBsYXllci5pbnRlcmZhY2UuZW5kb3cgPSBmdW5jdGlvbihhc3NldCwgY2xlYW4gPSB0cnVlKSB7XHJcblx0XHRcdGlmIChhc3NldCBpbnN0YW5jZW9mIENsYWltKSB7XHJcblx0XHRcdFx0cmVnaXN0cnkucGxheWVyc1twbGF5ZXIuaWRdLmJhbGFuY2VTaGVldC5hc3NldHMucHVzaChhc3NldCk7XHJcblx0XHRcdFx0aWYgKGNsZWFuKSBjbGVhbkFzc2V0KGFzc2V0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHBsYXllci5pbnRlcmZhY2UuaW5kZWJ0ID0gZnVuY3Rpb24obGlhYmlsaXR5LCBjbGVhbiA9IHRydWUpIHtcclxuXHRcdFx0aWYgKGxpYWJpbGl0eSBpbnN0YW5jZW9mIEZpbmFuY2lhbENsYWltKSB7XHJcblx0XHRcdFx0cmVnaXN0cnkucGxheWVyc1twbGF5ZXIuaWRdLmJhbGFuY2VTaGVldC5saWFiaWxpdGllcy5wdXNoKFxyXG5cdFx0XHRcdFx0bGlhYmlsaXR5KTtcclxuXHRcdFx0XHRpZiAoY2xlYW4pIGNsZWFuTGlhYmlsaXR5KGxpYWJpbGl0eSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRwbGF5ZXIuaW50ZXJmYWNlLnJldm9rZSA9IGZ1bmN0aW9uKGFzc2V0KSB7XHJcblx0XHRcdGlmIChhc3NldCBpbnN0YW5jZW9mIENsYWltKSB7XHJcblx0XHRcdFx0dmFyIGJzID0gcmVnaXN0cnkucGxheWVyc1twbGF5ZXIuaWRdLmJhbGFuY2VTaGVldC5hc3NldHNcclxuXHRcdFx0XHRicy5zcGxpY2UoYnMuaW5kZXhPZihhc3NldCksIDEpXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBUT0RPIGNvbnZlcnQgdGhpcyBvdmVyXHJcblx0XHRwbGF5ZXIuaW50ZXJmYWNlLmxlbmQgPSBmdW5jdGlvbihib3Jyb3dlciwgYW1vdW50LCBpbnN0cnVtZW50ID0gXCJEZWJ0XCIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBGaW5hbmNpYWxDbGFpbShwbGF5ZXIuaW50ZXJmYWNlLCBib3Jyb3dlciwgYW1vdW50LCBpbnN0cnVtZW50KVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBUaGUgcGx1Z2luIG9iamVjdC5cclxuXHR2YXIgUGx1Z2luID0ge1xyXG5cdFx0bmFtZTogXCJiYWxhbmNlLXNoZWV0LWNvbXBsZXhcIixcclxuXHJcblx0XHRzZXR0aW5nczogZnVuY3Rpb24ocGFyYW1ldGVycyA9IHt9KSB7XHJcblx0XHRcdE9iamVjdC5hc3NpZ24oc2V0dGluZ3MsIHBhcmFtZXRlcnMpXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIE9wdGlvbiB0byBpbml0aWFsaXplIGJ5IGNyZWF0aW5nICdwcm9wZXJ0eScgZm9yIGEgZ3JvdXAgb2YgcGxheWVycy5cclxuXHRcdGluaXQocGxheWVycyA9IFtdKSB7XHJcblx0XHRcdC8vIEFkZCBzb21lIHBsYXllcmxpc3QgZnVuY3Rpb25hbGl0eVxyXG5cdFx0XHRQbGF5ZXJMaXN0LnByb3RvdHlwZS5iYWxhbmNlU2hlZXRzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdFx0aWYgKHBsYXllci5iYWxhbmNlU2hlZXQpIHJldHVybiBwbGF5ZXIuaW50ZXJmYWNlLmJhbGFuY2VTaGVldCgpO1xyXG5cdFx0XHRcdFx0ZWxzZSByZXR1cm4gbnVsbDtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0UGxheWVyTGlzdC5wcm90b3R5cGUuYXNzZXRzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdFx0aWYgKHBsYXllci5iYWxhbmNlU2hlZXQpIHJldHVybiBwbGF5ZXIuaW50ZXJmYWNlLmJhbGFuY2VTaGVldCgpLmFzc2V0cztcclxuXHRcdFx0XHRcdGVsc2UgcmV0dXJuIG51bGw7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdFBsYXllckxpc3QucHJvdG90eXBlLmxpYWJpbGl0aWVzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdFx0aWYgKHBsYXllci5iYWxhbmNlU2hlZXQpIHJldHVybiBwbGF5ZXIuaW50ZXJmYWNlLmJhbGFuY2VTaGVldCgpLmxpYWJpbGl0aWVzO1xyXG5cdFx0XHRcdFx0ZWxzZSByZXR1cm4gbnVsbDtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0UGxheWVyTGlzdC5wcm90b3R5cGUubmV0V29ydGggPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0XHRpZiAocGxheWVyLmJhbGFuY2VTaGVldCkgcmV0dXJuIHBsYXllci5uZXRXb3J0aCgpO1xyXG5cdFx0XHRcdFx0ZWxzZSByZXR1cm4gbnVsbDtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0UGxheWVyTGlzdC5wcm90b3R5cGUuemVyb0JhbGFuY2VTaGVldHMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR0aGlzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0XHRhZGRFbnRyaWVzKHBsYXllcilcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQWRkIGJzIGZvciBzcGVjaWZpZWQgcGxheWVyc1xyXG5cdFx0XHRwbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0YWRkRW50cmllcyhyZWdpc3RyeS5wbGF5ZXJzW3BsYXllci5pZCgpXSk7XHJcblx0XHRcdH0pXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIElmIHdlJ3ZlIGluaXQtZWQgYWxyZWR5LCBqdXN0IGFkZCBicydzIHRvIHRoZSBjdXJyZW50IHBsYXllciBsaXN0IGlmIHRoZXkgZG9uJ3QgaGF2ZSBhbHJlYWR5XHJcblx0XHRyZXF1aXJlKHBsYXllcnMgPSBbXSkge1xyXG5cdFx0XHRwbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0aWYgKCFwbGF5ZXIuYmFsYW5jZVNoZWV0KSBhZGRFbnRyaWVzKHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyLmlkKCldKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdHN0b3AoKSB7XHJcblx0XHRcdC8vIHJlbW92ZSBwcm90b3R5cGUgYWRkRW50cmllc1xyXG5cdFx0XHRkZWxldGUgUGxheWVyTGlzdC5wcm90b3R5cGUuYmFsYW5jZVNoZWV0cztcclxuXHRcdFx0ZGVsZXRlIFBsYXllckxpc3QucHJvdG90eXBlLmFzc2V0cztcclxuXHRcdFx0ZGVsZXRlIFBsYXllckxpc3QucHJvdG90eXBlLmxpYWJpbGl0aWVzO1xyXG5cdFx0XHRkZWxldGUgUGxheWVyTGlzdC5wcm90b3R5cGUubmV0V29ydGg7XHJcblxyXG5cdFx0XHQvLyBkZWxldGUgYmFsYW5jZSBzaGVldCBwcm9wZXJ0aWVzIGZyb20gZXZlcnkgcGxheWVyIGFuZCBpbnRlcmZhY2UuXHJcblx0XHRcdGdhbWVQb3B1bGF0aW9uKCkuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLmJhbGFuY2VTaGVldDtcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLm5ldFdvcnRoO1xyXG5cdFx0XHRcdGRlbGV0ZSBwbGF5ZXIuaW50ZXJmYWNlLmJhbGFuY2VTaGVldDtcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLmludGVyZmFjZS5uZXRXb3J0aDtcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLmludGVyZmFjZS5lbmRvd0Fzc2V0cztcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLmludGVyZmFjZS5sZW5kO1xyXG5cdFx0XHR9KVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBQdWJsaWMgY2xhc3NlcyBmb3IgYXNzZXQvbGlhYmlsaXR5XHJcblx0XHRwdWJsaWNJZkFjdGl2ZToge1xyXG5cdFx0XHRSZWFsQ2xhaW0sXHJcblx0XHRcdEZpbmFuY2lhbENsYWltXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGNyZWF0ZSBwcm9wZXJ0eSBhbmQgaW50ZXJmYWNlIGZ1bmN0aW9uIHdoZW4gcGxheWVyIGlzIGNyZWF0ZWRcclxuXHRcdCdwbGF5ZXItY3JlYXRlJzogYWRkRW50cmllcyxcclxuXHJcblx0XHQvLyBCbGFuayBwcm9wZXJ0eSB3aGVuIHBsYXllciBpcyByZS1pbml0aWFsaXplZFxyXG5cdFx0XCJwbGF5ZXItcmVpbml0aWFsaXplXCIgKHBsYXllcikge1xyXG5cdFx0XHRwbGF5ZXIuYmFsYW5jZVNoZWV0ID0geyBhc3NldHM6IFtdLCBsaWFiaWxpdGllczogW10gfVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIFBsdWdpbjtcclxufVxyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhbGFuY2VTaGVldDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBQbHVnaW4gdG8gYWRkICdwcm9wZXJ0eScgKGFzIGluIHBlcnNvbmFsIHByb3BlcnR5KSBwcm9wZXJ0eSB0byBQbGF5ZXJzIHdoZW4gdGhleSBhcmUgaW5pdGlhbGl6ZWQuIE1lYW50IHRvIGJlIHVzZWQgZm9yXHJcbi8vIHNpbXVsYXRpb25zIGludm9sdmluZyBwZXJzb25hbCBwb3Nlc3Npb25zLCBmb3IgaW5zdGFuY2UgZWNvbm9taWMgc2ltdWxhdGlvbnMuXHJcblxyXG4vLyBOYXNoSlMgZW5naW5lIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG4vLyBHYW1lIHN0YXRlXHJcbnZhciB7IHJlZ2lzdHJ5LCBnYW1lUG9wdWxhdGlvbiB9ID0gRW5naW5lLkJhY2tlbmQuU3RhdGU7XHJcblxyXG4vLyBMZXQncyBhZGQgc29tZSBQbGF5ZXJMaXN0IGZ1bmN0aW9uYWxpdHlcclxudmFyIHsgUGxheWVyTGlzdCB9ID0gRW5naW5lLkJhY2tlbmQuQ2xhc3NlcztcclxuXHJcblxyXG52YXIgQmFsYW5jZVNoZWV0ID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHZhciBhZGRFbnRyaWVzID0gZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHQvL19wbGF5ZXIgcHJvcGVydGllcy9tZXRob2RzXHJcblx0XHRwbGF5ZXIuYmFsYW5jZVNoZWV0ID0geyBhc3NldHM6IHt9LCBsaWFiaWxpdGllczoge30gfVxyXG5cclxuXHRcdHBsYXllci5uZXRXb3J0aCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0dmFyIGFzc2V0cyA9IE9iamVjdC5lbnRyaWVzKHRoaXMuYmFsYW5jZVNoZWV0LmFzc2V0cykucmVkdWNlKGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpIHtcclxuXHRcdFx0XHRyZXR1cm4gYWNjdW11bGF0b3IgKyBjdXJyZW50VmFsdWVbMV1cclxuXHRcdFx0fSwgMCk7XHJcblxyXG5cdFx0XHR2YXIgbGlhYmlsaXRpZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLmJhbGFuY2VTaGVldC5saWFiaWxpdGllcykucmVkdWNlKGZ1bmN0aW9uKGFjY3VtdWxhdG9yLFxyXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSkge1xyXG5cdFx0XHRcdHJldHVybiBhY2N1bXVsYXRvciArIGN1cnJlbnRWYWx1ZVsxXVxyXG5cdFx0XHR9LCAwKTtcclxuXHJcblx0XHRcdHJldHVybiBhc3NldHMgLSBsaWFiaWxpdGllcztcclxuXHRcdH1cclxuXHJcblx0XHQvLyBVc2VyIGludGVyZmFjZVxyXG5cdFx0cGxheWVyLmludGVyZmFjZS5iYWxhbmNlU2hlZXQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVnaXN0cnkucGxheWVyc1twbGF5ZXIuaWRdLmJhbGFuY2VTaGVldCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHBsYXllci5pbnRlcmZhY2UubmV0V29ydGggPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyLmlkXS5uZXRXb3J0aCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRPRE8gdmFsaWRhdGUgb2JqZWN0LiBTaG91bGQgYmUgb2YgZm9ybSB7YXBwbGVzOjIsIGRvZ3M6MX1cclxuXHRcdHBsYXllci5pbnRlcmZhY2UuZW5kb3dBc3NldHMgPSBmdW5jdGlvbihhc3NldE9iamVjdCkge1xyXG5cclxuXHRcdFx0T2JqZWN0LmFzc2lnbihyZWdpc3RyeS5wbGF5ZXJzW3BsYXllci5pZF0uYmFsYW5jZVNoZWV0LmFzc2V0cywgYXNzZXRPYmplY3QpXHJcblx0XHR9XHJcblxyXG5cdFx0cGxheWVyLmludGVyZmFjZS5sZW5kID0gZnVuY3Rpb24obG9hbk9iamVjdCkge1xyXG5cdFx0XHQvL1RPRE8gdmFsaWRhdGUgb2JqZWN0LiBTaG91bGQgYmUgb2YgZm9ybSB7cGxheWVyMTp7bW9ydGdhZ2U6MTB9fVxyXG5cdFx0XHR2YXIgbGVuZGVyID0gcmVnaXN0cnkucGxheWVyc1twbGF5ZXIuaWRdLmJhbGFuY2VTaGVldC5hc3NldHNcclxuXHRcdFx0T2JqZWN0LmVudHJpZXMobG9hbk9iamVjdCkuZm9yRWFjaChmdW5jdGlvbihsb2FuVG8pIHtcclxuXHRcdFx0XHR2YXIgZGVidHM7XHJcblx0XHRcdFx0bGVuZGVyW2xvYW5Ub1swXV0gP1xyXG5cdFx0XHRcdFx0ZGVidHMgPSBsZW5kZXJbbG9hblRvWzBdXSA6IGRlYnRzID0gbGVuZGVyW2xvYW5Ub1swXV0gPSB7fTtcclxuXHJcblx0XHRcdFx0T2JqZWN0LmVudHJpZXMobG9hblRvWzFdKS5mb3JFYWNoKGZ1bmN0aW9uKG5ld0xvYW4pIHtcclxuXHRcdFx0XHRcdGRlYnRzW25ld0xvYW5bMF1dID8gZGVidHNbbmV3TG9hblswXV0gKz0gbmV3TG9hblsxXSA6IGRlYnRzW25ld0xvYW5bMF1dID0gbmV3TG9hblsxXVxyXG5cdFx0XHRcdFx0cmVnaXN0cnkucGxheWVyc1tsb2FuVG9bMF1dLmJhbGFuY2VTaGVldC5saWFiaWxpdGllc1tuZXdMb2FuWzBdXSA/IHJlZ2lzdHJ5LnBsYXllcnNbbG9hblRvWzBdXS5iYWxhbmNlU2hlZXRcclxuXHRcdFx0XHRcdFx0LmxpYWJpbGl0aWVzW25ld0xvYW5bMF1dICs9IG5ld0xvYW5bMV0gOiByZWdpc3RyeS5wbGF5ZXJzW2xvYW5Ub1swXV0uYmFsYW5jZVNoZWV0LmxpYWJpbGl0aWVzW1xyXG5cdFx0XHRcdFx0XHRcdG5ld0xvYW5bMF1dID0gbmV3TG9hblsxXTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8vIFRoZSBwbHVnaW4gb2JqZWN0LlxyXG5cdHZhciBQbHVnaW4gPSB7XHJcblx0XHRuYW1lOiBcImJhbGFuY2Utc2hlZXRcIixcclxuXHJcblx0XHQvLyBPcHRpb24gdG8gaW5pdGlhbGl6ZSBieSBjcmVhdGluZyAncHJvcGVydHknIGZvciBhIGdyb3VwIG9mIHBsYXllcnMuXHJcblx0XHRpbml0KHBsYXllcnMgPSBbXSkge1xyXG5cdFx0XHQvLyBBZGQgc29tZSBwbGF5ZXJsaXN0IGZ1bmN0aW9uYWxpdHlcclxuXHRcdFx0UGxheWVyTGlzdC5wcm90b3R5cGUuYmFsYW5jZVNoZWV0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0XHRcdGlmIChwbGF5ZXIuYmFsYW5jZVNoZWV0KSByZXR1cm4gcGxheWVyLmludGVyZmFjZS5iYWxhbmNlU2hlZXQoKTtcclxuXHRcdFx0XHRcdGVsc2UgcmV0dXJuIG51bGw7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdFBsYXllckxpc3QucHJvdG90eXBlLmFzc2V0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0XHRcdGlmIChwbGF5ZXIuYmFsYW5jZVNoZWV0KSByZXR1cm4gcGxheWVyLmludGVyZmFjZS5iYWxhbmNlU2hlZXQoKS5hc3NldHM7XHJcblx0XHRcdFx0XHRlbHNlIHJldHVybiBudWxsO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRQbGF5ZXJMaXN0LnByb3RvdHlwZS5saWFiaWxpdGllcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihwbGF5ZXIpIHtcclxuXHRcdFx0XHRcdGlmIChwbGF5ZXIuYmFsYW5jZVNoZWV0KSByZXR1cm4gcGxheWVyLmludGVyZmFjZS5iYWxhbmNlU2hlZXQoKS5saWFiaWxpdGllcztcclxuXHRcdFx0XHRcdGVsc2UgcmV0dXJuIG51bGw7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdFBsYXllckxpc3QucHJvdG90eXBlLm5ldFdvcnRoID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdFx0aWYgKHBsYXllci5iYWxhbmNlU2hlZXQpIHJldHVybiBwbGF5ZXIubmV0V29ydGgoKTtcclxuXHRcdFx0XHRcdGVsc2UgcmV0dXJuIG51bGw7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdFBsYXllckxpc3QucHJvdG90eXBlLnplcm9CYWxhbmNlU2hlZXRzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdFx0YWRkRW50cmllcyhwbGF5ZXIpXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEFkZCBicyBmb3Igc3BlY2lmaWVkIHBsYXllcnNcclxuXHRcdFx0cGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdGFkZEVudHJpZXMocmVnaXN0cnkucGxheWVyc1twbGF5ZXIuaWQoKV0pO1xyXG5cdFx0XHR9KVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBJZiB3ZSd2ZSBpbml0LWVkIGFscmVkeSwganVzdCBhZGQgYnMncyB0byB0aGUgY3VycmVudCBwbGF5ZXIgbGlzdCBpZiB0aGV5IGRvbid0IGhhdmUgYWxyZWFkeVxyXG5cdFx0cmVxdWlyZShwbGF5ZXJzID0gW10pIHtcclxuXHRcdFx0cGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRcdGlmICghcGxheWVyLmJhbGFuY2VTaGVldCkgYWRkRW50cmllcyhyZWdpc3RyeS5wbGF5ZXJzW3BsYXllci5pZCgpXSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHRzdG9wKCkge1xyXG5cdFx0XHQvLyByZW1vdmUgcHJvdG90eXBlIGFkZEVudHJpZXNcclxuXHRcdFx0ZGVsZXRlIFBsYXllckxpc3QucHJvdG90eXBlLmJhbGFuY2VTaGVldHM7XHJcblx0XHRcdGRlbGV0ZSBQbGF5ZXJMaXN0LnByb3RvdHlwZS5hc3NldHM7XHJcblx0XHRcdGRlbGV0ZSBQbGF5ZXJMaXN0LnByb3RvdHlwZS5saWFiaWxpdGllcztcclxuXHRcdFx0ZGVsZXRlIFBsYXllckxpc3QucHJvdG90eXBlLm5ldFdvcnRoO1xyXG5cclxuXHRcdFx0Ly8gZGVsZXRlIGJhbGFuY2Ugc2hlZXQgcHJvcGVydGllcyBmcm9tIGV2ZXJ5IHBsYXllciBhbmQgaW50ZXJmYWNlLlxyXG5cdFx0XHRnYW1lUG9wdWxhdGlvbigpLmZvckVhY2goZnVuY3Rpb24ocGxheWVyKSB7XHJcblx0XHRcdFx0ZGVsZXRlIHBsYXllci5iYWxhbmNlU2hlZXQ7XHJcblx0XHRcdFx0ZGVsZXRlIHBsYXllci5uZXRXb3J0aDtcclxuXHRcdFx0XHRkZWxldGUgcGxheWVyLmludGVyZmFjZS5iYWxhbmNlU2hlZXQ7XHJcblx0XHRcdFx0ZGVsZXRlIHBsYXllci5pbnRlcmZhY2UubmV0V29ydGg7XHJcblx0XHRcdFx0ZGVsZXRlIHBsYXllci5pbnRlcmZhY2UuZW5kb3dBc3NldHM7XHJcblx0XHRcdFx0ZGVsZXRlIHBsYXllci5pbnRlcmZhY2UubGVuZDtcclxuXHRcdFx0fSlcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gY3JlYXRlIHByb3BlcnR5IGFuZCBpbnRlcmZhY2UgZnVuY3Rpb24gd2hlbiBwbGF5ZXIgaXMgY3JlYXRlZFxyXG5cdFx0J3BsYXllci1jcmVhdGUnOiBhZGRFbnRyaWVzLFxyXG5cclxuXHRcdC8vIEJsYW5rIHByb3BlcnR5IHdoZW4gcGxheWVyIGlzIHJlLWluaXRpYWxpemVkXHJcblx0XHRcInBsYXllci1yZWluaXRpYWxpemVcIiAocGxheWVyKSB7XHJcblx0XHRcdHBsYXllci5iYWxhbmNlU2hlZXQgPSB7IGFzc2V0czogW10sIGxpYWJpbGl0aWVzOiBbXSB9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gUGx1Z2luO1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYWxhbmNlU2hlZXQ7XHJcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdFwiY29uZGVuc2UtbmV4dC1zdW1tYXJ5LXByZXZpZXdcIjogZmFsc2UsXHJcblx0XCJjbGVhci1oaXN0b3J5LW9uLXBsYXlcIjogdHJ1ZSxcclxuXHRcImluaXQtbG9nLWxldmVsXCI6IFwiaW5mb1wiLFxyXG5cdFwiaW5pdC1zeW5jLW1vZGVcIjogXCJhc3luY1wiXHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBnYW1lIHBpZWNlc1xyXG52YXIgcHJpc29uZXJEaWxlbW1hID0gcmVxdWlyZShcIi4vaXRlcmF0ZWQtcHJpc29uZXItZGlsZW1tYVwiKS5jcmVhdGVHZW5lcmF0b3I7XHJcbnZhciByb3VuZFJvYmluID0gcmVxdWlyZShcIi4vcm91bmQtcm9iaW5cIik7XHJcblxyXG4vLyBOYXNoSlMgZW5naW5lIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG52YXIgeyBMb29wIH0gPSBFbmdpbmUuRnJvbnRlbmQuUGxheWFibGVzO1xyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lV3JhcHBlciB9ID0gRW5naW5lLkJhY2tlbmQuSGVscGVyRnVuY3Rpb25zKFwic3RvY2stZ2FtZXNcIilcclxudmFyIHsgZ2VuZXJhdGVQb3B1bGF0aW9uIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJ0b3VybmFtZW50XCIpO1xyXG5cclxuLy8gUG9wdWxhdGlvbiBpbnRlcmZhY2VzXHJcbnZhciB7IFBvcHVsYXRpb24gfSA9IEVuZ2luZS5Gcm9udGVuZC5Qb3B1bGF0aW9uO1xyXG5cclxuXHJcbnZhciBBeGVscm9kVG91cm5hbWVudCA9IGdhbWVXcmFwcGVyKGZ1bmN0aW9uKHBsYXllcnMsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHZhciB7IGdlbmVyYXRlUGxheWVycyA9IHRydWUsIHJlcGVhdHMgPSA1LCBnYW1lTGVuZ3RoID0gMjAwIH0gPSBwYXJhbWV0ZXJzO1xyXG5cclxuXHQvLyBFaXRoZXIgY3JlYXRlIGFuIGVudGlyZSBwb3B1bGF0aW9uXHJcblx0aWYgKGdlbmVyYXRlUGxheWVycykge1xyXG5cdFx0Ly8gR2V0IHR3byBzZXRzIG9mIHBsYXllcnMuIFRoZSBzZWNvbmQgaXMgc28gcGxheWVycyBjYW4gcGxheSB0aGVtc2VsdmVzXHJcblx0XHRwbGF5ZXJzID0gZ2VuZXJhdGVQb3B1bGF0aW9uKCk7XHJcblx0XHR2YXIgY29waWVzID0gZ2VuZXJhdGVQb3B1bGF0aW9uKCk7XHJcblx0XHRwYXJhbWV0ZXJzLmNvcGllcyA9IGNvcGllcztcclxuXHR9XHJcblxyXG5cdC8vIG9yIHVzZSB0aGUgc3VwcGxpZWQgcGxheWVyc1xyXG5cdGVsc2UgaWYgKHBsYXllcnMpIHtcclxuXHRcdC8vIGRvIG5vdGhpbmdcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gb3IgdXNlIHRoZSBwbGF5ZXJzIGFscmVhZHkgcHJlc2VudFxyXG5cdFx0cGxheWVycyA9IFBvcHVsYXRpb24oKS5vbmx5QWxpdmUoKS5vbmx5QXZhaWxhYmxlKCk7XHJcblx0fVxyXG5cclxuXHQvLyBhc3NpZ24gcGFyYW1ldGVycyBhbmQgZ2VuZXJhdGUgdGhlIGdhbWVcclxuXHRwYXJhbWV0ZXJzLmluaXRpYWxpemVQbGF5ZXJzID0gcGxheWVycztcclxuXHR2YXIgaXRlcmF0aW9uID0gcm91bmRSb2JpbihwbGF5ZXJzLCBwcmlzb25lckRpbGVtbWEoZ2FtZUxlbmd0aCksIHBhcmFtZXRlcnMpO1xyXG5cclxuXHRyZXR1cm4gTG9vcChpdGVyYXRpb24sIHJlcGVhdHMsIHsgaWQ6IFwiQXhlbHJvZC1Ub3VybmFtZW50XCIgfSk7XHJcbn0pO1xyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEF4ZWxyb2RUb3VybmFtZW50O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vYmFzZSBnYW1lXHJcbnZhciBUd29QbGF5ZXJOb3JtYWwgPSByZXF1aXJlKFwiLi9zaW1wbGUtbm9ybWFsXCIpO1xyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lV3JhcHBlciB9ID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIikuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKVxyXG5cclxuXHJcbi8vIEJhdHRsZSBvZiB0aGUgU2V4ZXNcclxudmFyIEJhdHRsZU9mVGhlU2V4ZXMgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRwYXJhbWV0ZXJzLmlkID0gcGFyYW1ldGVycy5pZCB8fCBcIkJhdHRsZS1vZi10aGUtU2V4ZXNcIjtcclxuXHJcblx0dmFyIGNob2ljZXMgPSBbXHJcblx0XHRbXCJPcGVyYVwiLCBcIkZvb3RiYWxsXCJdLFxyXG5cdFx0W1wiT3BlcmFcIiwgXCJGb290YmFsbFwiXVxyXG5cdF07XHJcblx0dmFyIHBheW9mZnMgPSBbXHJcblx0XHRbXHJcblx0XHRcdFsyLCAxXSxcclxuXHRcdFx0WzAsIDBdXHJcblx0XHRdLFxyXG5cdFx0W1xyXG5cdFx0XHRbMCwgMF0sXHJcblx0XHRcdFsxLCAyXVxyXG5cdFx0XVxyXG5cdF07XHJcblxyXG5cdHJldHVybiBUd29QbGF5ZXJOb3JtYWwocGxheWVycywgY2hvaWNlcywgcGF5b2ZmcywgcGFyYW1ldGVycyk7XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCYXR0bGVPZlRoZVNleGVzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIE5hc2hKUyBlbmdpbmUgY29tcG9uZW50c1xyXG52YXIgRW5naW5lID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIilcclxuXHJcbi8vIFVzZXIgZGF0YVxyXG52YXIgeyBQb3B1bGF0aW9uIH0gPSBFbmdpbmUuRnJvbnRlbmRcclxuXHJcbi8vIFBsYXlhYmxlc1xyXG52YXIgeyBMYW1iZGEsIFNpbXVsdGFuZW91cywgU2VxdWVuY2UsIExvb3AgfSA9IEVuZ2luZS5Gcm9udGVuZC5QbGF5YWJsZXM7XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlzRnVuY3Rpb24gfSA9IEVuZ2luZS5CYWNrZW5kLkhlbHBlckZ1bmN0aW9ucyhcImdlbmVyYWxcIik7XHJcblxyXG5cclxuLy9DdWx0dXJhbCBldm9sdXRpb25cclxuLy9cclxuLy8gVE9ETzogYWRkIGluc3RydWN0aW9ucyBoZXJlXHJcbmZ1bmN0aW9uIEN1bHR1cmFsRXZvbHV0aW9uKGdhbWVHZW5lcmF0b3IsIG51bUxvb3BzID0gMSwge1xyXG5cdGlkID0gXCJDdWx0dXJhbEV2b2x1dGlvblwiLFxyXG5cdGdhbWVQcm9iYWJpbGl0eSA9IC4yNSxcclxuXHRwYWlyUHJvYmFiaWxpdHkgPSAuMjUsXHJcblx0Z2VuZXJhdGVQb3B1bGF0aW9uID0gbnVsbCxcclxuXHRsb29wID0gdHJ1ZVxyXG59ID0ge30pIHtcclxuXHJcblx0aWYgKGxvb3AgJiYgaXNOYU4obnVtTG9vcHMpKSB0aHJvdyBuZXcgRXJyb3IoXCJDdWx0dXJhbEV2b2x1dGlvbiBhcmd1bWVudCAnbnVtTG9vcHMgbXVzdCBiZSBhIG51bWJlclwiKTtcclxuXHRpZiAoIWlzRnVuY3Rpb24oZ2FtZUdlbmVyYXRvcikpIHRocm93IG5ldyBFcnJvcihcclxuXHRcdFwiQ3VsdHVyYWxFdm9sdXRpb24gYXJndW1lbnQgJ2dhbWVHZW5lcmF0b3InIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcclxuXHRpZiAoaXNOYU4oZ2FtZVByb2JhYmlsaXR5KSB8fCBnYW1lUHJvYmFiaWxpdHkgPCAwIHx8IGdhbWVQcm9iYWJpbGl0eSA+IDEpIHRocm93IG5ldyBFcnJvcihcclxuXHRcdFwiQ3VsdHVyYWxFdm9sdXRpb24gYXJndW1lbnQgJ2dhbWVQcm9iYWJpbGl0eScgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDFcIik7XHJcblx0aWYgKGlzTmFOKHBhaXJQcm9iYWJpbGl0eSkgfHwgcGFpclByb2JhYmlsaXR5IDwgMCB8fCBwYWlyUHJvYmFiaWxpdHkgPiAxKSB0aHJvdyBuZXcgRXJyb3IoXHJcblx0XHRcIkN1bHR1cmFsRXZvbHV0aW9uIGFyZ3VtZW50ICdwYWlyUHJvYmFiaWxpdHknIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxXCIpO1xyXG5cclxuXHQvLyBHZW5lcmF0ZSBwb3B1bGF0aW9uIGlmIHVzZXIgd2FudHMgdXMgdG8uXHJcblx0aWYgKGlzRnVuY3Rpb24oZ2VuZXJhdGVQb3B1bGF0aW9uKSkgZ2VuZXJhdGVQb3B1bGF0aW9uKCk7XHJcblxyXG5cdC8vUmVzZXQgdGhlIHNjb3JlcyBlYWNoIHJvdW5kLlxyXG5cdHZhciBSZXNldFNjb3JlcyA9IExhbWJkYShmdW5jdGlvbigpIHtcclxuXHRcdFBvcHVsYXRpb24oKS5vbmx5QWxpdmUoKS5yZXNldFNjb3JlcygpO1xyXG5cdH0pO1xyXG5cclxuXHQvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIG1hdGNoZXNcclxuXHR2YXIgbiA9IE1hdGguZmxvb3IoUG9wdWxhdGlvbigpLm9ubHlBbGl2ZSgpLmxlbmd0aCAqIGdhbWVQcm9iYWJpbGl0eSk7XHJcblxyXG5cdC8vIENyZWF0ZSBtYXRjaGVzLlxyXG5cdHZhciBtYXRjaGVzID0gWy4uLkFycmF5KG4pXVxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRtYXRjaGVzW2ldID0gZ2FtZUdlbmVyYXRvcigpO1xyXG5cdFx0aWYgKCFtYXRjaGVzW2ldLnBsYXkpIHRocm93IG5ldyBFcnJvcihcIkN1bHR1cmFsRXZvbHV0aW9uIGFyZ3VtZW50ICdnYW1lR2VuZXJhdG9yJyBtdXN0IHJldHVybiBhIFBsYXlhYmxlXCIpO1xyXG5cdH1cclxuXHJcblx0Ly9SdW4gYWxsIG1hdGNoZXMgc2ltdWx0YW5lb3VzbHlcclxuXHR2YXIgUm91bmQgPSBTaW11bHRhbmVvdXMobWF0Y2hlcyk7XHJcblxyXG5cdC8vQ2FsY3VsYXRlIG51bWJlciBvZiBwYWlyaW5nc1xyXG5cdHZhciBuID0gTWF0aC5mbG9vcihQb3B1bGF0aW9uKCkub25seUFsaXZlKCkubGVuZ3RoICogcGFpclByb2JhYmlsaXR5KVxyXG5cclxuXHQvL0NyZWF0ZSBwYWlyaW5nc1xyXG5cdHZhciBwYWlyaW5ncyA9IFsuLi5BcnJheShuKV07XHJcblx0Zm9yIChpID0gMDsgaSA8IG47IGkrKykge1xyXG5cclxuXHRcdHBhaXJpbmdzW2ldID0gTGFtYmRhKGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0Ly9GaW5kIHNvbWUgYXZhaWxhYmxlIHBsYXllcnNcclxuXHRcdFx0dmFyIHBvb2wgPSBQb3B1bGF0aW9uKCkub25seUFsaXZlKCkub25seUF2YWlsYWJsZSgpO1xyXG5cdFx0XHR2YXIgcDEgPSBwb29sW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvb2wubGVuZ3RoKV07XHJcblx0XHRcdHZhciBwMiA9IHBvb2xbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9vbC5sZW5ndGgpXTtcclxuXHJcblx0XHRcdC8vTWFyayB0aGVtIGJ1c3lcclxuXHRcdFx0cDEuYnVzeSgpO1xyXG5cdFx0XHRwMi5idXN5KCk7XHJcblxyXG5cdFx0XHQvLyBBc3NpZ24gc3RyYXRlZ3kgb2YgcGxheWVyIHdpdGggaGlnaGVyIHNjb3JlXHJcblx0XHRcdGlmIChwMS5zY29yZSgpID4gcDIuc2NvcmUoKSkgcDIuYXNzaWduKHAxLnN0cmF0ZWd5KCkpO1xyXG5cdFx0XHRlbHNlIGlmIChwMS5zY29yZSgpID09IHAyLnNjb3JlKCkpIG51bGw7XHJcblx0XHRcdGVsc2UgcDEuYXNzaWduKHAyLnN0cmF0ZWd5KCkpO1xyXG5cclxuXHRcdFx0Ly9SZXR1cm4gdmFsdWUgb2YgcGxheWVyIGlkcywgc28gdGhlIGxvZyBtYWtlcyBzb21lIHNlbnNlLlxyXG5cdFx0XHRyZXR1cm4gW3AxLmlkKCksIHAyLmlkKCldO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvLyBSdW4gcGFpcmluZ3Mgc2ltdWx0YW5lb3VzbHlcclxuXHR2YXIgUGFpcmluZyA9IFNpbXVsdGFuZW91cyhwYWlyaW5ncyk7XHJcblxyXG5cdC8vIEFmdGVyIHBhaXJpbmdzLCBtYXJrIGFsbCBwbGF5ZXJzIGFzIGF2YWlsYWJsZS5cclxuXHR2YXIgUmVsZWFzZVBsYXllcnMgPSBMYW1iZGEoZnVuY3Rpb24oKSB7XHJcblx0XHRQb3B1bGF0aW9uKCkub25seUFsaXZlKCkucmVsZWFzZSgpO1xyXG5cdH0pO1xyXG5cclxuXHQvLyBEZWZpbmUgdGhlIGdhbWUuXHJcblx0Um91bmQoUmVzZXRTY29yZXMpO1xyXG5cdFBhaXJpbmcoUm91bmQpO1xyXG5cdFJlbGVhc2VQbGF5ZXJzKFBhaXJpbmcpO1xyXG5cdHZhciBJdGVyYXRpb24gPSBTZXF1ZW5jZShSZXNldFNjb3JlcywgUmVsZWFzZVBsYXllcnMpO1xyXG5cclxuXHQvLyBVc2VyIGNhbiBzZXQgbG9vcCBwYXJhbWV0ZXIgdG8gZmFsc2UsIHRvIGF2b2lkIHdyYXBwaW5nIHRoaXMgaW4gYSBsb29wLlxyXG5cdGlmIChsb29wKVxyXG5cdFx0dmFyIENFID0gTG9vcChJdGVyYXRpb24sIG51bUxvb3BzLCB7IHBsYXlhYmxlUGFyYW1ldGVyczogeyBpbml0aWFsaXplUGxheWVyczogdHJ1ZSB9IH0pO1xyXG5cdGVsc2VcclxuXHRcdHZhciBDRSA9IEl0ZXJhdGlvbjtcclxuXHJcblx0cmV0dXJuIENFO1xyXG59XHJcblxyXG4vL1RPRE86IGZpeCBwYXJhbWV0ZXJzLiBVc2VyIHNob3VsZCBiZSBhYmxlIHRvIHN1cHBseSBwYXJhbWV0ZXJzIHdoaWNoIGVpdGhlclxyXG4vLyBlbmQgdXAgYXMgcGFyYW1ldGVycyBmb3IgdGhlIExvb3Agb3IgdGhlIFNlcXVlbmNlLlxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ3VsdHVyYWxFdm9sdXRpb247XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gYmFzZSBnYW1lXHJcbnZhciBUd29QbGF5ZXJOb3JtYWwgPSByZXF1aXJlKFwiLi9zaW1wbGUtbm9ybWFsXCIpLlR3b1BsYXllck5vcm1hbDtcclxuXHJcbi8vIE5hc2hKUyBlbmdpbmUgY29tcG9uZW50c1xyXG52YXIgRW5naW5lID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIilcclxuXHJcbi8vIE5hc2ggZW5naW5lIGNvbXBvbmVudHNcclxudmFyIHsgU2VxdWVuY2UsIExhbWJkYSB9ID0gRW5naW5lLkZyb250ZW5kLlBsYXlhYmxlcztcclxuXHJcbi8vIEdhbWUgc3RhdGVcclxudmFyIHsgcmVnaXN0cnkgfSA9IEVuZ2luZS5CYWNrZW5kLlN0YXRlXHJcblxyXG4vLyBoZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKVxyXG5cclxuLy8gV2UnbGwgbmVlZCB0aGUgJ2JhbGFuY2Utc2hlZXQnIHBsdWdpblxyXG52YXIgUGx1Z2luTWFuYWdlciA9IEVuZ2luZS5CYWNrZW5kLlBsdWdpbk1hbmFnZXI7XHJcblxyXG5mdW5jdGlvbiBpbnZlcnRUZXJtcyh0ZXJtc09mVHJhZGUpIHtcclxuXHR2YXIgaW52ZXJzZSA9IHt9XHJcblx0T2JqZWN0LmVudHJpZXModGVybXNPZlRyYWRlKS5mb3JFYWNoKGZ1bmN0aW9uKHRlcm0pIHtcclxuXHRcdGlmICh0ZXJtWzBdID09IFwiYm9ycm93XCIpIHtcclxuXHRcdFx0aW52ZXJzZS5sZW5kID0gdGVybVsxXVxyXG5cdFx0fSBlbHNlIGlmICh0ZXJtWzBdID09IFwibGVuZFwiKSB7XHJcblx0XHRcdGludmVyc2UuYm9ycm93ID0gdGVybVsxXVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW52ZXJzZVt0ZXJtWzBdXSA9IHRlcm1bMV0gKiAtMVxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdHJldHVybiBpbnZlcnNlO1xyXG59XHJcblxyXG4vLyB0ZXJtc09mVHJhZGUgc2hvdWxkIGJlIGFuIG9iamVjdCByZWZsZWN0aW5nIHRoZSBvdXRjb21lcyBmb3IgcGxheWVyIDEuXHJcbi8vIEV4YW1wbGUge2FwcGxlOjIsIG9yYW5nZTotMn0uIFRvIGJvcnJvdyBvciBsZW5kLCBjcmVhdGUgYSBzdWItb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGxvYW4gdGVybXMuXHJcbi8vIGVnIHthcHBsZToyLCBib3Jyb3c6e0lPVTo1fX0sIG9yIHtjb3VjaDotMTAsIGxlbmQ6eydjcmVkaXQgY2FyZCc6NTB9fVxyXG52YXIgRXhjaGFuZ2UgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCB0ZXJtc09mVHJhZGUgPSB7fSwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0dmFyIHsgdXRpbGl0eUZ1bmN0aW9ucywgdXRpbGl0eU1vZGUgPSBcImFic29sdXRlXCIsIGluaXRpYWxFbmRvd21lbnQgPSBbe30sIHt9XSB9ID0gcGFyYW1ldGVycyAvL3V0aWxpdHlGdW5jdGlvbnMgc2hvdWxkIGJlIGFuIGFycmF5IG9mIDIgZnVuY3Rpb25zLCB3aGljaCB0YWtlIGEgcmVzdWx0cyBvYmplY3QgYW5kIHJldHVybiBhIGNoYW5nZSBpbiB1dGlsaXR5XHJcblx0cGFyYW1ldGVycy5pZCA9IFwiRXhjaGFuZ2VcIiB8fCBwYXJhbWV0ZXJzLmlkO1xyXG5cclxuXHJcblxyXG5cclxuXHQvLyBUbyBwbGF5IHRoaXMgZ2FtZSwgcGxheWVycyB3aWxsIG5lZWQgYSBiYWxhbmNlIHNoZWV0LiBUaGlzIHBsdWdpbiB3aWxsIGFkZCBiYWxhbmNlIHNoZWV0cyB0byB0aGUgcGxheWVycyxcclxuXHQvLyBhcyB3ZWxsIGFzIGVuc3VyZSB0aGF0IG5ldyBwbGF5ZXJzIGFyZSBjcmVhdGVkIHdpdGggb25lLCBhbmQgdGhhdCB0aGV5IGFyZSByZS1pbml0aWFsaXplZCBwcm9wZXJseS5cclxuXHR2YXIgYmFsYW5jZVNoZWV0ID0gUGx1Z2luTWFuYWdlci5wYWNrYWdlKFwiYmFsYW5jZS1zaGVldC1jb21wbGV4XCIpLnJlcXVpcmUocGxheWVycyk7XHJcblx0YmFsYW5jZVNoZWV0LnNldHRpbmdzKHsgY2xlYW5aZXJvczogZmFsc2UgfSlcclxuXHJcblx0dmFyIHAxID0gcmVnaXN0cnkucGxheWVyc1twbGF5ZXJzWzBdLmlkKCldO1xyXG5cdHZhciBwMiA9IHJlZ2lzdHJ5LnBsYXllcnNbcGxheWVyc1sxXS5pZCgpXTtcclxuXHJcblx0Ly8gRG8gaW5pdGlhbCBlbmRvd21lbnRzIGlmIHRoZXJlIGFyZSBhbnkuIEZvcm1hdCBzYW1lIGFzIGZvciB0ZXJtcyBvZiB0cmFkZS5cclxuXHRpbml0aWFsRW5kb3dtZW50LmZvckVhY2goZnVuY3Rpb24oZW5kb3dtZW50LCBpbmRleCkge1xyXG5cdFx0dmFyIHBsYXllciA9IHBsYXllcnNbaW5kZXhdXHJcblx0XHR2YXIgaW52ZXJ0UGxheWVyID0gcGxheWVyc1tOdW1iZXIoIWluZGV4KV1cclxuXHRcdE9iamVjdC5lbnRyaWVzKGVuZG93bWVudCkuZm9yRWFjaChmdW5jdGlvbih0ZXJtKSB7XHJcblx0XHRcdGlmICh0ZXJtWzBdID09IFwiYm9ycm93XCIpIHtcclxuXHRcdFx0XHR2YXIgbG9hblRlcm1zID0gT2JqZWN0LmVudHJpZXModGVybVsxXSlbMF1cclxuXHRcdFx0XHRuZXcgYmFsYW5jZVNoZWV0LkZpbmFuY2lhbENsYWltKGludmVydFBsYXllciwgcGxheWVyLCBsb2FuVGVybXNbMV0sIGxvYW5UZXJtc1swXSlcclxuXHRcdFx0fSBlbHNlIGlmICh0ZXJtWzBdID09IFwibGVuZFwiKSB7XHJcblx0XHRcdFx0dmFyIGxvYW5UZXJtcyA9IE9iamVjdC5lbnRyaWVzKHRlcm1bMV0pWzBdXHJcblx0XHRcdFx0bmV3IGJhbGFuY2VTaGVldC5GaW5hbmNpYWxDbGFpbShwbGF5ZXIsIGludmVydFBsYXllciwgbG9hblRlcm1zWzFdLCBsb2FuVGVybXNbMF0pXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bmV3IGJhbGFuY2VTaGVldC5SZWFsQ2xhaW0ocGxheWVyLCB0ZXJtWzBdLCB0ZXJtWzFdKVxyXG5cdFx0XHR9XHJcblx0XHR9KVxyXG5cdH0pXHJcblxyXG5cdC8vIFRoZSBhY3R1YWwgcGxheWFibGVcclxuXHR2YXIgRGVjaXNpb24gPSBUd29QbGF5ZXJOb3JtYWwocGxheWVycywgW1xyXG5cdFx0W1wiQWNjZXB0XCIsIFwiUmVqZWN0XCJdLFxyXG5cdFx0W1wiQWNjZXB0XCIsIFwiUmVqZWN0XCJdXHJcblx0XSwgbnVsbCwge1xyXG5cdFx0aWQ6IFwiRGVjaXNpb25cIixcclxuXHRcdGluZm9ybWF0aW9uRmlsdGVyOiBmdW5jdGlvbihpbmZvKSB7IC8vVE9ETyBtaWdodCBuZWVkIHRvIHdyYXAgdXNlci1zdXBwbGllZCBpbmZvcm1hdGlvbkZpbHRlcj9cclxuXHRcdFx0aW5mby50ZXJtc09mVHJhZGUgPSB7XHJcblx0XHRcdFx0W3AxLmlkXTogdGVybXNPZlRyYWRlLFxyXG5cdFx0XHRcdFtwMi5pZF06IGludmVydFRlcm1zKHRlcm1zT2ZUcmFkZSlcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gaW5mbztcclxuXHRcdH1cclxuXHR9KVxyXG5cclxuXHQvLyBEaXN0cmlidXRlIHRoZSBnb29kc1xyXG5cdHZhciBEaXN0cmlidXRlID0gTGFtYmRhKGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciByZXN1bHRzID0gW107XHJcblxyXG5cdFx0T2JqZWN0LmVudHJpZXModGVybXNPZlRyYWRlKS5mb3JFYWNoKGZ1bmN0aW9uKHRlcm0pIHtcclxuXHRcdFx0aWYgKHRlcm1bMF0gPT0gXCJib3Jyb3dcIikge1xyXG5cdFx0XHRcdHZhciBsb2FuVGVybXMgPSBPYmplY3QuZW50cmllcyh0ZXJtWzFdKVswXVxyXG5cdFx0XHRcdHZhciBsb2FuID0gbmV3IGJhbGFuY2VTaGVldC5GaW5hbmNpYWxDbGFpbShwMi5pbnRlcmZhY2UsIHAxLmludGVyZmFjZSwgbG9hblRlcm1zWzFdLCBsb2FuVGVybXNbMF0pXHJcblxyXG5cdFx0XHRcdHJlc3VsdHMucHVzaCh7XHJcblx0XHRcdFx0XHRwbGF5ZXI6IHAxLmlkLFxyXG5cdFx0XHRcdFx0Ym9ycm93OiB7XHJcblx0XHRcdFx0XHRcdFtsb2FuVGVybXNbMF1dOiBsb2FuVGVybXNbMV1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0cmVzdWx0cy5wdXNoKHtcclxuXHRcdFx0XHRcdHBsYXllcjogcDIuaWQsXHJcblx0XHRcdFx0XHRsZW5kOiB7XHJcblx0XHRcdFx0XHRcdFtwMS5pZF06IHtcclxuXHRcdFx0XHRcdFx0XHRbbG9hblRlcm1zWzBdXTogbG9hblRlcm1zWzFdXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAodGVybVswXSA9PSBcImxlbmRcIikge1xyXG5cdFx0XHRcdHZhciBsb2FuVGVybXMgPSBPYmplY3QuZW50cmllcyh0ZXJtWzFdKVswXVxyXG5cdFx0XHRcdHZhciBsb2FuID0gbmV3IGJhbGFuY2VTaGVldC5GaW5hbmNpYWxDbGFpbShwMS5pbnRlcmZhY2UsIHAyLmludGVyZmFjZSwgbG9hblRlcm1zWzFdLCBsb2FuVGVybXNbMF0pXHJcblxyXG5cdFx0XHRcdHJlc3VsdHMucHVzaCh7XHJcblx0XHRcdFx0XHRwbGF5ZXI6IHAyLmlkLFxyXG5cdFx0XHRcdFx0Ym9ycm93OiB7XHJcblx0XHRcdFx0XHRcdFtsb2FuVGVybXNbMF1dOiBsb2FuVGVybXNbMV1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0cmVzdWx0cy5wdXNoKHtcclxuXHRcdFx0XHRcdHBsYXllcjogcDEuaWQsXHJcblx0XHRcdFx0XHRsZW5kOiB7XHJcblx0XHRcdFx0XHRcdFtwMi5pZF06IHtcclxuXHRcdFx0XHRcdFx0XHRbbG9hblRlcm1zWzBdXTogbG9hblRlcm1zWzFdXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGdvb2QgPSBuZXcgYmFsYW5jZVNoZWV0LlJlYWxDbGFpbShwMS5pbnRlcmZhY2UsIHRlcm1bMF0sIDApXHJcblx0XHRcdFx0Z29vZC50cmFuc2ZlcihwMi5pbnRlcmZhY2UsIHRlcm1bMV0gKiAtMSlcclxuXHJcblx0XHRcdFx0cmVzdWx0cy5wdXNoKHsgcGxheWVyOiBwMS5pZCwgW3Rlcm1bMF1dOiB0ZXJtWzFdIH0pO1xyXG5cdFx0XHRcdHJlc3VsdHMucHVzaCh7IHBsYXllcjogcDIuaWQsIFt0ZXJtWzBdXTogLTEgKiB0ZXJtWzFdIH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblxyXG5cdFx0aWYgKHV0aWxpdHlGdW5jdGlvbnMpIHtcclxuXHJcblx0XHRcdHAxLnNjb3JlID0gdXRpbGl0eU1vZGUudG9Mb3dlckNhc2UoKSA9PSBcInJlbGF0aXZlXCIgPyBwMS5zY29yZSArIHV0aWxpdHlGdW5jdGlvbnNbMF0ocmVzdWx0cykgOlxyXG5cdFx0XHRcdHV0aWxpdHlGdW5jdGlvbnNbMF0ocmVzdWx0cylcclxuXHRcdFx0cDIuc2NvcmUgPSB1dGlsaXR5TW9kZS50b0xvd2VyQ2FzZSgpID09IFwicmVsYXRpdmVcIiA/IHAyLnNjb3JlICsgdXRpbGl0eUZ1bmN0aW9uc1sxXShyZXN1bHRzKSA6XHJcblx0XHRcdFx0dXRpbGl0eUZ1bmN0aW9uc1sxXShyZXN1bHRzKVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHRzO1xyXG5cdH0sIHsgaWQ6IFwiRGlzdHJpYnV0aW9uXCIgfSk7XHJcblxyXG5cdC8vQnV0IG9ubHkgZG8gaXQgaWYgdGhlIHRyYWRlIGdvZXMgdGhyb3VnaC5cclxuXHREaXN0cmlidXRlKERlY2lzaW9uLkFjY2VwdC5BY2NlcHQoKSlcclxuXHJcblxyXG5cclxuXHRyZXR1cm4gU2VxdWVuY2UoRGVjaXNpb24sIERpc3RyaWJ1dGUsIHBhcmFtZXRlcnMpO1xyXG59LCB7XHJcblx0YXJndW1lbnRWYWxpZGF0b3IocGxheWVycywgdGVybXNPZlRyYWRlKSB7XHJcblx0XHQvLyBUT0RPOiB2YWxpZGF0ZSBwYXJhbWV0ZXJzXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXhjaGFuZ2U7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIFN0b2NrR2FtZXMgPSB7XHJcblx0Ly9HYW1lIHNrZWxldG9uc1xyXG5cdFwiVHdvLVBsYXllciBOb3JtYWxcIjogcmVxdWlyZShcIi4vc2ltcGxlLW5vcm1hbFwiKS5Ud29QbGF5ZXJOb3JtYWwsXHJcblx0XCJOb3JtYWxcIjogcmVxdWlyZShcIi4vc2ltcGxlLW5vcm1hbFwiKS5Ob3JtYWwsXHJcblx0XCJTaW1wbGUgWmVyby1TdW1cIjogcmVxdWlyZShcIi4vc2ltcGxlLXplcm8tc3VtXCIpLFxyXG5cclxuXHQvLyBDbGFzc2ljIGdhbWVzXHJcblx0XCJCYXR0bGUgT2YgVGhlIFNleGVzXCI6IHJlcXVpcmUoXCIuL2JhdHRsZS1vZi10aGUtc2V4ZXNcIiksXHJcblx0XCJNYXRjaGluZyBQZW5uaWVzXCI6IHJlcXVpcmUoXCIuL21hdGNoaW5nLXBlbm5pZXNcIiksXHJcblx0XCJQcmlzb25lcidzIERpbGVtbWFcIjogcmVxdWlyZShcIi4vcHJpc29uZXItZGlsZW1tYVwiKSxcclxuXHRcIlJvY2stUGFwZXItU2Npc3NvcnNcIjogcmVxdWlyZShcIi4vcm9jay1wYXBlci1zY2lzc29yc1wiKSxcclxuXHJcblx0Ly8gSXRlcmF0ZWQgZ2FtZXNcclxuXHRcIkl0ZXJhdGVkXCI6IHJlcXVpcmUoXCIuL2l0ZXJhdGVkXCIpLFxyXG5cdFwiSXRlcmF0ZWQgUHJpc29uZXIncyBEaWxlbW1hXCI6IHJlcXVpcmUoXCIuL2l0ZXJhdGVkLXByaXNvbmVyLWRpbGVtbWFcIiksXHJcblxyXG5cdC8vIEV2b2x1dGlvbmFyeSBnYW1lc1xyXG5cdFwiQ3VsdHVyYWwgRXZvbHV0aW9uXCI6IHJlcXVpcmUoXCIuL2N1bHR1cmFsLWV2b2x1dGlvblwiKSxcclxuXHJcblx0Ly9Ub3VybmFtZW50c1xyXG5cdFwiUm91bmQgUm9iaW5cIjogcmVxdWlyZShcIi4vcm91bmQtcm9iaW5cIiksXHJcblx0XCJBeGVscm9kIFRvdXJuYW1lbnRcIjogcmVxdWlyZShcIi4vYXhlbHJvZC10b3VybmFtZW50XCIpLFxyXG5cclxuXHQvLyBQcm9iYWJpbGl0eSBUaGVvcnlcclxuXHRcIk1vbnR5IEhhbGxcIjogcmVxdWlyZShcIi4vbW9udHktaGFsbFwiKSxcclxuXHJcblx0Ly9OZW9jbGFzc2ljYWwgZWNvbm9taWNzXHJcblx0XCJFeGNoYW5nZVwiOiByZXF1aXJlKFwiLi9leGNoYW5nZS1jb21wbGV4XCIpLFxyXG5cclxuXHQvLyBGdW5jdGlvbiB0byBkaXNwbGF5IGxvYWRlZCBxdWVyeSBzaG9ydGN1dHMuXHJcblx0cXVlcmllcygpIHtcclxuXHRcdHJldHVybiBPYmplY3Qua2V5cyhyZWdpc3RyeS5xdWVyaWVzKS5tYXAoZnVuY3Rpb24ocXVlcnkpIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRbcXVlcnldOiByZWdpc3RyeS5xdWVyaWVzW3F1ZXJ5XS5kZXNjcmlwdGlvblxyXG5cdFx0XHR9XHJcblx0XHR9KVxyXG5cdH1cclxufTtcclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTdG9ja0dhbWVzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vIEJhc2UgZ2FtZVxyXG52YXIgcHJpc29uZXJEaWxlbW1hID0gcmVxdWlyZShcIi4vcHJpc29uZXItZGlsZW1tYVwiKS5jcmVhdGVHZW5lcmF0b3IoKTtcclxuXHJcbi8vIE5hc2hKUyBlbmdpbmUgY29tcG9uZW50c1xyXG52YXIgRW5naW5lID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIilcclxuXHJcbi8vIGdhbWUgZW5naW5lXHJcbnZhciB7IExvb3AgfSA9IEVuZ2luZS5Gcm9udGVuZC5QbGF5YWJsZXM7XHJcblxyXG4vLyBoZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKVxyXG5cclxuLy8gR2FtZSB1dGlsaXR5XHJcbnZhciBJdGVyYXRlZCA9IHJlcXVpcmUoXCIuL2l0ZXJhdGVkXCIpXHJcblxyXG5cclxuXHJcbnZhciBJdGVyYXRlZFByaXNvbmVyRGlsZW1tYSA9IGdhbWVXcmFwcGVyKGZ1bmN0aW9uKHBsYXllcnMsIG51bWJlckl0ZXJhdGlvbnMgPSA1MCwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblx0cmV0dXJuIEl0ZXJhdGVkKHBsYXllcnMsIHByaXNvbmVyRGlsZW1tYSwgXCJQcmlzb25lci1EaWxlbW1hXCIsIG51bWJlckl0ZXJhdGlvbnMsIHBhcmFtZXRlcnMpXHJcbn0sIHtcclxuXHRxdWVyaWVzOiBbe1xyXG5cdFx0XHRzaG9ydGN1dDogXCJASVBELWNob2ljZXNcIixcclxuXHRcdFx0cXVlcnk6IFwiJG1hcCgkLlthY3Rpb25dLnJlc3VsdHMsIGZ1bmN0aW9uKCRsKXskbC5yZXN1bHR9KVwiLFxyXG5cdFx0XHRkZXNjcmlwdGlvbjogXCJSZXN1bHRzLCBvcmdhbml6ZWQgYnkgcm91bmQuXCJcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdHNob3J0Y3V0OiBcIkBJUEQtcGxheWVyc1wiLFxyXG5cdFx0XHRxdWVyeTogXCIkbWFwKCQuW2FjdGlvbl0ucmVzdWx0cywgZnVuY3Rpb24oJGwpeyRsLnBsYXllcn0pXCIsXHJcblx0XHRcdGRlc2NyaXB0aW9uOiBcIlBsYXllcnMsIG9yZ2FuaXplZCBieSByb3VuZC5cIlxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0c2hvcnRjdXQ6IFwiQElQRC1wYXlvdXRzXCIsXHJcblx0XHRcdHF1ZXJ5OiBcIiQuYWN0aW9uLnBheW91dHNcIixcclxuXHRcdFx0ZGVzY3JpcHRpb246IFwiUGF5b3V0cywgYXMgYXJyYXkgb2Ygb2JqZWN0cy5cIlxyXG5cdFx0fVxyXG5cdF0sXHJcblx0c3RyYXRlZ3lMb2FkZXIoKSB7XHJcblx0XHRyZXR1cm4gW3tcclxuXHRcdFx0XHRuYW1lOiBcIlRpdCBGb3IgVGF0XCIsXHJcblx0XHRcdFx0ZGVzY3JpcHRpb246IFwiRG8gd2hhdGV2ZXIgeW91ciBvcHBvbmVudCBkaWQgbGFzdCB0dXJuLiBDb29wZXJhdGUgaWYgdGhpcyBpcyB0aGUgZmlyc3QgdHVybi5cIixcclxuXHRcdFx0XHRzdHJhdGVneTogZnVuY3Rpb24gdGl0Rm9yVGF0KCkge1xyXG5cdFx0XHRcdFx0dGhpcy5jaG9vc2UgPSBmdW5jdGlvbihjaG9pY2VzLCBpbmZvcm1hdGlvbikge1xyXG5cdFx0XHRcdFx0XHRpZiAoaW5mb3JtYXRpb24ub3Bwb25lbnQuaGlzdG9yeS5sZW5ndGgpIHJldHVybiBpbmZvcm1hdGlvbi5vcHBvbmVudC5oaXN0b3J5W2luZm9ybWF0aW9uLm9wcG9uZW50XHJcblx0XHRcdFx0XHRcdFx0XHQuaGlzdG9yeS5sZW5ndGggLSAxXVxyXG5cdFx0XHRcdFx0XHRcdC5yZXN1bHRcclxuXHRcdFx0XHRcdFx0ZWxzZSByZXR1cm4gXCJDb29wZXJhdGVcIjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdHtcclxuXHRcdFx0XHRuYW1lOiBcIkdydWRnZXJcIixcclxuXHRcdFx0XHRkZXNjcmlwdGlvbjogXCJDb29wZXJhdGUgdW50aWwgeW91ciBvcHBvbmVudCBkb2Vzbid0LCB0aGVuIERlZmVjdC5cIixcclxuXHRcdFx0XHRzdHJhdGVneTogZnVuY3Rpb24gZ3J1ZGdlcigpIHtcclxuXHRcdFx0XHRcdHRoaXMuY29vcGVyYXRpbmcgPSB0cnVlXHJcblxyXG5cdFx0XHRcdFx0dGhpcy5jaG9vc2UgPSBmdW5jdGlvbihjaG9pY2VzLCBpbmZvcm1hdGlvbikge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gSWYgb3Bwb25lbnQganVzdCBkZWZlY3RlZCwgdGhlbiBzdG9wIGNvb3BlcmF0aW5nXHJcblx0XHRcdFx0XHRcdGlmIChpbmZvcm1hdGlvbi5vcHBvbmVudC5oaXN0b3J5Lmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChpbmZvcm1hdGlvbi5vcHBvbmVudC5oaXN0b3J5W2luZm9ybWF0aW9uLm9wcG9uZW50Lmhpc3RvcnkubGVuZ3RoIC0gMV0ucmVzdWx0ID09IFwiRGVmZWN0XCIpIHRoaXNcclxuXHRcdFx0XHRcdFx0XHRcdC5jb29wZXJhdGluZyA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5jb29wZXJhdGluZykgcmV0dXJuIFwiQ29vcGVyYXRlXCI7XHJcblx0XHRcdFx0XHRcdGVsc2UgcmV0dXJuIFwiRGVmZWN0XCI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0e1xyXG5cdFx0XHRcdG5hbWU6IFwiTmFpdmUgUHJvYmVyXCIsXHJcblx0XHRcdFx0ZGVzY3JpcHRpb246IFwiTGlrZSBUaXQgRm9yIFRhdCwgYnV0IG9jY2FzaW9uYWxseSBEZWZlY3RzIHdpdGggc21hbGwgcHJvYmFiaWxpdHlcIixcclxuXHRcdFx0XHRzdHJhdGVneTogZnVuY3Rpb24gcHJvYmVyKHByb2JhYmlsaXR5ID0gMC4xKSB7XHJcblx0XHRcdFx0XHR0aGlzLmNob29zZSA9IGZ1bmN0aW9uKGNob2ljZXMsIGluZm9ybWF0aW9uKSB7XHJcblx0XHRcdFx0XHRcdGlmIChNYXRoLnJhbmRvbSgpIDwgcHJvYmFiaWxpdHkpIHJldHVybiBcIkRlZmVjdFwiO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKGluZm9ybWF0aW9uLm9wcG9uZW50Lmhpc3RvcnkubGVuZ3RoKSByZXR1cm4gaW5mb3JtYXRpb24ub3Bwb25lbnQuaGlzdG9yeVtpbmZvcm1hdGlvbi5vcHBvbmVudFxyXG5cdFx0XHRcdFx0XHRcdFx0Lmhpc3RvcnkubGVuZ3RoIC0gMV1cclxuXHRcdFx0XHRcdFx0XHQucmVzdWx0XHJcblx0XHRcdFx0XHRcdGVsc2UgcmV0dXJuIFwiQ29vcGVyYXRlXCI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0e1xyXG5cdFx0XHRcdG5hbWU6IFwiVGl0IEZvciBUd28gVGF0c1wiLFxyXG5cdFx0XHRcdGRlc2NyaXB0aW9uOiBcIkNvb3BlcmF0ZXMgb24gdGhlIGZpcnN0IG1vdmUsIHRoZW4gRGVmZWN0cyBvbmx5IHdoZW4gdGhlIG9wcG9uZW50IERlZmVjdHMgdHdvIHRpbWVzXCIsXHJcblx0XHRcdFx0c3RyYXRlZ3k6IGZ1bmN0aW9uIFRGMlQoKSB7XHJcblx0XHRcdFx0XHR0aGlzLmNob29zZSA9IGZ1bmN0aW9uKGNob2ljZXMsIGluZm9ybWF0aW9uKSB7XHJcblx0XHRcdFx0XHRcdGlmIChpbmZvcm1hdGlvbi5vcHBvbmVudC5oaXN0b3J5Lmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoaW5mb3JtYXRpb24ub3Bwb25lbnQuaGlzdG9yeVtpbmZvcm1hdGlvbi5vcHBvbmVudC5oaXN0b3J5Lmxlbmd0aCAtIDFdLnJlc3VsdCA9PSBcIkRlZmVjdFwiICYmXHJcblx0XHRcdFx0XHRcdFx0XHRpbmZvcm1hdGlvbi5vcHBvbmVudC5oaXN0b3J5W2luZm9ybWF0aW9uLm9wcG9uZW50Lmhpc3RvcnkubGVuZ3RoIC0gMl0ucmVzdWx0ID09IFwiRGVmZWN0XCIpIHJldHVybiBcIkRlZmVjdFwiO1xyXG5cdFx0XHRcdFx0XHRcdGVsc2UgcmV0dXJuIFwiQ29vcGVyYXRlXCI7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSByZXR1cm4gXCJDb29wZXJhdGVcIjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRdXHJcblx0fVxyXG59KTtcclxuLy8gVE9ETyB2YWxpZGF0ZSBhcmd1bWVudHNcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSXRlcmF0ZWRQcmlzb25lckRpbGVtbWFcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBOYXNoSlMgZW5naW5lIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG4vLyBnYW1lIGVuZ2luZVxyXG52YXIgeyBMb29wIH0gPSBFbmdpbmUuRnJvbnRlbmQuUGxheWFibGVzO1xyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uc1xyXG52YXIgeyBnYW1lV3JhcHBlciB9ID0gRW5naW5lLkJhY2tlbmQuSGVscGVyRnVuY3Rpb25zKFwic3RvY2stZ2FtZXNcIilcclxuXHJcblxyXG52YXIgSXRlcmF0ZWQgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCBnYW1lR2VuZXJhdG9yLCBnYW1lTmFtZSwgbnVtYmVySXRlcmF0aW9ucyA9IDUwLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHJcblx0dmFyIHsgcGFyYW1ldGVyczogZ2FtZVBhcmFtZXRlcnMgPSB7fSB9ID0gcGFyYW1ldGVyc1xyXG5cclxuXHRnYW1lUGFyYW1ldGVycy5pZCA9IGdhbWVQYXJhbWV0ZXJzLmlkIHx8IGdhbWVOYW1lXHJcblx0cGFyYW1ldGVycy5pZCA9IHBhcmFtZXRlcnMuaWQgfHwgXCJJdGVyYXRlZC1cIiArIGdhbWVOYW1lO1xyXG5cclxuXHRyZXR1cm4gTG9vcChnYW1lR2VuZXJhdG9yKHBsYXllcnMsIGdhbWVQYXJhbWV0ZXJzKSwgbnVtYmVySXRlcmF0aW9ucywgcGFyYW1ldGVycyk7XHJcbn0pXHJcblxyXG4vLyBUT0RPIHZhbGlkYXRlIGFyZ3VtZW50c1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJdGVyYXRlZDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBiYXNlIGdhbWVcclxudmFyIFNpbXBsZVplcm9TdW0gPSByZXF1aXJlKFwiLi9zaW1wbGUtemVyby1zdW1cIik7XHJcblxyXG4vLyBOYXNoSlMgZW5naW5lIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG4vLyBoZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKVxyXG5cclxuLy8gUGxheS10aW1lIGxvZ2ljXHJcbnZhciB7IEV4cHJlc3Npb24gfSA9IEVuZ2luZS5Gcm9udGVuZFxyXG5cclxuXHJcbnZhciBNYXRjaGluZ1Blbm5pZXMgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRwYXJhbWV0ZXJzLmlkID0gcGFyYW1ldGVycy5pZCB8fCBcIk1hdGNoaW5nLVBlbm5pZXNcIjtcclxuXHRwYXlvZmYgPSBwYXJhbWV0ZXJzLnBheW9mZiB8fCAxO1xyXG5cclxuXHR2YXIgd2luID0gcGF5b2ZmO1xyXG5cdHZhciBsb3NlID0gRXhwcmVzc2lvbihmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAtcGF5b2ZmO1xyXG5cdH0pO1xyXG5cclxuXHR2YXIgY2hvaWNlcyA9IFtcclxuXHRcdFtcIkhlYWRzXCIsIFwiVGFpbHNcIl0sXHJcblx0XHRbXCJIZWFkc1wiLCBcIlRhaWxzXCJdXHJcblx0XTtcclxuXHJcblx0dmFyIHBheW9mZnMgPSBbXHJcblx0XHRbd2luLCBsb3NlXSxcclxuXHRcdFtsb3NlLCB3aW5dXHJcblx0XTtcclxuXHJcblx0cmV0dXJuIFNpbXBsZVplcm9TdW0ocGxheWVycywgY2hvaWNlcywgcGF5b2ZmcywgcGFyYW1ldGVycyk7XHJcbn0pO1xyXG5cclxuLy8gTWF0Y2hpbmcgUGVubmllc1xyXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGNoaW5nUGVubmllcztcclxuIiwiXCJ1c2Ugc3RyaWN0XCJcclxuXHJcbi8vIE5hc2hKUyBlbmdpbmUgY29tcG9uZW50c1xyXG52YXIgRW5naW5lID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIik7XHJcblxyXG4vLyBQbGF5YWJsZXNcclxudmFyIHsgQ2hvaWNlLCBMYW1iZGEgfSA9IEVuZ2luZS5Gcm9udGVuZC5QbGF5YWJsZXM7XHJcblxyXG4vLyBsb2dpY1xyXG52YXIgeyBWYXJpYWJsZSwgQ29tcGxleFZhcmlhYmxlIH0gPSBFbmdpbmUuRnJvbnRlbmRcclxuXHJcbi8vIGhlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgZ2FtZVdyYXBwZXIgfSA9IEVuZ2luZS5CYWNrZW5kLkhlbHBlckZ1bmN0aW9ucyhcInN0b2NrLWdhbWVzXCIpO1xyXG5cclxuXHJcbnZhciBNb250eUhhbGwgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXIsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHBhcmFtZXRlcnMuaWQgPSBwYXJhbWV0ZXJzLmlkIHx8IFwiTW9udHktSGFsbFwiXHJcblx0dmFyIG51bURvb3JzID0gcGFyYW1ldGVycy5udW1Eb29ycyB8fCAzO1xyXG5cdHZhciBudW1Qcml6ZXMgPSBwYXJhbWV0ZXJzLm51bVByaXplcyB8fCAxO1xyXG5cdHZhciBudW1SZXZlYWxzID0gcGFyYW1ldGVycy5udW1SZXZlYWxzIHx8IDE7XHJcblx0dmFyIHByaXplID0gcGFyYW1ldGVycy5wcml6ZSB8fCA1O1xyXG5cclxuXHQvLyBBbGxvdyBhcnJheSBvciBzaW5nbGUgcGxheWVyXHJcblx0aWYgKEFycmF5LmlzQXJyYXkocGxheWVyKSkgcGxheWVyID0gcGxheWVyWzBdXHJcblxyXG5cdC8vR2VuZXJhdGUgbGlzdCBvZiBkb29yc1xyXG5cdHZhciBkb29ycyA9IFtdO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRG9vcnM7IGkrKykge1xyXG5cdFx0ZG9vcnMucHVzaChcIkRvb3IgXCIgKyBpLnRvU3RyaW5nKCkpXHJcblx0fVxyXG5cclxuXHR2YXIgQ2hvb3NlID0gQ2hvaWNlKHBsYXllciwgZG9vcnMsIHsgaWQ6IFwiQ2hvb3NlXCIgfSk7XHJcblxyXG5cclxuXHR2YXIgcHJpemVzXHJcblx0dmFyIHNjb3JlcyA9IEFycmF5LmFwcGx5KG51bGwsIEFycmF5KGRvb3JzLmxlbmd0aCkpLm1hcChmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBWYXJpYWJsZSgwKVxyXG5cdH0pXHJcblxyXG5cdC8vTmVlZCB0byBzZXQgdGhpcyBoZXJlIGluIG9yZGVyIGZvciBzY29yaW5nIHRvIHdvcmtcclxuXHR2YXIgZG9vcnMyID0gQ29tcGxleFZhcmlhYmxlKGRvb3JzLnNsaWNlKCkpO1xyXG5cclxuXHR2YXIgUmV2ZWFsID0gTGFtYmRhKGZ1bmN0aW9uKHsgaGlzdG9yeSB9KSB7XHJcblxyXG5cdFx0Ly8gUmUtaW5pdGlhbGl6ZSBwYXlvZmZzLlxyXG5cdFx0cHJpemVzID0gW11cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2NvcmVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHNjb3Jlc1tpXS5zZXQoMClcclxuXHRcdH1cclxuXHJcblx0XHQvLyBXaGF0IGRvb3IgZGlkIHRoZSBwbGF5ZXIgb3Blbj9cclxuXHRcdHZhciBwbGF5ZXJDaG9pY2UgPSBoaXN0b3J5LmxvZy5xdWVyeShcIiRbY2hvaWNlPSdcIiArIENob29zZS5pZCgpICsgXCInXVstMV1cIikucmVzdWx0IC8vIFRPRE8gZG9lcyB0aGlzIHdvcms/XHJcblxyXG5cdFx0Ly8gU2VsZWN0IHdoaWNoIGRvb3JzIGhhdmUgcHJpemVzXHJcblx0XHR2YXIgcmV2ZWFsRnJvbSA9IGRvb3JzLnNsaWNlKCk7IC8vIENvcHkgdGhlIGRvb3JzIGxpc3RcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUHJpemVzOyBpKyspIHtcclxuXHRcdFx0dmFyIHByaXplSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiByZXZlYWxGcm9tLmxlbmd0aCkgLy8gU2VsZWN0IGEgZG9vciBmcm9tIHRoZSBkb29ycyBjb3B5XHJcblx0XHRcdHByaXplcy5wdXNoKHJldmVhbEZyb21bcHJpemVJbmRleF0pIC8vIEFkZCB0aGUgcHJpemUgdG8gdGhlIGxpc3RzXHJcblx0XHRcdHNjb3Jlc1twcml6ZUluZGV4XS5zZXQocHJpemUpIC8vIFNldCBwYXlvZmZzIGFwcHJvcHJpYXRlbHlcclxuXHRcdFx0cmV2ZWFsRnJvbS5zcGxpY2UocHJpemVJbmRleCwgMSkgLy8gUmVtb3ZlIHRoZSBwcml6ZWQgZG9vciBmcm9tIHRoZSBkb29ycyBjb3B5LCBzbyB0aGF0IHdlIGRvbid0IHNlbGVjdCBpdCBtb3JlIHRoYW4gb25jZVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vUmVtb3ZlIHBsYXllciBjaG9pY2UgZnJvbSBkb29ycyBjb3B5XHJcblx0XHR2YXIgcGxheWVyQ2hvaWNlSW5kZXggPSByZXZlYWxGcm9tLmluZGV4T2YocGxheWVyQ2hvaWNlKVxyXG5cdFx0aWYgKHBsYXllckNob2ljZUluZGV4ID4gLTEpIHJldmVhbEZyb20uc3BsaWNlKHBsYXllckNob2ljZUluZGV4LCAxKVxyXG5cclxuXHRcdC8vIENob29zZSBkb29ycyB0byByZXZlYWxcclxuXHRcdHZhciByZXZlYWwgPSBbXTtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUmV2ZWFsczsgaSsrKSB7XHJcblx0XHRcdHJldmVhbC5wdXNoKHJldmVhbEZyb21bTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKSAqIHJldmVhbEZyb20ubGVuZ3RoXSlcclxuXHRcdH1cclxuXHJcblx0XHQvLyBDb3B5IGRvb3JzIGxpc3QgdG8gc2VuZCBvbndhcmQsIHRoZW4gcmVtb3ZlIHRoZSByZXZlYWxlZCBkb29ycyBmcm9tIGxpc3RcclxuXHRcdGRvb3JzMi5zZXQoZG9vcnMuc2xpY2UoKSk7IC8vIE5lZWQgdG8gc2V0IHRoaXMgaGVyZSBzbyByZXZlYWxpbmcgdG8gd29ya1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCByZXZlYWwubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IGluZGV4ID0gZG9vcnMyLmluZGV4T2YocmV2ZWFsW2ldKVxyXG5cdFx0XHRkb29yczIoKS5zcGxpY2UoaW5kZXgsIDEpXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJldmVhbC5sZW5ndGggPT0gMSA/IHJldmVhbFswXSA6IHJldmVhbDtcclxuXHR9LCB7IGlkOiBcIlJldmVhbFwiIH0pXHJcblxyXG5cdHZhciBTZWNvbmRDaG9pY2UgPSBDaG9pY2UocGxheWVyLCBkb29yczIsIHsgaWQ6IFwiU3RheS1vci1Td2l0Y2hcIiwgdXNlUGF5b2ZmczogdHJ1ZSB9KTtcclxuXHRTZWNvbmRDaG9pY2Uuc2V0QWxsUGF5b2ZmcyhzY29yZXMpXHJcblxyXG5cdFJldmVhbChDaG9vc2UpXHJcblx0U2Vjb25kQ2hvaWNlKFJldmVhbClcclxuXHJcblx0cmV0dXJuIFNlcXVlbmNlKENob29zZSwgU2Vjb25kQ2hvaWNlLCBwYXJhbWV0ZXJzKTtcclxufSwge1xyXG5cclxuXHRzdHJhdGVneUxvYWRlcigpIHtcclxuXHRcdHJldHVybiBbe1xyXG5cdFx0XHRcdG5hbWU6IFwiQWx3YXlzIFN3aXRjaFwiLFxyXG5cdFx0XHRcdGRlc2NyaXB0aW9uOiBcIlJhbmRvbWx5IHNlbGVjdCBhIGRvb3IuIFRoZW4sIGFsd2F5cyBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgb25lLlwiLFxyXG5cclxuXHRcdFx0XHRzdHJhdGVneTogZnVuY3Rpb24gYWx3YXlzU3dpdGNoKCkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuZG9vciA9IG51bGw7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5jaG9vc2UgPSBmdW5jdGlvbihvcHRpb25zLCBpbmZvcm1hdGlvbikge1xyXG5cdFx0XHRcdFx0XHR2YXIgY2hvaWNlXHJcblx0XHRcdFx0XHRcdGlmICh0aGlzLmRvb3IpIHtcclxuXHRcdFx0XHRcdFx0XHRvcHRpb25zLnNwbGljZShvcHRpb25zLmluZGV4T2YodGhpcy5kb29yKSwgMSlcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmRvb3IgPSBudWxsO1xyXG5cdFx0XHRcdFx0XHRcdGNob2ljZSA9IG9wdGlvbnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogb3B0aW9ucy5sZW5ndGgpXVxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdGNob2ljZSA9IG9wdGlvbnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogb3B0aW9ucy5sZW5ndGgpXVxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuZG9vciA9IGNob2ljZVxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gY2hvaWNlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0bmFtZTogXCJBbHdheXMgU3RheVwiLFxyXG5cdFx0XHRcdGRlc2NyaXB0aW9uOiBcIlJhbmRvbWx5IHNlbGVjdCBhIGRvb3IuIFRoZW4sIGFsd2F5cyBzdGF5IHdpdGggdGhhdCBkb29yLlwiLFxyXG5cclxuXHRcdFx0XHRzdHJhdGVneTogZnVuY3Rpb24gYWx3YXlzU3RheSgpIHtcclxuXHRcdFx0XHRcdHRoaXMuZG9vciA9IG51bGw7XHJcblxyXG5cdFx0XHRcdFx0Ly9UT0RPIGFkZCBzdHJhdGVneSBkZXNjcmlwdGlvbiBmZWF0dXJlXHJcblx0XHRcdFx0XHR0aGlzLmNob29zZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGluZm9ybWF0aW9uKSB7XHJcblx0XHRcdFx0XHRcdHZhciBjaG9pY2VcclxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuZG9vcikge1xyXG5cdFx0XHRcdFx0XHRcdGNob2ljZSA9IHRoaXMuZG9vclxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuZG9vciA9IG51bGw7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdGNob2ljZSA9IG9wdGlvbnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogb3B0aW9ucy5sZW5ndGgpXVxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuZG9vciA9IGNob2ljZVxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gY2hvaWNlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRdXHJcblx0fVxyXG59KVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNb250eUhhbGxcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBiYXNlIGdhbWVcclxudmFyIFR3b1BsYXllck5vcm1hbCA9IHJlcXVpcmUoXCIuL3NpbXBsZS1ub3JtYWxcIikuVHdvUGxheWVyTm9ybWFsO1xyXG5cclxuLy9OYXNoSlMgZW5naW5lIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG4vLyBoZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKTtcclxuXHJcbi8vIHBsYXktdGltZSBsb2dpY1xyXG52YXIgeyBWYXJpYWJsZSwgRXhwcmVzc2lvbiB9ID0gRW5naW5lLkZyb250ZW5kO1xyXG5cclxuXHJcbnZhciBwcmlzb25lckRpbGVtbWEgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRwYXJhbWV0ZXJzLmlkID0gcGFyYW1ldGVycy5pZCB8fCBcIlByaXNvbmVyLURpbGVtbWFcIjtcclxuXHR2YXIgcGF5b2ZmcyA9IHBhcmFtZXRlcnMucGF5b2ZmcyB8fCBbVmFyaWFibGUoMSksIFZhcmlhYmxlKDIpLCBWYXJpYWJsZSgzKSwgVmFyaWFibGUoNCldO1xyXG5cclxuXHJcblx0Ly8gc29ydCBudW1iZXJzIGJlY2F1c2UgdGhlIHdyb25nIG9yZGVyIHdvdWxkIHNjcmV3IHVwIHRoZSBnYW1lXHJcblx0cGF5b2Zmcy5zb3J0KClcclxuXHR2YXIgc3Vja2VyID0gcGF5b2Zmc1swXVxyXG5cdHZhciBwdW5pc2htZW50ID0gcGF5b2Zmc1sxXVxyXG5cdHZhciByZXdhcmQgPSBwYXlvZmZzWzJdXHJcblx0dmFyIHRlbXB0YXRpb24gPSBwYXlvZmZzWzNdXHJcblxyXG5cclxuXHR2YXIgY2hvaWNlcyA9IFtcclxuXHRcdFtcIkNvb3BlcmF0ZVwiLCBcIkRlZmVjdFwiXSxcclxuXHRcdFtcIkNvb3BlcmF0ZVwiLCBcIkRlZmVjdFwiXVxyXG5cdF07XHJcblx0dmFyIGdhbWVQYXlvZmZzID0gW1xyXG5cdFx0W1xyXG5cdFx0XHRbcmV3YXJkLCByZXdhcmRdLFxyXG5cdFx0XHRbc3Vja2VyLCB0ZW1wdGF0aW9uXVxyXG5cdFx0XSxcclxuXHRcdFtcclxuXHRcdFx0W3RlbXB0YXRpb24sIHN1Y2tlcl0sXHJcblx0XHRcdFtwdW5pc2htZW50LCBwdW5pc2htZW50XVxyXG5cdFx0XVxyXG5cdF07XHJcblxyXG5cdHJldHVybiBUd29QbGF5ZXJOb3JtYWwocGxheWVycywgY2hvaWNlcywgZ2FtZVBheW9mZnMsIHBhcmFtZXRlcnMpO1xyXG59KTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHByaXNvbmVyRGlsZW1tYTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBiYXNlIGdhbWVcclxudmFyIFNpbXBsZVplcm9TdW0gPSByZXF1aXJlKFwiLi9zaW1wbGUtemVyby1zdW1cIik7XHJcblxyXG52YXIgRW5naW5lID0gcmVxdWlyZShcIi4uL2xpYi9lbmdpbmVcIilcclxuXHJcbi8vIGhlbHBlciBmdW5jdGlvbnNcclxudmFyIHsgZ2FtZVdyYXBwZXIgfSA9IEVuZ2luZS5CYWNrZW5kLkhlbHBlckZ1bmN0aW9ucyhcInN0b2NrLWdhbWVzXCIpXHJcblxyXG4vLyBQbGF5LXRpbWUgbG9naWNcclxudmFyIHsgRXhwcmVzc2lvbiB9ID0gRW5naW5lLkZyb250ZW5kXHJcblxyXG5cclxuLy8gUm9jay1QYXBlci1TY2lzc29yc1xyXG52YXIgUm9ja1BhcGVyU2Npc3NvcnMgPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRwYXJhbWV0ZXJzLmlkID0gcGFyYW1ldGVycy5pZCB8fCBcIlJvY2stUGFwZXItU2Npc3NvcnNcIjtcclxuXHRwYXJhbWV0ZXJzLnBheW9mZiA9IHBhcmFtZXRlcnMucGF5b2ZmIHx8IDE7XHJcblxyXG5cdHZhciB3aW4gPSBwYXJhbWV0ZXJzLnBheW9mZjtcclxuXHR2YXIgbG9zZSA9IEV4cHJlc3Npb24oZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gLXBheW9mZjtcclxuXHR9KTtcclxuXHJcblx0dmFyIGNob2ljZXMgPSBbXHJcblx0XHRbXCJSb2NrXCIsIFwiUGFwZXJcIiwgXCJTY2lzc29yc1wiXSxcclxuXHRcdFtcIlJvY2tcIiwgXCJQYXBlclwiLCBcIlNjaXNzb3JzXCJdXHJcblx0XTtcclxuXHR2YXIgcGF5b2ZmcyA9IFtcclxuXHRcdFswLCBsb3NlLCB3aW5dLFxyXG5cdFx0W3dpbiwgMCwgbG9zZV0sXHJcblx0XHRbbG9zZSwgd2luLCAwXVxyXG5cdF07XHJcblxyXG5cdHJldHVybiBTaW1wbGVaZXJvU3VtKHBsYXllcnMsIGNob2ljZXMsIHBheW9mZnMsIHBhcmFtZXRlcnMpO1xyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm9ja1BhcGVyU2Npc3NvcnNcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vL05hc2hKUyBFbmdpbmVcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG4vLyBoZWxwZXIgZnVuY3Rpb25cclxudmFyIHsgc2h1ZmZsZSB9ID0gRW5naW5lLkJhY2tlbmQuSGVscGVyRnVuY3Rpb25zKFwiZ2VuZXJhbFwiKTtcclxudmFyIHsgZ2FtZVdyYXBwZXIgfSA9IEVuZ2luZS5CYWNrZW5kLkhlbHBlckZ1bmN0aW9ucyhcInN0b2NrLWdhbWVzXCIpXHJcblxyXG4vLyBuYXNoSlMgZW5naW5lIGNvbXBvbmVudFxyXG52YXIgeyBTZXF1ZW5jZSwgU2ltdWx0YW5lb3VzIH0gPSBFbmdpbmUuRnJvbnRlbmQuUGxheWFibGVzO1xyXG5cclxuLy9mb3IgaW5mb3JtYXRpb24gbWVjaGFuaWNzXHJcbnZhciB7IEluZm9ybWF0aW9uLCBIaXN0b3J5LCBQbGF5ZXJMaXN0IH0gPSBFbmdpbmUuQmFja2VuZC5DbGFzc2VzO1xyXG5cclxuXHJcbi8vIGdhbWVHZW5lcmF0b3Igc2hvdWxkIGJlIGEgZnVuY3Rpb24gd2hvc2UgZmlyc3QgYXJndW1lbnQgaXMgYW4gYXJyYXkgb2YgcGxheWVyc1xyXG52YXIgUm91bmRSb2JpbiA9IGdhbWVXcmFwcGVyKGZ1bmN0aW9uKHBsYXllcnMsIGdhbWVHZW5lcmF0b3IsIHBhcmFtZXRlcnMgPSB7fSkge1xyXG5cdHBhcmFtZXRlcnMuaWQgPSBwYXJhbWV0ZXJzLmlkIHx8IFwiUm91bmQtUm9iaW5cIjtcclxuXHRwYXJhbWV0ZXJzLmluaXRpYWxpemVQbGF5ZXJzID0gcGFyYW1ldGVycy5pbml0aWFsaXplUGxheWVycyAmJiB0cnVlO1xyXG5cclxuXHQvLyBDcmVhdGUgYXJyYXkgb2YgZWFjaCBjb21iaW5hdGlvbiBvZiBwbGF5ZXJzXHJcblx0dmFyIG1hdGNoZXMgPSBbXTtcclxuXHJcblx0cGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uKHBsYXllcjEsIGluZGV4MSkge1xyXG5cdFx0Zm9yICh2YXIgaW5kZXgyID0gMDsgaW5kZXgyIDwgaW5kZXgxOyBpbmRleDIrKykge1xyXG5cdFx0XHRtYXRjaGVzLnB1c2goW3BsYXllcnNbaW5kZXgyXSwgcGxheWVyMV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG9wdGlvbmFsIHBhcmFtZXRlciAnY29waWVzLicgUGFzcyBhbiBleHRyYSBjb3B5IG9mIGVhY2ggcGxheWVyLCB0byBwbGF5IHRoZW1zZWx2ZXNcclxuXHRcdGlmIChwYXJhbWV0ZXJzLmNvcGllcykgbWF0Y2hlcy5wdXNoKFtwYXJhbWV0ZXJzLmNvcGllc1tpbmRleDFdLCBwbGF5ZXIxXSk7XHJcblx0fSk7XHJcblxyXG5cdC8vcmFuZG9taXplIHRoZSBvcmRlclxyXG5cdHNodWZmbGUobWF0Y2hlcyk7XHJcblxyXG5cdC8vIFRyYWNrIHNjb3Jlc1xyXG5cdHZhciBzY29yZXNSZWNvcmQgPSBbXTtcclxuXHJcblx0Ly9cclxuXHR2YXIgYWRkUm91bmQgPSBmdW5jdGlvbihwbGF5ZXJzLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHRcdC8vIGluZm9ybWF0aW9uIG1lY2hhbmljcyBhbmQgb3RoZXIgcGFyYW1ldGVyc1xyXG5cdFx0dmFyIHBvcHVsYXRpb24gPSBuZXcgUGxheWVyTGlzdChwbGF5ZXJzKS5nZW5lcmF0b3JcclxuXHRcdHBhcmFtZXRlcnMuY29tcGFydG1lbnRhbGl6ZSA9IHsgcG9wdWxhdGlvbiB9XHJcblx0XHRwYXJhbWV0ZXJzLmluaXRpYWxpemVQbGF5ZXJzID0gcG9wdWxhdGlvbjtcclxuXHJcblx0XHQvLyBnZW5lcmF0ZSByb3VuZFxyXG5cdFx0dmFyIHJvdW5kID0gZ2FtZUdlbmVyYXRvcihwbGF5ZXJzLCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0XHQvLyB0cmFjayB0aGUgc2NvcmVzXHJcblx0XHR2YXIgcmVjb3JkU2NvcmVzID0gTGFtYmRhKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgc2NvcmUgPSB7fVxyXG5cdFx0XHRmb3IgKGxldCBbc3RyYXRlZ3ksIHNjb3Jlc10gb2YgT2JqZWN0LmVudHJpZXMocG9wdWxhdGlvbigpLnNjb3Jlc0J5U3RyYXRlZ3koKSkpIHtcclxuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShzY29yZXMpKSB7XHJcblx0XHRcdFx0XHRpZiAoc2NvcmVzLmxlbmd0aCA9PSAxKSBzY29yZXMgPSBzY29yZXNbMF1cclxuXHRcdFx0XHRcdHNjb3JlW3N0cmF0ZWd5XSA9IHNjb3JlcztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0c2NvcmVzUmVjb3JkLnB1c2goc2NvcmUpO1xyXG5cclxuXHRcdFx0Ly9yZXR1cm4gc2NvcmUgZm9yIGhpc3RvcnlcclxuXHRcdFx0cmV0dXJuIHNjb3JlO1xyXG5cdFx0fSwgeyBpZDogXCJSZWNvcmQtU2NvcmVzXCIgfSk7XHJcblxyXG5cdFx0Ly9DaGFpbiB0b2dldGhlclxyXG5cdFx0cmVjb3JkU2NvcmVzKHJvdW5kKTtcclxuXHJcblx0XHQvLyByZXR1cm4gYm90aFxyXG5cdFx0cmV0dXJuIFtyb3VuZCwgcmVjb3JkU2NvcmVzXHJcblx0XHRcdC8vICxTZXF1ZW5jZShyb3VuZCwgcmVjb3JkU2NvcmVzKSAvLyBVbmNvbW1lbnQgZm9yIFNpbXVsdGFuZW91cyBpbXBsZW1lbnRhdGlvblxyXG5cdFx0XTtcclxuXHR9O1xyXG5cclxuXHJcblxyXG5cdC8vIFNlcXVlbnRpYWwgaW1wbGVtZW50YXRpb25cclxuXHQvLyBsb2FkIHRoZSBmaXJzdCBtYXRjaCBtYW51YWxseVxyXG5cdHZhciBbZmlyc3RSb3VuZCwgZmlyc3RSZWNvcmRdID0gYWRkUm91bmQoXHJcblx0XHRtYXRjaGVzLnNoaWZ0KCksXHJcblx0XHRwYXJhbWV0ZXJzLnBhcmFtZXRlcnNcclxuXHQpO1xyXG5cclxuXHQvL3RoZW4gbG9hZCBzdWJzZXF1ZW50IG1hdGNoZXNcclxuXHR2YXIgcmVjb3JkID0gZmlyc3RSZWNvcmQ7XHJcblx0dmFyIGxhc3RSZWNvcmQsIGxhc3RSb3VuZDtcclxuXHJcblx0bWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uKG1hdGNoKSB7XHJcblx0XHRbbGFzdFJvdW5kLCBsYXN0UmVjb3JkXSA9IGFkZFJvdW5kKG1hdGNoLCBwYXJhbWV0ZXJzLnBhcmFtZXRlcnMpO1xyXG5cclxuXHRcdGxhc3RSb3VuZChyZWNvcmQpO1xyXG5cdFx0cmVjb3JkID0gbGFzdFJlY29yZDtcclxuXHR9KTtcclxuXHJcblxyXG5cdHJldHVybiBTZXF1ZW5jZShmaXJzdFJvdW5kLCBsYXN0UmVjb3JkLCBwYXJhbWV0ZXJzKTtcclxuXHJcblx0LyogLy8gU2ltdWx0YW5lb3VzIGltcGxlbWVudGF0aW9uXHJcblx0dmFyIHJvdW5kcyA9IFtdO1xyXG5cdG1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbihtYXRjaCkge1xyXG5cdCAgcm91bmRzLnB1c2goYWRkUm91bmQobWF0Y2gsIHBhcmFtZXRlcnMuZ2FtZVBhcmFtZXRlcnMpWzJdKTtcclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIFNpbXVsdGFuZW91cyhyb3VuZHMsIHBhcmFtZXRlcnMpOyAqL1xyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm91bmRSb2JpbjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vL0dhbWUgZW5naW5lXHJcbnZhciBFbmdpbmUgPSByZXF1aXJlKFwiLi4vbGliL2VuZ2luZVwiKVxyXG5cclxuLy9IZWxwZXIgZnVuY3Rpb25zXHJcbnZhciB7IGlzRnVuY3Rpb24gfSA9IEVuZ2luZS5CYWNrZW5kLkhlbHBlckZ1bmN0aW9ucyhcImdlbmVyYWxcIilcclxudmFyIHsgZ2FtZVdyYXBwZXIgfSA9IEVuZ2luZS5CYWNrZW5kLkhlbHBlckZ1bmN0aW9ucyhcInN0b2NrLWdhbWVzXCIpXHJcblxyXG4vLyBQbGF5YWJsZXNcclxudmFyIHsgVHVybiwgQ2hvaWNlLCBSYW5kb21QbGF5ZXJDaG9pY2UgfSA9IEVuZ2luZS5Gcm9udGVuZC5QbGF5YWJsZXM7XHJcblxyXG4vL1BsYXktdGltZSBMb2dpY1xyXG52YXIgeyBSYW5kb21WYXJpYWJsZSB9ID0gRW5naW5lLkZyb250ZW5kXHJcblxyXG5cclxudmFyIE5vcm1hbCA9IGdhbWVXcmFwcGVyKGZ1bmN0aW9uKHBsYXllcnMsIGNob2ljZUxpc3RzLCBwYXlvZmZzID0gbnVsbCwgcGFyYW1ldGVycyA9IHt9KSB7XHJcblxyXG5cdFx0Ly9wcm9wb2dhdGUgdGhlIGluZm9ybWF0aW9uIGZpbHRlclxyXG5cdFx0cGFyYW1ldGVycy5wYXJhbWV0ZXJzID8gcGFyYW1ldGVycy5wYXJhbWV0ZXJzLmluZm9ybWF0aW9uRmlsdGVyID0gcGFyYW1ldGVycy5pbmZvcm1hdGlvbkZpbHRlciA6XHJcblx0XHRcdHBhcmFtZXRlcnMucGFyYW1ldGVycyA9IHsgaW5mb3JtYXRpb25GaWx0ZXI6IHBhcmFtZXRlcnMuaW5mb3JtYXRpb25GaWx0ZXIgfVxyXG5cclxuXHRcdC8vIGNvbnN0cnVjdCB0aGUgY2hvaWNlc1xyXG5cdFx0dmFyIGNob2ljZXMgPSBjaG9pY2VMaXN0cy5tYXAoZnVuY3Rpb24obGlzdCwgaW5kZXgpIHtcclxuXHRcdFx0cmV0dXJuIHBsYXllcnMgPT0gXCJyYW5kb21cIiA/IFJhbmRvbVBsYXllckNob2ljZShsaXN0LCBwYXJhbWV0ZXJzLnBhcmFtZXRlcnMpIDogQ2hvaWNlKHBsYXllcnNbaW5kZXhdLFxyXG5cdFx0XHRcdGxpc3QsIHBhcmFtZXRlcnMucGFyYW1ldGVycyk7XHJcblx0XHR9KTtcclxuXHJcblx0XHR2YXIgZ2FtZSA9IFR1cm4oY2hvaWNlcywgcGFyYW1ldGVycyk7XHJcblxyXG5cdFx0aWYgKHBheW9mZnMpIGdhbWUuc2V0QWxsUGF5b2ZmcyhwYXlvZmZzKTtcclxuXHJcblx0XHRyZXR1cm4gZ2FtZTtcclxuXHR9LCB7XHJcblx0XHRxdWVyaWVzOiBbe1xyXG5cdFx0XHRcdHNob3J0Y3V0OiBcIkBOLWNob2ljZXNcIixcclxuXHRcdFx0XHRxdWVyeTogXCIkLnJlc3VsdHN7cGxheWVyOnJlc3VsdH1cIixcclxuXHRcdFx0XHRkZXNjcmlwdGlvbjogXCJOb3JtYWw6IFBsYXllcnMgYW5kIHRoZWlyIGNob2ljZS5cIlxyXG5cdFx0XHR9LFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0c2hvcnRjdXQ6IFwiQE4tcGF5b3V0c1wiLFxyXG5cdFx0XHRcdHF1ZXJ5OiBcIiQucGF5b3V0c1wiLFxyXG5cdFx0XHRcdGRlc2NyaXB0aW9uOiBcIk5vcm1hbDogUGF5b3V0cyBvYmplY3QsIGJ5IHBsYXllci5cIlxyXG5cdFx0XHR9LFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0c2hvcnRjdXQ6IFwiQE4tcGxheWVyc1wiLFxyXG5cdFx0XHRcdHF1ZXJ5OiBcIiQucmVzdWx0cy5wbGF5ZXJcIixcclxuXHRcdFx0XHRkZXNjcmlwdGlvbjogXCJOb3JtYWw6IFdobyBwbGF5ZWQuXCJcclxuXHRcdFx0fVxyXG5cdFx0XSxcclxuXHRcdHN0cmF0ZWd5TG9hZGVyOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIFt7XHJcblx0XHRcdFx0XHRzdHJhdGVneTogZnVuY3Rpb24gY2hvb3NlRmlyc3QoKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuY2hvb3NlID0gZnVuY3Rpb24oY2hvaWNlcywgaW5mb3JtYXRpb24pIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY2hvaWNlc1swXVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0bmFtZTogXCJDaG9vc2UgRmlyc3RcIixcclxuXHRcdFx0XHRcdGRlc2NyaXB0aW9uOiBcIkFsd2F5cyBjaG9vc2UgZmlyc3QgYXZhaWxhYmxlIG9wdGlvbi5cIlxyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHN0cmF0ZWd5OiBmdW5jdGlvbiBjaG9vc2VTZWNvbmQoKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuY2hvb3NlID0gZnVuY3Rpb24oY2hvaWNlcywgaW5mb3JtYXRpb24pIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY2hvaWNlc1sxXVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0bmFtZTogXCJDaG9vc2UgU2Vjb25kXCIsXHJcblx0XHRcdFx0XHRkZXNjcmlwdGlvbjogXCJBbHdheXMgY2hvb3NlIHNlY29uZCBhdmFpbGFibGUgb3B0aW9uLlwiXHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0c3RyYXRlZ3k6IGZ1bmN0aW9uIHJhbmRvbWl6ZShjaG9pY2VzID0gWzAsIDFdKSB7XHJcblx0XHRcdFx0XHRcdC8vIENyZWF0aW5nIGEgbWFwIHdpbGwgbWFrZSBwaWNraW5nIGEgcmFuZG9tIHZhbHVlIGVhc2llclxyXG5cdFx0XHRcdFx0XHRjaG9pY2VzID0gY2hvaWNlcy5tYXAoZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gW2luZGV4LCBpdGVtXVxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0dmFyIGNob2ljZU1hcCA9IG5ldyBNYXAoY2hvaWNlcylcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMuY2hvb3NlID0gZnVuY3Rpb24oY2hvaWNlcywgaW5mb3JtYXRpb24pIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY2hvaWNlc1tjaG9pY2VNYXAuZ2V0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNob2ljZU1hcC5zaXplKSldO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0bmFtZTogXCJSYW5kb21pemVcIixcclxuXHRcdFx0XHRcdGRlc2NyaXB0aW9uOiBcIkNob29zZSByYW5kb21seSBmcm9tIGF2YWlsYWJsZSBvcHRpb25zLlwiXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRdO1xyXG5cdFx0fVxyXG5cdH0gLy8gXHRcdFx0XHRcdFx0XHRcdFx0XHRUT0RPOiB2YWxpZGF0ZSBhbGwgYXJndW1lbnRzXHJcbik7XHJcblxyXG5cclxudmFyIFR3b1BsYXllck5vcm1hbCA9IGdhbWVXcmFwcGVyKGZ1bmN0aW9uKHBsYXllcnMsIGNob2ljZXMsIHBheW9mZnMgPSBudWxsLCBwYXJhbWV0ZXJzID0ge30pIHtcclxuXHJcblx0Ly8gSW5mb3JtYXRpb24gbWVjaGFuaWNzLi4gVGhlcmUgYXJlIG9ubHkgdHdvIHBsYXllcnMsIHNvIHdlIGNhbiBoYXZlIGEgJ21lJyBhbmQgJ29wcG9uZW50JyBlbnRyeS5cclxuXHQvLyBJZiB1c2VyIHN1cHBsaWVkIGFuIGluZm9ybWF0aW9uIGZpbHRlciwgd3JhcCB0aGF0IGZpbHRlciBpbiBvdXJzLlxyXG5cdHZhciB7IGluZm9ybWF0aW9uRmlsdGVyIH0gPSBwYXJhbWV0ZXJzO1xyXG5cdGlmICghaXNGdW5jdGlvbihpbmZvcm1hdGlvbkZpbHRlcikpIGluZm9ybWF0aW9uRmlsdGVyID0gbnVsbDtcclxuXHJcblx0Ly8gV3JhcCB0aGUgdXNlcidzIGZpbHRlclxyXG5cdHZhciB3cmFwcGVkRmlsdGVyID0gZnVuY3Rpb24oaW5mb3JtYXRpb24pIHtcclxuXHRcdC8vIEZpZ3VyZSBvdXQgd2hvIEkgYW0gYW5kIHdobyB0aGUgb3Bwb25lbnQgaXNcclxuXHRcdHZhciBtZSA9IGluZm9ybWF0aW9uLm1lLmlkXHJcblx0XHR2YXIgcGxheWVycyA9IFtpbmZvcm1hdGlvbi50dXJuLmNob2ljZXNbMF0uY2hvaWNlLnBsYXllciwgaW5mb3JtYXRpb24udHVybi5jaG9pY2VzWzFdLmNob2ljZS5wbGF5ZXJdXHJcblx0XHR2YXIgb3Bwb25lbnQgPSBwbGF5ZXJzLnNwbGljZShwbGF5ZXJzLmluZGV4T2YobWUpLCAxKSAmJiBwbGF5ZXJzWzBdO1xyXG5cclxuXHRcdC8vIGFkZCBlbnRyeSBmb3Igb3Bwb25lbnRcclxuXHRcdHZhciBvcHBvbmVudERldGFpbCA9IGluZm9ybWF0aW9uLnBvcHVsYXRpb24uZmlsdGVyKGZ1bmN0aW9uKHBsYXllcikge1xyXG5cdFx0XHRyZXR1cm4gKHBsYXllci5pZCA9PSBvcHBvbmVudClcclxuXHRcdH0pWzBdO1xyXG5cdFx0aW5mb3JtYXRpb24ub3Bwb25lbnQgPSBvcHBvbmVudERldGFpbDtcclxuXHJcblx0XHQvLyBydW4gdGhlIHVzZXIncyBpbmZvcm1hdGlvbiBmaWx0ZXJcclxuXHRcdGlmIChpbmZvcm1hdGlvbkZpbHRlcikgaW5mb3JtYXRpb24gPSBpbmZvcm1hdGlvbkZpbHRlcihpbmZvcm1hdGlvbik7XHJcblxyXG5cdFx0cmV0dXJuIGluZm9ybWF0aW9uO1xyXG5cdH1cclxuXHJcblx0Ly8gUGFzcyB0aGUgaW5mb3JtYXRpb24gZmlsdGVyXHJcblx0cGFyYW1ldGVycy5pbmZvcm1hdGlvbkZpbHRlciA9IHdyYXBwZWRGaWx0ZXJcclxuXHJcblx0cmV0dXJuIE5vcm1hbChwbGF5ZXJzLCBjaG9pY2VzLCBwYXlvZmZzLCBwYXJhbWV0ZXJzKVxyXG59KTsgLy9cdFx0XHRcdCBcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFRPRE86IG1heSB3YW50IHRvIHZhbGlkYXRlIGFyZ3VtZW50cyBoZXJlIHRvb1xyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHsgVHdvUGxheWVyTm9ybWFsLCBOb3JtYWwgfTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBiYXNlIGdhbWVcclxudmFyIFR3b1BsYXllck5vcm1hbCA9IHJlcXVpcmUoXCIuL3NpbXBsZS1ub3JtYWxcIikuVHdvUGxheWVyTm9ybWFsO1xyXG5cclxuLy8gTmFzaEpTIGNvbXBvbmVudHNcclxudmFyIEVuZ2luZSA9IHJlcXVpcmUoXCIuLi9saWIvZW5naW5lXCIpXHJcblxyXG4vLyBHYW1lIHN0YXRlIGNvbnRyb2xsZXJcclxudmFyIHsgcmVnaXN0cnkgfSA9IEVuZ2luZS5CYWNrZW5kLlN0YXRlXHJcbnZhciB7IGdhbWVXcmFwcGVyIH0gPSBFbmdpbmUuQmFja2VuZC5IZWxwZXJGdW5jdGlvbnMoXCJzdG9jay1nYW1lc1wiKTtcclxuXHJcbi8vIFBsYXktdGltZSBsb2dpY1xyXG52YXIgeyBWYXJpYWJsZSwgRXhwcmVzc2lvbiB9ID0gRW5naW5lLkZyb250ZW5kO1xyXG5cclxuLyogYmVhdXRpZnkgcHJlc2VydmU6c3RhcnQgKi9cclxudmFyIFNpbXBsZVplcm9TdW0gPSBnYW1lV3JhcHBlcihmdW5jdGlvbihwbGF5ZXJzLCBjaG9pY2VzLCBwYXlvZmZzID0gW1swLCAwXSxcdFswLCAwXV0sIHBhcmFtZXRlcnM9e30pIHtcclxuLyogYmVhdXRpZnkgcHJlc2VydmU6ZW5kICovXHJcblxyXG5cdHZhciBnYW1lID0gVHdvUGxheWVyTm9ybWFsKHBsYXllcnMsIGNob2ljZXMsIG51bGwsIHBhcmFtZXRlcnMpXHJcblxyXG5cdHZhciBlO1xyXG5cclxuXHRjaG9pY2VzWzBdLmZvckVhY2goZnVuY3Rpb24oY2hvaWNlMCwgaW5kZXgwKSB7XHJcblx0XHRjaG9pY2VzWzFdLmZvckVhY2goZnVuY3Rpb24oY2hvaWNlMSwgaW5kZXgxKSB7XHJcblxyXG5cdFx0XHQvLyBTZXQgZXhwcmVzc2lvblxyXG5cdFx0XHRlID0gRXhwcmVzc2lvbihmdW5jdGlvbigpIHtcclxuXHRcdFx0XHQvL1JldHVybiB0aGUgbmVnYXRpdmUgcGF5b2ZmLCBvciB6ZXJvXHJcblx0XHRcdFx0cmV0dXJuICgwIC0gcmVnaXN0cnkudHVybnNbZ2FtZS5pZCgpXS5wYXlvZmZzSW1wbGljaXRbY2hvaWNlMF1bY2hvaWNlMV1bMF0gfHwgMCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly9TZXQgcGF5b2Zmc1xyXG5cdFx0XHRnYW1lW2Nob2ljZTBdW2Nob2ljZTFdKFtwYXlvZmZzW2luZGV4MF1baW5kZXgxXSwgZV0pO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblxyXG5cdHJldHVybiBnYW1lO1xyXG59KTsgLy9cdFx0XHRcdFx0VE9ETzogdmFsaWRhdGUgYXJndW1lbnRzXHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2ltcGxlWmVyb1N1bTtcclxuIl19
